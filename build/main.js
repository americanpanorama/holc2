(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/cartodb/basemaps.json":[function(require,module,exports){
module.exports={"name":"PanoramaBasemap","version":"0.0.1","layergroup":{"version":"1.3.0","layers":[{"type":"mapnik","options":{"sql":"SELECT cartodb_id, city, ST_Transform(ST_SetSRID(st_makepoint(looplng,looplat),4326), 3857) as the_geom_webmercator FROM holc_ads\n","cartocss":"#holc_ads::labels {\n  text-name: [city];\n  text-face-name: 'DejaVu Sans Book';\n  text-size: 10;\n  text-label-position-tolerance: 0;\n  text-fill: #0F3B82;\n  text-halo-fill: #FFF;\n  text-halo-radius: 1;\n  text-dy: -10;\n  text-allow-overlap: false;\n  text-placement: point;\n  text-placement-type: dummy;\n}","cartocss_version":"2.1.1"}}],"minzoom":2,"maxzoom":9}}

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/cartodb/config.json":[function(require,module,exports){
module.exports={
	"userId": "digitalscholarshiplab",
	"apiKey": ""
}

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/tileLayers.json":[function(require,module,exports){
module.exports={
	"layers": [
		{
			"urlNoLabels": "http://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png",
			"urlLabels": "http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
		}
	]
}

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/formsMetadata.json":[function(require,module,exports){
module.exports={
	"19370203": {
		"1": [
			"Name of City",
			"Security Grade",
			"Area No"
		],
		"2": "Description of Terrain",
		"3": "Favorable Influences",
		"4": "Detrimental Influences",
		"5": {
			"header": "Inhabitants",
			"subcats": {
				"a": "Type",
				"b": "Estimated annual family income",
				"c": "Foreign-born",
				"d": "Negro",
				"e": "Infiltration of",
				"f": "Relief families",
				"g": "Population is"
			}
		},
		"6": {
			"header": "Buildings",
			"subcats": {
				"a": "Type or Types",
				"b": "Type of Construction",
				"c": "Average age",
				"d": "Repair"
			}
		},
		"8": {
			"header": "Occupancy",
			"subcats": {
				"a": "Land",
				"b": "Dwelling units",
				"c": "Home Owners"
			}
		},
		"9": {
			"header": "Sales Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"10": {
			"header": "Rental Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"11": {
			"header": "New Construction",
			"subcats": {
				"a": "Types",
				"b": "Amount last year"
			}
		},
		"12": {
			"header": "Availability of Mortgage Funds",
			"subcats": {
				"a": "Home purchase",
				"b": "Home building"
			}
		},
		"13": "Trend of Desireability Next 10-15 Years",
		"14": "Clarifying Remarks",
		"15": "Information for this form was obtained from"
	},
	"19370826": {
		"1": [
			"Name of City",
			"Security Grade",
			"Area No"
		],
		"2": "Description of Terrain",
		"3": "Favorable Influences",
		"4": "Detrimental Influences",
		"5": {
			"header": "Inhabitants",
			"subcats": {
				"a": "Type",
				"b": "Estimated annual family income",
				"c": "Foreign-born",
				"d": "Negro",
				"e": "Infiltration of",
				"f": "Relief families",
				"g": "Population is"
			}
		},
		"6": {
			"header": "Buildings",
			"subcats": {
				"a": "Type or Types",
				"b": "Type of Construction",
				"c": "Average age",
				"d": "Repair"
			}
		},
		"8": {
			"header": "Occupancy",
			"subcats": {
				"a": "Land",
				"b": "Dwelling units",
				"c": "Home Owners"
			}
		},
		"9": {
			"header": "Sales Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"10": {
			"header": "Rental Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"11": {
			"header": "New Construction",
			"subcats": {
				"a": "Types",
				"b": "Amount last year"
			}
		},
		"12": {
			"header": "Availability of Mortgage Funds",
			"subcats": {
				"a": "Home purchase",
				"b": "Home building"
			}
		},
		"13": "Trend of Desireability Next 10-15 Years",
		"14": "Clarifying Remarks",
		"15": "Information for this form was obtained from"
	},
	"19371001": {
		"1": {
			"header": "Area Characteristics",
			"subcats": {
				"a": "Description of Terrain",
				"b": "Favorable Influences",
				"c": "Detrimental Influences",
				"d": "Percentage of land improved",
				"e": "Trend of desireability next 10-15 yrs."
			}
		},
		"2": {
			"header": "Inhabitants",
			"subcats": {
				"a": "Occupation",
				"b": "Estimated Annual Family Income",
				"c": "Foreign-born families",
				"d": "Negro",
				"e": "Infiltration of",
				"f": "Relief families",
				"g": "Population is"
			}
		},
		"4": {
			"header": "Availability of Mortgage Funds",
			"subcats": {
				"a": "Home purchase",
				"b": "Home building"
			}
		},
		"5": "Clarifying Remarks",
		"6": [
			"Name and Location",
			"Security Grade",
			"Area No."
		],
	}

}
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/panorama_nav.json":[function(require,module,exports){
module.exports=[
	{
		"title"         : "The Forced Migration of Enslaved People",
		"url"           : "http://dsl.richmond.edu/panorama/forcedmigration/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/forced-migration-img.png",
		"start_year"    : 1810,
		"end_year"      : 1860,
		"tags"          : []
	},
	{
		"title"         : "The Overland Trails",
		"url"           : "http://dsl.richmond.edu/panorama/overlandtrails/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/overland-img.png",
		"start_year"    : 1840,
		"end_year"      : 1860,
		"tags"          : []
	},
	{
		"title"         : "Foreign-Born Population",
		"url"           : "http://dsl.richmond.edu/panorama/foreignborn/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/foreign-born-img.png",
		"start_year"    : 1850,
		"end_year"      : 2010,
		"tags"          : []
	},
	{
		"title"         : "Canals",
		"url"           : "http://dsl.richmond.edu/panorama/canals/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/canal-img.png",
		"start_year"    : 1800,
		"end_year"      : 1860,
		"tags"          : []
	},
	{
		"title"         : "Mapping Inequality",
		"url"           : "http://dsl.richmond.edu/panorama/holc/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/holc-img.png",
		"start_year"    : 1800,
		"end_year"      : 1860,
		"tags"          : []
	}
]
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/state_abbr.json":[function(require,module,exports){
module.exports={
    "AL": "Alabama",
    "AK": "Alaska",
    "AS": "American Samoa",
    "AZ": "Arizona",
    "AR": "Arkansas",
    "CA": "California",
    "CO": "Colorado",
    "CT": "Connecticut",
    "DE": "Delaware",
    "DC": "District Of Columbia",
    "FM": "Federated States Of Micronesia",
    "FL": "Florida",
    "GA": "Georgia",
    "GU": "Guam",
    "HI": "Hawaii",
    "ID": "Idaho",
    "IL": "Illinois",
    "IN": "Indiana",
    "IA": "Iowa",
    "KS": "Kansas",
    "KY": "Kentucky",
    "LA": "Louisiana",
    "ME": "Maine",
    "MH": "Marshall Islands",
    "MD": "Maryland",
    "MA": "Massachusetts",
    "MI": "Michigan",
    "MN": "Minnesota",
    "MS": "Mississippi",
    "MO": "Missouri",
    "MT": "Montana",
    "NE": "Nebraska",
    "NV": "Nevada",
    "NH": "New Hampshire",
    "NJ": "New Jersey",
    "NM": "New Mexico",
    "NY": "New York",
    "NC": "North Carolina",
    "ND": "North Dakota",
    "MP": "Northern Mariana Islands",
    "OH": "Ohio",
    "OK": "Oklahoma",
    "OR": "Oregon",
    "PW": "Palau",
    "PA": "Pennsylvania",
    "PR": "Puerto Rico",
    "RI": "Rhode Island",
    "SC": "South Carolina",
    "SD": "South Dakota",
    "TN": "Tennessee",
    "TX": "Texas",
    "UT": "Utah",
    "VT": "Vermont",
    "VI": "Virgin Islands",
    "VA": "Virginia",
    "WA": "Washington",
    "WV": "West Virginia",
    "WI": "Wisconsin",
    "WY": "Wyoming"
}
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/@panorama/toolkit/dist/components.min.js":[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("react"),require("d3"),require("leaflet"),require("react-leaflet"),require("react-dom"),require("cartodb-client"),require("intro.js"),require("queue-async")):"function"==typeof define&&define.amd?define(["react","d3","leaflet","react-leaflet","react-dom","cartodb-client","intro.js","queue-async"],e):"object"==typeof exports?exports["@panorama/toolkit"]=e(require("react"),require("d3"),require("leaflet"),require("react-leaflet"),require("react-dom"),require("cartodb-client"),require("intro.js"),require("queue-async")):t["@panorama/toolkit"]=e(t.React,t.d3,t.leaflet,t["react-leaflet"],t["react-dom"],t["cartodb-client"],t["intro.js"],t["queue-async"])}(this,function(t,e,n,o,i,s,a,u){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}(function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e))switch(typeof t[e]){case"function":break;case"object":t[e]=function(e){var n=e.slice(1),r=t[e[0]];return function(t,e,o){r.apply(this,[t,e,o].concat(n))}}(t[e]);break;default:t[e]=t[t[e]]}return t}([function(t,e,n){"use strict";var r=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var o=n(45),i=r(o),s=n(72),a=r(s),u=n(73),l=r(u),c=n(74),p=r(c),f=n(46),h=r(f),d=n(81),y=r(d),v=n(75),m=r(v),g=n(76),x=r(g),b=n(78),k=r(b),_=n(79),P=r(_),T=n(80),O=r(T),w=n(84),M=r(w),E=n(85),C=r(E),S=n(87),j=r(S),A=n(89),L=r(A),I=n(90),R=r(I),D=n(31),N=n(92),F=r(N),H=n(97),U=r(H),q=n(93),W=r(q),B=n(83),z=r(B),K=n(95),G=r(K);e["default"]={AreaChart:i["default"],CartoDBLoader:a["default"],CartoDBTileLayer:l["default"],ChartSlider:p["default"],DiscreteBarChart:h["default"],Donut:y["default"],HashManager:m["default"],HorizontalDiscreteBarChart:x["default"],IntroManager:k["default"],ItemSelector:P["default"],LeafletChoropleth:O["default"],Legend:M["default"],LineChart:C["default"],MapChoropleth:j["default"],Navigation:L["default"],OffsetAreaChart:R["default"],PanoramaDispatcher:D.PanoramaDispatcher,PanoramaEventTypes:D.PanoramaEventTypes,Punchcard:F["default"],TimeBasedMarkers:U["default"],Tooltip:z["default"],ScatterPlot:W["default"],TexturalList:G["default"]},t.exports=e["default"]},function(t,e){"use strict";e["default"]=function(t){return t&&t.__esModule?t:{"default":t}},e.__esModule=!0},function(t,e){"use strict";e["default"]=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},e.__esModule=!0},function(t,e,n){"use strict";var r=n(102)["default"];e["default"]=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),r(t,o.key,o)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),e.__esModule=!0},function(t,e,n){"use strict";var r=n(103)["default"];e["default"]=function(t,e,n){for(var o=!0;o;){var i=t,s=e,a=n;o=!1,null===i&&(i=Function.prototype);var u=r(i,s);if(void 0!==u){if("value"in u)return u.value;var l=u.get;if(void 0===l)return;return l.call(a)}var c=Object.getPrototypeOf(i);if(null===c)return;t=c,e=s,n=a,o=!0,u=c=void 0}},e.__esModule=!0},function(t,e,n){"use strict";var r=n(101)["default"],o=n(105)["default"];e["default"]=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=r(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(o?o(t,e):t.__proto__=e)},e.__esModule=!0},function(e,n){e.exports=t},function(t,n){t.exports=e},function(t,e){var n=t.exports={version:"1.2.6"};"number"==typeof __e&&(__e=n)},function(t,e){var n=Object;t.exports={create:n.create,getProto:n.getPrototypeOf,isEnum:{}.propertyIsEnumerable,getDesc:n.getOwnPropertyDescriptor,setDesc:n.defineProperty,setDescs:n.defineProperties,getKeys:n.keys,getNames:n.getOwnPropertyNames,getSymbols:n.getOwnPropertySymbols,each:[].forEach}},function(t,e,n){var r=n(132)("wks"),o=n(138),i=n(12).Symbol;t.exports=function(t){return r[t]||(r[t]=i&&i[t]||(i||o)("Symbol."+t))}},function(t,e,n){"use strict";var r=n(23)["default"];e["default"]=r||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},e.__esModule=!0},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(t,e,n){"use strict";var r=n(3)["default"],o=n(2)["default"],i=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var s=n(7),a=i(s),u=n(98),l=i(u),c=function(){function t(e){o(this,t),this._props=e,this.root=null,this.mounted=!1,this.axes=[],this.tooltip=null,this.dispatch=a["default"].dispatch("mounted","updated","mouseOver","mouseOut","mouseMove","click")}return r(t,[{key:"willMount",value:function(){}},{key:"onMount",value:function(){var t=this;this.mounted||(this.addEvents(),this.root=a["default"].select(this.selector),this.svg=this.root.append("svg").classed("interactive",this.props.interactive),this.props.interactive&&this.props.tooltip&&this.svg.on("mousemove",this.dispatch.mouseMove),this.base=this.svg.append("g"),this.updateDimensions(),this.axes.forEach(function(e){return e.onMount(t.base)}),this.tooltipRef&&(this.tooltip=new l["default"](this.tooltipRef,this.props.tooltipOptions||{}),this.tooltip.relativeContainer=this.svg),this.mounted=!0,this.dispatch.mounted())}},{key:"onUpdate",value:function(){this.mounted&&(this.updateDimensions(),this._render(),this.dispatch.updated())}},{key:"onUnMount",value:function(){this.axes.forEach(function(t){return t.onUnMount()}),this.axes.length=0,this.removeEvents(),this.svg.on("move",null),this.svg.remove(),this.root=this.svg=null,this.mounted=!1,this.props=null}},{key:"addEvents",value:function(){this.dispatch.on("mounted",this.onMountedHandler.bind(this)),this.dispatch.on("updated",this.onUpdatedHandler.bind(this)),this.dispatch.on("mouseOver",this.onMouseOverHandler.bind(this)),this.dispatch.on("mouseOut",this.onMouseOutHandler.bind(this)),this.dispatch.on("click",this.onClickHandler.bind(this)),this.dispatch.on("mouseMove",this.onMouseMoveHandler.bind(this))}},{key:"removeEvents",value:function(){this.dispatch.on("mounted",null),this.dispatch.on("updated",null),this.dispatch.on("mouseOver",null),this.dispatch.on("mouseOut",null),this.dispatch.on("mouseMove",null),this.dispatch.on("click",null)}},{key:"onMountedHandler",value:function(){"function"==typeof this.props.onMountHandler&&this.props.onMountHandler()}},{key:"onUpdatedHandler",value:function(){"function"==typeof this.props.onUpdatedHandler&&this.props.onUpdatedHandler()}},{key:"onMouseOverHandler",value:function(t){this.tooltip&&this.tooltip.show(a["default"].event,t),"function"==typeof this.props.onMouseOverHandler&&this.props.onMouseOverHandler(t)}},{key:"onMouseOutHandler",value:function(t){this.tooltip&&this.tooltip.hide(),"function"==typeof this.props.onMouseOutHandler&&this.props.onMouseOutHandler(t)}},{key:"onMouseMoveHandler",value:function(){this.tooltip&&this.tooltip.setPosition(a["default"].event)}},{key:"onClickHandler",value:function(t){"function"==typeof this.props.onClickHandler&&this.props.onClickHandler(t)}},{key:"setAxis",value:function(t){"Axis"===t.toString()&&this.axes.push(t)}},{key:"updateAxis",value:function(t,e,n){this.axes[t].update(e,n)}},{key:"_render",value:function(){this.props.data&&(this.preRender(),this.axes.forEach(function(t){return t.render()}),this.render(),this.postRender())}},{key:"preRender",value:function(){}},{key:"render",value:function(){throw new Error("render function should be implemented")}},{key:"postRender",value:function(){}},{key:"updateDimensions",value:function(){var t=this,e=this.props,n=e.width,r=e.height,o=e.margin;(this.width!==n||this.height!==r)&&(this.width=n-o.left-o.right,this.height=r-o.top-o.bottom,this.svg.attr("width",n).attr("height",r),this.base.attr("transform","translate("+o.left+","+o.top+")"),this.axes.forEach(function(e){e.width=t.width,e.height=t.height}))}},{key:"selector",get:function(){return this._selector},set:function(t){this._selector=t}},{key:"props",get:function(){return this._props},set:function(t){this._props=t}},{key:"tooltipRef",set:function(t){this._tooltipRef=t},get:function(){return this._tooltipRef}}]),t}();e["default"]=c,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(32);n(163);var p=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,[{key:"componentWillMount",value:function(){if(!this.chartConstructor)throw new Error("Need to set chartConstructor");this.chart=new this.chartConstructor(this.props),this.chart.willMount()}},{key:"componentDidMount",value:function(){this.chart.selector=this.refs.chart,this.chart.tooltipRef=this.refs.tooltip,this.chart.props=this.props,this.chart.onMount()}},{key:"componentDidUpdate",value:function(){this.chart.props=this.props,this.chart.onUpdate()}},{key:"componentWillUnmount",value:function(){this.chart.onUnMount(),this.chart=null}},{key:"getClassName",value:function(){return this.props.className?" "+this.props.className:""}},{key:"render",value:function(){return l["default"].createElement("div",{className:"panorama"+this.getClassName()},l["default"].createElement("div",{ref:"chart",className:"panorama--chart-container"},this.props.tooltip&&l["default"].createElement("div",{ref:"tooltip",className:"panorama--tooltip"})))}}],[{key:"propTypes",value:c.DefaultTypes,enumerable:!0},{key:"defaultProps",value:c.DefaultProps,enumerable:!0}]),e}(u.Component);e["default"]=p,t.exports=e["default"]},function(t,e,n){var r=n(25);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,e){t.exports={}},function(t,e){function n(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}t.exports=n},function(t,e,n){"use strict";var r=n(3)["default"],o=n(2)["default"],i=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var s=n(7),a=i(s),u=n(32),l=function(){function t(e,n){o(this,t),this._options=e,this.axis=a["default"].svg.axis().scale(n),this.element=null}return r(t,[{key:"update",value:function(t,e){this.options=e,this.axis.scale(t),this.setAxisMethods()}},{key:"onMount",value:function(t){this.element=t.append("g").attr("class",this.options.className||""),this.setAxisMethods(),this.axisLabel()}},{key:"onUpdate",value:function(){}},{key:"onUnMount",value:function(){this.element&&this.element.remove(),this._options=null,this.element=null,this.axis=null}},{key:"render",value:function(){this.setPosition(),this.element.call(this.axis),this.renderTickExtras(),this.renderLabelExtras()}},{key:"renderTickExtras",value:function(){var t=this.element.selectAll("text");this.options.attr&&t.attr(this.options.attr),this.options.style&&t.style(this.options.style)}},{key:"renderLabelExtras",value:function(){if(this.label&&this.options.label){var t=this.options.label;t.attr&&this.label.attr(t.attr),t.style&&this.label.style(t.style)}}},{key:"setPosition",value:function(){var t=this.options.position;if(t)switch(t){case"bottom":this.element.attr("transform","translate(0,"+this.height+")");break;case"right":this.element.attr("transform","translate("+this.width+",0)")}}},{key:"setAxisMethods",value:function(){var t=this;u.axisMethods.forEach(function(e){t.options.hasOwnProperty(e)&&t.axis[e](t.options[e])})}},{key:"axisLabel",value:function(){this.options.label&&(this.label=this.element.append("text").text(this.options.label.text))}},{key:"toString",value:function(){return"Axis"}},{key:"options",get:function(){return this._options},set:function(t){this._options=t}},{key:"width",get:function(){return this._width},set:function(t){this._width=t}},{key:"height",get:function(){return this._height},set:function(t){this._height=t}}]),t}();e["default"]=l,t.exports=e["default"]},function(t,e,n){var r=n(34);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,o){return t.call(e,n,r,o)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){var r=n(12),o=n(8),i=n(19),s="prototype",a=function(t,e,n){var u,l,c,p=t&a.F,f=t&a.G,h=t&a.S,d=t&a.P,y=t&a.B,v=t&a.W,m=f?o:o[e]||(o[e]={}),g=f?r:h?r[e]:(r[e]||{})[s];f&&(n=e);for(u in n)l=!p&&g&&u in g,l&&u in m||(c=l?g[u]:n[u],m[u]=f&&"function"!=typeof g[u]?n[u]:y&&l?i(c,r):v&&g[u]==c?function(t){var e=function(e){return this instanceof t?new t(e):t(e)};return e[s]=t[s],e}(c):d&&"function"==typeof c?i(Function.call,c):c,d&&((m[s]||(m[s]={}))[u]=c))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,t.exports=a},function(t,e){t.exports=n},function(t,e){t.exports=o},function(t,e,n){t.exports={"default":n(110),__esModule:!0}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e,n){function r(t){return null!=t&&i(o(t))}var o=n(174),i=n(27);t.exports=r},function(t,e){function n(t){return"number"==typeof t&&t>-1&&t%1==0&&r>=t}var r=9007199254740991;t.exports=n},function(t,e){function n(t){return!!t&&"object"==typeof t}t.exports=n},function(t,e,n){var r=n(63),o=n(27),i=n(28),s="[object Array]",a=Object.prototype,u=a.toString,l=r(Array,"isArray"),c=l||function(t){return i(t)&&o(t.length)&&u.call(t)==s};t.exports=c},function(t,e){t.exports=i},function(t,e,n){"use strict";var r=n(23)["default"];Object.defineProperty(e,"__esModule",{value:!0});var o=n(70),i={Legend:{selected:"Legend:selected"},ItemSelector:{selected:"ItemSelector:selected"},ChartSlider:{selected:"ChartSlider:selected"}};e.PanoramaEventTypes=i;var s={Legend:{selected:function(t,e){s.emit(i.Legend.selected,t,e)}},ItemSelector:{selected:function(t,e){s.emit(i.ItemSelector.selected,t,e)}},ChartSlider:{selected:function(t){s.emit(i.ChartSlider.selected,t)}}};e.PanoramaDispatcher=s,r(s,o.EventEmitter.prototype)},function(t,e,n){"use strict";var r=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var o=n(6),i=n(7),s=r(i),a={width:o.PropTypes.number,height:o.PropTypes.number,margin:o.PropTypes.shape({top:o.PropTypes.number,right:o.PropTypes.number,bottom:o.PropTypes.number,left:o.PropTypes.number}),xAccessor:o.PropTypes.func,yAccessor:o.PropTypes.func,selectionAccessor:o.PropTypes.func,xScale:o.PropTypes.func,yScale:o.PropTypes.func,xaxis:o.PropTypes.object,yaxis:o.PropTypes.object,interactive:o.PropTypes.bool,tooltip:o.PropTypes.bool};e.DefaultTypes=a;var u={width:960,height:500,margin:{top:20,right:30,bottom:20,left:30},selectionAccessor:function(t){return t.key},xAccessor:function(t){return t.key},yAccessor:function(t){return t.value},xScale:s["default"].scale.linear(),yScale:s["default"].scale.linear(),interactive:!0,tooltip:!1};e.DefaultProps=u;var l=["orient","ticks","tickValues","tickSize","innerTickSize","outerTickSize","tickPadding","tickFormat"];e.axisMethods=l;var c={closeDelay:100,align:"top center",offset:[0,-10]};e.tooltipDefaultOptions=c},function(t,e){"use strict";e["default"]=function(t,e){var n={};for(var r in t)e.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n},e.__esModule=!0},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,e,n){var r=n(24),o=n(10)("toStringTag"),i="Arguments"==r(function(){return arguments}());t.exports=function(t){var e,n,s;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=(e=Object(t))[o])?n:i?r(e):"Object"==(s=r(e))&&"function"==typeof e.callee?"Arguments":s}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,e,n){t.exports=!n(38)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,e){t.exports=function(t){try{return!!t()}catch(e){return!0}}},function(t,e,n){var r=n(9),o=n(54);t.exports=n(37)?function(t,e,n){return r.setDesc(t,e,o(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(9).setDesc,o=n(49),i=n(10)("toStringTag");t.exports=function(t,e,n){t&&!o(t=n?t:t.prototype,i)&&r(t,i,{configurable:!0,value:e})}},function(t,e,n){"use strict";var r=n(135)(!0);n(51)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e,n){n(141);var r=n(16);r.NodeList=r.HTMLCollection=r.Array},function(t,e){function n(t,e){return t="number"==typeof t||r.test(t)?+t:-1,e=null==e?o:e,t>-1&&t%1==0&&e>t}var r=/^\d+$/,o=9007199254740991;t.exports=n},function(t,e,n){function r(t){return i(t)&&o(t)&&a.call(t,"callee")&&!u.call(t,"callee")}var o=n(26),i=n(28),s=Object.prototype,a=s.hasOwnProperty,u=s.propertyIsEnumerable;t.exports=r},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=u(l),p=n(6),f=n(14),h=u(f),d=n(71),y=u(d);n(148);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},h["default"].propTypes,{fillColor:p.PropTypes.oneOfType([p.PropTypes.string,p.PropTypes.number]),fillOpacity:p.PropTypes.number,interpolate:p.PropTypes.string}),enumerable:!0},{key:"defaultProps",value:a({},h["default"].defaultProps,{xScale:c["default"].scale.ordinal(),className:"area-chart",interpolate:"basis",xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(h["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=n(7),p=u(c),f=n(14),h=u(f),d=n(47),y=u(d);n(150);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},h["default"].propTypes,{barSpacing:l.PropTypes.number}),enumerable:!0},{key:"defaultProps",value:a({},h["default"].defaultProps,{barSpacing:.1,xScale:p["default"].scale.ordinal(),className:"bar-chart vertical",xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(h["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale))}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this._render()}},{key:"preRender",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale;o.rangeRoundBands([0,this.width],this.barSpacing),o.domain(e.map(function(t){return n(t)})),i.range([this.height,0]),i.domain([0,p["default"].max(e,function(t){return r(t)})]),this.updateAxis(0,o,this.props.xaxis),this.updateAxis(1,i,this.props.yaxis)}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=e.xAccessor,o=e.yAccessor,i=e.xScale,s=e.yScale,a=this.base.selectAll(".bar").data(n);a.exit().remove(),a.enter().append("rect").attr("class","bar"),a.attr("x",function(t){return i(r(t))}).attr("y",function(t){return s(o(t))}).attr("width",i.rangeBand()).attr("height",function(e){return t.height-s(o(e))})}},{key:"postRender",value:function(){var t=this.props,e=t.selected,n=t.selectionAccessor,r=t.interactive,o=this.base.selectAll(".bar");r&&o.on("click",this.dispatch.click).on("mouseover",this.dispatch.mouseOver).on("mouseout",this.dispatch.mouseOut),e&&o.classed("selected",function(t){return n(t)===e})}},{key:"barSpacing",get:function(){return this.props.barSpacing||.1}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e){"use strict";e["default"]=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e["default"]=t,e},e.__esModule=!0},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e,n){var r=n(24);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,e,n){"use strict";var r=n(52),o=n(20),i=n(55),s=n(39),a=n(49),u=n(16),l=n(124),c=n(40),p=n(9).getProto,f=n(10)("iterator"),h=!([].keys&&"next"in[].keys()),d="@@iterator",y="keys",v="values",m=function(){return this};t.exports=function(t,e,n,g,x,b,k){l(n,e,g);var _,P,T=function(t){if(!h&&t in E)return E[t];switch(t){case y:return function(){return new n(this,t)};case v:return function(){return new n(this,t)}}return function(){return new n(this,t)}},O=e+" Iterator",w=x==v,M=!1,E=t.prototype,C=E[f]||E[d]||x&&E[x],S=C||T(x);if(C){var j=p(S.call(new t));c(j,O,!0),!r&&a(E,d)&&s(j,f,m),w&&C.name!==v&&(M=!0,S=function(){return C.call(this)})}if(r&&!k||!h&&!M&&E[f]||s(E,f,S),u[e]=S,u[O]=m,x)if(_={values:w?S:T(v),keys:b?S:T(y),entries:w?T("entries"):S},k)for(P in _)P in E||i(E,P,_[P]);else o(o.P+o.F*(h||M),e,_);return _}},function(t,e){t.exports=!0},function(t,e,n){var r=n(20),o=n(8),i=n(38);t.exports=function(t,e){var n=(o.Object||{})[t]||Object[t],s={};s[t]=e(n),r(r.S+r.F*i(function(){n(1)}),"Object",s)}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e,n){t.exports=n(39)},function(t,e,n){var r=n(9).getDesc,o=n(25),i=n(15),s=function(t,e){if(i(t),!o(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,e,o){try{o=n(19)(Function.call,r(Object.prototype,"__proto__").set,2),o(t,[]),e=!(t instanceof Array)}catch(i){e=!0}return function(t,n){return s(t,n),e?t.__proto__=n:o(t,n),t}}({},!1):void 0),check:s}},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e,n){var r=n(50),o=n(36);t.exports=function(t){return r(o(t))}},function(t,e,n){var r=n(36);t.exports=function(t){return Object(r(t))}},function(t,e,n){var r=n(35),o=n(10)("iterator"),i=n(16);t.exports=n(8).getIteratorMethod=function(t){return void 0!=t?t[o]||t["@@iterator"]||i[r(t)]:void 0}},function(t,e){function n(t,e){if("function"!=typeof t)throw new TypeError(r);return e=o(void 0===e?t.length-1:+e||0,0),function(){for(var n=arguments,r=-1,i=o(n.length-e,0),s=Array(i);++r<i;)s[r]=n[e+r];switch(e){case 0:return t.call(this,s);case 1:return t.call(this,n[0],s);case 2:return t.call(this,n[0],n[1],s)}var a=Array(e+1);for(r=-1;++r<e;)a[r]=n[r];return a[e]=s,t.apply(this,a)}}var r="Expected a function",o=Math.max;t.exports=n},function(t,e,n){function r(t,e,n){if("function"!=typeof t)return o;if(void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 3:return function(n,r,o){return t.call(e,n,r,o)};case 4:return function(n,r,o,i){return t.call(e,n,r,o,i)};case 5:return function(n,r,o,i,s){return t.call(e,n,r,o,i,s)}}return function(){return t.apply(e,arguments)}}var o=n(182);t.exports=r},function(t,e,n){function r(t,e){var n=null==t?void 0:t[e];return o(n)?n:void 0}var o=n(180);t.exports=r},function(t,e,n){function r(t){return o(t)?t:Object(t)}var o=n(17);t.exports=r},function(t,e,n){var r=n(165),o=n(166),i=n(172),s=i(function(t,e,n){return n?r(t,e,n):o(t,e)});t.exports=s},function(t,e,n){var r=n(63),o=n(26),i=n(17),s=n(178),a=r(Object,"keys"),u=a?function(t){var e=null==t?void 0:t.constructor;return"function"==typeof e&&e.prototype===t||"function"!=typeof t&&o(t)?s(t):i(t)?a(t):[]}:s;t.exports=u},function(t,e,n){function r(t){if(null==t)return[];u(t)||(t=Object(t));var e=t.length;e=e&&a(e)&&(i(t)||o(t))&&e||0;for(var n=t.constructor,r=-1,l="function"==typeof n&&n.prototype===t,p=Array(e),f=e>0;++r<e;)p[r]=r+"";for(var h in t)f&&s(h,e)||"constructor"==h&&(l||!c.call(t,h))||p.push(h);return p}var o=n(44),i=n(29),s=n(43),a=n(27),u=n(17),l=Object.prototype,c=l.hasOwnProperty;t.exports=r},function(t,e){function n(t,e){var n=t.nodeName.toLowerCase();return(/input|select|textarea|button|object/.test(n)?!t.disabled:"a"===n?t.href||e:e)&&o(t)}function r(t){return t.offsetWidth<=0&&t.offsetHeight<=0||"none"===t.style.display}function o(t){for(;t&&t!==document.body;){if(r(t))return!1;t=t.parentNode}return!0}function i(t){var e=t.getAttribute("tabindex");null===e&&(e=void 0);var r=isNaN(e);return(r||e>=0)&&n(t,!r)}function s(t){return[].slice.call(t.querySelectorAll("*"),0).filter(function(t){return i(t)})}t.exports=s},function(t,e,n){function r(t){return function(e){return null==e?void 0:e[t]}}function o(t){return null!=t&&s(g(t))}function i(t,e){return t="number"==typeof t||h.test(t)?+t:-1,e=null==e?m:e,t>-1&&t%1==0&&e>t}function s(t){return"number"==typeof t&&t>-1&&t%1==0&&m>=t}function a(t){for(var e=l(t),n=e.length,r=n&&t.length,o=!!r&&s(r)&&(f(t)||p(t)),a=-1,u=[];++a<n;){var c=e[a];(o&&i(c,r)||y.call(t,c))&&u.push(c)}return u}function u(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function l(t){if(null==t)return[];u(t)||(t=Object(t));var e=t.length;e=e&&s(e)&&(f(t)||p(t))&&e||0;for(var n=t.constructor,r=-1,o="function"==typeof n&&n.prototype===t,a=Array(e),l=e>0;++r<e;)a[r]=r+"";for(var c in t)l&&i(c,e)||"constructor"==c&&(o||!y.call(t,c))||a.push(c);return a}var c=n(198),p=n(199),f=n(200),h=/^\d+$/,d=Object.prototype,y=d.hasOwnProperty,v=c(Object,"keys"),m=9007199254740991,g=r("length"),x=v?function(t){var e=null==t?void 0:t.constructor;return"function"==typeof e&&e.prototype===t||"function"!=typeof t&&o(t)?a(t):u(t)?v(t):[]}:a;t.exports=x},function(t,e){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function r(t){return"function"==typeof t}function o(t){return"number"==typeof t}function i(t){return"object"==typeof t&&null!==t}function s(t){return void 0===t}t.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(t){if(!o(t)||0>t||isNaN(t))throw TypeError("n must be a positive number");return this._maxListeners=t,this},n.prototype.emit=function(t){var e,n,o,a,u,l;if(this._events||(this._events={}),"error"===t&&(!this._events.error||i(this._events.error)&&!this._events.error.length)){if(e=arguments[1],e instanceof Error)throw e;throw TypeError('Uncaught, unspecified "error" event.')}if(n=this._events[t],s(n))return!1;if(r(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),n.apply(this,a)}else if(i(n))for(a=Array.prototype.slice.call(arguments,1),l=n.slice(),o=l.length,u=0;o>u;u++)l[u].apply(this,a);return!0},n.prototype.addListener=function(t,e){var o;if(!r(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",t,r(e.listener)?e.listener:e),this._events[t]?i(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,i(this._events[t])&&!this._events[t].warned&&(o=s(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,o&&o>0&&this._events[t].length>o&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),"function"==typeof console.trace&&console.trace())),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(t,e){function n(){this.removeListener(t,n),o||(o=!0,e.apply(this,arguments))}if(!r(e))throw TypeError("listener must be a function");var o=!1;return n.listener=e,this.on(t,n),this},n.prototype.removeListener=function(t,e){var n,o,s,a;if(!r(e))throw TypeError("listener must be a function");if(!this._events||!this._events[t])return this;if(n=this._events[t],s=n.length,o=-1,n===e||r(n.listener)&&n.listener===e)delete this._events[t],this._events.removeListener&&this.emit("removeListener",t,e);else if(i(n)){for(a=s;a-- >0;)if(n[a]===e||n[a].listener&&n[a].listener===e){o=a;break}if(0>o)return this;1===n.length?(n.length=0,delete this._events[t]):n.splice(o,1),this._events.removeListener&&this.emit("removeListener",t,e)}return this},n.prototype.removeAllListeners=function(t){var e,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(n=this._events[t],r(n))this.removeListener(t,n);else if(n)for(;n.length;)this.removeListener(t,n[n.length-1]);return delete this._events[t],this},n.prototype.listeners=function(t){var e;return e=this._events&&this._events[t]?r(this._events[t])?[this._events[t]]:this._events[t].slice():[]},n.prototype.listenerCount=function(t){if(this._events){var e=this._events[t];if(r(e))return 1;if(e)return e.length}return 0},n.listenerCount=function(t,e){return t.listenerCount(e)}},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){var t=this.props,e=t.xAccessor,n=t.yAccessor,r=t.xScale,o=t.yScale,i=t.interpolate;this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale)),this.points=[],this.areaGenerator=p["default"].svg.area().interpolate(i).x(function(t){return r(e(t))}).y0(function(t){return o(0)}).y1(function(t){return o(n(t))})}},{key:"onMount",value:function(){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this),this.baseLayer=this.base.append("g").classed("area-layer",!0),this._render()}},{key:"getClosestDataIndex",value:function(t){if(!this.points.length)return null;var e=this.props;e.data,e.xAccessor;return this.points.forEach(function(e){e.d=Math.abs(e.x-t)}),this.points.sort(function(t,e){return p["default"].ascending(t.d,e.d)}),this.points[0].i}},{key:"onMouseMoveHandler",value:function(){if(this.hover&&this.tooltip){var t=p["default"].mouse(this.baseLayer.node()),e=(this.props.xScale.invert(t[0]),this.getClosestDataIndex(t[0]));this.tooltip.setPosition(p["default"].event),null!==e&&this.tooltip.setContent(this.props.data[0][e])}}},{key:"preRender",value:function(){var t=this,e=this.props,n=e.data,r=e.xScale,o=e.yScale,i=e.interpolate,s=e.xAccessor,a=e.yAccessor;r.range([0,this.width]),o.range([this.height,0]),
this.updateAxis(0,r,this.props.xaxis),this.updateAxis(1,o,this.props.yaxis),this.areaGenerator.interpolate(i).x(function(t){return r(s(t))}).y0(function(t){return o(0)}).y1(function(t){return o(a(t))}),this.points=[],n.length&&n[0].forEach(function(e,n){var o=r(s(e));t.points.push({x:o,i:n})})}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=(e.xAccessor,e.yAccessor,e.xScale,e.yScale,e.fillColor),o=e.fillOpacity,i=this.baseLayer.selectAll("path.area").data(n);i.exit().remove(),i.enter().append("path").attr("class","area"),i.attr("d",function(e){return t.areaGenerator(e)}).style("fill",r).style("opacity",o)}},{key:"postRender",value:function(){this.props.interactive&&this.baseLayer.selectAll("path.area").on("mouseover",this.onOver.bind(this)).on("mouseout",this.onOut.bind(this))}},{key:"onOver",value:function(){this.hover=!0,this.tooltip&&this.tooltip.show()}},{key:"onOut",value:function(){this.hover=!1,this.tooltip&&this.tooltip.hide()}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";function r(t,e){function n(t){return new o(function(e,n){var o=(0,a["default"])(3);t.forEach(function(t){o.defer(r,t)}),o.awaitAll(function(t){for(var r=arguments.length,o=Array(r>1?r-1:0),i=1;r>i;i++)o[i-1]=arguments[i];t?n(t):e.apply(void 0,o)})})}function r(t,n){i.sqlRequest(t.query,function(e,r){if(e)n(e);else{var o=void 0;switch(t.format.toLowerCase()){case"geojson":o=r.features;break;default:o=r.rows}n(null,o)}},{format:t.format,dangerouslyExposedAPIKey:e})}var i=new l["default"](t);return{query:n}}var o=n(106)["default"],i=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=r;var s=n(203),a=i(s),u=n(201),l=i(u);t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"];Object.defineProperty(e,"__esModule",{value:!0});var a=n(6),u=n(21),l=n(22),c=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"componentWillMount",value:function(){if(r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this),!cartodb)throw new Error('CartoDBTileLayer requires `cartodb`. `cartodb` is not currently available as an npm package and therefore must be loaded as a global, e.g. via a CDN script in your index.html, such as <script src="http://libs.cartocdn.com/cartodb.js/v3/3.15/cartodb.core.js">');this.leafletElement=(0,u.tileLayer)("",this.props),this._getCartoDBTilesTemplates(function(t,e){t?console.error(t):this.leafletElement.setUrl(e.tiles[0])}.bind(this))}},{key:"_getCartoDBTilesTemplates",value:function(t){cartodb.Tiles.getTiles({type:"cartodb",user_name:this.props.userId,sublayers:[{sql:this.props.sql,cartocss:this.props.cartocss}]},function(e,n){!e||n?(n||(n="Empty response."),t(n,e)):t(null,e)})}}],[{key:"propTypes",value:{userId:a.PropTypes.string,sql:a.PropTypes.string,cartocss:a.PropTypes.string},enumerable:!0}]),e}(l.BaseTileLayer);e["default"]=c,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(30),p=a(c),f=n(7),h=a(f);n(149);var d=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{width:u.PropTypes.number,height:u.PropTypes.number,scale:u.PropTypes.func,orient:u.PropTypes.string,margin:u.PropTypes.shape({top:u.PropTypes.number,right:u.PropTypes.number,bottom:u.PropTypes.number,left:u.PropTypes.number}),children:l["default"].PropTypes.node,selectedValue:u.PropTypes.number,onClickOrMove:u.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{scale:h["default"].scale.linear().clamp(!0),orient:"bottom",margin:{top:20,right:30,bottom:20,left:30},onClickOrMove:null},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){y.create(this.refs.axis,this.props.scale,this.props.orient,this.props.margin,this.props.onClickOrMove);try{this.containerNode=p["default"].findDOMNode(this)}catch(t){}this.forceUpdate()}},{key:"componentDidUpdate",value:function(){y.update(this.refs.axis,this.props.scale,this.props.orient,this.props.margin,this.props.selectedValue,this.props.onClickOrMove);try{this.containerNode=p["default"].findDOMNode(this)}catch(t){}}},{key:"componentWillUnmount",value:function(){y.destroy(this.refs.axis)}},{key:"render",value:function(){var t=u.Children.count(this.props.children);return t>1&&console.warn("ChartSlider is designed to wrap only one child component, but it found "+t+" children."),l["default"].createElement("div",{className:"panorama chart-slider"},l["default"].cloneElement(this.props.children,{width:this.containerNode?this.containerNode.offsetWidth:this.props.width,height:this.props.height}),l["default"].createElement("div",{className:"top-rule",style:{marginLeft:this.props.margin.left+"px",marginRight:this.props.margin.right+"px",width:"calc(100% - "+(this.props.margin.left+this.props.margin.right)+"px)"}}),l["default"].createElement("div",{className:"d3-chart-slider",ref:"axis"}))}}]),e}(l["default"].Component);e["default"]=d;var y={create:function(t,e,n,r,o){this.onBrushMoved=this.onBrushMoved.bind(this),this.node=t;var i=13;this.axisPrimary=h["default"].svg.axis().orient(n).ticks(5).tickFormat(String).tickSize(i),this.axisSecondary=h["default"].svg.axis().orient(n).ticks(10).tickFormat(function(t){return""}).tickSize(i-3),this.axisTertiary=h["default"].svg.axis().orient(n).ticks(40).tickFormat(function(t){return""}).tickSize(i-6),this.brush=h["default"].svg.brush().on("brush",this.onBrushMoved);var s=h["default"].select(t).append("svg");s.append("g").attr("class","axis tertiary"),s.append("g").attr("class","axis secondary"),s.append("g").attr("class","axis primary"),this.handle=s.append("g").attr("class","handle");var a=t.offsetHeight-r.bottom+i+3,u=this.handle.append("g").attr("class","handle-elements");u.append("line").attr({x1:0,x2:0,y1:0,y2:a});var l=10;u.append("path").attr("d","M 30 0 L 70 0 C 85 0 93.29179606750063 13.416407864998739 86.58359213500125 26.832815729997478 L 63.41640786499873 73.16718427000252 C 56.708203932499366 86.58359213500125 43.29179606750063 86.58359213500125 36.58359213500126 73.16718427000252 L 13.416407864998739 26.832815729997478 C 6.708203932499369 13.416407864998739 15 0 30 0 Z ").attr("transform","scale("+l/100+") translate(-50, 0)"),u.append("path").attr("d","M 30 0 L 70 0 C 85 0 93.29179606750063 13.416407864998739 86.58359213500125 26.832815729997478 L 63.41640786499873 73.16718427000252 C 56.708203932499366 86.58359213500125 43.29179606750063 86.58359213500125 36.58359213500126 73.16718427000252 L 13.416407864998739 26.832815729997478 C 6.708203932499369 13.416407864998739 15 0 30 0 Z ").attr("transform","rotate(180) scale("+l/100+") translate(-50, "+-(100/l*a)+")"),this.update(t,e,n,r)},update:function(t,e,n,r,o,i){this.node=t,this.onClickOrMove=i,e.range([0,t.offsetWidth-r.left-r.right]),this.axisPrimary.scale(e),this.axisSecondary.scale(e),this.axisTertiary.scale(e),this.brush.x(e);var s="translate("+r.left+", "+(t.offsetHeight-r.bottom)+")",a=h["default"].select(t).select("svg");a.attr("width","100%").attr("height","100%"),a.select(".axis.primary").call(this.axisPrimary).attr("transform",s).selectAll("text").attr("y",Math.floor(2/3*r.bottom)),a.select(".axis.secondary").call(this.axisSecondary).attr("transform",s),a.select(".axis.tertiary").call(this.axisTertiary).attr("transform",s),this.handle.call(this.brush).attr("transform","translate("+r.left+", 0)").select(".background").on("mousedown.brush",this.onBrushMoved).on("touchstart.brush",this.onBrushMoved),this.handle.selectAll(".background").attr("height","100%"),"undefined"!=typeof o&&this.onSelectedValueChanged(o)},destroy:function(t){h["default"].select(t).html(""),this.node=null,this.axisPrimary=null,this.axisSecondary=null,this.axisTertiary=null,this.brush=null,this.handle=null},onBrushMoved:function(){var t=this.brush.x(),e=t.domain(),n=h["default"].mouse(h["default"].select(this.node).select(".axis")[0][0])[0],r=t.invert(n);r=Math.round(Math.max(e[0],Math.min(e[1],r))),this.onClickOrMove&&this.onClickOrMove(r)},onSelectedValueChanged:function(t){this.handle.call(this.brush.extent([t,t+2]));var e=this.brush.x()(t);this.handle.select(".handle-elements").attr("transform","translate("+e+", 0)")}};t.exports=e["default"]},function(t,e,n){"use strict";var r=n(23)["default"],o=n(104)["default"];Object.defineProperty(e,"__esModule",{value:!0});var i=n(70),s=function(){function t(t){var e=r({},h,t);for(var n in e)null==e[n]?delete e[n]:n===p&&(e[n]=l(e[p]));var i="#"+o(e).map(function(t){return t+"="+e[t]}).join("&");document.location.hash!==i&&document.location.replace(i)}function e(){var t=arguments.length<=0||void 0===arguments[0]?null:arguments[0];return t?h[t]:r({},h)}function n(t,e){h=t,e||f.emit(c,r({},h))}function s(){n(a(window.location.hash))}function a(t){var e=t.replace(/^#\/?|\/$/g,"").split("&").reduce(function(t,e){return e=e.split("="),e[0]===p&&(e[1]=u(e[1])),t[e[0]]=e[1],t},{});return e}function u(t){if(t=t.split("/"),3==t.length){var e=parseInt(t[0],10),n=parseFloat(t[1]),r=parseFloat(t[2]);return isNaN(e)||isNaN(n)||isNaN(r)?!1:{center:[n,r],zoom:e}}return!1}function l(t){var e=void 0,n=void 0,r=t.zoom,o=Math.max(0,Math.ceil(Math.log(r)/Math.LN2));return Array.isArray(t.center)?(e=t.center[0],n=t.center[1]):(e=t.center.lat,n=t.center.lng),[r,e.toFixed(o),n.toFixed(o)].join("/")}var c="hashChanged",p="loc",f={},h={};return r(f,i.EventEmitter.prototype),window.addEventListener("hashchange",s),n(a(window.location.hash),!0),f.EVENT_HASH_CHANGED=c,f.MAP_STATE_KEY=p,f.updateHash=t,f.getState=e,f}();e["default"]=s,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=u(l),p=n(46),f=u(p),h=n(77),d=u(h),y=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=d["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{xScale:c["default"].scale.linear(),yScale:c["default"].scale.ordinal()}),enumerable:!0}]),e}(f["default"]);e["default"]=y,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(7),l=a(u),c=n(47),p=a(c),f=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"preRender",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale;i.rangeRoundBands([0,this.height],this.barSpacing),i.domain(e.map(function(t){return r(t)})),o.range([0,this.width]),o.domain([0,l["default"].max(e,function(t){return n(t)})]),this.updateAxis(0,o,this.props.xaxis),this.updateAxis(1,i,this.props.yaxis)}},{key:"render",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale,s=this.base.selectAll(".bar").data(e);s.exit().remove(),s.enter().append("rect").attr("class","bar"),s.attr("x","0").attr("y",function(t){return i(r(t))}).attr("width",function(t){return o(n(t))}).attr("height",i.rangeBand())}}]),e}(p["default"]);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(23)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(202),c=n(6),p=u(c);n(151);var f=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.onIntroExit=this.onIntroExit.bind(this),this.initIntro()}return o(e,t),i(e,null,[{key:"propTypes",value:{open:c.PropTypes.bool,step:c.PropTypes.oneOfType([c.PropTypes.number,c.PropTypes.string]),steps:c.PropTypes.arrayOf(c.PropTypes.shape({element:c.PropTypes.string,intro:c.PropTypes.string,position:function(t,e,n){return/top|right|bottom|left/.test(t[e])?void 0:new Error("`position` must be one of 'top', 'right', 'bottom', or 'left'.")}})).isRequired,config:c.PropTypes.object,onExit:c.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{open:!1,step:0,steps:[],config:{showStepNumbers:!1,skipLabel:"×",nextLabel:"⟩",prevLabel:"⟨",doneLabel:"×"},onExit:null},enumerable:!0}]),i(e,[{key:"initIntro",value:function(){this.intro=(0,l.introJs)(document.querySelector("body")),this.intro.onexit(this.onIntroExit),this.intro.oncomplete(this.onIntroExit),this.introIsOpen=!1}},{key:"onIntroExit",value:function(){this.introIsOpen=!1,this.props.onExit&&this.props.onExit()}},{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){if(this.props.open){if(this.introIsOpen)return;if(this.intro._introItems)this.props.step&&1!==this.props.step?this.intro.goToStep(this.props.step-1).start():this.intro.start();else{var t={steps:this.props.steps};t=a(t,this.props.config),this.intro.setOptions(t),this.intro.goToStep(this.props.step).start()}this.introIsOpen=!0}else this.intro.exit()}},{key:"getDefaultState",value:function(){return{}}},{key:"render",value:function(){return p["default"].createElement("div",{className:"panorama intro-manager"})}}]),e}(p["default"].Component);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(31);n(152);var p=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.onItemClick=this.onItemClick.bind(this),this.onArrowMouseDown=this.onArrowMouseDown.bind(this),this.onArrowMouseUp=this.onArrowMouseUp.bind(this),this.animateScrollPosition=this.animateScrollPosition.bind(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{title:u.PropTypes.string,items:u.PropTypes.array.isRequired,selectedIndex:u.PropTypes.oneOfType([u.PropTypes.string,u.PropTypes.number]),selectedItem:u.PropTypes.object,onItemSelected:u.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{title:"",items:[],selectedIndex:"",selectedItem:null,onItemSelected:null},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){this.scrollToSelectedItem()}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){this.scrollToSelectedItem()}},{key:"onItemClick",value:function(t){t.currentTarget&&t.currentTarget.dataset&&(this.props.onItemSelected&&this.props.onItemSelected(this.props.items[t.currentTarget.dataset.index],t.currentTarget.dataset.index),c.PanoramaDispatcher.ItemSelector.selected(this.props.items[t.currentTarget.dataset.index],t.currentTarget.dataset.index))}},{key:"onArrowMouseDown",value:function(t){var e=void 0;if(t.target.classList.contains("up-arrow")?e=-1:t.target.classList.contains("down-arrow")&&(e=1),e){var n=this.refs["item-list"],r=16,o=0,i=n.querySelector("li"),s=window.getComputedStyle(i),a=i.offsetHeight+(s?parseFloat(s["margin-bottom"].replace("px","")):0);this.arrowMouseUp=!1;var u=function(){o--<=1&&(this.scrollToPosition(n.scrollTop+e*a),o=r=Math.max(1,Math.floor(.75*r))),this.arrowMouseUp||window.requestAnimationFrame(u)}.bind(this);window.requestAnimationFrame(u)}}},{key:"onArrowMouseUp",value:function(t){this.arrowMouseUp=!0}},{key:"scrollToPosition",value:function(t){"undefined"==typeof this.targetScrollPosition?(this.targetScrollPosition=t,this.animateScrollPosition()):this.targetScrollPosition=t}},{key:"scrollToSelectedItem",value:function(){var t=this.refs["item-list"],e=t.querySelector(".selected");e&&this.scrollToPosition(e.offsetTop-t.offsetHeight)}},{key:"animateScrollPosition",value:function(){var t=this.refs["item-list"],e=void 0;"undefined"==typeof this.scrollPosition&&(this.scrollPosition=t.scrollTop),e=this.targetScrollPosition-this.scrollPosition,Math.abs(e)>1?(this.scrollPosition+=.25*e,t.scrollTop=this.scrollPosition,window.requestAnimationFrame(this.animateScrollPosition)):(t.scrollTop=this.targetScrollPosition,this.targetScrollPosition=void 0,this.scrollPosition=void 0)}},{key:"getDefaultState",value:function(){return{}}},{key:"render",value:function(){var t=this,e=void 0;return l["default"].createElement("div",{className:"panorama item-selector"},l["default"].createElement("h3",null,this.props.title),l["default"].createElement("div",{className:"scroll-arrow up-arrow",onMouseDown:this.onArrowMouseDown,onMouseUp:this.onArrowMouseUp}),l["default"].createElement("ul",{ref:"item-list"},this.props.items.map(function(n,r){return e=t.props.selectedItem.id==n.id||t.props.selectedItem===n||t.props.selectedIndex===r,l["default"].createElement("li",{className:"item"+(e?" selected":"")+(n.className?" "+n.className:""),"data-index":r,key:r,onClick:t.onItemClick},l["default"].createElement("span",null,n.name))})),l["default"].createElement("div",{className:"scroll-arrow down-arrow",onMouseDown:this.onArrowMouseDown,onMouseUp:this.onArrowMouseUp}))}}]),e}(l["default"].Component);e["default"]=p,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(33)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=(u(l),n(22)),p=n(21),f=n(181),h=u(f),d=n(17),y=(u(d),n(29)),v=(u(y),n(65)),m=(u(v),["stroke","color","weight","opacity","fill","fillColor","fillOpacity","fillRule","dashArray","lineCap","lineJoin","clickable","pointerEvents","className"]);n(153);var g=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this),this.mouseTimer=null,this.currentId=null,this.hasTooltip=!1,this.state={showTooltip:!1,tooltipPosition:null,tooltipContent:""}}return o(e,t),i(e,null,[{key:"PropTypes",value:{styler:l.PropTypes.func,onEachFeature:l.PropTypes.func,setTooltipContent:l.PropTypes.func,selectedStyle:l.PropTypes.object,onFeatureClick:l.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{selectedStyle:{}},enumerable:!0}]),i(e,[{key:"shouldComponentUpdate",value:function(t){return!0}},{key:"componentWillMount",value:function(){r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this);var t=this.props.data,n=this.setGeoJSONOptions();this.setTooltipFlag(),this.leafletElement=(0,p.geoJson)(t,n)}},{key:"componentDidMount",value:function(){var t=this.props.map;this.leafletElement.addTo(t),this.hasTooltip&&t.on("mousemove",this.onMouseMove.bind(this))}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(t){var e=this.props.data;t.data!==e&&this.leafletElement.addData(e)}},{key:"setGeoJSONOptions",value:function(){var t=a(this.props,[]);return{style:t.style||null,onEachFeature:t.onEachFeature||this.onEachFeature.bind(this),filter:t.filter||null,pointToLayer:t.pointToLayer||null,coordsToLatLng:t.coordsToLatLng||null}}},{key:"setTooltipFlag",value:function(){var t=this,e=this.props.children;l.Children.forEach(e,function(e){e.type&&e.type.name&&"Tooltip"===e.type.name&&(t.hasTooltip=!0)})}},{key:"getPathOptions",value:function(t){return(0,h["default"])(t,m)}},{key:"getTooltipContent",value:function(t){return"function"==typeof this.props.setTooltipContent?this.props.setTooltipContent(t):""}},{key:"onMouseOver",value:function(t){if(this.currentId!==t.target){if(t.target.setStyle(this.props.selectedStyle),this.currentId!==t.target){this.currentId=t.target;var e=this.getTooltipContent(t.target.feature);this.setState({showTooltip:!0,tooltipPosition:t.latlng,tooltipContent:e})}L.Browser.ie||L.Browser.opera||t.target.bringToFront()}}},{key:"onMouseOut",value:function(t){var e=this;this.leafletElement.resetStyle(t.target),this.currentId=null,clearTimeout(this.mouseTimer),this.mouseTimer=setTimeout(function(){null===e.currentId&&(e.currentId=null,e.setState({showTooltip:!1}))},200)}},{key:"onMouseMove",value:function(t){this.currentId&&(p.DomEvent.stopPropagation(t),this.setState({tooltipPosition:t.latlng}))}},{key:"onClick",value:function(t){"function"==typeof this.props.onFeatureClick&&this.props.onFeatureClick(t.target,this.props.map)}},{key:"onEachFeature",value:function(t,e){this.hasTooltip&&e.on({mouseover:this.onMouseOver.bind(this),mouseout:this.onMouseOut.bind(this)}),e.on("click",this.onClick.bind(this))}},{key:"render",value:function(){return this.renderChildrenWithProps({tooltipContainer:this.leafletElement,popupContainer:this.leafletElement,position:this.state.tooltipPosition,isOpen:this.state.showTooltip,content:this.state.tooltipContent})}}]),e}(c.MapLayer);e["default"]=g,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(33)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=(u(l),n(22)),p=(n(21),n(82)),f=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{center:c.PropTypes.latlng.isRequired,outerRadius:l.PropTypes.number.isRequired,innerRadius:l.PropTypes.number.isRequired},enumerable:!0},{key:"defaultProps",value:{},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){var t=this.props,n=t.center,o=t.outerRadius,i=t.innerRadius,s=a(t,["center","outerRadius","innerRadius"]);r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this),this.leafletElement=new p.LeafletDonut(n,o,i,this.getPathOptions(s))}},{key:"componentDidUpdate",value:function(t){this.props.center!==t.center&&this.leafletElement.setLatLng(this.props.center),(this.props.outerRadius!==t.outerRadius||this.props.innerRadius!==t.innerRadius)&&this.leafletElement.setRadius(this.props.outerRadius,this.props.innerRadius),this.setStyleIfChanged(t,this.props)}}]),e}(c.Path);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var o=n(48)["default"];Object.defineProperty(e,"__esModule",{value:!0});var i=n(21),s=o(i),a=function(t){return t.Circle.extend({initialize:function(e,n,r,o){t.Path.prototype.initialize.call(this,o),this._latlng=t.latLng(e),this._mOuterRadius=n,this._mInnerRadius=this._validateInnerRadius(n,r)},setRadius:function(t,e){return this._mOuterRadius=t,this._mInnerRadius=this._validateInnerRadius(t,e),this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,n=this._map.latLngToLayerPoint([e.lat,e.lng-t[0]]),r=this._map.latLngToLayerPoint([e.lat,e.lng-t[1]]);this._point=this._map.latLngToLayerPoint(e),this._outerRadius=Math.max(this._point.x-n.x,1),this._innerRadius=Math.max(this._point.x-r.x,1)},getBounds:function(){var e=this._getLngRadius()[0],n=this._getLatRadius()[0],r=this._latlng;return new t.LatLngBounds([r.lat-n,r.lng-e],[r.lat+n,r.lng+e])},getRadius:function(){return[this._mOuterRadius,this._mInnerRadius]},_getLatRadius:function(){return[this._mOuterRadius/40075017*360,this._mInnerRadius/40075017*360]},_getLngRadius:function(){var e=this._getLatRadius();return[e[0]/Math.cos(t.LatLng.DEG_TO_RAD*this._latlng.lat),e[1]/Math.cos(t.LatLng.DEG_TO_RAD*this._latlng.lat)]},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._outerRadius,n=this._point;return n.x-e>t.max.x||n.y-e>t.max.y||n.x+e<t.min.x||n.y+e<t.min.y},_validateInnerRadius:function(t,e){return e>=t?t-1:e},getArc:function(t,e,n){var r=t.x-.01,o=t.y-e,i=t.y-n;return["M",t.x,o,"A",e,e,0,1,1,r,o,"M",r,i,"A",n,n,0,1,0,t.x,i,"Z"].join(" ")},getPathString:function(){var e=this._point,n=this._outerRadius,o=this._innerRadius;return this._checkIfEmpty()?"":t.Browser.svg?this.getArc(e,n,o):(e._round(),r=Math.round(r),"AL "+e.x+","+e.y+" "+n+","+n+" 0,23592600")}})}(s);e.LeafletDonut=a},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(33)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=n(22),p=n(21),f=n(65),h=u(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"componentWillMount",value:function(){r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this);var t=this.props,n=(t.children,t.map,a(t,["children","map"])),o=(0,h["default"])({},n);o.className=o.className?o.className+" panorama-leaflet-tip":"panorama-leaflet-tip",o.closeButton=!1,o.offset=o.offset||[0,-3],this.leafletElement=(0,p.popup)(o)}},{key:"componentDidMount",value:function(){}},{key:"componentDidUpdate",value:function(t){var e=this.props,n=e.map,r=e.position,o=e.isOpen,i=e.content;r!==t.position&&this.leafletElement.setLatLng(r),i!==t.content&&this.leafletElement.setContent(i),o!==t.isOpen&&(o?(this.leafletElement.openOn(n),this.renderPopupContent()):(n.closePopup(),this.removePopupContent()))}}],[{key:"propTypes",value:{children:l.PropTypes.node,map:l.PropTypes.instanceOf(p.Map),tooltipContainer:l.PropTypes.object,position:c.PropTypes.latlng},enumerable:!0}]),e}(c.Popup);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(31);n(154);var p=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.onItemClick=this.onItemClick.bind(this),this.onItemEnter=this.onItemEnter.bind(this),this.onItemLeave=this.onItemLeave.bind(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{items:u.PropTypes.array.isRequired,selectedItem:u.PropTypes.string,onItemSelected:u.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{items:[],selectedItem:"",onItemSelected:null},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){}},{key:"onItemClick",value:function(t){t.currentTarget&&t.currentTarget.dataset&&(this.props.onItemSelected&&this.props.onItemSelected(t.currentTarget.dataset.item,this.props.items.indexOf(t.currentTarget.dataset.item)),c.PanoramaDispatcher.Legend.selected(t.currentTarget.dataset.item,this.props.items.indexOf(t.currentTarget.dataset.item)))}},{key:"onItemEnter",value:function(t){t.currentTarget&&t.currentTarget.dataset&&this.props.onItemEnter&&this.props.onItemEnter(t.currentTarget.dataset.item,this.props.items.indexOf(t.currentTarget.dataset.item))}},{key:"onItemLeave",value:function(t){t.currentTarget&&t.currentTarget.dataset&&this.props.onItemLeave&&this.props.onItemLeave(t.currentTarget.dataset.item,this.props.items.indexOf(t.currentTarget.dataset.item))}},{key:"render",value:function(){var t=this;return l["default"].createElement("div",{className:"panorama legend "+this.props.className},l["default"].createElement("ul",null,this.props.items.map(function(e,n){var r=t.props.selectedItem===e||t.props.selectedItem==n;return l["default"].createElement("li",{className:"item"+(r?" selected":""),"data-item":e,key:e,onClick:t.onItemClick,onMouseEnter:t.onItemEnter,onMouseLeave:t.onItemLeave},l["default"].createElement("span",null,t.capitalize(e)))})))}},{key:"capitalize",value:function(t){return t.charAt(0).toUpperCase()+t.slice(1)}}]),e}(l["default"].Component);e["default"]=p,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=(u(l),n(6)),p=n(14),f=u(p),h=n(86),d=u(h);n(155);var y=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=d["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes,{strokeColor:c.PropTypes.oneOfType([c.PropTypes.string,c.PropTypes.number]),strokeOpacity:c.PropTypes.number,isInterpolated:c.PropTypes.bool,interpolate:c.PropTypes.string}),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{className:"line-chart",isInterpolated:!1,interpolate:"basis",xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(f["default"]);e["default"]=y,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale)),this.lineGenerator=p["default"].svg.line()}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this.lineLayer=this.base.append("g").classed("line-layer",!0),this._render()}},{key:"preRender",value:function(){var t=this.props,e=(t.data,t.xAccessor),n=t.yAccessor,r=t.xScale,o=t.yScale,i=t.isInterpolated,s=t.interpolate;r.range([0,this.width]),o.range([this.height,0]),this.updateAxis(0,r,this.props.xaxis),this.updateAxis(1,o,this.props.yaxis);var a=i?s:"linear";this.lineGenerator.interpolate(a).x(function(t){return r(e(t))}).y(function(t){return o(n(t))})}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=(e.xAccessor,e.yAccessor,e.xScale,e.yScale,e.strokeColor),o=e.strokeOpacity,i=this.lineLayer.selectAll("path.line").data(n);i.exit().remove(),i.enter().append("path").attr("class","line"),i.attr("d",function(e){return t.lineGenerator(e)}).style({stroke:r,strokeOpacity:o})}},{key:"postRender",value:function(){}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=(u(l),n(6)),p=n(14),f=u(p),h=n(88),d=u(h);n(156);var y=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=d["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes,{projection:c.PropTypes.string,mapScale:c.PropTypes.oneOfType([c.PropTypes.number,c.PropTypes.string]),selected:c.PropTypes.any,selectedAccessor:c.PropTypes.func,hoverStyle:c.PropTypes.object}),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{projection:"albersUsa",className:"map choropleth",mapScale:500}),enumerable:!0}]),e}(f["default"]);e["default"]=y,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(107)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(13),c=u(l),p=n(7),f=u(p),h=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this._path=f["default"].geo.path(),this._projection=f["default"].geo[this.props.projection](),this._render(),this._selected=null,this._hoverElement=null}},{key:"preRender",value:function(){this.updateProjection();
}},{key:"render",value:function(){var t=this.props,e=t.data,n=t.styler,r=t.interactive,o=t.selected,i=t.selectedAccessor;if(e&&e.features){var s=this,a=this.base.selectAll("path").data(e.features);a.exit().remove(),a.enter().append("path").attr("class","geometry").attr("d",this._path),a.each(function(t){f["default"].select(this).style(n(t))}),r&&(f["default"].selectAll(".hover-dupe").remove(),this._hoverElement=null,a.on("click",null).on("mouseover",null).on("mouseout",null).on("click",this.dispatch.click).on("mouseenter",function(t){i(t)!==o&&(s._hoverElement=s.bringToTop(this,"hover-dupe sel-"+i(t),s.props.hoverStyle||null),s.dispatch.mouseOver(t))}).on("mouseleave",function(t){s._hoverElement&&s._hoverElement.remove(),s._hoverElement=null,s.dispatch.mouseOut(t)})),o&&o!==this._selected&&(this._selected=o,f["default"].selectAll(".selected-dupe").remove(),a.filter(function(t){return i(t)===o}).each(function(){s.bringToTop(this,"selected-dupe")}))}}},{key:"postRender",value:function(){}},{key:"bringToTop",value:function(t,e,n){var r=f["default"].select(t.parentNode.appendChild(t.cloneNode(!0),t.nextSibling)).classed(e,!0);return n&&r.style(n),r}},{key:"updateProjection",value:function(){var t=this.props,e=t.data,n=t.mapScale,r=t.projection,o=n,i=[this.width/2,this.height/2];if("auto"===n){var s=this.fitMap(e),u=a(s,2);o=u[0],i=u[1]}this._projection=f["default"].geo[r]().scale(o).translate(i),this._path.projection(this._projection)}},{key:"fitMap",value:function(t){var e=this.props.projection,n=f["default"].geo[e]().scale(1).translate([0,0]),r=f["default"].geo.path().projection(n),o=r.bounds(t),i=.95/Math.max((o[1][0]-o[0][0])/this.width,(o[1][1]-o[0][1])/this.height),s=[(this.width-i*(o[1][0]+o[0][0]))/2,(this.height-i*(o[1][1]+o[0][1]))/2];return[i,s]}}]),e}(c["default"]);e["default"]=h,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(188),p=a(c);n(157);var f=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{nav_data:u.PropTypes.array.isRequired,show_menu:u.PropTypes.bool,on_hamburger_click:u.PropTypes.func,style:u.PropTypes.object,title:u.PropTypes.string,home_url:u.PropTypes.string,links:u.PropTypes.array,link_separator:u.PropTypes.string},enumerable:!0},{key:"defaultProps",value:{title:"American Panorama",home_url:"http://dsl.richmond.edu/panorama",links:[],link_separator:" ",nav_data:{},show_menu:!1,on_hamburger_click:null,style:{overlay:{position:"fixed",top:0,left:0,backgroundColor:"rgba(0,0,0,0.5)"},content:{position:"absolute",top:0,left:0,bottom:"auto",right:"auto",border:0,background:"rgba(0,0,0,0.5)",overflow:"auto",WebkitOverflowScrolling:"touch",borderRadius:"4px",outline:"none",padding:0}}},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){}},{key:"computeDimensions",value:function(){return(window.innerWidth-40*this.props.nav_data.length)/this.props.nav_data.length}},{key:"render",value:function(){var t=this;return l["default"].createElement("div",null,l["default"].createElement("div",{id:"hamburger"},l["default"].createElement("img",{src:"http://dsl.richmond.edu/panorama/static/images/menu.svg",onClick:this.props.on_hamburger_click})),l["default"].createElement(p["default"],{isOpen:this.props.show_menu,onRequestClose:this.props.on_hamburger_click,className:"nav_header",style:this.props.style},l["default"].createElement("div",{id:"nav_header"},l["default"].createElement("div",{id:"navburger"},l["default"].createElement("img",{src:"http://dsl.richmond.edu/panorama/static/images/menu-close.svg",onClick:this.props.on_hamburger_click})),this.props.title&&this.props.home_url?l["default"].createElement("h1",null,l["default"].createElement("a",{href:this.props.home_url},this.props.title)):"",l["default"].createElement("h2",null,this.props.links.map(function(e,n){return l["default"].createElement("a",{href:e.url,key:"pan_nav_links_"+n},n<t.props.links.length-1?e.name+t.props.link_separator:e.name)})),l["default"].createElement("div",{id:"maps"},this.props.nav_data.map(function(e,n){return l["default"].createElement("div",{className:"pan_nav_item",key:"pan_nav_item_"+n,style:{width:t.computeDimensions()+"px"}},l["default"].createElement("a",{href:e.url},l["default"].createElement("img",{src:e.screenshot,style:{width:t.computeDimensions()+"px"}})),l["default"].createElement("br",null),l["default"].createElement("h4",null,l["default"].createElement("a",{href:e.url},e.title)))})))))}}]),e}(l["default"].Component);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=(u(l),n(7)),p=(u(c),n(14)),f=u(p),h=n(45),d=(u(h),n(91)),y=u(d);n(158);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"],this.chartIdAccessor=t.chartIdAccessor}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes,{areaChartData:l.PropTypes.array,chartSpacing:l.PropTypes.number,colorPalette:l.PropTypes.array,selectedChartId:l.PropTypes.oneOfType([l.PropTypes.string,l.PropTypes.number]),chartIdAccessor:l.PropTypes.func,metadataAccessor:l.PropTypes.func,interpolate:l.PropTypes.string,circleRadius:l.PropTypes.number}),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{className:"offset-area-chart",areaChartData:[],chartSpacing:4,colorPalette:null,selectedChartId:null,chartIdAccessor:null,metadataAccessor:null,interpolate:"basis",circleRadius:2}),enumerable:!0}]),e}(f["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=(a(f),function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){var t=this.props,e=t.xAccessor,n=t.yAccessor,r=t.xScale,o=t.yScale,i=t.interpolate;this.areaGenerator=p["default"].svg.area().interpolate(i).x(function(t){return r(e(t))}).y0(function(t){return o(0)}).y1(function(t){return o(n(t))})}},{key:"onMount",value:function(){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this),this.lineLayer=this.base.append("g").classed("offset-area-lines",!0),this._render()}},{key:"preRender",value:function(){var t=this.props,e=t.xScale,n=t.yScale,r=(t.xAccessor,t.yAccessor,t.areaChartConfig),o=t.interpolate,i=this.height-this.props.areaChartData.length*this.props.chartSpacing;e.range([0,this.width]),n.range([i,0]),this.areaGenerator=p["default"].svg.area().interpolate(o).x(function(t){return e(r.xAccessor(t))}).y0(function(t){return n(0)}).y1(function(t){return n(r.yAccessor(t))})}},{key:"areaOffsetTranslation",value:function(t){var e=this.props.chartSpacing;return"translate(0,"+e*t+")"}},{key:"lineOffsetTranslation",value:function(t){var e=this.props,n=e.data,r=e.chartSpacing,o=e.yScale,i=(o(0),n.length-t),s=-r*i;return"translate(0,"+s+")"}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=e.xAccessor,o=(e.yAccessor,e.xScale),i=e.yScale,s=(e.fillColor,e.fillOpacity,e.areaChartData),a=e.colorPalette,u=e.metadataAccessor,l=e.chartIdAccessor,c=e.selectedChartId,p=e.circleRadius,f=(e.interactive,this.base.selectAll("g.area-container").data(s));f.exit().remove(),f.enter().append("g").attr("class","area-container").append("path").attr("class","area"),f.attr("transform",function(e,n){return t.areaOffsetTranslation(n)}).classed("selected",function(t){return l(t)===c?!0:!1}).selectAll("path").attr("d",function(e){return t.areaGenerator(e)}).attr("fill",function(t,e,n){return a[n%a.length]});var h=i(0)+this.props.areaChartData.length*this.props.chartSpacing,d=o.domain();this.lineLayer.attr("transform","translate(0, "+h+")");var y=this.lineLayer.selectAll("g.line-group").data(n);y.exit().remove(),y.enter().append("g").attr("class","line-group").append("line").attr("class","lifespan"),y.attr("transform",function(e,n){return t.lineOffsetTranslation(n)}).classed("selected",function(t){return l(t)==c?!0:!1}).selectAll("line").attr("x1",function(t){return o(Math.max(r(t,0),d[0]))}).attr("x2",function(t){return o(Math.min(r(t,1),d[1]))}).attr("y1",0).attr("y2",0).style("stroke",function(t,e){return a[e%a.length]});var v=y.selectAll("circle").data(function(t){return u(t)});v.exit().remove(),v.enter().append("circle"),v.attr("cx",function(t){return o(Math.max(t,d[0]))}).attr("cy",0).attr("r",p).style("fill",function(t,e,n){return a[n%a.length]})}},{key:"postRender",value:function(){}}]),e}(l["default"]));e["default"]=h,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"],l=n(48)["default"];Object.defineProperty(e,"__esModule",{value:!0});var c=n(6),p=u(c),f=n(7),h=l(f);n(159);var d=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{data:c.PropTypes.array.isRequired,onItemClick:c.PropTypes.func,loading:c.PropTypes.bool,noDataAvailableMsg:c.PropTypes.string,punchcardOptions:c.PropTypes.object,selectAccessor:c.PropTypes.func,textValueFormatter:c.PropTypes.func,headerMargin:c.PropTypes.number},enumerable:!0},{key:"defaultProps",value:{data:[],onItemClick:null,loading:!0,noDataAvailableMsg:"No commodities data available for this canal in the selected year.",radiusExtent:[2,10],textValueFormatter:function(t){return t},headerMargin:0},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){this.renderVisualization()}},{key:"componentDidUpdate",value:function(){y.destroy(this.refs.content),this.renderVisualization()}},{key:"componentWillUnmount",value:function(){y.destroy(this.refs.content)}},{key:"render",value:function(){return p["default"].createElement("div",{className:"panorama punchcard"},this.renderPlaceholder(),p["default"].createElement("div",{className:"content",ref:"content",style:{marginTop:this.props.headerMargin+"px"}}))}},{key:"renderVisualization",value:function(){!this.isEmpty(this.props.data)&&this.refs.content&&y.update(this.refs.content,a({},this.props))}},{key:"renderPlaceholder",value:function(){var t=this.props,e=t.loading,n=t.noDataAvailableMsg;return e?p["default"].createElement("div",{className:"placeholder",ref:"placeholder"},p["default"].createElement("h4",null,"Loading...")):!this.props.loading&&this.isEmpty(this.props.data)?p["default"].createElement("div",{className:"placeholder",ref:"placeholder"},p["default"].createElement("h4",null,n)):null}},{key:"isEmpty",value:function(t){return t.length<1}}]),e}(p["default"].Component);e["default"]=d;var y={_setTextValueFormatter:function(t){return t},setTextValueFormatter:function(t){this._setTextValueFormatter=t},ROW_HEIGHT:25,COMMODITY_TEXT_OFFSET_Y:5,update:function(t,e){var n=this,r=e.colorScale,o=e.valueAccessor,i=e.onItemClick,s=e.textValueFormatter,a=e.selected,u=e.selectAccessor;"function"==typeof s&&this.setTextValueFormatter(s);var l=e.radiusExtent[1],c=this,p=h.scale.sqrt().range(e.radiusExtent).domain([1,e.radiusMaxValue]),f=p.domain(),d=f[0]+Math.sqrt(.25)*(f[1]-f[0]),y=h.select(t).selectAll("div").data(e.data).enter().append("div").attr("style",function(t){return"color: "+r(e.colorAccessor(t))+";"}).attr("class","category");y.append("h4").text(function(t){return t.name}),y=y.append("svg").attr("height",function(t){return t.commodities.length*c.ROW_HEIGHT}).style("stroke",function(t){return r(e.colorAccessor(t))}).style("fill",function(t){return r(e.colorAccessor(t))}),this.categoryNodeWidth=(y.node().offsetWidth||y.node().getBoundingClientRect().width)-2.5*this.ROW_HEIGHT;var v=y.selectAll("g").data(function(t){return t.commodities}).enter().append("g");v.classed("selected",function(t){return u(t)===a}),v.append("circle").attr("r",function(t){var e=o(t);return e?p(e):d}).style("fill",function(t){return o(t)?null:"none"}).style("stroke",function(t){return o(t)?"none":null}).style("stroke-width",function(t){return o(t)?null:2}),v.append("text").text(function(t){return t.name}).style("stroke","none").attr("x",2*c.ROW_HEIGHT).attr("y",c.COMMODITY_TEXT_OFFSET_Y).call(this.wrap,this.categoryNodeWidth);var m=void 0;y.each(function(t,e){h.select(this).selectAll("g").each(function(t,e){e||(m=0);var n=h.select(this);n.attr("transform","translate("+.5*c.ROW_HEIGHT+", "+(e+.5+m)*c.ROW_HEIGHT+")"),m+=n.selectAll("tspan").size()-1});var n=h.select(this);n.attr("height",parseFloat(n.attr("height"))+m*c.ROW_HEIGHT)}),v.append("rect").attr("x",-l).attr("y",-l).attr("width",this.categoryNodeWidth+2.5*this.ROW_HEIGHT).attr("height",this.ROW_HEIGHT).on("mouseover",function(t,e){c.onItemMouseOver(this,t,e)}).on("mouseout",function(t,e){c.onItemMouseOut(this,t,e)}).on("click",function(t,e){"function"==typeof i&&i.call(n,t,e)})},onItemMouseOver:function(t,e,n){var r=h.select(t.parentNode);r.select("text").text((e.prettyValue||this._setTextValueFormatter(e.value))+(e.units?" "+e.units:"")).style("font-weight",400)},onItemMouseOut:function(t,e,n){var r=h.select(t.parentNode);r.select("text").text(e.name).style("font-weight",null).call(this.wrap,this.categoryNodeWidth)},destroy:function(t){h.select(t).html("")},wrap:function(t,e){t.each(function(){var t=["/","&"],n=h.select(this),r=n.text(),o=void 0;t.forEach(function(t){r=r.replace(t,t+" ")});for(var i=r.split(/\s+/).reverse(),s=void 0,a=[],u=0,l=1.1,c=n.attr("x"),p=n.attr("y"),f=parseFloat(n.attr("dy")||0),d=n.text(null).append("tspan").attr("x",c).attr("y",p).attr("dy",f+"em");s=i.pop();)a.push(s),d.text(a.join(" ")),d.node().getComputedTextLength()>e&&(a.pop(),o=a.join(" "),t.forEach(function(t){o=o.replace(t+" ",t)}),d.text(o),a=[s],d=n.append("tspan").attr("x",c).attr("y",p).attr("dy",++u*l+f+"em").text(s))})}};t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=u(l),p=n(6),f=n(14),h=u(f),d=n(94),y=u(d);n(160);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},h["default"].propTypes,{dotRadiusScale:p.PropTypes.func,dotRadius:p.PropTypes.number,dotRadiusAccessor:p.PropTypes.func,dotColorScale:p.PropTypes.func,dotColorAccessor:p.PropTypes.func}),enumerable:!0},{key:"defaultProps",value:a({},h["default"].defaultProps,{xScale:c["default"].scale.linear(),yScale:c["default"].scale.linear(),className:"scatterplot",dotRadius:3,xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(h["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale))}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this._render()}},{key:"preRender",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale,s=t.dotRadiusScale,a=t.dotRadiusAccessor;o.range([0,this.width]),o.domain(p["default"].extent(e,function(t){return n(t)})).nice(),i.range([this.height,0]),i.domain(p["default"].extent(e,function(t){return r(t)})).nice(),s&&a&&s.domain(p["default"].extent(e,function(t){return a(t)}))}},{key:"render",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale,s=t.dotRadius,a=t.dotRadiusScale,u=t.dotRadiusAccessor,l=t.dotColorScale,c=t.dotColorAccessor,p=this.base.selectAll(".dot").data(e);p.exit().remove(),p.enter().append("circle").attr("class","dot"),p.attr("r",function(t){return a||u?a(u(t)):s}).attr("cx",function(t){return o(n(t))}).attr("cy",function(t){return i(r(t))}).style("fill",function(t){return l&&c?l(c(t)):"lime"})}},{key:"postRender",value:function(){var t=this.props,e=t.selected,n=t.selectionAccessor,r=t.interactive,o=this.base.selectAll(".dot");r&&o.on("click",this.dispatch.click).on("mouseover",this.dispatch.mouseOver).on("mouseout",this.dispatch.mouseOut),e&&o.classed("selected",function(t){return n(t)===e})}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(30),p=a(c),f=n(96),h=a(f);n(161);var d=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.selectedKey=null,this.currentKey=null,this.handleScroll=this.handleScroll.bind(this),this.onClickHandler=this.onClickHandler.bind(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{items:u.PropTypes.array.isRequired,keyAccessor:u.PropTypes.func.isRequired,renderItem:u.PropTypes.func.isRequired,onItemClicked:u.PropTypes.func,selected:u.PropTypes.string,height:u.PropTypes.any,isItemDirty:u.PropTypes.func,onStoryScroll:u.PropTypes.func,sensitivity:u.PropTypes.number},enumerable:!0},{key:"defaultProps",value:{selected:null,height:400,sensitivity:30},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){this.listContainer=p["default"].findDOMNode(this.refs.list),this.listContainer.addEventListener("scroll",this.handleScroll,!1)}},{key:"componentWillUnmount",value:function(){this.listContainer.removeEventListener("scroll",this.handleScroll)}},{key:"componentDidUpdate",value:function(){var t=this.props.selected;this.buildItemCache(),this.anchors.length&&t!==this.selectedKey&&(this.selectedKey=t,this.setScrollPosition())}},{key:"buildItemCache",value:function(){var t=this;this.anchors=[],this.anchorMap={};var e=this.listContainer.querySelectorAll(".textural-list--item");[].forEach.call(e,function(e){var n={t:e.offsetTop,key:e.getAttribute("data-id")};t.anchorMap[n.key]=e,t.anchors.push(n)})}},{key:"setScrollPosition",value:function(){if(this.selectedKey&&this.listContainer){var t=this.selectedKey in this.anchorMap?this.anchorMap[this.selectedKey].offsetTop:null;t&&(this.listContainer.scrollTop=t)}}},{key:"handleScroll",value:function(){var t=this,e=this.props,n=e.onStoryScroll,r=e.sensitivity,o=this.listContainer.scrollTop,i=this.currentKey,s=this.listContainer.scrollHeight,a=this.listContainer.clientHeight,u=void 0;this.anchors&&(0>=o?this.currentKey=this.anchors[0].key:s-o===a?this.currentKey=this.anchors[this.anchors.length-1].key:this.anchors.forEach(function(e){u=o-e.t,r>u&&u>-r&&t.currentKey!==e.key&&(t.currentKey=e.key)}),i!==this.currentKey&&"function"==typeof n&&n(this.currentKey))}},{key:"getClosestItemNode",value:function(t){for(;t&&t!==document;t=t.parentNode)if(t.classList.contains("textural-list--item"))return t;return!1}},{key:"getDataItemForKey",value:function(t){var e=this,n=this.props,r=n.items,o=n.keyAccessor,i=r.filter(function(n){return e.coerceKey(o(n))===t});return i.length?i:null}},{key:"onClickHandler",value:function(t){var e=this.props.onItemClicked,n=t.target||null;if(n){var r=n.classList.contains("textural-list--item")?n:this.getClosestItemNode(n);if(r){var o=r.getAttribute("data-id");if(o){var i=this.getDataItemForKey(o);i.length&&"function"==typeof e&&e(i)}}}}},{key:"renderItems",value:function(){var t=this,e=this.props,n=e.renderItem,r=e.items,o=e.keyAccessor,i=e.isItemDirty,s="function"==typeof o?!0:!1,a="function"==typeof i?!0:!1;return r.map(function(e,r){var u=a?i(e):!0,c=s?o(e):r;return l["default"].createElement(h["default"],{key:c,renderItem:n,index:r,identifier:t.coerceKey(c),dirty:u})})}},{key:"coerceKey",value:function(t){return""+t}},{key:"isNumeric",value:function(t){return!isNaN(t)}},{key:"render",value:function(){var t=this.props.height,e=this.isNumeric(t)?{maxHeight:t}:null;return l["default"].createElement("div",{className:"panorama textural-list"},l["default"].createElement("div",{ref:"list",className:"textural-list--inner",style:e,onClick:this.onClickHandler},this.renderItems()))}}]),e}(u.Component);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{renderItem:u.PropTypes.func.isRequired,index:u.PropTypes.number.isRequired,dirty:u.PropTypes.bool,identifier:u.PropTypes.string},enumerable:!0},{key:"defaultProps",value:{dirty:!0},enumerable:!0}]),i(e,[{key:"shouldComponentUpdate",value:function(t,e){return t.dirty}},{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){}},{key:"render",value:function(){var t=this.props,e=t.renderItem,n=t.index,r=t.identifier;return l["default"].createElement("div",{className:"textural-list--item","data-id":r},e(n))}}]),e}(u.Component);e["default"]=c,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=n(22),c=n(7),p=a(c);n(162);var f=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.map=null}return o(e,t),i(e,null,[{key:"propTypes",value:{features:u.PropTypes.object.isRequired,currentDate:u.PropTypes.instanceOf(Date)},enumerable:!0},{key:"defaultProps",value:{features:{},currentDate:null},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){this.markers=[],this.map=this.props.map,this._el=L.DomUtil.create("div","panorama time-based-markers-layer leaflet-zoom-hide leaflet-d3-overlay"),this.map.getPanes().overlayPane.appendChild(this._el),this.svg=p["default"].select(this._el).append("svg"),this.container=this.svg.append("g").attr("class","panorama time-based-markers-container"),this.setOverlayPosition(),this.map.on("viewreset",this._reset,this),this.dirty&&this.draw(this.props.features)}},{key:"componentWillUnmount",value:function(){this.map.getPanes().overlayPane.removeChild(this._el),this.map.off("viewreset",this._reset,this),this.markers=[],this.line=null}},{key:"componentDidUpdate",value:function(){var t=this;this.props.features&&this.props.features.features.length&&!this.loaded&&this.draw(this.props.features),this.props.currentDate!==this.currentDate&&(this.currentDate=this.props.currentDate,this.filter()),setTimeout(function(){t.map.getPanes().overlayPane.appendChild(t._el)},1)}},{key:"render",value:function(){return!1}},{key:"setOverlayPosition",value:function(){var t=this.map.getBounds(),e=this.map.latLngToLayerPoint(t.getNorthWest());this.map.latLngToLayerPoint(t.getSouthEast());this.svg&&(p["default"].select(this._el).style("width",this.map.getSize().x+"px").style("height",this.map.getSize().y+"px").style("margin-left","0px").style("margin-top","0px").attr("transform","translate("+-e.x+","+-e.y+")"),this.svg.style("width",this.map.getSize().x+"px").style("height",this.map.getSize().y+"px"))}},{key:"_reset",value:function(){this.setOverlayPosition(),this.filter(),this.position()}},{key:"filter",value:function(){if(this.map){var t=this.props.currentDate||null,e=this.map.getZoom(),n=!1;this.markers.forEach(function(r){r.show="none",t&&e>=r.zoomStart&&e<=r.zoomEnd&&(r.start?!r.end&&t>=r.start?(r.show="block",n=!0):t>=r.start&&t<=r.end&&(r.show="block",n=!0):(r.show="block",n=!0)),r.elm.style("display",r.show)}),n&&this.position()}}},{key:"position",value:function(){if(this.markers&&this.map){var t=this;this.markers.forEach(function(e){if("none"!==e.show){var n;"icon"===e.markerType?(n=t.map.latLngToLayerPoint(e.coords),e.elm.attr("cx",n.x+"px").attr("cy",n.y+"px")):"label"===e.markerType?(n=t.map.latLngToLayerPoint(e.coords),e.elm.attr("x",n.x+"px").attr("y",n.y+"px")):"line"===e.markerType&&e.elm.attr("d",t.line(e.coords))}})}}},{key:"draw",value:function(t){function e(t,e){return i.container.append("circle").attr("class","time-based-"+[e.maptype,e.type].join(" ")).attr("cx",t.x+"px").attr("cy",t.y+"px").attr("r",3)}function n(t,e){var n="left"===e.justify?"start":"end";return i.container.append("text").attr("class","with-outlines time-based-"+[e.maptype,e.type].join(" ")).attr("x",t.x+"px").attr("y",t.y+"px").attr("text-anchor",n).text(e.location)}function r(t,e){return i.container.append("path").attr("class","time-based-"+[e.maptype,e.type].join(" ")).attr("d",i.line(t))}function o(o){t.features.forEach(function(t){var s,a,u,l=t.properties,c=t.geometry.type;l.maptype===o&&("icon"===l.maptype?(s=t.geometry.coordinates.reverse(),u=i.map.latLngToLayerPoint(s),a=e(u,l)):"label"===l.maptype?(s=t.geometry.coordinates.reverse(),u=i.map.latLngToLayerPoint(s),a=n(u,l)):"line"===l.maptype&&(s=t.geometry.coordinates,s.forEach(function(t){t.reverse()}),a=r(s,l)),a?i.markers.push({elm:a,coords:s,geometryType:c,markerType:l.maptype||"",start:l.start_year?new Date(l.start_year):null,end:l.end_year?new Date(l.end_year):null,zoomStart:l.startzoom?+l.startzoom:i.map.minZoom,zoomEnd:l.endzoom?+l.endzoom:i.map.maxZoom}):console.error("Unknown feature: ",t))})}if(t&&!this.loaded){if(this.loaded=!0,!this.map)return void(this.dirty=!0);this.dirty=!1;var i=this;if(this.markers.length)return position();this.line=p["default"].svg.line().x(function(t){return i.map.latLngToLayerPoint(t).x}).y(function(t){return i.map.latLngToLayerPoint(t).y}).interpolate("linear"),this.markers=[],o("label"),o("line"),o("icon"),this.filter()}}}]),e}(l.MapLayer);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(3)["default"],o=n(2)["default"],i=n(11)["default"],s=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var a=n(7),u=s(a),l=n(32),c=function(){function t(e,n){o(this,t),this._options=i({},l.tooltipDefaultOptions,n),this._element=u["default"].select(e),this.closeTimer=null}return r(t,[{key:"unMount",value:function(){this._options={},this._element=null,this._relativeContainer=null,this.closeTimer&&(clearTimeout(this.closeTimer),this.closeTimer=null)}},{key:"setPosition",value:function(t){if(this.isShowing){var e=this.calcPosition(t);this.element.style("left",e[0]+"px").style("top",e[1]+"px")}}},{key:"calcPosition",value:function(t){var e=this.options,n=e.offset,r=e.align,o=r.split(" "),i=this.element.node().offsetWidth,s=this.element.node().offsetHeight,a=this.relativeContainer||t.target||t.srcElement,u=a.getBoundingClientRect(),l=t.clientX-u.left,c=t.clientY-u.top;switch(o[0]){case"top":c-=s-n[1];break;case"bottom":default:c-=n[1]}switch(o[1]){case"center":l-=i/2+n[0];break;case"right":l-=i+n[0];break;case"left":default:l+=n[0]}return[l,c]}},{key:"setContent",value:function(t){return"function"==typeof this.options.onSetTooltipContent?this.options.onSetTooltipContent(this.element,t):this.element.text(""),this}},{key:"show",value:function(t,e){return this.isShowing?void 0:(this.isShowing=!0,this.element.classed("active",!0),t&&this.setPosition(t),e&&this.setContent(e),this)}},{key:"hide",value:function(t){var e=this;if(this.isShowing)return this.closeTimer&&(clearTimeout(this.closeTimer),this.closeTimer=null),this.isShowing=!1,t||this.options.closeDelay<1?this.setActiveToFalse():this.closeTimer=setTimeout(function(){e.isShowing||e.setActiveToFalse()},this.options.closeDelay),this}},{key:"setActiveToFalse",value:function(){this.closeTimer=null,this.element.classed("active",!1)}},{key:"toString",value:function(){return"Tooltip"}},{key:"element",get:function(){return this._element},set:function(t){this._element=u["default"].select(t)}},{key:"options",get:function(){return this._options},set:function(t){this._options=i({},this.options,{obj:t})}},{key:"relativeContainer",get:function(){return this._relativeContainer},set:function(t){this._relativeContainer=t.node?t.node():t}}]),t}();e["default"]=c,t.exports=e["default"]},function(t,e,n){t.exports={"default":n(108),__esModule:!0}},function(t,e,n){t.exports={"default":n(109),__esModule:!0}},function(t,e,n){t.exports={"default":n(111),__esModule:!0}},function(t,e,n){t.exports={"default":n(112),__esModule:!0}},function(t,e,n){t.exports={"default":n(113),__esModule:!0}},function(t,e,n){t.exports={"default":n(114),__esModule:!0}},function(t,e,n){t.exports={"default":n(115),__esModule:!0}},function(t,e,n){t.exports={"default":n(116),__esModule:!0}},function(t,e,n){"use strict";var r=n(99)["default"],o=n(100)["default"];e["default"]=function(){function t(t,e){var n=[],o=!0,i=!1,s=void 0;try{for(var a,u=r(t);!(o=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);o=!0);}catch(l){i=!0,s=l}finally{try{!o&&u["return"]&&u["return"]()}finally{if(i)throw s}}return n}return function(e,n){if(Array.isArray(e))return e;if(o(Object(e)))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),e.__esModule=!0},function(t,e,n){n(42),n(41),t.exports=n(139)},function(t,e,n){n(42),n(41),t.exports=n(140)},function(t,e,n){n(142),t.exports=n(8).Object.assign},function(t,e,n){var r=n(9);t.exports=function(t,e){return r.create(t,e)}},function(t,e,n){var r=n(9);t.exports=function(t,e,n){return r.setDesc(t,e,n)}},function(t,e,n){var r=n(9);n(143),t.exports=function(t,e){return r.getDesc(t,e)}},function(t,e,n){n(144),t.exports=n(8).Object.keys},function(t,e,n){n(145),t.exports=n(8).Object.setPrototypeOf},function(t,e,n){n(146),n(41),n(42),n(147),t.exports=n(8).Promise},function(t,e){t.exports=function(){}},function(t,e,n){var r=n(25),o=n(12).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,e,n){var r=n(19),o=n(123),i=n(122),s=n(15),a=n(137),u=n(60);t.exports=function(t,e,n,l){var c,p,f,h=u(t),d=r(n,l,e?2:1),y=0;if("function"!=typeof h)throw TypeError(t+" is not iterable!");if(i(h))for(c=a(t.length);c>y;y++)e?d(s(p=t[y])[0],p[1]):d(t[y]);else for(f=h.call(t);!(p=f.next()).done;)o(f,d,p.value,e)}},function(t,e,n){t.exports=n(12).document&&document.documentElement},function(t,e){t.exports=function(t,e,n){var r=void 0===n;switch(e.length){case 0:return r?t():t.call(n);case 1:return r?t(e[0]):t.call(n,e[0]);case 2:return r?t(e[0],e[1]):t.call(n,e[0],e[1]);case 3:return r?t(e[0],e[1],e[2]):t.call(n,e[0],e[1],e[2]);case 4:return r?t(e[0],e[1],e[2],e[3]):t.call(n,e[0],e[1],e[2],e[3])}return t.apply(n,e)}},function(t,e,n){var r=n(16),o=n(10)("iterator"),i=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||i[o]===t)}},function(t,e,n){var r=n(15);t.exports=function(t,e,n,o){try{return o?e(r(n)[0],n[1]):e(n)}catch(i){var s=t["return"];throw void 0!==s&&r(s.call(t)),i}}},function(t,e,n){"use strict";var r=n(9),o=n(54),i=n(40),s={};n(39)(s,n(10)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=r.create(s,{next:o(1,n)}),i(t,e+" Iterator")}},function(t,e,n){var r=n(10)("iterator"),o=!1;
try{var i=[7][r]();i["return"]=function(){o=!0},Array.from(i,function(){throw 2})}catch(s){}t.exports=function(t,e){if(!e&&!o)return!1;var n=!1;try{var i=[7],s=i[r]();s.next=function(){n=!0},i[r]=function(){return s},t(i)}catch(a){}return n}},function(t,e){t.exports=function(t,e){return{value:e,done:!!t}}},function(t,e,n){var r,o,i,s=n(12),a=n(136).set,u=s.MutationObserver||s.WebKitMutationObserver,l=s.process,c=s.Promise,p="process"==n(24)(l),f=function(){var t,e,n;for(p&&(t=l.domain)&&(l.domain=null,t.exit());r;)e=r.domain,n=r.fn,e&&e.enter(),n(),e&&e.exit(),r=r.next;o=void 0,t&&t.enter()};if(p)i=function(){l.nextTick(f)};else if(u){var h=1,d=document.createTextNode("");new u(f).observe(d,{characterData:!0}),i=function(){d.data=h=-h}}else i=c&&c.resolve?function(){c.resolve().then(f)}:function(){a.call(s,f)};t.exports=function(t){var e={fn:t,next:void 0,domain:p&&l.domain};o&&(o.next=e),r||(r=e,i()),o=e}},function(t,e,n){var r=n(9),o=n(59),i=n(50);t.exports=n(38)(function(){var t=Object.assign,e={},n={},r=Symbol(),o="abcdefghijklmnopqrst";return e[r]=7,o.split("").forEach(function(t){n[t]=t}),7!=t({},e)[r]||Object.keys(t({},n)).join("")!=o})?function(t,e){for(var n=o(t),s=arguments,a=s.length,u=1,l=r.getKeys,c=r.getSymbols,p=r.isEnum;a>u;)for(var f,h=i(s[u++]),d=c?l(h).concat(c(h)):l(h),y=d.length,v=0;y>v;)p.call(h,f=d[v++])&&(n[f]=h[f]);return n}:Object.assign},function(t,e,n){var r=n(55);t.exports=function(t,e){for(var n in e)r(t,n,e[n]);return t}},function(t,e){t.exports=Object.is||function(t,e){return t===e?0!==t||1/t===1/e:t!=t&&e!=e}},function(t,e,n){"use strict";var r=n(8),o=n(9),i=n(37),s=n(10)("species");t.exports=function(t){var e=r[t];i&&e&&!e[s]&&o.setDesc(e,s,{configurable:!0,get:function(){return this}})}},function(t,e,n){var r=n(12),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,e,n){var r=n(15),o=n(34),i=n(10)("species");t.exports=function(t,e){var n,s=r(t).constructor;return void 0===s||void 0==(n=r(s)[i])?e:o(n)}},function(t,e){t.exports=function(t,e,n){if(!(t instanceof e))throw TypeError(n+": use the 'new' operator!");return t}},function(t,e,n){var r=n(57),o=n(36);t.exports=function(t){return function(e,n){var i,s,a=String(o(e)),u=r(n),l=a.length;return 0>u||u>=l?t?"":void 0:(i=a.charCodeAt(u),55296>i||i>56319||u+1===l||(s=a.charCodeAt(u+1))<56320||s>57343?t?a.charAt(u):i:t?a.slice(u,u+2):(i-55296<<10)+(s-56320)+65536)}}},function(t,e,n){var r,o,i,s=n(19),a=n(121),u=n(120),l=n(118),c=n(12),p=c.process,f=c.setImmediate,h=c.clearImmediate,d=c.MessageChannel,y=0,v={},m="onreadystatechange",g=function(){var t=+this;if(v.hasOwnProperty(t)){var e=v[t];delete v[t],e()}},x=function(t){g.call(t.data)};f&&h||(f=function(t){for(var e=[],n=1;arguments.length>n;)e.push(arguments[n++]);return v[++y]=function(){a("function"==typeof t?t:Function(t),e)},r(y),y},h=function(t){delete v[t]},"process"==n(24)(p)?r=function(t){p.nextTick(s(g,t,1))}:d?(o=new d,i=o.port2,o.port1.onmessage=x,r=s(i.postMessage,i,1)):c.addEventListener&&"function"==typeof postMessage&&!c.importScripts?(r=function(t){c.postMessage(t+"","*")},c.addEventListener("message",x,!1)):r=m in l("script")?function(t){u.appendChild(l("script"))[m]=function(){u.removeChild(this),g.call(t)}}:function(t){setTimeout(s(g,t,1),0)}),t.exports={set:f,clear:h}},function(t,e,n){var r=n(57),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,e){var n=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++n+r).toString(36))}},function(t,e,n){var r=n(15),o=n(60);t.exports=n(8).getIterator=function(t){var e=o(t);if("function"!=typeof e)throw TypeError(t+" is not iterable!");return r(e.call(t))}},function(t,e,n){var r=n(35),o=n(10)("iterator"),i=n(16);t.exports=n(8).isIterable=function(t){var e=Object(t);return void 0!==e[o]||"@@iterator"in e||i.hasOwnProperty(r(e))}},function(t,e,n){"use strict";var r=n(117),o=n(126),i=n(16),s=n(58);t.exports=n(51)(Array,"Array",function(t,e){this._t=s(t),this._i=0,this._k=e},function(){var t=this._t,e=this._k,n=this._i++;return!t||n>=t.length?(this._t=void 0,o(1)):"keys"==e?o(0,n):"values"==e?o(0,t[n]):o(0,[n,t[n]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,e,n){var r=n(20);r(r.S+r.F,"Object",{assign:n(128)})},function(t,e,n){var r=n(58);n(53)("getOwnPropertyDescriptor",function(t){return function(e,n){return t(r(e),n)}})},function(t,e,n){var r=n(59);n(53)("keys",function(t){return function(e){return t(r(e))}})},function(t,e,n){var r=n(20);r(r.S,"Object",{setPrototypeOf:n(56).set})},function(t,e){},function(t,e,n){"use strict";var r,o=n(9),i=n(52),s=n(12),a=n(19),u=n(35),l=n(20),c=n(25),p=n(15),f=n(34),h=n(134),d=n(119),y=n(56).set,v=n(130),m=n(10)("species"),g=n(133),x=n(127),b="Promise",k=s.process,_="process"==u(k),P=s[b],T=function(t){var e=new P(function(){});return t&&(e.constructor=Object),P.resolve(e)===e},O=function(){function t(e){var n=new P(e);return y(n,t.prototype),n}var e=!1;try{if(e=P&&P.resolve&&T(),y(t,P),t.prototype=o.create(P.prototype,{constructor:{value:t}}),t.resolve(5).then(function(){})instanceof t||(e=!1),e&&n(37)){var r=!1;P.resolve(o.setDesc({},"then",{get:function(){r=!0}})),e=r}}catch(i){e=!1}return e}(),w=function(t,e){return i&&t===P&&e===r?!0:v(t,e)},M=function(t){var e=p(t)[m];return void 0!=e?e:t},E=function(t){var e;return c(t)&&"function"==typeof(e=t.then)?e:!1},C=function(t){var e,n;this.promise=new t(function(t,r){if(void 0!==e||void 0!==n)throw TypeError("Bad Promise constructor");e=t,n=r}),this.resolve=f(e),this.reject=f(n)},S=function(t){try{t()}catch(e){return{error:e}}},j=function(t,e){if(!t.n){t.n=!0;var n=t.c;x(function(){for(var r=t.v,o=1==t.s,i=0,a=function(e){var n,i,s=o?e.ok:e.fail,a=e.resolve,u=e.reject;try{s?(o||(t.h=!0),n=s===!0?r:s(r),n===e.promise?u(TypeError("Promise-chain cycle")):(i=E(n))?i.call(n,a,u):a(n)):u(r)}catch(l){u(l)}};n.length>i;)a(n[i++]);n.length=0,t.n=!1,e&&setTimeout(function(){var e,n,o=t.p;A(o)&&(_?k.emit("unhandledRejection",r,o):(e=s.onunhandledrejection)?e({promise:o,reason:r}):(n=s.console)&&n.error&&n.error("Unhandled promise rejection",r)),t.a=void 0},1)})}},A=function(t){var e,n=t._d,r=n.a||n.c,o=0;if(n.h)return!1;for(;r.length>o;)if(e=r[o++],e.fail||!A(e.promise))return!1;return!0},L=function(t){var e=this;e.d||(e.d=!0,e=e.r||e,e.v=t,e.s=2,e.a=e.c.slice(),j(e,!0))},I=function(t){var e,n=this;if(!n.d){n.d=!0,n=n.r||n;try{if(n.p===t)throw TypeError("Promise can't be resolved itself");(e=E(t))?x(function(){var r={r:n,d:!1};try{e.call(t,a(I,r,1),a(L,r,1))}catch(o){L.call(r,o)}}):(n.v=t,n.s=1,j(n,!1))}catch(r){L.call({r:n,d:!1},r)}}};O||(P=function(t){f(t);var e=this._d={p:h(this,P,b),c:[],a:void 0,s:0,d:!1,v:void 0,h:!1,n:!1};try{t(a(I,e,1),a(L,e,1))}catch(n){L.call(e,n)}},n(129)(P.prototype,{then:function(t,e){var n=new C(g(this,P)),r=n.promise,o=this._d;return n.ok="function"==typeof t?t:!0,n.fail="function"==typeof e&&e,o.c.push(n),o.a&&o.a.push(n),o.s&&j(o,!1),r},"catch":function(t){return this.then(void 0,t)}})),l(l.G+l.W+l.F*!O,{Promise:P}),n(40)(P,b),n(131)(b),r=n(8)[b],l(l.S+l.F*!O,b,{reject:function(t){var e=new C(this),n=e.reject;return n(t),e.promise}}),l(l.S+l.F*(!O||T(!0)),b,{resolve:function(t){if(t instanceof P&&w(t.constructor,this))return t;var e=new C(this),n=e.resolve;return n(t),e.promise}}),l(l.S+l.F*!(O&&n(125)(function(t){P.all(t)["catch"](function(){})})),b,{all:function(t){var e=M(this),n=new C(e),r=n.resolve,i=n.reject,s=[],a=S(function(){d(t,!1,s.push,s);var n=s.length,a=Array(n);n?o.each.call(s,function(t,o){var s=!1;e.resolve(t).then(function(t){s||(s=!0,a[o]=t,--n||r(a))},i)}):r(a)});return a&&i(a.error),n.promise},race:function(t){var e=M(this),n=new C(e),r=n.reject,o=S(function(){d(t,!1,function(t){e.resolve(t).then(n.resolve,r)})});return o&&r(o.error),n.promise}})},function(t,e){},148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,function(t,e){function n(t,e){for(var n=-1,r=e.length,o=t.length;++n<r;)t[o+n]=e[n];return t}t.exports=n},function(t,e,n){function r(t,e,n){for(var r=-1,i=o(e),s=i.length;++r<s;){var a=i[r],u=t[a],l=n(u,e[a],a,t,e);(l===l?l===u:u!==u)&&(void 0!==u||a in t)||(t[a]=l)}return t}var o=n(66);t.exports=r},function(t,e,n){function r(t,e){return null==e?t:o(e,i(e),t)}var o=n(167),i=n(66);t.exports=r},function(t,e){function n(t,e,n){n||(n={});for(var r=-1,o=e.length;++r<o;){var i=e[r];n[i]=t[i]}return n}t.exports=n},function(t,e,n){function r(t,e,n,l){l||(l=[]);for(var c=-1,p=t.length;++c<p;){var f=t[c];u(f)&&a(f)&&(n||s(f)||i(f))?e?r(f,e,n,l):o(l,f):n||(l[l.length]=f)}return l}var o=n(164),i=n(44),s=n(29),a=n(26),u=n(28);t.exports=r},function(t,e,n){var r=n(173),o=r();t.exports=o},function(t,e,n){function r(t,e){return o(t,e,i)}var o=n(169),i=n(67);t.exports=r},function(t,e){function n(t){return function(e){return null==e?void 0:e[t]}}t.exports=n},function(t,e,n){function r(t){return s(function(e,n){var r=-1,s=null==e?0:n.length,a=s>2?n[s-2]:void 0,u=s>2?n[2]:void 0,l=s>1?n[s-1]:void 0;for("function"==typeof a?(a=o(a,l,5),s-=2):(a="function"==typeof l?l:void 0,s-=a?1:0),u&&i(n[0],n[1],u)&&(a=3>s?void 0:a,s=1);++r<s;){var c=n[r];c&&t(e,c,a)}return e})}var o=n(62),i=n(175),s=n(61);t.exports=r},function(t,e,n){function r(t){return function(e,n,r){for(var i=o(e),s=r(e),a=s.length,u=t?a:-1;t?u--:++u<a;){var l=s[u];if(n(i[l],l,i)===!1)break}return e}}var o=n(64);t.exports=r},function(t,e,n){var r=n(171),o=r("length");t.exports=o},function(t,e,n){function r(t,e,n){if(!s(n))return!1;var r=typeof e;if("number"==r?o(n)&&i(e,n.length):"string"==r&&e in n){var a=n[e];return t===t?t===a:a!==a}return!1}var o=n(26),i=n(43),s=n(17);t.exports=r},function(t,e,n){function r(t,e){t=o(t);for(var n=-1,r=e.length,i={};++n<r;){var s=e[n];s in t&&(i[s]=t[s])}return i}var o=n(64);t.exports=r},function(t,e,n){function r(t,e){var n={};return o(t,function(t,r,o){e(t,r,o)&&(n[r]=t)}),n}var o=n(170);t.exports=r},function(t,e,n){function r(t){for(var e=u(t),n=e.length,r=n&&t.length,l=!!r&&a(r)&&(i(t)||o(t)),p=-1,f=[];++p<n;){var h=e[p];(l&&s(h,r)||c.call(t,h))&&f.push(h)}return f}var o=n(44),i=n(29),s=n(43),a=n(27),u=n(67),l=Object.prototype,c=l.hasOwnProperty;t.exports=r},function(t,e,n){function r(t){return o(t)&&a.call(t)==i}var o=n(17),i="[object Function]",s=Object.prototype,a=s.toString;t.exports=r},function(t,e,n){function r(t){return null==t?!1:o(t)?c.test(u.call(t)):i(t)&&s.test(t)}var o=n(179),i=n(28),s=/^\[object .+?Constructor\]$/,a=Object.prototype,u=Function.prototype.toString,l=a.hasOwnProperty,c=RegExp("^"+u.call(l).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");t.exports=r},function(t,e,n){var r=n(168),o=n(62),i=n(176),s=n(177),a=n(61),u=a(function(t,e){return null==t?{}:"function"==typeof e[0]?s(t,o(e[0],e[1],3)):i(t,r(e))});t.exports=u},function(t,e){function n(t){return t}t.exports=n},function(t,e,n){function r(t){delete t.ref}var o=n(6),i=n(30),s=n(190),a=o.createFactory(n(184)),u=n(185),l=n(189),c=n(30).unstable_renderSubtreeIntoContainer,p=s.canUseDOM?window.HTMLElement:{};t.exports=o.createClass({displayName:"Modal",statics:{setAppElement:u.setElement,injectCSS:function(){}},propTypes:{isOpen:o.PropTypes.bool.isRequired,style:o.PropTypes.shape({content:o.PropTypes.object,overlay:o.PropTypes.object}),appElement:o.PropTypes.instanceOf(p),onRequestClose:o.PropTypes.func,closeTimeoutMS:o.PropTypes.number,ariaHideApp:o.PropTypes.bool},getDefaultProps:function(){return{isOpen:!1,ariaHideApp:!0,closeTimeoutMS:0}},componentDidMount:function(){this.node=document.createElement("div"),this.node.className="ReactModalPortal",document.body.appendChild(this.node),this.renderPortal(this.props)},componentWillReceiveProps:function(t){this.renderPortal(t)},componentWillUnmount:function(){i.unmountComponentAtNode(this.node),document.body.removeChild(this.node)},renderPortal:function(t){t.isOpen?l(document.body).add("ReactModal__Body--open"):l(document.body).remove("ReactModal__Body--open"),t.ariaHideApp&&u.toggle(t.isOpen,t.appElement),r(t),this.portal=c(this,a(t),this.node)},render:function(){return o.DOM.noscript()}})},function(t,e,n){function r(t){t.stopPropagation()}var o=n(6),i=o.DOM.div,s=n(186),a=n(187),u=n(191),l={overlay:{base:"ReactModal__Overlay",afterOpen:"ReactModal__Overlay--after-open",beforeClose:"ReactModal__Overlay--before-close"},content:{base:"ReactModal__Content",afterOpen:"ReactModal__Content--after-open",beforeClose:"ReactModal__Content--before-close"}},c={overlay:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(255, 255, 255, 0.75)"},content:{position:"absolute",top:"40px",left:"40px",right:"40px",bottom:"40px",border:"1px solid #ccc",background:"#fff",overflow:"auto",WebkitOverflowScrolling:"touch",borderRadius:"4px",outline:"none",padding:"20px"}};t.exports=o.createClass({displayName:"ModalPortal",getDefaultProps:function(){return{style:{overlay:{},content:{}}}},getInitialState:function(){return{afterOpen:!1,beforeClose:!1}},componentDidMount:function(){this.props.isOpen&&(this.setFocusAfterRender(!0),this.open())},componentWillUnmount:function(){clearTimeout(this.closeTimer)},componentWillReceiveProps:function(t){!this.props.isOpen&&t.isOpen?(this.setFocusAfterRender(!0),this.open()):this.props.isOpen&&!t.isOpen&&this.close()},componentDidUpdate:function(){this.focusAfterRender&&(this.focusContent(),this.setFocusAfterRender(!1))},setFocusAfterRender:function(t){this.focusAfterRender=t},open:function(){s.setupScopedFocus(this.node),s.markForFocusLater(),this.setState({isOpen:!0},function(){this.setState({afterOpen:!0})}.bind(this))},close:function(){this.ownerHandlesClose()&&(this.props.closeTimeoutMS>0?this.closeWithTimeout():this.closeWithoutTimeout())},focusContent:function(){this.refs.content.focus()},closeWithTimeout:function(){this.setState({beforeClose:!0},function(){this.closeTimer=setTimeout(this.closeWithoutTimeout,this.props.closeTimeoutMS)}.bind(this))},closeWithoutTimeout:function(){this.setState({afterOpen:!1,beforeClose:!1},this.afterClose)},afterClose:function(){s.returnFocus(),s.teardownScopedFocus()},handleKeyDown:function(t){9==t.keyCode&&a(this.refs.content,t),27==t.keyCode&&this.requestClose()},handleOverlayClick:function(){this.ownerHandlesClose()?this.requestClose():this.focusContent()},requestClose:function(){this.ownerHandlesClose()&&this.props.onRequestClose()},ownerHandlesClose:function(){return this.props.onRequestClose},shouldBeClosed:function(){return!this.props.isOpen&&!this.state.beforeClose},buildClassName:function(t,e){var n=l[t].base;return this.state.afterOpen&&(n+=" "+l[t].afterOpen),this.state.beforeClose&&(n+=" "+l[t].beforeClose),e?n+" "+e:n},render:function(){return this.shouldBeClosed()?i():i({ref:"overlay",className:this.buildClassName("overlay",this.props.overlayClassName),style:u({},c.overlay,this.props.style.overlay||{}),onClick:this.handleOverlayClick},i({ref:"content",style:u({},c.content,this.props.style.content||{}),className:this.buildClassName("content",this.props.className),tabIndex:"-1",onClick:r,onKeyDown:this.handleKeyDown},this.props.children))}})},function(t,e){function n(t){if("string"==typeof t){var e=document.querySelectorAll(t);t="length"in e?e[0]:e}u=t||u}function r(t){s(t),(t||u).setAttribute("aria-hidden","true")}function o(t){s(t),(t||u).removeAttribute("aria-hidden")}function i(t,e){t?r(e):o(e)}function s(t){if(!t&&!u)throw new Error("react-modal: You must set an element with `Modal.setAppElement(el)` to make this accessible")}function a(){u=document.body}var u="undefined"!=typeof document?document.body:null;e.toggle=i,e.setElement=n,e.show=o,e.hide=r,e.resetForTesting=a},function(t,e,n){function r(t){u=!0}function o(t){if(u){if(u=!1,!s)return;setTimeout(function(){if(!s.contains(document.activeElement)){var t=i(s)[0]||s;t.focus()}},0)}}var i=n(68),s=null,a=null,u=!1;e.markForFocusLater=function(){a=document.activeElement},e.returnFocus=function(){try{a.focus()}catch(t){console.warn("You tried to return focus to "+a+" but it is not in the DOM anymore")}a=null},e.setupScopedFocus=function(t){s=t,window.addEventListener?(window.addEventListener("blur",r,!1),document.addEventListener("focus",o,!0)):(window.attachEvent("onBlur",r),document.attachEvent("onFocus",o))},e.teardownScopedFocus=function(){s=null,window.addEventListener?(window.removeEventListener("blur",r),document.removeEventListener("focus",o)):(window.detachEvent("onBlur",r),document.detachEvent("onFocus",o))}},function(t,e,n){var r=n(68);t.exports=function(t,e){var n=r(t),o=n[e.shiftKey?0:n.length-1],i=o===document.activeElement||t===document.activeElement;if(i){e.preventDefault();var s=n[e.shiftKey?n.length-1:0];s.focus()}}},function(t,e,n){t.exports=n(183)},function(t,e){function n(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0,r=t.length;r>n;n++)if(t[n]===e)return n;return-1}function r(t){if(!(this instanceof r))return new r(t);t||(t={}),t.nodeType&&(t={el:t}),this.opts=t,this.el=t.el||document.body,"object"!=typeof this.el&&(this.el=document.querySelector(this.el))}t.exports=function(t){return new r(t)},r.prototype.add=function(t){var e=this.el;if(e){if(""===e.className)return e.className=t;var r=e.className.split(" ");return n(r,t)>-1?r:(r.push(t),e.className=r.join(" "),r)}},r.prototype.remove=function(t){var e=this.el;if(e&&""!==e.className){var r=e.className.split(" "),o=n(r,t);return o>-1&&r.splice(o,1),e.className=r.join(" "),r}},r.prototype.has=function(t){var e=this.el;if(e){var r=e.className.split(" ");return n(r,t)>-1}},r.prototype.toggle=function(t){var e=this.el;e&&(this.has(t)?this.remove(t):this.add(t))}},function(t,e,n){var r;!function(){"use strict";var o=!("undefined"==typeof window||!window.document||!window.document.createElement),i={canUseDOM:o,canUseWorkers:"undefined"!=typeof Worker,canUseEventListeners:o&&!(!window.addEventListener&&!window.attachEvent),canUseViewport:o&&!!window.screen};r=function(){return i}.call(e,n,e,t),!(void 0!==r&&(t.exports=r))}()},function(t,e,n){function r(t,e,n){for(var r=-1,o=s(e),i=o.length;++r<i;){var a=o[r],u=t[a],l=n(u,e[a],a,t,e);(l===l?l===u:u!==u)&&(void 0!==u||a in t)||(t[a]=l)}return t}var o=n(192),i=n(194),s=n(69),a=i(function(t,e,n){return n?r(t,e,n):o(t,e)});t.exports=a},function(t,e,n){function r(t,e){return null==e?t:o(e,i(e),t)}var o=n(193),i=n(69);t.exports=r},function(t,e){function n(t,e,n){n||(n={});for(var r=-1,o=e.length;++r<o;){var i=e[r];n[i]=t[i]}return n}t.exports=n},function(t,e,n){function r(t){return s(function(e,n){var r=-1,s=null==e?0:n.length,a=s>2?n[s-2]:void 0,u=s>2?n[2]:void 0,l=s>1?n[s-1]:void 0;for("function"==typeof a?(a=o(a,l,5),s-=2):(a="function"==typeof l?l:void 0,s-=a?1:0),u&&i(n[0],n[1],u)&&(a=3>s?void 0:a,s=1);++r<s;){var c=n[r];c&&t(e,c,a)}return e})}var o=n(195),i=n(196),s=n(197);t.exports=r},function(t,e){function n(t,e,n){if("function"!=typeof t)return r;if(void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 3:return function(n,r,o){return t.call(e,n,r,o)};case 4:return function(n,r,o,i){return t.call(e,n,r,o,i)};case 5:return function(n,r,o,i,s){return t.call(e,n,r,o,i,s)}}return function(){return t.apply(e,arguments)}}function r(t){return t}t.exports=n},function(t,e){function n(t){return function(e){return null==e?void 0:e[t]}}function r(t){return null!=t&&s(c(t))}function o(t,e){return t="number"==typeof t||u.test(t)?+t:-1,e=null==e?l:e,t>-1&&t%1==0&&e>t}function i(t,e,n){if(!a(n))return!1;var i=typeof e;if("number"==i?r(n)&&o(e,n.length):"string"==i&&e in n){var s=n[e];return t===t?t===s:s!==s}return!1}function s(t){return"number"==typeof t&&t>-1&&t%1==0&&l>=t}function a(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}var u=/^\d+$/,l=9007199254740991,c=n("length");t.exports=i},function(t,e){function n(t,e){if("function"!=typeof t)throw new TypeError(r);return e=o(void 0===e?t.length-1:+e||0,0),function(){for(var n=arguments,r=-1,i=o(n.length-e,0),s=Array(i);++r<i;)s[r]=n[e+r];switch(e){case 0:return t.call(this,s);case 1:return t.call(this,n[0],s);case 2:return t.call(this,n[0],n[1],s)}var a=Array(e+1);for(r=-1;++r<e;)a[r]=n[r];return a[e]=s,t.apply(this,a)}}var r="Expected a function",o=Math.max;t.exports=n},function(t,e){function n(t){return!!t&&"object"==typeof t}function r(t,e){var n=null==t?void 0:t[e];return s(n)?n:void 0}function o(t){return i(t)&&f.call(t)==a}function i(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function s(t){return null==t?!1:o(t)?h.test(c.call(t)):n(t)&&u.test(t)}var a="[object Function]",u=/^\[object .+?Constructor\]$/,l=Object.prototype,c=Function.prototype.toString,p=l.hasOwnProperty,f=l.toString,h=RegExp("^"+c.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");t.exports=r},function(t,e){function n(t){return!!t&&"object"==typeof t}function r(t){return function(e){return null==e?void 0:e[t]}}function o(t){return null!=t&&i(p(t))}function i(t){return"number"==typeof t&&t>-1&&t%1==0&&c>=t}function s(t){return n(t)&&o(t)&&u.call(t,"callee")&&!l.call(t,"callee")}var a=Object.prototype,u=a.hasOwnProperty,l=a.propertyIsEnumerable,c=9007199254740991,p=r("length");t.exports=s},function(t,e){function n(t){return!!t&&"object"==typeof t}function r(t,e){var n=null==t?void 0:t[e];return a(n)?n:void 0}function o(t){return"number"==typeof t&&t>-1&&t%1==0&&m>=t}function i(t){return s(t)&&d.call(t)==l}function s(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function a(t){return null==t?!1:i(t)?y.test(f.call(t)):n(t)&&c.test(t)}var u="[object Array]",l="[object Function]",c=/^\[object .+?Constructor\]$/,p=Object.prototype,f=Function.prototype.toString,h=p.hasOwnProperty,d=p.toString,y=RegExp("^"+f.call(h).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),v=r(Array,"isArray"),m=9007199254740991,g=v||function(t){return n(t)&&o(t.length)&&d.call(t)==u};t.exports=g},function(t,e){t.exports=s},function(t,e){t.exports=a},function(t,e){t.exports=u}]))});

},{"cartodb-client":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/cartodb-client/index.js","d3":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/d3/d3.js","intro.js":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/intro.js/intro.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","queue-async":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/queue-async/build/queue.js","react":"react","react-dom":"react-dom","react-leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/cartodb-client/index.js":[function(require,module,exports){
module.exports = require("./src/cartodb-client");

},{"./src/cartodb-client":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/cartodb-client/src/cartodb-client.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/cartodb-client/src/cartodb-client.js":[function(require,module,exports){
(function() {
  "use strict";

  function CartoDBClient(accountName,options) {

    options = options || {};

    var that = this;

    options.apiroot     = options.apiroot      || "http://{accountName}.cartodb.com/api/v2/";
    options.format      = options.format       || "GeoJSON";
    options.accountName = options.accountName  || accountName;

    //
    // Request remote data
    //
    function request(uri, callback) {

      if (window && window.XMLHttpRequest) {
        var xmlHttp = null;

        xmlHttp = new window.XMLHttpRequest();

        xmlHttp.onreadystatechange = function() {
          if ((xmlHttp.readyState|0) === 4) {
            if ((xmlHttp.status|0) === 200 ) {

              callback(null, xmlHttp);
            } else {
              callback(xmlHttp);
            }
          }
        };

        xmlHttp.open( "GET", uri, true );
        return xmlHttp.send( null );
      } else {
        return false;
      }
    }

    //
    // Build a string from a template and data
    //
    function buildTemplate(template, data) {
      var outString = template;

      for (var i in data) {
        if (data.hasOwnProperty(i)) {
          outString = outString.split("{" + i + "}").join(data[i]);
        }
      }

      return outString;
    }

    //
    // Request from the CartoDb SQL endpoint
    //
    function sqlRequest(sql, callback, _options) {

      _options = _options || {};

      //
      // Override defaults
      //
      if (Object.keys(_options).length) {
        for (var i in _options) {

          if (_options.hasOwnProperty(i)) {

            options[i] = _options[i];

          }

        }
      }

      var url = buildTemplate([
        buildTemplate(options.apiroot, options),
        "sql",
        "?format=" + options.format,
        "&q=" + sql
      ].join(""), options);

      if (options.dangerouslyExposedAPIKey) {
        console.warn("Exposing API key in URL! Do not push this to production.");
        url += ("&api_key=" + options.dangerouslyExposedAPIKey);
      }

      return request(url,
        function (err, response) {

          try {
            callback(err, JSON.parse(response.responseText), response);
          } catch (err) {
            callback(err, null, response);
          }

        }
      );

    }

    //
    // Promise request
    function requestPromise(params) {
      var opts = normalizeOptions(params.options);

      var url = (params.sql) ? buildTemplate([
                  buildTemplate(opts.apiroot, opts),
                  "sql",
                  "?format=" + opts.format,
                  "&q=" + params.sql
                ].join(""), opts) : params.url;

      var key = params.key;


      return new Promise(function(resolve, reject) {

        if (window && window.XMLHttpRequest) {
          // Do the usual XHR stuff
          var req = new XMLHttpRequest();
          req.open('GET', url);

          req.onload = function() {
            // This is called even on 404 etc
            // so check the status
            if (req.status == 200) {
              // Resolve the promise with the response text
              return resolve({
                payload: req.response || req.responseText,
                id: key
              });
            }
            else {
              // Otherwise reject with the status text
              // which will hopefully be a meaningful error
              reject({
                payload: Error(req.statusText),
                id: key
              });
            }
          };

          // Handle network errors
          req.onerror = function() {
            reject({
              payload: Error("Network Error"),
              id: key
            });
          };

          // Make the request
          req.send();

        } else {
          reject({
            payload: Error("XMLHttpRequest not supported"),
            id: key
          });
        }
      });



    }

    //
    //
    //
    function normalizeOptions(_options) {
      _options = _options || {};

      var rsp = {};
      for (var key in options) {
        var value = (_options.hasOwnProperty(key)) ? _options[key] : options[key];
        rsp[key] = value;
      }

      return rsp;
    }

    //
    // Public interface
    //
    that.sqlRequest = sqlRequest;
    that.requestPromise = requestPromise;
    that.requestPromiseParallel = function(queue) {
      return Promise.all(
        queue.map(function(q){
          return requestPromise(q).then(function(rsp) {
            return {
              response: rsp,
              key: rsp.id
            };
          }).catch(function(err) {
            return err;
          });
        })
      )
    };

    that.requestPromiseJSON = function(params) {
      return requestPromise(params).then(function(rsp) {
        return {
          response: JSON.parse(rsp.payload),
          key: rsp.id
        };
      }).catch(function(err) {
        return err;
      });
    };

    that.requestPromiseParallelJSON = function(queue) {
      return Promise.all(
        queue.map(that.requestPromiseJSON)
      )
    };

    return that;

  }



  //
  // If this is a CommonJS module
  //
  if (typeof module === "object" && module.exports) {
    module.exports = CartoDBClient;
  }

  //
  // If this is an AMD module
  //
  if (typeof define === "function") {
    define(CartoDBClient);
  }

  //
  // If just exports and it's an object
  //
  if (typeof module !== "object" && typeof exports === "object") {
    exports.CartoDBClient = CartoDBClient;
  }

  //
  // If none of those, add it to Window (as long as there is nothing named samesies)
  //
  if (typeof define !== "function" && typeof window === "object") {
    if (!window.STMN) {
      window.STMN = {};
    }
    window.STMN.CartoDBClient = CartoDBClient;
  }

}());
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/d3/d3.js":[function(require,module,exports){
!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/flux/lib/Dispatcher.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))

},{"_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js","fbjs/lib/invariant":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/flux/node_modules/fbjs/lib/invariant.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/flux/node_modules/fbjs/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/intro.js/intro.js":[function(require,module,exports){
/**
 * Intro.js v1.1.1
 * https://github.com/usablica/intro.js
 * MIT licensed
 *
 * Copyright (C) 2013 usabli.ca - A weekend project by Afshin Mehrabani (@afshinmeh)
 */

(function (root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports);
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['exports'], factory);
  } else {
    // Browser globals
    factory(root);
  }
} (this, function (exports) {
  //Default config/variables
  var VERSION = '1.1.1';

  /**
   * IntroJs main class
   *
   * @class IntroJs
   */
  function IntroJs(obj) {
    this._targetElement = obj;

    this._options = {
      /* Next button label in tooltip box */
      nextLabel: 'Next &rarr;',
      /* Previous button label in tooltip box */
      prevLabel: '&larr; Back',
      /* Skip button label in tooltip box */
      skipLabel: 'Skip',
      /* Done button label in tooltip box */
      doneLabel: 'Done',
      /* Default tooltip box position */
      tooltipPosition: 'bottom',
      /* Next CSS class for tooltip boxes */
      tooltipClass: '',
      /* CSS class that is added to the helperLayer */
      highlightClass: '',
      /* Close introduction when pressing Escape button? */
      exitOnEsc: true,
      /* Close introduction when clicking on overlay layer? */
      exitOnOverlayClick: true,
      /* Show step numbers in introduction? */
      showStepNumbers: true,
      /* Let user use keyboard to navigate the tour? */
      keyboardNavigation: true,
      /* Show tour control buttons? */
      showButtons: true,
      /* Show tour bullets? */
      showBullets: true,
      /* Show tour progress? */
      showProgress: false,
      /* Scroll to highlighted element? */
      scrollToElement: true,
      /* Set the overlay opacity */
      overlayOpacity: 0.8,
      /* Precedence of positions, when auto is enabled */
      positionPrecedence: ["bottom", "top", "right", "left"],
      /* Disable an interaction with element? */
      disableInteraction: false
    };
  }

  /**
   * Initiate a new introduction/guide from an element in the page
   *
   * @api private
   * @method _introForElement
   * @param {Object} targetElm
   * @returns {Boolean} Success or not?
   */
  function _introForElement(targetElm) {
    var introItems = [],
        self = this;

    if (this._options.steps) {
      //use steps passed programmatically
      for (var i = 0, stepsLength = this._options.steps.length; i < stepsLength; i++) {
        var currentItem = _cloneObject(this._options.steps[i]);
        //set the step
        currentItem.step = introItems.length + 1;
        //use querySelector function only when developer used CSS selector
        if (typeof(currentItem.element) === 'string') {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        }

        //intro without element
        if (typeof(currentItem.element) === 'undefined' || currentItem.element == null) {
          var floatingElementQuery = document.querySelector(".introjsFloatingElement");

          if (floatingElementQuery == null) {
            floatingElementQuery = document.createElement('div');
            floatingElementQuery.className = 'introjsFloatingElement';

            document.body.appendChild(floatingElementQuery);
          }

          currentItem.element  = floatingElementQuery;
          currentItem.position = 'floating';
        }

        if (currentItem.element != null) {
          introItems.push(currentItem);
        }
      }

    } else {
      //use steps from data-* annotations
      var allIntroSteps = targetElm.querySelectorAll('*[data-intro]');
      //if there's no element to intro
      if (allIntroSteps.length < 1) {
        return false;
      }

      //first add intro items with data-step
      for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
        var currentElement = allIntroSteps[i];
        var step = parseInt(currentElement.getAttribute('data-step'), 10);

        if (step > 0) {
          introItems[step - 1] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: parseInt(currentElement.getAttribute('data-step'), 10),
            tooltipClass: currentElement.getAttribute('data-tooltipClass'),
            highlightClass: currentElement.getAttribute('data-highlightClass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
          };
        }
      }

      //next add intro items without data-step
      //todo: we need a cleanup here, two loops are redundant
      var nextStep = 0;
      for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
        var currentElement = allIntroSteps[i];

        if (currentElement.getAttribute('data-step') == null) {

          while (true) {
            if (typeof introItems[nextStep] == 'undefined') {
              break;
            } else {
              nextStep++;
            }
          }

          introItems[nextStep] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: nextStep + 1,
            tooltipClass: currentElement.getAttribute('data-tooltipClass'),
            highlightClass: currentElement.getAttribute('data-highlightClass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
          };
        }
      }
    }

    //removing undefined/null elements
    var tempIntroItems = [];
    for (var z = 0; z < introItems.length; z++) {
      introItems[z] && tempIntroItems.push(introItems[z]);  // copy non-empty values to the end of the array
    }

    introItems = tempIntroItems;

    //Ok, sort all items with given steps
    introItems.sort(function (a, b) {
      return a.step - b.step;
    });

    //set it to the introJs object
    self._introItems = introItems;

    //add overlay layer to the page
    if(_addOverlayLayer.call(self, targetElm)) {
      //then, start the show
      _nextStep.call(self);

      var skipButton     = targetElm.querySelector('.introjs-skipbutton'),
          nextStepButton = targetElm.querySelector('.introjs-nextbutton');

      self._onKeyDown = function(e) {
        if (e.keyCode === 27 && self._options.exitOnEsc == true) {
          //escape key pressed, exit the intro
          //check if exit callback is defined
          if (self._introExitCallback != undefined) {
            self._introExitCallback.call(self);
          }
          _exitIntro.call(self, targetElm);
        } else if(e.keyCode === 37) {
          //left arrow
          _previousStep.call(self);
        } else if (e.keyCode === 39) {
          //right arrow
          _nextStep.call(self);
        } else if (e.keyCode === 13) {
          //srcElement === ie
          var target = e.target || e.srcElement;
          if (target && target.className.indexOf('introjs-prevbutton') > 0) {
            //user hit enter while focusing on previous button
            _previousStep.call(self);
          } else if (target && target.className.indexOf('introjs-skipbutton') > 0) {
            //user hit enter while focusing on skip button
            if (self._introItems.length - 1 == self._currentStep && typeof (self._introCompleteCallback) === 'function') {
                self._introCompleteCallback.call(self);
            }
            //check if any callback is defined
            if (self._introExitCallback != undefined) {
              self._introExitCallback.call(self);
            }
            _exitIntro.call(self, targetElm);
          } else {
            //default behavior for responding to enter
            _nextStep.call(self);
          }

          //prevent default behaviour on hitting Enter, to prevent steps being skipped in some browsers
          if(e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }
      };

      self._onResize = function(e) {
        _setHelperLayerPosition.call(self, document.querySelector('.introjs-helperLayer'));
        _setHelperLayerPosition.call(self, document.querySelector('.introjs-tooltipReferenceLayer'));
      };

      if (window.addEventListener) {
        if (this._options.keyboardNavigation) {
          window.addEventListener('keydown', self._onKeyDown, true);
        }
        //for window resize
        window.addEventListener('resize', self._onResize, true);
      } else if (document.attachEvent) { //IE
        if (this._options.keyboardNavigation) {
          document.attachEvent('onkeydown', self._onKeyDown);
        }
        //for window resize
        document.attachEvent('onresize', self._onResize);
      }
    }
    return false;
  }

 /*
   * makes a copy of the object
   * @api private
   * @method _cloneObject
  */
  function _cloneObject(object) {
      if (object == null || typeof (object) != 'object' || typeof (object.nodeType) != 'undefined') {
        return object;
      }
      var temp = {};
      for (var key in object) {
        if (typeof (jQuery) != 'undefined' && object[key] instanceof jQuery) {
          temp[key] = object[key];
        } else {
          temp[key] = _cloneObject(object[key]);
        }
      }
      return temp;
  }
  /**
   * Go to specific step of introduction
   *
   * @api private
   * @method _goToStep
   */
  function _goToStep(step) {
    //because steps starts with zero
    this._currentStep = step - 2;
    if (typeof (this._introItems) !== 'undefined') {
      _nextStep.call(this);
    }
  }

  /**
   * Go to next step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _nextStep() {
    this._direction = 'forward';

    if (typeof (this._currentStep) === 'undefined') {
      this._currentStep = 0;
    } else {
      ++this._currentStep;
    }

    if ((this._introItems.length) <= this._currentStep) {
      //end of the intro
      //check if any callback is defined
      if (typeof (this._introCompleteCallback) === 'function') {
        this._introCompleteCallback.call(this);
      }
      _exitIntro.call(this, this._targetElement);
      return;
    }

    var nextStep = this._introItems[this._currentStep];
    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Go to previous step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _previousStep() {
    this._direction = 'backward';

    if (this._currentStep === 0) {
      return false;
    }

    var nextStep = this._introItems[--this._currentStep];
    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Exit from intro
   *
   * @api private
   * @method _exitIntro
   * @param {Object} targetElement
   */
  function _exitIntro(targetElement) {
    //remove overlay layer from the page
    var overlayLayer = targetElement.querySelector('.introjs-overlay');

    //return if intro already completed or skipped
    if (overlayLayer == null) {
      return;
    }

    //for fade-out animation
    overlayLayer.style.opacity = 0;
    setTimeout(function () {
      if (overlayLayer.parentNode) {
        overlayLayer.parentNode.removeChild(overlayLayer);
      }
    }, 500);

    //remove all helper layers
    var helperLayer = targetElement.querySelector('.introjs-helperLayer');
    if (helperLayer) {
      helperLayer.parentNode.removeChild(helperLayer);
    }

    var referenceLayer = targetElement.querySelector('.introjs-tooltipReferenceLayer');
    if (referenceLayer) {
      referenceLayer.parentNode.removeChild(referenceLayer);
    }
    //remove disableInteractionLayer
    var disableInteractionLayer = targetElement.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer) {
      disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
    }

    //remove intro floating element
    var floatingElement = document.querySelector('.introjsFloatingElement');
    if (floatingElement) {
      floatingElement.parentNode.removeChild(floatingElement);
    }

    //remove `introjs-showElement` class from the element
    var showElement = document.querySelector('.introjs-showElement');
    if (showElement) {
      showElement.className = showElement.className.replace(/introjs-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, ''); // This is a manual trim.
    }

    //remove `introjs-fixParent` class from the elements
    var fixParents = document.querySelectorAll('.introjs-fixParent');
    if (fixParents && fixParents.length > 0) {
      for (var i = fixParents.length - 1; i >= 0; i--) {
        fixParents[i].className = fixParents[i].className.replace(/introjs-fixParent/g, '').replace(/^\s+|\s+$/g, '');
      }
    }

    //clean listeners
    if (window.removeEventListener) {
      window.removeEventListener('keydown', this._onKeyDown, true);
    } else if (document.detachEvent) { //IE
      document.detachEvent('onkeydown', this._onKeyDown);
    }

    //set the step to zero
    this._currentStep = undefined;
  }

  /**
   * Render tooltip box in the page
   *
   * @api private
   * @method _placeTooltip
   * @param {HTMLElement} targetElement
   * @param {HTMLElement} tooltipLayer
   * @param {HTMLElement} arrowLayer
   * @param {HTMLElement} helperNumberLayer
   */
  function _placeTooltip(targetElement, tooltipLayer, arrowLayer, helperNumberLayer) {
    var tooltipCssClass = '',
        currentStepObj,
        tooltipOffset,
        targetOffset,
        windowSize,
        currentTooltipPosition;

    //reset the old style
    tooltipLayer.style.top        = null;
    tooltipLayer.style.right      = null;
    tooltipLayer.style.bottom     = null;
    tooltipLayer.style.left       = null;
    tooltipLayer.style.marginLeft = null;
    tooltipLayer.style.marginTop  = null;

    arrowLayer.style.display = 'inherit';

    if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
      helperNumberLayer.style.top  = null;
      helperNumberLayer.style.left = null;
    }

    //prevent error when `this._currentStep` is undefined
    if (!this._introItems[this._currentStep]) return;

    //if we have a custom css class for each step
    currentStepObj = this._introItems[this._currentStep];
    if (typeof (currentStepObj.tooltipClass) === 'string') {
      tooltipCssClass = currentStepObj.tooltipClass;
    } else {
      tooltipCssClass = this._options.tooltipClass;
    }

    tooltipLayer.className = ('introjs-tooltip ' + tooltipCssClass).replace(/^\s+|\s+$/g, '');

    currentTooltipPosition = this._introItems[this._currentStep].position;
    if ((currentTooltipPosition == "auto" || this._options.tooltipPosition == "auto")) {
      if (currentTooltipPosition != "floating") { // Floating is always valid, no point in calculating
        currentTooltipPosition = _determineAutoPosition.call(this, targetElement, tooltipLayer, currentTooltipPosition);
      }
    }
    targetOffset  = _getOffset(targetElement);
    tooltipOffset = _getOffset(tooltipLayer);
    windowSize    = _getWinSize();
    switch (currentTooltipPosition) {
      case 'top':
        arrowLayer.className = 'introjs-arrow bottom';

        var tooltipLayerStyleLeft = 15;
        _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.bottom = (targetOffset.height +  20) + 'px';
        break;
      case 'right':
        tooltipLayer.style.left = (targetOffset.width + 20) + 'px';
        if (targetOffset.top + tooltipOffset.height > windowSize.height) {
          // In this case, right would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          arrowLayer.className = "introjs-arrow left-bottom";
          tooltipLayer.style.top = "-" + (tooltipOffset.height - targetOffset.height - 20) + "px";
        } else {
          arrowLayer.className = 'introjs-arrow left';
        }
        break;
      case 'left':
        if (this._options.showStepNumbers == true) {
          tooltipLayer.style.top = '15px';
        }

        if (targetOffset.top + tooltipOffset.height > windowSize.height) {
          // In this case, left would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          tooltipLayer.style.top = "-" + (tooltipOffset.height - targetOffset.height - 20) + "px";
          arrowLayer.className = 'introjs-arrow right-bottom';
        } else {
          arrowLayer.className = 'introjs-arrow right';
        }
        tooltipLayer.style.right = (targetOffset.width + 20) + 'px';

        break;
      case 'floating':
        arrowLayer.style.display = 'none';

        //we have to adjust the top and left of layer manually for intro items without element
        tooltipLayer.style.left   = '50%';
        tooltipLayer.style.top    = '50%';
        tooltipLayer.style.marginLeft = '-' + (tooltipOffset.width / 2)  + 'px';
        tooltipLayer.style.marginTop  = '-' + (tooltipOffset.height / 2) + 'px';

        if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
          helperNumberLayer.style.left = '-' + ((tooltipOffset.width / 2) + 18) + 'px';
          helperNumberLayer.style.top  = '-' + ((tooltipOffset.height / 2) + 18) + 'px';
        }

        break;
      case 'bottom-right-aligned':
        arrowLayer.className      = 'introjs-arrow top-right';

        var tooltipLayerStyleRight = 0;
        _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
        tooltipLayer.style.top    = (targetOffset.height +  20) + 'px';
        break;

      case 'bottom-middle-aligned':
        arrowLayer.className      = 'introjs-arrow top-middle';

        var tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2;
        if (_checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
          tooltipLayer.style.right = null;
          _checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
        }
        tooltipLayer.style.top = (targetOffset.height + 20) + 'px';
        break;

      case 'bottom-left-aligned':
      // Bottom-left-aligned is the same as the default bottom
      case 'bottom':
      // Bottom going to follow the default behavior
      default:
        arrowLayer.className = 'introjs-arrow top';

        var tooltipLayerStyleLeft = 0;
        _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.top    = (targetOffset.height +  20) + 'px';
        break;
    }
  }

  /**
   * Set tooltip left so it doesn't go off the right side of the window
   *
   * @return boolean true, if tooltipLayerStyleLeft is ok.  false, otherwise.
   */
  function _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer) {
    if (targetOffset.left + tooltipLayerStyleLeft + tooltipOffset.width > windowSize.width) {
      // off the right side of the window
      tooltipLayer.style.left = (windowSize.width - tooltipOffset.width - targetOffset.left) + 'px';
      return false;
    }
    tooltipLayer.style.left = tooltipLayerStyleLeft + 'px';
    return true;
  }

  /**
   * Set tooltip right so it doesn't go off the left side of the window
   *
   * @return boolean true, if tooltipLayerStyleRight is ok.  false, otherwise.
   */
  function _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer) {
    if (targetOffset.left + targetOffset.width - tooltipLayerStyleRight - tooltipOffset.width < 0) {
      // off the left side of the window
      tooltipLayer.style.left = (-targetOffset.left) + 'px';
      return false;
    }
    tooltipLayer.style.right = tooltipLayerStyleRight + 'px';
    return true;
  }

  /**
   * Determines the position of the tooltip based on the position precedence and availability
   * of screen space.
   *
   * @param {Object} targetElement
   * @param {Object} tooltipLayer
   * @param {Object} desiredTooltipPosition
   *
   */
  function _determineAutoPosition(targetElement, tooltipLayer, desiredTooltipPosition) {

    // Take a clone of position precedence. These will be the available
    var possiblePositions = this._options.positionPrecedence.slice();

    var windowSize = _getWinSize();
    var tooltipHeight = _getOffset(tooltipLayer).height + 10;
    var tooltipWidth = _getOffset(tooltipLayer).width + 20;
    var targetOffset = _getOffset(targetElement);

    // If we check all the possible areas, and there are no valid places for the tooltip, the element
    // must take up most of the screen real estate. Show the tooltip floating in the middle of the screen.
    var calculatedPosition = "floating";

    // Check if the width of the tooltip + the starting point would spill off the right side of the screen
    // If no, neither bottom or top are valid
    if (targetOffset.left + tooltipWidth > windowSize.width || ((targetOffset.left + (targetOffset.width / 2)) - tooltipWidth) < 0) {
      _removeEntry(possiblePositions, "bottom");
      _removeEntry(possiblePositions, "top");
    } else {
      // Check for space below
      if ((targetOffset.height + targetOffset.top + tooltipHeight) > windowSize.height) {
        _removeEntry(possiblePositions, "bottom");
      }

      // Check for space above
      if (targetOffset.top - tooltipHeight < 0) {
        _removeEntry(possiblePositions, "top");
      }
    }

    // Check for space to the right
    if (targetOffset.width + targetOffset.left + tooltipWidth > windowSize.width) {
      _removeEntry(possiblePositions, "right");
    }

    // Check for space to the left
    if (targetOffset.left - tooltipWidth < 0) {
      _removeEntry(possiblePositions, "left");
    }

    // At this point, our array only has positions that are valid. Pick the first one, as it remains in order
    if (possiblePositions.length > 0) {
      calculatedPosition = possiblePositions[0];
    }

    // If the requested position is in the list, replace our calculated choice with that
    if (desiredTooltipPosition && desiredTooltipPosition != "auto") {
      if (possiblePositions.indexOf(desiredTooltipPosition) > -1) {
        calculatedPosition = desiredTooltipPosition;
      }
    }

    return calculatedPosition;
  }

  /**
   * Remove an entry from a string array if it's there, does nothing if it isn't there.
   *
   * @param {Array} stringArray
   * @param {String} stringToRemove
   */
  function _removeEntry(stringArray, stringToRemove) {
    if (stringArray.indexOf(stringToRemove) > -1) {
      stringArray.splice(stringArray.indexOf(stringToRemove), 1);
    }
  }

  /**
   * Update the position of the helper layer on the screen
   *
   * @api private
   * @method _setHelperLayerPosition
   * @param {Object} helperLayer
   */
  function _setHelperLayerPosition(helperLayer) {
    if (helperLayer) {
      //prevent error when `this._currentStep` in undefined
      if (!this._introItems[this._currentStep]) return;

      var currentElement  = this._introItems[this._currentStep],
          elementPosition = _getOffset(currentElement.element),
          widthHeightPadding = 10;

      if (currentElement.position == 'floating') {
        widthHeightPadding = 0;
      }

      //set new position to helper layer
      helperLayer.setAttribute('style', 'width: ' + (elementPosition.width  + widthHeightPadding)  + 'px; ' +
                                        'height:' + (elementPosition.height + widthHeightPadding)  + 'px; ' +
                                        'top:'    + (elementPosition.top    - 5)   + 'px;' +
                                        'left: '  + (elementPosition.left   - 5)   + 'px;');

    }
  }

  /**
   * Add disableinteraction layer and adjust the size and position of the layer
   *
   * @api private
   * @method _disableInteraction
   */
  function _disableInteraction () {
    var disableInteractionLayer = document.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer === null) {
      disableInteractionLayer = document.createElement('div');
      disableInteractionLayer.className = 'introjs-disableInteraction';
      this._targetElement.appendChild(disableInteractionLayer);
    }

    _setHelperLayerPosition.call(this, disableInteractionLayer);
  }

  /**
   * Show an element on the page
   *
   * @api private
   * @method _showElement
   * @param {Object} targetElement
   */
  function _showElement(targetElement) {

    if (typeof (this._introChangeCallback) !== 'undefined') {
      this._introChangeCallback.call(this, targetElement.element);
    }

    var self = this,
        oldHelperLayer = document.querySelector('.introjs-helperLayer'),
        oldReferenceLayer = document.querySelector('.introjs-tooltipReferenceLayer'),
        highlightClass = 'introjs-helperLayer',
        elementPosition = _getOffset(targetElement.element);

    //check for a current step highlight class
    if (typeof (targetElement.highlightClass) === 'string') {
      highlightClass += (' ' + targetElement.highlightClass);
    }
    //check for options highlight class
    if (typeof (this._options.highlightClass) === 'string') {
      highlightClass += (' ' + this._options.highlightClass);
    }

    if (oldHelperLayer != null) {
      var oldHelperNumberLayer = oldReferenceLayer.querySelector('.introjs-helperNumberLayer'),
          oldtooltipLayer      = oldReferenceLayer.querySelector('.introjs-tooltiptext'),
          oldArrowLayer        = oldReferenceLayer.querySelector('.introjs-arrow'),
          oldtooltipContainer  = oldReferenceLayer.querySelector('.introjs-tooltip'),
          skipTooltipButton    = oldReferenceLayer.querySelector('.introjs-skipbutton'),
          prevTooltipButton    = oldReferenceLayer.querySelector('.introjs-prevbutton'),
          nextTooltipButton    = oldReferenceLayer.querySelector('.introjs-nextbutton');

      //update or reset the helper highlight class
      oldHelperLayer.className = highlightClass;
      //hide the tooltip
      oldtooltipContainer.style.opacity = 0;
      oldtooltipContainer.style.display = "none";

      if (oldHelperNumberLayer != null) {
        var lastIntroItem = this._introItems[(targetElement.step - 2 >= 0 ? targetElement.step - 2 : 0)];

        if (lastIntroItem != null && (this._direction == 'forward' && lastIntroItem.position == 'floating') || (this._direction == 'backward' && targetElement.position == 'floating')) {
          oldHelperNumberLayer.style.opacity = 0;
        }
      }

      //set new position to helper layer
      _setHelperLayerPosition.call(self, oldHelperLayer);
      _setHelperLayerPosition.call(self, oldReferenceLayer);

      //remove `introjs-fixParent` class from the elements
      var fixParents = document.querySelectorAll('.introjs-fixParent');
      if (fixParents && fixParents.length > 0) {
        for (var i = fixParents.length - 1; i >= 0; i--) {
          fixParents[i].className = fixParents[i].className.replace(/introjs-fixParent/g, '').replace(/^\s+|\s+$/g, '');
        };
      }

      //remove old classes
      var oldShowElement = document.querySelector('.introjs-showElement');
      oldShowElement.className = oldShowElement.className.replace(/introjs-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, '');

      //we should wait until the CSS3 transition is competed (it's 0.3 sec) to prevent incorrect `height` and `width` calculation
      if (self._lastShowElementTimer) {
        clearTimeout(self._lastShowElementTimer);
      }
      self._lastShowElementTimer = setTimeout(function() {
        //set current step to the label
        if (oldHelperNumberLayer != null) {
          oldHelperNumberLayer.innerHTML = targetElement.step;
        }
        //set current tooltip text
        oldtooltipLayer.innerHTML = targetElement.intro;
        //set the tooltip position
        oldtooltipContainer.style.display = "block";
        _placeTooltip.call(self, targetElement.element, oldtooltipContainer, oldArrowLayer, oldHelperNumberLayer);

        //change active bullet
        oldReferenceLayer.querySelector('.introjs-bullets li > a.active').className = '';
        oldReferenceLayer.querySelector('.introjs-bullets li > a[data-stepnumber="' + targetElement.step + '"]').className = 'active';

        oldReferenceLayer.querySelector('.introjs-progress .introjs-progressbar').setAttribute('style', 'width:' + _getProgress.call(self) + '%;');

        //show the tooltip
        oldtooltipContainer.style.opacity = 1;
        if (oldHelperNumberLayer) oldHelperNumberLayer.style.opacity = 1;

        //reset button focus
        if (nextTooltipButton.tabIndex === -1) {
          //tabindex of -1 means we are at the end of the tour - focus on skip / done
          skipTooltipButton.focus();
        } else {
          //still in the tour, focus on next
          nextTooltipButton.focus();
        }
      }, 350);

    } else {
      var helperLayer       = document.createElement('div'),
          referenceLayer    = document.createElement('div'),
          arrowLayer        = document.createElement('div'),
          tooltipLayer      = document.createElement('div'),
          tooltipTextLayer  = document.createElement('div'),
          bulletsLayer      = document.createElement('div'),
          progressLayer     = document.createElement('div'),
          buttonsLayer      = document.createElement('div');

      helperLayer.className = highlightClass;
      referenceLayer.className = 'introjs-tooltipReferenceLayer';

      //set new position to helper layer
      _setHelperLayerPosition.call(self, helperLayer);
      _setHelperLayerPosition.call(self, referenceLayer);

      //add helper layer to target element
      this._targetElement.appendChild(helperLayer);
      this._targetElement.appendChild(referenceLayer);

      arrowLayer.className = 'introjs-arrow';

      tooltipTextLayer.className = 'introjs-tooltiptext';
      tooltipTextLayer.innerHTML = targetElement.intro;

      bulletsLayer.className = 'introjs-bullets';

      if (this._options.showBullets === false) {
        bulletsLayer.style.display = 'none';
      }

      var ulContainer = document.createElement('ul');

      for (var i = 0, stepsLength = this._introItems.length; i < stepsLength; i++) {
        var innerLi    = document.createElement('li');
        var anchorLink = document.createElement('a');

        anchorLink.onclick = function() {
          self.goToStep(this.getAttribute('data-stepnumber'));
        };

        if (i === (targetElement.step-1)) anchorLink.className = 'active';

        anchorLink.href = 'javascript:void(0);';
        anchorLink.innerHTML = "&nbsp;";
        anchorLink.setAttribute('data-stepnumber', this._introItems[i].step);

        innerLi.appendChild(anchorLink);
        ulContainer.appendChild(innerLi);
      }

      bulletsLayer.appendChild(ulContainer);

      progressLayer.className = 'introjs-progress';

      if (this._options.showProgress === false) {
        progressLayer.style.display = 'none';
      }
      var progressBar = document.createElement('div');
      progressBar.className = 'introjs-progressbar';
      progressBar.setAttribute('style', 'width:' + _getProgress.call(this) + '%;');

      progressLayer.appendChild(progressBar);

      buttonsLayer.className = 'introjs-tooltipbuttons';
      if (this._options.showButtons === false) {
        buttonsLayer.style.display = 'none';
      }

      tooltipLayer.className = 'introjs-tooltip';
      tooltipLayer.appendChild(tooltipTextLayer);
      tooltipLayer.appendChild(bulletsLayer);
      tooltipLayer.appendChild(progressLayer);

      //add helper layer number
      if (this._options.showStepNumbers == true) {
        var helperNumberLayer = document.createElement('span');
        helperNumberLayer.className = 'introjs-helperNumberLayer';
        helperNumberLayer.innerHTML = targetElement.step;
        referenceLayer.appendChild(helperNumberLayer);
      }

      tooltipLayer.appendChild(arrowLayer);
      referenceLayer.appendChild(tooltipLayer);

      //next button
      var nextTooltipButton = document.createElement('a');

      nextTooltipButton.onclick = function() {
        if (self._introItems.length - 1 != self._currentStep) {
          _nextStep.call(self);
        }
      };

      nextTooltipButton.href = 'javascript:void(0);';
      nextTooltipButton.innerHTML = this._options.nextLabel;

      //previous button
      var prevTooltipButton = document.createElement('a');

      prevTooltipButton.onclick = function() {
        if (self._currentStep != 0) {
          _previousStep.call(self);
        }
      };

      prevTooltipButton.href = 'javascript:void(0);';
      prevTooltipButton.innerHTML = this._options.prevLabel;

      //skip button
      var skipTooltipButton = document.createElement('a');
      skipTooltipButton.className = 'introjs-button introjs-skipbutton';
      skipTooltipButton.href = 'javascript:void(0);';
      skipTooltipButton.innerHTML = this._options.skipLabel;

      skipTooltipButton.onclick = function() {
        if (self._introItems.length - 1 == self._currentStep && typeof (self._introCompleteCallback) === 'function') {
          self._introCompleteCallback.call(self);
        }

        if (self._introItems.length - 1 != self._currentStep && typeof (self._introExitCallback) === 'function') {
          self._introExitCallback.call(self);
        }

        _exitIntro.call(self, self._targetElement);
      };

      buttonsLayer.appendChild(skipTooltipButton);

      //in order to prevent displaying next/previous button always
      if (this._introItems.length > 1) {
        buttonsLayer.appendChild(prevTooltipButton);
        buttonsLayer.appendChild(nextTooltipButton);
      }

      tooltipLayer.appendChild(buttonsLayer);

      //set proper position
      _placeTooltip.call(self, targetElement.element, tooltipLayer, arrowLayer, helperNumberLayer);
    }

    //disable interaction
    if (this._options.disableInteraction === true) {
      _disableInteraction.call(self);
    }

    prevTooltipButton.removeAttribute('tabIndex');
    nextTooltipButton.removeAttribute('tabIndex');

    if (this._currentStep == 0 && this._introItems.length > 1) {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton introjs-disabled';
      prevTooltipButton.tabIndex = '-1';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton';
      skipTooltipButton.innerHTML = this._options.skipLabel;
    } else if (this._introItems.length - 1 == this._currentStep || this._introItems.length == 1) {
      skipTooltipButton.innerHTML = this._options.doneLabel;
      prevTooltipButton.className = 'introjs-button introjs-prevbutton';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton introjs-disabled';
      nextTooltipButton.tabIndex = '-1';
    } else {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton';
      skipTooltipButton.innerHTML = this._options.skipLabel;
    }

    //Set focus on "next" button, so that hitting Enter always moves you onto the next step
    nextTooltipButton.focus();

    //add target element position style
    targetElement.element.className += ' introjs-showElement';

    var currentElementPosition = _getPropValue(targetElement.element, 'position');
    if (currentElementPosition !== 'absolute' &&
        currentElementPosition !== 'relative') {
      //change to new intro item
      targetElement.element.className += ' introjs-relativePosition';
    }

    var parentElm = targetElement.element.parentNode;
    while (parentElm != null) {
      if (parentElm.tagName.toLowerCase() === 'body') break;

      //fix The Stacking Contenxt problem.
      //More detail: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
      var zIndex = _getPropValue(parentElm, 'z-index');
      var opacity = parseFloat(_getPropValue(parentElm, 'opacity'));
      var transform = _getPropValue(parentElm, 'transform') || _getPropValue(parentElm, '-webkit-transform') || _getPropValue(parentElm, '-moz-transform') || _getPropValue(parentElm, '-ms-transform') || _getPropValue(parentElm, '-o-transform');
      if (/[0-9]+/.test(zIndex) || opacity < 1 || (transform !== 'none' && transform !== undefined)) {
        parentElm.className += ' introjs-fixParent';
      }

      parentElm = parentElm.parentNode;
    }

    if (!_elementInViewport(targetElement.element) && this._options.scrollToElement === true) {
      var rect = targetElement.element.getBoundingClientRect(),
        winHeight = _getWinSize().height,
        top = rect.bottom - (rect.bottom - rect.top),
        bottom = rect.bottom - winHeight;

      //Scroll up
      if (top < 0 || targetElement.element.clientHeight > winHeight) {
        window.scrollBy(0, top - 30); // 30px padding from edge to look nice

      //Scroll down
      } else {
        window.scrollBy(0, bottom + 100); // 70px + 30px padding from edge to look nice
      }
    }

    if (typeof (this._introAfterChangeCallback) !== 'undefined') {
      this._introAfterChangeCallback.call(this, targetElement.element);
    }
  }

  /**
   * Get an element CSS property on the page
   * Thanks to JavaScript Kit: http://www.javascriptkit.com/dhtmltutors/dhtmlcascade4.shtml
   *
   * @api private
   * @method _getPropValue
   * @param {Object} element
   * @param {String} propName
   * @returns Element's property value
   */
  function _getPropValue (element, propName) {
    var propValue = '';
    if (element.currentStyle) { //IE
      propValue = element.currentStyle[propName];
    } else if (document.defaultView && document.defaultView.getComputedStyle) { //Others
      propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
    }

    //Prevent exception in IE
    if (propValue && propValue.toLowerCase) {
      return propValue.toLowerCase();
    } else {
      return propValue;
    }
  }

  /**
   * Provides a cross-browser way to get the screen dimensions
   * via: http://stackoverflow.com/questions/5864467/internet-explorer-innerheight
   *
   * @api private
   * @method _getWinSize
   * @returns {Object} width and height attributes
   */
  function _getWinSize() {
    if (window.innerWidth != undefined) {
      return { width: window.innerWidth, height: window.innerHeight };
    } else {
      var D = document.documentElement;
      return { width: D.clientWidth, height: D.clientHeight };
    }
  }

  /**
   * Add overlay layer to the page
   * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
   *
   * @api private
   * @method _elementInViewport
   * @param {Object} el
   */
  function _elementInViewport(el) {
    var rect = el.getBoundingClientRect();

    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      (rect.bottom+80) <= window.innerHeight && // add 80 to get the text right
      rect.right <= window.innerWidth
    );
  }

  /**
   * Add overlay layer to the page
   *
   * @api private
   * @method _addOverlayLayer
   * @param {Object} targetElm
   */
  function _addOverlayLayer(targetElm) {
    var overlayLayer = document.createElement('div'),
        styleText = '',
        self = this;

    //set css class name
    overlayLayer.className = 'introjs-overlay';

    //check if the target element is body, we should calculate the size of overlay layer in a better way
    if (targetElm.tagName.toLowerCase() === 'body') {
      styleText += 'top: 0;bottom: 0; left: 0;right: 0;position: fixed;';
      overlayLayer.setAttribute('style', styleText);
    } else {
      //set overlay layer position
      var elementPosition = _getOffset(targetElm);
      if (elementPosition) {
        styleText += 'width: ' + elementPosition.width + 'px; height:' + elementPosition.height + 'px; top:' + elementPosition.top + 'px;left: ' + elementPosition.left + 'px;';
        overlayLayer.setAttribute('style', styleText);
      }
    }

    targetElm.appendChild(overlayLayer);

    overlayLayer.onclick = function() {
      if (self._options.exitOnOverlayClick == true) {

        //check if any callback is defined
        if (self._introExitCallback != undefined) {
          self._introExitCallback.call(self);
        }
        _exitIntro.call(self, targetElm);
      }
    };

    setTimeout(function() {
      styleText += 'opacity: ' + self._options.overlayOpacity.toString() + ';';
      overlayLayer.setAttribute('style', styleText);
    }, 10);

    return true;
  }

  /**
   * Get an element position on the page
   * Thanks to `meouw`: http://stackoverflow.com/a/442474/375966
   *
   * @api private
   * @method _getOffset
   * @param {Object} element
   * @returns Element's position info
   */
  function _getOffset(element) {
    var elementPosition = {};

    //set width
    elementPosition.width = element.offsetWidth;

    //set height
    elementPosition.height = element.offsetHeight;

    //calculate element top and left
    var _x = 0;
    var _y = 0;
    while (element && !isNaN(element.offsetLeft) && !isNaN(element.offsetTop)) {
      _x += element.offsetLeft;
      _y += element.offsetTop;
      element = element.offsetParent;
    }
    //set top
    elementPosition.top = _y;
    //set left
    elementPosition.left = _x;

    return elementPosition;
  }

  /**
   * Gets the current progress percentage
   *
   * @api private
   * @method _getProgress
   * @returns current progress percentage
   */
  function _getProgress() {
    // Steps are 0 indexed
    var currentStep = parseInt((this._currentStep + 1), 10);
    return ((currentStep / this._introItems.length) * 100);
  }

  /**
   * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
   * via: http://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
   *
   * @param obj1
   * @param obj2
   * @returns obj3 a new object based on obj1 and obj2
   */
  function _mergeOptions(obj1,obj2) {
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }

  var introJs = function (targetElm) {
    if (typeof (targetElm) === 'object') {
      //Ok, create a new instance
      return new IntroJs(targetElm);

    } else if (typeof (targetElm) === 'string') {
      //select the target element with query selector
      var targetElement = document.querySelector(targetElm);

      if (targetElement) {
        return new IntroJs(targetElement);
      } else {
        throw new Error('There is no element with given selector.');
      }
    } else {
      return new IntroJs(document.body);
    }
  };

  /**
   * Current IntroJs version
   *
   * @property version
   * @type String
   */
  introJs.version = VERSION;

  //Prototype
  introJs.fn = IntroJs.prototype = {
    clone: function () {
      return new IntroJs(this);
    },
    setOption: function(option, value) {
      this._options[option] = value;
      return this;
    },
    setOptions: function(options) {
      this._options = _mergeOptions(this._options, options);
      return this;
    },
    start: function () {
      _introForElement.call(this, this._targetElement);
      return this;
    },
    goToStep: function(step) {
      _goToStep.call(this, step);
      return this;
    },
    nextStep: function() {
      _nextStep.call(this);
      return this;
    },
    previousStep: function() {
      _previousStep.call(this);
      return this;
    },
    exit: function() {
      _exitIntro.call(this, this._targetElement);
      return this;
    },
    refresh: function() {
      _setHelperLayerPosition.call(this, document.querySelector('.introjs-helperLayer'));
      _setHelperLayerPosition.call(this, document.querySelector('.introjs-tooltipReferenceLayer'));
      return this;
    },
    onbeforechange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introBeforeChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onbeforechange was not a function');
      }
      return this;
    },
    onchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onchange was not a function.');
      }
      return this;
    },
    onafterchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introAfterChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onafterchange was not a function');
      }
      return this;
    },
    oncomplete: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introCompleteCallback = providedCallback;
      } else {
        throw new Error('Provided callback for oncomplete was not a function.');
      }
      return this;
    },
    onexit: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introExitCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onexit was not a function.');
      }
      return this;
    }
  };

  exports.introJs = introJs;
  return introJs;
}));

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js":[function(require,module,exports){
/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
(function (window, document, undefined) {
var oldL = window.L,
    L = {};

L.version = '0.7.7';

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed

L.noConflict = function () {
	window.L = oldL;
	return this;
};

window.L = L;


/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	extend: function (dest) { // (Object[, Object, ...]) ->
		var sources = Array.prototype.slice.call(arguments, 1),
		    i, j, len, src;

		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j] || {};
			for (i in src) {
				if (src.hasOwnProperty(i)) {
					dest[i] = src[i];
				}
			}
		}
		return dest;
	},

	bind: function (fn, obj) { // (Function, Object) -> Function
		var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
		return function () {
			return fn.apply(obj, args || arguments);
		};
	},

	stamp: (function () {
		var lastId = 0,
		    key = '_leaflet_id';
		return function (obj) {
			obj[key] = obj[key] || ++lastId;
			return obj[key];
		};
	}()),

	invokeEach: function (obj, method, context) {
		var i, args;

		if (typeof obj === 'object') {
			args = Array.prototype.slice.call(arguments, 3);

			for (i in obj) {
				method.apply(context, [i, obj[i]].concat(args));
			}
			return true;
		}

		return false;
	},

	limitExecByInterval: function (fn, time, context) {
		var lock, execOnUnlock;

		return function wrapperFn() {
			var args = arguments;

			if (lock) {
				execOnUnlock = true;
				return;
			}

			lock = true;

			setTimeout(function () {
				lock = false;

				if (execOnUnlock) {
					wrapperFn.apply(context, args);
					execOnUnlock = false;
				}
			}, time);

			fn.apply(context, args);
		};
	},

	falseFn: function () {
		return false;
	},

	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	setOptions: function (obj, options) {
		obj.options = L.extend({}, obj.options, options);
		return obj.options;
	},

	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},
	template: function (str, data) {
		return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
			var value = data[key];
			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);
			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		var i, fn,
		    prefixes = ['webkit', 'moz', 'o', 'ms'];

		for (i = 0; i < prefixes.length && !fn; i++) {
			fn = window[prefixes[i] + name];
		}

		return fn;
	}

	var lastTime = 0;

	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame ||
	        getPrefixed('RequestAnimationFrame') || timeoutDefer;

	var cancelFn = window.cancelAnimationFrame ||
	        getPrefixed('CancelAnimationFrame') ||
	        getPrefixed('CancelRequestAnimationFrame') ||
	        function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate, element) {
		fn = L.bind(fn, context);

		if (immediate && requestFn === timeoutDefer) {
			fn();
		} else {
			return requestFn.call(window, fn, element);
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};

}());

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function (props) {

	// extended class with the new prototype
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		if (this._initHooks) {
			this.callInitHooks();
		}
	};

	// instantiate class without calling constructor
	var F = function () {};
	F.prototype = this.prototype;

	var proto = new F();
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	//inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (props.options && proto.options) {
		props.options = L.extend({}, proto.options, props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	var parent = this;
	// jshint camelcase: false
	NewClass.__super__ = parent.prototype;

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parent.prototype.callInitHooks) {
			parent.prototype.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};


/*
 * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
 */

var eventsKey = '_leaflet_events';

L.Mixin = {};

L.Mixin.Events = {

	addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

		// types can be a map of types/handlers
		if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey] = this[eventsKey] || {},
		    contextId = context && context !== this && L.stamp(context),
		    i, len, event, type, indexKey, indexLenKey, typeIndex;

		// types can be a string of space-separated words
		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			event = {
				action: fn,
				context: context || this
			};
			type = types[i];

			if (contextId) {
				// store listeners of a particular context in a separate hash (if it has an id)
				// gives a major performance boost when removing thousands of map layers

				indexKey = type + '_idx';
				indexLenKey = indexKey + '_len';

				typeIndex = events[indexKey] = events[indexKey] || {};

				if (!typeIndex[contextId]) {
					typeIndex[contextId] = [];

					// keep track of the number of keys in the index to quickly check if it's empty
					events[indexLenKey] = (events[indexLenKey] || 0) + 1;
				}

				typeIndex[contextId].push(event);


			} else {
				events[type] = events[type] || [];
				events[type].push(event);
			}
		}

		return this;
	},

	hasEventListeners: function (type) { // (String) -> Boolean
		var events = this[eventsKey];
		return !!events && ((type in events && events[type].length > 0) ||
		                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
	},

	removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

		if (!this[eventsKey]) {
			return this;
		}

		if (!types) {
			return this.clearAllEventListeners();
		}

		if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey],
		    contextId = context && context !== this && L.stamp(context),
		    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			type = types[i];
			indexKey = type + '_idx';
			indexLenKey = indexKey + '_len';

			typeIndex = events[indexKey];

			if (!fn) {
				// clear all listeners for a type if function isn't specified
				delete events[type];
				delete events[indexKey];
				delete events[indexLenKey];

			} else {
				listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

				if (listeners) {
					for (j = listeners.length - 1; j >= 0; j--) {
						if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
							removed = listeners.splice(j, 1);
							// set the old action to a no-op, because it is possible
							// that the listener is being iterated over as part of a dispatch
							removed[0].action = L.Util.falseFn;
						}
					}

					if (context && typeIndex && (listeners.length === 0)) {
						delete typeIndex[contextId];
						events[indexLenKey]--;
					}
				}
			}
		}

		return this;
	},

	clearAllEventListeners: function () {
		delete this[eventsKey];
		return this;
	},

	fireEvent: function (type, data) { // (String[, Object])
		if (!this.hasEventListeners(type)) {
			return this;
		}

		var event = L.Util.extend({}, data, { type: type, target: this });

		var events = this[eventsKey],
		    listeners, i, len, typeIndex, contextId;

		if (events[type]) {
			// make sure adding/removing listeners inside other listeners won't cause infinite loop
			listeners = events[type].slice();

			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].action.call(listeners[i].context, event);
			}
		}

		// fire event for the context-indexed listeners as well
		typeIndex = events[type + '_idx'];

		for (contextId in typeIndex) {
			listeners = typeIndex[contextId].slice();

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].action.call(listeners[i].context, event);
				}
			}
		}

		return this;
	},

	addOneTimeEventListener: function (types, fn, context) {

		if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

		var handler = L.bind(function () {
			this
			    .removeEventListener(types, fn, context)
			    .removeEventListener(types, handler, context);
		}, this);

		return this
		    .addEventListener(types, fn, context)
		    .addEventListener(types, handler, context);
	}
};

L.Mixin.Events.on = L.Mixin.Events.addEventListener;
L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ie = 'ActiveXObject' in window,
		ielt9 = ie && !document.addEventListener,

	    // terrible browser detection to work around Safari / iOS / Android browser bugs
	    ua = navigator.userAgent.toLowerCase(),
	    webkit = ua.indexOf('webkit') !== -1,
	    chrome = ua.indexOf('chrome') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android = ua.indexOf('android') !== -1,
	    android23 = ua.search('android [23]') !== -1,
		gecko = ua.indexOf('gecko') !== -1,

	    mobile = typeof orientation !== undefined + '',
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
		pointer = (window.PointerEvent && window.navigator.pointerEnabled) ||
				  msPointer,
	    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
	             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
	              window.matchMedia('(min-resolution:144dpi)').matches),

	    doc = document.documentElement,
	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera3d = 'OTransition' in doc.style,
	    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;

	var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {
		ie: ie,
		ielt9: ielt9,
		webkit: webkit,
		gecko: gecko && !webkit && !window.opera && !ie,

		android: android,
		android23: android23,

		chrome: chrome,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera3d: opera3d,
		any3d: any3d,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,

		touch: touch,
		msPointer: msPointer,
		pointer: pointer,

		retina: retina
	};

}());


/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};


/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};


/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};


/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return (typeof id === 'string' ? document.getElementById(id) : id);
	},

	getStyle: function (el, style) {

		var value = el.style[style];

		if (!value && el.currentStyle) {
			value = el.currentStyle[style];
		}

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	getViewportOffset: function (element) {

		var top = 0,
		    left = 0,
		    el = element,
		    docBody = document.body,
		    docEl = document.documentElement,
		    pos;

		do {
			top  += el.offsetTop  || 0;
			left += el.offsetLeft || 0;

			//add borders
			top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
			left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

			pos = L.DomUtil.getStyle(el, 'position');

			if (el.offsetParent === docBody && pos === 'absolute') { break; }

			if (pos === 'fixed') {
				top  += docBody.scrollTop  || docEl.scrollTop  || 0;
				left += docBody.scrollLeft || docEl.scrollLeft || 0;
				break;
			}

			if (pos === 'relative' && !el.offsetLeft) {
				var width = L.DomUtil.getStyle(el, 'width'),
				    maxWidth = L.DomUtil.getStyle(el, 'max-width'),
				    r = el.getBoundingClientRect();

				if (width !== 'none' || maxWidth !== 'none') {
					left += r.left + el.clientLeft;
				}

				//calculate full y offset since we're breaking out of the loop
				top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

				break;
			}

			el = el.offsetParent;

		} while (el);

		el = element;

		do {
			if (el === docBody) { break; }

			top  -= el.scrollTop  || 0;
			left -= el.scrollLeft || 0;

			el = el.parentNode;
		} while (el);

		return new L.Point(left, top);
	},

	documentIsLtr: function () {
		if (!L.DomUtil._docIsLtrCached) {
			L.DomUtil._docIsLtrCached = true;
			L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
		}
		return L.DomUtil._docIsLtr;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil._getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil._getClass(el);
			L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	_setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	_getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {

			var filter = false,
			    filterName = 'DXImageTransform.Microsoft.Alpha';

			// filters collection throws an error if we try to retrieve a filter that doesn't exist
			try {
				filter = el.filters.item(filterName);
			} catch (e) {
				// don't set opacity to 1 if we haven't already set an opacity,
				// it isn't needed and breaks transparent pngs.
				if (value === 1) { return; }
			}

			value = Math.round(value * 100);

			if (filter) {
				filter.Enabled = (value !== 100);
				filter.Opacity = value;
			} else {
				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
			}
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	getTranslateString: function (point) {
		// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
		// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
		// (same speed either way), Opera 12 doesn't support translate3d

		var is3d = L.Browser.webkit3d,
		    open = 'translate' + (is3d ? '3d' : '') + '(',
		    close = (is3d ? ',0' : '') + ')';

		return open + point.x + 'px,' + point.y + 'px' + close;
	},

	getScaleString: function (scale, origin) {

		var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
		    scaleStr = ' scale(' + scale + ') ';

		return preTranslateStr + scaleStr;
	},

	setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

		// jshint camelcase: false
		el._leaflet_pos = point;

		if (!disable3D && L.Browser.any3d) {
			el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		// jshint camelcase: false
		return el._leaflet_pos;
	}
};


// prefix style property names

L.DomUtil.TRANSFORM = L.DomUtil.testProp(
        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

L.DomUtil.TRANSITION = L.DomUtil.testProp(
        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

L.DomUtil.TRANSITION_END =
        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
        L.DomUtil.TRANSITION + 'End' : 'transitionend';

(function () {
    if ('onselectstart' in document) {
        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
            },

            enableTextSelection: function () {
                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
            }
        });
    } else {
        var userSelectProperty = L.DomUtil.testProp(
            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                if (userSelectProperty) {
                    var style = document.documentElement.style;
                    this._userSelect = style[userSelectProperty];
                    style[userSelectProperty] = 'none';
                }
            },

            enableTextSelection: function () {
                if (userSelectProperty) {
                    document.documentElement.style[userSelectProperty] = this._userSelect;
                    delete this._userSelect;
                }
            }
        });
    }

	L.extend(L.DomUtil, {
		disableImageDrag: function () {
			L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
		},

		enableImageDrag: function () {
			L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
		}
	});
})();


/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
	lat = parseFloat(lat);
	lng = parseFloat(lng);

	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = lat;
	this.lng = lng;

	if (alt !== undefined) {
		this.alt = parseFloat(alt);
	}
};

L.extend(L.LatLng, {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

L.LatLng.prototype = {
	equals: function (obj) { // (LatLng) -> Boolean
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= L.LatLng.MAX_MARGIN;
	},

	toString: function (precision) { // (Number) -> String
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
	// TODO move to projection code, LatLng shouldn't know about Earth
	distanceTo: function (other) { // (LatLng) -> Number
		other = L.latLng(other);

		var R = 6378137, // earth radius in meters
		    d2r = L.LatLng.DEG_TO_RAD,
		    dLat = (other.lat - this.lat) * d2r,
		    dLon = (other.lng - this.lng) * d2r,
		    lat1 = this.lat * d2r,
		    lat2 = other.lat * d2r,
		    sin1 = Math.sin(dLat / 2),
		    sin2 = Math.sin(dLon / 2);

		var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

		return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	},

	wrap: function (a, b) { // (Number, Number) -> LatLng
		var lng = this.lng;

		a = a || -180;
		b = b ||  180;

		lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

		return new L.LatLng(this.lat, lng);
	}
};

L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a)) {
		if (typeof a[0] === 'number' || typeof a[0] === 'string') {
			return new L.LatLng(a[0], a[1], a[2]);
		} else {
			return null;
		}
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b);
};



/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {
	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		if (!obj) { return this; }

		var latLng = L.latLng(obj);
		if (latLng !== null) {
			obj = latLng;
		} else {
			obj = L.latLngBounds(obj);
		}

		if (obj instanceof L.LatLng) {
			if (!this._southWest && !this._northEast) {
				this._southWest = new L.LatLng(obj.lat, obj.lng);
				this._northEast = new L.LatLng(obj.lat, obj.lng);
			} else {
				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
				this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
			}
		} else if (obj instanceof L.LatLngBounds) {
			this.extend(obj._southWest);
			this.extend(obj._northEast);
		}
		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};


/*
 * L.Projection contains various geographical projections used by CRS classes.
 */

L.Projection = {};


/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    x = latlng.lng * d,
		    y = lat * d;

		y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    lng = point.x * d,
		    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

		return new L.LatLng(lat, lng);
	}
};


/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	}
};


/*
 * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	project: function (latlng) {
		return this.projection.project(latlng);
	},

	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	getSize: function (zoom) {
		var s = this.scale(zoom);
		return L.point(s, s);
	}
};


/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	}
});


/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
 * and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS, {
	code: 'EPSG:3857',

	projection: L.Projection.SphericalMercator,
	transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

	project: function (latlng) { // (LatLng) -> Point
		var projectedPoint = this.projection.project(latlng),
		    earthRadius = 6378137;
		return projectedPoint.multiplyBy(earthRadius);
	}
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});


/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS, {
	code: 'EPSG:4326',

	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
});


/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
		trackResize: true,
		markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);


		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];

		this._layers = {};
		this._zoomBoundLayers = {};
		this._tileLayersNum = 0;

		this.callInitHooks();

		this._addLayers(options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	fitBounds: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return this.setView(center, zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		this.options.maxBounds = bounds;

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds, this);
		}

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds, this);
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	addLayer: function (layer) {
		// TODO method is too big, refactor

		var id = L.stamp(layer);

		if (this._layers[id]) { return this; }

		this._layers[id] = layer;

		// TODO getMaxZoom, getMinZoom in ILayer (instead of options)
		if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
			this._zoomBoundLayers[id] = layer;
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor!!!
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum++;
			this._tileLayersToLoad++;
			layer.on('load', this._onTileLayerLoad, this);
		}

		if (this._loaded) {
			this._layerAdd(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
		}

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum--;
			this._tileLayersToLoad--;
			layer.off('load', this._onTileLayerLoad, this);
		}

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {
		if (this._loaded) {
			this.fire('unload');
		}

		this._initEvents('off');

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		this._clearPanes();
		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		return this;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ?
			(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
			this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._initialTopLeftPoint;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom) {
		var crs = this.options.crs;
		return crs.scale(toZoom) / crs.scale(this._zoom);
	},

	getScaleZoom: function (scale) {
		return this._zoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};

		this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

		this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
		panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
		panes.shadowPane = this._createPane('leaflet-shadow-pane');
		panes.overlayPane = this._createPane('leaflet-overlay-pane');
		panes.markerPane = this._createPane('leaflet-marker-pane');
		panes.popupPane = this._createPane('leaflet-popup-pane');

		var zoomHide = ' leaflet-zoom-hide';

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, zoomHide);
			L.DomUtil.addClass(panes.shadowPane, zoomHide);
			L.DomUtil.addClass(panes.popupPane, zoomHide);
		}
	},

	_createPane: function (className, container) {
		return L.DomUtil.create('div', className, container || this._panes.objectsPane);
	},

	_clearPanes: function () {
		this._container.removeChild(this._mapPane);
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		} else {
			this._initialTopLeftPoint._add(this._getMapPanePos());
		}

		this._tileLayersToLoad = this._tileLayersNum;

		var loading = !this._loaded;
		this._loaded = true;

		this.fire('viewreset', {hard: !preserveMapOffset});

		if (loading) {
			this.fire('load');
			this.eachLayer(this._layerAdd, this);
		}

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_updateZoomLevels: function () {
		var i,
			minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (i in this._zoomBoundLayers) {
			var layer = this._zoomBoundLayers[i];
			if (!isNaN(layer.options.minZoom)) {
				minZoom = Math.min(minZoom, layer.options.minZoom);
			}
			if (!isNaN(layer.options.maxZoom)) {
				maxZoom = Math.max(maxZoom, layer.options.maxZoom);
			}
		}

		if (i === undefined) { // we have no tilelayers
			this._layersMaxZoom = this._layersMinZoom = undefined;
		} else {
			this._layersMaxZoom = maxZoom;
			this._layersMinZoom = minZoom;
		}

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// map events

	_initEvents: function (onOff) {
		if (!L.DomEvent) { return; }

		onOff = onOff || 'on';

		L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

		var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
		              'mouseleave', 'mousemove', 'contextmenu'],
		    i, len;

		for (i = 0, len = events.length; i < len; i++) {
			L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
		}

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_onMouseClick: function (e) {
		if (!this._loaded || (!e._simulated &&
		        ((this.dragging && this.dragging.moved()) ||
		         (this.boxZoom  && this.boxZoom.moved()))) ||
		            L.DomEvent._skipped(e)) { return; }

		this.fire('preclick');
		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type;

		type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

		if (!this.hasEventListeners(type)) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}

		var containerPoint = this.mouseEventToContainerPoint(e),
		    layerPoint = this.containerPointToLayerPoint(containerPoint),
		    latlng = this.layerPointToLatLng(layerPoint);

		this.fire(type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});
	},

	_onTileLayerLoad: function () {
		this._tileLayersToLoad--;
		if (this._tileLayersNum && !this._tileLayersToLoad) {
			this.fire('tilelayersload');
		}
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, this);
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	_layerAdd: function (layer) {
		layer.onAdd(this);
		this.fire('layeradd', {layer: layer});
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos());
	},

	_getNewTopLeftPoint: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._round();
	},

	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
		return this.project(latlng, newZoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	MAX_LATITUDE: 85.0840591556,

	R_MINOR: 6356752.314245179,
	R_MAJOR: 6378137,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    x = latlng.lng * d * r,
		    y = lat * d,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1.0 - tmp * tmp),
		    con = eccent * Math.sin(y);

		con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

		var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
		y = -r * Math.log(ts);

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    lng = point.x * d / r,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1 - (tmp * tmp)),
		    ts = Math.exp(- point.y / r),
		    phi = (Math.PI / 2) - 2 * Math.atan(ts),
		    numIter = 15,
		    tol = 1e-7,
		    i = numIter,
		    dphi = 0.1,
		    con;

		while ((Math.abs(dphi) > tol) && (--i > 0)) {
			con = eccent * Math.sin(phi);
			dphi = (Math.PI / 2) - 2 * Math.atan(ts *
			            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, lng);
	}
};



L.CRS.EPSG3395 = L.extend({}, L.CRS, {
	code: 'EPSG:3395',

	projection: L.Projection.Mercator,

	transformation: (function () {
		var m = L.Projection.Mercator,
		    r = m.R_MAJOR,
		    scale = 0.5 / (Math.PI * r);

		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});


/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',
		zoomOffset: 0,
		opacity: 1,
		/*
		maxNativeZoom: null,
		zIndex: null,
		tms: false,
		continuousWorld: false,
		noWrap: false,
		zoomReverse: false,
		detectRetina: false,
		reuseTiles: false,
		bounds: false,
		*/
		unloadInvisibleTiles: L.Browser.mobile,
		updateWhenIdle: L.Browser.mobile
	},

	initialize: function (url, options) {
		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			if (options.minZoom > 0) {
				options.minZoom--;
			}
			this.options.maxZoom--;
		}

		if (options.bounds) {
			options.bounds = L.latLngBounds(options.bounds);
		}

		this._url = url;

		var subdomains = this.options.subdomains;

		if (typeof subdomains === 'string') {
			this.options.subdomains = subdomains.split('');
		}
	},

	onAdd: function (map) {
		this._map = map;
		this._animated = map._zoomAnimated;

		// create a container div for tiles
		this._initContainer();

		// set up events
		map.on({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.on({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
			map.on('move', this._limitedUpdate, this);
		}

		this._reset();
		this._update();
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		this._container.parentNode.removeChild(this._container);

		map.off({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.off({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			map.off('move', this._limitedUpdate, this);
		}

		this._container = null;
		this._map = null;
	},

	bringToFront: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.appendChild(this._container);
			this._setAutoZIndex(pane, Math.max);
		}

		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.insertBefore(this._container, pane.firstChild);
			this._setAutoZIndex(pane, Math.min);
		}

		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}
		return this;
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (pane, compare) {

		var layers = pane.children,
		    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
		    zIndex, i, len;

		for (i = 0, len = layers.length; i < len; i++) {

			if (layers[i] !== this._container) {
				zIndex = parseInt(layers[i].style.zIndex, 10);

				if (!isNaN(zIndex)) {
					edgeZIndex = compare(edgeZIndex, zIndex);
				}
			}
		}

		this.options.zIndex = this._container.style.zIndex =
		        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
	},

	_updateOpacity: function () {
		var i,
		    tiles = this._tiles;

		if (L.Browser.ielt9) {
			for (i in tiles) {
				L.DomUtil.setOpacity(tiles[i], this.options.opacity);
			}
		} else {
			L.DomUtil.setOpacity(this._container, this.options.opacity);
		}
	},

	_initContainer: function () {
		var tilePane = this._map._panes.tilePane;

		if (!this._container) {
			this._container = L.DomUtil.create('div', 'leaflet-layer');

			this._updateZIndex();

			if (this._animated) {
				var className = 'leaflet-tile-container';

				this._bgBuffer = L.DomUtil.create('div', className, this._container);
				this._tileContainer = L.DomUtil.create('div', className, this._container);

			} else {
				this._tileContainer = this._container;
			}

			tilePane.appendChild(this._container);

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}
	},

	_reset: function (e) {
		for (var key in this._tiles) {
			this.fire('tileunload', {tile: this._tiles[key]});
		}

		this._tiles = {};
		this._tilesToLoad = 0;

		if (this.options.reuseTiles) {
			this._unusedTiles = [];
		}

		this._tileContainer.innerHTML = '';

		if (this._animated && e && e.hard) {
			this._clearBgBuffer();
		}

		this._initContainer();
	},

	_getTileSize: function () {
		var map = this._map,
		    zoom = map.getZoom() + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom,
		    tileSize = this.options.tileSize;

		if (zoomN && zoom > zoomN) {
			tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
		}

		return tileSize;
	},

	_update: function () {

		if (!this._map) { return; }

		var map = this._map,
		    bounds = map.getPixelBounds(),
		    zoom = map.getZoom(),
		    tileSize = this._getTileSize();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		var tileBounds = L.bounds(
		        bounds.min.divideBy(tileSize)._floor(),
		        bounds.max.divideBy(tileSize)._floor());

		this._addTilesFromCenterOut(tileBounds);

		if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
			this._removeOtherTiles(tileBounds);
		}
	},

	_addTilesFromCenterOut: function (bounds) {
		var queue = [],
		    center = bounds.getCenter();

		var j, i, point;

		for (j = bounds.min.y; j <= bounds.max.y; j++) {
			for (i = bounds.min.x; i <= bounds.max.x; i++) {
				point = new L.Point(i, j);

				if (this._tileShouldBeLoaded(point)) {
					queue.push(point);
				}
			}
		}

		var tilesToLoad = queue.length;

		if (tilesToLoad === 0) { return; }

		// load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center);
		});

		var fragment = document.createDocumentFragment();

		// if its the first batch of tiles to load
		if (!this._tilesToLoad) {
			this.fire('loading');
		}

		this._tilesToLoad += tilesToLoad;

		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment);
		}

		this._tileContainer.appendChild(fragment);
	},

	_tileShouldBeLoaded: function (tilePoint) {
		if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
			return false; // already loaded
		}

		var options = this.options;

		if (!options.continuousWorld) {
			var limit = this._getWrapTileNum();

			// don't load if exceeds world bounds
			if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
				tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
		}

		if (options.bounds) {
			var tileSize = this._getTileSize(),
			    nwPoint = tilePoint.multiplyBy(tileSize),
			    sePoint = nwPoint.add([tileSize, tileSize]),
			    nw = this._map.unproject(nwPoint),
			    se = this._map.unproject(sePoint);

			// TODO temporary hack, will be removed after refactoring projections
			// https://github.com/Leaflet/Leaflet/issues/1618
			if (!options.continuousWorld && !options.noWrap) {
				nw = nw.wrap();
				se = se.wrap();
			}

			if (!options.bounds.intersects([nw, se])) { return false; }
		}

		return true;
	},

	_removeOtherTiles: function (bounds) {
		var kArr, x, y, key;

		for (key in this._tiles) {
			kArr = key.split(':');
			x = parseInt(kArr[0], 10);
			y = parseInt(kArr[1], 10);

			// remove tile if it's out of bounds
			if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
				this._removeTile(key);
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		this.fire('tileunload', {tile: tile, url: tile.src});

		if (this.options.reuseTiles) {
			L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
			this._unusedTiles.push(tile);

		} else if (tile.parentNode === this._tileContainer) {
			this._tileContainer.removeChild(tile);
		}

		// for https://github.com/CloudMade/Leaflet/issues/137
		if (!L.Browser.android) {
			tile.onload = null;
			tile.src = L.Util.emptyImageUrl;
		}

		delete this._tiles[key];
	},

	_addTile: function (tilePoint, container) {
		var tilePos = this._getTilePos(tilePoint);

		// get unused tile - or create a new tile
		var tile = this._getTile();

		/*
		Chrome 20 layouts much faster with top/left (verify with timeline, frames)
		Android 4 browser has display issues with top/left and requires transform instead
		(other browsers don't currently care) - see debug/hacks/jitter.html for an example
		*/
		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

		this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

		this._loadTile(tile, tilePoint);

		if (tile.parentNode !== this._tileContainer) {
			container.appendChild(tile);
		}
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._map.getZoom();

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getTilePos: function (tilePoint) {
		var origin = this._map.getPixelOrigin(),
		    tileSize = this._getTileSize();

		return tilePoint.multiplyBy(tileSize).subtract(origin);
	},

	// image-specific code (override to implement e.g. Canvas or SVG tile layer)

	getTileUrl: function (tilePoint) {
		return L.Util.template(this._url, L.extend({
			s: this._getSubdomain(tilePoint),
			z: tilePoint.z,
			x: tilePoint.x,
			y: tilePoint.y
		}, this.options));
	},

	_getWrapTileNum: function () {
		var crs = this._map.options.crs,
		    size = crs.getSize(this._map.getZoom());
		return size.divideBy(this._getTileSize())._floor();
	},

	_adjustTilePoint: function (tilePoint) {

		var limit = this._getWrapTileNum();

		// wrap tile coordinates
		if (!this.options.continuousWorld && !this.options.noWrap) {
			tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
		}

		if (this.options.tms) {
			tilePoint.y = limit.y - tilePoint.y - 1;
		}

		tilePoint.z = this._getZoomForUrl();
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	_getTile: function () {
		if (this.options.reuseTiles && this._unusedTiles.length > 0) {
			var tile = this._unusedTiles.pop();
			this._resetTile(tile);
			return tile;
		}
		return this._createTile();
	},

	// Override if data stored on a tile needs to be cleaned up before reuse
	_resetTile: function (/*tile*/) {},

	_createTile: function () {
		var tile = L.DomUtil.create('img', 'leaflet-tile');
		tile.style.width = tile.style.height = this._getTileSize() + 'px';
		tile.galleryimg = 'no';

		tile.onselectstart = tile.onmousemove = L.Util.falseFn;

		if (L.Browser.ielt9 && this.options.opacity !== undefined) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}
		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.mobileWebkit3d) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer  = this;
		tile.onload  = this._tileOnLoad;
		tile.onerror = this._tileOnError;

		this._adjustTilePoint(tilePoint);
		tile.src     = this.getTileUrl(tilePoint);

		this.fire('tileloadstart', {
			tile: tile,
			url: tile.src
		});
	},

	_tileLoaded: function () {
		this._tilesToLoad--;

		if (this._animated) {
			L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
		}

		if (!this._tilesToLoad) {
			this.fire('load');

			if (this._animated) {
				// clear scaled tiles after all new tiles are loaded (for performance)
				clearTimeout(this._clearBgBufferTimer);
				this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
			}
		}
	},

	_tileOnLoad: function () {
		var layer = this._layer;

		//Only if we are loading an actual image
		if (this.src !== L.Util.emptyImageUrl) {
			L.DomUtil.addClass(this, 'leaflet-tile-loaded');

			layer.fire('tileload', {
				tile: this,
				url: this.src
			});
		}

		layer._tileLoaded();
	},

	_tileOnError: function () {
		var layer = this._layer;

		layer.fire('tileerror', {
			tile: this,
			url: this.src
		});

		var newUrl = layer.options.errorTileUrl;
		if (newUrl) {
			this.src = newUrl;
		}

		layer._tileLoaded();
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};


/*
 * L.TileLayer.WMS is used for putting WMS tile layers on the map.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	initialize: function (url, options) { // (String, Object)

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams),
		    tileSize = options.tileSize || this.options.tileSize;

		if (options.detectRetina && L.Browser.retina) {
			wmsParams.width = wmsParams.height = tileSize * 2;
		} else {
			wmsParams.width = wmsParams.height = tileSize;
		}

		for (var i in options) {
			// all keys that are not TileLayer options go to WMS params
			if (!this.options.hasOwnProperty(i) && i !== 'crs') {
				wmsParams[i] = options[i];
			}
		}

		this.wmsParams = wmsParams;

		L.setOptions(this, options);
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;

		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (tilePoint) { // (Point, Number) -> String

		var map = this._map,
		    tileSize = this.options.tileSize,

		    nwPoint = tilePoint.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
		    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
		    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
		        [se.y, nw.x, nw.y, se.x].join(',') :
		        [nw.x, se.y, se.x, nw.y].join(','),

		    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};


/*
 * L.TileLayer.Canvas is a class that you can use as a base for creating
 * dynamically drawn Canvas-based tile layers.
 */

L.TileLayer.Canvas = L.TileLayer.extend({
	options: {
		async: false
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}

		for (var i in this._tiles) {
			this._redrawTile(this._tiles[i]);
		}
		return this;
	},

	_redrawTile: function (tile) {
		this.drawTile(tile, tile._tilePoint, this._map._zoom);
	},

	_createTile: function () {
		var tile = L.DomUtil.create('canvas', 'leaflet-tile');
		tile.width = tile.height = this.options.tileSize;
		tile.onselectstart = tile.onmousemove = L.Util.falseFn;
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer = this;
		tile._tilePoint = tilePoint;

		this._redrawTile(tile);

		if (!this.options.async) {
			this.tileDrawn(tile);
		}
	},

	drawTile: function (/*tile, tilePoint*/) {
		// override with rendering code
	},

	tileDrawn: function (tile) {
		this._tileOnLoad.call(tile);
	}
});


L.tileLayer.canvas = function (options) {
	return new L.TileLayer.Canvas(options);
};


/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		opacity: 1
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._image) {
			this._initImage();
		}

		map._panes.overlayPane.appendChild(this._image);

		map.on('viewreset', this._reset, this);

		if (map.options.zoomAnimation && L.Browser.any3d) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._reset();
	},

	onRemove: function (map) {
		map.getPanes().overlayPane.removeChild(this._image);

		map.off('viewreset', this._reset, this);

		if (map.options.zoomAnimation) {
			map.off('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// TODO remove bringToFront/bringToBack duplication from TileLayer/Path
	bringToFront: function () {
		if (this._image) {
			this._map._panes.overlayPane.appendChild(this._image);
		}
		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.overlayPane;
		if (this._image) {
			pane.insertBefore(this._image, pane.firstChild);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;
		this._image.src = this._url;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	_initImage: function () {
		this._image = L.DomUtil.create('img', 'leaflet-image-layer');

		if (this._map.options.zoomAnimation && L.Browser.any3d) {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
		} else {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
		}

		this._updateOpacity();

		//TODO createImage util method to remove duplication
		L.extend(this._image, {
			galleryimg: 'no',
			onselectstart: L.Util.falseFn,
			onmousemove: L.Util.falseFn,
			onload: L.bind(this._onImageLoad, this),
			src: this._url
		});
	},

	_animateZoom: function (e) {
		var map = this._map,
		    image = this._image,
		    scale = map.getZoomScale(e.zoom),
		    nw = this._bounds.getNorthWest(),
		    se = this._bounds.getSouthEast(),

		    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
		    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
		    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

		image.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
	},

	_reset: function () {
		var image   = this._image,
		    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

		L.DomUtil.setPosition(image, topLeft);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_onImageLoad: function () {
		this.fire('load');
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};


/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	options: {
		/*
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		*/
		className: ''
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img;
		if (!oldIcon || oldIcon.tagName !== 'IMG') {
			img = this._createImg(src);
		} else {
			img = this._createImg(src, oldIcon);
		}
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor;

		if (name === 'shadow') {
			anchor = L.point(options.shadowAnchor || options.iconAnchor);
		} else {
			anchor = L.point(options.iconAnchor);
		}

		if (!anchor && size) {
			anchor = size.divideBy(2, true);
		}

		img.className = 'leaflet-marker-' + name + ' ' + options.className;

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
			return this.options[name + 'RetinaUrl'];
		}
		return this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};


/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],

		shadowSize: [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		if (L.Browser.retina && name === 'icon') {
			name += '-2x';
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, matches, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;
		matches = src.match(leafletRe);

		if (matches) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());


/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		icon: new L.Icon.Default(),
		title: '',
		alt: '',
		clickable: true,
		draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._map = map;

		map.on('viewreset', this.update, this);

		this._initIcon();
		this.update();
		this.fire('add');

		if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
			map.on('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		if (this.dragging) {
			this.dragging.disable();
		}

		this._removeIcon();
		this._removeShadow();

		this.fire('remove');

		map.off({
			'viewreset': this.update,
			'zoomanim': this._animateZoom
		}, this);

		this._map = null;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);

		this.update();

		return this.fire('move', { latlng: this._latlng });
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		this.update();

		return this;
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup);
		}

		return this;
	},

	update: function () {
		if (this._icon) {
			this._setPos(this._map.latLngToLayerPoint(this._latlng).round());
		}
		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    map = this._map,
		    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
		    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		this._initInteraction();

		if (options.riseOnHover) {
			L.DomEvent
				.on(icon, 'mouseover', this._bringToFront, this)
				.on(icon, 'mouseout', this._resetZIndex, this);
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		var panes = this._map._panes;

		if (addIcon) {
			panes.markerPane.appendChild(this._icon);
		}

		if (newShadow && addShadow) {
			panes.shadowPane.appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent
			    .off(this._icon, 'mouseover', this._bringToFront)
			    .off(this._icon, 'mouseout', this._resetZIndex);
		}

		this._map._panes.markerPane.removeChild(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			this._map._panes.shadowPane.removeChild(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.clickable) { return; }

		// TODO refactor into something shared with Map/Path/etc. to DRY it up

		var icon = this._icon,
		    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

		L.DomUtil.addClass(icon, 'leaflet-clickable');
		L.DomEvent.on(icon, 'click', this._onMouseClick, this);
		L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

		for (var i = 0; i < events.length; i++) {
			L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
		}

		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);

			if (this.options.draggable) {
				this.dragging.enable();
			}
		}
	},

	_onMouseClick: function (e) {
		var wasDragged = this.dragging && this.dragging.moved();

		if (this.hasEventListeners(e.type) || wasDragged) {
			L.DomEvent.stopPropagation(e);
		}

		if (wasDragged) { return; }

		if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});
	},

	_onKeyPress: function (e) {
		if (e.keyCode === 13) {
			this.fire('click', {
				originalEvent: e,
				latlng: this._latlng
			});
		}
	},

	_fireMouseEvent: function (e) {

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});

		// TODO proper custom event propagation
		// this line will always be called if marker is in a FeatureGroup
		if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousedown') {
			L.DomEvent.stopPropagation(e);
		} else {
			L.DomEvent.preventDefault(e);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._icon, this.options.opacity);
		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, this.options.opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};


/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html !== false) {
			div.innerHTML = options.html;
		} else {
			div.innerHTML = '';
		}

		if (options.bgPos) {
			div.style.backgroundPosition =
			        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}

		this._setIconStyles(div, 'icon');
		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};


/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minWidth: 50,
		maxWidth: 300,
		// maxHeight: null,
		autoPan: true,
		closeButton: true,
		offset: [0, 7],
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: null,
		// autoPanPaddingBottomRight: null,
		keepInView: false,
		className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
		this._animated = L.Browser.any3d && this.options.zoomAnimation;
		this._isOpen = false;
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initLayout();
		}

		var animFade = map.options.fadeAnimation;

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 0);
		}
		map._panes.popupPane.appendChild(this._container);

		map.on(this._getEvents(), this);

		this.update();

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.fire('open');

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this});
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		map._panes.popupPane.removeChild(this._container);

		L.Util.falseFn(this._container.offsetWidth); // force reflow

		map.off(this._getEvents(), this);

		if (map.options.fadeAnimation) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		this._map = null;

		this.fire('close');

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this});
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	_getEvents: function () {
		var events = {
			viewreset: this._updatePosition
		};

		if (this._animated) {
			events.zoomanim = this._zoomAnimation;
		}
		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
			        (this._animated ? 'animated' : 'hide'),
			container = this._container = L.DomUtil.create('div', containerClass),
			closeButton;

		if (this.options.closeButton) {
			closeButton = this._closeButton =
			        L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';
			L.DomEvent.disableClickPropagation(closeButton);

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper =
		        L.DomUtil.create('div', prefix + '-content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);

		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent.disableScrollPropagation(this._contentNode);
		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		if (typeof this._content === 'string') {
			this._contentNode.innerHTML = this._content;
		} else {
			while (this._contentNode.hasChildNodes()) {
				this._contentNode.removeChild(this._contentNode.firstChild);
			}
			this._contentNode.appendChild(this._content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    animated = this._animated,
		    offset = L.point(this.options.offset);

		if (animated) {
			L.DomUtil.setPosition(this._container, pos);
		}

		this._containerBottom = -offset.y - (animated ? 0 : pos.y);
		this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = this._containerBottom + 'px';
		this._container.style.left = this._containerLeft + 'px';
	},

	_zoomAnimation: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,

		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._animated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		this.closePopup();

		if (!(popup instanceof L.Popup)) {
			var content = popup;

			popup = new L.Popup(options)
			    .setLatLng(latlng)
			    .setContent(content);
		}
		popup._isOpen = true;

		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
			popup._isOpen = false;
		}
		return this;
	}
});


/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	openPopup: function () {
		if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
			this._popup.setLatLng(this._latlng);
			this._map.openPopup(this._popup);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function () {
		if (this._popup) {
			if (this._popup._isOpen) {
				this.closePopup();
			} else {
				this.openPopup();
			}
		}
		return this;
	},

	bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

		anchor = anchor.add(L.Popup.prototype.options.offset);

		if (options && options.offset) {
			anchor = anchor.add(options.offset);
		}

		options = L.extend({offset: anchor}, options);

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this.togglePopup, this)
			    .on('remove', this.closePopup, this)
			    .on('move', this._movePopup, this);
			this._popupHandlersAdded = true;
		}

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			this._popup = new L.Popup(options, this)
				.setContent(content);
		}

		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this.togglePopup, this)
			    .off('remove', this.closePopup, this)
			    .off('move', this._movePopup, this);
			this._popupHandlersAdded = false;
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});


/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Class.extend({
	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		this.eachLayer(this.removeLayer, this);
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this._map = map;
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
		this._map = null;
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};


/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({
	includes: L.Mixin.Events,

	statics: {
		EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
	},

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		if ('on' in layer) {
			layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.addLayer.call(this, layer);

		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions);
		}

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		if ('off' in layer) {
			layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		if (this._popupContent) {
			this.invoke('unbindPopup');
		}

		return this.fire('layerremove', {layer: layer});
	},

	bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke('bindPopup', content, options);
	},

	openPopup: function (latlng) {
		// open popup on the first layer
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break;
		}
		return this;
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		this.eachLayer(function (layer) {
			bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
		});

		return bounds;
	},

	_propagateEvent: function (e) {
		e = L.extend({
			layer: e.target,
			target: this
		}, e);
		this.fire(e.type, e);
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};


/*
 * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
 */

L.Path = L.Class.extend({
	includes: [L.Mixin.Events],

	statics: {
		// how much to extend the clip area around the map view
		// (relative to its size, e.g. 0.5 is half the screen in each direction)
		// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
		CLIP_PADDING: (function () {
			var max = L.Browser.mobile ? 1280 : 2000,
			    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
			return Math.max(0, Math.min(0.5, target));
		})()
	},

	options: {
		stroke: true,
		color: '#0033ff',
		dashArray: null,
		lineCap: null,
		lineJoin: null,
		weight: 5,
		opacity: 0.5,

		fill: false,
		fillColor: null, //same as color by default
		fillOpacity: 0.2,

		clickable: true
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initElements();
			this._initEvents();
		}

		this.projectLatlngs();
		this._updatePath();

		if (this._container) {
			this._map._pathRoot.appendChild(this._container);
		}

		this.fire('add');

		map.on({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		map._pathRoot.removeChild(this._container);

		// Need to fire remove event before we set _map to null as the event hooks might need the object
		this.fire('remove');
		this._map = null;

		if (L.Browser.vml) {
			this._container = null;
			this._stroke = null;
			this._fill = null;
		}

		map.off({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	projectLatlngs: function () {
		// do all projection stuff here
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._container) {
			this._updateStyle();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._updatePath();
		}
		return this;
	}
});

L.Map.include({
	_updatePathViewport: function () {
		var p = L.Path.CLIP_PADDING,
		    size = this.getSize(),
		    panePos = L.DomUtil.getPosition(this._mapPane),
		    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
		    max = min.add(size.multiplyBy(1 + p * 2)._round());

		this._pathViewport = new L.Bounds(min, max);
	}
});


/*
 * Extends L.Path with SVG-specific rendering code.
 */

L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

L.Path = L.Path.extend({
	statics: {
		SVG: L.Browser.svg
	},

	bringToFront: function () {
		var root = this._map._pathRoot,
		    path = this._container;

		if (path && root.lastChild !== path) {
			root.appendChild(path);
		}
		return this;
	},

	bringToBack: function () {
		var root = this._map._pathRoot,
		    path = this._container,
		    first = root.firstChild;

		if (path && first !== path) {
			root.insertBefore(path, first);
		}
		return this;
	},

	getPathString: function () {
		// form path string here
	},

	_createElement: function (name) {
		return document.createElementNS(L.Path.SVG_NS, name);
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._initPath();
		this._initStyle();
	},

	_initPath: function () {
		this._container = this._createElement('g');

		this._path = this._createElement('path');

		if (this.options.className) {
			L.DomUtil.addClass(this._path, this.options.className);
		}

		this._container.appendChild(this._path);
	},

	_initStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke-linejoin', 'round');
			this._path.setAttribute('stroke-linecap', 'round');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill-rule', 'evenodd');
		}
		if (this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', this.options.pointerEvents);
		}
		if (!this.options.clickable && !this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', 'none');
		}
		this._updateStyle();
	},

	_updateStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke', this.options.color);
			this._path.setAttribute('stroke-opacity', this.options.opacity);
			this._path.setAttribute('stroke-width', this.options.weight);
			if (this.options.dashArray) {
				this._path.setAttribute('stroke-dasharray', this.options.dashArray);
			} else {
				this._path.removeAttribute('stroke-dasharray');
			}
			if (this.options.lineCap) {
				this._path.setAttribute('stroke-linecap', this.options.lineCap);
			}
			if (this.options.lineJoin) {
				this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
			}
		} else {
			this._path.setAttribute('stroke', 'none');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill', this.options.fillColor || this.options.color);
			this._path.setAttribute('fill-opacity', this.options.fillOpacity);
		} else {
			this._path.setAttribute('fill', 'none');
		}
	},

	_updatePath: function () {
		var str = this.getPathString();
		if (!str) {
			// fix webkit empty string parsing bug
			str = 'M0 0';
		}
		this._path.setAttribute('d', str);
	},

	// TODO remove duplication with L.Map
	_initEvents: function () {
		if (this.options.clickable) {
			if (L.Browser.svg || !L.Browser.vml) {
				L.DomUtil.addClass(this._path, 'leaflet-clickable');
			}

			L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

			var events = ['dblclick', 'mousedown', 'mouseover',
			              'mouseout', 'mousemove', 'contextmenu'];
			for (var i = 0; i < events.length; i++) {
				L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
			}
		}
	},

	_onMouseClick: function (e) {
		if (this._map.dragging && this._map.dragging.moved()) { return; }

		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._map || !this.hasEventListeners(e.type)) { return; }

		var map = this._map,
		    containerPoint = map.mouseEventToContainerPoint(e),
		    layerPoint = map.containerPointToLayerPoint(containerPoint),
		    latlng = map.layerPointToLatLng(layerPoint);

		this.fire(e.type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});

		if (e.type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousemove') {
			L.DomEvent.stopPropagation(e);
		}
	}
});

L.Map.include({
	_initPathRoot: function () {
		if (!this._pathRoot) {
			this._pathRoot = L.Path.prototype._createElement('svg');
			this._panes.overlayPane.appendChild(this._pathRoot);

			if (this.options.zoomAnimation && L.Browser.any3d) {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

				this.on({
					'zoomanim': this._animatePathZoom,
					'zoomend': this._endPathZoom
				});
			} else {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
			}

			this.on('moveend', this._updateSvgViewport);
			this._updateSvgViewport();
		}
	},

	_animatePathZoom: function (e) {
		var scale = this.getZoomScale(e.zoom),
		    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

		this._pathRoot.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

		this._pathZooming = true;
	},

	_endPathZoom: function () {
		this._pathZooming = false;
	},

	_updateSvgViewport: function () {

		if (this._pathZooming) {
			// Do not update SVGs while a zoom animation is going on otherwise the animation will break.
			// When the zoom animation ends we will be updated again anyway
			// This fixes the case where you do a momentum move and zoom while the move is still ongoing.
			return;
		}

		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    max = vp.max,
		    width = max.x - min.x,
		    height = max.y - min.y,
		    root = this._pathRoot,
		    pane = this._panes.overlayPane;

		// Hack to make flicker on drag end on mobile webkit less irritating
		if (L.Browser.mobileWebkit) {
			pane.removeChild(root);
		}

		L.DomUtil.setPosition(root, min);
		root.setAttribute('width', width);
		root.setAttribute('height', height);
		root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

		if (L.Browser.mobileWebkit) {
			pane.appendChild(root);
		}
	}
});


/*
 * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
 */

L.Path.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			this._popup = content;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this._openPopup, this)
			    .on('remove', this.closePopup, this);

			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this._openPopup)
			    .off('remove', this.closePopup);

			this._popupHandlersAdded = false;
		}
		return this;
	},

	openPopup: function (latlng) {

		if (this._popup) {
			// open the popup from one of the path's points if not specified
			latlng = latlng || this._latlng ||
			         this._latlngs[Math.floor(this._latlngs.length / 2)];

			this._openPopup({latlng: latlng});
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	_openPopup: function (e) {
		this._popup.setLatLng(e.latlng);
		this._map.openPopup(this._popup);
	}
});


/*
 * Vector rendering for IE6-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
	statics: {
		VML: true,
		CLIP_PADDING: 0.02
	},

	_createElement: (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement(
				        '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	}()),

	_initPath: function () {
		var container = this._container = this._createElement('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape' +
			(this.options.className ? ' ' + this.options.className : ''));

		if (this.options.clickable) {
			L.DomUtil.addClass(container, 'leaflet-clickable');
		}

		container.coordsize = '1 1';

		this._path = this._createElement('path');
		container.appendChild(this._path);

		this._map._pathRoot.appendChild(container);
	},

	_initStyle: function () {
		this._updateStyle();
	},

	_updateStyle: function () {
		var stroke = this._stroke,
		    fill = this._fill,
		    options = this.options,
		    container = this._container;

		container.stroked = options.stroke;
		container.filled = options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = this._stroke = this._createElement('stroke');
				stroke.endcap = 'round';
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			if (options.lineCap) {
				stroke.endcap = options.lineCap.replace('butt', 'flat');
			}
			if (options.lineJoin) {
				stroke.joinstyle = options.lineJoin;
			}

		} else if (stroke) {
			container.removeChild(stroke);
			this._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = this._fill = this._createElement('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			this._fill = null;
		}
	},

	_updatePath: function () {
		var style = this._container.style;

		style.display = 'none';
		this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
		style.display = '';
	}
});

L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
	_initPathRoot: function () {
		if (this._pathRoot) { return; }

		var root = this._pathRoot = document.createElement('div');
		root.className = 'leaflet-vml-container';
		this._panes.overlayPane.appendChild(root);

		this.on('moveend', this._updatePathViewport);
		this._updatePathViewport();
	}
});


/*
 * Vector rendering for all browsers that support canvas.
 */

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
	statics: {
		//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
		CANVAS: true,
		SVG: false
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._requestUpdate();
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._map) {
			this._updateStyle();
			this._requestUpdate();
		}
		return this;
	},

	onRemove: function (map) {
		map
		    .off('viewreset', this.projectLatlngs, this)
		    .off('moveend', this._updatePath, this);

		if (this.options.clickable) {
			this._map.off('click', this._onClick, this);
			this._map.off('mousemove', this._onMouseMove, this);
		}

		this._requestUpdate();
		
		this.fire('remove');
		this._map = null;
	},

	_requestUpdate: function () {
		if (this._map && !L.Path._updateRequest) {
			L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
		}
	},

	_fireMapMoveEnd: function () {
		L.Path._updateRequest = null;
		this.fire('moveend');
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._ctx = this._map._canvasCtx;
	},

	_updateStyle: function () {
		var options = this.options;

		if (options.stroke) {
			this._ctx.lineWidth = options.weight;
			this._ctx.strokeStyle = options.color;
		}
		if (options.fill) {
			this._ctx.fillStyle = options.fillColor || options.color;
		}

		if (options.lineCap) {
			this._ctx.lineCap = options.lineCap;
		}
		if (options.lineJoin) {
			this._ctx.lineJoin = options.lineJoin;
		}
	},

	_drawPath: function () {
		var i, j, len, len2, point, drawMethod;

		this._ctx.beginPath();

		for (i = 0, len = this._parts.length; i < len; i++) {
			for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
				point = this._parts[i][j];
				drawMethod = (j === 0 ? 'move' : 'line') + 'To';

				this._ctx[drawMethod](point.x, point.y);
			}
			// TODO refactor ugly hack
			if (this instanceof L.Polygon) {
				this._ctx.closePath();
			}
		}
	},

	_checkIfEmpty: function () {
		return !this._parts.length;
	},

	_updatePath: function () {
		if (this._checkIfEmpty()) { return; }

		var ctx = this._ctx,
		    options = this.options;

		this._drawPath();
		ctx.save();
		this._updateStyle();

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke) {
			ctx.globalAlpha = options.opacity;
			ctx.stroke();
		}

		ctx.restore();

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_initEvents: function () {
		if (this.options.clickable) {
			this._map.on('mousemove', this._onMouseMove, this);
			this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);
		}
	},

	_fireMouseEvent: function (e) {
		if (this._containsPoint(e.layerPoint)) {
			this.fire(e.type, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		// TODO don't do on each move
		if (this._containsPoint(e.layerPoint)) {
			this._ctx.canvas.style.cursor = 'pointer';
			this._mouseInside = true;
			this.fire('mouseover', e);

		} else if (this._mouseInside) {
			this._ctx.canvas.style.cursor = '';
			this._mouseInside = false;
			this.fire('mouseout', e);
		}
	}
});

L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
	_initPathRoot: function () {
		var root = this._pathRoot,
		    ctx;

		if (!root) {
			root = this._pathRoot = document.createElement('canvas');
			root.style.position = 'absolute';
			ctx = this._canvasCtx = root.getContext('2d');

			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			this._panes.overlayPane.appendChild(root);

			if (this.options.zoomAnimation) {
				this._pathRoot.className = 'leaflet-zoom-animated';
				this.on('zoomanim', this._animatePathZoom);
				this.on('zoomend', this._endPathZoom);
			}
			this.on('moveend', this._updateCanvasViewport);
			this._updateCanvasViewport();
		}
	},

	_updateCanvasViewport: function () {
		// don't redraw while zooming. See _updateSvgViewport for more details
		if (this._pathZooming) { return; }
		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    size = vp.max.subtract(min),
		    root = this._pathRoot;

		//TODO check if this works properly on mobile webkit
		L.DomUtil.setPosition(root, min);
		root.width = size.x;
		root.height = size.y;
		root.getContext('2d').translate(-min.x, -min.y);
	}
});


/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

/*jshint bitwise:false */ // allow bitwise operations for this file

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max;

		if (code & 8) { // top
			return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
		} else if (code & 4) { // bottom
			return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
		} else if (code & 2) { // right
			return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
		} else if (code & 1) { // left
			return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
		}
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}
		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};


/*
 * L.Polyline is used to display polylines on a map.
 */

L.Polyline = L.Path.extend({
	initialize: function (latlngs, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlngs = this._convertLatLngs(latlngs);
	},

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0,
		noClip: false
	},

	projectLatlngs: function () {
		this._originalPoints = [];

		for (var i = 0, len = this._latlngs.length; i < len; i++) {
			this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
		}
	},

	getPathString: function () {
		for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
			str += this._getPathPartStr(this._parts[i]);
		}
		return str;
	},

	getLatLngs: function () {
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._latlngs = this._convertLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		this._latlngs.push(L.latLng(latlng));
		return this.redraw();
	},

	spliceLatLngs: function () { // (Number index, Number howMany)
		var removed = [].splice.apply(this._latlngs, arguments);
		this._convertLatLngs(this._latlngs, true);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

		for (var j = 0, jLen = parts.length; j < jLen; j++) {
			var points = parts[j];
			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];
				var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getBounds: function () {
		return new L.LatLngBounds(this.getLatLngs());
	},

	_convertLatLngs: function (latlngs, overwrite) {
		var i, len, target = overwrite ? latlngs : [];

		for (i = 0, len = latlngs.length; i < len; i++) {
			if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
				return;
			}
			target[i] = L.latLng(latlngs[i]);
		}
		return target;
	},

	_initEvents: function () {
		L.Path.prototype._initEvents.call(this);
	},

	_getPathPartStr: function (points) {
		var round = L.Path.VML;

		for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
			p = points[j];
			if (round) {
				p._round();
			}
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}
		return str;
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    len = points.length,
		    i, k, segment;

		if (this.options.noClip) {
			this._parts = [points];
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    vp = this._map._pathViewport,
		    lu = L.LineUtil;

		for (i = 0, k = 0; i < len - 1; i++) {
			segment = lu.clipSegment(points[i], points[i + 1], vp, i);
			if (!segment) {
				continue;
			}

			parts[k] = parts[k] || [];
			parts[k].push(segment[0]);

			// if segment goes out of screen, or it's the last one, it's the end of the line part
			if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
				parts[k].push(segment[1]);
				k++;
			}
		}
	},

	// simplify each clipped part of the polyline
	_simplifyPoints: function () {
		var parts = this._parts,
		    lu = L.LineUtil;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
		}
	},

	_updatePath: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();

		L.Path.prototype._updatePath.call(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};


/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

/*jshint bitwise:false */ // allow bitwise operations here

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};


/*
 * L.Polygon is used to display polygons on a map.
 */

L.Polygon = L.Polyline.extend({
	options: {
		fill: true
	},

	initialize: function (latlngs, options) {
		L.Polyline.prototype.initialize.call(this, latlngs, options);
		this._initWithHoles(latlngs);
	},

	_initWithHoles: function (latlngs) {
		var i, len, hole;
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._latlngs = this._convertLatLngs(latlngs[0]);
			this._holes = latlngs.slice(1);

			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
				if (hole[0].equals(hole[hole.length - 1])) {
					hole.pop();
				}
			}
		}

		// filter out last point if its equal to the first one
		latlngs = this._latlngs;

		if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
			latlngs.pop();
		}
	},

	projectLatlngs: function () {
		L.Polyline.prototype.projectLatlngs.call(this);

		// project polygon holes points
		// TODO move this logic to Polyline to get rid of duplication
		this._holePoints = [];

		if (!this._holes) { return; }

		var i, j, len, len2;

		for (i = 0, len = this._holes.length; i < len; i++) {
			this._holePoints[i] = [];

			for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
				this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
			}
		}
	},

	setLatLngs: function (latlngs) {
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._initWithHoles(latlngs);
			return this.redraw();
		} else {
			return L.Polyline.prototype.setLatLngs.call(this, latlngs);
		}
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    newParts = [];

		this._parts = [points].concat(this._holePoints);

		if (this.options.noClip) { return; }

		for (var i = 0, len = this._parts.length; i < len; i++) {
			var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
			if (clipped.length) {
				newParts.push(clipped);
			}
		}

		this._parts = newParts;
	},

	_getPathPartStr: function (points) {
		var str = L.Polyline.prototype._getPathPartStr.call(this, points);
		return str + (L.Browser.svg ? 'z' : 'x');
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};


/*
 * Contains L.MultiPolyline and L.MultiPolygon layers.
 */

(function () {
	function createMulti(Klass) {

		return L.FeatureGroup.extend({

			initialize: function (latlngs, options) {
				this._layers = {};
				this._options = options;
				this.setLatLngs(latlngs);
			},

			setLatLngs: function (latlngs) {
				var i = 0,
				    len = latlngs.length;

				this.eachLayer(function (layer) {
					if (i < len) {
						layer.setLatLngs(latlngs[i++]);
					} else {
						this.removeLayer(layer);
					}
				}, this);

				while (i < len) {
					this.addLayer(new Klass(latlngs[i++], this._options));
				}

				return this;
			},

			getLatLngs: function () {
				var latlngs = [];

				this.eachLayer(function (layer) {
					latlngs.push(layer.getLatLngs());
				});

				return latlngs;
			}
		});
	}

	L.MultiPolyline = createMulti(L.Polyline);
	L.MultiPolygon = createMulti(L.Polygon);

	L.multiPolyline = function (latlngs, options) {
		return new L.MultiPolyline(latlngs, options);
	};

	L.multiPolygon = function (latlngs, options) {
		return new L.MultiPolygon(latlngs, options);
	};
}());


/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};


/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 */

L.Circle = L.Path.extend({
	initialize: function (latlng, radius, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	options: {
		fill: true
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		return this.redraw();
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	projectLatlngs: function () {
		var lngRadius = this._getLngRadius(),
		    latlng = this._latlng,
		    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

		this._point = this._map.latLngToLayerPoint(latlng);
		this._radius = Math.max(this._point.x - pointLeft.x, 1);
	},

	getBounds: function () {
		var lngRadius = this._getLngRadius(),
		    latRadius = (this._mRadius / 40075017) * 360,
		    latlng = this._latlng;

		return new L.LatLngBounds(
		        [latlng.lat - latRadius, latlng.lng - lngRadius],
		        [latlng.lat + latRadius, latlng.lng + lngRadius]);
	},

	getLatLng: function () {
		return this._latlng;
	},

	getPathString: function () {
		var p = this._point,
		    r = this._radius;

		if (this._checkIfEmpty()) {
			return '';
		}

		if (L.Browser.svg) {
			return 'M' + p.x + ',' + (p.y - r) +
			       'A' + r + ',' + r + ',0,1,1,' +
			       (p.x - 0.1) + ',' + (p.y - r) + ' z';
		} else {
			p._round();
			r = Math.round(r);
			return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
		}
	},

	getRadius: function () {
		return this._mRadius;
	},

	// TODO Earth hardcoded, move into projection code!

	_getLatRadius: function () {
		return (this._mRadius / 40075017) * 360;
	},

	_getLngRadius: function () {
		return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
	},

	_checkIfEmpty: function () {
		if (!this._map) {
			return false;
		}
		var vp = this._map._pathViewport,
		    r = this._radius,
		    p = this._point;

		return p.x - r > vp.max.x || p.y - r > vp.max.y ||
		       p.x + r < vp.min.x || p.y + r < vp.min.y;
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};


/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Circle.extend({
	options: {
		radius: 10,
		weight: 2
	},

	initialize: function (latlng, options) {
		L.Circle.prototype.initialize.call(this, latlng, null, options);
		this._radius = this.options.radius;
	},

	projectLatlngs: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
	},

	_updateStyle : function () {
		L.Circle.prototype._updateStyle.call(this);
		this.setRadius(this.options.radius);
	},

	setLatLng: function (latlng) {
		L.Circle.prototype.setLatLng.call(this, latlng);
		if (this._popup && this._popup._isOpen) {
			this._popup.setLatLng(latlng);
		}
		return this;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};


/*
 * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
 */

L.Polyline.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, dist, part,
		    w = this.options.weight / 2;

		if (L.Browser.touch) {
			w += 10; // polyline click tolerance on touch devices
		}

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) {
					continue;
				}

				dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

				if (dist <= w) {
					return true;
				}
			}
		}
		return false;
	}
});


/*
 * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
 */

L.Polygon.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2,
		    i, j, k,
		    len, len2;

		// TODO optimization: check if within bounds first

		if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
			// click on polygon border
			return true;
		}

		// ray casting algorithm for detecting if point is in polygon

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) &&
						(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		return inside;
	}
});


/*
 * Extends L.Circle with Canvas-specific code.
 */

L.Circle.include(!L.Path.CANVAS ? {} : {
	_drawPath: function () {
		var p = this._point;
		this._ctx.beginPath();
		this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
	},

	_containsPoint: function (p) {
		var center = this._point,
		    w2 = this.options.stroke ? this.options.weight / 2 : 0;

		return (p.distanceTo(center) <= this._radius + w2);
	}
});


/*
 * CircleMarker canvas specific drawing parts.
 */

L.CircleMarker.include(!L.Path.CANVAS ? {} : {
	_updateStyle: function () {
		L.Path.prototype._updateStyle.call(this);
	}
});


/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// Only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(features[i]);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		var style = this.options.style;
		if (style) {
			// reset any custom styles
			L.Util.extend(layer.options, layer.defaultOptions);

			this._setLayerStyle(layer, style);
		}
	},

	setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    latlng, latlngs, i, len;

		coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
			latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
			return new L.Polyline(latlngs, vectorOptions);

		case 'Polygon':
			if (coords.length === 2 && !coords[1].length) {
				throw new Error('Invalid GeoJSON object.');
			}
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.Polygon(latlngs, vectorOptions);

		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.MultiPolyline(latlngs, vectorOptions);

		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
			return new L.MultiPolygon(latlngs, vectorOptions);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, pointToLayer, coordsToLatLng, vectorOptions));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
		var latlng, i, len,
		    latlngs = [];

		for (i = 0, len = coords.length; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		var coords = [latlng.lng, latlng.lat];

		if (latlng.alt !== undefined) {
			coords.push(latlng.alt);
		}
		return coords;
	},

	latLngsToCoords: function (latLngs) {
		var coords = [];

		for (var i = 0, len = latLngs.length; i < len; i++) {
			coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.include({
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'LineString',
			coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
		});
	}
});

L.Polygon.include({
	toGeoJSON: function () {
		var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
		    i, len, hole;

		coords[0].push(coords[0][0]);

		if (this._holes) {
			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
				hole.push(hole[0]);
				coords.push(hole);
			}
		}

		return L.GeoJSON.getFeature(this, {
			type: 'Polygon',
			coordinates: coords
		});
	}
});

(function () {
	function multiToGeoJSON(type) {
		return function () {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON().geometry.coordinates);
			});

			return L.GeoJSON.getFeature(this, {
				type: type,
				coordinates: coords
			});
		};
	}

	L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
	L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

	L.LayerGroup.include({
		toGeoJSON: function () {

			var geometry = this.feature && this.feature.geometry,
				jsons = [],
				json;

			if (geometry && geometry.type === 'MultiPoint') {
				return multiToGeoJSON('MultiPoint').call(this);
			}

			var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					json = layer.toGeoJSON();
					jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
				}
			});

			if (isGeometryCollection) {
				return L.GeoJSON.getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});
}());

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};


/*
 * L.DomEvent contains functions for working with DOM events.
 */

L.DomEvent = {
	/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
	addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler, originalHandler, newType;

		if (obj[key]) { return this; }

		handler = function (e) {
			return fn.call(context || obj, e || L.DomEvent._getEvent());
		};

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			return this.addPointerListener(obj, type, handler, id);
		}
		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);
		}

		if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {

				originalHandler = handler;
				newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

				handler = function (e) {
					if (!L.DomEvent._checkMouse(obj, e)) { return; }
					return originalHandler(e);
				};

				obj.addEventListener(newType, handler, false);

			} else if (type === 'click' && L.Browser.android) {
				originalHandler = handler;
				handler = function (e) {
					return L.DomEvent._filterClick(e, originalHandler);
				};

				obj.addEventListener(type, handler, false);
			} else {
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[key] = handler;

		return this;
	},

	removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler = obj[key];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);
		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
			} else {
				obj.removeEventListener(type, handler, false);
			}
		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[key] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		return L.DomEvent
			.on(el, 'mousewheel', stop)
			.on(el, 'MozMousePixelScroll', stop);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(el, L.Draggable.START[i], stop);
		}

		return L.DomEvent
			.on(el, 'click', L.DomEvent._fakeStop)
			.on(el, 'dblclick', stop);
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	_getEvent: function () { // evil magic for IE
		/*jshint noarg:false */
		var e = window.event;
		if (!e) {
			var caller = arguments.callee.caller;
			while (caller) {
				e = caller['arguments'][0];
				if (e && window.Event === e.constructor) {
					break;
				}
				caller = caller.caller;
			}
		}
		return e;
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		return handler(e);
	}
};

L.DomEvent.on = L.DomEvent.addListener;
L.DomEvent.off = L.DomEvent.removeListener;


/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Class.extend({
	includes: L.Mixin.Events,

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
	},

	enable: function () {
		if (this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (L.Draggable._disabled) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');
			this._lastTarget = e.target || e.srcElement;
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		this.fire('predrag');
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag');
	},

	_onUp: function () {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove)
			    .off(document, L.Draggable.END[i], this._onUp);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});


/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});


/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
	easeLinearity: 0.25,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				'dragstart': this._onDragStart,
				'drag': this._onDrag,
				'dragend': this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		var map = this._map;

		if (map._panAnim) {
			map._panAnim.stop();
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move')
		    .fire('drag');
	},

	_onViewReset: function () {
		// TODO fix hardcoded Earth values
		var pxCenter = this._map.getSize()._divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.project([0, 180]).x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,
		    delay = +new Date() - this._lastTime,

		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime + delay - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
		L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
		L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(40 - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.preventDefault(e);
		L.DomEvent.stopPropagation(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last,
		    doubleTap = false,
		    delay = 250,
		    touch,
		    pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend,
		    trackedTouches = [];

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length;
			} else {
				count = e.touches.length;
			}
			if (count > 1) {
				return;
			}

			var now = Date.now(),
				delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) {
					return;
				}
				trackedTouches.splice(idx, 1);
			}

			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = { },
						prop;

					// jshint forin:false
					for (var i in touch) {
						prop = touch[i];
						if (typeof prop === 'function') {
							newTouch[i] = prop.bind(touch);
						} else {
							newTouch[i] = prop;
						}
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}
		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
		// will not come through to us, so we will lose track of how many touches are ongoing
		var endElement = L.Browser.pointer ? document.documentElement : obj;

		obj.addEventListener(touchstart, onTouchStart, false);
		endElement.addEventListener(touchend, onTouchEnd, false);

		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_';

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		(L.Browser.pointer ? document.documentElement : obj).removeEventListener(
		        this._touchend, obj[pre + this._touchend + id], false);

		if (L.Browser.pointer) {
			document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
				false);
		}

		return this;
	}
});


/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	//static
	POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
	POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
	POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: [],
	_pointerDocumentListener: false,

	// Provides a touch events wrapper for (ms)pointer events.
	// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
	//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		switch (type) {
		case 'touchstart':
			return this.addPointerListenerStart(obj, type, handler, id);
		case 'touchend':
			return this.addPointerListenerEnd(obj, type, handler, id);
		case 'touchmove':
			return this.addPointerListenerMove(obj, type, handler, id);
		default:
			throw 'Unknown touch event type';
		}
	},

	addPointerListenerStart: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    pointers = this._pointers;

		var cb = function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				L.DomEvent.preventDefault(e);
			}

			var alreadyInArray = false;
			for (var i = 0; i < pointers.length; i++) {
				if (pointers[i].pointerId === e.pointerId) {
					alreadyInArray = true;
					break;
				}
			}
			if (!alreadyInArray) {
				pointers.push(e);
			}

			e.touches = pointers.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchstart' + id] = cb;
		obj.addEventListener(this.POINTER_DOWN, cb, false);

		// need to also listen for end events to keep the _pointers list accurate
		// this needs to be on the body and never go away
		if (!this._pointerDocumentListener) {
			var internalCb = function (e) {
				for (var i = 0; i < pointers.length; i++) {
					if (pointers[i].pointerId === e.pointerId) {
						pointers.splice(i, 1);
						break;
					}
				}
			};
			//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

			this._pointerDocumentListener = true;
		}

		return this;
	},

	addPointerListenerMove: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		function cb(e) {

			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches[i] = e;
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		}

		obj[pre + 'touchmove' + id] = cb;
		obj.addEventListener(this.POINTER_MOVE, cb, false);

		return this;
	},

	addPointerListenerEnd: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		var cb = function (e) {
			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches.splice(i, 1);
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchend' + id] = cb;
		obj.addEventListener(this.POINTER_UP, cb, false);
		obj.addEventListener(this.POINTER_CANCEL, cb, false);

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var pre = '_leaflet_',
		    cb = obj[pre + type + id];

		switch (type) {
		case 'touchstart':
			obj.removeEventListener(this.POINTER_DOWN, cb, false);
			break;
		case 'touchmove':
			obj.removeEventListener(this.POINTER_MOVE, cb, false);
			break;
		case 'touchend':
			obj.removeEventListener(this.POINTER_UP, cb, false);
			obj.removeEventListener(this.POINTER_CANCEL, cb, false);
			break;
		}

		return this;
	}
});


/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		if (map._panAnim) {
			map._panAnim.stop();
		}

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (this._scale === 1) { return; }

		if (!map.options.bounceAtZoomLimits) {
			if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
			    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
		}

		if (!this._moved) {
			L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(
		        this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map,
		    origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),
		    zoom = map.getScaleZoom(this._scale);

		map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		var map = this._map;

		this._zooming = false;
		L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),

		    oldZoom = map.getZoom(),
		    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
		    roundZoomDelta = (floatZoomDelta > 0 ?
		            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

		    zoom = map._limitZoom(oldZoom + roundZoomDelta),
		    scale = map.getZoomScale(zoom) / this._scale;

		map._animateZoom(center, zoom, origin, scale);
	},

	_getScaleOrigin: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		L.DomEvent
			.on(document, 'touchmove', this._onMove, this)
			.on(document, 'touchend', this._onUp, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent
			.off(document, 'touchmove', this._onMove, this)
			.off(document, 'touchend', this._onUp, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}


/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._moved = false;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
		this._moved = false;
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		this._moved = false;

		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

		L.DomEvent
		    .on(document, 'mousemove', this._onMouseMove, this)
		    .on(document, 'mouseup', this._onMouseUp, this)
		    .on(document, 'keydown', this._onKeyDown, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
			L.DomUtil.setPosition(this._box, this._startLayerPoint);

			//TODO refactor: move cursor to styles
			this._container.style.cursor = 'crosshair';
			this._map.fire('boxzoomstart');
		}

		var startPoint = this._startLayerPoint,
		    box = this._box,

		    layerPoint = this._map.mouseEventToLayerPoint(e),
		    offset = layerPoint.subtract(startPoint),

		    newPos = new L.Point(
		        Math.min(layerPoint.x, startPoint.x),
		        Math.min(layerPoint.y, startPoint.y));

		L.DomUtil.setPosition(box, newPos);

		this._moved = true;

		// TODO refactor: remove hardcoded 4 pixels
		box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
		box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
	},

	_finish: function () {
		if (this._moved) {
			this._pane.removeChild(this._box);
			this._container.style.cursor = '';
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent
		    .off(document, 'mousemove', this._onMouseMove)
		    .off(document, 'mouseup', this._onMouseUp)
		    .off(document, 'keydown', this._onKeyDown);
	},

	_onMouseUp: function (e) {

		this._finish();

		var map = this._map,
		    layerPoint = map.mouseEventToLayerPoint(e);

		if (this._startLayerPoint.equals(layerPoint)) { return; }

		var bounds = new L.LatLngBounds(
		        map.layerPointToLatLng(this._startLayerPoint),
		        map.layerPointToLatLng(layerPoint));

		map.fitBounds(bounds);

		map.fire('boxzoomend', {
			boxZoomBounds: bounds
		});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent
		    .on(container, 'focus', this._onFocus, this)
		    .on(container, 'blur', this._onBlur, this)
		    .on(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .on('focus', this._addHooks, this)
		    .on('blur', this._removeHooks, this);
	},

	removeHooks: function () {
		this._removeHooks();

		var container = this._map._container;

		L.DomEvent
		    .off(container, 'focus', this._onFocus, this)
		    .off(container, 'blur', this._onBlur, this)
		    .off(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .off('focus', this._addHooks, this)
		    .off('blur', this._removeHooks, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key]);

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;
		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon);
		}

		this._draggable
			.on('dragstart', this._onDragStart, this)
			.on('drag', this._onDrag, this)
			.on('dragend', this._onDragEnd, this);
		this._draggable.enable();
		L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable
			.off('dragstart', this._onDragStart, this)
			.off('drag', this._onDrag, this)
			.off('dragend', this._onDragEnd, this);

		this._draggable.disable();
		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function () {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;

		marker
		    .fire('move', {latlng: latlng})
		    .fire('drag');
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});


/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	removeFrom: function (map) {
		var pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		corner.removeChild(this._container);
		this._map = null;

		if (this.onRemove) {
			this.onRemove(map);
		}

		return this;
	},

	_refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.removeFrom(this);
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		this._container.removeChild(this._controlContainer);
	}
});


/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
	options: {
		position: 'topleft',
		zoomInText: '+',
		zoomInTitle: 'Zoom in',
		zoomOutText: '-',
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

		this._map = map;

		this._zoomInButton  = this._createButton(
		        this.options.zoomInText, this.options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn,  this);
		this._zoomOutButton = this._createButton(
		        this.options.zoomOutText, this.options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut, this);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	_zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1);
	},

	_zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1);
	},

	_createButton: function (html, title, className, container, fn, context) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
		    .on(link, 'click', stop)
		    .on(link, 'mousedown', stop)
		    .on(link, 'dblclick', stop)
		    .on(link, 'click', L.DomEvent.preventDefault)
		    .on(link, 'click', fn, context)
		    .on(link, 'click', this._refocusOnMap, context);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		L.DomEvent.disableClickPropagation(this._container);

		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}
		
		map
		    .on('layeradd', this._onLayerAdd, this)
		    .on('layerremove', this._onLayerRemove, this);

		this._update();

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerAdd)
		    .off('layerremove', this._onLayerRemove);

	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	},

	_onLayerAdd: function (e) {
		if (e.layer.getAttribution) {
			this.addAttribution(e.layer.getAttribution());
		}
	},

	_onLayerRemove: function (e) {
		if (e.layer.getAttribution) {
			this.removeAttribution(e.layer.getAttribution());
		}
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true,
		updateWhenIdle: false
	},

	onAdd: function (map) {
		this._map = map;

		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className, container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className + '-line', container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className + '-line', container);
		}
	},

	_update: function () {
		var bounds = this._map.getBounds(),
		    centerLat = bounds.getCenter().lat,
		    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
		    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

		    size = this._map.getSize(),
		    options = this.options,
		    maxMeters = 0;

		if (size.x > 0) {
			maxMeters = dist * (options.maxWidth / size.x);
		}

		this._updateScales(options, maxMeters);
	},

	_updateScales: function (options, maxMeters) {
		if (options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}

		if (options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters);

		this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
		this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    scale = this._iScale,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);

			scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
			scale.innerHTML = miles + ' mi';

		} else {
			feet = this._getRoundNum(maxFeet);

			scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
			scale.innerHTML = feet + ' ft';
		}
	},

	_getScaleWidth: function (ratio) {
		return Math.round(this.options.maxWidth * ratio) - 10;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};


/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		map
		    .on('layeradd', this._onLayerChange, this)
		    .on('layerremove', this._onLayerChange, this);

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerChange, this)
		    .off('layerremove', this._onLayerChange, this);
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		this._update();
		return this;
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		this._update();
		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);
		delete this._layers[id];
		this._update();
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent
				    .on(container, 'mouseover', this._expand, this)
				    .on(container, 'mouseout', this._collapse, this);
			}
			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			}
			else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}
			//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) {
			return;
		}

		this._baseLayersList.innerHTML = '';
		this._overlaysList.innerHTML = '';

		var baseLayersPresent = false,
		    overlaysPresent = false,
		    i, obj;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
	},

	_onLayerChange: function (e) {
		var obj = this._layers[L.stamp(e.layer)];

		if (!obj) { return; }

		if (!this._handlingClick) {
			this._update();
		}

		var type = obj.overlay ?
			(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'layeradd' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
		if (checked) {
			radioHtml += ' checked="checked"';
		}
		radioHtml += '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    input,
		    checked = this._map.hasLayer(obj.layer);

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var i, input, obj,
		    inputs = this._form.getElementsByTagName('input'),
		    inputsLen = inputs.length;

		this._handlingClick = true;

		for (i = 0; i < inputsLen; i++) {
			input = inputs[i];
			obj = this._layers[input.layerId];

			if (input.checked && !this._map.hasLayer(obj.layer)) {
				this._map.addLayer(obj.layer);

			} else if (!input.checked && this._map.hasLayer(obj.layer)) {
				this._map.removeLayer(obj.layer);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};


/*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */

L.PosAnimation = L.Class.extend({
	includes: L.Mixin.Events,

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;

		this.fire('start');

		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);

		// toggle reflow, Chrome flickers for some reason if you don't do this
		L.Util.falseFn(el.offsetWidth);

		// there's no native way to track value updates of transitioned properties, so we imitate this
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
	},

	stop: function () {
		if (!this._inProgress) { return; }

		// if we just removed the transition property, the element would jump to its final position,
		// so we need to make it stay at the current position

		L.DomUtil.setPosition(this._el, this._getPos());
		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
	},

	_onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return;
		}
		// jshint camelcase: false
		// make L.DomUtil.getPosition return intermediate position value during animation
		this._el._leaflet_pos = stepPos;

		this.fire('step');
	},

	// you can't easily get intermediate values of properties animated with CSS3 Transitions,
	// we need to parse computed style (in case of transform it returns matrix string)

	_transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

	_getPos: function () {
		var left, top, matches,
		    el = this._el,
		    style = window.getComputedStyle(el);

		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) { return; }
			left = parseFloat(matches[1]);
			top  = parseFloat(matches[2]);
		} else {
			left = parseFloat(style.left);
			top  = parseFloat(style.top);
		}

		return new L.Point(left, top, true);
	},

	_onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

		if (!this._inProgress) { return; }
		this._inProgress = false;

		this._el.style[L.DomUtil.TRANSITION] = '';

		// jshint camelcase: false
		// make sure L.DomUtil.getPosition returns the final position value after animation
		this._el._leaflet_pos = this._newPos;

		clearInterval(this._stepTimer);

		this.fire('step').fire('end');
	}

});


/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		if (this._panAnim) {
			this._panAnim.stop();
		}

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});


/*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */

L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step();
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function () {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration));
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});


/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

if (L.DomUtil.TRANSITION) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
				L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!L.DomUtil.TRANSITION ? {} : {

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
			origin = this._getCenterLayerPoint()._add(offset);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		this
		    .fire('movestart')
		    .fire('zoomstart');

		this._animateZoom(center, zoom, origin, scale, null, true);

		return true;
	},

	_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {

		if (!forTouchZoom) {
			this._animatingZoom = true;
		}

		// put transform transition on all layers with leaflet-zoom-animated class
		L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

		// remember what center/zoom to set after animation
		this._animateToCenter = center;
		this._animateToZoom = zoom;

		// disable any dragging during animation
		if (L.Draggable) {
			L.Draggable._disabled = true;
		}

		L.Util.requestAnimFrame(function () {
			this.fire('zoomanim', {
				center: center,
				zoom: zoom,
				origin: origin,
				scale: scale,
				delta: delta,
				backwards: backwards
			});
			// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689
			setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
		}, this);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		L.Util.requestAnimFrame(function () {
			this._resetView(this._animateToCenter, this._animateToZoom, true, true);

			if (L.Draggable) {
				L.Draggable._disabled = false;
			}
		}, this);
	}
});


/*
	Zoom animation logic for L.TileLayer.
*/

L.TileLayer.include({
	_animateZoom: function (e) {
		if (!this._animating) {
			this._animating = true;
			this._prepareBgBuffer();
		}

		var bg = this._bgBuffer,
		    transform = L.DomUtil.TRANSFORM,
		    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
		    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

		bg.style[transform] = e.backwards ?
				scaleStr + ' ' + initialTransform :
				initialTransform + ' ' + scaleStr;
	},

	_endZoomAnim: function () {
		var front = this._tileContainer,
		    bg = this._bgBuffer;

		front.style.visibility = '';
		front.parentNode.appendChild(front); // Bring to fore

		// force reflow
		L.Util.falseFn(bg.offsetWidth);

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			this._clearBgBuffer();
		}

		this._animating = false;
	},

	_clearBgBuffer: function () {
		var map = this._map;

		if (map && !map._animatingZoom && !map.touchZoom._zooming) {
			this._bgBuffer.innerHTML = '';
			this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
		}
	},

	_prepareBgBuffer: function () {

		var front = this._tileContainer,
		    bg = this._bgBuffer;

		// if foreground layer doesn't have many tiles but bg layer does,
		// keep the existing bg layer and just zoom it some more

		var bgLoaded = this._getLoadedTilesPercentage(bg),
		    frontLoaded = this._getLoadedTilesPercentage(front);

		if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

			front.style.visibility = 'hidden';
			this._stopLoadingImages(front);
			return;
		}

		// prepare the buffer to become the front tile pane
		bg.style.visibility = 'hidden';
		bg.style[L.DomUtil.TRANSFORM] = '';

		// switch out the current layer to be the new bg layer (and vice-versa)
		this._tileContainer = bg;
		bg = this._bgBuffer = front;

		this._stopLoadingImages(bg);

		//prevent bg buffer from clearing right after zoom
		clearTimeout(this._clearBgBufferTimer);
	},

	_getLoadedTilesPercentage: function (container) {
		var tiles = container.getElementsByTagName('img'),
		    i, len, count = 0;

		for (i = 0, len = tiles.length; i < len; i++) {
			if (tiles[i].complete) {
				count++;
			}
		}
		return count / len;
	},

	// stops loading all tiles in the background layer
	_stopLoadingImages: function (container) {
		var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
		    i, len, tile;

		for (i = 0, len = tiles.length; i < len; i++) {
			tile = tiles[i];

			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;

				tile.parentNode.removeChild(tile);
			}
		}
	}
});


/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		watch: false,
		setView: false,
		maxZoom: Infinity,
		timeout: 10000,
		maximumAge: 0,
		enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

		if (!navigator.geolocation) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),

		    latAccuracy = 180 * pos.coords.accuracy / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

		    bounds = L.latLngBounds(
		            [lat - latAccuracy, lng - lngAccuracy],
		            [lat + latAccuracy, lng + lngAccuracy]),

		    options = this._locateOptions;

		if (options.setView) {
			var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
			this.setView(latlng, zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});


}(window, document));
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/queue-async/build/queue.js":[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('queue', factory) :
  (global.queue = factory());
}(this, function () { 'use strict';

  var slice = [].slice;

  function noop() {}

  var noabort = {};
  var success = [null];
  function newQueue(concurrency) {
    if (!(concurrency >= 1)) throw new Error;

    var q,
        tasks = [],
        results = [],
        waiting = 0,
        active = 0,
        ended = 0,
        starting, // inside a synchronous task callback?
        error,
        callback = noop,
        callbackAll = true;

    function start() {
      if (starting) return; // let the current task complete
      while (starting = waiting && active < concurrency) {
        var i = ended + active,
            t = tasks[i],
            j = t.length - 1,
            c = t[j];
        t[j] = end(i);
        --waiting, ++active, tasks[i] = c.apply(null, t) || noabort;
      }
    }

    function end(i) {
      return function(e, r) {
        if (!tasks[i]) throw new Error; // detect multiple callbacks
        --active, ++ended, tasks[i] = null;
        if (error != null) return; // only report the first error
        if (e != null) {
          abort(e);
        } else {
          results[i] = r;
          if (waiting) start();
          else if (!active) notify();
        }
      };
    }

    function abort(e) {
      error = e; // ignore new tasks and squelch active callbacks
      waiting = NaN; // stop queued tasks from starting
      notify();
    }

    function notify() {
      if (error != null) callback(error);
      else if (callbackAll) callback(null, results);
      else callback.apply(null, success.concat(results));
    }

    return q = {
      defer: function(f) {
        if (callback !== noop) throw new Error;
        var t = slice.call(arguments, 1);
        t.push(f);
        ++waiting, tasks.push(t);
        start();
        return q;
      },
      abort: function() {
        if (error == null) {
          var i = ended + active, t;
          while (--i >= 0) (t = tasks[i]) && t.abort && t.abort();
          abort(new Error("abort"));
        }
        return q;
      },
      await: function(f) {
        if (callback !== noop) throw new Error;
        callback = f, callbackAll = false;
        if (!waiting && !active) notify();
        return q;
      },
      awaitAll: function(f) {
        if (callback !== noop) throw new Error;
        callback = f, callbackAll = true;
        if (!waiting && !active) notify();
        return q;
      }
    };
  }

  function queue(concurrency) {
    return newQueue(arguments.length ? +concurrency : Infinity);
  }

  queue.version = "1.2.1";

  return queue;

}));
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Handle.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcTooltip = require('rc-tooltip');

var _rcTooltip2 = _interopRequireDefault(_rcTooltip);

var Handle = (function (_React$Component) {
  _inherits(Handle, _React$Component);

  function Handle(props) {
    _classCallCheck(this, Handle);

    _get(Object.getPrototypeOf(Handle.prototype), 'constructor', this).call(this, props);

    this.state = {
      isTooltipVisible: false
    };
  }

  _createClass(Handle, [{
    key: 'showTooltip',
    value: function showTooltip() {
      this.setState({
        isTooltipVisible: true
      });
    }
  }, {
    key: 'hideTooltip',
    value: function hideTooltip() {
      this.setState({
        isTooltipVisible: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var props = this.props;
      var className = props.className;
      var tipTransitionName = props.tipTransitionName;
      var tipFormatter = props.tipFormatter;
      var vertical = props.vertical;
      var offset = props.offset;
      var value = props.value;
      var dragging = props.dragging;
      var noTip = props.noTip;

      var style = vertical ? { bottom: offset + '%' } : { left: offset + '%' };
      var handle = _react2['default'].createElement('div', { className: className, style: style,
        onMouseUp: this.showTooltip.bind(this),
        onMouseEnter: this.showTooltip.bind(this),
        onMouseLeave: this.hideTooltip.bind(this) });

      if (noTip) {
        return handle;
      }

      var isTooltipVisible = dragging || this.state.isTooltipVisible;
      return _react2['default'].createElement(
        _rcTooltip2['default'],
        {
          prefixCls: className.replace('slider-handle', 'tooltip'),
          placement: 'top',
          visible: isTooltipVisible,
          overlay: _react2['default'].createElement(
            'span',
            null,
            tipFormatter(value)
          ),
          delay: 0,
          transitionName: tipTransitionName },
        handle
      );
    }
  }]);

  return Handle;
})(_react2['default'].Component);

exports['default'] = Handle;

Handle.propTypes = {
  className: _react2['default'].PropTypes.string,
  vertical: _react2['default'].PropTypes.bool,
  offset: _react2['default'].PropTypes.number,
  tipTransitionName: _react2['default'].PropTypes.string,
  tipFormatter: _react2['default'].PropTypes.func,
  value: _react2['default'].PropTypes.number,
  dragging: _react2['default'].PropTypes.bool,
  noTip: _react2['default'].PropTypes.bool
};
module.exports = exports['default'];
},{"rc-tooltip":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Marks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var Marks = function Marks(_ref) {
  var className = _ref.className;
  var vertical = _ref.vertical;
  var marks = _ref.marks;
  var included = _ref.included;
  var upperBound = _ref.upperBound;
  var lowerBound = _ref.lowerBound;
  var max = _ref.max;
  var min = _ref.min;

  var marksKeys = Object.keys(marks);
  var marksCount = marksKeys.length;
  var unit = 100 / (marksCount - 1);
  var markWidth = unit * 0.9;

  var range = max - min;
  var elements = marksKeys.map(parseFloat).sort(function (a, b) {
    return a - b;
  }).map(function (point) {
    var _classNames;

    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var markClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, className + '-text', true), _defineProperty(_classNames, className + '-text-active', isActived), _classNames));

    var bottomStyle = {
      // height: markWidth + '%',
      marginBottom: '-200' + '%',
      bottom: (point - min) / range * 100 + '%'
    };

    var leftStyle = {
      width: markWidth + '%',
      marginLeft: -markWidth / 2 + '%',
      left: (point - min) / range * 100 + '%'
    };

    var style = vertical ? bottomStyle : leftStyle;

    var markPoint = marks[point];
    var markPointIsObject = typeof markPoint === 'object' && !_react2['default'].isValidElement(markPoint);
    var markLabel = markPointIsObject ? markPoint.label : markPoint;
    var markStyle = markPointIsObject ? _extends({}, style, markPoint.style) : style;
    return _react2['default'].createElement(
      'span',
      { className: markClassName, style: markStyle, key: point },
      markLabel
    );
  });

  return _react2['default'].createElement(
    'div',
    { className: className },
    elements
  );
};

exports['default'] = Marks;
module.exports = exports['default'];
},{"classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/classnames/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Slider.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcUtilLibDomAddEventListener = require('rc-util/lib/Dom/addEventListener');

var _rcUtilLibDomAddEventListener2 = _interopRequireDefault(_rcUtilLibDomAddEventListener);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _Handle = require('./Handle');

var _Handle2 = _interopRequireDefault(_Handle);

var _Steps = require('./Steps');

var _Steps2 = _interopRequireDefault(_Steps);

var _Marks = require('./Marks');

var _Marks2 = _interopRequireDefault(_Marks);

function noop() {}

function isNotTouchEvent(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === 'touchend' && e.touches.length > 0;
}

function getTouchPosition(vertical, e) {
  return vertical ? e.touches[0].clientY : e.touches[0].pageX;
}

function getMousePosition(vertical, e) {
  return vertical ? e.clientY : e.pageX;
}

function pauseEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}

var Slider = (function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);

    var range = props.range;
    var min = props.min;
    var max = props.max;

    var initialValue = range ? [min, min] : min;
    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;
    var value = props.value !== undefined ? props.value : defaultValue;

    var upperBound = undefined;
    var lowerBound = undefined;
    if (props.range) {
      lowerBound = this.trimAlignValue(value[0]);
      upperBound = this.trimAlignValue(value[1]);
    } else {
      upperBound = this.trimAlignValue(value);
    }

    var recent = undefined;
    if (props.range && upperBound === lowerBound) {
      recent = lowerBound === max ? 'lowerBound' : 'upperBound';
    } else {
      recent = 'upperBound';
    }

    this.state = {
      handle: null,
      recent: recent,
      upperBound: upperBound,
      // If Slider is not range, set `lowerBound` equal to `min`.
      lowerBound: lowerBound || min
    };
  }

  _createClass(Slider, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;

      var _state = this.state;
      var lowerBound = _state.lowerBound;
      var upperBound = _state.upperBound;

      if (nextProps.range) {
        var value = nextProps.value || [lowerBound, upperBound];
        var nextUpperBound = this.trimAlignValue(value[1], nextProps);
        var nextLowerBound = this.trimAlignValue(value[0], nextProps);
        if (nextLowerBound === lowerBound && nextUpperBound === upperBound) return;

        this.setState({
          upperBound: nextUpperBound,
          lowerBound: nextLowerBound
        });
        if (this.isValueOutOfBounds(upperBound, nextProps) || this.isValueOutOfBounds(lowerBound, nextProps)) {
          this.props.onChange([nextLowerBound, nextUpperBound]);
        }
      } else {
        var value = nextProps.value !== undefined ? nextProps.value : upperBound;
        var nextValue = this.trimAlignValue(value, nextProps);
        if (nextValue === upperBound && lowerBound === nextProps.min) return;

        this.setState({
          upperBound: nextValue,
          lowerBound: nextProps.min
        });
        if (this.isValueOutOfBounds(upperBound, nextProps)) {
          this.props.onChange(nextValue);
        }
      }
    }
  }, {
    key: 'onChange',
    value: function onChange(state) {
      var props = this.props;
      var isNotControlled = !('value' in props);
      if (isNotControlled) {
        this.setState(state);
      } else if (state.handle) {
        this.setState({ handle: state.handle });
      }

      var data = _extends({}, this.state, state);
      var changedValue = props.range ? [data.lowerBound, data.upperBound] : data.upperBound;
      props.onChange(changedValue);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var position = getMousePosition(this.props.vertical, e);
      this.onMove(e, position);
    }
  }, {
    key: 'onTouchMove',
    value: function onTouchMove(e) {
      if (isNotTouchEvent(e)) {
        this.end('touch');
        return;
      }

      var position = getTouchPosition(this.props.vertical, e);
      this.onMove(e, position);
    }
  }, {
    key: 'onMove',
    value: function onMove(e, position) {
      pauseEvent(e);
      var props = this.props;
      var state = this.state;

      var diffPosition = position - this.startPosition;
      diffPosition = this.props.vertical ? -diffPosition : diffPosition;
      var diffValue = diffPosition / this.getSliderLength() * (props.max - props.min);

      var value = this.trimAlignValue(this.startValue + diffValue);
      var oldValue = state[state.handle];
      if (value === oldValue) return;

      if (props.allowCross && value < state.lowerBound && state.handle === 'upperBound') {
        this.onChange({
          handle: 'lowerBound',
          lowerBound: value,
          upperBound: this.state.lowerBound
        });
        return;
      }
      if (props.allowCross && value > state.upperBound && state.handle === 'lowerBound') {
        this.onChange({
          handle: 'upperBound',
          upperBound: value,
          lowerBound: this.state.upperBound
        });
        return;
      }

      this.onChange(_defineProperty({}, state.handle, value));
    }
  }, {
    key: 'onTouchStart',
    value: function onTouchStart(e) {
      if (isNotTouchEvent(e)) return;

      var position = getTouchPosition(this.props.vertical, e);
      this.onStart(position);
      this.addDocumentEvents('touch');
      pauseEvent(e);
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      if (e.button !== 0) {
        return;
      }
      var position = getMousePosition(this.props.vertical, e);
      this.onStart(position);
      this.addDocumentEvents('mouse');
      pauseEvent(e);
    }
  }, {
    key: 'onStart',
    value: function onStart(position) {
      var props = this.props;
      props.onBeforeChange(this.getValue());

      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;

      var state = this.state;
      var upperBound = state.upperBound;
      var lowerBound = state.lowerBound;

      var valueNeedChanging = 'upperBound';
      if (this.props.range) {
        var isLowerBoundCloser = Math.abs(upperBound - value) > Math.abs(lowerBound - value);
        if (isLowerBoundCloser) {
          valueNeedChanging = 'lowerBound';
        }

        var isAtTheSamePoint = upperBound === lowerBound;
        if (isAtTheSamePoint) {
          valueNeedChanging = state.recent;
        }

        if (isAtTheSamePoint && value !== upperBound) {
          valueNeedChanging = value < upperBound ? 'lowerBound' : 'upperBound';
        }
      }

      this.setState({
        handle: valueNeedChanging,
        recent: valueNeedChanging
      });

      var oldValue = state[valueNeedChanging];
      if (value === oldValue) return;

      this.onChange(_defineProperty({}, valueNeedChanging, value));
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var _state2 = this.state;
      var lowerBound = _state2.lowerBound;
      var upperBound = _state2.upperBound;

      return this.props.range ? [lowerBound, upperBound] : upperBound;
    }
  }, {
    key: 'getSliderLength',
    value: function getSliderLength() {
      var slider = this.refs.slider;
      if (!slider) {
        return 0;
      }

      return this.props.vertical ? slider.clientHeight : slider.clientWidth;
    }
  }, {
    key: 'getSliderStart',
    value: function getSliderStart() {
      var slider = this.refs.slider;
      var rect = slider.getBoundingClientRect();

      return this.props.vertical ? rect.top : rect.left;
    }
  }, {
    key: 'getPrecision',
    value: function getPrecision(step) {
      var stepString = step.toString();
      var precision = 0;
      if (stepString.indexOf('.') >= 0) {
        precision = stepString.length - stepString.indexOf('.') - 1;
      }
      return precision;
    }
  }, {
    key: 'isValueOutOfBounds',
    value: function isValueOutOfBounds(value, props) {
      return value < props.min || value > props.max;
    }
  }, {
    key: 'trimAlignValue',
    value: function trimAlignValue(v, nextProps) {
      var state = this.state || {};
      var handle = state.handle;
      var lowerBound = state.lowerBound;
      var upperBound = state.upperBound;

      var _extends2 = _extends({}, this.props, nextProps || {});

      var marks = _extends2.marks;
      var step = _extends2.step;
      var min = _extends2.min;
      var max = _extends2.max;
      var allowCross = _extends2.allowCross;

      var val = v;
      if (val <= min) {
        val = min;
      }
      if (val >= max) {
        val = max;
      }
      if (!allowCross && handle === 'upperBound' && val <= lowerBound) {
        val = lowerBound;
      }
      if (!allowCross && handle === 'lowerBound' && val >= upperBound) {
        val = upperBound;
      }

      var points = Object.keys(marks).map(parseFloat);
      if (step !== null) {
        var closestStep = Math.round((val - min) / step) * step + min;
        points.push(closestStep);
      }

      var diffs = points.map(function (point) {
        return Math.abs(val - point);
      });
      var closestPoint = points[diffs.indexOf(Math.min.apply(Math, diffs))];

      return step !== null ? parseFloat(closestPoint.toFixed(this.getPrecision(step))) : closestPoint;
    }
  }, {
    key: 'calcOffset',
    value: function calcOffset(value) {
      var _props = this.props;
      var min = _props.min;
      var max = _props.max;

      var ratio = (value - min) / (max - min);
      return ratio * 100;
    }
  }, {
    key: 'calcValue',
    value: function calcValue(offset) {
      var _props2 = this.props;
      var vertical = _props2.vertical;
      var min = _props2.min;
      var max = _props2.max;

      var ratio = Math.abs(offset / this.getSliderLength());
      var value = vertical ? (1 - ratio) * (max - min) + min : ratio * (max - min) + min;
      return value;
    }
  }, {
    key: 'calcValueByPos',
    value: function calcValueByPos(position) {
      var pixelOffset = position - this.getSliderStart();
      var nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
      return nextValue;
    }
  }, {
    key: 'addDocumentEvents',
    value: function addDocumentEvents(type) {
      if (type === 'touch') {
        // just work for chrome iOS Safari and Android Browser
        this.onTouchMoveListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'touchmove', this.onTouchMove.bind(this));
        this.onTouchUpListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'touchend', this.end.bind(this, 'touch'));
      } else if (type === 'mouse') {
        this.onMouseMoveListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'mousemove', this.onMouseMove.bind(this));
        this.onMouseUpListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'mouseup', this.end.bind(this, 'mouse'));
      }
    }
  }, {
    key: 'removeEvents',
    value: function removeEvents(type) {
      if (type === 'touch') {
        this.onTouchMoveListener.remove();
        this.onTouchUpListener.remove();
      } else if (type === 'mouse') {
        this.onMouseMoveListener.remove();
        this.onMouseUpListener.remove();
      }
    }
  }, {
    key: 'end',
    value: function end(type) {
      this.removeEvents(type);
      this.props.onAfterChange(this.getValue());
      this.setState({ handle: null });
    }
  }, {
    key: 'render',
    value: function render() {
      var _classNames;

      var _state3 = this.state;
      var handle = _state3.handle;
      var upperBound = _state3.upperBound;
      var lowerBound = _state3.lowerBound;
      var _props3 = this.props;
      var className = _props3.className;
      var prefixCls = _props3.prefixCls;
      var disabled = _props3.disabled;
      var vertical = _props3.vertical;
      var dots = _props3.dots;
      var included = _props3.included;
      var range = _props3.range;
      var step = _props3.step;
      var marks = _props3.marks;
      var max = _props3.max;
      var min = _props3.min;
      var tipTransitionName = _props3.tipTransitionName;
      var tipFormatter = _props3.tipFormatter;
      var children = _props3.children;

      var customHandle = this.props.handle;

      var upperOffset = this.calcOffset(upperBound);
      var lowerOffset = this.calcOffset(lowerBound);

      var handleClassName = prefixCls + '-handle';
      var isNoTip = step === null || tipFormatter === null;

      var upper = (0, _react.cloneElement)(customHandle, { className: handleClassName,
        noTip: isNoTip, tipTransitionName: tipTransitionName, tipFormatter: tipFormatter,
        vertical: vertical, offset: upperOffset, value: upperBound, dragging: handle === 'upperBound' });

      var lower = null;
      if (range) {
        lower = (0, _react.cloneElement)(customHandle, { className: handleClassName,
          noTip: isNoTip, tipTransitionName: tipTransitionName, tipFormatter: tipFormatter,
          vertical: vertical, offset: lowerOffset, value: lowerBound, dragging: handle === 'lowerBound' });
      }

      var sliderClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, prefixCls, true), _defineProperty(_classNames, prefixCls + '-disabled', disabled), _defineProperty(_classNames, className, !!className), _defineProperty(_classNames, prefixCls + '-vertical', this.props.vertical), _classNames));
      var isIncluded = included || range;
      return _react2['default'].createElement(
        'div',
        { ref: 'slider', className: sliderClassName,
          onTouchStart: disabled ? noop : this.onTouchStart.bind(this),
          onMouseDown: disabled ? noop : this.onMouseDown.bind(this) },
        upper,
        lower,
        _react2['default'].createElement(_Track2['default'], { className: prefixCls + '-track', vertical: vertical, included: isIncluded,
          offset: lowerOffset, length: upperOffset - lowerOffset }),
        _react2['default'].createElement(_Steps2['default'], { prefixCls: prefixCls, vertical: vertical, marks: marks, dots: dots, step: step,
          included: isIncluded, lowerBound: lowerBound,
          upperBound: upperBound, max: max, min: min }),
        _react2['default'].createElement(_Marks2['default'], { className: prefixCls + '-mark', vertical: vertical, marks: marks,
          included: isIncluded, lowerBound: lowerBound,
          upperBound: upperBound, max: max, min: min }),
        children
      );
    }
  }]);

  return Slider;
})(_react2['default'].Component);

Slider.propTypes = {
  min: _react2['default'].PropTypes.number,
  max: _react2['default'].PropTypes.number,
  step: _react2['default'].PropTypes.number,
  defaultValue: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  value: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  marks: _react2['default'].PropTypes.object,
  included: _react2['default'].PropTypes.bool,
  className: _react2['default'].PropTypes.string,
  prefixCls: _react2['default'].PropTypes.string,
  disabled: _react2['default'].PropTypes.bool,
  children: _react2['default'].PropTypes.any,
  onBeforeChange: _react2['default'].PropTypes.func,
  onChange: _react2['default'].PropTypes.func,
  onAfterChange: _react2['default'].PropTypes.func,
  handle: _react2['default'].PropTypes.element,
  tipTransitionName: _react2['default'].PropTypes.string,
  tipFormatter: _react2['default'].PropTypes.func,
  dots: _react2['default'].PropTypes.bool,
  range: _react2['default'].PropTypes.bool,
  vertical: _react2['default'].PropTypes.bool,
  allowCross: _react2['default'].PropTypes.bool
};

Slider.defaultProps = {
  prefixCls: 'rc-slider',
  className: '',
  tipTransitionName: '',
  min: 0,
  max: 100,
  step: 1,
  marks: {},
  handle: _react2['default'].createElement(_Handle2['default'], null),
  onBeforeChange: noop,
  onChange: noop,
  onAfterChange: noop,
  tipFormatter: function tipFormatter(value) {
    return value;
  },
  included: true,
  disabled: false,
  dots: false,
  range: false,
  vertical: false,
  allowCross: true
};

exports['default'] = Slider;
module.exports = exports['default'];
},{"./Handle":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Handle.js","./Marks":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Marks.js","./Steps":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Steps.js","./Track":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Track.js","classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/classnames/index.js","rc-util/lib/Dom/addEventListener":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Steps.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function calcPoints(vertical, marks, dots, step, min, max) {
  (0, _warning2['default'])(dots ? step > 0 : true, '`Slider[step]` should be a positive number in order to make Slider[dots] work.');
  var points = Object.keys(marks).map(parseFloat);
  if (dots) {
    for (var i = min; i <= max; i = i + step) {
      if (points.indexOf(i) >= 0) continue;
      points.push(i);
    }
  }
  return points;
}

var Steps = function Steps(_ref) {
  var prefixCls = _ref.prefixCls;
  var vertical = _ref.vertical;
  var marks = _ref.marks;
  var dots = _ref.dots;
  var step = _ref.step;
  var included = _ref.included;
  var lowerBound = _ref.lowerBound;
  var upperBound = _ref.upperBound;
  var max = _ref.max;
  var min = _ref.min;

  var range = max - min;
  var elements = calcPoints(vertical, marks, dots, step, min, max).map(function (point) {
    var _classNames;

    var offset = Math.abs(point - min) / range * 100 + '%';
    var style = vertical ? { bottom: offset } : { left: offset };

    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var pointClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, prefixCls + '-dot', true), _defineProperty(_classNames, prefixCls + '-dot-active', isActived), _classNames));

    return _react2['default'].createElement('span', { className: pointClassName, style: style, key: point });
  });

  return _react2['default'].createElement(
    'div',
    { className: prefixCls + '-step' },
    elements
  );
};

exports['default'] = Steps;
module.exports = exports['default'];
},{"classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/classnames/index.js","react":"react","warning":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/warning/browser.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Track.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var Track = function Track(_ref) {
  var className = _ref.className;
  var included = _ref.included;
  var vertical = _ref.vertical;
  var offset = _ref.offset;
  var length = _ref.length;

  var style = {
    visibility: included ? 'visible' : 'hidden'
  };
  if (vertical) {
    style.bottom = offset + '%';
    style.height = length + '%';
  } else {
    style.left = offset + '%';
    style.width = length + '%';
  }
  return _react2['default'].createElement('div', { className: className, style: style });
};

exports['default'] = Track;
module.exports = exports['default'];
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./Slider');
},{"./Slider":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/Slider.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/classnames/index.js":[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/Tooltip.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _placements = require('./placements');

var _rcTrigger = require('rc-trigger');

var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var Tooltip = _react2["default"].createClass({
  displayName: 'Tooltip',

  propTypes: {
    trigger: _react.PropTypes.any,
    children: _react.PropTypes.any,
    defaultVisible: _react.PropTypes.bool,
    visible: _react.PropTypes.bool,
    placement: _react.PropTypes.string,
    transitionName: _react.PropTypes.string,
    animation: _react.PropTypes.any,
    onVisibleChange: _react.PropTypes.func,
    afterVisibleChange: _react.PropTypes.func,
    overlay: _react.PropTypes.oneOfType([_react2["default"].PropTypes.node, _react2["default"].PropTypes.func]).isRequired,
    overlayStyle: _react.PropTypes.object,
    overlayClassName: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    getTooltipContainer: _react.PropTypes.func,
    destroyTooltipOnHide: _react.PropTypes.bool,
    align: _react.PropTypes.object,
    arrowContent: _react.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-tooltip',
      mouseEnterDelay: 0,
      destroyTooltipOnHide: false,
      mouseLeaveDelay: 0.1,
      align: {},
      placement: 'right',
      trigger: ['hover'],
      arrowContent: null
    };
  },
  getPopupElement: function getPopupElement() {
    var _props = this.props;
    var arrowContent = _props.arrowContent;
    var overlay = _props.overlay;
    var prefixCls = _props.prefixCls;

    return [_react2["default"].createElement(
      'div',
      { className: prefixCls + '-arrow', key: 'arrow' },
      arrowContent
    ), _react2["default"].createElement(
      'div',
      { className: prefixCls + '-inner', key: 'content' },
      typeof overlay === 'function' ? overlay() : overlay
    )];
  },
  getPopupDomNode: function getPopupDomNode() {
    return this.refs.trigger.getPopupDomNode();
  },
  render: function render() {
    var _props2 = this.props;
    var overlayClassName = _props2.overlayClassName;
    var trigger = _props2.trigger;
    var mouseEnterDelay = _props2.mouseEnterDelay;
    var mouseLeaveDelay = _props2.mouseLeaveDelay;
    var overlayStyle = _props2.overlayStyle;
    var prefixCls = _props2.prefixCls;
    var children = _props2.children;
    var onVisibleChange = _props2.onVisibleChange;
    var transitionName = _props2.transitionName;
    var animation = _props2.animation;
    var placement = _props2.placement;
    var align = _props2.align;
    var destroyTooltipOnHide = _props2.destroyTooltipOnHide;
    var defaultVisible = _props2.defaultVisible;
    var getTooltipContainer = _props2.getTooltipContainer;

    var restProps = _objectWithoutProperties(_props2, ['overlayClassName', 'trigger', 'mouseEnterDelay', 'mouseLeaveDelay', 'overlayStyle', 'prefixCls', 'children', 'onVisibleChange', 'transitionName', 'animation', 'placement', 'align', 'destroyTooltipOnHide', 'defaultVisible', 'getTooltipContainer']);

    var extraProps = _extends({}, restProps);
    if ('visible' in this.props) {
      extraProps.popupVisible = this.props.visible;
    }
    return _react2["default"].createElement(
      _rcTrigger2["default"],
      _extends({
        popupClassName: overlayClassName,
        ref: 'trigger',
        prefixCls: prefixCls,
        popup: this.getPopupElement,
        action: trigger,
        builtinPlacements: _placements.placements,
        popupPlacement: placement,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltipOnHide,
        mouseLeaveDelay: mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay: mouseEnterDelay
      }, extraProps),
      children
    );
  }
});

exports["default"] = Tooltip;
module.exports = exports['default'];
},{"./placements":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/placements.js","rc-trigger":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./Tooltip');
},{"./Tooltip":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/Tooltip.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/placements.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};

var targetOffset = [0, 0];

var placements = exports.placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  }
};

exports["default"] = placements;
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/LazyRenderBox.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var LazyRenderBox = _react2["default"].createClass({
  displayName: 'LazyRenderBox',

  propTypes: {
    children: _react.PropTypes.any,
    className: _react.PropTypes.string,
    visible: _react.PropTypes.bool,
    hiddenClassName: _react.PropTypes.string
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    return nextProps.hiddenClassName || nextProps.visible;
  },
  render: function render() {
    var _props = this.props;
    var hiddenClassName = _props.hiddenClassName;
    var visible = _props.visible;

    var props = _objectWithoutProperties(_props, ['hiddenClassName', 'visible']);

    if (hiddenClassName || _react2["default"].Children.count(props.children) > 1) {
      if (!visible && hiddenClassName) {
        props.className += ' ' + hiddenClassName;
      }
      return _react2["default"].createElement('div', props);
    }

    return _react2["default"].Children.only(props.children);
  }
});

exports["default"] = LazyRenderBox;
module.exports = exports['default'];
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Popup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _rcAlign = require('rc-align');

var _rcAlign2 = _interopRequireDefault(_rcAlign);

var _rcAnimate = require('rc-animate');

var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

var _PopupInner = require('./PopupInner');

var _PopupInner2 = _interopRequireDefault(_PopupInner);

var _LazyRenderBox = require('./LazyRenderBox');

var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Popup = _react2["default"].createClass({
  displayName: 'Popup',

  propTypes: {
    visible: _react.PropTypes.bool,
    style: _react.PropTypes.object,
    getClassNameFromAlign: _react.PropTypes.func,
    onAlign: _react.PropTypes.func,
    getRootDomNode: _react.PropTypes.func,
    onMouseEnter: _react.PropTypes.func,
    align: _react.PropTypes.any,
    destroyPopupOnHide: _react.PropTypes.bool,
    className: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    onMouseLeave: _react.PropTypes.func
  },

  componentDidMount: function componentDidMount() {
    this.rootNode = this.getPopupDomNode();
  },
  onAlign: function onAlign(popupDomNode, align) {
    var props = this.props;
    var alignClassName = props.getClassNameFromAlign(props.align);
    var currentAlignClassName = props.getClassNameFromAlign(align);
    if (alignClassName !== currentAlignClassName) {
      this.currentAlignClassName = currentAlignClassName;
      popupDomNode.className = this.getClassName(currentAlignClassName);
    }
    props.onAlign(popupDomNode, align);
  },
  getPopupDomNode: function getPopupDomNode() {
    return _reactDom2["default"].findDOMNode(this.refs.popup);
  },
  getTarget: function getTarget() {
    return this.props.getRootDomNode();
  },
  getMaskTransitionName: function getMaskTransitionName() {
    var props = this.props;
    var transitionName = props.maskTransitionName;
    var animation = props.maskAnimation;
    if (!transitionName && animation) {
      transitionName = props.prefixCls + '-' + animation;
    }
    return transitionName;
  },
  getTransitionName: function getTransitionName() {
    var props = this.props;
    var transitionName = props.transitionName;
    if (!transitionName && props.animation) {
      transitionName = props.prefixCls + '-' + props.animation;
    }
    return transitionName;
  },
  getClassName: function getClassName(currentAlignClassName) {
    return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
  },
  getPopupElement: function getPopupElement() {
    var props = this.props;
    var align = props.align;
    var style = props.style;
    var visible = props.visible;
    var prefixCls = props.prefixCls;
    var destroyPopupOnHide = props.destroyPopupOnHide;

    var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
    var hiddenClassName = prefixCls + '-hidden';
    if (!visible) {
      this.currentAlignClassName = null;
    }
    var newStyle = _extends({}, style, this.getZIndexStyle());
    var popupInnerProps = {
      className: className,
      prefixCls: prefixCls,
      ref: 'popup',
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      style: newStyle
    };
    if (destroyPopupOnHide) {
      return _react2["default"].createElement(
        _rcAnimate2["default"],
        {
          component: '',
          exclusive: true,
          transitionAppear: true,
          transitionName: this.getTransitionName()
        },
        visible ? _react2["default"].createElement(
          _rcAlign2["default"],
          {
            target: this.getTarget,
            key: 'popup',
            ref: this.saveAlign,
            monitorWindowResize: true,
            align: align,
            onAlign: this.onAlign
          },
          _react2["default"].createElement(
            _PopupInner2["default"],
            _extends({
              visible: true
            }, popupInnerProps),
            props.children
          )
        ) : null
      );
    }
    return _react2["default"].createElement(
      _rcAnimate2["default"],
      {
        component: '',
        exclusive: true,
        transitionAppear: true,
        transitionName: this.getTransitionName(),
        showProp: 'xVisible'
      },
      _react2["default"].createElement(
        _rcAlign2["default"],
        {
          target: this.getTarget,
          key: 'popup',
          ref: this.saveAlign,
          monitorWindowResize: true,
          xVisible: visible,
          childrenProps: { visible: 'xVisible' },
          disabled: !visible,
          align: align,
          onAlign: this.onAlign
        },
        _react2["default"].createElement(
          _PopupInner2["default"],
          _extends({
            hiddenClassName: hiddenClassName
          }, popupInnerProps),
          props.children
        )
      )
    );
  },
  getZIndexStyle: function getZIndexStyle() {
    var style = {};
    var props = this.props;
    if (props.zIndex !== undefined) {
      style.zIndex = props.zIndex;
    }
    return style;
  },
  getMaskElement: function getMaskElement() {
    var props = this.props;
    var maskElement = void 0;
    if (props.mask) {
      var maskTransition = this.getMaskTransitionName();
      maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
        style: this.getZIndexStyle(),
        key: 'mask',
        className: props.prefixCls + '-mask',
        hiddenClassName: props.prefixCls + '-mask-hidden',
        visible: props.visible
      });
      if (maskTransition) {
        maskElement = _react2["default"].createElement(
          _rcAnimate2["default"],
          {
            key: 'mask',
            showProp: 'visible',
            transitionAppear: true,
            component: '',
            transitionName: maskTransition
          },
          maskElement
        );
      }
    }
    return maskElement;
  },
  saveAlign: function saveAlign(align) {
    this.alignInstance = align;
  },
  render: function render() {
    return _react2["default"].createElement(
      'div',
      null,
      this.getMaskElement(),
      this.getPopupElement()
    );
  }
});

exports["default"] = Popup;
module.exports = exports['default'];
},{"./LazyRenderBox":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/LazyRenderBox.js","./PopupInner":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/PopupInner.js","rc-align":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/index.js","rc-animate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/index.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/PopupInner.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _LazyRenderBox = require('./LazyRenderBox');

var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var PopupInner = _react2["default"].createClass({
  displayName: 'PopupInner',

  propTypes: {
    hiddenClassName: _react.PropTypes.string,
    className: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    onMouseEnter: _react.PropTypes.func,
    onMouseLeave: _react.PropTypes.func,
    children: _react.PropTypes.any
  },
  render: function render() {
    var props = this.props;
    var className = props.className;
    if (!props.visible) {
      className += ' ' + props.hiddenClassName;
    }
    return _react2["default"].createElement(
      'div',
      {
        className: className,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        style: props.style
      },
      _react2["default"].createElement(
        _LazyRenderBox2["default"],
        { className: props.prefixCls + '-content', visible: props.visible },
        props.children
      )
    );
  }
});

exports["default"] = PopupInner;
module.exports = exports['default'];
},{"./LazyRenderBox":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/LazyRenderBox.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Trigger.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _createChainedFunction = require('rc-util/lib/createChainedFunction');

var _createChainedFunction2 = _interopRequireDefault(_createChainedFunction);

var _contains = require('rc-util/lib/Dom/contains');

var _contains2 = _interopRequireDefault(_contains);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _Popup = require('./Popup');

var _Popup2 = _interopRequireDefault(_Popup);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function noop() {}

function returnEmptyString() {
  return '';
}

var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];

var Trigger = _react2["default"].createClass({
  displayName: 'Trigger',

  propTypes: {
    action: _react.PropTypes.any,
    showAction: _react.PropTypes.any,
    hideAction: _react.PropTypes.any,
    getPopupClassNameFromAlign: _react.PropTypes.any,
    onPopupVisibleChange: _react.PropTypes.func,
    afterPopupVisibleChange: _react.PropTypes.func,
    popup: _react.PropTypes.oneOfType([_react.PropTypes.node, _react.PropTypes.func]).isRequired,
    popupStyle: _react.PropTypes.object,
    prefixCls: _react.PropTypes.string,
    popupClassName: _react.PropTypes.string,
    popupPlacement: _react.PropTypes.string,
    builtinPlacements: _react.PropTypes.object,
    popupTransitionName: _react.PropTypes.string,
    popupAnimation: _react.PropTypes.any,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    zIndex: _react.PropTypes.number,
    focusDelay: _react.PropTypes.number,
    blurDelay: _react.PropTypes.number,
    getPopupContainer: _react.PropTypes.func,
    destroyPopupOnHide: _react.PropTypes.bool,
    mask: _react.PropTypes.bool,
    onPopupAlign: _react.PropTypes.func,
    popupAlign: _react.PropTypes.object,
    popupVisible: _react.PropTypes.bool,
    maskTransitionName: _react.PropTypes.string,
    maskAnimation: _react.PropTypes.string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-trigger-popup',
      getPopupClassNameFromAlign: returnEmptyString,
      onPopupVisibleChange: noop,
      afterPopupVisibleChange: noop,
      onPopupAlign: noop,
      popupClassName: '',
      mouseEnterDelay: 0,
      mouseLeaveDelay: 0.1,
      focusDelay: 0,
      blurDelay: 0.15,
      popupStyle: {},
      destroyPopupOnHide: false,
      popupAlign: {},
      defaultPopupVisible: false,
      mask: false,
      action: [],
      showAction: [],
      hideAction: []
    };
  },
  getInitialState: function getInitialState() {
    var props = this.props;
    var popupVisible = void 0;
    if ('popupVisible' in props) {
      popupVisible = !!props.popupVisible;
    } else {
      popupVisible = !!props.defaultPopupVisible;
    }
    return {
      popupVisible: popupVisible
    };
  },
  componentDidMount: function componentDidMount() {
    this.componentDidUpdate({}, {
      popupVisible: this.state.popupVisible
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if ('popupVisible' in nextProps) {
      this.setState({
        popupVisible: !!nextProps.popupVisible
      });
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    var _this = this;

    var props = this.props;
    var state = this.state;
    if (this.popupRendered) {
      var _ret = function () {
        var self = _this;
        _reactDom2["default"].unstable_renderSubtreeIntoContainer(_this, _this.getPopupElement(), _this.getPopupContainer(), function mounted() {
          self.popupInstance = this;
          if (prevState.popupVisible !== state.popupVisible) {
            props.afterPopupVisibleChange(state.popupVisible);
          }
        });
        if (_this.isClickToHide()) {
          if (state.popupVisible) {
            if (!_this.clickOutsideHandler) {
              _this.clickOutsideHandler = (0, _addEventListener2["default"])(document, 'mousedown', _this.onDocumentClick);
              _this.touchOutsideHandler = (0, _addEventListener2["default"])(document, 'touchstart', _this.onDocumentClick);
            }
            return {
              v: void 0
            };
          }
        }
        if (_this.clickOutsideHandler) {
          _this.clickOutsideHandler.remove();
          _this.touchOutsideHandler.remove();
          _this.clickOutsideHandler = null;
          _this.touchOutsideHandler = null;
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    var popupContainer = this.popupContainer;
    if (popupContainer) {
      _reactDom2["default"].unmountComponentAtNode(popupContainer);
      popupContainer.parentNode.removeChild(popupContainer);
      this.popupContainer = null;
    }
    this.clearDelayTimer();
    if (this.clickOutsideHandler) {
      this.clickOutsideHandler.remove();
      this.touchOutsideHandler.remove();
      this.clickOutsideHandler = null;
      this.touchOutsideHandler = null;
    }
  },
  onMouseEnter: function onMouseEnter() {
    this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
  },
  onMouseLeave: function onMouseLeave(e) {
    // https://github.com/react-component/trigger/pull/13
    // react bug?
    if (e.relatedTarget && !e.relatedTarget.setTimeout && (0, _contains2["default"])(this.popupContainer, e.relatedTarget)) {
      return;
    }
    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
  },
  onFocus: function onFocus() {
    // incase focusin and focusout
    this.clearDelayTimer();
    if (this.isFocusToShow()) {
      this.focusTime = Date.now();
      this.delaySetPopupVisible(true, this.props.focusDelay);
    }
  },
  onMouseDown: function onMouseDown() {
    this.preClickTime = Date.now();
  },
  onTouchStart: function onTouchStart() {
    this.preTouchTime = Date.now();
  },
  onBlur: function onBlur() {
    this.clearDelayTimer();
    if (this.isBlurToHide()) {
      this.delaySetPopupVisible(false, this.props.blurDelay);
    }
  },
  onClick: function onClick(event) {
    // focus will trigger click
    if (this.focusTime) {
      var preTime = void 0;
      if (this.preClickTime && this.preTouchTime) {
        preTime = Math.min(this.preClickTime, this.preTouchTime);
      } else if (this.preClickTime) {
        preTime = this.preClickTime;
      } else if (this.preTouchTime) {
        preTime = this.preTouchTime;
      }
      if (Math.abs(preTime - this.focusTime) < 20) {
        return;
      }
      this.focusTime = 0;
    }
    this.preClickTime = 0;
    this.preTouchTime = 0;
    event.preventDefault();
    var nextVisible = !this.state.popupVisible;
    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
      this.setPopupVisible(!this.state.popupVisible);
    }
  },
  onDocumentClick: function onDocumentClick(event) {
    var target = event.target;
    var root = (0, _reactDom.findDOMNode)(this);
    var popupNode = this.getPopupDomNode();
    if (!(0, _contains2["default"])(root, target) && !(0, _contains2["default"])(popupNode, target)) {
      this.setPopupVisible(false);
    }
  },
  getPopupDomNode: function getPopupDomNode() {
    // for test
    if (this.popupInstance) {
      return this.popupInstance.isMounted() ? this.popupInstance.getPopupDomNode() : null;
    }
    return null;
  },
  getRootDomNode: function getRootDomNode() {
    return _reactDom2["default"].findDOMNode(this);
  },
  getPopupContainer: function getPopupContainer() {
    if (!this.popupContainer) {
      this.popupContainer = document.createElement('div');
      var mountNode = this.props.getPopupContainer ? this.props.getPopupContainer((0, _reactDom.findDOMNode)(this)) : document.body;
      mountNode.appendChild(this.popupContainer);
    }
    return this.popupContainer;
  },
  getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
    var className = [];
    var props = this.props;
    var popupPlacement = props.popupPlacement;
    var builtinPlacements = props.builtinPlacements;
    var prefixCls = props.prefixCls;

    if (popupPlacement && builtinPlacements) {
      className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
    }
    if (props.getPopupClassNameFromAlign) {
      className.push(props.getPopupClassNameFromAlign(align));
    }
    return className.join(' ');
  },
  getPopupAlign: function getPopupAlign() {
    var props = this.props;
    var popupPlacement = props.popupPlacement;
    var popupAlign = props.popupAlign;
    var builtinPlacements = props.builtinPlacements;

    if (popupPlacement && builtinPlacements) {
      return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
    }
    return popupAlign;
  },
  getPopupElement: function getPopupElement() {
    var props = this.props;
    var state = this.state;

    var mouseProps = {};
    if (this.isMouseEnterToShow()) {
      mouseProps.onMouseEnter = this.onMouseEnter;
    }
    if (this.isMouseLeaveToHide()) {
      mouseProps.onMouseLeave = this.onMouseLeave;
    }
    return _react2["default"].createElement(
      _Popup2["default"],
      _extends({
        prefixCls: props.prefixCls,
        destroyPopupOnHide: props.destroyPopupOnHide,
        visible: state.popupVisible,
        className: props.popupClassName,
        action: props.action,
        align: this.getPopupAlign(),
        onAlign: props.onPopupAlign,
        animation: props.popupAnimation,
        getClassNameFromAlign: this.getPopupClassNameFromAlign
      }, mouseProps, {
        getRootDomNode: this.getRootDomNode,
        style: props.popupStyle,
        mask: props.mask,
        zIndex: props.zIndex,
        transitionName: props.popupTransitionName,
        maskAnimation: props.maskAnimation,
        maskTransitionName: props.maskTransitionName
      }),
      typeof props.popup === 'function' ? props.popup() : props.popup
    );
  },
  setPopupVisible: function setPopupVisible(popupVisible) {
    this.clearDelayTimer();
    if (this.state.popupVisible !== popupVisible) {
      if (!('popupVisible' in this.props)) {
        this.setState({
          popupVisible: popupVisible
        });
      }
      this.props.onPopupVisibleChange(popupVisible);
    }
  },
  delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
    var _this2 = this;

    var delay = delayS * 1000;
    this.clearDelayTimer();
    if (delay) {
      this.delayTimer = setTimeout(function () {
        _this2.setPopupVisible(visible);
        _this2.clearDelayTimer();
      }, delay);
    } else {
      this.setPopupVisible(visible);
    }
  },
  clearDelayTimer: function clearDelayTimer() {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
  },
  isClickToShow: function isClickToShow() {
    var _props = this.props;
    var action = _props.action;
    var showAction = _props.showAction;

    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
  },
  isClickToHide: function isClickToHide() {
    var _props2 = this.props;
    var action = _props2.action;
    var hideAction = _props2.hideAction;

    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
  },
  isMouseEnterToShow: function isMouseEnterToShow() {
    var _props3 = this.props;
    var action = _props3.action;
    var showAction = _props3.showAction;

    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
  },
  isMouseLeaveToHide: function isMouseLeaveToHide() {
    var _props4 = this.props;
    var action = _props4.action;
    var hideAction = _props4.hideAction;

    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
  },
  isFocusToShow: function isFocusToShow() {
    var _props5 = this.props;
    var action = _props5.action;
    var showAction = _props5.showAction;

    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
  },
  isBlurToHide: function isBlurToHide() {
    var _props6 = this.props;
    var action = _props6.action;
    var hideAction = _props6.hideAction;

    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
  },
  forcePopupAlign: function forcePopupAlign() {
    if (this.state.popupVisible && this.popupInstance && this.popupInstance.alignInstance) {
      this.popupInstance.alignInstance.forceAlign();
    }
  },
  render: function render() {
    this.popupRendered = this.popupRendered || this.state.popupVisible;
    var props = this.props;
    var children = props.children;
    var child = _react2["default"].Children.only(children);
    var childProps = child.props || {};
    var newChildProps = {};

    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = (0, _createChainedFunction2["default"])(this.onClick, childProps.onClick);
      newChildProps.onMouseDown = (0, _createChainedFunction2["default"])(this.onMouseDown, childProps.onMouseDown);
      newChildProps.onTouchStart = (0, _createChainedFunction2["default"])(this.onTouchStart, childProps.onTouchStart);
    }
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseEnter = (0, _createChainedFunction2["default"])(this.onMouseEnter, childProps.onMouseEnter);
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseLeave = (0, _createChainedFunction2["default"])(this.onMouseLeave, childProps.onMouseLeave);
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = (0, _createChainedFunction2["default"])(this.onFocus, childProps.onFocus);
      newChildProps.onBlur = (0, _createChainedFunction2["default"])(this.onBlur, childProps.onBlur);
    }

    ALL_HANDLERS.forEach(function (handler) {
      var newFn = void 0;
      if (props[handler] && newChildProps[handler]) {
        newFn = (0, _createChainedFunction2["default"])(props[handler], newChildProps[handler]);
      } else {
        newFn = props[handler] || newChildProps[handler];
      }
      if (newFn) {
        newChildProps[handler] = newFn;
      }
    });

    return _react2["default"].cloneElement(child, newChildProps);
  }
});

exports["default"] = Trigger;
module.exports = exports['default'];
},{"./Popup":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Popup.js","./utils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/utils.js","rc-util/lib/Dom/addEventListener":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js","rc-util/lib/Dom/contains":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/contains.js","rc-util/lib/createChainedFunction":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/createChainedFunction.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./Trigger');
},{"./Trigger":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Trigger.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/utils.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getAlignFromPlacement = getAlignFromPlacement;
exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;
function isPointsEq(a1, a2) {
  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _extends({}, baseAlign, align);
}

function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
  var points = align.points;
  for (var placement in builtinPlacements) {
    if (builtinPlacements.hasOwnProperty(placement)) {
      if (isPointsEq(builtinPlacements[placement].points, points)) {
        return prefixCls + '-placement-' + placement;
      }
    }
  }
  return '';
}
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/Align.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _domAlign = require('dom-align');

var _domAlign2 = _interopRequireDefault(_domAlign);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _isWindow = require('./isWindow');

var _isWindow2 = _interopRequireDefault(_isWindow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function buffer(fn, ms) {
  var timer = void 0;
  return function bufferFn() {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(fn, ms);
  };
}

var Align = _react2["default"].createClass({
  displayName: 'Align',

  propTypes: {
    childrenProps: _react.PropTypes.object,
    align: _react.PropTypes.object.isRequired,
    target: _react.PropTypes.func,
    onAlign: _react.PropTypes.func,
    monitorBufferTime: _react.PropTypes.number,
    monitorWindowResize: _react.PropTypes.bool,
    disabled: _react.PropTypes.bool,
    children: _react.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      target: function target() {
        return window;
      },
      onAlign: function onAlign() {},

      monitorBufferTime: 50,
      monitorWindowResize: false,
      disabled: false
    };
  },
  componentDidMount: function componentDidMount() {
    var props = this.props;
    // if parent ref not attached .... use document.getElementById
    this.forceAlign();
    if (!props.disabled && props.monitorWindowResize) {
      this.startMonitorWindowResize();
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    var reAlign = false;
    var props = this.props;

    if (!props.disabled) {
      if (prevProps.disabled || prevProps.align !== props.align) {
        reAlign = true;
      } else {
        var lastTarget = prevProps.target();
        var currentTarget = props.target();
        if ((0, _isWindow2["default"])(lastTarget) && (0, _isWindow2["default"])(currentTarget)) {
          reAlign = false;
        } else if (lastTarget !== currentTarget) {
          reAlign = true;
        }
      }
    }

    if (reAlign) {
      this.forceAlign();
    }

    if (props.monitorWindowResize && !props.disabled) {
      this.startMonitorWindowResize();
    } else {
      this.stopMonitorWindowResize();
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this.stopMonitorWindowResize();
  },
  startMonitorWindowResize: function startMonitorWindowResize() {
    if (!this.resizeHandler) {
      this.resizeHandler = (0, _addEventListener2["default"])(window, 'resize', buffer(this.forceAlign, this.props.monitorBufferTime));
    }
  },
  stopMonitorWindowResize: function stopMonitorWindowResize() {
    if (this.resizeHandler) {
      this.resizeHandler.remove();
      this.resizeHandler = null;
    }
  },
  forceAlign: function forceAlign() {
    var props = this.props;
    if (!props.disabled) {
      var source = _reactDom2["default"].findDOMNode(this);
      props.onAlign(source, (0, _domAlign2["default"])(source, props.target(), props.align));
    }
  },
  render: function render() {
    var _props = this.props;
    var childrenProps = _props.childrenProps;
    var children = _props.children;

    var child = _react2["default"].Children.only(children);
    if (childrenProps) {
      var newProps = {};
      for (var prop in childrenProps) {
        if (childrenProps.hasOwnProperty(prop)) {
          newProps[prop] = this.props[childrenProps[prop]];
        }
      }
      return _react2["default"].cloneElement(child, newProps);
    }
    return child;
  }
});

exports["default"] = Align;
module.exports = exports['default'];
},{"./isWindow":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/isWindow.js","dom-align":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/index.js","rc-util/lib/Dom/addEventListener":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Align = require('./Align');

var _Align2 = _interopRequireDefault(_Align);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports["default"] = _Align2["default"]; // export this package's api

module.exports = exports['default'];
},{"./Align":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/Align.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/isWindow.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isWindow;
function isWindow(obj) {
  /* eslint no-eq-null: 0 */
  /* eslint eqeqeq: 0 */
  return obj != null && obj == obj.window;
}
module.exports = exports['default'];
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/adjustForViewport.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = _utils2['default'].clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }

  // Right edge outside viewport, try to move it.
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }

  // Top edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }

  // Bottom edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return _utils2['default'].mix(pos, size);
}

exports['default'] = adjustForViewport;
module.exports = exports['default'];
},{"./utils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getAlignOffset.js":[function(require,module,exports){
/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = undefined;
  var y = undefined;

  x = region.left;
  y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

exports['default'] = getAlignOffset;
module.exports = exports['default'];
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getElFuturePos.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _getAlignOffset = require('./getAlignOffset');

var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var xy = undefined;
  var diff = undefined;
  var p1 = undefined;
  var p2 = undefined;

  xy = {
    left: elRegion.left,
    top: elRegion.top
  };

  p1 = (0, _getAlignOffset2['default'])(refNodeRegion, points[1]);
  p2 = (0, _getAlignOffset2['default'])(elRegion, points[0]);

  diff = [p2.left - p1.left, p2.top - p1.top];

  return {
    left: xy.left - diff[0] + offset[0] - targetOffset[0],
    top: xy.top - diff[1] + offset[1] - targetOffset[1]
  };
}

exports['default'] = getElFuturePos;
module.exports = exports['default'];
},{"./getAlignOffset":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getAlignOffset.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getOffsetParent.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

/**
 * 得到会导致元素显示不全的祖先元素
 */

function getOffsetParent(element) {
  // ie 这个也不是完全可行
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法
  var doc = element.ownerDocument;
  var body = doc.body;
  var parent = undefined;
  var positionStyle = _utils2['default'].css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
  }

  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
    positionStyle = _utils2['default'].css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}

exports['default'] = getOffsetParent;
module.exports = exports['default'];
},{"./utils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getRegion.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function getRegion(node) {
  var offset = undefined;
  var w = undefined;
  var h = undefined;
  if (!_utils2['default'].isWindow(node) && node.nodeType !== 9) {
    offset = _utils2['default'].offset(node);
    w = _utils2['default'].outerWidth(node);
    h = _utils2['default'].outerHeight(node);
  } else {
    var win = _utils2['default'].getWindow(node);
    offset = {
      left: _utils2['default'].getWindowScrollLeft(win),
      top: _utils2['default'].getWindowScrollTop(win)
    };
    w = _utils2['default'].viewportWidth(win);
    h = _utils2['default'].viewportHeight(win);
  }
  offset.width = w;
  offset.height = h;
  return offset;
}

exports['default'] = getRegion;
module.exports = exports['default'];
},{"./utils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getVisibleRectForElement.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _getOffsetParent = require('./getOffsetParent');

var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

/**
 * 获得元素的显示部分的区域
 */
function getVisibleRectForElement(element) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = (0, _getOffsetParent2['default'])(element);
  var scrollX = undefined;
  var scrollY = undefined;
  var winSize = undefined;
  var doc = element.ownerDocument;
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && _utils2['default'].css(el, 'overflow') !== 'visible') {
      var pos = _utils2['default'].offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = (0, _getOffsetParent2['default'])(el);
  }

  // Clip by window's viewport.
  scrollX = _utils2['default'].getWindowScrollLeft(win);
  scrollY = _utils2['default'].getWindowScrollTop(win);
  visibleRect.left = Math.max(visibleRect.left, scrollX);
  visibleRect.top = Math.max(visibleRect.top, scrollY);
  winSize = {
    width: _utils2['default'].viewportWidth(win),
    height: _utils2['default'].viewportHeight(win)
  };
  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

exports['default'] = getVisibleRectForElement;
module.exports = exports['default'];
},{"./getOffsetParent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getOffsetParent.js","./utils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/index.js":[function(require,module,exports){
/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _getOffsetParent = require('./getOffsetParent');

var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

var _getVisibleRectForElement = require('./getVisibleRectForElement');

var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);

var _adjustForViewport = require('./adjustForViewport');

var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);

var _getRegion = require('./getRegion');

var _getRegion2 = _interopRequireDefault(_getRegion);

var _getElFuturePos = require('./getElFuturePos');

var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);

// http://yiminghe.iteye.com/blog/1124720

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  _utils2['default'].each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n = undefined;
  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }
  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}

function domAlign(el, refNode, align) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var target = align.target || refNode;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};

  var fail = 0;
  // 当前节点可以被放置的显示区域
  var visibleRect = (0, _getVisibleRectForElement2['default'])(source);
  // 当前节点所占的区域, left/top/width/height
  var elRegion = (0, _getRegion2['default'])(source);
  // 参照节点所占的区域, left/top/width/height
  var refNodeRegion = (0, _getRegion2['default'])(target);
  // 将 offset 转换成数值，支持百分比
  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, refNodeRegion);
  // 当前节点将要被放置的位置
  var elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
  // 当前节点将要所处的区域
  var newElRegion = _utils2['default'].merge(elRegion, elFuturePos);

  // 如果可视区域不能完全放置当前节点时允许调整
  if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/ig, {
          l: 'r',
          r: 'l'
        });
        // 偏移量也反下
        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[tb]/ig, {
          t: 'b',
          b: 't'
        });
        // 偏移量也反下
        var newOffset = flipOffset(offset, 1);
        var newTargetOffset = flipOffset(targetOffset, 1);
        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailY(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    // 如果失败，重新计算当前节点将要被放置的位置
    if (fail) {
      elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
      _utils2['default'].mix(newElRegion, elFuturePos);
    }

    // 检查反下后的位置是否可以放下了
    // 如果仍然放不下只有指定了可以调整当前方向才调整
    newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);

    newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);

    // 确实要调整，甚至可能会调整高度宽度
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = (0, _adjustForViewport2['default'])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }

  // need judge to in case set fixed with in css on height auto element
  if (newElRegion.width !== elRegion.width) {
    _utils2['default'].css(source, 'width', source.width() + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    _utils2['default'].css(source, 'height', source.height() + newElRegion.height - elRegion.height);
  }

  // https://github.com/kissyteam/kissy/issues/190
  // http://localhost:8888/kissy/src/overlay/demo/other/relative_align/align.html
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>
  _utils2['default'].offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom
  });

  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}

domAlign.__getOffsetParent = _getOffsetParent2['default'];

domAlign.__getVisibleRectForElement = _getVisibleRectForElement2['default'];

exports['default'] = domAlign;

/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/
module.exports = exports['default'];
},{"./adjustForViewport":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/adjustForViewport.js","./getElFuturePos":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getElFuturePos.js","./getOffsetParent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getOffsetParent.js","./getRegion":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getRegion.js","./getVisibleRectForElement":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getVisibleRectForElement.js","./utils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

var getComputedStyleX = undefined;

function css(el, name, v) {
  var value = v;
  if (typeof name === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = value + 'px';
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box = undefined;
  var x = undefined;
  var y = undefined;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top;

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;

  return { left: x, top: y };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = elem.ownerDocument;
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;

    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
}

// 设置 elem 相对 elem.ownerDocument 的坐标
function setOffset(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = presetH + 'px';
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = presetV + 'px';
  }
  var old = getOffset(elem);
  var ret = {};
  var key = undefined;
  for (key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      if (dir === key) {
        ret[dir] = preset + offset[key] - old[key];
      } else {
        ret[dir] = preset + old[key] - offset[key];
      }
    }
  }
  css(elem, ret);
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = undefined;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = undefined;
  var j = undefined;
  var i = undefined;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = undefined;
        if (prop === 'border') {
          cssProp = prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

var domUtils = {};

each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name],
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var val = undefined;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i = undefined;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    for (var i = 0; i < args.length; i++) {
      utils.mix(ret, args[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};

mix(utils, domUtils);

exports['default'] = utils;
module.exports = exports['default'];
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/Animate.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _ChildrenUtils = require('./ChildrenUtils');

var _AnimateChild = require('./AnimateChild');

var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultKey = 'rc_animate_' + Date.now();


function getChildrenFromProps(props) {
  var children = props.children;
  if (_react2["default"].isValidElement(children)) {
    if (!children.key) {
      return _react2["default"].cloneElement(children, {
        key: defaultKey
      });
    }
  }
  return children;
}

function noop() {}

var Animate = _react2["default"].createClass({
  displayName: 'Animate',

  propTypes: {
    component: _react2["default"].PropTypes.any,
    animation: _react2["default"].PropTypes.object,
    transitionName: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.string, _react2["default"].PropTypes.object]),
    transitionEnter: _react2["default"].PropTypes.bool,
    transitionAppear: _react2["default"].PropTypes.bool,
    exclusive: _react2["default"].PropTypes.bool,
    transitionLeave: _react2["default"].PropTypes.bool,
    onEnd: _react2["default"].PropTypes.func,
    onEnter: _react2["default"].PropTypes.func,
    onLeave: _react2["default"].PropTypes.func,
    onAppear: _react2["default"].PropTypes.func,
    showProp: _react2["default"].PropTypes.string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      animation: {},
      component: 'span',
      transitionEnter: true,
      transitionLeave: true,
      transitionAppear: false,
      onEnd: noop,
      onEnter: noop,
      onLeave: noop,
      onAppear: noop
    };
  },
  getInitialState: function getInitialState() {
    this.currentlyAnimatingKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
    return {
      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
    };
  },
  componentDidMount: function componentDidMount() {
    var _this = this;

    var showProp = this.props.showProp;
    var children = this.state.children;
    if (showProp) {
      children = children.filter(function (child) {
        return !!child.props[showProp];
      });
    }
    children.forEach(function (child) {
      if (child) {
        _this.performAppear(child.key);
      }
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    this.nextProps = nextProps;
    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
    var props = this.props;
    // exclusive needs immediate response
    if (props.exclusive) {
      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
        _this2.stop(key);
      });
    }
    var showProp = props.showProp;
    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
    // last props children if exclusive
    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
    // in case destroy in showProp mode
    var newChildren = [];
    if (showProp) {
      currentChildren.forEach(function (currentChild) {
        var nextChild = currentChild && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
        var newChild = void 0;
        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
          newChild = _react2["default"].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
        } else {
          newChild = nextChild;
        }
        if (newChild) {
          newChildren.push(newChild);
        }
      });
      nextChildren.forEach(function (nextChild) {
        if (!nextChild || !(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
          newChildren.push(nextChild);
        }
      });
    } else {
      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
    }

    // need render to avoid update
    this.setState({
      children: newChildren
    });

    nextChildren.forEach(function (child) {
      var key = child && child.key;
      if (child && currentlyAnimatingKeys[key]) {
        return;
      }
      var hasPrev = child && (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
      if (showProp) {
        var showInNext = child.props[showProp];
        if (hasPrev) {
          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
          if (!showInNow && showInNext) {
            _this2.keysToEnter.push(key);
          }
        } else if (showInNext) {
          _this2.keysToEnter.push(key);
        }
      } else if (!hasPrev) {
        _this2.keysToEnter.push(key);
      }
    });

    currentChildren.forEach(function (child) {
      var key = child && child.key;
      if (child && currentlyAnimatingKeys[key]) {
        return;
      }
      var hasNext = child && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
      if (showProp) {
        var showInNow = child.props[showProp];
        if (hasNext) {
          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
          if (!showInNext && showInNow) {
            _this2.keysToLeave.push(key);
          }
        } else if (showInNow) {
          _this2.keysToLeave.push(key);
        }
      } else if (!hasNext) {
        _this2.keysToLeave.push(key);
      }
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);
    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },
  performEnter: function performEnter(key) {
    // may already remove by exclusive
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
    }
  },
  performAppear: function performAppear(key) {
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
    }
  },
  handleDoneAdding: function handleDoneAdding(key, type) {
    var props = this.props;
    delete this.currentlyAnimatingKeys[key];
    // if update on exclusive mode, skip check
    if (props.exclusive && props !== this.nextProps) {
      return;
    }
    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
    if (!this.isValidChildByKey(currentChildren, key)) {
      // exclusive will not need this
      this.performLeave(key);
    } else {
      if (type === 'appear') {
        if (_util2["default"].allowAppearCallback(props)) {
          props.onAppear(key);
          props.onEnd(key, true);
        }
      } else {
        if (_util2["default"].allowEnterCallback(props)) {
          props.onEnter(key);
          props.onEnd(key, true);
        }
      }
    }
  },
  performLeave: function performLeave(key) {
    // may already remove by exclusive
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
    }
  },
  handleDoneLeaving: function handleDoneLeaving(key) {
    var props = this.props;
    delete this.currentlyAnimatingKeys[key];
    // if update on exclusive mode, skip check
    if (props.exclusive && props !== this.nextProps) {
      return;
    }
    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
    // in case state change is too fast
    if (this.isValidChildByKey(currentChildren, key)) {
      this.performEnter(key);
    } else {
      var end = function end() {
        if (_util2["default"].allowLeaveCallback(props)) {
          props.onLeave(key);
          props.onEnd(key, false);
        }
      };
      /* eslint react/no-is-mounted:0 */
      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
        this.setState({
          children: currentChildren
        }, end);
      } else {
        end();
      }
    }
  },
  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
    var showProp = this.props.showProp;
    if (showProp) {
      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
    }
    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
  },
  stop: function stop(key) {
    delete this.currentlyAnimatingKeys[key];
    var component = this.refs[key];
    if (component) {
      component.stop();
    }
  },
  render: function render() {
    var props = this.props;
    this.nextProps = props;
    var stateChildren = this.state.children;
    var children = null;
    if (stateChildren) {
      children = stateChildren.map(function (child) {
        if (child === null || child === undefined) {
          return child;
        }
        if (!child.key) {
          throw new Error('must set key for <rc-animate> children');
        }
        return _react2["default"].createElement(
          _AnimateChild2["default"],
          {
            key: child.key,
            ref: child.key,
            animation: props.animation,
            transitionName: props.transitionName,
            transitionEnter: props.transitionEnter,
            transitionAppear: props.transitionAppear,
            transitionLeave: props.transitionLeave
          },
          child
        );
      });
    }
    var Component = props.component;
    if (Component) {
      var passedProps = props;
      if (typeof Component === 'string') {
        passedProps = {
          className: props.className,
          style: props.style
        };
      }
      return _react2["default"].createElement(
        Component,
        passedProps,
        children
      );
    }
    return children[0] || null;
  }
});

exports["default"] = Animate;
module.exports = exports['default'];
},{"./AnimateChild":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/AnimateChild.js","./ChildrenUtils":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/ChildrenUtils.js","./util":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/util.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/AnimateChild.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _cssAnimation = require('css-animation');

var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var transitionMap = {
  enter: 'transitionEnter',
  appear: 'transitionAppear',
  leave: 'transitionLeave'
};

var AnimateChild = _react2["default"].createClass({
  displayName: 'AnimateChild',

  propTypes: {
    children: _react2["default"].PropTypes.any
  },

  componentWillUnmount: function componentWillUnmount() {
    this.stop();
  },
  componentWillEnter: function componentWillEnter(done) {
    if (_util2["default"].isEnterSupported(this.props)) {
      this.transition('enter', done);
    } else {
      done();
    }
  },
  componentWillAppear: function componentWillAppear(done) {
    if (_util2["default"].isAppearSupported(this.props)) {
      this.transition('appear', done);
    } else {
      done();
    }
  },
  componentWillLeave: function componentWillLeave(done) {
    if (_util2["default"].isLeaveSupported(this.props)) {
      this.transition('leave', done);
    } else {
      // always sync, do not interupt with react component life cycle
      // update hidden -> animate hidden ->
      // didUpdate -> animate leave -> unmount (if animate is none)
      done();
    }
  },
  transition: function transition(animationType, finishCallback) {
    var _this = this;

    var node = _reactDom2["default"].findDOMNode(this);
    var props = this.props;
    var transitionName = props.transitionName;
    var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) === 'object';
    this.stop();
    var end = function end() {
      _this.stopper = null;
      finishCallback();
    };
    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
      var name = nameIsObj ? transitionName[animationType] : transitionName + '-' + animationType;
      this.stopper = (0, _cssAnimation2["default"])(node, name, end);
    } else {
      this.stopper = props.animation[animationType](node, end);
    }
  },
  stop: function stop() {
    var stopper = this.stopper;
    if (stopper) {
      this.stopper = null;
      stopper.stop();
    }
  },
  render: function render() {
    return this.props.children;
  }
});

exports["default"] = AnimateChild;
module.exports = exports['default'];
},{"./util":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/util.js","css-animation":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/index.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/ChildrenUtils.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayChildren = toArrayChildren;
exports.findChildInChildrenByKey = findChildInChildrenByKey;
exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
exports.isSameChildren = isSameChildren;
exports.mergeChildren = mergeChildren;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function toArrayChildren(children) {
  var ret = [];
  _react2["default"].Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}

function findChildInChildrenByKey(children, key) {
  var ret = null;
  if (children) {
    children.forEach(function (child) {
      if (ret) {
        return;
      }
      if (child && child.key === key) {
        ret = child;
      }
    });
  }
  return ret;
}

function findShownChildInChildrenByKey(children, key, showProp) {
  var ret = null;
  if (children) {
    children.forEach(function (child) {
      if (child && child.key === key && child.props[showProp]) {
        if (ret) {
          throw new Error('two child with same key for <rc-animate> children');
        }
        ret = child;
      }
    });
  }
  return ret;
}

function findHiddenChildInChildrenByKey(children, key, showProp) {
  var found = 0;
  if (children) {
    children.forEach(function (child) {
      if (found) {
        return;
      }
      found = child && child.key === key && !child.props[showProp];
    });
  }
  return found;
}

function isSameChildren(c1, c2, showProp) {
  var same = c1.length === c2.length;
  if (same) {
    c1.forEach(function (child, index) {
      var child2 = c2[index];
      if (child && child2) {
        if (child && !child2 || !child && child2) {
          same = false;
        } else if (child.key !== child2.key) {
          same = false;
        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
          same = false;
        }
      }
    });
  }
  return same;
}

function mergeChildren(prev, next) {
  var ret = [];

  // For each key of `next`, the list of keys to insert before that key in
  // the combined list
  var nextChildrenPending = {};
  var pendingChildren = [];
  prev.forEach(function (child) {
    if (child && findChildInChildrenByKey(next, child.key)) {
      if (pendingChildren.length) {
        nextChildrenPending[child.key] = pendingChildren;
        pendingChildren = [];
      }
    } else {
      pendingChildren.push(child);
    }
  });

  next.forEach(function (child) {
    if (child && nextChildrenPending.hasOwnProperty(child.key)) {
      ret = ret.concat(nextChildrenPending[child.key]);
    }
    ret.push(child);
  });

  ret = ret.concat(pendingChildren);

  return ret;
}
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/index.js":[function(require,module,exports){
'use strict';

// export this package's api
module.exports = require('./Animate');
},{"./Animate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/Animate.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/util.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {
  isAppearSupported: function isAppearSupported(props) {
    return props.transitionName && props.transitionAppear || props.animation.appear;
  },
  isEnterSupported: function isEnterSupported(props) {
    return props.transitionName && props.transitionEnter || props.animation.enter;
  },
  isLeaveSupported: function isLeaveSupported(props) {
    return props.transitionName && props.transitionLeave || props.animation.leave;
  },
  allowAppearCallback: function allowAppearCallback(props) {
    return props.transitionAppear || props.animation.appear;
  },
  allowEnterCallback: function allowEnterCallback(props) {
    return props.transitionEnter || props.animation.enter;
  },
  allowLeaveCallback: function allowLeaveCallback(props) {
    return props.transitionLeave || props.animation.leave;
  }
};
exports["default"] = util;
module.exports = exports['default'];
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/Event.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },

  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
      var baseEvents = EVENT_NAME_MAP[baseEventName];
      for (var styleName in baseEvents) {
        if (styleName in style) {
          endEvents.push(baseEvents[styleName]);
          break;
        }
      }
    }
  }
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },


  endEvents: endEvents,

  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

exports["default"] = TransitionEvents;
module.exports = exports['default'];
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Event = require('./Event');

var _Event2 = _interopRequireDefault(_Event);

var _componentClasses = require('component-classes');

var _componentClasses2 = _interopRequireDefault(_componentClasses);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;


var capitalPrefixes = ['Webkit', 'Moz', 'O',
// ms is special .... !
'ms'];
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getDuration(node, name) {
  var style = window.getComputedStyle(node);

  var ret = '';
  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);
    if (ret) {
      break;
    }
  }
  return ret;
}

function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;
    var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;
    var time = Math.max(transitionDuration, animationDuration);
    // sometimes, browser bug
    node.rcEndAnimTimeout = setTimeout(function () {
      node.rcEndAnimTimeout = null;
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1000 + 200);
  }
}

function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}

var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
  var className = transitionName;
  var activeClassName = className + '-active';
  var end = endCallback;
  var start = void 0;
  var active = void 0;
  var nodeClasses = (0, _componentClasses2["default"])(node);

  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }

  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);

    nodeClasses.remove(className);
    nodeClasses.remove(activeClassName);

    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;

    // Usually this optional end is used for informing an owner of
    // a leave animation and telling it to remove the child.
    if (end) {
      end();
    }
  };

  _Event2["default"].addEndEventListener(node, node.rcEndListener);

  if (start) {
    start();
  }
  nodeClasses.add(className);

  node.rcAnimTimeout = setTimeout(function () {
    node.rcAnimTimeout = null;
    nodeClasses.add(activeClassName);
    if (active) {
      setTimeout(active, 0);
    }
    fixBrowserByTimeout(node);
    // 30ms for firefox
  }, 30);

  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};

cssAnimation.style = function (node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);

    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;

    // Usually this optional callback is used for informing an owner of
    // a leave animation and telling it to remove the child.
    if (callback) {
      callback();
    }
  };

  _Event2["default"].addEndEventListener(node, node.rcEndListener);

  node.rcAnimTimeout = setTimeout(function () {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }
    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};

cssAnimation.setTransition = function (node, p, value) {
  var property = p;
  var v = value;
  if (value === undefined) {
    v = property;
    property = '';
  }
  property = property || '';
  capitalPrefixes.forEach(function (prefix) {
    node.style[prefix + 'Transition' + property] = v;
  });
};

cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

exports["default"] = cssAnimation;
module.exports = exports['default'];
},{"./Event":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/Event.js","component-classes":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/index.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

try {
  var index = require('indexof');
} catch (err) {
  var index = require('component-indexof');
}

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

},{"component-indexof":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/node_modules/component-indexof/index.js","indexof":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/node_modules/component-indexof/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/node_modules/component-indexof/index.js":[function(require,module,exports){
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListenerWrap;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _addDomEventListener = require('add-dom-event-listener');

var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function addEventListenerWrap(target, eventType, cb) {
  /* eslint camelcase: 2 */
  var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
    _reactDom2['default'].unstable_batchedUpdates(cb, e);
  } : cb;
  return (0, _addDomEventListener2['default'])(target, eventType, callback);
}

module.exports = exports['default'];
},{"add-dom-event-listener":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/index.js","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/contains.js":[function(require,module,exports){
"use strict";

module.exports = function contains(root, n) {
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }

  return false;
};
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/lib/createChainedFunction.js":[function(require,module,exports){
/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @returns {function|null}
 */
"use strict";

function createChainedFunction() {
  var args = arguments;
  return function chainedFunction() {
    for (var i = 0; i < args.length; i++) {
      if (args[i] && args[i].apply) {
        args[i].apply(this, arguments);
      }
    }
  };
}

module.exports = createChainedFunction;
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventBaseObject.js":[function(require,module,exports){
/**
 * @ignore
 * base event object for custom and dom event.
 * @author yiminghe@gmail.com
 */

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

function EventBaseObject() {
  this.timeStamp = Date.now();
  this.target = undefined;
  this.currentTarget = undefined;
}

EventBaseObject.prototype = {
  isEventObject: 1,

  constructor: EventBaseObject,

  isDefaultPrevented: returnFalse,

  isPropagationStopped: returnFalse,

  isImmediatePropagationStopped: returnFalse,

  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
  },

  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
  },

  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    // fixed 1.2
    // call stopPropagation implicitly
    this.stopPropagation();
  },

  halt: function halt(immediate) {
    if (immediate) {
      this.stopImmediatePropagation();
    } else {
      this.stopPropagation();
    }
    this.preventDefault();
  }
};

exports["default"] = EventBaseObject;
module.exports = exports["default"];
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventObject.js":[function(require,module,exports){
/**
 * @ignore
 * event object for dom
 * @author yiminghe@gmail.com
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _EventBaseObject = require('./EventBaseObject');

var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var TRUE = true;
var FALSE = false;
var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

function isNullOrUndefined(w) {
  return w === null || w === undefined;
}

var eventNormalizers = [{
  reg: /^key/,
  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
  fix: function fix(event, nativeEvent) {
    if (isNullOrUndefined(event.which)) {
      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
    }

    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
    if (event.metaKey === undefined) {
      event.metaKey = event.ctrlKey;
    }
  }
}, {
  reg: /^touch/,
  props: ['touches', 'changedTouches', 'targetTouches']
}, {
  reg: /^hashchange$/,
  props: ['newURL', 'oldURL']
}, {
  reg: /^gesturechange$/i,
  props: ['rotation', 'scale']
}, {
  reg: /^(mousewheel|DOMMouseScroll)$/,
  props: [],
  fix: function fix(event, nativeEvent) {
    var deltaX = undefined;
    var deltaY = undefined;
    var delta = undefined;
    var wheelDelta = nativeEvent.wheelDelta;
    var axis = nativeEvent.axis;
    var wheelDeltaY = nativeEvent.wheelDeltaY;
    var wheelDeltaX = nativeEvent.wheelDeltaX;
    var detail = nativeEvent.detail;

    // ie/webkit
    if (wheelDelta) {
      delta = wheelDelta / 120;
    }

    // gecko
    if (detail) {
      // press control e.detail == 1 else e.detail == 3
      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
    }

    // Gecko
    if (axis !== undefined) {
      if (axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = 0 - delta;
      } else if (axis === event.VERTICAL_AXIS) {
        deltaX = 0;
        deltaY = delta;
      }
    }

    // Webkit
    if (wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120;
    }
    if (wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120;
    }

    // 默认 deltaY (ie)
    if (!deltaX && !deltaY) {
      deltaY = delta;
    }

    if (deltaX !== undefined) {
      /**
       * deltaX of mousewheel event
       * @property deltaX
       * @member Event.DomEvent.Object
       */
      event.deltaX = deltaX;
    }

    if (deltaY !== undefined) {
      /**
       * deltaY of mousewheel event
       * @property deltaY
       * @member Event.DomEvent.Object
       */
      event.deltaY = deltaY;
    }

    if (delta !== undefined) {
      /**
       * delta of mousewheel event
       * @property delta
       * @member Event.DomEvent.Object
       */
      event.delta = delta;
    }
  }
}, {
  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
  fix: function fix(event, nativeEvent) {
    var eventDoc = undefined;
    var doc = undefined;
    var body = undefined;
    var target = event.target;
    var button = nativeEvent.button;

    // Calculate pageX/Y if missing and clientX/Y available
    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
      eventDoc = target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // which for click: 1 === left; 2 === middle; 3 === right
    // do not use button
    if (!event.which && button !== undefined) {
      if (button & 1) {
        event.which = 1;
      } else if (button & 2) {
        event.which = 3;
      } else if (button & 4) {
        event.which = 2;
      } else {
        event.which = 0;
      }
    }

    // add relatedTarget, if necessary
    if (!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
    }

    return event;
  }
}];

function retTrue() {
  return TRUE;
}

function retFalse() {
  return FALSE;
}

function DomEventObject(nativeEvent) {
  var type = nativeEvent.type;

  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

  _EventBaseObject2['default'].call(this);

  this.nativeEvent = nativeEvent;

  // in case dom event has been mark as default prevented by lower dom node
  var isDefaultPrevented = retFalse;
  if ('defaultPrevented' in nativeEvent) {
    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
  } else if ('getPreventDefault' in nativeEvent) {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
  } else if ('returnValue' in nativeEvent) {
    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
  }

  this.isDefaultPrevented = isDefaultPrevented;

  var fixFns = [];
  var fixFn = undefined;
  var l = undefined;
  var prop = undefined;
  var props = commonProps.concat();

  eventNormalizers.forEach(function (normalizer) {
    if (type.match(normalizer.reg)) {
      props = props.concat(normalizer.props);
      if (normalizer.fix) {
        fixFns.push(normalizer.fix);
      }
    }
  });

  l = props.length;

  // clone properties of the original event object
  while (l) {
    prop = props[--l];
    this[prop] = nativeEvent[prop];
  }

  // fix target property, if necessary
  if (!this.target && isNative) {
    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
  }

  // check if target is a text node (safari)
  if (this.target && this.target.nodeType === 3) {
    this.target = this.target.parentNode;
  }

  l = fixFns.length;

  while (l) {
    fixFn = fixFns[--l];
    fixFn(this, nativeEvent);
  }

  this.timeStamp = nativeEvent.timeStamp || Date.now();
}

var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
  constructor: DomEventObject,

  preventDefault: function preventDefault() {
    var e = this.nativeEvent;

    // if preventDefault exists run it on the original event
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      // otherwise set the returnValue property of the original event to FALSE (IE)
      e.returnValue = FALSE;
    }

    EventBaseObjectProto.preventDefault.call(this);
  },

  stopPropagation: function stopPropagation() {
    var e = this.nativeEvent;

    // if stopPropagation exists run it on the original event
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      // otherwise set the cancelBubble property of the original event to TRUE (IE)
      e.cancelBubble = TRUE;
    }

    EventBaseObjectProto.stopPropagation.call(this);
  }
});

exports['default'] = DomEventObject;
module.exports = exports['default'];
},{"./EventBaseObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventBaseObject.js","object-assign":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/node_modules/object-assign/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListener;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _EventObject = require('./EventObject');

var _EventObject2 = _interopRequireDefault(_EventObject);

function addEventListener(target, eventType, callback) {
  function wrapCallback(e) {
    var ne = new _EventObject2['default'](e);
    callback.call(target, ne);
  }

  if (target.addEventListener) {
    target.addEventListener(eventType, wrapCallback, false);
    return {
      remove: function remove() {
        target.removeEventListener(eventType, wrapCallback, false);
      }
    };
  } else if (target.attachEvent) {
    target.attachEvent('on' + eventType, wrapCallback);
    return {
      remove: function remove() {
        target.detachEvent('on' + eventType, wrapCallback);
      }
    };
  }
}

module.exports = exports['default'];
},{"./EventObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/node_modules/object-assign/index.js":[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/node_modules/warning/browser.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/AttributionControl.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _leaflet = require('leaflet');

var _MapControl2 = require('./MapControl');

var _MapControl3 = _interopRequireDefault(_MapControl2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AttributionControl = function (_MapControl) {
  _inherits(AttributionControl, _MapControl);

  function AttributionControl() {
    _classCallCheck(this, AttributionControl);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(AttributionControl).apply(this, arguments));
  }

  _createClass(AttributionControl, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.leafletElement = _leaflet.control.attribution(this.props);
    }
  }]);

  return AttributionControl;
}(_MapControl3.default);

AttributionControl.propTypes = {
  prefix: _react.PropTypes.string
};
exports.default = AttributionControl;
},{"./MapControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapControl.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/BaseTileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseTileLayer = function (_MapLayer) {
  _inherits(BaseTileLayer, _MapLayer);

  function BaseTileLayer() {
    _classCallCheck(this, BaseTileLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(BaseTileLayer).apply(this, arguments));
  }

  _createClass(BaseTileLayer, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props;
      var opacity = _props.opacity;
      var zIndex = _props.zIndex;

      if (opacity !== prevProps.opacity) {
        this.leafletElement.setOpacity(opacity);
      }
      if (zIndex !== prevProps.zIndex) {
        this.leafletElement.setZIndex(zIndex);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return BaseTileLayer;
}(_MapLayer3.default);

BaseTileLayer.propTypes = {
  opacity: _react.PropTypes.number,
  zIndex: _react.PropTypes.number
};
exports.default = BaseTileLayer;
},{"./MapLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/CanvasTileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _leaflet = require('leaflet');

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CanvasTileLayer = function (_BaseTileLayer) {
  _inherits(CanvasTileLayer, _BaseTileLayer);

  function CanvasTileLayer() {
    _classCallCheck(this, CanvasTileLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(CanvasTileLayer).apply(this, arguments));
  }

  _createClass(CanvasTileLayer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(CanvasTileLayer.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer']);

      this.leafletElement = _leaflet.tileLayer.canvas(props);
    }
  }]);

  return CanvasTileLayer;
}(_BaseTileLayer3.default);

exports.default = CanvasTileLayer;
},{"./BaseTileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/BaseTileLayer.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Circle.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _latlng = require('./types/latlng');

var _latlng2 = _interopRequireDefault(_latlng);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Circle = function (_Path) {
  _inherits(Circle, _Path);

  function Circle() {
    _classCallCheck(this, Circle);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Circle).apply(this, arguments));
  }

  _createClass(Circle, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Circle.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var center = _props.center;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var radius = _props.radius;

      var props = _objectWithoutProperties(_props, ['center', 'map', 'layerContainer', 'radius']);

      this.leafletElement = (0, _leaflet.circle)(center, radius, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.center !== prevProps.center) {
        this.leafletElement.setLatLng(this.props.center);
      }
      if (this.props.radius !== prevProps.radius) {
        this.leafletElement.setRadius(this.props.radius);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return Circle;
}(_Path3.default);

Circle.propTypes = {
  center: _latlng2.default.isRequired,
  radius: _react.PropTypes.number.isRequired
};
exports.default = Circle;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/CircleMarker.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _latlng = require('./types/latlng');

var _latlng2 = _interopRequireDefault(_latlng);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CircleMarker = function (_Path) {
  _inherits(CircleMarker, _Path);

  function CircleMarker() {
    _classCallCheck(this, CircleMarker);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(CircleMarker).apply(this, arguments));
  }

  _createClass(CircleMarker, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(CircleMarker.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var center = _props.center;
      var _map = _props.map;
      var _lc = _props.layerContainer;

      var props = _objectWithoutProperties(_props, ['center', 'map', 'layerContainer']);

      this.leafletElement = (0, _leaflet.circleMarker)(center, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.center !== prevProps.center) {
        this.leafletElement.setLatLng(this.props.center);
      }
      if (this.props.radius !== prevProps.radius) {
        this.leafletElement.setRadius(this.props.radius);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return CircleMarker;
}(_Path3.default);

CircleMarker.propTypes = {
  center: _latlng2.default.isRequired,
  radius: _react.PropTypes.number
};
exports.default = CircleMarker;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/FeatureGroup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _leaflet = require('leaflet');

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FeatureGroup = function (_Path) {
  _inherits(FeatureGroup, _Path);

  function FeatureGroup() {
    _classCallCheck(this, FeatureGroup);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(FeatureGroup).apply(this, arguments));
  }

  _createClass(FeatureGroup, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.leafletElement = (0, _leaflet.featureGroup)();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(Object.getPrototypeOf(FeatureGroup.prototype), 'componentDidMount', this).call(this);
      this.setStyle(this.props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      this.setStyleIfChanged(prevProps, this.props);
    }
  }, {
    key: 'render',
    value: function render() {
      return this.renderChildrenWithProps({
        layerContainer: this.leafletElement,
        popupContainer: this.leafletElement
      });
    }
  }]);

  return FeatureGroup;
}(_Path3.default);

exports.default = FeatureGroup;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/GeoJson.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GeoJson = function (_Path) {
  _inherits(GeoJson, _Path);

  function GeoJson() {
    _classCallCheck(this, GeoJson);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(GeoJson).apply(this, arguments));
  }

  _createClass(GeoJson, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(GeoJson.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var data = _props.data;
      var _map = _props.map;
      var _lc = _props.layerContainer;

      var props = _objectWithoutProperties(_props, ['data', 'map', 'layerContainer']);

      this.leafletElement = (0, _leaflet.geoJson)(data, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if ((0, _isFunction3.default)(this.props.style)) {
        this.setStyle(this.props.style);
      } else {
        this.setStyleIfChanged(prevProps, this.props);
      }
    }
  }]);

  return GeoJson;
}(_Path3.default);

GeoJson.propTypes = {
  data: _react.PropTypes.object.isRequired
};
exports.default = GeoJson;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","lodash/isFunction":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isFunction.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/ImageOverlay.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _bounds = require('./types/bounds');

var _bounds2 = _interopRequireDefault(_bounds);

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ImageOverlay = function (_MapLayer) {
  _inherits(ImageOverlay, _MapLayer);

  function ImageOverlay() {
    _classCallCheck(this, ImageOverlay);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ImageOverlay).apply(this, arguments));
  }

  _createClass(ImageOverlay, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(ImageOverlay.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var bounds = _props.bounds;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var url = _props.url;

      var props = _objectWithoutProperties(_props, ['bounds', 'map', 'layerContainer', 'url']);

      this.leafletElement = (0, _leaflet.imageOverlay)(url, bounds, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.url !== prevProps.url) {
        this.leafletElement.setUrl(this.props.url);
      }
      if (this.props.opacity !== prevProps.opacity) {
        this.leafletElement.setOpacity(this.props.opacity);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return ImageOverlay;
}(_MapLayer3.default);

ImageOverlay.propTypes = {
  attribution: _react.PropTypes.string,
  bounds: _bounds2.default.isRequired,
  opacity: _react.PropTypes.number,
  url: _react.PropTypes.string.isRequired
};
exports.default = ImageOverlay;
},{"./MapLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js","./types/bounds":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/bounds.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/LayerGroup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _leaflet = require('leaflet');

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LayerGroup = function (_MapLayer) {
  _inherits(LayerGroup, _MapLayer);

  function LayerGroup() {
    _classCallCheck(this, LayerGroup);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(LayerGroup).apply(this, arguments));
  }

  _createClass(LayerGroup, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(LayerGroup.prototype), 'componentWillMount', this).call(this);
      this.leafletElement = (0, _leaflet.layerGroup)();
    }
  }, {
    key: 'render',
    value: function render() {
      return this.renderChildrenWithProps({
        layerContainer: this.leafletElement
      });
    }
  }]);

  return LayerGroup;
}(_MapLayer3.default);

exports.default = LayerGroup;
},{"./MapLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/LayersControl.js":[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _leaflet = require('leaflet');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _children2 = require('./types/children');

var _children3 = _interopRequireDefault(_children2);

var _layerContainer = require('./types/layerContainer');

var _layerContainer2 = _interopRequireDefault(_layerContainer);

var _MapControl2 = require('./MapControl');

var _MapControl3 = _interopRequireDefault(_MapControl2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var controlledLayerPropTypes = {
  addBaseLayer: _react.PropTypes.func,
  addOverlay: _react.PropTypes.func,
  checked: _react.PropTypes.bool,
  children: _react.PropTypes.node.isRequired,
  map: _react.PropTypes.instanceOf(_leaflet.Map),
  name: _react.PropTypes.string.isRequired,
  removeLayer: _react.PropTypes.func,
  removeLayerControl: _react.PropTypes.func
};

// Abtract class for layer container, extended by BaseLayer and Overlay

var ControlledLayer = function (_Component) {
  _inherits(ControlledLayer, _Component);

  function ControlledLayer() {
    _classCallCheck(this, ControlledLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ControlledLayer).apply(this, arguments));
  }

  _createClass(ControlledLayer, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(_ref) {
      var checked = _ref.checked;
      var map = _ref.map;

      // Handle dynamically (un)checking the layer => adding/removing from the map
      if (checked && !this.props.checked) {
        map.addLayer(this.layer);
      } else if (this.props.checked && !checked) {
        map.removeLayer(this.layer);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.props.removeLayerControl(this.layer);
    }
  }, {
    key: 'removeLayer',
    value: function removeLayer(layer) {
      this.props.removeLayer(layer);
    }
  }, {
    key: 'render',
    value: function render() {
      return (0, _react.cloneElement)(_react.Children.only(this.props.children), {
        // Proxy layer container method calls to local methods
        layerContainer: {
          addLayer: this.addLayer.bind(this),
          removeLayer: this.removeLayer.bind(this)
        },
        map: this.props.map
      });
    }
  }]);

  return ControlledLayer;
}(_react.Component);

ControlledLayer.propTypes = controlledLayerPropTypes;

var BaseLayer = function (_ControlledLayer) {
  _inherits(BaseLayer, _ControlledLayer);

  function BaseLayer() {
    _classCallCheck(this, BaseLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(BaseLayer).apply(this, arguments));
  }

  _createClass(BaseLayer, [{
    key: 'addLayer',
    value: function addLayer(layer) {
      this.layer = layer; // Keep layer reference to handle dynamic changes of props
      var _props = this.props;
      var addBaseLayer = _props.addBaseLayer;
      var checked = _props.checked;
      var name = _props.name;

      addBaseLayer(layer, name, checked);
    }
  }]);

  return BaseLayer;
}(ControlledLayer);

BaseLayer.propTypes = controlledLayerPropTypes;

var Overlay = function (_ControlledLayer2) {
  _inherits(Overlay, _ControlledLayer2);

  function Overlay() {
    _classCallCheck(this, Overlay);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Overlay).apply(this, arguments));
  }

  _createClass(Overlay, [{
    key: 'addLayer',
    value: function addLayer(layer) {
      this.layer = layer; // Keep layer reference to handle dynamic changes of props
      var _props2 = this.props;
      var addOverlay = _props2.addOverlay;
      var checked = _props2.checked;
      var name = _props2.name;

      addOverlay(layer, name, checked);
    }
  }]);

  return Overlay;
}(ControlledLayer);

Overlay.propTypes = controlledLayerPropTypes;

var LayersControl = function (_MapControl) {
  _inherits(LayersControl, _MapControl);

  function LayersControl() {
    _classCallCheck(this, LayersControl);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(LayersControl).apply(this, arguments));
  }

  _createClass(LayersControl, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _props3 = this.props;
      var baseLayers = _props3.baseLayers;
      var _children = _props3.children;
      var _lc = _props3.layerContainer;
      var _map = _props3.map;
      var overlays = _props3.overlays;

      var options = _objectWithoutProperties(_props3, ['baseLayers', 'children', 'layerContainer', 'map', 'overlays']);

      // Pre-v0.11 behavior, warn in v0.11, remove in v0.12


      this.legacy = !!(baseLayers || overlays);

      if (this.legacy) {
        process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'The "baseLayers" and "overlays" properties for "LayersControl" are deprecated and will be removed in the next version. You should use the "LayersControl.BaseLayer" and "LayersControl.Overlay" instead, see the documentation for more information.') : void 0;
        this.leafletElement = _leaflet.control.layers(baseLayers, overlays, options);
      } else {
        this.leafletElement = _leaflet.control.layers(undefined, undefined, options);
        this.controlProps = {
          addBaseLayer: this.addBaseLayer.bind(this),
          addOverlay: this.addOverlay.bind(this),
          removeLayer: this.removeLayer.bind(this),
          removeLayerControl: this.removeLayerControl.bind(this)
        };
      }
    }
  }, {
    key: 'addBaseLayer',
    value: function addBaseLayer(layer, name) {
      var checked = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      if (checked) {
        this.props.map.addLayer(layer);
      }
      this.leafletElement.addBaseLayer(layer, name);
    }
  }, {
    key: 'addOverlay',
    value: function addOverlay(layer, name) {
      var checked = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      if (checked) {
        this.props.map.addLayer(layer);
      }
      this.leafletElement.addOverlay(layer, name);
    }
  }, {
    key: 'removeLayer',
    value: function removeLayer(layer) {
      this.props.map.removeLayer(layer);
    }
  }, {
    key: 'removeLayerControl',
    value: function removeLayerControl(layer) {
      this.leafletElement.removeLayer(layer);
    }
  }, {
    key: 'getClonedChildrenWithProps',
    value: function getClonedChildrenWithProps(extra) {
      var _props4 = this.props;
      var children = _props4.children;
      var layerContainer = _props4.layerContainer;
      var map = _props4.map;

      var props = (0, _assign3.default)({ layerContainer: layerContainer, map: map }, extra);

      return _react.Children.map(children, function (child) {
        return child ? (0, _react.cloneElement)(child, props) : null;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.legacy) {
        return null;
      }

      var children = this.getClonedChildrenWithProps(this.controlProps);
      return _react2.default.createElement(
        'div',
        { style: { display: 'none' } },
        children
      );
    }
  }]);

  return LayersControl;
}(_MapControl3.default);

LayersControl.propTypes = {
  baseLayers: _react.PropTypes.object,
  children: _children3.default,
  layerContainer: _layerContainer2.default,
  map: _react.PropTypes.instanceOf(_leaflet.Map),
  overlays: _react.PropTypes.object
};
exports.default = LayersControl;


LayersControl.BaseLayer = BaseLayer;
LayersControl.Overlay = Overlay;
}).call(this,require('_process'))

},{"./MapControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapControl.js","./types/children":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/children.js","./types/layerContainer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/layerContainer.js","_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","lodash/assign":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/assign.js","react":"react","warning":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/warning/browser.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Map.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _isUndefined2 = require('lodash/isUndefined');

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

var _bounds = require('./types/bounds');

var _bounds2 = _interopRequireDefault(_bounds);

var _children = require('./types/children');

var _children2 = _interopRequireDefault(_children);

var _latlng = require('./types/latlng');

var _latlng2 = _interopRequireDefault(_latlng);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/no-did-mount-set-state */

var normalizeCenter = function normalizeCenter(pos) {
  return (0, _isArray3.default)(pos) ? pos : [pos.lat, pos.lng || pos.lon];
};

var Map = function (_MapComponent) {
  _inherits(Map, _MapComponent);

  function Map(props) {
    _classCallCheck(this, Map);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Map).call(this, props));

    _this.state = {
      id: props.id || (0, _uniqueId3.default)('map')
    };
    return _this;
  }

  _createClass(Map, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var props = (0, _omit3.default)(this.props, ['children', 'className', 'id', 'style']);
      this.leafletElement = _leaflet2.default.map(this.state.id, props);
      _get(Object.getPrototypeOf(Map.prototype), 'componentDidMount', this).call(this);
      this.setState({ map: this.leafletElement });
      if (!(0, _isUndefined3.default)(props.bounds)) {
        this.leafletElement.fitBounds(props.bounds, props.boundsOptions);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props;
      var bounds = _props.bounds;
      var boundsOptions = _props.boundsOptions;
      var center = _props.center;
      var maxBounds = _props.maxBounds;
      var zoom = _props.zoom;
      var animate = _props.animate;

      if (center && this.shouldUpdateCenter(center, prevProps.center)) {
        this.leafletElement.setView(center, zoom, { animate: animate });
      } else if (zoom && zoom !== prevProps.zoom) {
        this.leafletElement.setZoom(zoom);
      }
      if (maxBounds && this.shouldUpdateBounds(maxBounds, prevProps.maxBounds)) {
        this.leafletElement.setMaxBounds(maxBounds);
      }
      if (bounds && (this.shouldUpdateBounds(bounds, prevProps.bounds) || boundsOptions !== prevProps.boundsOptions)) {
        this.leafletElement.fitBounds(bounds, boundsOptions);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(Object.getPrototypeOf(Map.prototype), 'componentWillUnmount', this).call(this);
      this.leafletElement.remove();
    }
  }, {
    key: 'shouldUpdateCenter',
    value: function shouldUpdateCenter(next, prev) {
      if (!prev) return true;
      next = normalizeCenter(next);
      prev = normalizeCenter(prev);
      return next[0] !== prev[0] || next[1] !== prev[1];
    }
  }, {
    key: 'shouldUpdateBounds',
    value: function shouldUpdateBounds(next, prev) {
      if (!prev) return true;
      next = _leaflet2.default.latLngBounds(next);
      prev = _leaflet2.default.latLngBounds(prev);
      return !next.equals(prev);
    }
  }, {
    key: 'render',
    value: function render() {
      var map = this.leafletElement;
      var children = map ? _react2.default.Children.map(this.props.children, function (child) {
        return child ? _react2.default.cloneElement(child, { map: map, layerContainer: map }) : null;
      }) : null;

      return _react2.default.createElement(
        'div',
        {
          className: this.props.className,
          id: this.state.id,
          style: this.props.style },
        children
      );
    }
  }]);

  return Map;
}(_MapComponent3.default);

Map.propTypes = {
  animate: _react.PropTypes.bool,
  bounds: _bounds2.default,
  boundsOptions: _react.PropTypes.object,
  center: _latlng2.default,
  children: _children2.default,
  className: _react.PropTypes.string,
  id: _react.PropTypes.string,
  maxBounds: _bounds2.default,
  maxZoom: _react.PropTypes.number,
  minZoom: _react.PropTypes.number,
  style: _react.PropTypes.object,
  zoom: _react.PropTypes.number
};
Map.defaultProps = {
  animate: false
};
exports.default = Map;
},{"./MapComponent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapComponent.js","./types/bounds":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/bounds.js","./types/children":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/children.js","./types/latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","lodash/isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","lodash/isUndefined":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isUndefined.js","lodash/omit":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/omit.js","lodash/uniqueId":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/uniqueId.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapComponent.js":[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EVENTS_RE_LEGACY = /^onLeaflet(.+)$/i;
var EVENTS_RE = /^on(.+)$/i;

var MapComponent = function (_Component) {
  _inherits(MapComponent, _Component);

  function MapComponent() {
    _classCallCheck(this, MapComponent);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MapComponent).apply(this, arguments));
  }

  _createClass(MapComponent, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this._leafletEvents = this.extractLeafletEvents(this.props);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.bindLeafletEvents(this._leafletEvents);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var next = this.extractLeafletEvents(nextProps);
      this._leafletEvents = this.bindLeafletEvents(next, this._leafletEvents);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var el = this.leafletElement;
      if (!el) return;

      (0, _forEach3.default)(this._leafletEvents, function (cb, ev) {
        el.off(ev, cb);
      });
    }
  }, {
    key: 'getLeafletElement',
    value: function getLeafletElement() {
      return this.leafletElement;
    }
  }, {
    key: 'extractLeafletEvents',
    value: function extractLeafletEvents(props) {
      return (0, _reduce3.default)((0, _keys3.default)(props), function (res, prop) {
        var maybeEvent = prop.replace(EVENTS_RE_LEGACY, function (match, p) {
          process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '"onLeaflet' + p + '" and other "onLeaflet..." properties are deprecated and support will be removed in the next version, use "on' + p + '" instead.') : void 0;
          return 'on' + p;
        });
        if (EVENTS_RE.test(maybeEvent)) {
          var key = maybeEvent.replace(EVENTS_RE, function (match, p) {
            return p.toLowerCase();
          });
          res[key] = props[prop];
        }
        return res;
      }, {});
    }
  }, {
    key: 'bindLeafletEvents',
    value: function bindLeafletEvents() {
      var next = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var prev = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var el = this.leafletElement;
      if (!el || !el.on) return;

      var diff = (0, _clone3.default)(prev);
      (0, _forEach3.default)(prev, function (cb, ev) {
        if (!next[ev] || cb !== next[ev]) {
          delete diff[ev];
          el.off(ev, cb);
        }
      });

      (0, _forEach3.default)(next, function (cb, ev) {
        if (!prev[ev] || cb !== prev[ev]) {
          diff[ev] = cb;
          el.on(ev, cb);
        }
      });

      return diff;
    }
  }, {
    key: 'fireLeafletEvent',
    value: function fireLeafletEvent(type, data) {
      var el = this.leafletElement;
      if (el) el.fire(type, data);
    }
  }]);

  return MapComponent;
}(_react.Component);

exports.default = MapComponent;
}).call(this,require('_process'))

},{"_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js","lodash/clone":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/clone.js","lodash/forEach":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/forEach.js","lodash/keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js","lodash/reduce":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/reduce.js","react":"react","warning":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/warning/browser.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapControl.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _controlPosition = require('./types/controlPosition');

var _controlPosition2 = _interopRequireDefault(_controlPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MapControl = function (_Component) {
  _inherits(MapControl, _Component);

  function MapControl() {
    _classCallCheck(this, MapControl);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MapControl).apply(this, arguments));
  }

  _createClass(MapControl, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.leafletElement.addTo(this.props.map);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.position !== prevProps.position) {
        this.leafletElement.setPosition(this.props.position);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.leafletElement.removeFrom(this.props.map);
    }
  }, {
    key: 'getLeafletElement',
    value: function getLeafletElement() {
      return this.leafletElement;
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return MapControl;
}(_react.Component);

MapControl.propTypes = {
  map: _react.PropTypes.object,
  position: _controlPosition2.default
};
exports.default = MapControl;
},{"./types/controlPosition":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/controlPosition.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _leaflet = require('leaflet');

var _children = require('./types/children');

var _children2 = _interopRequireDefault(_children);

var _layerContainer = require('./types/layerContainer');

var _layerContainer2 = _interopRequireDefault(_layerContainer);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MapLayer = function (_MapComponent) {
  _inherits(MapLayer, _MapComponent);

  function MapLayer() {
    _classCallCheck(this, MapLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MapLayer).apply(this, arguments));
  }

  _createClass(MapLayer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(Object.getPrototypeOf(MapLayer.prototype), 'componentDidMount', this).call(this);
      this.props.layerContainer.addLayer(this.leafletElement);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(Object.getPrototypeOf(MapLayer.prototype), 'componentWillUnmount', this).call(this);
      this.props.layerContainer.removeLayer(this.leafletElement);
    }
  }, {
    key: 'getClonedChildrenWithProps',
    value: function getClonedChildrenWithProps(extra) {
      var _props = this.props;
      var children = _props.children;
      var map = _props.map;
      var layerContainer = _props.layerContainer;

      var props = (0, _assign3.default)({ map: map, layerContainer: layerContainer }, extra);

      return _react.Children.map(children, function (child) {
        return child ? (0, _react.cloneElement)(child, props) : null;
      });
    }
  }, {
    key: 'renderChildrenWithProps',
    value: function renderChildrenWithProps(props) {
      var children = this.getClonedChildrenWithProps(props);
      return _react2.default.createElement(
        'div',
        { style: { display: 'none' } },
        children
      );
    }
  }]);

  return MapLayer;
}(_MapComponent3.default);

MapLayer.propTypes = {
  children: _children2.default,
  layerContainer: _layerContainer2.default,
  map: _react.PropTypes.instanceOf(_leaflet.Map)
};
exports.default = MapLayer;
},{"./MapComponent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapComponent.js","./types/children":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/children.js","./types/layerContainer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/layerContainer.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","lodash/assign":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/assign.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Marker.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _latlng = require('./types/latlng');

var _latlng2 = _interopRequireDefault(_latlng);

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Marker = function (_MapLayer) {
  _inherits(Marker, _MapLayer);

  function Marker() {
    _classCallCheck(this, Marker);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Marker).apply(this, arguments));
  }

  _createClass(Marker, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Marker.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var position = _props.position;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'position']);

      this.leafletElement = (0, _leaflet.marker)(position, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.position !== prevProps.position) {
        this.leafletElement.setLatLng(this.props.position);
      }
      if (this.props.icon !== prevProps.icon) {
        this.leafletElement.setIcon(this.props.icon);
      }
      if (this.props.zIndexOffset !== prevProps.zIndexOffset) {
        this.leafletElement.setZIndexOffset(this.props.zIndexOffset);
      }
      if (this.props.opacity !== prevProps.opacity) {
        this.leafletElement.setOpacity(this.props.opacity);
      }
      if (this.props.draggable !== prevProps.draggable) {
        if (this.props.draggable) {
          this.leafletElement.dragging.enable();
        } else {
          this.leafletElement.dragging.disable();
        }
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.renderChildrenWithProps({
        popupContainer: this.leafletElement
      });
    }
  }]);

  return Marker;
}(_MapLayer3.default);

Marker.propTypes = {
  icon: _react.PropTypes.instanceOf(_leaflet.Icon),
  opacity: _react.PropTypes.number,
  position: _latlng2.default.isRequired,
  zIndexOffset: _react.PropTypes.number
};
exports.default = Marker;
},{"./MapLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js","./types/latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MultiPolygon.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _latlngList = require('./types/latlngList');

var _latlngList2 = _interopRequireDefault(_latlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultiPolygon = function (_Path) {
  _inherits(MultiPolygon, _Path);

  function MultiPolygon() {
    _classCallCheck(this, MultiPolygon);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MultiPolygon).apply(this, arguments));
  }

  _createClass(MultiPolygon, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(MultiPolygon.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var polygons = _props.polygons;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'polygons']);

      this.leafletElement = (0, _leaflet.multiPolygon)(polygons, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.polygons !== prevProps.polygons) {
        this.leafletElement.setLatLngs(this.props.polygons);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return MultiPolygon;
}(_Path3.default);

MultiPolygon.propTypes = {
  polygons: _react.PropTypes.arrayOf(_latlngList2.default).isRequired
};
exports.default = MultiPolygon;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MultiPolyline.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _latlngList = require('./types/latlngList');

var _latlngList2 = _interopRequireDefault(_latlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultiPolyline = function (_Path) {
  _inherits(MultiPolyline, _Path);

  function MultiPolyline() {
    _classCallCheck(this, MultiPolyline);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MultiPolyline).apply(this, arguments));
  }

  _createClass(MultiPolyline, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(MultiPolyline.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var polylines = _props.polylines;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'polylines']);

      this.leafletElement = (0, _leaflet.multiPolyline)(polylines, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.polylines !== prevProps.polylines) {
        this.leafletElement.setLatLngs(this.props.polylines);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return MultiPolyline;
}(_Path3.default);

MultiPolyline.propTypes = {
  polylines: _react.PropTypes.arrayOf(_latlngList2.default).isRequired
};
exports.default = MultiPolyline;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OPTIONS = ['stroke', 'color', 'weight', 'opacity', 'fill', 'fillColor', 'fillOpacity', 'fillRule', 'dashArray', 'lineCap', 'lineJoin', 'clickable', 'pointerEvents', 'className'];

var Path = function (_MapLayer) {
  _inherits(Path, _MapLayer);

  function Path() {
    _classCallCheck(this, Path);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Path).apply(this, arguments));
  }

  _createClass(Path, [{
    key: 'getPathOptions',
    value: function getPathOptions(props) {
      return (0, _pick3.default)(props, OPTIONS);
    }
  }, {
    key: 'setStyle',
    value: function setStyle() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      this.leafletElement.setStyle(options);
    }
  }, {
    key: 'setStyleIfChanged',
    value: function setStyleIfChanged(fromProps, toProps) {
      var nextStyle = this.getPathOptions(toProps);
      if (!(0, _isEqual3.default)(nextStyle, this.getPathOptions(fromProps))) {
        this.setStyle(nextStyle);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.renderChildrenWithProps({
        popupContainer: this.leafletElement
      });
    }
  }]);

  return Path;
}(_MapLayer3.default);

exports.default = Path;
},{"./MapLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js","lodash/isEqual":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isEqual.js","lodash/pick":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/pick.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Polygon.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _latlngList = require('./types/latlngList');

var _latlngList2 = _interopRequireDefault(_latlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Polygon = function (_Path) {
  _inherits(Polygon, _Path);

  function Polygon() {
    _classCallCheck(this, Polygon);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Polygon).apply(this, arguments));
  }

  _createClass(Polygon, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Polygon.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var positions = _props.positions;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'positions']);

      this.leafletElement = (0, _leaflet.polygon)(positions, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.positions !== prevProps.positions) {
        this.leafletElement.setLatLngs(this.props.positions);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return Polygon;
}(_Path3.default);

Polygon.propTypes = {
  positions: _react.PropTypes.oneOfType([_latlngList2.default, _react.PropTypes.arrayOf(_latlngList2.default)]).isRequired
};
exports.default = Polygon;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Polyline.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _leaflet = require('leaflet');

var _latlngList = require('./types/latlngList');

var _latlngList2 = _interopRequireDefault(_latlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Polyline = function (_Path) {
  _inherits(Polyline, _Path);

  function Polyline() {
    _classCallCheck(this, Polyline);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Polyline).apply(this, arguments));
  }

  _createClass(Polyline, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Polyline.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var positions = _props.positions;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'positions']);

      this.leafletElement = (0, _leaflet.polyline)(positions, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.positions !== prevProps.positions) {
        this.leafletElement.setLatLngs(this.props.positions);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return Polyline;
}(_Path3.default);

Polyline.propTypes = {
  positions: _latlngList2.default.isRequired
};
exports.default = Polyline;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Popup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _reactDom = require('react-dom');

var _leaflet = require('leaflet');

var _latlng = require('./types/latlng');

var _latlng2 = _interopRequireDefault(_latlng);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Popup = function (_MapComponent) {
  _inherits(Popup, _MapComponent);

  function Popup() {
    _classCallCheck(this, Popup);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Popup).apply(this, arguments));
  }

  _createClass(Popup, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Popup.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _children = _props.children;
      var _map = _props.map;
      var popupContainer = _props.popupContainer;

      var props = _objectWithoutProperties(_props, ['children', 'map', 'popupContainer']);

      this.leafletElement = (0, _leaflet.popup)(props, popupContainer);
      this.leafletElement.on('open', this.renderPopupContent.bind(this));
      this.leafletElement.on('close', this.removePopupContent.bind(this));
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _props2 = this.props;
      var map = _props2.map;
      var popupContainer = _props2.popupContainer;
      var position = _props2.position;

      var el = this.leafletElement;

      if (popupContainer) {
        // Attach to container component
        popupContainer.bindPopup(el);
      } else {
        // Attach to a Map
        if (position) {
          el.setLatLng(position);
        }
        el.openOn(map);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var position = this.props.position;


      if (position !== prevProps.position) {
        this.leafletElement.setLatLng(position);
      }

      if (this.leafletElement._isOpen) {
        this.renderPopupContent();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(Object.getPrototypeOf(Popup.prototype), 'componentWillUnmount', this).call(this);
      this.removePopupContent();
      this.props.map.removeLayer(this.leafletElement);
    }
  }, {
    key: 'renderPopupContent',
    value: function renderPopupContent() {
      if (this.props.children) {
        (0, _reactDom.render)(_react.Children.only(this.props.children), this.leafletElement._contentNode);

        this.leafletElement._updateLayout();
        this.leafletElement._updatePosition();
        this.leafletElement._adjustPan();
      } else {
        this.removePopupContent();
      }
    }
  }, {
    key: 'removePopupContent',
    value: function removePopupContent() {
      if (this.leafletElement._contentNode) {
        (0, _reactDom.unmountComponentAtNode)(this.leafletElement._contentNode);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return Popup;
}(_MapComponent3.default);

Popup.propTypes = {
  children: _react.PropTypes.node,
  map: _react.PropTypes.instanceOf(_leaflet.Map),
  popupContainer: _react.PropTypes.object,
  position: _latlng2.default
};
exports.default = Popup;
},{"./MapComponent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapComponent.js","./types/latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Rectangle.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _leaflet = require('leaflet');

var _bounds = require('./types/bounds');

var _bounds2 = _interopRequireDefault(_bounds);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Rectangle = function (_Path) {
  _inherits(Rectangle, _Path);

  function Rectangle() {
    _classCallCheck(this, Rectangle);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Rectangle).apply(this, arguments));
  }

  _createClass(Rectangle, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Rectangle.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var bounds = _props.bounds;
      var _map = _props.map;
      var _lc = _props.layerContainer;

      var props = _objectWithoutProperties(_props, ['bounds', 'map', 'layerContainer']);

      this.leafletElement = (0, _leaflet.rectangle)(bounds, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.bounds !== prevProps.bounds) {
        this.leafletElement.setBounds(this.props.bounds);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }]);

  return Rectangle;
}(_Path3.default);

Rectangle.propTypes = {
  bounds: _bounds2.default.isRequired
};
exports.default = Rectangle;
},{"./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./types/bounds":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/bounds.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/ScaleControl.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _leaflet = require('leaflet');

var _MapControl2 = require('./MapControl');

var _MapControl3 = _interopRequireDefault(_MapControl2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ZoomControl = function (_MapControl) {
  _inherits(ZoomControl, _MapControl);

  function ZoomControl() {
    _classCallCheck(this, ZoomControl);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ZoomControl).apply(this, arguments));
  }

  _createClass(ZoomControl, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.leafletElement = _leaflet.control.scale(this.props);
    }
  }]);

  return ZoomControl;
}(_MapControl3.default);

ZoomControl.propTypes = {
  imperial: _react.PropTypes.bool,
  maxWidth: _react.PropTypes.number,
  metric: _react.PropTypes.bool,
  updateWhenIdle: _react.PropTypes.bool
};
exports.default = ZoomControl;
},{"./MapControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapControl.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/TileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TileLayer = function (_BaseTileLayer) {
  _inherits(TileLayer, _BaseTileLayer);

  function TileLayer() {
    _classCallCheck(this, TileLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(TileLayer).apply(this, arguments));
  }

  _createClass(TileLayer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(TileLayer.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var url = _props.url;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'url']);

      this.leafletElement = (0, _leaflet.tileLayer)(url, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      _get(Object.getPrototypeOf(TileLayer.prototype), 'componentDidUpdate', this).call(this, prevProps);
      var url = this.props.url;

      if (url !== prevProps.url) {
        this.leafletElement.setUrl(url);
      }
    }
  }]);

  return TileLayer;
}(_BaseTileLayer3.default);

TileLayer.propTypes = {
  url: _react.PropTypes.string.isRequired
};
exports.default = TileLayer;
},{"./BaseTileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/BaseTileLayer.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/WMSTileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _leaflet = require('leaflet');

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WMSTileLayer = function (_BaseTileLayer) {
  _inherits(WMSTileLayer, _BaseTileLayer);

  function WMSTileLayer() {
    _classCallCheck(this, WMSTileLayer);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(WMSTileLayer).apply(this, arguments));
  }

  _createClass(WMSTileLayer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(WMSTileLayer.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var _map = _props.map;
      var _lc = _props.layerContainer;
      var url = _props.url;

      var props = _objectWithoutProperties(_props, ['map', 'layerContainer', 'url']);

      this.leafletElement = _leaflet.tileLayer.wms(url, props);
    }
  }]);

  return WMSTileLayer;
}(_BaseTileLayer3.default);

WMSTileLayer.propTypes = {
  url: _react.PropTypes.string.isRequired
};
exports.default = WMSTileLayer;
},{"./BaseTileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/BaseTileLayer.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/ZoomControl.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _leaflet = require('leaflet');

var _MapControl2 = require('./MapControl');

var _MapControl3 = _interopRequireDefault(_MapControl2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ZoomControl = function (_MapControl) {
  _inherits(ZoomControl, _MapControl);

  function ZoomControl() {
    _classCallCheck(this, ZoomControl);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ZoomControl).apply(this, arguments));
  }

  _createClass(ZoomControl, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.leafletElement = _leaflet.control.zoom(this.props);
    }
  }]);

  return ZoomControl;
}(_MapControl3.default);

ZoomControl.propTypes = {
  zoomInText: _react.PropTypes.string,
  zoomInTitle: _react.PropTypes.string,
  zoomOutText: _react.PropTypes.string,
  zoomOutTitle: _react.PropTypes.string
};
exports.default = ZoomControl;
},{"./MapControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapControl.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setIconDefaultImagePath = exports.ZoomControl = exports.WMSTileLayer = exports.TileLayer = exports.ScaleControl = exports.Rectangle = exports.Popup = exports.Polyline = exports.Polygon = exports.Path = exports.MultiPolyline = exports.MultiPolygon = exports.Marker = exports.MapLayer = exports.MapControl = exports.MapComponent = exports.Map = exports.LayersControl = exports.LayerGroup = exports.ImageOverlay = exports.GeoJson = exports.FeatureGroup = exports.CircleMarker = exports.Circle = exports.CanvasTileLayer = exports.BaseTileLayer = exports.AttributionControl = exports.PropTypes = undefined;

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

var _types = require('./types');

var _PropTypes = _interopRequireWildcard(_types);

var _AttributionControl2 = require('./AttributionControl');

var _AttributionControl3 = _interopRequireDefault(_AttributionControl2);

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

var _CanvasTileLayer2 = require('./CanvasTileLayer');

var _CanvasTileLayer3 = _interopRequireDefault(_CanvasTileLayer2);

var _Circle2 = require('./Circle');

var _Circle3 = _interopRequireDefault(_Circle2);

var _CircleMarker2 = require('./CircleMarker');

var _CircleMarker3 = _interopRequireDefault(_CircleMarker2);

var _FeatureGroup2 = require('./FeatureGroup');

var _FeatureGroup3 = _interopRequireDefault(_FeatureGroup2);

var _GeoJson2 = require('./GeoJson');

var _GeoJson3 = _interopRequireDefault(_GeoJson2);

var _ImageOverlay2 = require('./ImageOverlay');

var _ImageOverlay3 = _interopRequireDefault(_ImageOverlay2);

var _LayerGroup2 = require('./LayerGroup');

var _LayerGroup3 = _interopRequireDefault(_LayerGroup2);

var _LayersControl2 = require('./LayersControl');

var _LayersControl3 = _interopRequireDefault(_LayersControl2);

var _Map2 = require('./Map');

var _Map3 = _interopRequireDefault(_Map2);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

var _MapControl2 = require('./MapControl');

var _MapControl3 = _interopRequireDefault(_MapControl2);

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

var _Marker2 = require('./Marker');

var _Marker3 = _interopRequireDefault(_Marker2);

var _MultiPolygon2 = require('./MultiPolygon');

var _MultiPolygon3 = _interopRequireDefault(_MultiPolygon2);

var _MultiPolyline2 = require('./MultiPolyline');

var _MultiPolyline3 = _interopRequireDefault(_MultiPolyline2);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var _Polygon2 = require('./Polygon');

var _Polygon3 = _interopRequireDefault(_Polygon2);

var _Polyline2 = require('./Polyline');

var _Polyline3 = _interopRequireDefault(_Polyline2);

var _Popup2 = require('./Popup');

var _Popup3 = _interopRequireDefault(_Popup2);

var _Rectangle2 = require('./Rectangle');

var _Rectangle3 = _interopRequireDefault(_Rectangle2);

var _ScaleControl2 = require('./ScaleControl');

var _ScaleControl3 = _interopRequireDefault(_ScaleControl2);

var _TileLayer2 = require('./TileLayer');

var _TileLayer3 = _interopRequireDefault(_TileLayer2);

var _WMSTileLayer2 = require('./WMSTileLayer');

var _WMSTileLayer3 = _interopRequireDefault(_WMSTileLayer2);

var _ZoomControl2 = require('./ZoomControl');

var _ZoomControl3 = _interopRequireDefault(_ZoomControl2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.PropTypes = _PropTypes;
exports.AttributionControl = _AttributionControl3.default;
exports.BaseTileLayer = _BaseTileLayer3.default;
exports.CanvasTileLayer = _CanvasTileLayer3.default;
exports.Circle = _Circle3.default;
exports.CircleMarker = _CircleMarker3.default;
exports.FeatureGroup = _FeatureGroup3.default;
exports.GeoJson = _GeoJson3.default;
exports.ImageOverlay = _ImageOverlay3.default;
exports.LayerGroup = _LayerGroup3.default;
exports.LayersControl = _LayersControl3.default;
exports.Map = _Map3.default;
exports.MapComponent = _MapComponent3.default;
exports.MapControl = _MapControl3.default;
exports.MapLayer = _MapLayer3.default;
exports.Marker = _Marker3.default;
exports.MultiPolygon = _MultiPolygon3.default;
exports.MultiPolyline = _MultiPolyline3.default;
exports.Path = _Path3.default;
exports.Polygon = _Polygon3.default;
exports.Polyline = _Polyline3.default;
exports.Popup = _Popup3.default;
exports.Rectangle = _Rectangle3.default;
exports.ScaleControl = _ScaleControl3.default;
exports.TileLayer = _TileLayer3.default;
exports.WMSTileLayer = _WMSTileLayer3.default;
exports.ZoomControl = _ZoomControl3.default;
var setIconDefaultImagePath = exports.setIconDefaultImagePath = function setIconDefaultImagePath(path) {
  _leaflet2.default.Icon.Default.imagePath = path;
};

setIconDefaultImagePath('//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images');
},{"./AttributionControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/AttributionControl.js","./BaseTileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/BaseTileLayer.js","./CanvasTileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/CanvasTileLayer.js","./Circle":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Circle.js","./CircleMarker":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/CircleMarker.js","./FeatureGroup":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/FeatureGroup.js","./GeoJson":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/GeoJson.js","./ImageOverlay":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/ImageOverlay.js","./LayerGroup":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/LayerGroup.js","./LayersControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/LayersControl.js","./Map":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Map.js","./MapComponent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapComponent.js","./MapControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapControl.js","./MapLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MapLayer.js","./Marker":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Marker.js","./MultiPolygon":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MultiPolygon.js","./MultiPolyline":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/MultiPolyline.js","./Path":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Path.js","./Polygon":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Polygon.js","./Polyline":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Polyline.js","./Popup":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Popup.js","./Rectangle":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/Rectangle.js","./ScaleControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/ScaleControl.js","./TileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/TileLayer.js","./WMSTileLayer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/WMSTileLayer.js","./ZoomControl":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/ZoomControl.js","./types":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/index.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/bounds.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _leaflet = require('leaflet');

var _latlngList = require('./latlngList');

var _latlngList2 = _interopRequireDefault(_latlngList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _react.PropTypes.oneOfType([_react.PropTypes.instanceOf(_leaflet.LatLngBounds), _latlngList2.default]);
},{"./latlngList":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/children.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

exports.default = _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.node), _react.PropTypes.node]);
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/controlPosition.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

exports.default = _react.PropTypes.oneOf(['topleft', 'topright', 'bottomleft', 'bottomright']);
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layerContainer = exports.latlngList = exports.latlng = exports.controlPosition = exports.children = exports.bounds = undefined;

var _bounds2 = require('./bounds');

var _bounds3 = _interopRequireDefault(_bounds2);

var _children2 = require('./children');

var _children3 = _interopRequireDefault(_children2);

var _controlPosition2 = require('./controlPosition');

var _controlPosition3 = _interopRequireDefault(_controlPosition2);

var _latlng2 = require('./latlng');

var _latlng3 = _interopRequireDefault(_latlng2);

var _latlngList2 = require('./latlngList');

var _latlngList3 = _interopRequireDefault(_latlngList2);

var _layerContainer2 = require('./layerContainer');

var _layerContainer3 = _interopRequireDefault(_layerContainer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.bounds = _bounds3.default;
exports.children = _children3.default;
exports.controlPosition = _controlPosition3.default;
exports.latlng = _latlng3.default;
exports.latlngList = _latlngList3.default;
exports.layerContainer = _layerContainer3.default;
},{"./bounds":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/bounds.js","./children":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/children.js","./controlPosition":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/controlPosition.js","./latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","./latlngList":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js","./layerContainer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/layerContainer.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

exports.default = _react.PropTypes.oneOfType([
// [Number, Number]
_react.PropTypes.arrayOf(_react.PropTypes.number),
// {lat: Number, lng: Number}
_react.PropTypes.shape({
  lat: _react.PropTypes.number,
  lng: _react.PropTypes.number
}),
// {lat: Number, lon: Number}
_react.PropTypes.shape({
  lat: _react.PropTypes.number,
  lon: _react.PropTypes.number
})]);
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlngList.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _latlng = require('./latlng');

var _latlng2 = _interopRequireDefault(_latlng);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _react.PropTypes.arrayOf(_latlng2.default);
},{"./latlng":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/latlng.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/types/layerContainer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

exports.default = _react.PropTypes.shape({
  addLayer: _react.PropTypes.func.isRequired,
  removeLayer: _react.PropTypes.func.isRequired
});
},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_DataView.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js","./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Hash.js":[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashClear.js","./_hashDelete":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashDelete.js","./_hashGet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashGet.js","./_hashHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashHas.js","./_hashSet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashSet.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_ListCache.js":[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheClear.js","./_listCacheDelete":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheDelete.js","./_listCacheGet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheGet.js","./_listCacheHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheHas.js","./_listCacheSet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheSet.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Map.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js","./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_MapCache.js":[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheClear.js","./_mapCacheDelete":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheDelete.js","./_mapCacheGet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheGet.js","./_mapCacheHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheHas.js","./_mapCacheSet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheSet.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Promise.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js","./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Reflect.js":[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Reflect = root.Reflect;

module.exports = Reflect;

},{"./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Set.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js","./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_SetCache.js":[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_MapCache.js","./_setCacheAdd":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setCacheAdd.js","./_setCacheHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setCacheHas.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Stack.js":[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_ListCache.js","./_stackClear":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackClear.js","./_stackDelete":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackDelete.js","./_stackGet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackGet.js","./_stackHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackHas.js","./_stackSet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackSet.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Symbol.js":[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Uint8Array.js":[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_WeakMap.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js","./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_addMapEntry.js":[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `Map#set` because it doesn't return the map instance in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_addSetEntry.js":[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_apply.js":[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayEach.js":[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayIncludes.js":[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to search.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIndexOf.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayIncludesWith.js":[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to search.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayMap.js":[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayPush.js":[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayReduce.js":[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arraySome.js":[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assignValue.js":[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

module.exports = assignValue;

},{"./eq":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/eq.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assocIndexOf.js":[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/eq.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseAssign.js":[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copyObject.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseClone.js":[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    getAllKeys = require('./_getAllKeys'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isHostObject = require('./_isHostObject'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  // Recursively populate clone (susceptible to call stack limits).
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Stack.js","./_arrayEach":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayEach.js","./_assignValue":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assignValue.js","./_baseAssign":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseAssign.js","./_cloneBuffer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneBuffer.js","./_copyArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copyArray.js","./_copySymbols":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copySymbols.js","./_getAllKeys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getAllKeys.js","./_getTag":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getTag.js","./_initCloneArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_initCloneArray.js","./_initCloneByTag":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_initCloneByTag.js","./_initCloneObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_initCloneObject.js","./_isHostObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isHostObject.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./isBuffer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isBuffer.js","./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseCreate.js":[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

module.exports = baseCreate;

},{"./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseDifference.js":[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

},{"./_SetCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_SetCache.js","./_arrayIncludes":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayIncludes.js","./_arrayIncludesWith":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayIncludesWith.js","./_arrayMap":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayMap.js","./_baseUnary":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseUnary.js","./_cacheHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cacheHas.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseEach.js":[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseForOwn.js","./_createBaseEach":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_createBaseEach.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseFlatten.js":[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayPush.js","./_isFlattenable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isFlattenable.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseFor.js":[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_createBaseFor.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseForOwn.js":[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseFor.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseGet.js":[function(require,module,exports){
var castPath = require('./_castPath'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_castPath.js","./_isKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKey.js","./_toKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseGetAllKeys.js":[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayPush.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseHas.js":[function(require,module,exports){
var getPrototype = require('./_getPrototype');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
  // that are composed entirely of index properties, return `false` for
  // `hasOwnProperty` checks of them.
  return object != null &&
    (hasOwnProperty.call(object, key) ||
      (typeof object == 'object' && key in object && getPrototype(object) === null));
}

module.exports = baseHas;

},{"./_getPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getPrototype.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseHasIn.js":[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIndexOf.js":[function(require,module,exports){
var indexOfNaN = require('./_indexOfNaN');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;

},{"./_indexOfNaN":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_indexOfNaN.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsEqual.js":[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObject = require('./isObject'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsEqualDeep.js","./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js","./isObjectLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObjectLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsEqualDeep.js":[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isHostObject = require('./_isHostObject'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Stack.js","./_equalArrays":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalArrays.js","./_equalByTag":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalByTag.js","./_equalObjects":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalObjects.js","./_getTag":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getTag.js","./_isHostObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isHostObject.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./isTypedArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isTypedArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsMatch.js":[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Stack.js","./_baseIsEqual":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsEqual.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsNative.js":[function(require,module,exports){
var isFunction = require('./isFunction'),
    isHostObject = require('./_isHostObject'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isHostObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isHostObject.js","./_isMasked":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isMasked.js","./_toSource":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toSource.js","./isFunction":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isFunction.js","./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIteratee.js":[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseMatches.js","./_baseMatchesProperty":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseMatchesProperty.js","./identity":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/identity.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./property":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/property.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseKeys.js":[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object.keys;

/**
 * The base implementation of `_.keys` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  return nativeKeys(Object(object));
}

module.exports = baseKeys;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseKeysIn.js":[function(require,module,exports){
var Reflect = require('./_Reflect'),
    iteratorToArray = require('./_iteratorToArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var enumerate = Reflect ? Reflect.enumerate : undefined,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * The base implementation of `_.keysIn` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  object = object == null ? object : Object(object);

  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

// Fallback for IE < 9 with es6-shim.
if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
  baseKeysIn = function(object) {
    return iteratorToArray(enumerate(object));
  };
}

module.exports = baseKeysIn;

},{"./_Reflect":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Reflect.js","./_iteratorToArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_iteratorToArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseMatches.js":[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsMatch.js","./_getMatchData":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMatchData.js","./_matchesStrictComparable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_matchesStrictComparable.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseMatchesProperty.js":[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsEqual.js","./_isKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKey.js","./_isStrictComparable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isStrictComparable.js","./_matchesStrictComparable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_matchesStrictComparable.js","./_toKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js","./get":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/get.js","./hasIn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/hasIn.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_basePick.js":[function(require,module,exports){
var arrayReduce = require('./_arrayReduce');

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return arrayReduce(props, function(result, key) {
    if (key in object) {
      result[key] = object[key];
    }
    return result;
  }, {});
}

module.exports = basePick;

},{"./_arrayReduce":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayReduce.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseProperty.js":[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_basePropertyDeep.js":[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseGet.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseReduce.js":[function(require,module,exports){
/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseTimes.js":[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseToString.js":[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Symbol.js","./isSymbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isSymbol.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseUnary.js":[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing wrapper metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cacheHas.js":[function(require,module,exports){
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_castPath.js":[function(require,module,exports){
var isArray = require('./isArray'),
    stringToPath = require('./_stringToPath');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

module.exports = castPath;

},{"./_stringToPath":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stringToPath.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_checkGlobal.js":[function(require,module,exports){
/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = checkGlobal;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneArrayBuffer.js":[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Uint8Array.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneBuffer.js":[function(require,module,exports){
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneDataView.js":[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneArrayBuffer.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneMap.js":[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_addMapEntry.js","./_arrayReduce":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayReduce.js","./_mapToArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapToArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneRegExp.js":[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneSet.js":[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_addSetEntry.js","./_arrayReduce":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayReduce.js","./_setToArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setToArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneSymbol.js":[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Symbol.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneTypedArray.js":[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneArrayBuffer.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copyArray.js":[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copyObject.js":[function(require,module,exports){
var assignValue = require('./_assignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assignValue.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copySymbols.js":[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copyObject.js","./_getSymbols":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getSymbols.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_coreJsData.js":[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_createAssigner.js":[function(require,module,exports){
var isIterateeCall = require('./_isIterateeCall'),
    rest = require('./rest');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return rest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_isIterateeCall":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIterateeCall.js","./rest":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/rest.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_createBaseEach.js":[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_createBaseFor.js":[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalArrays.js":[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_SetCache.js","./_arraySome":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arraySome.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalByTag.js":[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and
      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
      // not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object) ? other != +other : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;
      stack.set(object, other);

      // Recursively compare objects (susceptible to call stack limits).
      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Symbol.js","./_Uint8Array":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Uint8Array.js","./_equalArrays":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalArrays.js","./_mapToArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapToArray.js","./_setToArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setToArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_equalObjects.js":[function(require,module,exports){
var baseHas = require('./_baseHas'),
    keys = require('./keys');

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : baseHas(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  return result;
}

module.exports = equalObjects;

},{"./_baseHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseHas.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getAllKeys.js":[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseGetAllKeys.js","./_getSymbols":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getSymbols.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getAllKeysIn.js":[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseGetAllKeys.js","./_getSymbolsIn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getSymbolsIn.js","./keysIn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keysIn.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getLength.js":[function(require,module,exports){
var baseProperty = require('./_baseProperty');

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

module.exports = getLength;

},{"./_baseProperty":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseProperty.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMapData.js":[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKeyable.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMatchData.js":[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isStrictComparable.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js":[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsNative.js","./_getValue":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getValue.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getPrototype.js":[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetPrototype = Object.getPrototypeOf;

/**
 * Gets the `[[Prototype]]` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {null|Object} Returns the `[[Prototype]]`.
 */
function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

module.exports = getPrototype;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getSymbols.js":[function(require,module,exports){
var stubArray = require('./stubArray');

/** Built-in value references. */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbols(object) {
  // Coerce `object` to an object to avoid non-object errors in V8.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
  return getOwnPropertySymbols(Object(object));
}

// Fallback for IE < 11.
if (!getOwnPropertySymbols) {
  getSymbols = stubArray;
}

module.exports = getSymbols;

},{"./stubArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/stubArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getSymbolsIn.js":[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols');

/** Built-in value references. */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayPush.js","./_getPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getPrototype.js","./_getSymbols":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getSymbols.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getTag.js":[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
  return objectToString.call(value);
}

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_DataView.js","./_Map":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Map.js","./_Promise":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Promise.js","./_Set":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Set.js","./_WeakMap":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_WeakMap.js","./_toSource":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toSource.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getValue.js":[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hasPath.js":[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isKey = require('./_isKey'),
    isLength = require('./isLength'),
    isString = require('./isString'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isString(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_castPath.js","./_isIndex":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIndex.js","./_isKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKey.js","./_toKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js","./isArguments":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArguments.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./isLength":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isLength.js","./isString":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isString.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashClear.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

module.exports = hashClear;

},{"./_nativeCreate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_nativeCreate.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashDelete.js":[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

module.exports = hashDelete;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashGet.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_nativeCreate.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashHas.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_nativeCreate.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hashSet.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_nativeCreate.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_indexKeys.js":[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isLength = require('./isLength'),
    isString = require('./isString');

/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (isLength(length) &&
      (isArray(object) || isString(object) || isArguments(object))) {
    return baseTimes(length, String);
  }
  return null;
}

module.exports = indexKeys;

},{"./_baseTimes":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseTimes.js","./isArguments":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArguments.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./isLength":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isLength.js","./isString":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isString.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_indexOfNaN.js":[function(require,module,exports){
/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = indexOfNaN;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_initCloneArray.js":[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_initCloneByTag.js":[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneArrayBuffer.js","./_cloneDataView":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneDataView.js","./_cloneMap":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneMap.js","./_cloneRegExp":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneRegExp.js","./_cloneSet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneSet.js","./_cloneSymbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneSymbol.js","./_cloneTypedArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_cloneTypedArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_initCloneObject.js":[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseCreate.js","./_getPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getPrototype.js","./_isPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isPrototype.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isFlattenable.js":[function(require,module,exports){
var isArguments = require('./isArguments'),
    isArray = require('./isArray');

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value);
}

module.exports = isFlattenable;

},{"./isArguments":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArguments.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isHostObject.js":[function(require,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIndex.js":[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIterateeCall.js":[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIndex.js","./eq":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/eq.js","./isArrayLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLike.js","./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKey.js":[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./isSymbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isSymbol.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKeyable.js":[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isMasked.js":[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_coreJsData.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isPrototype.js":[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isStrictComparable.js":[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_iteratorToArray.js":[function(require,module,exports){
/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheClear.js":[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

module.exports = listCacheClear;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheDelete.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assocIndexOf.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheGet.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assocIndexOf.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheHas.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assocIndexOf.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_listCacheSet.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assocIndexOf.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheClear.js":[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Hash.js","./_ListCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_ListCache.js","./_Map":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_Map.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheDelete.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

module.exports = mapCacheDelete;

},{"./_getMapData":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMapData.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheGet.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMapData.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheHas.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMapData.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapCacheSet.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getMapData.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_mapToArray.js":[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_matchesStrictComparable.js":[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_nativeCreate.js":[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getNative.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js":[function(require,module,exports){
(function (global){
var checkGlobal = require('./_checkGlobal');

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(typeof self == 'object' && self);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(typeof this == 'object' && this);

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();

module.exports = root;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_checkGlobal":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_checkGlobal.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setCacheAdd.js":[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setCacheHas.js":[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_setToArray.js":[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackClear.js":[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

module.exports = stackClear;

},{"./_ListCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_ListCache.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackDelete.js":[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

module.exports = stackDelete;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackGet.js":[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackHas.js":[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stackSet.js":[function(require,module,exports){
var ListCache = require('./_ListCache'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
    cache = this.__data__ = new MapCache(cache.__data__);
  }
  cache.set(key, value);
  return this;
}

module.exports = stackSet;

},{"./_ListCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_ListCache.js","./_MapCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_MapCache.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_stringToPath.js":[function(require,module,exports){
var memoize = require('./memoize'),
    toString = require('./toString');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  var result = [];
  toString(string).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./memoize":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/memoize.js","./toString":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toString.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js":[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isSymbol.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toSource.js":[function(require,module,exports){
/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/assign.js":[function(require,module,exports){
var assignValue = require('./_assignValue'),
    copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    isArrayLike = require('./isArrayLike'),
    isPrototype = require('./_isPrototype'),
    keys = require('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.c = 3;
 * }
 *
 * function Bar() {
 *   this.e = 5;
 * }
 *
 * Foo.prototype.d = 4;
 * Bar.prototype.f = 6;
 *
 * _.assign({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3, 'e': 5 }
 */
var assign = createAssigner(function(object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_assignValue.js","./_copyObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_copyObject.js","./_createAssigner":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_createAssigner.js","./_isPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isPrototype.js","./isArrayLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLike.js","./keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/clone.js":[function(require,module,exports){
var baseClone = require('./_baseClone');

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, false, true);
}

module.exports = clone;

},{"./_baseClone":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseClone.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/eq.js":[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/forEach.js":[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _([1, 2]).forEach(function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = forEach;

},{"./_arrayEach":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayEach.js","./_baseEach":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseEach.js","./_baseIteratee":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIteratee.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/get.js":[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is used in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseGet.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/hasIn.js":[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseHasIn.js","./_hasPath":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_hasPath.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/identity.js":[function(require,module,exports){
/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArguments.js":[function(require,module,exports){
var isArrayLikeObject = require('./isArrayLikeObject');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

module.exports = isArguments;

},{"./isArrayLikeObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLikeObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js":[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLike.js":[function(require,module,exports){
var getLength = require('./_getLength'),
    isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./_getLength":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getLength.js","./isFunction":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isFunction.js","./isLength":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isLength.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLikeObject.js":[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLike.js","./isObjectLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObjectLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isBuffer.js":[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = !Buffer ? stubFalse : function(value) {
  return value instanceof Buffer;
};

module.exports = isBuffer;

},{"./_root":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_root.js","./stubFalse":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/stubFalse.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isEqual.js":[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent,
 *  else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIsEqual.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isFunction.js":[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;

},{"./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isLength.js":[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js":[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObjectLike.js":[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isString.js":[function(require,module,exports){
var isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;

},{"./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js","./isObjectLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObjectLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isSymbol.js":[function(require,module,exports){
var isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;

},{"./isObjectLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObjectLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isTypedArray.js":[function(require,module,exports){
var isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

module.exports = isTypedArray;

},{"./isLength":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isLength.js","./isObjectLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObjectLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isUndefined.js":[function(require,module,exports){
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keys.js":[function(require,module,exports){
var baseHas = require('./_baseHas'),
    baseKeys = require('./_baseKeys'),
    indexKeys = require('./_indexKeys'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isPrototype = require('./_isPrototype');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  var isProto = isPrototype(object);
  if (!(isProto || isArrayLike(object))) {
    return baseKeys(object);
  }
  var indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (baseHas(object, key) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"./_baseHas":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseHas.js","./_baseKeys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseKeys.js","./_indexKeys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_indexKeys.js","./_isIndex":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIndex.js","./_isPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isPrototype.js","./isArrayLike":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArrayLike.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/keysIn.js":[function(require,module,exports){
var baseKeysIn = require('./_baseKeysIn'),
    indexKeys = require('./_indexKeys'),
    isIndex = require('./_isIndex'),
    isPrototype = require('./_isPrototype');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  var index = -1,
      isProto = isPrototype(object),
      props = baseKeysIn(object),
      propsLength = props.length,
      indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  while (++index < propsLength) {
    var key = props[index];
    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"./_baseKeysIn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseKeysIn.js","./_indexKeys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_indexKeys.js","./_isIndex":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isIndex.js","./_isPrototype":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isPrototype.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/memoize.js":[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_MapCache.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/omit.js":[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    basePick = require('./_basePick'),
    getAllKeysIn = require('./_getAllKeysIn'),
    rest = require('./rest'),
    toKey = require('./_toKey');

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = rest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

module.exports = omit;

},{"./_arrayMap":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayMap.js","./_baseDifference":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseDifference.js","./_baseFlatten":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseFlatten.js","./_basePick":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_basePick.js","./_getAllKeysIn":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_getAllKeysIn.js","./_toKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js","./rest":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/rest.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/pick.js":[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseFlatten = require('./_baseFlatten'),
    basePick = require('./_basePick'),
    rest = require('./rest'),
    toKey = require('./_toKey');

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = rest(function(object, props) {
  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
});

module.exports = pick;

},{"./_arrayMap":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayMap.js","./_baseFlatten":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseFlatten.js","./_basePick":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_basePick.js","./_toKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js","./rest":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/rest.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/property.js":[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseProperty.js","./_basePropertyDeep":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_basePropertyDeep.js","./_isKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_isKey.js","./_toKey":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_toKey.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/reduce.js":[function(require,module,exports){
var arrayReduce = require('./_arrayReduce'),
    baseEach = require('./_baseEach'),
    baseIteratee = require('./_baseIteratee'),
    baseReduce = require('./_baseReduce'),
    isArray = require('./isArray');

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

},{"./_arrayReduce":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_arrayReduce.js","./_baseEach":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseEach.js","./_baseIteratee":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseIteratee.js","./_baseReduce":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseReduce.js","./isArray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isArray.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/rest.js":[function(require,module,exports){
var apply = require('./_apply'),
    toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

module.exports = rest;

},{"./_apply":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_apply.js","./toInteger":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toInteger.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/stubArray.js":[function(require,module,exports){
/**
 * A method that returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/stubFalse.js":[function(require,module,exports){
/**
 * A method that returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toFinite.js":[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toNumber.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toInteger.js":[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toFinite.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toNumber.js":[function(require,module,exports){
var isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isFunction":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isFunction.js","./isObject":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isObject.js","./isSymbol":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/isSymbol.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toString.js":[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/_baseToString.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/uniqueId.js":[function(require,module,exports){
var toString = require('./toString');

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;

},{"./toString":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/lodash/toString.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/node_modules/warning/browser.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/components/Modal.js":[function(require,module,exports){
(function (process){
var React = require('react');
var ReactDOM = require('react-dom');
var ExecutionEnvironment = require('exenv');
var ModalPortal = React.createFactory(require('./ModalPortal'));
var ariaAppHider = require('../helpers/ariaAppHider');
var elementClass = require('element-class');
var renderSubtreeIntoContainer = require("react-dom").unstable_renderSubtreeIntoContainer;

var SafeHTMLElement = ExecutionEnvironment.canUseDOM ? window.HTMLElement : {};

var Modal = module.exports = React.createClass({

  displayName: 'Modal',
  statics: {
    setAppElement: ariaAppHider.setElement,
    injectCSS: function() {
      "production" !== process.env.NODE_ENV
        && console.warn('React-Modal: injectCSS has been deprecated ' +
                        'and no longer has any effect. It will be removed in a later version');
    }
  },

  propTypes: {
    isOpen: React.PropTypes.bool.isRequired,
    style: React.PropTypes.shape({
      content: React.PropTypes.object,
      overlay: React.PropTypes.object
    }),
    appElement: React.PropTypes.instanceOf(SafeHTMLElement),
    onRequestClose: React.PropTypes.func,
    closeTimeoutMS: React.PropTypes.number,
    ariaHideApp: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      isOpen: false,
      ariaHideApp: true,
      closeTimeoutMS: 0
    };
  },

  componentDidMount: function() {
    this.node = document.createElement('div');
    this.node.className = 'ReactModalPortal';
    document.body.appendChild(this.node);
    this.renderPortal(this.props);
  },

  componentWillReceiveProps: function(newProps) {
    this.renderPortal(newProps);
  },

  componentWillUnmount: function() {
    ReactDOM.unmountComponentAtNode(this.node);
    document.body.removeChild(this.node);
  },

  renderPortal: function(props) {
    if (props.isOpen) {
      elementClass(document.body).add('ReactModal__Body--open');
    } else {
      elementClass(document.body).remove('ReactModal__Body--open');
    }

    if (props.ariaHideApp) {
      ariaAppHider.toggle(props.isOpen, props.appElement);
    }
    sanitizeProps(props);
    this.portal = renderSubtreeIntoContainer(this, ModalPortal(props), this.node);
  },

  render: function () {
    return React.DOM.noscript();
  }
});

function sanitizeProps(props) {
  delete props.ref;
}

}).call(this,require('_process'))

},{"../helpers/ariaAppHider":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/ariaAppHider.js","./ModalPortal":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/components/ModalPortal.js","_process":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/process/browser.js","element-class":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/element-class/index.js","exenv":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/exenv/index.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/components/ModalPortal.js":[function(require,module,exports){
var React = require('react');
var div = React.DOM.div;
var focusManager = require('../helpers/focusManager');
var scopeTab = require('../helpers/scopeTab');
var Assign = require('lodash.assign');


// so that our CSS is statically analyzable
var CLASS_NAMES = {
  overlay: {
    base: 'ReactModal__Overlay',
    afterOpen: 'ReactModal__Overlay--after-open',
    beforeClose: 'ReactModal__Overlay--before-close'
  },
  content: {
    base: 'ReactModal__Content',
    afterOpen: 'ReactModal__Content--after-open',
    beforeClose: 'ReactModal__Content--before-close'
  }
};

var defaultStyles = {
  overlay: {
    position        : 'fixed',
    top             : 0,
    left            : 0,
    right           : 0,
    bottom          : 0,
    backgroundColor : 'rgba(255, 255, 255, 0.75)'
  },
  content: {
    position                : 'absolute',
    top                     : '40px',
    left                    : '40px',
    right                   : '40px',
    bottom                  : '40px',
    border                  : '1px solid #ccc',
    background              : '#fff',
    overflow                : 'auto',
    WebkitOverflowScrolling : 'touch',
    borderRadius            : '4px',
    outline                 : 'none',
    padding                 : '20px'
  }
};

function stopPropagation(event) {
  event.stopPropagation();
}

var ModalPortal = module.exports = React.createClass({

  displayName: 'ModalPortal',

  getDefaultProps: function() {
    return {
      style: {
        overlay: {},
        content: {}
      }
    };
  },

  getInitialState: function() {
    return {
      afterOpen: false,
      beforeClose: false
    };
  },

  componentDidMount: function() {
    // Focus needs to be set when mounting and already open
    if (this.props.isOpen) {
      this.setFocusAfterRender(true);
      this.open();
    }
  },

  componentWillUnmount: function() {
    clearTimeout(this.closeTimer);
  },

  componentWillReceiveProps: function(newProps) {
    // Focus only needs to be set once when the modal is being opened
    if (!this.props.isOpen && newProps.isOpen) {
      this.setFocusAfterRender(true);
      this.open();
    } else if (this.props.isOpen && !newProps.isOpen) {
      this.close();
    }
  },

  componentDidUpdate: function () {
    if (this.focusAfterRender) {
      this.focusContent();
      this.setFocusAfterRender(false);
    }
  },

  setFocusAfterRender: function (focus) {
    this.focusAfterRender = focus;
  },

  open: function() {
    focusManager.setupScopedFocus(this.node);
    focusManager.markForFocusLater();
    this.setState({isOpen: true}, function() {
      this.setState({afterOpen: true});
    }.bind(this));
  },

  close: function() {
    if (!this.ownerHandlesClose())
      return;
    if (this.props.closeTimeoutMS > 0)
      this.closeWithTimeout();
    else
      this.closeWithoutTimeout();
  },

  focusContent: function() {
    this.refs.content.focus();
  },

  closeWithTimeout: function() {
    this.setState({beforeClose: true}, function() {
      this.closeTimer = setTimeout(this.closeWithoutTimeout, this.props.closeTimeoutMS);
    }.bind(this));
  },

  closeWithoutTimeout: function() {
    this.setState({
      afterOpen: false,
      beforeClose: false
    }, this.afterClose);
  },

  afterClose: function() {
    focusManager.returnFocus();
    focusManager.teardownScopedFocus();
  },

  handleKeyDown: function(event) {
    if (event.keyCode == 9 /*tab*/) scopeTab(this.refs.content, event);
    if (event.keyCode == 27 /*esc*/) this.requestClose();
  },

  handleOverlayClick: function() {
    if (this.ownerHandlesClose())
      this.requestClose();
    else
      this.focusContent();
  },

  requestClose: function() {
    if (this.ownerHandlesClose())
      this.props.onRequestClose();
  },

  ownerHandlesClose: function() {
    return this.props.onRequestClose;
  },

  shouldBeClosed: function() {
    return !this.props.isOpen && !this.state.beforeClose;
  },

  buildClassName: function(which, additional) {
    var className = CLASS_NAMES[which].base;
    if (this.state.afterOpen)
      className += ' '+CLASS_NAMES[which].afterOpen;
    if (this.state.beforeClose)
      className += ' '+CLASS_NAMES[which].beforeClose;
    return additional ? className + ' ' + additional : className;
  },

  render: function() {
    return this.shouldBeClosed() ? div() : (
      div({
        ref: "overlay",
        className: this.buildClassName('overlay', this.props.overlayClassName),
        style: Assign({}, defaultStyles.overlay, this.props.style.overlay || {}),
        onClick: this.handleOverlayClick
      },
        div({
          ref: "content",
          style: Assign({}, defaultStyles.content, this.props.style.content || {}),
          className: this.buildClassName('content', this.props.className),
          tabIndex: "-1",
          onClick: stopPropagation,
          onKeyDown: this.handleKeyDown
        },
          this.props.children
        )
      )
    );
  }
});

},{"../helpers/focusManager":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/focusManager.js","../helpers/scopeTab":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/scopeTab.js","lodash.assign":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/ariaAppHider.js":[function(require,module,exports){
var _element = typeof document !== 'undefined' ? document.body : null;

function setElement(element) {
  if (typeof element === 'string') {
    var el = document.querySelectorAll(element);
    element = 'length' in el ? el[0] : el;
  }
  _element = element || _element;
}

function hide(appElement) {
  validateElement(appElement);
  (appElement || _element).setAttribute('aria-hidden', 'true');
}

function show(appElement) {
  validateElement(appElement);
  (appElement || _element).removeAttribute('aria-hidden');
}

function toggle(shouldHide, appElement) {
  if (shouldHide)
    hide(appElement);
  else
    show(appElement);
}

function validateElement(appElement) {
  if (!appElement && !_element)
    throw new Error('react-modal: You must set an element with `Modal.setAppElement(el)` to make this accessible');
}

function resetForTesting() {
  _element = document.body;
}

exports.toggle = toggle;
exports.setElement = setElement;
exports.show = show;
exports.hide = hide;
exports.resetForTesting = resetForTesting;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/focusManager.js":[function(require,module,exports){
var findTabbable = require('../helpers/tabbable');
var modalElement = null;
var focusLaterElement = null;
var needToFocus = false;

function handleBlur(event) {
  needToFocus = true;
}

function handleFocus(event) {
  if (needToFocus) {
    needToFocus = false;
    if (!modalElement) {
      return;
    }
    // need to see how jQuery shims document.on('focusin') so we don't need the
    // setTimeout, firefox doesn't support focusin, if it did, we could focus
    // the element outside of a setTimeout. Side-effect of this implementation 
    // is that the document.body gets focus, and then we focus our element right 
    // after, seems fine.
    setTimeout(function() {
      if (modalElement.contains(document.activeElement))
        return;
      var el = (findTabbable(modalElement)[0] || modalElement);
      el.focus();
    }, 0);
  }
}

exports.markForFocusLater = function() {
  focusLaterElement = document.activeElement;
};

exports.returnFocus = function() {
  try {
    focusLaterElement.focus();
  }
  catch (e) {
    console.warn('You tried to return focus to '+focusLaterElement+' but it is not in the DOM anymore');
  }
  focusLaterElement = null;
};

exports.setupScopedFocus = function(element) {
  modalElement = element;

  if (window.addEventListener) {
    window.addEventListener('blur', handleBlur, false);
    document.addEventListener('focus', handleFocus, true);
  } else {
    window.attachEvent('onBlur', handleBlur);
    document.attachEvent('onFocus', handleFocus);
  }
};

exports.teardownScopedFocus = function() {
  modalElement = null;

  if (window.addEventListener) {
    window.removeEventListener('blur', handleBlur);
    document.removeEventListener('focus', handleFocus);
  } else {
    window.detachEvent('onBlur', handleBlur);
    document.detachEvent('onFocus', handleFocus);
  }
};



},{"../helpers/tabbable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/tabbable.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/scopeTab.js":[function(require,module,exports){
var findTabbable = require('../helpers/tabbable');

module.exports = function(node, event) {
  var tabbable = findTabbable(node);
  var finalTabbable = tabbable[event.shiftKey ? 0 : tabbable.length - 1];
  var leavingFinalTabbable = (
    finalTabbable === document.activeElement ||
    // handle immediate shift+tab after opening with mouse
    node === document.activeElement
  );
  if (!leavingFinalTabbable) return;
  event.preventDefault();
  var target = tabbable[event.shiftKey ? tabbable.length - 1 : 0];
  target.focus();
};

},{"../helpers/tabbable":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/tabbable.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/helpers/tabbable.js":[function(require,module,exports){
/*!
 * Adapted from jQuery UI core
 *
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */

function focusable(element, isTabIndexNotNaN) {
  var nodeName = element.nodeName.toLowerCase();
  return (/input|select|textarea|button|object/.test(nodeName) ?
    !element.disabled :
    "a" === nodeName ?
      element.href || isTabIndexNotNaN :
      isTabIndexNotNaN) && visible(element);
}

function hidden(el) {
  return (el.offsetWidth <= 0 && el.offsetHeight <= 0) ||
    el.style.display === 'none';
}

function visible(element) {
  while (element) {
    if (element === document.body) break;
    if (hidden(element)) return false;
    element = element.parentNode;
  }
  return true;
}

function tabbable(element) {
  var tabIndex = element.getAttribute('tabindex');
  if (tabIndex === null) tabIndex = undefined;
  var isTabIndexNaN = isNaN(tabIndex);
  return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
}

function findTabbableDescendants(element) {
  return [].slice.call(element.querySelectorAll('*'), 0).filter(function(el) {
    return tabbable(el);
  });
}

module.exports = findTabbableDescendants;


},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/index.js":[function(require,module,exports){
module.exports = require('./components/Modal');


},{"./components/Modal":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/components/Modal.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/element-class/index.js":[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function indexOf(arr, prop) {
  if (arr.indexOf) return arr.indexOf(prop)
  for (var i = 0, len = arr.length; i < len; i++)
    if (arr[i] === prop) return i
  return -1
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (indexOf(classes, className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = indexOf(classes, className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return indexOf(classes, className) > -1
}

ElementClass.prototype.toggle = function(className) {
  var el = this.el
  if (!el) return
  if (this.has(className)) this.remove(className)
  else this.add(className)
}

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/exenv/index.js":[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/

(function () {
	'use strict';

	var canUseDOM = !!(
		typeof window !== 'undefined' &&
		window.document &&
		window.document.createElement
	);

	var ExecutionEnvironment = {

		canUseDOM: canUseDOM,

		canUseWorkers: typeof Worker !== 'undefined',

		canUseEventListeners:
			canUseDOM && !!(window.addEventListener || window.attachEvent),

		canUseViewport: canUseDOM && !!window.screen

	};

	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		define(function () {
			return ExecutionEnvironment;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = ExecutionEnvironment;
	} else {
		window.ExecutionEnvironment = ExecutionEnvironment;
	}

}());

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/index.js":[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    createAssigner = require('lodash._createassigner'),
    keys = require('lodash.keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"lodash._baseassign":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/index.js","lodash._createassigner":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/index.js","lodash.keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/index.js":[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = require('lodash._basecopy'),
    keys = require('lodash.keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"lodash._basecopy":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/node_modules/lodash._basecopy/index.js","lodash.keys":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/node_modules/lodash._basecopy/index.js":[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/index.js":[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var bindCallback = require('lodash._bindcallback'),
    isIterateeCall = require('lodash._isiterateecall'),
    restParam = require('lodash.restparam');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"lodash._bindcallback":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._bindcallback/index.js","lodash._isiterateecall":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._isiterateecall/index.js","lodash.restparam":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash.restparam/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._bindcallback/index.js":[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._isiterateecall/index.js":[function(require,module,exports){
/**
 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isIterateeCall;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash.restparam/index.js":[function(require,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/index.js":[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash._getnative/index.js","lodash.isarguments":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js","lodash.isarray":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarray/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash._getnative/index.js":[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js":[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarray/index.js":[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/accessor.js":[function(require,module,exports){
var Accessor = {
  IDENTITY_FN: function (input) {
    return input;
  },

  generateAccessor: function (field) {
    return function (object) {
      return object[field];
    };
  },

  generateOptionToStringFor: function (prop) {
    if (typeof prop === 'string') {
      return this.generateAccessor(prop);
    } else if (typeof prop === 'function') {
      return prop;
    } else {
      return this.IDENTITY_FN;
    }
  },

  valueForOption: function (option, object) {
    if (typeof option === 'string') {
      return object[option];
    } else if (typeof option === 'function') {
      return option(object);
    } else {
      return object;
    }
  }
};

module.exports = Accessor;
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/keyevent.js":[function(require,module,exports){
/**
 * PolyFills make me sad
 */
var KeyEvent = KeyEvent || {};
KeyEvent.DOM_VK_UP = KeyEvent.DOM_VK_UP || 38;
KeyEvent.DOM_VK_DOWN = KeyEvent.DOM_VK_DOWN || 40;
KeyEvent.DOM_VK_BACK_SPACE = KeyEvent.DOM_VK_BACK_SPACE || 8;
KeyEvent.DOM_VK_RETURN = KeyEvent.DOM_VK_RETURN || 13;
KeyEvent.DOM_VK_ENTER = KeyEvent.DOM_VK_ENTER || 14;
KeyEvent.DOM_VK_ESCAPE = KeyEvent.DOM_VK_ESCAPE || 27;
KeyEvent.DOM_VK_TAB = KeyEvent.DOM_VK_TAB || 9;

module.exports = KeyEvent;
},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/react-typeahead.js":[function(require,module,exports){
var Typeahead = require('./typeahead');
var Tokenizer = require('./tokenizer');

module.exports = {
  Typeahead: Typeahead,
  Tokenizer: Tokenizer
};
},{"./tokenizer":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/tokenizer/index.js","./typeahead":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/tokenizer/index.js":[function(require,module,exports){
var Accessor = require('../accessor');
var React = require('react');
var Token = require('./token');
var KeyEvent = require('../keyevent');
var Typeahead = require('../typeahead');
var classNames = require('classnames');

function _arraysAreDifferent(array1, array2) {
  if (array1.length != array2.length) {
    return true;
  }
  for (var i = array2.length - 1; i >= 0; i--) {
    if (array2[i] !== array1[i]) {
      return true;
    }
  }
}

/**
 * A typeahead that, when an option is selected, instead of simply filling
 * the text entry widget, prepends a renderable "token", that may be deleted
 * by pressing backspace on the beginning of the line with the keyboard.
 */
var TypeaheadTokenizer = React.createClass({
  displayName: 'TypeaheadTokenizer',

  propTypes: {
    name: React.PropTypes.string,
    options: React.PropTypes.array,
    customClasses: React.PropTypes.object,
    allowCustomValues: React.PropTypes.number,
    defaultSelected: React.PropTypes.array,
    defaultValue: React.PropTypes.string,
    placeholder: React.PropTypes.string,
    disabled: React.PropTypes.bool,
    inputProps: React.PropTypes.object,
    onTokenRemove: React.PropTypes.func,
    onKeyDown: React.PropTypes.func,
    onKeyPress: React.PropTypes.func,
    onKeyUp: React.PropTypes.func,
    onTokenAdd: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    filterOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    displayOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    formInputOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    maxVisible: React.PropTypes.number,
    defaultClassNames: React.PropTypes.bool
  },

  getInitialState: function () {
    return {
      // We need to copy this to avoid incorrect sharing
      // of state across instances (e.g., via getDefaultProps())
      selected: this.props.defaultSelected.slice(0)
    };
  },

  getDefaultProps: function () {
    return {
      options: [],
      defaultSelected: [],
      customClasses: {},
      allowCustomValues: 0,
      defaultValue: "",
      placeholder: "",
      disabled: false,
      inputProps: {},
      defaultClassNames: true,
      filterOption: null,
      displayOption: function (token) {
        return token;
      },
      formInputOption: null,
      onKeyDown: function (event) {},
      onKeyPress: function (event) {},
      onKeyUp: function (event) {},
      onFocus: function (event) {},
      onBlur: function (event) {},
      onTokenAdd: function () {},
      onTokenRemove: function () {}
    };
  },

  componentWillReceiveProps: function (nextProps) {
    // if we get new defaultProps, update selected
    if (_arraysAreDifferent(this.props.defaultSelected, nextProps.defaultSelected)) {
      this.setState({ selected: nextProps.defaultSelected.slice(0) });
    }
  },

  focus: function () {
    this.refs.typeahead.focus();
  },

  getSelectedTokens: function () {
    return this.state.selected;
  },

  // TODO: Support initialized tokens
  //
  _renderTokens: function () {
    var tokenClasses = {};
    tokenClasses[this.props.customClasses.token] = !!this.props.customClasses.token;
    var classList = classNames(tokenClasses);
    var result = this.state.selected.map(function (selected) {
      var displayString = Accessor.valueForOption(this.props.displayOption, selected);
      var value = Accessor.valueForOption(this.props.formInputOption || this.props.displayOption, selected);
      return React.createElement(
        Token,
        { key: displayString, className: classList,
          onRemove: this._removeTokenForValue,
          object: selected,
          value: value,
          name: this.props.name },
        displayString
      );
    }, this);
    return result;
  },

  _getOptionsForTypeahead: function () {
    // return this.props.options without this.selected
    return this.props.options;
  },

  _onKeyDown: function (event) {
    // We only care about intercepting backspaces
    if (event.keyCode === KeyEvent.DOM_VK_BACK_SPACE) {
      return this._handleBackspace(event);
    }
    this.props.onKeyDown(event);
  },

  _handleBackspace: function (event) {
    // No tokens
    if (!this.state.selected.length) {
      return;
    }

    // Remove token ONLY when bksp pressed at beginning of line
    // without a selection
    var entry = this.refs.typeahead.refs.entry;
    if (entry.selectionStart == entry.selectionEnd && entry.selectionStart == 0) {
      this._removeTokenForValue(this.state.selected[this.state.selected.length - 1]);
      event.preventDefault();
    }
  },

  _removeTokenForValue: function (value) {
    var index = this.state.selected.indexOf(value);
    if (index == -1) {
      return;
    }

    this.state.selected.splice(index, 1);
    this.setState({ selected: this.state.selected });
    this.props.onTokenRemove(value);
    return;
  },

  _addTokenForValue: function (value) {
    if (this.state.selected.indexOf(value) != -1) {
      return;
    }
    this.state.selected.push(value);
    this.setState({ selected: this.state.selected });
    this.refs.typeahead.setEntryText("");
    this.props.onTokenAdd(value);
  },

  render: function () {
    var classes = {};
    classes[this.props.customClasses.typeahead] = !!this.props.customClasses.typeahead;
    var classList = classNames(classes);
    var tokenizerClasses = [this.props.defaultClassNames && "typeahead-tokenizer"];
    tokenizerClasses[this.props.className] = !!this.props.className;
    var tokenizerClassList = classNames(tokenizerClasses);

    return React.createElement(
      'div',
      { className: tokenizerClassList },
      this._renderTokens(),
      React.createElement(Typeahead, { ref: 'typeahead',
        className: classList,
        placeholder: this.props.placeholder,
        disabled: this.props.disabled,
        inputProps: this.props.inputProps,
        allowCustomValues: this.props.allowCustomValues,
        customClasses: this.props.customClasses,
        options: this._getOptionsForTypeahead(),
        defaultValue: this.props.defaultValue,
        maxVisible: this.props.maxVisible,
        onOptionSelected: this._addTokenForValue,
        onKeyDown: this._onKeyDown,
        onKeyPress: this.props.onKeyPress,
        onKeyUp: this.props.onKeyUp,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur,
        displayOption: this.props.displayOption,
        defaultClassNames: this.props.defaultClassNames,
        filterOption: this.props.filterOption })
    );
  }
});

module.exports = TypeaheadTokenizer;
},{"../accessor":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/accessor.js","../keyevent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/keyevent.js","../typeahead":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/index.js","./token":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/tokenizer/token.js","classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/tokenizer/token.js":[function(require,module,exports){
var React = require('react');
var classNames = require('classnames');

/**
 * Encapsulates the rendering of an option that has been "selected" in a
 * TypeaheadTokenizer
 */
var Token = React.createClass({
  displayName: 'Token',

  propTypes: {
    className: React.PropTypes.string,
    name: React.PropTypes.string,
    children: React.PropTypes.string,
    object: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object]),
    onRemove: React.PropTypes.func,
    value: React.PropTypes.string
  },

  render: function () {
    var className = classNames(["typeahead-token", this.props.className]);

    return React.createElement(
      'div',
      { className: className },
      this._renderHiddenInput(),
      this.props.children,
      this._renderCloseButton()
    );
  },

  _renderHiddenInput: function () {
    // If no name was set, don't create a hidden input
    if (!this.props.name) {
      return null;
    }

    return React.createElement('input', {
      type: 'hidden',
      name: this.props.name + '[]',
      value: this.props.value || this.props.object
    });
  },

  _renderCloseButton: function () {
    if (!this.props.onRemove) {
      return "";
    }
    return React.createElement(
      'a',
      { className: 'typeahead-token-close', href: '#', onClick: function (event) {
          this.props.onRemove(this.props.object);
          event.preventDefault();
        }.bind(this) },
      '×'
    );
  }
});

module.exports = Token;
},{"classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/index.js":[function(require,module,exports){
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Accessor = require('../accessor');
var React = require('react');
var TypeaheadSelector = require('./selector');
var KeyEvent = require('../keyevent');
var fuzzy = require('fuzzy');
var classNames = require('classnames');

/**
 * A "typeahead", an auto-completing text input
 *
 * Renders an text input that shows options nearby that you can use the
 * keyboard or mouse to select.  Requires CSS for MASSIVE DAMAGE.
 */
var Typeahead = React.createClass({
  displayName: 'Typeahead',

  propTypes: {
    name: React.PropTypes.string,
    customClasses: React.PropTypes.object,
    maxVisible: React.PropTypes.number,
    options: React.PropTypes.array,
    allowCustomValues: React.PropTypes.number,
    defaultValue: React.PropTypes.string,
    value: React.PropTypes.string,
    placeholder: React.PropTypes.string,
    disabled: React.PropTypes.bool,
    textarea: React.PropTypes.bool,
    inputProps: React.PropTypes.object,
    onOptionSelected: React.PropTypes.func,
    onChange: React.PropTypes.func,
    onKeyDown: React.PropTypes.func,
    onKeyPress: React.PropTypes.func,
    onKeyUp: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    filterOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    displayOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    formInputOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    defaultClassNames: React.PropTypes.bool,
    customListComponent: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.func]),
    showOptionsWhenEmpty: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      options: [],
      customClasses: {},
      allowCustomValues: 0,
      defaultValue: "",
      value: null,
      placeholder: "",
      disabled: false,
      textarea: false,
      inputProps: {},
      onOptionSelected: function (option) {},
      onChange: function (event) {},
      onKeyDown: function (event) {},
      onKeyPress: function (event) {},
      onKeyUp: function (event) {},
      onFocus: function (event) {},
      onBlur: function (event) {},
      filterOption: null,
      defaultClassNames: true,
      customListComponent: TypeaheadSelector,
      showOptionsWhenEmpty: false
    };
  },

  getInitialState: function () {
    return {
      // The currently visible set of options
      visible: this.getOptionsForValue(this.props.defaultValue, this.props.options),

      // This should be called something else, "entryValue"
      entryValue: this.props.value || this.props.defaultValue,

      // A valid typeahead value
      selection: this.props.value,

      // Index of the selection
      selectionIndex: null
    };
  },

  _shouldSkipSearch: function (input) {
    var emptyValue = !input || input.trim().length == 0;
    return !this.props.showOptionsWhenEmpty && emptyValue;
  },

  getOptionsForValue: function (value, options) {
    if (this._shouldSkipSearch(value)) {
      return [];
    }

    var filterOptions = this._generateFilterFunction();
    var result = filterOptions(value, options);
    if (this.props.maxVisible) {
      result = result.slice(0, this.props.maxVisible);
    }
    return result;
  },

  setEntryText: function (value) {
    this.refs.entry.value = value;
    this._onTextEntryUpdated();
  },

  focus: function () {
    this.refs.entry.focus();
  },

  _hasCustomValue: function () {
    if (this.props.allowCustomValues > 0 && this.state.entryValue.length >= this.props.allowCustomValues && this.state.visible.indexOf(this.state.entryValue) < 0) {
      return true;
    }
    return false;
  },

  _getCustomValue: function () {
    if (this._hasCustomValue()) {
      return this.state.entryValue;
    }
    return null;
  },

  _renderIncrementalSearchResults: function () {
    // Nothing has been entered into the textbox
    if (this._shouldSkipSearch(this.state.entryValue)) {
      return "";
    }

    // Something was just selected
    if (this.state.selection) {
      return "";
    }

    return React.createElement(this.props.customListComponent, {
      ref: 'sel', options: this.state.visible,
      onOptionSelected: this._onOptionSelected,
      allowCustomValues: this.props.allowCustomValues,
      customValue: this._getCustomValue(),
      customClasses: this.props.customClasses,
      selectionIndex: this.state.selectionIndex,
      defaultClassNames: this.props.defaultClassNames,
      displayOption: Accessor.generateOptionToStringFor(this.props.displayOption) });
  },

  getSelection: function () {
    var index = this.state.selectionIndex;
    if (this._hasCustomValue()) {
      if (index === 0) {
        return this.state.entryValue;
      } else {
        index--;
      }
    }
    return this.state.visible[index];
  },

  _onOptionSelected: function (option, event) {
    var nEntry = this.refs.entry;
    nEntry.focus();

    var displayOption = Accessor.generateOptionToStringFor(this.props.displayOption);
    var optionString = displayOption(option, 0);

    var formInputOption = Accessor.generateOptionToStringFor(this.props.formInputOption || displayOption);
    var formInputOptionString = formInputOption(option);

    nEntry.value = optionString;
    this.setState({ visible: this.getOptionsForValue(optionString, this.props.options),
      selection: formInputOptionString,
      entryValue: optionString });
    return this.props.onOptionSelected(option, event);
  },

  _onTextEntryUpdated: function () {
    var value = this.refs.entry.value;
    this.setState({ visible: this.getOptionsForValue(value, this.props.options),
      selection: null,
      entryValue: value });
  },

  _onEnter: function (event) {
    var selection = this.getSelection();
    if (!selection) {
      return this.props.onKeyDown(event);
    }
    return this._onOptionSelected(selection, event);
  },

  _onEscape: function () {
    this.setState({
      selectionIndex: null
    });
  },

  _onTab: function (event) {
    var selection = this.getSelection();
    var option = selection ? selection : this.state.visible.length > 0 ? this.state.visible[0] : null;

    if (option === null && this._hasCustomValue()) {
      option = this._getCustomValue();
    }

    if (option !== null) {
      return this._onOptionSelected(option, event);
    }
  },

  eventMap: function (event) {
    var events = {};

    events[KeyEvent.DOM_VK_UP] = this.navUp;
    events[KeyEvent.DOM_VK_DOWN] = this.navDown;
    events[KeyEvent.DOM_VK_RETURN] = events[KeyEvent.DOM_VK_ENTER] = this._onEnter;
    events[KeyEvent.DOM_VK_ESCAPE] = this._onEscape;
    events[KeyEvent.DOM_VK_TAB] = this._onTab;

    return events;
  },

  _nav: function (delta) {
    if (!this._hasHint()) {
      return;
    }
    var newIndex = this.state.selectionIndex === null ? delta == 1 ? 0 : delta : this.state.selectionIndex + delta;
    var length = this.state.visible.length;
    if (this._hasCustomValue()) {
      length += 1;
    }

    if (newIndex < 0) {
      newIndex += length;
    } else if (newIndex >= length) {
      newIndex -= length;
    }

    this.setState({ selectionIndex: newIndex });
  },

  navDown: function () {
    this._nav(1);
  },

  navUp: function () {
    this._nav(-1);
  },

  _onChange: function (event) {
    if (this.props.onChange) {
      this.props.onChange(event);
    }

    this._onTextEntryUpdated();
  },

  _onKeyDown: function (event) {
    // If there are no visible elements, don't perform selector navigation.
    // Just pass this up to the upstream onKeydown handler.
    // Also skip if the user is pressing the shift key, since none of our handlers are looking for shift
    if (!this._hasHint() || event.shiftKey) {
      return this.props.onKeyDown(event);
    }

    var handler = this.eventMap()[event.keyCode];

    if (handler) {
      handler(event);
    } else {
      return this.props.onKeyDown(event);
    }
    // Don't propagate the keystroke back to the DOM/browser
    event.preventDefault();
  },

  componentWillReceiveProps: function (nextProps) {
    this.setState({
      visible: this.getOptionsForValue(this.state.entryValue, nextProps.options)
    });
  },

  render: function () {
    var inputClasses = {};
    inputClasses[this.props.customClasses.input] = !!this.props.customClasses.input;
    var inputClassList = classNames(inputClasses);

    var classes = {
      typeahead: this.props.defaultClassNames
    };
    classes[this.props.className] = !!this.props.className;
    var classList = classNames(classes);

    var InputElement = this.props.textarea ? 'textarea' : 'input';

    return React.createElement(
      'div',
      { className: classList },
      this._renderHiddenInput(),
      React.createElement(InputElement, _extends({ ref: 'entry', type: 'text',
        disabled: this.props.disabled
      }, this.props.inputProps, {
        placeholder: this.props.placeholder,
        className: inputClassList,
        value: this.state.entryValue,
        defaultValue: this.props.defaultValue,
        onChange: this._onChange,
        onKeyDown: this._onKeyDown,
        onKeyPress: this.props.onKeyPress,
        onKeyUp: this.props.onKeyUp,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur
      })),
      this._renderIncrementalSearchResults()
    );
  },

  _renderHiddenInput: function () {
    if (!this.props.name) {
      return null;
    }

    return React.createElement('input', {
      type: 'hidden',
      name: this.props.name,
      value: this.state.selection
    });
  },

  _generateFilterFunction: function () {
    var filterOptionProp = this.props.filterOption;
    if (typeof filterOptionProp === 'function') {
      return function (value, options) {
        return options.filter(function (o) {
          return filterOptionProp(value, o);
        });
      };
    } else {
      var mapper;
      if (typeof filterOptionProp === 'string') {
        mapper = Accessor.generateAccessor(filterOptionProp);
      } else {
        mapper = Accessor.IDENTITY_FN;
      }
      return function (value, options) {
        return fuzzy.filter(value, options, { extract: mapper }).map(function (res) {
          return options[res.index];
        });
      };
    }
  },

  _hasHint: function () {
    return this.state.visible.length > 0 || this._hasCustomValue();
  }
});

module.exports = Typeahead;
},{"../accessor":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/accessor.js","../keyevent":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/keyevent.js","./selector":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/selector.js","classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/classnames/index.js","fuzzy":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/fuzzy/lib/fuzzy.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/option.js":[function(require,module,exports){
var React = require('react');
var classNames = require('classnames');

/**
 * A single option within the TypeaheadSelector
 */
var TypeaheadOption = React.createClass({
  displayName: 'TypeaheadOption',

  propTypes: {
    customClasses: React.PropTypes.object,
    customValue: React.PropTypes.string,
    onClick: React.PropTypes.func,
    children: React.PropTypes.string,
    hover: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      customClasses: {},
      onClick: function (event) {
        event.preventDefault();
      }
    };
  },

  render: function () {
    var classes = {};
    classes[this.props.customClasses.hover || "hover"] = !!this.props.hover;
    classes[this.props.customClasses.listItem] = !!this.props.customClasses.listItem;

    if (this.props.customValue) {
      classes[this.props.customClasses.customAdd] = !!this.props.customClasses.customAdd;
    }

    var classList = classNames(classes);

    return React.createElement(
      'li',
      { className: classList, onClick: this._onClick },
      React.createElement(
        'a',
        { href: 'javascript: void 0;', className: this._getClasses(), ref: 'anchor' },
        this.props.children
      )
    );
  },

  _getClasses: function () {
    var classes = {
      "typeahead-option": true
    };
    classes[this.props.customClasses.listAnchor] = !!this.props.customClasses.listAnchor;

    return classNames(classes);
  },

  _onClick: function (event) {
    event.preventDefault();
    return this.props.onClick(event);
  }
});

module.exports = TypeaheadOption;
},{"classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/selector.js":[function(require,module,exports){
var React = require('react');
var TypeaheadOption = require('./option');
var classNames = require('classnames');

/**
 * Container for the options rendered as part of the autocompletion process
 * of the typeahead
 */
var TypeaheadSelector = React.createClass({
  displayName: 'TypeaheadSelector',

  propTypes: {
    options: React.PropTypes.array,
    allowCustomValues: React.PropTypes.number,
    customClasses: React.PropTypes.object,
    customValue: React.PropTypes.string,
    selectionIndex: React.PropTypes.number,
    onOptionSelected: React.PropTypes.func,
    displayOption: React.PropTypes.func.isRequired,
    defaultClassNames: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      selectionIndex: null,
      customClasses: {},
      allowCustomValues: 0,
      customValue: null,
      onOptionSelected: function (option) {},
      defaultClassNames: true
    };
  },

  render: function () {
    // Don't render if there are no options to display
    if (!this.props.options.length && this.props.allowCustomValues <= 0) {
      return false;
    }

    var classes = {
      "typeahead-selector": this.props.defaultClassNames
    };
    classes[this.props.customClasses.results] = this.props.customClasses.results;
    var classList = classNames(classes);

    // CustomValue should be added to top of results list with different class name
    var customValue = null;
    var customValueOffset = 0;
    if (this.props.customValue !== null) {
      customValueOffset++;
      customValue = React.createElement(
        TypeaheadOption,
        { ref: this.props.customValue, key: this.props.customValue,
          hover: this.props.selectionIndex === 0,
          customClasses: this.props.customClasses,
          customValue: this.props.customValue,
          onClick: this._onClick.bind(this, this.props.customValue) },
        this.props.customValue
      );
    }

    var results = this.props.options.map(function (result, i) {
      var displayString = this.props.displayOption(result, i);
      var uniqueKey = displayString + '_' + i;
      return React.createElement(
        TypeaheadOption,
        { ref: uniqueKey, key: uniqueKey,
          hover: this.props.selectionIndex === i + customValueOffset,
          customClasses: this.props.customClasses,
          onClick: this._onClick.bind(this, result) },
        displayString
      );
    }, this);

    return React.createElement(
      'ul',
      { className: classList },
      customValue,
      results
    );
  },

  _onClick: function (result, event) {
    return this.props.onOptionSelected(result, event);
  }

});

module.exports = TypeaheadSelector;
},{"./option":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/typeahead/option.js","classnames":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/classnames/index.js":[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

function classNames() {
	var classes = '';
	var arg;

	for (var i = 0; i < arguments.length; i++) {
		arg = arguments[i];
		if (!arg) {
			continue;
		}

		if ('string' === typeof arg || 'number' === typeof arg) {
			classes += ' ' + arg;
		} else if (Object.prototype.toString.call(arg) === '[object Array]') {
			classes += ' ' + classNames.apply(null, arg);
		} else if ('object' === typeof arg) {
			for (var key in arg) {
				if (!arg.hasOwnProperty(key) || !arg[key]) {
					continue;
				}
				classes += ' ' + key;
			}
		}
	}
	return classes.substr(1);
}

// safely export classNames for node / browserify
if (typeof module !== 'undefined' && module.exports) {
	module.exports = classNames;
}

// safely export classNames for RequireJS
if (typeof define !== 'undefined' && define.amd) {
	define('classnames', [], function() {
		return classNames;
	});
}

},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/node_modules/fuzzy/lib/fuzzy.js":[function(require,module,exports){
/*
 * Fuzzy
 * https://github.com/myork/fuzzy
 *
 * Copyright (c) 2012 Matt York
 * Licensed under the MIT license.
 */

(function() {

var root = this;

var fuzzy = {};

// Use in node or in browser
if (typeof exports !== 'undefined') {
  module.exports = fuzzy;
} else {
  root.fuzzy = fuzzy;
}

// Return all elements of `array` that have a fuzzy
// match against `pattern`.
fuzzy.simpleFilter = function(pattern, array) {
  return array.filter(function(string) {
    return fuzzy.test(pattern, string);
  });
};

// Does `pattern` fuzzy match `string`?
fuzzy.test = function(pattern, string) {
  return fuzzy.match(pattern, string) !== null;
};

// If `pattern` matches `string`, wrap each matching character
// in `opts.pre` and `opts.post`. If no match, return null
fuzzy.match = function(pattern, string, opts) {
  opts = opts || {};
  var patternIdx = 0
    , result = []
    , len = string.length
    , totalScore = 0
    , currScore = 0
    // prefix
    , pre = opts.pre || ''
    // suffix
    , post = opts.post || ''
    // String to compare against. This might be a lowercase version of the
    // raw string
    , compareString =  opts.caseSensitive && string || string.toLowerCase()
    , ch, compareChar;

  pattern = opts.caseSensitive && pattern || pattern.toLowerCase();

  // For each character in the string, either add it to the result
  // or wrap in template if it's the next string in the pattern
  for(var idx = 0; idx < len; idx++) {
    ch = string[idx];
    if(compareString[idx] === pattern[patternIdx]) {
      ch = pre + ch + post;
      patternIdx += 1;

      // consecutive characters should increase the score more than linearly
      currScore += 1 + currScore;
    } else {
      currScore = 0;
    }
    totalScore += currScore;
    result[result.length] = ch;
  }

  // return rendered string if we have a match for every char
  if(patternIdx === pattern.length) {
    return {rendered: result.join(''), score: totalScore};
  }

  return null;
};

// The normal entry point. Filters `arr` for matches against `pattern`.
// It returns an array with matching values of the type:
//
//     [{
//         string:   '<b>lah' // The rendered string
//       , index:    2        // The index of the element in `arr`
//       , original: 'blah'   // The original element in `arr`
//     }]
//
// `opts` is an optional argument bag. Details:
//
//    opts = {
//        // string to put before a matching character
//        pre:     '<b>'
//
//        // string to put after matching character
//      , post:    '</b>'
//
//        // Optional function. Input is an entry in the given arr`,
//        // output should be the string to test `pattern` against.
//        // In this example, if `arr = [{crying: 'koala'}]` we would return
//        // 'koala'.
//      , extract: function(arg) { return arg.crying; }
//    }
fuzzy.filter = function(pattern, arr, opts) {
  opts = opts || {};
  return arr
    .reduce(function(prev, element, idx, arr) {
      var str = element;
      if(opts.extract) {
        str = opts.extract(element);
      }
      var rendered = fuzzy.match(pattern, str, opts);
      if(rendered != null) {
        prev[prev.length] = {
            string: rendered.rendered
          , score: rendered.score
          , index: idx
          , original: element
        };
      }
      return prev;
    }, [])

    // Sort by score. Browsers are inconsistent wrt stable/unstable
    // sorting, so force stable by using the index in the case of tie.
    // See http://ofb.net/~sethml/is-sort-stable.html
    .sort(function(a,b) {
      var compare = b.score - a.score;
      if(compare) return compare;
      return a.index - b.index;
    });
};


}());


},{}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/App.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var React = _interopRequireWildcard(_react);

var _AreaDescriptionsStore = require('./stores/AreaDescriptionsStore');

var _AreaDescriptionsStore2 = _interopRequireDefault(_AreaDescriptionsStore);

var _CityStore = require('./stores/CityStore');

var _CityStore2 = _interopRequireDefault(_CityStore);

var _DimensionsStore = require('./stores/DimensionsStore');

var _DimensionsStore2 = _interopRequireDefault(_DimensionsStore);

var _MapStateStore = require('./stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

var _RasterStore = require('./stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

var _UserLocationStore = require('./stores/UserLocationStore');

var _UserLocationStore2 = _interopRequireDefault(_UserLocationStore);

var _TextsStore = require('./stores/TextsStore');

var _TextsStore2 = _interopRequireDefault(_TextsStore);

var _ADCat = require('./components/ADCat.jsx');

var _ADCat2 = _interopRequireDefault(_ADCat);

var _AreaDescription = require('./components/AreaDescription.jsx');

var _AreaDescription2 = _interopRequireDefault(_AreaDescription);

var _toolkit = require('@panorama/toolkit');

var _CitySnippet = require('./components/CitySnippet.jsx');

var _CitySnippet2 = _interopRequireDefault(_CitySnippet);

var _CityStats = require('./components/CityStats.jsx');

var _CityStats2 = _interopRequireDefault(_CityStats);

var _Downloader = require('./components/Downloader.jsx');

var _Downloader2 = _interopRequireDefault(_Downloader);

var _leaflet = require('leaflet');

var _reactLeaflet = require('react-leaflet');

var _reactModal = require('react-modal');

var _reactModal2 = _interopRequireDefault(_reactModal);

var _rcSlider = require('rc-slider');

var _rcSlider2 = _interopRequireDefault(_rcSlider);

var _StateStats = require('./components/StateStats.jsx');

var _StateStats2 = _interopRequireDefault(_StateStats);

var _reactTypeahead = require('react-typeahead');

var _TypeAheadCitySnippet = require('./components/TypeAheadCitySnippet.jsx');

var _TypeAheadCitySnippet2 = _interopRequireDefault(_TypeAheadCitySnippet);

var _HOLCMap = require('./components/HOLCMap.jsx');

var _HOLCMap2 = _interopRequireDefault(_HOLCMap);

var _SidebarMap = require('./components/SidebarMap.jsx');

var _SidebarMap2 = _interopRequireDefault(_SidebarMap);

var _AppActionCreator = require('./utils/AppActionCreator');

var _panorama_nav = require('../data/panorama_nav.json');

var _panorama_nav2 = _interopRequireDefault(_panorama_nav);

var _state_abbr = require('../data/state_abbr.json');

var _state_abbr2 = _interopRequireDefault(_state_abbr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import "babel-polyfill";

// stores


// components (views)


// utils


// data


var App = function (_React$Component) {
	_inherits(App, _React$Component);

	function App(props) {
		_classCallCheck(this, App);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(App).call(this, props));

		_this.state = _this.getDefaultState();

		// bind handlers
		var handlers = ['onWindowResize', 'onModalClick', 'toggleBurgessDiagram', 'storeChanged', 'onBurgessChartOff', 'onBurgessChartHover', 'onStateSelected', 'onCitySelected', 'onMapMoved', 'onPanoramaMenuClick', 'onDownloadClicked', 'onCategoryClick', 'neighborhoodHighlighted', 'neighborhoodsUnhighlighted', 'onSliderChange', 'onUserCityResponse', 'onNeighborhoodPolygonClick', 'onAreaChartHover', 'onAreaChartOff', 'onCityMarkerSelected', 'onGradeHover', 'onGradeUnhover', 'onHOLCIDClick', 'onNeighborhoodClose', 'onCategoryClose', 'onAdImageClicked'];
		handlers.map(function (handler) {
			_this[handler] = _this[handler].bind(_this);
		});
		return _this;
	}

	/* Lifecycle methods */

	_createClass(App, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			_AppActionCreator.AppActions.loadInitialData(this.state, _toolkit.HashManager.getState());

			//try to retrieve the users location
			if (navigator.geolocation) {
				navigator.geolocation.getCurrentPosition(function (position) {
					_AppActionCreator.AppActions.userLocated([position.coords.latitude, position.coords.longitude]);
				}, function (error) {
					console.warn('Geolocation error occurred. Error code: ' + error.code);
				});
			}
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			window.addEventListener('resize', this.onWindowResize);
			_AreaDescriptionsStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_CityStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_DimensionsStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_MapStateStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_RasterStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_UserLocationStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_TextsStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);

			// you have to wait until there's a map to query to get the visible maps
			var waitingId = setInterval(function () {
				if (_RasterStore2.default.hasLoaded() && _AreaDescriptionsStore2.default.hasLoaded()) {
					clearInterval(waitingId);

					// emit mapped moved event to initialize map state
					_AppActionCreator.AppActions.mapInitialized(_this2.getLeafletElementForMap());
				}
			}, 100);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {}

		/* setState methods */

	}, {
		key: 'getDefaultState',
		value: function getDefaultState() {
			var hashState = _toolkit.HashManager.getState();

			return {
				selectedCity: hashState.city ? parseInt(hashState.city) : null,
				selectedNeighborhood: hashState.area ? hashState.area : null,
				selectedCategory: hashState.category ? hashState.category : null,
				selectedRingGrade: {
					ringId: null,
					grade: null
				},
				selectedGrade: null,
				raster: {
					opacity: hashState.opacity ? parseFloat(hashState.opacity) : 0.8
				},
				highlightedNeighborhood: null,
				burgessDiagramVisible: false,
				downloadOpen: false,
				adImageOpen: false,
				map: {
					zoom: hashState.loc && hashState.loc.zoom ? hashState.loc.zoom : 5,
					center: hashState.loc && hashState.loc.center ? [hashState.loc.center[0], hashState.loc.center[1]] : [39.8333333, -98.585522]
				},
				dimensions: {
					left: {
						width: 0,
						height: 0
					},
					upperRight: {
						width: 0,
						height: 0
					}
				}
			};
		}
	}, {
		key: 'storeChanged',
		value: function storeChanged() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			this.setState({
				selectedCity: _CityStore2.default.getId(),
				selectedGrade: _CityStore2.default.getSelectedGrade(),
				selectedNeighborhood: _CityStore2.default.getSelectedHolcId(),
				selectedCategory: _CityStore2.default.getSelectedCategory(),
				selectedRingGrade: _CityStore2.default.getSelectedRingGrade(),
				highlightedNeighborhood: _CityStore2.default.getHighlightedHolcId(),
				map: {
					center: _MapStateStore2.default.getCenter(),
					zoom: _MapStateStore2.default.getZoom()
				}
			}, this.changeHash);
		}
	}, {
		key: 'onMapMoved',
		value: function onMapMoved(event) {
			_AppActionCreator.AppActions.mapMoved(this.getLeafletElementForMap());
		}
	}, {
		key: 'onCitySelected',
		value: function onCitySelected(event) {
			_AppActionCreator.AppActions.citySelected(event.target.id, true);
		}
	}, {
		key: 'onCityMarkerSelected',
		value: function onCityMarkerSelected(event) {
			_AppActionCreator.AppActions.citySelected(event.target.options.id, true);
		}
	}, {
		key: 'onNeighborhoodPolygonClick',
		value: function onNeighborhoodPolygonClick(event) {
			var neighborhoodId = event.target.options.neighborhoodId,
			    adId = parseInt(event.target.options.adId);

			// clicking on a selected neighborhood deselects it
			neighborhoodId = neighborhoodId == this.state.selectedNeighborhood && adId == this.state.selectedCity ? null : neighborhoodId;

			_AppActionCreator.AppActions.neighborhoodSelected(neighborhoodId, adId);
		}
	}, {
		key: 'onNeighborhoodClose',
		value: function onNeighborhoodClose() {
			_AppActionCreator.AppActions.neighborhoodSelected(null, this.state.selectedCity);
		}
	}, {
		key: 'onHOLCIDClick',
		value: function onHOLCIDClick(event) {
			_AppActionCreator.AppActions.neighborhoodSelected(event.target.id, this.state.selectedCity);
		}
	}, {
		key: 'neighborhoodHighlighted',
		value: function neighborhoodHighlighted(event) {
			_AppActionCreator.AppActions.neighborhoodHighlighted(event.target.id);
		}
	}, {
		key: 'neighborhoodsUnhighlighted',
		value: function neighborhoodsUnhighlighted() {
			_AppActionCreator.AppActions.neighborhoodHighlighted(null);
		}
	}, {
		key: 'onCategoryClick',
		value: function onCategoryClick(event) {
			_AppActionCreator.AppActions.ADCategorySelected(event.target.id);
		}
	}, {
		key: 'onCategoryClose',
		value: function onCategoryClose(event) {
			_AppActionCreator.AppActions.ADCategorySelected(null);
		}
	}, {
		key: 'onBurgessChartHover',
		value: function onBurgessChartHover(ringId, grade) {
			_AppActionCreator.AppActions.ringGradeSelected({ ringId: ringId, grade: grade });
		}
	}, {
		key: 'onBurgessChartOff',
		value: function onBurgessChartOff() {
			_AppActionCreator.AppActions.ringGradeSelected({ ringId: -1, grade: null });
		}
	}, {
		key: 'onAreaChartHover',
		value: function onAreaChartHover(grade) {
			_AppActionCreator.AppActions.gradeSelected(grade);
		}
	}, {
		key: 'onAreaChartOff',
		value: function onAreaChartOff() {
			_AppActionCreator.AppActions.gradeSelected(null);
		}
	}, {
		key: 'onLegendSelect',
		value: function onLegendSelect(legendText) {}
	}, {
		key: 'onGradeHover',
		value: function onGradeHover(event) {
			_AppActionCreator.AppActions.gradeSelected(event.target.grade);
		}
	}, {
		key: 'onGradeUnhover',
		value: function onGradeUnhover() {
			_AppActionCreator.AppActions.gradeSelected(null);
		}
	}, {
		key: 'categorySelected',
		value: function categorySelected(id) {
			this.setState({
				selectedNeighborhood: null,
				selectedCategory: id
			}, this.changeHash);
		}
	}, {
		key: 'onWindowResize',
		value: function onWindowResize(event) {
			_AppActionCreator.AppActions.windowResized();
		}
	}, {
		key: 'onStateSelected',
		value: function onStateSelected(value, index) {
			// for click on state name in sidebar
			value = value.target ? value.target : value;

			this.setState({
				selectedCity: null,
				selectedNeighborhood: null,
				map: {
					zoom: this.getLeafletElementForMap().getBoundsZoom(_RasterStore2.default.getMapBoundsForState(value.id)),
					center: _RasterStore2.default.getCenterForState(value.id)
				}
			}, this.changeHash());
		}
	}, {
		key: 'onSliderChange',
		value: function onSliderChange(value) {
			this.setState({
				raster: {
					opacity: value / 100
				}
			}, this.changeHash);
		}
	}, {
		key: 'onDownloadClicked',
		value: function onDownloadClicked() {
			this.setState({
				downloadOpen: !this.state.downloadOpen
			});
		}
	}, {
		key: 'onAdImageClicked',
		value: function onAdImageClicked() {
			_AppActionCreator.AppActions.ADImageOpened(this.state.selectedNeighborhood, this.state.selectedCity);
			this.setState({
				adImageOpen: !this.state.adImageOpen
			});
		}
	}, {
		key: 'onPanoramaMenuClick',
		value: function onPanoramaMenuClick() {
			this.setState({
				show_panorama_menu: !this.state.show_panorama_menu
			});
		}
	}, {
		key: 'onUserCityResponse',
		value: function onUserCityResponse(event) {
			if (event.target.value == 'yes') {
				_AppActionCreator.AppActions.citySelected(_UserLocationStore2.default.getAdId(), true);
			}
			_AppActionCreator.AppActions.userRespondedToZoomOffer();
		}
	}, {
		key: 'toggleBurgessDiagram',
		value: function toggleBurgessDiagram() {
			this.setState({
				burgessDiagramVisible: !this.state.burgessDiagramVisible
			});
		}
	}, {
		key: 'onModalClick',
		value: function onModalClick(event) {
			var subject = event.target.id ? event.target.id : null;
			_AppActionCreator.AppActions.onModalClick(subject);
		}
	}, {
		key: 'getLeafletElementForMap',
		value: function getLeafletElementForMap() {
			return this.refs.holc_map ? this.refs.holc_map.refs.the_map.leafletElement : this.refs.sidebar_map.refs.holc_map.refs.the_map.leafletElement;
		}

		/* manage hash */

	}, {
		key: 'changeHash',
		value: function changeHash() {
			_toolkit.HashManager.updateHash({
				city: this.state.selectedCity,
				area: this.state.selectedNeighborhood,
				category: this.state.selectedCategory,
				opacity: this.state.raster.opacity,
				loc: {
					zoom: this.state.map.zoom,
					center: this.state.map.center
				}
			});
		}
	}, {
		key: 'searchDisplay',
		value: function searchDisplay() {
			var _this3 = this;

			var citiesOptions = _RasterStore2.default.getCityIdsAndNames(),
			    citiesData = _RasterStore2.default.getAllRasters();
			return citiesOptions.map(function (cityOption) {
				return {
					id: cityOption.id,
					cityName: cityOption.cityName,
					display: React.createElement(_CitySnippet2.default, {
						cityData: citiesData[cityOption.id],
						onCityClick: _this3.props.onCityClick,
						key: 'citySearch' + cityOption.id
					})
				};
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this4 = this;

			var modalStyle = {
				overlay: {
					backgroundColor: null
				},
				content: {
					top: null,
					left: null,
					right: null,
					bottom: null,
					border: null,
					background: null,
					borderRadius: null,
					padding: null,
					position: null
				}
			},
			    ADs = _AreaDescriptionsStore2.default.getVisible(),
			    aboveThreshold = _MapStateStore2.default.isAboveZoomThreshold(),
			    outerRadius = _CityStore2.default.getOuterRingRadius();

			var selectedADs = _AreaDescriptionsStore2.default.getADsForNeighborhood(this.state.selectedCity, this.state.selectedNeighborhood),
			    neighborhoodNames = _AreaDescriptionsStore2.default.getNeighborhoodNames(this.state.selectedCity),
			    ADsByCat = _AreaDescriptionsStore2.default.getADsForCategory(this.state.selectedCity, this.state.selectedCategory),
			    catNum = this.state.selectedCategory ? this.state.selectedCategory.split('-')[0] : null,
			    catLetter = this.state.selectedCategory ? this.state.selectedCategory.split('-')[1] : null,
			    visibleMaps = _MapStateStore2.default.getVisibleHOLCMaps(),
			    visibleStates = _MapStateStore2.default.getVisibleHOLCMapsByState();

			//setIconDefaultImagePath('./static');

			return React.createElement(
				'div',
				{ className: 'container full-height' },
				React.createElement(_toolkit.Navigation, {
					show_menu: this.state.show_panorama_menu,
					on_hamburger_click: this.onPanoramaMenuClick,
					nav_data: _panorama_nav2.default.filter(function (item, i) {
						return item.url.indexOf('holc') === -1;
					})
				}),
				React.createElement(
					'div',
					{ className: 'row full-height' },
					React.createElement(
						'div',
						{ className: 'columns eight full-height' },
						React.createElement(
							'header',
							{ className: 'row u-full-width' },
							React.createElement(
								'h1',
								null,
								React.createElement(
									'span',
									{ className: 'header-main' },
									'Mapping Inequality'
								),
								React.createElement(
									'span',
									{ className: 'header-sub' },
									'Redlining in New Deal America'
								)
							),
							React.createElement(
								'h4',
								{ onClick: this.onModalClick, id: 'about' },
								'Introduction'
							),
							React.createElement(
								'h4',
								{ onClick: this.onModalClick, id: 'bibliograph' },
								'Bibliographic Notes & Bibliography'
							),
							React.createElement(
								'h4',
								{ onClick: this.onModalClick, id: 'credits' },
								'Credits'
							),
							React.createElement('hr', { className: 'style-eight' })
						),
						React.createElement(
							'div',
							{
								className: 'row template-tile leaflet-container main-pane',
								style: _DimensionsStore2.default.getMainPaneStyle()
							},
							!this.state.adImageOpen ? React.createElement(_HOLCMap2.default, {
								ref: 'holc_map',
								state: this.state,
								onMapMoved: this.onMapMoved,
								onNeighborhoodPolygonClick: this.onNeighborhoodPolygonClick,
								onCityMarkerSelected: this.onCityMarkerSelected
							}) : React.createElement(
								_reactLeaflet.Map,
								{
									ref: 'the_ad_tiles',
									center: [75, -125],
									zoom: 3,
									className: 'the_ad',
									style: _DimensionsStore2.default.getADViewerStyle()
								},
								React.createElement(_reactLeaflet.TileLayer, {
									key: 'AD',
									url: _AreaDescriptionsStore2.default.getAdTileUrl(this.state.selectedCity, this.state.selectedNeighborhood),
									zIndex: 1000
								}),
								React.createElement(_toolkit.Legend, {
									items: ['Close'],
									className: 'adClose',
									onItemSelected: this.onAdImageClicked
								})
							),
							_TextsStore2.default.mainModalIsOpen() ? React.createElement(
								'div',
								{ className: 'longishform' },
								React.createElement(
									'button',
									{ className: 'close', onClick: this.onModalClick },
									React.createElement(
										'span',
										null,
										'×'
									)
								),
								React.createElement('div', { className: 'content', dangerouslySetInnerHTML: _TextsStore2.default.getModalContent() })
							) : null,
							false ? React.createElement(
								'div',
								{ className: 'longishform' },
								React.createElement(
									'button',
									{ className: 'close', onClick: this.onAdImageClicked },
									React.createElement(
										'span',
										null,
										'×'
									)
								),
								React.createElement('img', { src: _AreaDescriptionsStore2.default.getAdUrl(this.state.selectedCity, this.state.selectedNeighborhood) })
							) : null
						)
					),
					aboveThreshold ? React.createElement(
						'div',
						{ className: 'opacitySlider' },
						React.createElement(_rcSlider2.default, {
							vertical: true,
							defaultValue: this.state.raster.opacity * 100,
							onAfterChange: this.onSliderChange
						})
					) : '',
					React.createElement(
						'div',
						{ className: 'columns four full-height' },
						React.createElement(
							'div',
							{
								className: 'row template-tile city-selector',
								style: _DimensionsStore2.default.getSearchStyle()
							},
							React.createElement(_reactTypeahead.Typeahead, {
								options: _AreaDescriptionsStore2.default.getADsList(),
								placeholder: 'Search by city or state',
								filterOption: 'searchName',
								displayOption: function displayOption(city, i) {
									return city.ad_id;
								},
								onOptionSelected: this.onCitySelected,
								customListComponent: _TypeAheadCitySnippet2.default,
								maxVisible: 8
							})
						),
						React.createElement(
							'div',
							{
								className: 'row full-height template-tile dataViewer',
								style: _DimensionsStore2.default.getSidebarHeightStyle()
							},
							!this.state.selectedNeighborhood && !this.state.selectedCategory && !this.state.downloadOpen && this.state.selectedCity ? React.createElement(_CityStats2.default, {
								name: _CityStore2.default.getName(),
								state: _CityStore2.default.getState(),
								cityData: _CityStore2.default.getCityData(),
								area: _AreaDescriptionsStore2.default.getArea(this.state.selectedCity),
								gradeStats: _CityStore2.default.getGradeStats(),
								ringStats: _CityStore2.default.getRingStats(),
								areaSelected: this.onBurgessChartHover,
								areaUnselected: this.onBurgessChartOff,
								gradeSelected: this.onAreaChartHover,
								gradeUnselected: this.onAreaChartOff,
								openBurgess: this.onModalClick,
								burgessDiagramVisible: this.state.burgessDiagramVisible,
								toggleBurgessDiagram: this.toggleBurgessDiagram,
								hasADs: _AreaDescriptionsStore2.default.hasADData(this.state.selectedCity),
								onDownloadClicked: this.onDownloadClicked
							}) : '',
							!this.state.selectedNeighborhood && !this.state.selectedCategory && this.state.selectedCity && Object.keys(ADs).length >= 2 ? React.createElement(
								'div',
								null,
								React.createElement(
									'h4',
									null,
									'Other Visible Maps'
								),
								Object.keys(visibleMaps).map(function (mapId) {
									return visibleMaps[mapId].cityId !== _this4.state.selectedCity ? React.createElement(_CitySnippet2.default, {
										cityData: visibleMaps[mapId],
										onCityClick: _this4.onCitySelected,
										key: 'city' + mapId,
										recenter: false
									}) : '';
								})
							) : '',
							this.state.selectedNeighborhood && !this.state.adImageOpen ? React.createElement(_AreaDescription2.default, {
								areaId: this.state.selectedNeighborhood,
								previousAreaId: _AreaDescriptionsStore2.default.getPreviousHOLCId(this.state.selectedCity, this.state.selectedNeighborhood),
								nextAreaId: _AreaDescriptionsStore2.default.getNextHOLCId(this.state.selectedCity, this.state.selectedNeighborhood),
								neighborhoodNames: neighborhoodNames,
								areaDescriptions: selectedADs,
								thumbnailUrl: _AreaDescriptionsStore2.default.getThumbnailUrl(this.state.selectedCity, this.state.selectedNeighborhood),
								formId: _CityStore2.default.getFormId(),
								cityId: this.state.selectedCity,
								onCategoryClick: this.onCategoryClick,
								onHOLCIDClick: this.onHOLCIDClick,
								onAdImageClicked: this.onAdImageClicked,
								onClose: this.onNeighborhoodClose,
								ref: 'areadescription' + this.state.selectedNeighborhood,
								previousStyle: _DimensionsStore2.default.getADNavPreviousStyle(),
								nextStyle: _DimensionsStore2.default.getADNavNextStyle()
							}) : '',
							this.state.selectedNeighborhood && this.state.adImageOpen ? React.createElement(_SidebarMap2.default, {
								ref: 'sidebar_map',
								state: this.state,
								onMapMoved: this.onMapMoved,
								onNeighborhoodPolygonClick: this.onNeighborhoodPolygonClick,
								onCityMarkerSelected: this.onCityMarkerSelected,
								areaId: this.state.selectedNeighborhood,
								previousAreaId: _AreaDescriptionsStore2.default.getPreviousHOLCId(this.state.selectedCity, this.state.selectedNeighborhood),
								nextAreaId: _AreaDescriptionsStore2.default.getNextHOLCId(this.state.selectedCity, this.state.selectedNeighborhood),
								neighborhoodNames: neighborhoodNames,
								onHOLCIDClick: this.onHOLCIDClick,
								onClose: this.onNeighborhoodClose,
								previousStyle: _DimensionsStore2.default.getADNavPreviousStyle(),
								nextStyle: _DimensionsStore2.default.getADNavNextStyle(),
								mapStyle: _DimensionsStore2.default.getSidebarMapStyle()

							}) : '',
							this.state.selectedCategory ? React.createElement(_ADCat2.default, {
								ADsByCat: ADsByCat,
								neighborhoodNames: neighborhoodNames,
								formId: _AreaDescriptionsStore2.default.getFormId(this.state.selectedCity),
								title: _AreaDescriptionsStore2.default.getCatTitle(this.state.selectedCity, catNum, catLetter),
								catNum: catNum,
								catLetter: catLetter,
								previousCatIds: _AreaDescriptionsStore2.default.getPreviousCatIds(this.state.selectedCity, catNum, catLetter),
								nextCatIds: _AreaDescriptionsStore2.default.getNextCatIds(this.state.selectedCity, catNum, catLetter),
								cityId: this.state.selectedCity,
								onNeighborhoodClick: this.onHOLCIDClick,
								onCategoryClick: this.onCategoryClick,
								onNeighborhoodHover: this.neighborhoodHighlighted,
								onNeighborhoodOut: this.neighborhoodsUnhighlighted,
								previousStyle: _DimensionsStore2.default.getADNavPreviousStyle(),
								nextStyle: _DimensionsStore2.default.getADNavNextStyle(),
								onClose: this.onCategoryClose
							}) : '',
							!this.state.selectedCity && !this.state.selectedNeighborhood && !this.state.selectedCategory && visibleStates ? Object.keys(visibleStates).map(function (theState) {
								return React.createElement(_StateStats2.default, {
									stateName: _state_abbr2.default[theState],
									cities: visibleStates[theState],
									onCityClick: _this4.onCitySelected,
									key: theState
								});
							}) : '',
							this.state.downloadOpen ? React.createElement(_Downloader2.default, {
								mapurl: _RasterStore2.default.getMapUrl(),
								thumbnail: _RasterStore2.default.getMapThumbnail(),
								name: _RasterStore2.default.getSelectedCityMetadata().name,
								state: _CityStore2.default.getState(),
								adGeojson: _AreaDescriptionsStore2.default.getADsAsGeojson(this.state.selectedCity),
								onDownloadClicked: this.onDownloadClicked
							}) : null
						)
					),
					React.createElement(
						_reactModal2.default,
						{
							isOpen: _UserLocationStore2.default.getOfferZoomTo(),
							style: modalStyle
						},
						React.createElement(
							'p',
							null,
							'Would you like to zoom to ',
							_UserLocationStore2.default.getCity(),
							'?'
						),
						React.createElement(
							'button',
							{ onClick: this.onUserCityResponse, value: 'yes' },
							'Sure'
						),
						React.createElement(
							'button',
							{ onClick: this.onUserCityResponse, value: 'no' },
							'No thanks'
						)
					)
				)
			);
		}
	}]);

	return App;
}(React.Component);

App.defaultProps = {
	somethingRequested: Object.keys(_toolkit.HashManager.getState()).reduce(function (a, b) {
		return typeof a !== 'undefined' && typeof _toolkit.HashManager.getState()[a] !== 'undefined' || typeof b !== 'undefined' && typeof _toolkit.HashManager.getState()[b] !== 'undefined';
	}, '')
};
exports.default = App;

},{"../data/panorama_nav.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/panorama_nav.json","../data/state_abbr.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/state_abbr.json","./components/ADCat.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/ADCat.jsx","./components/AreaDescription.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/AreaDescription.jsx","./components/CitySnippet.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/CitySnippet.jsx","./components/CityStats.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/CityStats.jsx","./components/Downloader.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/Downloader.jsx","./components/HOLCMap.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/HOLCMap.jsx","./components/SidebarMap.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarMap.jsx","./components/StateStats.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/StateStats.jsx","./components/TypeAheadCitySnippet.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/TypeAheadCitySnippet.jsx","./stores/AreaDescriptionsStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/AreaDescriptionsStore.js","./stores/CityStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/CityStore.js","./stores/DimensionsStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/DimensionsStore.js","./stores/MapStateStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/MapStateStore.js","./stores/RasterStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/RasterStore.js","./stores/TextsStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/TextsStore.js","./stores/UserLocationStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/UserLocationStore.js","./utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","@panorama/toolkit":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/@panorama/toolkit/dist/components.min.js","leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js","rc-slider":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/rc-slider/lib/index.js","react":"react","react-leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/index.js","react-modal":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-modal/lib/index.js","react-typeahead":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-typeahead/lib/react-typeahead.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/ADCat.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _SidebarNeighborhoodNav = require('./SidebarNeighborhoodNav.jsx');

var _SidebarNeighborhoodNav2 = _interopRequireDefault(_SidebarNeighborhoodNav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ADCat = function (_React$Component) {
	_inherits(ADCat, _React$Component);

	// property validation

	function ADCat() {
		_classCallCheck(this, ADCat);

		// bind handlers

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ADCat).call(this));

		_this.render19370826_5c = _this.render19370203_5c;
		_this.render19370203_5d = _this.render19370203_5c;
		_this.render19370826_5d = _this.render19370203_5c;
		_this.render19370826_5g = _this.render19370203_5g;
		_this.render19370826_8a = _this.render19370203_8a;
		_this.render19370203_8b = _this.render19370203_8a;
		_this.render19370826_8b = _this.render19370203_8a;
		_this.render19370203_8c = _this.render19370203_8a;
		_this.render19370826_8c = _this.render19370203_8a;
		var handlers = ['render19370826_5c', 'render19370826_5c', 'render19370203_5d', 'render19370826_5d', 'render19370826_5g', 'render19370203_5g', 'render19370203_8a', 'render19370826_8a', 'render19370203_8b', 'render19370826_8b', 'render19370203_8c', 'render19370826_8c'];
		handlers.map(function (handler) {
			_this[handler] = _this[handler].bind(_this);
		});
		return _this;
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(ADCat, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return true;
			//return (nextProps.catNum !== this.props.catNum || nextProps.catLetter !== this.props.catLetter || nextProps.cityId !== this.props.cityId)
		}

		/* alphanum.js (C) Brian Huisman
  * Based on the Alphanum Algorithm by David Koelle
  * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
  *
  * Distributed under same license as original
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or any later version.
  * 
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  * 
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  */

	}, {
		key: 'alphanumCase',
		value: function alphanumCase(a, b) {
			function chunkify(t) {
				var tz = new Array();
				var x = 0,
				    y = -1,
				    n = 0,
				    i,
				    j;
				while (i = (j = t.charAt(x++)).charCodeAt(0)) {
					var m = i == 46 || i >= 48 && i <= 57;
					if (m !== n) {
						tz[++y] = '';
						n = m;
					}
					tz[y] += j;
				}
				return tz;
			}

			var aa = chunkify(a.toLowerCase());
			var bb = chunkify(b.toLowerCase());
			for (var x = 0; aa[x] && bb[x]; x++) {
				if (aa[x] !== bb[x]) {
					var c = Number(aa[x]),
					    d = Number(bb[x]);
					if (c == aa[x] && d == bb[x]) {
						return c - d;
					} else return aa[x] > bb[x] ? 1 : -1;
				}
			}
			return aa.length - bb.length;
		}
	}, {
		key: 'getCategoryString',
		value: function getCategoryString(catNum, catLetter) {
			return catNum + (catLetter ? '-' + catLetter : '');
		}
	}, {
		key: 'renderGrade',
		value: function renderGrade(grade) {
			var _this2 = this;

			var idiosyncraticDisplay = this['render' + this.props.formId + '_' + this.props.catNum + (this.props.catLetter ? this.props.catLetter : '')],
			    categoryData = this.props.ADsByCat;

			if (!categoryData) {
				return;
			}

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'div',
					{ className: 'grade-header' + grade },
					_react2.default.createElement(
						'h2',
						null,
						grade
					)
				),
				_react2.default.createElement(
					'ul',
					{ className: 'area_description', ref: 'cat' + grade },
					Object.keys(categoryData).sort(this.alphanumCase).map(function (neighborhoodId) {
						if (grade == neighborhoodId.charAt(0)) {
							return _react2.default.createElement(
								'li',
								{
									key: 'cat' + grade + neighborhoodId,
									onClick: _this2.props.onNeighborhoodClick,
									onMouseEnter: _this2.props.onNeighborhoodHover,
									onMouseLeave: _this2.props.onNeighborhoodOut,
									id: neighborhoodId
								},
								_react2.default.createElement(
									'span',
									{ className: 'subcatName', id: neighborhoodId },
									neighborhoodId
								),
								_this2.props.neighborhoodNames[neighborhoodId] ? _react2.default.createElement(
									'span',
									{ className: 'subcatName', id: neighborhoodId },
									' ' + _this2.props.neighborhoodNames[neighborhoodId]
								) : '',
								':',
								typeof idiosyncraticDisplay === 'function' ? idiosyncraticDisplay(categoryData[neighborhoodId]) : _this2.renderDatum(categoryData[neighborhoodId])
							);
						}
					})
				)
			);
		}
	}, {
		key: 'renderDatum',
		value: function renderDatum(datum, neighborhoodId) {
			return _react2.default.createElement(
				'span',
				null,
				datum ? _react2.default.createElement(
					'span',
					{ className: 'subcatData' },
					datum
				) : _react2.default.createElement(
					'span',
					{ className: 'empty' },
					'empty'
				)
			);
		}
	}, {
		key: 'render19370203_5c',
		value: function render19370203_5c(data) {
			return _react2.default.createElement(
				'span',
				null,
				this.renderDatum(data[1]),
				'; ',
				this.renderDatum(data[2])
			);
		}
	}, {
		key: 'render19370203_5g',
		value: function render19370203_5g(data) {
			return _react2.default.createElement(
				'span',
				null,
				'Population is increasing ',
				this.renderDatum(data[1]),
				'; decreasing ',
				this.renderDatum(data[2]),
				'; static.'
			);
		}
	}, {
		key: 'render19370203_8a',
		value: function render19370203_8a(data) {
			return _react2.default.createElement(
				'span',
				null,
				this.renderDatum(data),
				'%'
			);
		}
	}, {
		key: 'render',
		value: function render() {

			var previousCat = this.props.previousCatIds,
			    nextCat = this.props.nextCatIds;

			return _react2.default.createElement(
				'div',
				{ className: 'ADCategory' },
				_react2.default.createElement(
					'h2',
					null,
					this.props.title,
					' ',
					_react2.default.createElement(
						'span',
						{ onClick: this.props.onClose },
						'x'
					)
				),
				this.props.previousCatIds ? _react2.default.createElement(
					'div',
					{
						className: 'adNav',
						style: this.props.previousStyle,
						onClick: this.props.onCategoryClick,
						id: this.getCategoryString.apply(this, _toConsumableArray(previousCat))
					},
					previousCat[1] ? previousCat[0] + previousCat[1] : previousCat[0]
				) : '',
				this.props.nextCatIds ? _react2.default.createElement(
					'div',
					{
						className: 'adNav',
						style: this.props.nextStyle,
						onClick: this.props.onCategoryClick,
						id: this.getCategoryString.apply(this, _toConsumableArray(nextCat))
					},
					nextCat[1] ? nextCat[0] + nextCat[1] : nextCat[0]
				) : '',
				this.renderGrade('A'),
				this.renderGrade('B'),
				this.renderGrade('C'),
				this.renderGrade('D')
			);
		}
	}]);

	return ADCat;
}(_react2.default.Component);

ADCat.propTypes = {};
ADCat.defaultProps = {
	catNum: undefined,
	catLetter: undefined
};
exports.default = ADCat;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","./SidebarNeighborhoodNav.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodNav.jsx","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/AreaDescription.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _SidebarNeighborhoodNav = require('./SidebarNeighborhoodNav.jsx');

var _SidebarNeighborhoodNav2 = _interopRequireDefault(_SidebarNeighborhoodNav);

var _SidebarNeighborhoodTitle = require('./SidebarNeighborhoodTitle.jsx');

var _SidebarNeighborhoodTitle2 = _interopRequireDefault(_SidebarNeighborhoodTitle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AreaDescription = function (_React$Component) {
	_inherits(AreaDescription, _React$Component);

	// property validation

	function AreaDescription() {
		_classCallCheck(this, AreaDescription);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(AreaDescription).call(this));
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(AreaDescription, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return true;
			return nextProps.areaId !== this.props.areaId || nextProps.cityId !== this.props.cityId || nextProps.previousStyle !== this.props.previousStyle;
		}
	}, {
		key: 'render',
		value: function render() {

			return _react2.default.createElement(
				'div',
				{ className: 'areaDescription' },
				_react2.default.createElement(_SidebarNeighborhoodTitle2.default, {
					areaId: this.props.areaId,
					name: this.props.neighborhoodNames[this.props.areaId],
					onClose: this.props.onClose
				}),
				this.props.previousAreaId ? _react2.default.createElement(_SidebarNeighborhoodNav2.default, {
					style: this.props.previousStyle,
					onHOLCIDClick: this.props.onHOLCIDClick,
					areaId: this.props.previousAreaId,
					name: this.props.neighborhoodNames[this.props.previousAreaId]
				}) : '',
				this.props.nextAreaId && this.props.nextAreaId !== 'null' ? _react2.default.createElement(_SidebarNeighborhoodNav2.default, {
					style: this.props.nextStyle,
					onHOLCIDClick: this.props.onHOLCIDClick,
					areaId: this.props.nextAreaId,
					name: this.props.neighborhoodNames[this.props.nextAreaId]
				}) : '',
				[19370203, 19370826].indexOf(parseInt(this.props.formId)) >= 0 ? this.renderNSForm8_19370203() : parseInt(this.props.formId) == 19371001 ? this.renderNSForm8_19371001() : null,
				_react2.default.createElement(
					'figure',
					{ className: 'adThumbnail' },
					_react2.default.createElement('img', { src: this.props.thumbnailUrl, onClick: this.props.onAdImageClicked }),
					_react2.default.createElement(
						'figcaption',
						null,
						'Click on the thumbnail to see a zoomable version.'
					)
				)
			);
		}
	}, {
		key: 'renderNSForm8_19370203',
		value: function renderNSForm8_19370203() {
			var AD = this.props.areaDescriptions;

			if (AD === false) {
				return;
			}

			return _react2.default.createElement(
				'ul',
				{ className: 'area_description NSForm8' },
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'1'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Name of City'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[1] && AD[1][1] ? AD[1][1] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						' Security Grade '
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[1] && AD[1][2] ? AD[1][2] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						' Area No. '
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[1] && AD[1][3] ? AD[1][3] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				this.renderSimpleCategory(2, 'Description of Terrain'),
				this.renderSimpleCategory(3, 'Favorable Influences'),
				this.renderSimpleCategory(4, 'Detrimental Influences'),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'5'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Inhabitants'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(5, 'a', 'Type'),
						this.renderSimpleSubcategory(5, 'b', 'Estimated annual family income'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: '5-c' },
								'c'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: '5-c' },
								'Foreign-born'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['c']['1'] ? AD[5]['c']['1'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								),
								'; ',
								AD[5] && AD[5]['c']['2'] ? AD[5]['c']['2'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: '5-d' },
								'd'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: '5-d' },
								'Negro'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['d']['1'] ? AD[5]['d']['1'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								),
								'; ',
								AD[5] && AD[5]['d']['2'] ? AD[5]['d']['2'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							)
						),
						this.renderSimpleSubcategory(5, 'e', 'Infiltration of'),
						this.renderSimpleSubcategory(5, 'f', 'Relief families'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: '5-g' },
								'g'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: '5-g' },
								'Population is increasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['g']['1'] ? AD[5]['g']['1'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName' },
								'; decreasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['g']['2'] ? AD[5]['g']['2'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							),
							';',
							_react2.default.createElement(
								'span',
								{ className: 'subcatName' },
								'; static'
							)
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'6'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Buildings'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(6, 'a', 'Type or Types'),
						this.renderSimpleSubcategory(6, 'b', 'Type of construction'),
						this.renderSimpleSubcategory(6, 'c', 'Average age'),
						this.renderSimpleSubcategory(6, 'd', 'Repair')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'7'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'History'
					),
					_react2.default.createElement(
						'table',
						null,
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Sales Values'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Year'
								),
								_react2.default.createElement(
									'th',
									null,
									'Range'
								),
								_react2.default.createElement(
									'th',
									null,
									'Predominating'
								),
								_react2.default.createElement(
									'th',
									null,
									'%'
								)
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'1929 level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][1] ? AD[7][1] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][2] ? AD[7][2] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									'100%'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7][5],
									' level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][6] ? AD[7][6] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][7] ? AD[7][7] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][8] ? AD[7][8] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7][12],
									'  level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][13] ? AD[7][13] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][14] ? AD[7][14] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][15] ? AD[7][15] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							)
						)
					),
					_react2.default.createElement(
						'table',
						null,
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Rental Values'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Year'
								),
								_react2.default.createElement(
									'th',
									null,
									'Range'
								),
								_react2.default.createElement(
									'th',
									null,
									'Predominating'
								),
								_react2.default.createElement(
									'th',
									null,
									'%'
								)
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'1929 level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][3] ? AD[7][3] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][4] ? AD[7][4] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									'100%'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7] && AD[7][5] ? AD[7][5] : '',
									' level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][9] ? AD[7][9] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][10] ? AD[7][10] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][11] ? AD[7][11] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7][12],
									'  level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][16] ? AD[7][16] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][17] ? AD[7][17] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][18] ? AD[7][18] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							)
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'percentage' },
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'Peak Sales values occurred in'
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][19] ? AD[7][19] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							' and were '
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][20] ? AD[7][20] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'% of the 1929 level.'
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'percentage' },
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'Peak rental values occurred in'
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][21] ? AD[7][21] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							' and were '
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][22] ? AD[7][22] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'% of the 1929 level.'
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'8'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Occupancy'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(8, 'a', 'Land'),
						this.renderSimpleSubcategory(8, 'b', 'Dwelling units'),
						this.renderSimpleSubcategory(8, 'c', 'Home Owners')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'9'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Sales Demand'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(9, 'a', ''),
						this.renderSimpleSubcategory(9, 'b', ''),
						this.renderSimpleSubcategory(9, 'c', 'Activity is')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'10'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Rental Demand'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(10, 'a', ''),
						this.renderSimpleSubcategory(10, 'b', ''),
						this.renderSimpleSubcategory(10, 'c', 'Activity is')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'11'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'New Construction'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(11, 'a', 'Types'),
						this.renderSimpleSubcategory(11, 'b', 'Amount last year')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'12'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Availability of Mortgage Funds'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(12, 'a', 'Home purchase'),
						this.renderSimpleSubcategory(12, 'b', 'Home building')
					)
				),
				this.renderSimpleCategory(13, 'Trend of Desireability Next 10-15 Years'),
				this.renderSimpleCategory(14, 'Clarifying Remarks'),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'15'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Information for this form was obtained from'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[15] && typeof AD[15] == 'string' ? AD[15] : AD[15] && AD[15][1] ? AD[15][1] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				_typeof(AD[15]) === 'object' ? _react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						'Date'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[15] && AD[15][2] ? AD[15][2] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						'193'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[15] && AD[15][3] ? AD[15][3] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				) : ''
			);
		}
	}, {
		key: 'renderNSForm8_19371001',
		value: function renderNSForm8_19371001() {
			var AD = this.props.areaDescriptions;

			if (AD === false) {
				return;
			}

			return _react2.default.createElement(
				'ul',
				{ className: 'area_description NSForm8' },
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'1'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Area Characteristics'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(1, 'a', 'Description of Terrain'),
						this.renderSimpleSubcategory(1, 'b', 'Favorable Influences'),
						this.renderSimpleSubcategory(1, 'c', 'Detrimental Influences'),
						this.renderSimpleSubcategory(1, 'd', 'Percentage of land improved'),
						this.renderSimpleSubcategory(1, 'e', 'Trend of desireability next 10-15 yrs.')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'2'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Inhabitants'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(2, 'a', 'Occupation'),
						this.renderSimpleSubcategory(2, 'b', 'Estimated Annual Family Income'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter' },
								'c'
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'Foreign-born families'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								this.renderSimpleData(2, 'c', 1)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'%;'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'c', 2)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'  predominating'
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter' },
								'd'
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'Negro'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								this.renderSimpleData(2, 'd', 1)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'%;'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'd', 2)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'  predominating'
							)
						),
						this.renderSimpleSubcategory(2, 'e', 'Infiltration of'),
						this.renderSimpleSubcategory(2, 'f', 'Relief families'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter' },
								'g'
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'Population is increasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'g', 1)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'; decreasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'g', 2)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'; static'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'g', 3)
							)
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'3'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Buildings'
					),
					_react2.default.createElement(
						'table',
						null,
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement('th', null),
								_react2.default.createElement(
									'th',
									null,
									'Predominating ',
									this.renderSimpleData(3, null, 1),
									'%'
								),
								_react2.default.createElement(
									'th',
									null,
									'Other Type ',
									this.renderSimpleData(3, null, 2),
									'%'
								),
								_react2.default.createElement(
									'th',
									null,
									'Other Type ',
									this.renderSimpleData(3, null, 3),
									'%'
								)
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'a'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Type'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'a', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'a', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'a', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'b'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Construction'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'b', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'b', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'b', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'c'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Average age'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'c', 1),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Years'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'c', 2),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Years'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'c', 3),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Years'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'd'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Repair'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'd', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'd', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'd', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'e'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Occupancy'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'e', 1),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'e', 2),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'e', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'f'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Home Ownership'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'f', 1),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'f', 2),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'f', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'g'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Constructed past yr.'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'g', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'g', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'g', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'h'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'1929 Price range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'h', 1),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'h', 2),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'h', 3),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'i'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'i', 1),
										' Price range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'i', 2),
									' ',
									this.renderSimpleData(3, 'i', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'i', 4),
									' ',
									this.renderSimpleData(3, 'i', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'i', 6),
									' ',
									this.renderSimpleData(3, 'i', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'j'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'j', 1),
										' Price range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'j', 2),
									' ',
									this.renderSimpleData(3, 'j', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'j', 4),
									' ',
									this.renderSimpleData(3, 'j', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'j', 6),
									' ',
									this.renderSimpleData(3, 'j', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'k'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Sales demand Up to'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'k', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									'Up to ',
									this.renderSimpleData(3, 'k', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'k', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'l'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Activity'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'l', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'l', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'l', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'm'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'1929 Rent range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'm', 1),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'm', 2),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'm', 3),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'n'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'n', 1),
										' Rent range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'n', 2),
									' ',
									this.renderSimpleData(3, 'n', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'n', 4),
									' ',
									this.renderSimpleData(3, 'n', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'n', 6),
									' ',
									this.renderSimpleData(3, 'n', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'o'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'o', 1),
										' Rent range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'o', 2),
									' ',
									this.renderSimpleData(3, 'o', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'o', 4),
									' ',
									this.renderSimpleData(3, 'o', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'o', 6),
									' ',
									this.renderSimpleData(3, 'o', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'p'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Rental demand Up to'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'p', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									'Up to ',
									this.renderSimpleData(3, 'p', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'p', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'q'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Activity'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'q', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'q', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'q', 3)
								)
							)
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'4'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Availability of Mortgage Funds'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(4, 'a', 'Home purchase'),
						this.renderSimpleSubcategory(4, 'b', 'Home building')
					)
				),
				this.renderSimpleCategory(5, 'Clarifying Remarks'),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'6'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Name and Location'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[6] && AD[6][1] ? AD[6][1] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Security Grade'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[6] && AD[6][2] ? AD[6][2] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Area No.'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[6] && AD[6][3] ? AD[6][3] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				)
			);
		}
	}, {
		key: 'renderSimpleCategory',
		value: function renderSimpleCategory(catNum, catName) {
			var AD = this.props.areaDescriptions;

			return _react2.default.createElement(
				'li',
				{ key: 'AD-' + catNum },
				_react2.default.createElement(
					'span',
					{ className: 'catNum catSelectable', onClick: this.props.onCategoryClick, id: catNum },
					catNum
				),
				_react2.default.createElement(
					'span',
					{ className: 'catName catSelectable', onClick: this.props.onCategoryClick, id: catNum },
					catName
				),
				_react2.default.createElement(
					'span',
					{ className: 'catData' },
					AD[catNum] ? AD[catNum] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				)
			);
		}
	}, {
		key: 'renderSimpleSubcategory',
		value: function renderSimpleSubcategory(catNum, catLetter, subcatName) {
			var AD = this.props.areaDescriptions;

			if (AD === false) {
				return;
			}

			if (!AD[catNum]) {
				console.warn(catNum + catLetter + ' is not defined', AD);
				return;
			}

			if (_typeof(AD[catNum][catLetter]) == 'object') {
				console.warn(catNum + catLetter + ' is an object when a string was expected');
			}
			return _react2.default.createElement(
				'li',
				null,
				_react2.default.createElement(
					'span',
					{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: catNum + '-' + catLetter },
					catLetter
				),
				_react2.default.createElement(
					'span',
					{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: catNum + '-' + catLetter },
					subcatName
				),
				_react2.default.createElement(
					'span',
					{ className: 'subcatData' },
					AD[catNum] && AD[catNum][catLetter] && _typeof(AD[catNum][catLetter]) !== 'object' ? AD[catNum][catLetter] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				)
			);
		}
	}, {
		key: 'renderSimpleData',
		value: function renderSimpleData(catNum) {
			var subcatLetter = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
			var order = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

			var AD = this.props.areaDescriptions;
			if (order == null) {
				return _react2.default.createElement(
					'span',
					null,
					AD[catNum] && AD[catNum][subcatLetter] ? AD[catNum][subcatLetter] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				);
			} else if (subcatLetter == '') {
				return _react2.default.createElement(
					'span',
					null,
					AD[catNum] && AD[catNum][order] ? AD[catNum][order] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				);
			} else {
				return _react2.default.createElement(
					'span',
					null,
					AD[catNum] && AD[catNum][subcatLetter] && AD[catNum][subcatLetter][order] ? AD[catNum][subcatLetter][order] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				);
			}
		}
	}]);

	return AreaDescription;
}(_react2.default.Component);

AreaDescription.propTypes = {
	areaDescriptions: _react2.default.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.bool])
};
AreaDescription.defaultProps = {
	areaDescriptions: {}
};
exports.default = AreaDescription;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","./SidebarNeighborhoodNav.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodNav.jsx","./SidebarNeighborhoodTitle.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodTitle.jsx","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/AreaPolygon.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _reactLeaflet = require('react-leaflet');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AreaPolygon = function (_GeoJson) {
	_inherits(AreaPolygon, _GeoJson);

	function AreaPolygon() {
		_classCallCheck(this, AreaPolygon);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(AreaPolygon).apply(this, arguments));
	}

	_createClass(AreaPolygon, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			if (nextProps.data !== this.props.data) {
				this.leafletElement.clearLayers();
			}
			if (nextProps.className !== this.props.className) {
				this.leafletElement.options.className = nextProps.className;
			}

			if (nextProps.fillOpacity !== this.props.fillOpacity) {
				console.log(this.leafletElement);
				this.leafletElement.options.fillOpacity = nextProps.fillOpacity;
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (prevProps.data !== this.props.data) {
				this.leafletElement.addData(this.props.data);
			}
			this.setStyleIfChanged(prevProps.style, this.props.style);
		}
	}]);

	return AreaPolygon;
}(_reactLeaflet.GeoJson);

exports.default = AreaPolygon;


AreaPolygon.propTypes = {
	data: _react.PropTypes.object.isRequired
};

},{"react":"react","react-leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/CitySnippet.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _d = require('d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CitySnippet = function (_React$Component) {
	_inherits(CitySnippet, _React$Component);

	function CitySnippet() {
		_classCallCheck(this, CitySnippet);

		//this.d3Chart = this.d3Chart.bind(this);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CitySnippet).call(this));

		_this.d3PieChart = {
			radius: 30,

			update: function update(node, gradeStats) {
				if (Object.keys(gradeStats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;

				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#f4f570', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#A3A34B', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#f4f570', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var pie = d3.layout.pie().value(function (d) {
					return d.percent;
				}).sort(null);
				var arc = d3.svg.arc().outerRadius(scope.radius - 10).innerRadius(0);
				var percent = d3.format(',%');

				var theChart = d3.select(node).append('svg').attr('width', scope.radius * 2).attr('height', scope.radius * 2).attr('id', 'piechart').append('g').attr('transform', 'translate(' + scope.radius + ',' + scope.radius + ')');

				// theChart
				//   .selectAll('rect')
				//   .data(gradeStats)
				//   .enter().append('rect')
				//   //.attr('class', (d,i,j) => 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1))
				//   .attr('height', scope.HEIGHT)
				//   .attr('width', (d) => d.width)
				//   .attr('opacity', .7)
				//   .attr('y', 0)
				//   .attr('x', (d) => d.x + scope.MARGIN)
				//   .attr('fill', (d) => colorGrade(d.grade));

				theChart.selectAll('path').data(pie(gradeStats)).enter().append('path').attr("d", arc).filter(function (d) {
					return d.data.percent > 0;
				}).attr('fill', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('stroke-width', 0).attr('class', function (d) {
					return 'sliceGrade' + d.data.grade;
				});
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		_this.d3BarChart = {
			// layout constants
			WIDTH: 90,
			HEIGHT: 40,
			MARGIN: 24,

			update: function update(node, gradeStats) {
				var width = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

				if (Object.keys(gradeStats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;

				if (width) {
					//scope.WIDTH = width;
				}

				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#f4f570', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#A3A34B', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#CCCC00', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var percent = d3.format(',%');
				var width = d3.scale.linear().rangeRound([0, scope.WIDTH]);

				var x = 0;
				gradeStats.forEach(function (d, i) {
					gradeStats[i] = { x: x, width: width(d.percent), percent: d.percent, grade: d.grade };
					x += width(d.percent);
				});

				var theChart = d3.select(node).append('svg').attr('width', scope.WIDTH).attr('height', scope.HEIGHT + scope.MARGIN).attr('id', 'barchart').selectAll('g').data(gradeStats).enter().append('g');

				theChart.selectAll('rect').data(gradeStats).enter().append('rect')
				//.attr('class', (d,i,j) => 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1))
				.attr('height', scope.HEIGHT / 4 - 4).attr('width', function (d) {
					return d.width;
				}).attr('opacity', .7).attr('y', function (d, i) {
					return scope.MARGIN + scope.HEIGHT / 4 * i;
				}).attr('x', function (d) {
					return scope.WIDTH - d.width;
				}).attr('fill', function (d) {
					return colorGrade(d.grade);
				});

				// theChart
				//   .selectAll('text')
				//   .data(gradeStats)
				//   .enter().append('text')
				//   .attr('x', (d) => d.x + d.width / 2 + scope.MARGIN)
				//   .attr('y', 11)
				//   .attr('text-anchor', 'middle')
				//   .attr('font-family', 'sans-serif')
				//   .attr('font-size', '10px')
				//   .attr('fill', (d) => (d.grade == 'C') ? 'black' : 'white')
				//   .text((d) => (d.percent > 0.03) ? percent(d.percent) : '');
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		_this.d3Chart = {
			// layout constants
			WIDTH: _this.props && _this.props.areaChartWidth ? _this.props.areaChartWidth : 250,
			HEIGHT: 15,
			MARGIN: 20,

			update: function update(node, gradeStats) {
				var width = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

				if (Object.keys(gradeStats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;

				if (width) {
					//scope.WIDTH = width;
				}

				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#f4f570', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#A3A34B', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#f4f570', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var percent = d3.format(',%');
				var width = d3.scale.linear().rangeRound([0, scope.WIDTH]);

				var x = 0;
				gradeStats.forEach(function (d, i) {
					gradeStats[i] = { x: x, width: width(d.percent), percent: d.percent, grade: d.grade };
					x += width(d.percent);
				});

				var theChart = d3.select(node).append('svg').attr('width', scope.WIDTH + scope.MARGIN).attr('height', scope.HEIGHT).attr('id', 'barchart').selectAll('g').data(gradeStats).enter().append('g');

				theChart.selectAll('rect').data(gradeStats).enter().append('rect')
				//.attr('class', (d,i,j) => 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1))
				.attr('height', scope.HEIGHT).attr('width', function (d) {
					return d.width;
				}).attr('opacity', .7).attr('y', 0).attr('x', function (d) {
					return d.x + scope.MARGIN;
				}).attr('fill', function (d) {
					return colorGrade(d.grade);
				});

				theChart.selectAll('text').data(gradeStats).enter().append('text').attr('x', function (d) {
					return d.x + d.width / 2 + scope.MARGIN;
				}).attr('y', 11).attr('text-anchor', 'middle').attr('font-family', 'sans-serif').attr('font-size', '10px').attr('fill', function (d) {
					return d.grade == 'C' ? 'black' : 'white';
				}).text(function (d) {
					return d.percent > 0.03 ? percent(d.percent) : '';
				});
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		return _this;
	}
	// property validation


	_createClass(CitySnippet, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.cityData.city !== this.props.cityData.city;
		}
	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.cityData.hasPolygons) {
				//this.d3Chart.update(this.refs.barchart, this.parsePercents(), this.props.areaChartWidth);
				//this.d3PieChart.update(this.refs.piechart, this.parsePercents());
				this.d3BarChart.update(this.refs.barchart, this.parsePercents());
			}
		}
	}, {
		key: 'parsePercents',
		value: function parsePercents() {

			return this.props.cityData.hasPolygons ? [{ 'grade': 'A', 'percent': this.props.cityData.area.a / this.props.cityData.area.total }, { 'grade': 'B', 'percent': this.props.cityData.area.b / this.props.cityData.area.total }, { 'grade': 'C', 'percent': this.props.cityData.area.c / this.props.cityData.area.total }, { 'grade': 'D', 'percent': this.props.cityData.area.d / this.props.cityData.area.total }] : false;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'city-snippet',
					onClick: this.props.onCityClick,
					id: this.props.cityData.ad_id
				},
				this.props.cityData.hasADs ? _react2.default.createElement(
					'h4',
					null,
					'area descriptions available'
				) : '',
				this.props.cityData.hasPolygons ? _react2.default.createElement('div', { className: 'barchart', ref: 'barchart' }) : null,
				_react2.default.createElement(
					'h3',
					null,
					this.props.cityData.name + (this.props.displayState ? ', ' + this.props.cityData.state : '')
				),
				_react2.default.createElement(
					'div',
					{ className: 'populationStats' },
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Population (1940):'
					),
					' ',
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						this.props.cityData.population_1940.toLocaleString()
					)
				),
				this.render_population_details()
			);
		}
	}, {
		key: 'render_population_details',
		value: function render_population_details() {
			var CD = this.props.cityData,
			    aggregated_pop = CD.white_pop_1940 + CD.black_pop_1940 + CD.asian_pacific_islander_1940 + CD.american_indian_eskimo_1940;
			if (aggregated_pop == 0) {
				return false;
			} else {
				var proportions = [{
					'label': 'white',
					'proportion': CD.white_pop_1940 / aggregated_pop
				}, {
					'label': 'African American',
					'proportion': CD.black_pop_1940 / aggregated_pop
				}, {
					'label': 'Asian American',
					'proportion': CD.asian_pacific_islander_1940 / aggregated_pop
				}, {
					'label': 'Native American',
					'proportion': CD.american_indian_eskimo_1940 / aggregated_pop
				}];
				proportions.sort(function (a, b) {
					return a.proportion < b.proportion;
				});
				return _react2.default.createElement(
					'ul',
					null,
					proportions.map(function (pop) {
						if (Math.round(pop.proportion * 100) !== 0) {
							return _react2.default.createElement(
								'li',
								{ key: 'pop1940' + pop.label.replace(/ /g, '') },
								Math.round(pop.proportion * 100) + '% ' + pop.label
							);
						}
					})
				);
			}
		}
	}]);

	return CitySnippet;
}(_react2.default.Component);

CitySnippet.propTypes = {
	cityData: _react.PropTypes.object
};
exports.default = CitySnippet;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","d3":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/d3/d3.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/CityStats.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _d = require('d3');

var d3 = _interopRequireWildcard(_d);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CityStats = function (_React$Component) {
	_inherits(CityStats, _React$Component);

	// property validation

	function CityStats(props) {
		_classCallCheck(this, CityStats);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CityStats).call(this, props));

		_this.d3NestedPieChart = {
			// layout constants
			HEADER: 25,
			WIDTH: 250,
			DIAMETER: 250, // of the donut
			STATSHEIGHT: 18,
			DONUTWIDTH: 35,
			MARGIN: 10,

			update: function update(node, ringstats, gradeStats) {
				if (Object.keys(ringstats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;
				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#ffdf00', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#ffdf00', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#ffdf00', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var pie = d3.layout.pie().value(function (d) {
					return d.percent;
				}).sort(null);
				var arc = d3.svg.arc().innerRadius(function (d) {
					return (d.data.ringId - 1.5) * scope.DONUTWIDTH;
				}).outerRadius(function (d) {
					return (d.data.ringId - 0.5) * scope.DONUTWIDTH;
				});
				var arcBorder = d3.svg.arc().innerRadius(function (d) {
					return (d.data.ringId - 0.5) * scope.DONUTWIDTH;
				}).outerRadius(function (d) {
					return (d.data.ringId - 0.5) * scope.DONUTWIDTH;
				});
				var percent = d3.format(',%');

				// <g> for each ring
				var ringNodes = d3.select(node).append('svg').attr('width', scope.WIDTH).attr('height', scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER).attr('id', 'piechart').selectAll('g').data(ringstats).enter().append('g');
				//.attr('transform', 'translate(' + (scope.WIDTH / 2) + ',' + (scope.HEIGHT / 2 + 50) + ')');

				// path for each pie piece
				var burgess = ringNodes.selectAll('path').data(function (d) {
					return pie(d.percents);
				}).enter().append('path').filter(function (d) {
					return d.data.percent > 0;
				}).attr('transform', 'translate(' + scope.WIDTH / 2 + ',' + (scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')').attr('d', arc).attr('fill', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('fill-opacity', function (d) {
					return d.data.opacity;
				}).attr('stroke', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('stroke-width', 0).attr('data-opacity', function (d) {
					return d.data.opacity;
				}).attr('class', function (d) {
					return 'sliceGrade' + d.data.grade;
				}).on('mouseover', function (d) {
					d3.select(this).transition().duration(2000).attr('fill-opacity', 1);
					d3.select('#ring' + d.data.ringId + 'grade' + d.data.grade).attr('opacity', 1);
					d3.selectAll('.areaBar').transition().duration(2000).attr('height', scope.STATSHEIGHT * 0.5).attr('y', scope.HEADER + scope.MARGIN + scope.STATSHEIGHT * 0.25).attr('opacity', .25);
					d3.selectAll('.barGrade' + d.data.grade).filter('.ring' + d.data.ringId).attr('height', scope.STATSHEIGHT).attr('y', scope.HEADER + scope.MARGIN).transition().duration(2000).attr('opacity', 1);
					d3.selectAll('.barGradePercent' + d.data.grade).filter('.ring' + d.data.ringId).transition().duration(500).attr('opacity', 1);
					d3.selectAll('.overallPercent').transition().attr('opacity', 0);
					scope.onHover(d.data.ringId, d.data.grade);
				}).on('mouseout', function (d) {
					scope.onHoverOut();
					d3.select(this).transition().attr('fill-opacity', function (d) {
						return d.data.opacity;
					});
					d3.select('#ring' + d.data.ringId + 'grade' + d.data.grade).attr('opacity', 0);
					d3.selectAll('.areaBar').transition().duration(2000).attr('height', scope.STATSHEIGHT).attr('y', scope.HEADER + scope.MARGIN).attr('opacity', .7);
					d3.selectAll('.areaBarPercent').transition().attr('opacity', 0);
					d3.selectAll('.overallPercent').transition().attr('opacity', 1);
				});

				// add thin stroke line for each slice of pies
				ringNodes.selectAll('path.border').data(function (d) {
					return pie(d.percents);
				}).enter().append('path').classed('border', true).attr('transform', 'translate(' + scope.WIDTH / 2 + ',' + (scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')').attr('d', arcBorder).attr('fill', function (d, i) {
					return color(i);
				}).attr('stroke', function (d, i) {
					return colorBorder(i);
				}).attr('stroke-width', 0.25).attr('stroke-opacity', 0.7);

				// a tranparent border around each slice
				// it's made opaque for highlighting and thus needs
				// to be added after the slice and the border
				ringNodes.selectAll('paths.sliceBorder').data(function (d) {
					return pie(d.percents);
				}).enter().append('path').filter(function (d) {
					return d.data.percent > 0;
				}).attr('transform', 'translate(' + scope.WIDTH / 2 + ',' + (scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')').attr('d', arc).attr('fill-opacity', 0).attr('stroke', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('stroke-width', 0).attr('pointer-events', 'none').attr('class', function (d) {
					return 'sliceBorder grade' + d.data.grade;
				});

				// add text for each slice of pie
				ringNodes.selectAll('text.burgessSlicePercent').data(function (d) {
					return pie(d.percents);
				}).enter().append('text').filter(function (d) {
					return d.data.percent > 0;
				}).attr('transform', function (d) {
					return 'translate(' + (arc.centroid(d)[0] + scope.WIDTH / 2) + ',' + (arc.centroid(d)[1] + scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')';
				}).attr('text-anchor', 'middle').style('font', '11px Arial').attr('dy', 5.5).attr('opacity', 0).attr('id', function (d) {
					return 'ring' + d.data.ringId + 'grade' + d.data.grade;
				}).attr('class', function (d) {
					return 'burgessSlicePercent grade' + d.data.grade;
				}).attr('fill', function (d) {
					return d.data.grade == 'C' ? 'black' : 'white';
				}).attr('pointer-events', 'none').text(function (d) {
					return percent(d.value);
				});

				ringNodes.selectAll('rect').data(ringstats).enter().append('rect').attr('class', function (d, i, j) {
					return 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1);
				}).attr('height', scope.STATSHEIGHT).attr('width', function (d, i, j) {
					return Math.round(d.percents[j].overallPercent * scope.WIDTH);
				}).attr('opacity', .7).attr('y', scope.HEADER + scope.MARGIN).attr('x', function (d, i, j) {
					var x = 0;
					for (var j0 = 0; j0 <= 3; j0++) {
						for (var i0 = 0; i0 <= 3; i0++) {
							if (ringstats[j0].percents[i0].grade < d.percents[j].grade || ringstats[j0].percents[i0].grade == d.percents[j].grade && ringstats[j0].percents[i0].ringId < d.percents[j].ringId) {
								x += Math.round(ringstats[j0].percents[i0].overallPercent * scope.WIDTH);
							}
						}
					}
					return x;
				}).attr('fill', function (d, i, j) {
					return color(j);
				}).on('mouseover', function (d, i, j) {
					var grade = ['A', 'B', 'C', 'D'][j];
					d3.selectAll('.areaBar').transition().duration(1000).attr('opacity', .4);
					d3.selectAll('rect.barGrade' + grade).transition().duration(1000).attr('opacity', 1);
					d3.selectAll('.sliceBorder').filter('.grade' + grade).transition().duration(1000).attr('stroke-width', 5);
					d3.selectAll('.burgessSlicePercent').filter('.grade' + grade).filter(function (d) {
						return d.data.percent > .06;
					}).transition().attr('fill', 'black').attr('opacity', 1);
					scope.onGradeHover(grade);
				}).on('mouseout', function (d, i, j) {
					var grade = ['A', 'B', 'C', 'D'][j];
					d3.selectAll('.areaBar').transition().attr('opacity', .7);
					d3.selectAll('.sliceBorder').transition().attr('stroke-width', 0);
					d3.selectAll('.burgessSlicePercent').transition().attr('opacity', 0).attr('fill', function (d) {
						return d.data.grade == 'C' ? 'black' : 'white';
					});
					scope.onGradeHoverOut();
				});

				// percents for each of these slices in the area chart
				ringNodes.selectAll('text.slicePercent').data(ringstats).enter().append('text').attr('x', function (d, i, j) {
					var x = 0;
					for (var j0 = 0; j0 <= 3; j0++) {
						for (var i0 = 0; i0 <= 3; i0++) {
							if (ringstats[j0].percents[i0].grade < d.percents[j].grade || ringstats[j0].percents[i0].grade == d.percents[j].grade && ringstats[j0].percents[i0].ringId < d.percents[j].ringId) {
								x += Math.round(ringstats[j0].percents[i0].overallPercent * scope.WIDTH);
							}
						}
					}
					x += Math.round(d.percents[j].overallPercent * scope.WIDTH / 2);
					return x;
				}).attr('y', scope.HEADER + scope.MARGIN + 13).attr('class', function (d, i, j) {
					return 'areaBarPercent barGradePercent' + d.percents[j].grade + ' ring' + (i + 1);
				}).attr('pointer-events', 'none').attr('text-anchor', 'middle').attr('font-family', 'sans-serif').attr('font-size', '10px').attr('fill', function (d, i, j) {
					return d.percents[j].grade == 'C' ? 'black' : 'white';
				}).attr('opacity', 0).text(function (d, i, j) {
					return percent(d.percents[j].overallPercent);
				});

				ringNodes.selectAll('text.overallPercent').data(gradeStats).enter().append('text').attr('x', function (d, i) {
					var x = d.percent * scope.WIDTH / 2;
					for (var i0 = 0; i0 < i; i0++) {
						x += gradeStats[i0].percent * scope.WIDTH;
					}
					return x;
				}).attr('y', scope.HEADER + scope.MARGIN + 13).attr('pointer-events', 'none').attr('text-anchor', 'middle').attr('font-family', 'sans-serif').attr('font-size', '10px').attr('fill', function (d) {
					return d.grade == 'C' ? 'black' : 'white';
				}).classed('overallPercent', true).text(function (d) {
					return percent(d.percent);
				});

				ringNodes.append('text').attr('x', scope.WIDTH / 2).attr('y', scope.HEADER).attr('text-anchor', 'middle').text('Grading in Terms of Area');

				ringNodes.append('text').attr('x', scope.WIDTH / 2).attr('y', scope.HEADER + scope.MARGIN * 4 + scope.STATSHEIGHT).attr('text-anchor', 'middle').text('Grading & Density Outward');

				ringNodes.append('text').attr('x', scope.WIDTH / 2).attr('y', scope.HEADER * 2 + scope.MARGIN * 4 + scope.STATSHEIGHT).attr('text-anchor', 'middle').text('from City Center');

				d3.xml('static/burgess.svg').get(function (error, xml) {
					if (error) throw error;

					var burgessDiagram = ringNodes.node().appendChild(xml.documentElement);

					var innerSVG = ringNodes.select("svg");

					innerSVG.attr('x', -5).attr('y', 102);

					innerSVG.transition().duration(10000).attr('opacity', .35);
				});
			},

			onHover: function onHover() {
				// bound in componentDidMount to the areaSelected method of App (passed in as a props)
			},

			onHoverOut: function onHoverOut() {
				// bound in componentDidMount to the areaUnselected metthod of App
			},

			onGradeHover: function onGradeHover() {
				// bound in componentDidMount to the gradeSelected method of App (passed in as a props)
			},

			onGradeHoverOut: function onGradeHoverOut() {
				// bound in componentDidMount to the gradeUnselected metthod of App
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		return _this;
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(CityStats, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps, nextState) {
			if (nextProps.hasADs !== this.props.hasADs) {
				return true;
			}
			// don't know why this is necessary, but the component is updating on mouseover--this prevents that.
			return nextProps.burgessDiagramVisible !== this.props.burgessDiagramVisible || nextProps.ringStats !== this.props.ringStats;
		}
	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.d3NestedPieChart.onHover = this.props.areaSelected.bind(this);
			this.d3NestedPieChart.onHoverOut = this.props.areaUnselected.bind(this);
			this.d3NestedPieChart.onGradeHover = this.props.gradeSelected.bind(this);
			this.d3NestedPieChart.onGradeHoverOut = this.props.gradeUnselected.bind(this);
			if (this.props.ringStats) {
				this.d3NestedPieChart.update(this.refs.content, this.props.ringStats, this.props.gradeStats);
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			this.d3NestedPieChart.destroy(this.refs.content);
			this.d3NestedPieChart.onHover = this.props.areaSelected.bind(this);
			this.d3NestedPieChart.onHoverOut = this.props.areaUnselected.bind(this);
			this.d3NestedPieChart.onGradeHover = this.props.gradeSelected.bind(this);
			this.d3NestedPieChart.onGradeHoverOut = this.props.gradeUnselected.bind(this);
			if (this.props.ringStats) {
				this.d3NestedPieChart.update(this.refs.content, this.props.ringStats, this.props.gradeStats);
			}
		}
	}, {
		key: 'areaHover',
		value: function areaHover(selectedRingId, selectedGrade) {
			_AppActionCreator.AppActions.ringAreaSelected(selectedRingId, selectedGrade);
		}
	}, {
		key: 'getPopLabel',
		value: function getPopLabel(key) {
			var labels = {
				white: 'white',
				black: 'African American',
				asianAmerican: 'Asian American',
				nativeAmerican: 'Native American'
			};

			return labels[key];
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var burgessClassName = this.props.burgessDiagramVisible ? '' : 'hidden',
			    population1930 = this.props.cityData.population_1930 && this.props.cityData.population_1930 !== 0 ? this.props.cityData.population_1930.toLocaleString() : null,
			    population1940 = this.props.cityData.population_1940 && this.props.cityData.population_1940 !== 0 ? this.props.cityData.population_1940.toLocaleString() : null,
			    area = this.props.area ? Math.round(this.props.area * 100) / 100 + 'sq mi' : '';

			var CD = this.props.cityData,
			    aggregated_pop_1930 = CD.white_pop_1930 + CD.black_pop_1930 + CD.asian_pacific_ilslander_1930 + CD.american_indian_eskimo_1930,
			    aggregated_pop_1940 = CD.white_pop_1940 + CD.black_pop_1940 + CD.asian_pacific_ilslander_1940 + CD.american_indian_eskimo_1940,
			    popStats = {
				1930: {
					//total: (this.props.cityData.population_1930 && this.props.cityData.population_1930 !== 0) ? this.props.cityData.population_1930 : null,
					white: CD.white_pop_1930 / aggregated_pop_1930,
					black: CD.black_pop_1930 / aggregated_pop_1930,
					asianAmerican: CD.asian_pacific_ilslander_1930 / aggregated_pop_1930,
					nativeAmerican: CD.american_indian_eskimo_1930 / aggregated_pop_1930
				},
				1940: {
					//total: (this.props.cityData.population_1940 && this.props.cityData.population_1940 !== 0) ? this.props.cityData.population_1940 : null,
					white: CD.white_pop_1940 / aggregated_pop_1940,
					black: CD.black_pop_1940 / aggregated_pop_1940,
					asianAmerican: CD.asian_pacific_ilslander_1940 / aggregated_pop_1940,
					nativeAmerican: CD.american_indian_eskimo_1940 / aggregated_pop_1940
				}
			};

			var orderedKeys = Object.keys(popStats[1940]).sort(function (a, b) {
				return popStats[1940][a] < popStats[1940][b];
			});

			return _react2.default.createElement(
				'div',
				{ className: 'cityStats' },
				_react2.default.createElement(
					'h2',
					null,
					this.props.name + ', ',
					_react2.default.createElement(
						'span',
						{
							//onClick={ this.onStateSelected }
							id: this.props.state
						},
						this.props.state
					),
					_react2.default.createElement('div', { className: 'downloadicon', onClick: this.props.onDownloadClicked })
				),
				this.props.hasADs ? _react2.default.createElement(
					'div',
					{ className: 'adInstructions' },
					'click on neighborhoods on the map to read their area description'
				) : _react2.default.createElement(
					'div',
					{ className: 'adInstructions' },
					'area descriptions aren\'t available for this city, but will be soon'
				),
				_react2.default.createElement(
					'table',
					{ className: 'population-stats' },
					_react2.default.createElement(
						'tbody',
						null,
						_react2.default.createElement(
							'tr',
							null,
							_react2.default.createElement('th', null),
							_react2.default.createElement(
								'th',
								null,
								'1930'
							),
							_react2.default.createElement(
								'th',
								null,
								'1940'
							)
						),
						_react2.default.createElement(
							'tr',
							null,
							_react2.default.createElement(
								'td',
								null,
								'Population'
							),
							_react2.default.createElement(
								'td',
								{ className: 'total', key: 'total1930' },
								population1930
							),
							_react2.default.createElement(
								'td',
								{ className: 'total', key: 'total1940' },
								population1940
							)
						),
						orderedKeys.map(function (popkey) {
							return popStats[1930][popkey] > 0.01 || popStats[1930][popkey] > 0.01 ? _react2.default.createElement(
								'tr',
								{ key: popkey },
								_react2.default.createElement(
									'td',
									null,
									_this2.getPopLabel(popkey)
								),
								_react2.default.createElement(
									'td',
									null,
									Math.round(popStats[1930][popkey] * 1000) / 10 + '%'
								),
								_react2.default.createElement(
									'td',
									null,
									Math.round(popStats[1940][popkey] * 1000) / 10 + '%'
								)
							) : null;
						})
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'nestedpiechart' },
					_react2.default.createElement(
						'button',
						{
							className: 'intro-button'

						},
						_react2.default.createElement('span', { className: 'icon info', id: 'burgess', onClick: this.props.openBurgess })
					),
					this.props.ringStats ? _react2.default.createElement('div', { className: 'content', ref: 'content' }) : _react2.default.createElement(
						'p',
						null,
						'Area descriptions are not yet available but will be eventually.'
					)
				)
			);
		}
	}]);

	return CityStats;
}(_react2.default.Component);

CityStats.propTypes = {
	ringStats: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.bool]),
	gradeStats: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.bool]),
	areaSelected: _react.PropTypes.func,
	areaUnselected: _react.PropTypes.func,
	gradeSelected: _react.PropTypes.func,
	gradeUnselected: _react.PropTypes.func,
	toggleBurgessDiagram: _react.PropTypes.func,
	burgessDiagramVisible: _react.PropTypes.bool,
	cityData: _react.PropTypes.object
};
CityStats.defaultProps = {
	name: '',
	ringStats: {
		1: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 },
		2: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 },
		3: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 },
		4: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 }
	},
	gradeStats: {
		'A': { 'area': 0, 'percent': 0 },
		'B': { 'area': 0, 'percent': 0 },
		'C': { 'area': 0, 'percent': 0 },
		'D': { 'area': 0, 'percent': 0 }
	}
};
exports.default = CityStats;
;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","d3":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/d3/d3.js","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/Donut/Donut.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactLeaflet = require('react-leaflet');

var _LDonut = require('./L.Donut.js');

var _LDonut2 = _interopRequireDefault(_LDonut);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Donut = function (_Path) {
	_inherits(Donut, _Path);

	// Radii are in meters

	function Donut() {
		_classCallCheck(this, Donut);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(Donut).call(this));
	}

	_createClass(Donut, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			var _props = this.props;
			var center = _props.center;
			var outerRadius = _props.outerRadius;
			var innerRadius = _props.innerRadius;

			var props = _objectWithoutProperties(_props, ['center', 'outerRadius', 'innerRadius']);

			_get(Object.getPrototypeOf(Donut.prototype), 'componentWillMount', this).call(this);
			this.leafletElement = new _LDonut2.default(center, outerRadius, innerRadius, props);
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (this.props.center !== prevProps.center) {
				this.leafletElement.setLatLng(this.props.center);
			}

			if (this.props.outerRadius !== prevProps.outerRadius || this.props.innerRadius !== prevProps.innerRadius) {
				this.leafletElement.setRadius(this.props.outerRadius, this.props.innerRadius);
			}

			this.setStyleIfChanged(prevProps, this.props);
		}
	}]);

	return Donut;
}(_reactLeaflet.Path);

Donut.propTypes = {
	center: _reactLeaflet.PropTypes.latlng.isRequired,
	outerRadius: _react.PropTypes.number.isRequired,
	innerRadius: _react.PropTypes.number.isRequired
};
Donut.defaultProps = {};
exports.default = Donut;

},{"./L.Donut.js":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/Donut/L.Donut.js","react":"react","react-leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/Donut/L.Donut.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _leaflet = require('leaflet');

var L = _interopRequireWildcard(_leaflet);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Donut = function (L) {

	return L.Circle.extend({

		initialize: function initialize(latlng, outerRadius, innerRadius, options) {
			L.Path.prototype.initialize.call(this, options);

			this._latlng = L.latLng(latlng);
			this._mOuterRadius = outerRadius;
			this._mInnerRadius = this._validateInnerRadius(outerRadius, innerRadius);
		},

		setRadius: function setRadius(outerRadius, innerRadius) {
			this._mOuterRadius = outerRadius;
			this._mInnerRadius = this._validateInnerRadius(outerRadius, innerRadius);
			return this.redraw();
		},

		projectLatlngs: function projectLatlngs() {
			var lngRadius = this._getLngRadius(),
			    latlng = this._latlng,
			    outerPointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius[0]]),
			    innerPointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius[1]]);

			this._point = this._map.latLngToLayerPoint(latlng);
			this._outerRadius = Math.max(this._point.x - outerPointLeft.x, 1);
			this._innerRadius = Math.max(this._point.x - innerPointLeft.x, 1);
		},

		getBounds: function getBounds() {
			var lngRadius = this._getLngRadius()[0],
			    latRadius = this._getLatRadius()[0],
			    latlng = this._latlng;

			return new L.LatLngBounds([latlng.lat - latRadius, latlng.lng - lngRadius], [latlng.lat + latRadius, latlng.lng + lngRadius]);
		},

		getRadius: function getRadius() {
			return [this._mOuterRadius, this._mInnerRadius];
		},

		_getLatRadius: function _getLatRadius() {
			return [this._mOuterRadius / 40075017 * 360, this._mInnerRadius / 40075017 * 360];
		},

		_getLngRadius: function _getLngRadius() {
			var radii = this._getLatRadius();

			return [radii[0] / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat), radii[1] / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat)];
		},

		_checkIfEmpty: function _checkIfEmpty() {
			if (!this._map) {
				return false;
			}

			var vp = this._map._pathViewport,
			    outerRadius = this._outerRadius,
			    p = this._point;

			return p.x - outerRadius > vp.max.x || p.y - outerRadius > vp.max.y || p.x + outerRadius < vp.min.x || p.y + outerRadius < vp.min.y;
		},

		_validateInnerRadius: function _validateInnerRadius(outer, inner) {
			if (inner >= outer) return outer - 1;
			return inner;
		},

		getArc: function getArc(pt, outerRadius, innerRadius) {
			var x2 = pt.x - 0.01;
			var y1 = pt.y - outerRadius;
			var y2 = pt.y - innerRadius;

			return ['M', pt.x, y1, 'A', outerRadius, outerRadius, 0, 1, 1, x2, y1, 'M', x2, y2, 'A', innerRadius, innerRadius, 0, 1, 0, pt.x, y2, 'Z'].join(' ');
		},

		getPathString: function getPathString() {
			var p = this._point,
			    outerRadius = this._outerRadius,
			    innerRadius = this._innerRadius;

			if (this._checkIfEmpty()) {
				return '';
			}

			if (L.Browser.svg) {
				return this.getArc(p, outerRadius, innerRadius);
			} else {
				// TODO: VML Donut path
				p._round();
				r = Math.round(r);
				return 'AL ' + p.x + ',' + p.y + ' ' + outerRadius + ',' + outerRadius + ' 0,' + 65535 * 360;
			}
		}
	});
}(L);

exports.default = Donut;

},{"leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/Downloader.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Downloader = function (_React$Component) {
	_inherits(Downloader, _React$Component);

	function Downloader() {
		_classCallCheck(this, Downloader);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Downloader).call(this));

		_this.downloadGeojson = _this.downloadGeojson.bind(_this);
		return _this;
	}
	// property validation


	_createClass(Downloader, [{
		key: 'downloadGeojson',
		value: function downloadGeojson() {
			var geojson = this.props.adGeojson;
			var blob = new Blob([JSON.stringify(geojson)]);

			var geojsonURL = window.URL.createObjectURL(blob);
			var tempLink = document.createElement('a');
			tempLink.href = geojsonURL;
			tempLink.setAttribute('download', 'areadescription.geojson');
			tempLink.click();
		}
	}, {
		key: 'render',
		value: function render() {

			return _react2.default.createElement(
				'div',
				{ className: 'download_menu' },
				_react2.default.createElement(
					'h2',
					null,
					_react2.default.createElement(
						'span',
						null,
						this.props.name + ', ' + this.props.state
					),
					_react2.default.createElement(
						'div',
						{ onClick: this.props.onDownloadClicked },
						'x'
					)
				),
				_react2.default.createElement(
					'ul',
					null,
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement('img', { src: this.props.thumbnail }),
						_react2.default.createElement(
							'h3',
							null,
							_react2.default.createElement(
								'a',
								{ href: this.props.mapurl, download: this.props.name + 'HOLCMap.jpg' },
								'Download HOLC map (original)'
							)
						)
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement('img', { src: this.props.mapThumbnail }),
						_react2.default.createElement(
							'h3',
							null,
							_react2.default.createElement(
								'a',
								{ onClick: this.downloadGeojson },
								'Download HOLC area description'
							)
						)
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement('img', { src: this.props.mapThumbnail }),
						_react2.default.createElement(
							'h3',
							null,
							_react2.default.createElement(
								'a',
								{ href: this.props.mapurl, download: this.props.name + 'HOLCMap.jpg' },
								'Download HOLC georeferenced map'
							)
						)
					)
				)
			);
		}
	}]);

	return Downloader;
}(_react2.default.Component);

Downloader.propTypes = {
	mapurl: _react.PropTypes.string,
	name: _react.PropTypes.string
};
exports.default = Downloader;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/HOLCMap.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var React = _interopRequireWildcard(_react);

var _AreaDescriptionsStore = require('../stores/AreaDescriptionsStore');

var _AreaDescriptionsStore2 = _interopRequireDefault(_AreaDescriptionsStore);

var _CityStore = require('../stores/CityStore');

var _CityStore2 = _interopRequireDefault(_CityStore);

var _MapStateStore = require('../stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

var _RasterStore = require('../stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

var _UserLocationStore = require('../stores/UserLocationStore');

var _UserLocationStore2 = _interopRequireDefault(_UserLocationStore);

var _reactLeaflet = require('react-leaflet');

var _toolkit = require('@panorama/toolkit');

var _AreaPolygon = require('./AreaPolygon.jsx');

var _AreaPolygon2 = _interopRequireDefault(_AreaPolygon);

var _Donut = require('./Donut/Donut.jsx');

var _Donut2 = _interopRequireDefault(_Donut);

var _config = require('../../basemaps/cartodb/config.json');

var _config2 = _interopRequireDefault(_config);

var _basemaps = require('../../basemaps/cartodb/basemaps.json');

var _basemaps2 = _interopRequireDefault(_basemaps);

var _tileLayers = require('../../basemaps/tileLayers.json');

var _tileLayers2 = _interopRequireDefault(_tileLayers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// stores


// components


var HOLCMap = function (_React$Component) {
	_inherits(HOLCMap, _React$Component);

	function HOLCMap(props) {
		_classCallCheck(this, HOLCMap);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(HOLCMap).call(this, props));
	}

	_createClass(HOLCMap, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var ADs = _AreaDescriptionsStore2.default.getVisible(),
			    aboveThreshold = _MapStateStore2.default.isAboveZoomThreshold(),
			    outerRadius = _CityStore2.default.getOuterRingRadius(),
			    visibleMapsList = _MapStateStore2.default.getVisibleHOLCMapsList(),
			    legendData = {
				items: ['A First Grade', 'B Second Grade', 'C Third Grade', 'D Fourth Grade']
			};

			if (!aboveThreshold) {
				legendData.items.push('Area for each grade');
			}

			return React.createElement(
				_reactLeaflet.Map,
				{
					ref: 'the_map',
					center: this.props.state.map.center,
					zoom: this.props.state.map.zoom,
					onMoveend: this.props.onMapMoved,
					className: 'the_map'
				},
				React.createElement(_reactLeaflet.TileLayer, {
					key: aboveThreshold ? 'labels' : 'noLabels',
					url: aboveThreshold ? _tileLayers2.default.layers[0].urlLabels : _tileLayers2.default.layers[0].urlNoLabels,
					zIndex: -1
				}),
				visibleMapsList.map(function (item, i) {
					return React.createElement(_reactLeaflet.TileLayer, {
						key: 'holctiles' + item.id,
						url: item.url,
						minZoom: item.minZoom,
						bounds: item.bounds,
						opacity: _this2.props.state.raster.opacity,
						zIndex: item.ad_id == _this2.props.state.selectedCity ? 1 : null
					});
				}),
				!aboveThreshold ? _basemaps2.default.layergroup.layers.map(function (item, i) {
					return React.createElement(_toolkit.CartoDBTileLayer, {
						key: 'cartodb-tile-layer-' + i,
						userId: _config2.default.userId,
						sql: item.options.sql,
						cartocss: item.options.cartocss,
						zIndex: 1000
					});
				}) : null,
				aboveThreshold && outerRadius > 0 ? React.createElement(_reactLeaflet.Circle, {
					center: _CityStore2.default.getLoopLatLng(),
					radius: outerRadius / 7,
					fillOpacity: this.props.state.selectedRingGrade.ringId >= 2 ? 0.75 : 0,
					fillColor: '#000',
					clickable: false,
					className: 'donuthole',
					key: 'donuthole'
				}) : null,
				aboveThreshold && outerRadius > 0 ? [2, 3, 4, 5].map(function (ringNum) {
					return React.createElement(_Donut2.default, {
						center: _CityStore2.default.getLoopLatLng(),
						innerRadius: (ringNum * 2 - 3) / 7 * outerRadius,
						outerRadius: ringNum == 5 ? outerRadius * 100 : (ringNum * 2 - 1) / 7 * outerRadius,
						clickable: false,
						fillOpacity: _this2.props.state.selectedRingGrade.ringId > 0 && ringNum !== _this2.props.state.selectedRingGrade.ringId ? 0.75 : 0,
						fillColor: '#000',
						weight: 1,
						className: 'donut',
						key: 'donut' + String(ringNum)
					});
				}) : null,
				aboveThreshold && this.props.state.selectedRingGrade.ringId > 0 ? React.createElement(
					_reactLeaflet.LayerGroup,
					null,
					React.createElement(_reactLeaflet.GeoJson, {
						data: _CityStore2.default.getInvertedGeoJsonForSelectedRingArea(this.props.state.selectedRingGrade.ringId, this.props.state.selectedRingGrade.grade),
						clickable: false,
						key: 'invertedRingStroke',
						fillColor: '#000',
						fillOpacity: 0.6,
						color: '#fff',
						weight: 2,
						opacity: 0.9,
						className: 'invertedRingGradedArea'
					}),
					React.createElement(_reactLeaflet.GeoJson, {
						data: _CityStore2.default.getGeoJsonForSelectedRingArea(this.props.state.selectedRingGrade.ringId, this.props.state.selectedRingGrade.grade),
						clickable: false,
						key: 'ringStroke',
						fillOpacity: (1 - this.props.state.raster.opacity) / 2,
						weight: 2,
						opacity: 0.9,
						className: 'ringGradedArea grade' + this.props.state.selectedRingGrade.grade
					})
				) : null,
				aboveThreshold && this.props.state.selectedGrade ? React.createElement(_AreaPolygon2.default, {
					data: _AreaDescriptionsStore2.default.getGeoJsonForGrade(this.props.state.selectedCity, this.props.state.selectedGrade),
					key: 'selectedGradedNeighborhoods',
					className: 'selectedGradedNeighborhoods grade' + this.props.state.selectedGrade
				}) : null,
				aboveThreshold && this.props.state.highlightedNeighborhood && ADs[this.props.state.selectedCity] && ADs[this.props.state.selectedCity][this.props.state.highlightedNeighborhood] && ADs[this.props.state.selectedCity][this.props.state.highlightedNeighborhood].area_geojson_inverted ? React.createElement(_AreaPolygon2.default, {
					data: ADs[this.props.state.selectedCity][this.props.state.highlightedNeighborhood].area_geojson_inverted,
					clickable: false,
					className: 'neighborhoodPolygonInverted grade' + ADs[this.props.state.selectedCity][this.props.state.highlightedNeighborhood].holc_grade,
					key: 'neighborhoodPolygonInverted' + this.props.state.highlightedNeighborhood
				}) : null,
				aboveThreshold && this.props.state.selectedNeighborhood && ADs[this.props.state.selectedCity] && ADs[this.props.state.selectedCity][this.props.state.selectedNeighborhood] && ADs[this.props.state.selectedCity][this.props.state.selectedNeighborhood].area_geojson_inverted ? React.createElement(_AreaPolygon2.default, {
					data: ADs[this.props.state.selectedCity][this.props.state.selectedNeighborhood].area_geojson_inverted,
					clickable: false,
					className: 'neighborhoodPolygonInverted grade' + ADs[this.props.state.selectedCity][this.props.state.selectedNeighborhood].holc_grade,
					key: 'neighborhoodPolygonInverted' + this.props.state.selectedNeighborhood
				}) : null,
				aboveThreshold ? Object.keys(ADs).map(function (adId) {
					return Object.keys(ADs[adId]).map(function (areaId) {
						return React.createElement(_AreaPolygon2.default, {
							data: ADs[adId][areaId].area_geojson,
							className: 'neighborhoodPolygon grade' + ADs[adId][areaId].holc_grade,
							key: 'neighborhoodPolygon' + adId + '-' + areaId,
							onClick: _this2.props.onNeighborhoodPolygonClick,
							adId: adId,
							neighborhoodId: areaId
							//fillOpacity={ (id == this.props.state.selectedNeighborhood) ? 1 : 0 }
							, style: {
								opacity: _this2.props.state.selectedRingGrade.ringId > 0 ? (1 - _this2.props.state.raster.opacity) / 5 : (1 - _this2.props.state.raster.opacity) / 2,
								fillOpacity: _this2.props.state.selectedRingGrade.ringId > 0 ? 0 : (1 - _this2.props.state.raster.opacity) / 5
							}
						});
					});
				}) : null,
				!aboveThreshold ? _AreaDescriptionsStore2.default.getADsList().map(function (item, i) {
					return item.radii && item.centerLat ? Object.keys(item.radii).map(function (grade) {
						return item.radii[grade].inner == 0 ? React.createElement(_reactLeaflet.Circle, {
							center: [item.centerLat, item.centerLng],
							radius: item.radii[grade].outer,
							id: item.ad_id,
							onClick: _this2.props.onCityMarkerSelected,
							key: 'clickableDonut' + item.ad_id + grade,
							className: 'simpleDonut grade_' + grade
						}) : React.createElement(_Donut2.default, {
							center: [item.centerLat, item.centerLng],
							innerRadius: item.radii[grade].inner,
							outerRadius: item.radii[grade].outer,
							id: item.ad_id,
							onClick: _this2.props.onCityMarkerSelected,
							key: 'clickableDonut' + item.ad_id + grade,
							className: 'simpleDonut grade_' + grade
						});
					}) : !item.parent_id && item.centerLat ? React.createElement(_reactLeaflet.Circle, {
						center: [item.centerLat, item.centerLng],
						radius: 25000,
						id: item.ad_id,
						onClick: _this2.onCityMarkerSelected,
						key: 'clickableMap' + item.ad_id,
						className: 'cityCircle '
					}) : null;
				}) : null,
				this.props.state.userLocation ? React.createElement(_reactLeaflet.Marker, { position: this.props.state.userLocation }) : null,
				React.createElement(_toolkit.Legend, _extends({}, legendData, { onItemSelected: this.onGradeHover }))
			);
		}
	}]);

	return HOLCMap;
}(React.Component);

exports.default = HOLCMap;

},{"../../basemaps/cartodb/basemaps.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/cartodb/basemaps.json","../../basemaps/cartodb/config.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/cartodb/config.json","../../basemaps/tileLayers.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/tileLayers.json","../stores/AreaDescriptionsStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/AreaDescriptionsStore.js","../stores/CityStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/CityStore.js","../stores/MapStateStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/MapStateStore.js","../stores/RasterStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/RasterStore.js","../stores/UserLocationStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/UserLocationStore.js","./AreaPolygon.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/AreaPolygon.jsx","./Donut/Donut.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/Donut/Donut.jsx","@panorama/toolkit":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/@panorama/toolkit/dist/components.min.js","react":"react","react-leaflet":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/react-leaflet/lib/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarMap.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _SidebarNeighborhoodNav = require('./SidebarNeighborhoodNav.jsx');

var _SidebarNeighborhoodNav2 = _interopRequireDefault(_SidebarNeighborhoodNav);

var _SidebarNeighborhoodTitle = require('./SidebarNeighborhoodTitle.jsx');

var _SidebarNeighborhoodTitle2 = _interopRequireDefault(_SidebarNeighborhoodTitle);

var _HOLCMap = require('./HOLCMap.jsx');

var _HOLCMap2 = _interopRequireDefault(_HOLCMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SidebarMap = function (_React$Component) {
	_inherits(SidebarMap, _React$Component);

	// property validation

	function SidebarMap() {
		_classCallCheck(this, SidebarMap);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(SidebarMap).call(this));
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(SidebarMap, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return true;
		}
	}, {
		key: 'render',
		value: function render() {

			return _react2.default.createElement(
				'div',
				{ className: 'areaDescription' },
				_react2.default.createElement(_SidebarNeighborhoodTitle2.default, {
					areaId: this.props.areaId,
					name: this.props.neighborhoodNames[this.props.areaId],
					onClose: this.props.onClose
				}),
				this.props.previousAreaId ? _react2.default.createElement(_SidebarNeighborhoodNav2.default, {
					style: this.props.previousStyle,
					onHOLCIDClick: this.props.onHOLCIDClick,
					areaId: this.props.previousAreaId,
					name: this.props.neighborhoodNames[this.props.previousAreaId]
				}) : '',
				this.props.nextAreaId && this.props.nextAreaId !== 'null' ? _react2.default.createElement(_SidebarNeighborhoodNav2.default, {
					style: this.props.nextStyle,
					onHOLCIDClick: this.props.onHOLCIDClick,
					areaId: this.props.nextAreaId,
					name: this.props.neighborhoodNames[this.props.nextAreaId]
				}) : '',
				_react2.default.createElement(
					'div',
					{ style: this.props.mapStyle },
					_react2.default.createElement(_HOLCMap2.default, {
						ref: 'holc_map',
						state: this.props.state,
						onMapMoved: this.props.onMapMoved,
						onNeighborhoodPolygonClick: this.props.onNeighborhoodPolygonClick,
						onCityMarkerSelected: this.props.onCityMarkerSelected,
						style: this.props.mapStyle
					})
				)
			);
		}
	}]);

	return SidebarMap;
}(_react2.default.Component);

SidebarMap.propTypes = {};
SidebarMap.defaultProps = {};
exports.default = SidebarMap;

},{"./HOLCMap.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/HOLCMap.jsx","./SidebarNeighborhoodNav.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodNav.jsx","./SidebarNeighborhoodTitle.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodTitle.jsx","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodNav.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SidebarNeighborhoodNav = function (_React$Component) {
	_inherits(SidebarNeighborhoodNav, _React$Component);

	function SidebarNeighborhoodNav() {
		_classCallCheck(this, SidebarNeighborhoodNav);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(SidebarNeighborhoodNav).apply(this, arguments));
	}

	_createClass(SidebarNeighborhoodNav, [{
		key: 'render',
		value: function render() {

			return _react2.default.createElement(
				'div',
				{
					className: 'adNav',
					style: this.props.style,
					onClick: this.props.onHOLCIDClick,
					id: this.props.areaId
				},
				this.props.areaId,
				this.props.name ? ' ' + this.props.name : ''
			);
		}
	}]);

	return SidebarNeighborhoodNav;
}(_react2.default.Component);

exports.default = SidebarNeighborhoodNav;

},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/SidebarNeighborhoodTitle.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SidebarNeighborhoodNav = function (_React$Component) {
	_inherits(SidebarNeighborhoodNav, _React$Component);

	function SidebarNeighborhoodNav() {
		_classCallCheck(this, SidebarNeighborhoodNav);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(SidebarNeighborhoodNav).apply(this, arguments));
	}

	_createClass(SidebarNeighborhoodNav, [{
		key: 'render',
		value: function render() {

			return _react2.default.createElement(
				'h2',
				{ className: 'sidebarTitle' },
				_react2.default.createElement(
					'span',
					null,
					this.props.areaId
				),
				this.props.name ? _react2.default.createElement(
					'span',
					null,
					' ' + this.props.name
				) : '',
				_react2.default.createElement(
					'span',
					{ className: 'closeicon', onClick: this.props.onClose },
					'x'
				)
			);
		}
	}]);

	return SidebarNeighborhoodNav;
}(_react2.default.Component);

exports.default = SidebarNeighborhoodNav;

},{"react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/StateStats.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CitySnippet = require('./CitySnippet.jsx');

var _CitySnippet2 = _interopRequireDefault(_CitySnippet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StateStats = function (_React$Component) {
	_inherits(StateStats, _React$Component);

	function StateStats() {
		_classCallCheck(this, StateStats);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(StateStats).call(this));
	}
	// property validation


	_createClass(StateStats, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'h2',
					null,
					this.props.stateName
				),
				this.props.cities.map(function (cityData) {
					return _react2.default.createElement(_CitySnippet2.default, {
						cityData: cityData,
						onCityClick: _this2.props.onCityClick,
						key: 'city' + cityData.ad_id
					});
				})
			);
		}
	}]);

	return StateStats;
}(_react2.default.Component);

StateStats.propTypes = {
	stateName: _react.PropTypes.string
};
exports.default = StateStats;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","./CitySnippet.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/CitySnippet.jsx","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/TypeAheadCitySnippet.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CitySnippet = require('./CitySnippet.jsx');

var _CitySnippet2 = _interopRequireDefault(_CitySnippet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TypeAheadCitySnippet = function (_React$Component) {
	_inherits(TypeAheadCitySnippet, _React$Component);

	function TypeAheadCitySnippet() {
		_classCallCheck(this, TypeAheadCitySnippet);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(TypeAheadCitySnippet).call(this));
	}

	_createClass(TypeAheadCitySnippet, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				'div',
				null,
				this.props.options.map(function (cityData) {
					return _react2.default.createElement(_CitySnippet2.default, { cityData: cityData, onCityClick: _this2.props.onOptionSelected, displayState: true, key: 'city' + cityData.ad_id });
				})
			);
		}
	}]);

	return TypeAheadCitySnippet;
}(_react2.default.Component);

exports.default = TypeAheadCitySnippet;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","./CitySnippet.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/components/CitySnippet.jsx","react":"react"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/main.jsx":[function(require,module,exports){
'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _App = require('./App.jsx');

var _App2 = _interopRequireDefault(_App);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//process.env.NODE_ENV = 'development';
//import Perf from 'react-addons-perf';
//window.Perf = Perf;

//Perf.start();

_reactDom2.default.render(_react2.default.createElement(_App2.default, null), document.getElementById('app-container'));
//Perf.stop();
//Perf.printWasted();

},{"./App.jsx":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/App.jsx","react":"react","react-dom":"react-dom"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/AreaDescriptionsStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

var _formsMetadata = require('../../data/formsMetadata.json');

var _formsMetadata2 = _interopRequireDefault(_formsMetadata);

var _MapStateStore = require('../stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

var _state_abbr = require('../../data/state_abbr.json');

var _state_abbr2 = _interopRequireDefault(_state_abbr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AreaDescriptionsStore = {

	data: {
		adIds: [],
		areaDescriptions: {},
		adsMetadata: {},
		hasLoaded: false
	},

	dataLoader: _CartoDBLoader2.default,

	loadADMetadata: function loadADMetadata() {
		var _this = this;

		var query = "WITH polygon_bounds as (select ad_id, st_xmin(st_envelope(st_collect(holc_polygons.the_geom))) as bbxmin, st_ymin(st_envelope(st_collect(holc_polygons.the_geom))) as bbymin, st_xmax(st_envelope(st_collect(holc_polygons.the_geom))) as bbxmax, st_ymax(st_envelope(st_collect(holc_polygons.the_geom))) as bbymax FROM holc_polygons group by ad_id) SELECT holc_polygons.ad_id, city, state, looplat, looplng, population_1940, population_1930, american_indian_eskimo_1930, american_indian_eskimo_1940, asian_pacific_ilslander_1930 as asian_pacific_islander_1930, asian_pacific_ilslander_1940 as asian_pacific_islander_1940, black_pop_1930, black_pop_1940, white_pop_1930, white_pop_1940, sum(st_area(holc_polygons.the_geom_webmercator)) / 1609.34^2 as total_area, sum(CASE WHEN holc_grade = 'A' THEN st_area(holc_polygons.the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_a, sum(CASE WHEN holc_grade = 'B' THEN st_area(holc_polygons.the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_b, sum(CASE WHEN holc_grade = 'C' THEN st_area(holc_polygons.the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_c, sum(CASE WHEN holc_grade = 'D' THEN st_area(holc_polygons.the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_d, bbxmin, bbymin, bbxmax, bbymax FROM holc_polygons join holc_ads on holc_polygons.ad_id = holc_ads.city_id join polygon_bounds on holc_ads.city_id = polygon_bounds.ad_id group by holc_polygons.ad_id, city, state, looplat, looplng, population_1940, population_1930, american_indian_eskimo_1930, american_indian_eskimo_1940, asian_pacific_ilslander_1930, asian_pacific_ilslander_1940, black_pop_1930, black_pop_1940, white_pop_1930, white_pop_1940, bbxmin, bbymin, bbxmax, bbymax  order by ad_id desc";

		this.dataLoader.query([{ query: query, format: 'JSON' }]).then(function (responses) {
			responses.forEach(function (response) {
				if (response.length > 0) {
					responses[0].forEach(function (response) {
						_this.data.adsMetadata[response.ad_id] = {
							ad_id: response.ad_id,
							state: response.state,
							name: response.city,
							searchName: response.city + ', ' + _state_abbr2.default[response.state],
							centerLat: response.looplat,
							centerLng: response.looplng,
							bounds: [[response.bbymin, response.bbxmin], [response.bbymax, response.bbxmax]],
							population_1930: response.population_1930,
							population_1940: response.population_1940,
							american_indian_eskimo_1930: response.american_indian_eskimo_1930,
							american_indian_eskimo_1940: response.american_indian_eskimo_1940,
							asian_pacific_islander_1930: response.asian_pacific_islander_1930,
							asian_pacific_islander_1940: response.asian_pacific_islander_1940,
							black_pop_1930: response.black_pop_1930,
							black_pop_1940: response.black_pop_1940,
							white_pop_1930: response.white_pop_1930,
							white_pop_1940: response.white_pop_1940,
							hasPolygons: true,
							hasADs: false,
							area: {
								total: response.total_area,
								a: response.area_a,
								b: response.area_b,
								c: response.area_c,
								d: response.area_d
							}
						};

						_this.data.adsMetadata[response.ad_id].radii = _this.calculateSimpleRingsRadii(_this.data.adsMetadata[response.ad_id].area);
					});
				}
			});

			_this.data.hasLoaded = true;

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('AreaDescriptionsStore received error:', error);
			throw error;
		});
	},

	loadData: function loadData(adIds) {
		var _this2 = this;

		this.data.adIds = adIds.map(function (adId) {
			return parseInt(adId);
		});

		// create queries for those that aren't already in memory
		var queries = [];
		adIds.forEach(function (adId) {
			if (!_this2.data.areaDescriptions[adId]) {
				queries.push({
					query: 'SELECT holc_ads.city_id as ad_id, holc_maps.file_name, holc_ads.year, holc_ads.state, holc_polygons.name, form_id, holc_id, holc_grade, polygon_id, cat_id, sub_cat_id, _order as order, data, ST_asgeojson (holc_polygons.the_geom, 4) as the_geojson, st_xmin(st_envelope(holc_polygons.the_geom)) as bbxmin, st_ymin(st_envelope(holc_polygons.the_geom)) as bbymin, st_xmax(st_envelope(holc_polygons.the_geom)) as bbxmax, st_ymax(st_envelope(holc_polygons.the_geom)) as bbymax, st_y(st_centroid(holc_polygons.the_geom)) as centerlat, st_x(st_centroid(holc_polygons.the_geom)) as centerlng, st_area(holc_polygons.the_geom::geography)/1000000 * 0.386102 as sqmi FROM holc_ad_data right join holc_polygons on holc_ad_data.polygon_id = holc_polygons.neighborhood_id join holc_ads on holc_ads.city_id = holc_polygons.ad_id join holc_maps_ads_join on holc_maps_ads_join.ad_id = holc_ads.city_id join holc_maps on holc_maps.map_id = holc_maps_ads_join.map_id and parent_id is null  where holc_ads.city_id = ' + adId + ' order by holc_id, cat_id, sub_cat_id, _order',
					format: 'JSON'
				});
			}
		});

		this.dataLoader.query(queries).then(function (responses) {
			responses.forEach(function (response) {
				if (response.length > 0) {
					(function () {
						var adId = response[0].ad_id;
						_this2.data.areaDescriptions[adId] = {
							formId: response[0].form_id,
							byNeighborhood: _this2.parseAreaDescriptions(response)
						};
						_this2.data.areaDescriptions[adId].byCategory = _this2.parseADsByCat(_this2.data.areaDescriptions[adId].byNeighborhood);
						_this2.data.areaDescriptions[adId].area = Object.keys(_this2.data.areaDescriptions[adId].byNeighborhood).map(function (HOLCId, i) {
							return _this2.data.areaDescriptions[adId].byNeighborhood[HOLCId].sqmi;
						}).reduce(function (a, b) {
							return a + b;
						}, 0);
					})();
				}
			});

			_this2.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('AreaDescriptionsStore received error:', error);
			throw error;
		});
	},

	parseAreaDescriptions: function parseAreaDescriptions(rawAdData) {
		var adData = {};

		for (var row in rawAdData) {
			var d = rawAdData[row];

			// define id if undefined
			if (typeof adData[d.holc_id] == 'undefined') {
				adData[d.holc_id] = {};
			}
			// assign properties   
			adData[d.holc_id].area_geojson = !adData[d.holc_id].area_geojson ? JSON.parse(d.the_geojson) : adData[d.holc_id].area_geojson;
			adData[d.holc_id].area_geojson_inverted = !adData[d.holc_id].area_geojson_inverted ? this.parseInvertedGeoJson(JSON.parse(d.the_geojson)) : adData[d.holc_id].area_geojson_inverted;
			adData[d.holc_id].center = [d.centerlat, d.centerlng];
			adData[d.holc_id].boundingBox = [[d.bbymin, d.bbxmin], [d.bbymax, d.bbxmax]];
			adData[d.holc_id].name = d.name;
			adData[d.holc_id].holc_grade = d.holc_grade;
			adData[d.holc_id].sqmi = d.sqmi;

			adData[d.holc_id].url = 'http://holc.s3-website-us-east-1.amazonaws.com/tiles/' + d.state + '/' + d.file_name.replace(/\s+/g, '') + '/' + d.year + '/full-size/' + d.holc_id + '.jpg';
			adData[d.holc_id].tileUrl = 'http://holc.s3-website-us-east-1.amazonaws.com/ads/' + d.state + '/' + d.file_name.replace(/\s+/g, '') + '/' + d.year + '/' + d.holc_id + '/{z}/{x}_{y}.png';
			adData[d.holc_id].thumbnailUrl = 'http://holc.s3-website-us-east-1.amazonaws.com/ads/' + d.state + '/' + d.file_name.replace(/\s+/g, '') + '/' + d.year + '/' + d.holc_id + '/thumbnail.jpg';

			// define area description if undefined
			if (typeof adData[d.holc_id].areaDesc == 'undefined') {
				adData[d.holc_id].areaDesc = {};
			}

			// define category id for area description if undefined
			if (d.cat_id && d.sub_cat_id === '' && d.order === null) {
				adData[d.holc_id].areaDesc[d.cat_id] = d.data;
			} else if (d.cat_id && typeof adData[d.holc_id].areaDesc[d.cat_id] === 'undefined') {
				adData[d.holc_id].areaDesc[d.cat_id] = {};
			}
			// check for subcategories
			if (d.sub_cat_id) {
				// create sub-object if we have a subcategory...
				if (typeof adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id] == 'undefined') {

					adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id] = {};

					// look for order
					if (d.order) {
						adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id][d.order] = d.data;
					} else {
						adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id] = d.data;
					}
				}
			}

			// look for order
			else if (d.order) {
					adData[d.holc_id].areaDesc[d.cat_id][d.order] = rawAdData[row].data;
				}

			if (Object.keys(adData[d.holc_id].areaDesc).length === 0) {
				adData[d.holc_id].areaDesc = false;
			}
		} // end if

		return adData;
	},

	parseADsByCat: function parseADsByCat(ADs) {
		var ADsByCat = {};
		Object.keys(ADs).forEach(function (neighborhoodId) {
			Object.keys(ADs[neighborhoodId].areaDesc).forEach(function (cat) {
				// initialize if necessary
				ADsByCat[cat] = ADsByCat[cat] || {};
				if (typeof ADs[neighborhoodId].areaDesc[cat] == 'string') {
					ADsByCat[cat][neighborhoodId] = ADs[neighborhoodId].areaDesc[cat];
				} else if (_typeof(ADs[neighborhoodId].areaDesc[cat]) == 'object') {
					Object.keys(ADs[neighborhoodId].areaDesc[cat]).forEach(function (subcat) {
						ADsByCat[cat][subcat] = ADsByCat[cat][subcat] || {};
						ADsByCat[cat][subcat][neighborhoodId] = ADs[neighborhoodId].areaDesc[cat][subcat];
					});
				}
			});
		});

		return ADsByCat;
	},

	parseInvertedGeoJson: function parseInvertedGeoJson(geojson) {
		//Create a new set of latlngs, adding our world-sized ring first
		var NWHemisphere = [[0, 0], [0, 90], [-180, 90], [-180, 0], [0, 0]],
		    newLatLngs = [NWHemisphere],
		    holes = [];

		geojson.coordinates.forEach(function (polygon, i) {
			polygon.forEach(function (polygonpieces, i2) {
				if (i2 == 0) {
					newLatLngs.push(polygonpieces);
				} else {
					holes.push(polygonpieces);
				}
			});
		});
		geojson.coordinates = holes.length > 0 ? [newLatLngs.concat(holes)] : [newLatLngs];
		return geojson;
	},

	calculateSimpleRingsRadii: function calculateSimpleRingsRadii(areaData) {
		var furthestRadius = 25000,
		    fullArea = Math.PI * furthestRadius * furthestRadius,
		    outerRadius = void 0,
		    innerRadius = 0,
		    donutArea = void 0,
		    gradeArea = void 0,
		    radii = {};

		['d', 'c', 'b', 'a'].forEach(function (grade) {
			var donutholeArea = Math.PI * innerRadius * innerRadius,
			    gradeArea = fullArea * (areaData[grade] / areaData.total),
			    outerRadius = Math.round(Math.sqrt((gradeArea + donutholeArea) / Math.PI));
			radii[grade] = {
				'inner': innerRadius,
				'outer': outerRadius
			};
			innerRadius = outerRadius;
		});

		return radii;
	},

	getName: function getName(adId, HOLCId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood[HOLCId] ? this.data.areaDescriptions[adId].byNeighborhood[HOLCId].name : null;
	},

	getThumbnailUrl: function getThumbnailUrl(adId, HOLCId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood && this.data.areaDescriptions[adId].byNeighborhood[HOLCId] ? this.data.areaDescriptions[adId].byNeighborhood[HOLCId].thumbnailUrl : null;
	},

	getAdUrl: function getAdUrl(adId, HOLCId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood && this.data.areaDescriptions[adId].byNeighborhood[HOLCId] ? this.data.areaDescriptions[adId].byNeighborhood[HOLCId].url : null;
	},

	getAdTileUrl: function getAdTileUrl(adId, HOLCId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood && this.data.areaDescriptions[adId].byNeighborhood[HOLCId] ? this.data.areaDescriptions[adId].byNeighborhood[HOLCId].tileUrl : null;
	},

	getNeighborhoodNames: function getNeighborhoodNames(adId) {
		var _this3 = this;

		var names = {};
		if (this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood) {
			Object.keys(this.data.areaDescriptions[adId].byNeighborhood).forEach(function (holcId) {
				names[holcId] = _this3.getName(adId, holcId);
			});
		}
		return names;
	},

	getAreaDescriptions: function getAreaDescriptions() {
		return this.data.areaDescriptions;
	},

	getADs: function getADs(adId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].byNeighborhood : false;
	},

	getADsMetadata: function getADsMetadata() {
		return this.data.adsMetadata;
	},

	// return a flat list of the HOLC maps for rendering
	getADsList: function getADsList() {
		var _this4 = this;

		return Object.keys(this.data.adsMetadata).map(function (adId) {
			return _this4.data.adsMetadata[adId];
		});
	},

	getGeoJsonForGrade: function getGeoJsonForGrade(adId, grade) {
		var _this5 = this;

		var polygons = [[[0, 0], [0, 90], [-180, 90], [-180, 0], [0, 0]]],
		    holes = [];
		Object.keys(this.data.areaDescriptions[adId].byNeighborhood).forEach(function (id, i) {
			if (_this5.data.areaDescriptions[adId].byNeighborhood[id].holc_grade == grade) {
				_this5.data.areaDescriptions[adId].byNeighborhood[id].area_geojson.coordinates.forEach(function (coordset) {
					coordset.forEach(function (coords, i2) {
						if (i2 == 0) {
							polygons.push(coords);
						} else {
							holes.push(coords);
						}
					});
				});
			}
		});

		polygons = holes.length > 0 ? [polygons.concat(holes)] : [polygons];

		var geojson = {
			'type': 'Feature',
			'geometry': {
				'type': 'MultiPolygon',
				'coordinates': polygons
			},
			'properties': {}
		};

		return geojson;
	},

	getADsForNeighborhood: function getADsForNeighborhood(adId, holcId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood[holcId] ? this.data.areaDescriptions[adId].byNeighborhood[holcId].areaDesc : false;
	},

	getADsForCategory: function getADsForCategory(adId, category) {
		if (!this.data.areaDescriptions[adId] || !category) {
			return null;
		}

		var _category$split = category.split('-');

		var _category$split2 = _slicedToArray(_category$split, 2);

		var catNum = _category$split2[0];
		var catLetter = _category$split2[1];


		if (!catNum) {
			return this.data.areaDescriptions[adId].byCategory;
		}

		if (!catLetter && this.data.areaDescriptions[adId].byCategory[catNum]) {
			return this.data.areaDescriptions[adId].byCategory[catNum];
		} else if (catLetter && this.data.areaDescriptions[adId].byCategory[catNum] && this.data.areaDescriptions[adId].byCategory[catNum][catLetter]) {
			return this.data.areaDescriptions[adId].byCategory[catNum][catLetter];
		}

		return null;
	},

	getVisible: function getVisible() {
		var _this6 = this;

		var ADs = {};
		this.data.adIds.forEach(function (adId) {
			if (_this6.data.areaDescriptions[adId]) {
				ADs[adId] = _this6.data.areaDescriptions[adId].byNeighborhood;
			}
		});
		return ADs;
	},

	getVisibleMapIds: function getVisibleMapIds() {
		return this.data.adIds;
	},

	getArea: function getArea(adId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].area : null;
	},

	getNeighborhoodBoundingBox: function getNeighborhoodBoundingBox(adId, holcId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].byNeighborhood[holcId].boundingBox : null;
	},

	getNeighborhoodCenter: function getNeighborhoodCenter(adId, holcId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].byNeighborhood[holcId].center : null;
	},

	getPreviousHOLCId: function getPreviousHOLCId(adId, HOLCId) {
		if (this.data.areaDescriptions[adId]) {
			var formIds = Object.keys(this.data.areaDescriptions[adId].byNeighborhood).sort(this.alphanumCase);
			return formIds[formIds.indexOf(HOLCId) - 1];
		} else {
			return false;
		}
	},

	getNextHOLCId: function getNextHOLCId(adId, HOLCId) {
		if (this.data.areaDescriptions[adId]) {
			var formIds = Object.keys(this.data.areaDescriptions[adId].byNeighborhood).sort(this.alphanumCase);
			return formIds[formIds.indexOf(HOLCId) + 1];
		} else {
			return false;
		}
	},

	getFormId: function getFormId(adId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].formId : null;
	},

	getPreviousCatIds: function getPreviousCatIds(adId, catNum, catLetter) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var formId = this.data.areaDescriptions[adId].formId;
		for (var checkCatNum = !catLetter || catLetter == 'a' ? parseInt(catNum) - 1 : parseInt(catNum); checkCatNum >= 1; checkCatNum--) {
			for (var checkCatLetter = !catLetter || catLetter == 'a' ? 'z' : String.fromCharCode(catLetter.charCodeAt() - 1); checkCatLetter >= 'a'; checkCatLetter = String.fromCharCode(checkCatLetter.charCodeAt() - 1), catLetter = undefined) {
				if (typeof _formsMetadata2.default[formId][checkCatNum] === 'string') {
					return [checkCatNum, undefined];
				} else if (_formsMetadata2.default[formId][checkCatNum] && _formsMetadata2.default[formId][checkCatNum].subcats && typeof _formsMetadata2.default[formId][checkCatNum].subcats[checkCatLetter] === 'string') {
					return [checkCatNum, checkCatLetter];
				}
			}
		}

		return false;
	},

	getNextCatIds: function getNextCatIds(adId, catNum, catLetter) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var formId = this.data.areaDescriptions[adId].formId;
		for (var checkCatNum = !catLetter ? parseInt(catNum) + 1 : parseInt(catNum); checkCatNum < 30; checkCatNum++) {
			for (var checkCatLetter = !catLetter || catLetter == 'z' ? 'a' : String.fromCharCode(catLetter.charCodeAt() + 1); checkCatLetter <= 'z'; checkCatLetter = String.fromCharCode(checkCatLetter.charCodeAt() + 1), catLetter = undefined) {
				if (typeof _formsMetadata2.default[formId][checkCatNum] === 'string') {
					return [checkCatNum, undefined];
				} else if (_formsMetadata2.default[formId][checkCatNum] && _formsMetadata2.default[formId][checkCatNum].subcats && typeof _formsMetadata2.default[formId][checkCatNum].subcats[checkCatLetter] === 'string') {
					return [checkCatNum, checkCatLetter];
				}
			}
		}

		return false;
	},

	getCatTitle: function getCatTitle(adId, cat, subcat) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var formId = this.data.areaDescriptions[adId].formId;
		if (!subcat) {
			return cat + ' ' + _formsMetadata2.default[formId][cat];
		} else if (subcat) {
			return cat + subcat + ' ' + _formsMetadata2.default[formId][cat].header + (_formsMetadata2.default[formId][cat].subcats[subcat] !== '' ? ': ' + _formsMetadata2.default[formId][cat].subcats[subcat] : '');
		} else {
			return null;
		}
	},

	getADsAsGeojson: function getADsAsGeojson(adId) {
		console.log(adId);
		var ADs = this.data.areaDescriptions[adId].byNeighborhood;
		var features = Object.keys(ADs).map(function (holcId) {
			var the_geojson = {
				type: "Feature",
				geometry: ADs[holcId].area_geojson,
				properties: {
					id: holcId,
					grade: ADs[holcId].holc_grade,
					name: ADs[holcId].name
				}
			};

			Object.keys(ADs[holcId].areaDesc).forEach(function (catNum) {
				if (typeof ADs[holcId].areaDesc[catNum] == 'string') {
					the_geojson.properties['ad' + catNum] = ADs[holcId].areaDesc[catNum];
				} else {
					Object.keys(ADs[holcId].areaDesc[catNum]).forEach(function (catLetter) {
						if (typeof ADs[holcId].areaDesc[catNum][catLetter] == 'string') {
							the_geojson.properties['ad' + catNum + catLetter] = ADs[holcId].areaDesc[catNum][catLetter];
						} else {
							Object.keys(ADs[holcId].areaDesc[catNum][catLetter]).forEach(function (subpart) {
								the_geojson.properties['ad' + catNum + catLetter + subpart] = ADs[holcId].areaDesc[catNum][catLetter][subpart];
							});
						}
					});
				}
			});

			return the_geojson;
		});
		var geojson = {
			type: "FeatureCollection",
			features: features
		};

		return geojson;
	},


	hasLoaded: function hasLoaded() {
		return this.data.hasLoaded;
	},

	hasADData: function hasADData(adId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood['C1'];
	},

	/* alphanum.js (C) Brian Huisman
 * Based on the Alphanum Algorithm by David Koelle
 * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
 *
 * Distributed under same license as original
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
	alphanumCase: function alphanumCase(a, b) {
		function chunkify(t) {
			var tz = new Array();
			var x = 0,
			    y = -1,
			    n = 0,
			    i,
			    j;
			while (i = (j = t.charAt(x++)).charCodeAt(0)) {
				var m = i == 46 || i >= 48 && i <= 57;
				if (m !== n) {
					tz[++y] = '';
					n = m;
				}
				tz[y] += j;
			}
			return tz;
		}

		var aa = a.neighborhoodId ? chunkify(a.neighborhoodId.toLowerCase()) : chunkify(a.toLowerCase());
		var bb = b.neighborhoodId ? chunkify(b.neighborhoodId.toLowerCase()) : chunkify(b.toLowerCase());
		for (var x = 0; aa[x] && bb[x]; x++) {
			if (aa[x] !== bb[x]) {
				var c = Number(aa[x]),
				    d = Number(bb[x]);
				if (c == aa[x] && d == bb[x]) {
					return c - d;
				} else return aa[x] > bb[x] ? 1 : -1;
			}
		}
		return aa.length - bb.length;
	}

};

// Mixin EventEmitter functionality
Object.assign(AreaDescriptionsStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
_AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.loadInitialData:
			_AppDispatcher2.default.waitFor([_MapStateStore2.default.dispatchToken]);
			AreaDescriptionsStore.loadADMetadata();
			if (action.state.selectedCity) {
				AreaDescriptionsStore.loadData([action.state.selectedCity]);
			}
			break;

		case _AppActionCreator.AppActionTypes.mapMoved:
			_AppDispatcher2.default.waitFor([_MapStateStore2.default.dispatchToken]);

			var visibleHOLCMapsIds = _MapStateStore2.default.getVisibleHOLCMapsIds(),
			    visibleADIds = _MapStateStore2.default.getVisibleAdIds();

			if (visibleADIds && _MapStateStore2.default.isAboveZoomThreshold()) {
				AreaDescriptionsStore.loadData(visibleADIds);
			}
			break;
	}

	return true;
});

exports.default = AreaDescriptionsStore;

},{"../../data/formsMetadata.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/formsMetadata.json","../../data/state_abbr.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/state_abbr.json","../stores/MapStateStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/MapStateStore.js","../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/CartoDBLoader.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/CityStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _CityStore;

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

var _formsMetadata = require('../../data/formsMetadata.json');

var _formsMetadata2 = _interopRequireDefault(_formsMetadata);

var _MapStateStore = require('../stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* City Store is responsible for maintaining most of the important state
variables: e.g. selected city, neighborhood, category, ring, grade, etc. */
var CityStore = (_CityStore = {

	data: {
		id: null,
		name: null,
		state: null,
		year: null,
		selectedRingGrade: {
			ringId: -1,
			grade: null
		},
		selectedHolcId: null,
		selectedCategory: null,
		selectedGrade: null,
		highlightedHolcId: null,
		areas: {},
		ringAreasGeometry: [], // not the rings themselves but the intersection of rings and areas
		loopLatLng: [],
		// the distance in meters between the loop center and the outermost point
		outerRingRadius: null,
		cityData: {},

		/** Percentages of each ring for each grade, with 
   * density recording the amount of neighborhood area 
   * in the ring.
   * {
   *   1: {
   *     'A': float,
   *     'B': float,
   *     'C': float,
   *     'D': float,
   *     'density': float,
   *   },
   *   2: { ... },
   *   ...
   }
   * }
   */
		ringStats: [],
		gradeStats: [],

		ADsByCat: {},
		polygonBoundingBox: null,
		polygonsCenter: null,
		gradedArea: null,
		gradedAreaOfRings: {},
		gradedAreaByGrade: {},
		users: {
			latLng: null,
			adId: null,
			city: null,
			neighborhood: null,
			offerZoomTo: false
		},
		selectedByUser: false,
		hasLoaded: false
	},

	cache: {},

	// TODO: Make a generic DataLoader class to define an interface,
	// and let CartoDBLoader extend and implement that?
	// Basic idea is that anything with a query method that returns a Promise
	// that resolves with an array of response data or rejects with an error
	// can be used here.
	dataLoader: _CartoDBLoader2.default,

	loadData: function loadData(cityId, selectedByUser) {
		var _this = this;

		if (cityId == null) {
			this.data.id = null;
			this.data.selectedHolcId = null;
			this.data.selectedCategory = null;
			this.emit(_AppActionCreator.AppActionTypes.storeChanged);
			return;
		}

		if (cityId == this.data.id) {
			// already loaded;
			this.emit(_AppActionCreator.AppActionTypes.storeChanged);
			return;
		}

		// // check to see if the city data has already been loaded and stored in cache
		// if (this.cache[cityId]) {
		// 	console.log(this.cache);
		// 	this.data = this.cache[cityId];
		// 	console.log(this.data);
		// 	this.emit(AppActionTypes.storeChanged);
		// 	return;
		// }

		this.dataLoader.query([{
			query: 'SELECT * from holc_ads where city_id = ' + cityId,
			format: 'JSON'
		},
		// get ring polygons
		{
			query: 'WITH the_hull as (select ST_Collect(digitalscholarshiplab.holc_polygons.the_geom_webmercator) as hull, ad_id FROM digitalscholarshiplab.holc_polygons where ad_id = ' + cityId + ' GROUP BY ad_id), maxdist as (SELECT st_distance_sphere(st_transform(st_endpoint(st_longestline(st_transform(ST_SetSRID(ST_MakePoint(looplng,looplat),4326),3857), hull)), 4326), ST_SetSRID(ST_MakePoint(looplng,looplat), 4326)) as outerringradius, st_length(st_longestline(st_transform(ST_SetSRID(ST_Point(looplng,looplat),4326),3857), hull)) / 3.5 as distintv, ST_Transform(ST_SetSRID(ST_MakePoint(looplng,looplat),4326),3857)::geometry as the_point from the_hull join holc_ads on the_hull.ad_id = holc_ads.city_id and holc_ads.city_id = ' + cityId + ' Order by distintv DESC Limit 1 ), city_buffers as (SELECT ST_Transform((ST_Buffer(the_point,distintv * 3.5,\'quad_segs=32\')::geometry),3857) as buffer4, ST_Transform((ST_Buffer(the_point,distintv * 2.5,\'quad_segs=32\')::geometry),3857) as buffer3, ST_Transform((ST_Buffer(the_point,distintv * 1.5,\'quad_segs=32\')::geometry),3857) as buffer2, ST_Transform((ST_Buffer(the_point,distintv * 0.5,\'quad_segs=32\')::geometry),3857) as buffer1 FROM maxdist), city_rings as (SELECT ST_Difference(buffer4, buffer3) as the_geom_webmercator, 4 as ring_id, st_area(ST_Difference(buffer4, buffer3)) as ring_area from city_buffers union all select ST_Difference(buffer3, buffer2) as the_geom_webmercator, 3 as ring_id, st_area(ST_Difference(buffer3, buffer2)) as ring_area from city_buffers union all select ST_Difference(buffer2, buffer1) as the_geom_webmercator, 2 as ring_id, st_area(ST_Difference(buffer2, buffer1)) as ring_area from city_buffers union all select buffer1 as the_webmercator, 1 as ring_id, st_area(buffer1) as ring_area from city_buffers ), combined_grades as (SELECT holc_grade, ST_union(the_geom_webmercator) as the_geom_webmercator FROM digitalscholarshiplab.holc_polygons where ad_id = ' + cityId + ' group by holc_grade) SELECT holc_grade as grade, ring_id as ring, ST_AsGeoJSON(ST_Transform(ST_Intersection(city_rings.the_geom_webmercator, combined_grades.the_geom_webmercator),4326), 4) as the_geojson, ST_AsGeoJSON(ST_Transform(ST_Difference(city_rings.the_geom_webmercator, combined_grades.the_geom_webmercator),4326), 4) as inverted_geojson, st_area(ST_Intersection(city_rings.the_geom_webmercator, combined_grades.the_geom_webmercator)) as area, ST_Area(city_rings.the_geom_webmercator) as ring_area, outerringradius FROM city_rings, combined_grades, maxdist',
			format: 'JSON'
		}, {
			query: 'Select st_x(st_centroid(ST_SetSRID(st_extent(the_geom),4326))) as centerLng, st_y(st_centroid(ST_SetSRID(st_extent(the_geom),4326))) as centerLat, st_xmin(ST_SetSRID(st_extent(the_geom),4326)) as minlng, st_ymin(ST_SetSRID(st_extent(the_geom),4326)) as minlat, st_xmax(ST_SetSRID(st_extent(the_geom),4326)) as maxlng, st_ymax(ST_SetSRID(st_extent(the_geom),4326)) as maxlat from digitalscholarshiplab.holc_polygons where ad_id = ' + cityId,
			format: 'JSON'
		}]).then(function (response) {
			_this.data.id = parseInt(cityId);
			_this.data.selectedByUser = selectedByUser;

			var cityData = response[0][0];
			_this.data.name = cityData.city;
			_this.data.state = cityData.state;
			_this.data.year = cityData.year;
			_this.data.form_id = cityData.form_id;
			_this.data.cityData = cityData;

			var ringData = response[1];
			_this.data.gradedArea = _this.calculatedGradedArea(ringData);
			_this.data.gradedAreaOfRings = _this.calculateGradedAreaOfRings(ringData);
			_this.data.gradedAreaByGrade = _this.calculateGradedAreaByGrade(ringData);
			_this.data.ringAreasGeometry = _this.parseRingAreaGeometry(ringData);
			_this.data.ringStats = _this.parseRingStats(_this.data.ringAreasGeometry);
			_this.data.outerRingRadius = response[1][0] ? response[1][0].outerringradius : false;
			_this.data.loopLatLng = cityData ? [cityData.looplat, cityData.looplng] : false;
			_this.data.gradeStats = _this.parseGradeStats(_this.data.ringAreasGeometry);

			var polygonLatLngs = response[2][0];
			if (polygonLatLngs.minlat) {
				_this.data.polygonBoundingBox = [[polygonLatLngs.minlat, polygonLatLngs.minlng], [polygonLatLngs.maxlat, polygonLatLngs.maxlng]];
				_this.data.polygonsCenter = [polygonLatLngs.centerlat, polygonLatLngs.centerlng];
			} else {
				_this.data.polygonBoundingBox = null;
				_this.data.polygonsCenter = null;
			}

			_this.data.hasLoaded = true;

			// console.log('CityStore finished loading');
			// console.log(this.data);

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('CityStore received error:', error);
			throw error;
		});
	},

	getCityFromPoint: function getCityFromPoint(point) {
		var _this2 = this;

		var adId = void 0;
		this.dataLoader.query([{
			query: 'SELECT ad_id, city, ST_distance(ST_setsrid(ST_MakePoint(holc_maps.looplng, holc_maps.looplat),4326), ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326)) as distance, st_xmin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmin, st_xmax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmax, st_ymin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymin, st_ymax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymax from holc_maps join holc_maps_ads_join on holc_maps.map_id = holc_maps_ads_join.map_id join holc_ads on holc_ads.city_id = holc_maps_ads_join.ad_id order by distance limit 1',
			format: 'JSON'
		}]).then(function (response) {
			_this2.data.users.city = response[0][0].city;
			_this2.data.users.adId = response[0][0].ad_id;

			_this2.emit(_AppActionCreator.AppActionTypes.userLocated);
		}, function (error) {
			// TODO: handle this.
			console.log('Location received error:', error);
			throw error;
		});
	},

	/* setter functions for state variable */

	setHighlightedHolcId: function setHighlightedHolcId(holcId) {
		this.data.highlightedHolcId = holcId;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedCategory: function setSelectedCategory(id) {
		this.data.selectedCategory = id;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedHolcId: function setSelectedHolcId(holcId) {
		this.data.selectedHolcId = holcId;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedGrade: function setSelectedGrade(grade) {
		this.data.selectedGrade = grade;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedRingGrade: function setSelectedRingGrade(selectedRingGrade) {
		this.data.selectedRingGrade = selectedRingGrade;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	/* getter functions */

	getHighlightedHolcId: function getHighlightedHolcId() {
		return this.data.highlightedHolcId;
	},

	getId: function getId() {
		return this.data.id;
	},

	getSelectedCategory: function getSelectedCategory() {
		return this.data.selectedCategory;
	},

	getSelectedHolcId: function getSelectedHolcId() {
		return this.data.selectedHolcId;
	},

	getSelectedGrade: function getSelectedGrade() {
		return this.data.selectedGrade;
	},

	getSelectedRingGrade: function getSelectedRingGrade() {
		return this.data.selectedRingGrade;
	},

	getName: function getName() {
		return this.data.name;
	},

	getState: function getState() {
		return this.data.state;
	},

	getFormId: function getFormId() {
		return this.data.form_id;
	},

	getRingStats: function getRingStats() {
		return this.data.ringStats;
	},

	getRingAreasGeometry: function getRingAreasGeometry() {
		return this.data.ringAreasGeometry;
	},

	getGradeStats: function getGradeStats() {
		return this.data.gradeStats;
	},

	getCityData: function getCityData() {
		return this.data.cityData;
	}

}, _defineProperty(_CityStore, 'getSelectedGrade', function getSelectedGrade() {
	return this.data.selectedGrade;
}), _defineProperty(_CityStore, 'getGeoJsonForSelectedRingArea', function getGeoJsonForSelectedRingArea(ring, grade) {
	return this.data.ringAreasGeometry[ring][grade].the_geojson;
}), _defineProperty(_CityStore, 'getInvertedGeoJsonForSelectedRingArea', function getInvertedGeoJsonForSelectedRingArea(ring, grade) {
	return this.data.ringAreasGeometry[ring][grade].inverted_geojson;
}), _defineProperty(_CityStore, 'getOuterRingRadius', function getOuterRingRadius() {
	return this.data.outerRingRadius;
}), _defineProperty(_CityStore, 'getLoopLatLng', function getLoopLatLng() {
	return this.data.loopLatLng;
}), _defineProperty(_CityStore, 'getPolygonsBounds', function getPolygonsBounds() {
	return this.data.polygonBoundingBox;
}), _defineProperty(_CityStore, 'getPolygonsCenter', function getPolygonsCenter() {
	return this.data.polygonsCenter;
}), _defineProperty(_CityStore, 'getSelectedByUser', function getSelectedByUser() {
	return this.data.selectedByUser;
}), _defineProperty(_CityStore, 'getUsersCity', function getUsersCity() {
	return this.data.users.city;
}), _defineProperty(_CityStore, 'getUsersAdId', function getUsersAdId() {
	return this.data.users.adId;
}), _defineProperty(_CityStore, 'getUsersNeighborhood', function getUsersNeighborhood() {
	return this.data.users.neighborhood;
}), _defineProperty(_CityStore, 'getADsByCat', function getADsByCat(cat, subcat) {
	if (!cat) {
		return this.data.ADsByCat;
	}

	if (!subcat && this.data.ADsByCat[cat]) {
		return this.data.ADsByCat[cat];
	} else if (subcat && this.data.ADsByCat[cat] && this.data.ADsByCat[cat][subcat]) {
		return this.data.ADsByCat[cat][subcat];
	}

	return false;
}), _defineProperty(_CityStore, 'getCategoryString', function getCategoryString(catNum, catLetter) {
	return catNum + (catLetter ? '-' + catLetter : '');
}), _defineProperty(_CityStore, 'getCatTitle', function getCatTitle(cat, subcat) {
	var formId = this.getFormId();
	if (!subcat) {
		return cat + ' ' + _formsMetadata2.default[formId][cat];
	} else if (subcat) {
		return cat + subcat + ' ' + _formsMetadata2.default[formId][cat].header + (_formsMetadata2.default[formId][cat].subcats[subcat] !== '' ? ': ' + _formsMetadata2.default[formId][cat].subcats[subcat] : '');
	} else {
		return false;
	}
}), _defineProperty(_CityStore, 'queryCategory', function queryCategory(catNum, catLetter) {
	var _this3 = this;

	if (Object.keys(this.data.areaDescriptions).length === 0) {
		return [];
	}

	var arr = []; // array to store results

	Object.keys(this.data.areaDescriptions).map(function (neighborhoodId, i) {
		if (_this3.data.areaDescriptions[neighborhoodId].areaDesc.hasOwnProperty(catNum) && typeof catLetter == 'undefined') {
			arr.push({ neighborhoodId: neighborhoodId, answer: _this3.data.areaDescriptions[neighborhoodId].areaDesc[catNum].a });
		} else if (_this3.data.areaDescriptions[neighborhoodId].areaDesc.hasOwnProperty(catNum) && _this3.data.areaDescriptions[neighborhoodId].areaDesc[catNum].hasOwnProperty(catLetter)) {
			arr.push({ neighborhoodId: neighborhoodId, answer: _this3.data.areaDescriptions[neighborhoodId].areaDesc[catNum][catLetter].a });
		} else {
			arr.push({ neighborhoodId: neighborhoodId, answer: null });
		}
	});

	arr.sort(this.alphanumCase);

	return arr;
}), _defineProperty(_CityStore, 'calculatedGradedArea', function calculatedGradedArea(geometries) {
	var gradedTotalArea = 0;
	geometries.forEach(function (d) {
		gradedTotalArea += d.area;
	});

	return gradedTotalArea;
}), _defineProperty(_CityStore, 'calculateGradedAreaOfRings', function calculateGradedAreaOfRings(geometries) {
	var gradedAreaOfRings = { 1: 0, 2: 0, 3: 0, 4: 0 };
	geometries.forEach(function (d) {
		gradedAreaOfRings[d.ring] += d.area;
	});

	return gradedAreaOfRings;
}), _defineProperty(_CityStore, 'calculateGradedAreaByGrade', function calculateGradedAreaByGrade(geometries) {
	var gradedAreaByGrade = { 'A': 0, 'B': 0, 'C': 0, 'D': 0 };
	geometries.forEach(function (d) {
		gradedAreaByGrade[d.grade] += d.area;
	});

	return gradedAreaByGrade;
}), _defineProperty(_CityStore, 'parseRingAreaGeometry', function parseRingAreaGeometry(geometries) {
	var _this4 = this;

	if (geometries.length == 0) {
		return false;
	}

	var defaultProps = {
		the_geojson: {},
		inverted_geojson: {},
		percent: 0,
		overallPercent: 0
	},
	    ringAreasGeometry = {
		1: { A: defaultProps, B: defaultProps, C: defaultProps, D: defaultProps },
		2: { A: defaultProps, B: defaultProps, C: defaultProps, D: defaultProps },
		3: { A: defaultProps, B: defaultProps, C: defaultProps, D: defaultProps },
		4: { A: defaultProps, B: defaultProps, C: defaultProps, D: defaultProps }
	};

	geometries.forEach(function (d) {
		ringAreasGeometry[d.ring].density = _this4.data.gradedAreaOfRings[d.ring] / d.ring_area;
		ringAreasGeometry[d.ring][d.grade] = {
			'the_geojson': JSON.parse(d.the_geojson),
			'inverted_geojson': JSON.parse(d.inverted_geojson),
			'percent': d.area / _this4.data.gradedAreaOfRings[d.ring],
			'overallPercent': d.area / _this4.data.gradedArea
		};
	});

	return ringAreasGeometry;
}), _defineProperty(_CityStore, 'parseRingStats', function parseRingStats(ringStats) {
	if (!ringStats || ringStats.length == 0) {
		return false;
	}

	/* let ringCumulative = {
 		1: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0},
 		2: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0},
 		3: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0},
 		4: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0}
 	},
 	areaOfRings = {},
 	totalGradedArea = 0, 
 	ringStats = { 1 : {}, 2: {}, 3: {}, 4: {} };
 ringAreaGeometry.forEach((ring) => {
 	ringCumulative[ring.ring_id][ring.holc_grade] += ring.area;
 	ringCumulative[ring.ring_id].total += ring.area;
 	areaOfRings[ring.ring_id] = ring.ring_area;
 	totalGradedArea += ring.area;
 });
 console.log(totalGradedArea);
 Object.keys(ringCumulative).map((ring_id) => {
 	Object.keys(ringCumulative[ring_id]).map((grade) => {
 		ringStats[ring_id][grade] = (ringStats[ring_id][grade]) ? ringStats[ring_id][grade] : {};
 		ringStats[ring_id][grade].percent = ringCumulative[ring_id][grade] / ringCumulative[ring_id].total;
 		ringStats[ring_id].density = ringCumulative[ring_id].total / areaOfRings[ring_id];
 		ringStats[ring_id][grade].overallPercent = ringCumulative[ring_id][grade] / totalGradedArea;
 	});
 }); */

	//format for D3
	var formattedStats = [];
	for (var ringId = 1; ringId <= 4; ringId++) {
		formattedStats.push({
			percents: [{ percent: ringStats[ringId].A.percent, overallPercent: ringStats[ringId].A.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'A' }, { percent: ringStats[ringId].B.percent, overallPercent: ringStats[ringId].B.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'B' }, { percent: ringStats[ringId].C.percent, overallPercent: ringStats[ringId].C.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'C' }, { percent: ringStats[ringId].D.percent, overallPercent: ringStats[ringId].D.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'D' }] });
	}

	return formattedStats;
}), _defineProperty(_CityStore, 'hasLoaded', function hasLoaded() {
	return this.data.hasLoaded;
}), _defineProperty(_CityStore, 'parseGradeStats', function parseGradeStats(ringAreasGeometry) {
	var _this5 = this;

	var grades = ['A', 'B', 'C', 'D'];

	//format for D3
	return grades.map(function (grade) {
		return {
			grade: grade,
			percent: _this5.data.gradedAreaByGrade[grade] / _this5.data.gradedArea
		};
	});
}), _defineProperty(_CityStore, 'parseInvertedGeoJson', function parseInvertedGeoJson(geojson) {
	//Create a new set of latlngs, adding our world-sized ring first
	var NWHemisphere = [[0, 0], [0, 90], [-180, 90], [-180, 0], [0, 0]],
	    newLatLngs = [NWHemisphere],
	    holes = [];

	geojson.coordinates.forEach(function (polygon, i) {
		polygon.forEach(function (polygonpieces, i2) {
			if (i2 == 0) {
				newLatLngs.push(polygonpieces);
			} else {
				holes.push(polygonpieces);
			}
		});
	});
	geojson.coordinates = holes.length > 0 ? [newLatLngs.concat(holes)] : [newLatLngs];
	return geojson;
}), _defineProperty(_CityStore, 'alphanumCase', function alphanumCase(a, b) {
	function chunkify(t) {
		var tz = new Array();
		var x = 0,
		    y = -1,
		    n = 0,
		    i,
		    j;
		while (i = (j = t.charAt(x++)).charCodeAt(0)) {
			var m = i == 46 || i >= 48 && i <= 57;
			if (m !== n) {
				tz[++y] = '';
				n = m;
			}
			tz[y] += j;
		}
		return tz;
	}

	var aa = a.neighborhoodId ? chunkify(a.neighborhoodId.toLowerCase()) : chunkify(a.toLowerCase());
	var bb = b.neighborhoodId ? chunkify(b.neighborhoodId.toLowerCase()) : chunkify(b.toLowerCase());
	for (var x = 0; aa[x] && bb[x]; x++) {
		if (aa[x] !== bb[x]) {
			var c = Number(aa[x]),
			    d = Number(bb[x]);
			if (c == aa[x] && d == bb[x]) {
				return c - d;
			} else return aa[x] > bb[x] ? 1 : -1;
		}
	}
	return aa.length - bb.length;
}), _CityStore);

// Mixin EventEmitter functionality
Object.assign(CityStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
CityStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.ADCategorySelected:
			CityStore.setSelectedCategory(action.value);
			CityStore.setSelectedHolcId(null);
			break;

		case _AppActionCreator.AppActionTypes.loadInitialData:
			if (action.state.selectedCity) {
				CityStore.loadData(action.state.selectedCity, true);
			}
			if (action.state.selectedNeighborhood) {
				CityStore.setSelectedHolcId(action.state.selectedNeighborhood);
			}
			if (action.state.selectedCategory) {
				CityStore.setSelectedCategory(action.state.selectedCategory);
			}
			break;

		case _AppActionCreator.AppActionTypes.citySelected:
			CityStore.loadData(action.value, action.selectedByUser);
			CityStore.setSelectedHolcId(null);
			CityStore.setSelectedCategory(null);
			break;

		case _AppActionCreator.AppActionTypes.gradeSelected:
			CityStore.setSelectedGrade(action.value);
			break;

		case _AppActionCreator.AppActionTypes.neighborhoodHighlighted:
			CityStore.setHighlightedHolcId(action.holcId);
			break;

		case _AppActionCreator.AppActionTypes.neighborhoodSelected:
			CityStore.setSelectedCategory(null);
			CityStore.setSelectedHolcId(action.holcId);
			if (action.adId !== CityStore.getId()) {
				CityStore.loadData(action.adId, false);
			}
			break;

		case _AppActionCreator.AppActionTypes.ringGradeSelected:
			CityStore.setSelectedRingGrade(action.value);
			break;

		case _AppActionCreator.AppActionTypes.mapMoved:
			_AppDispatcher2.default.waitFor([_MapStateStore2.default.dispatchToken]);

			// you have to wait for initial load of mapstore
			var waitingInitialLoad = setInterval(function () {
				clearInterval(waitingInitialLoad);

				var visibleAdIds = _MapStateStore2.default.getVisibleAdIds();
				// unload city if nothing's visible or below zoom threshold
				if (visibleAdIds.length == 0 || !_MapStateStore2.default.isAboveZoomThreshold()) {
					CityStore.loadData(null);
				}
				// load a city if there's only one visible and it's different
				else if (visibleAdIds.length == 1 && visibleAdIds[0] !== CityStore.getId()) {
						CityStore.loadData(visibleAdIds[0], { zoomTo: false });
					}
					// unload the city if there are more than one but it's not among them
					else if (visibleAdIds.length > 1 && visibleAdIds.indexOf(CityStore.getId()) == -1) {
							CityStore.loadData(null);
						}
						// unload city if more than one are visible and it's below the zoom threshold
						else if (visibleAdIds.length > 1 && !_MapStateStore2.default.isAboveZoomThreshold()) {
								CityStore.loadData(null);
							}
			}, 100);
			break;
	}

	return true;
});

exports.default = CityStore;

},{"../../data/formsMetadata.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/formsMetadata.json","../stores/MapStateStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/MapStateStore.js","../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/CartoDBLoader.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/DimensionsStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DimensionsStore = {

	data: {
		containerPadding: 20,
		headerHeight: 100,
		tilesHeight: window.innerHeight - 140, // two paddings + headerHeight
		sidebarTitleBottomMargin: 10,
		adNavHeight: 20,

		sidebarWidth: 0,
		mainPaneWidth: 0,
		sidebarTitleHeight: 0
	},

	computeComponentDimensions: function computeComponentDimensions() {
		this.data.tilesHeight = window.innerHeight - this.data.headerHeight - 2 * this.data.containerPadding;
		this.data.sidebarWidth = document.getElementsByClassName('dataViewer').length > 0 ? document.getElementsByClassName('dataViewer')[0].offsetWidth : 0;
		this.data.mainPaneWidth = document.getElementsByClassName('main-pane').length > 0 ? document.getElementsByClassName('main-pane')[0].offsetWidth : 0;
		this.data.sidebarTitleHeight = document.getElementsByClassName('sidebarTitle').length > 0 ? document.getElementsByClassName('sidebarTitle')[0].offsetHeight : 0;

		console.log(this.data);

		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},
	getDimensions: function getDimensions() {
		return this.data;
	},


	getMainPaneStyle: function getMainPaneStyle() {
		return { height: this.data.tilesHeight + 'px' };
	},

	getSidebarHeightStyle: function getSidebarHeightStyle() {
		// same as the main panel style as it's just the height
		return this.getMainPaneStyle();
	},

	getADViewerStyle: function getADViewerStyle() {
		return {
			height: this.data.tilesHeight - this.data.containerPadding * 2 + 'px',
			width: this.data.mainPaneWidth - this.data.containerPadding * 2 + 'px'
		};
	},

	// this needs to be redone

	getSearchStyle: function getSearchStyle() {
		return {
			width: window.innerWidth / 3 - 2 * this.data.containerPadding + 'px',
			height: window.innerHeight - 2 * this.data.containerPadding + 'px'
		};
	},

	getADNavPreviousStyle: function getADNavPreviousStyle() {
		return {
			width: this.data.tilesHeight + 'px',
			top: (this.data.tilesHeight + this.data.containerPadding) / 2 + this.data.headerHeight + 'px',
			right: this.data.containerPadding * 1.5 - this.data.tilesHeight / 2 + this.data.sidebarWidth - this.data.adNavHeight + 'px'
		};
	},

	getADNavNextStyle: function getADNavNextStyle() {
		return {
			width: this.data.tilesHeight + 'px',
			top: (this.data.tilesHeight + this.data.containerPadding) / 2 + this.data.headerHeight + 'px',
			right: this.data.containerPadding * 1.5 - this.data.tilesHeight / 2 + 'px'
		};
	},

	getSidebarMapStyle: function getSidebarMapStyle() {
		console.log(this.data.tilesHeight, this.data.sidebarTitleHeight, this.data.containerPadding);
		return {
			width: this.data.sidebarWidth - 2 * this.data.adNavHeight + 'px',
			height: this.data.tilesHeight - this.data.sidebarTitleHeight - this.data.sidebarTitleBottomMargin - 2 * this.data.containerPadding + 'px'
		};
	}

};

// Mixin EventEmitter functionality
Object.assign(DimensionsStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
DimensionsStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {
		case _AppActionCreator.AppActionTypes.loadInitialData:
		case _AppActionCreator.AppActionTypes.mapInitialized:
		case _AppActionCreator.AppActionTypes.windowResized:
			DimensionsStore.computeComponentDimensions();
			break;
	}
});

exports.default = DimensionsStore;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/MapStateStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _AreaDescriptionsStore = require('../stores/AreaDescriptionsStore');

var _AreaDescriptionsStore2 = _interopRequireDefault(_AreaDescriptionsStore);

var _CityStore = require('../stores/CityStore');

var _CityStore2 = _interopRequireDefault(_CityStore);

var _RasterStore = require('../stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MapStateStore = {

	data: {
		theMap: null,
		center: [39.8333333, -98.585522],
		zoom: 12,
		bounds: null,
		visibleHOLCMaps: {},
		visibleHOLCMapsIds: [],
		visibleAdIds: [],
		adZoomThreshold: 9,
		hasLoaded: false
	},

	loadData: function loadData(theMap, rasters, adsMetadata) {
		var theBounds = theMap.getBounds();
		var visibleHOLCMaps = {},
		    visibleHOLCMapsIds = [],
		    visibleHOLCMapsByState = {},
		    visibleAdIds = [];

		Object.keys(rasters).forEach(function (id) {
			if (theBounds.intersects(rasters[id].bounds)) {
				visibleHOLCMaps[id] = rasters[id];
				visibleHOLCMapsIds.push(parseInt(id));
			}
		});

		Object.keys(adsMetadata).forEach(function (ad_id) {
			if (theBounds.intersects(adsMetadata[ad_id].bounds)) {
				if (visibleAdIds.indexOf(ad_id) == -1) {
					visibleAdIds.push(parseInt(ad_id));
				}
			}
		});

		// // organize by state
		// visibleHOLCMapsIds.forEach((id) => {
		// 	visibleHOLCMapsByState[visibleHOLCMaps[id].state] = (visibleHOLCMapsByState[visibleHOLCMaps[id].state]) ? visibleHOLCMapsByState[visibleHOLCMaps[id].state] : [];
		// 	visibleHOLCMapsByState[visibleHOLCMaps[id].state].push(visibleHOLCMaps[id]);
		// });
		// // alphabetize
		// Object.keys(visibleHOLCMapsByState).forEach((the_state) => {
		// 	visibleHOLCMapsByState[the_state].sort((a,b) => a.city > b.city);
		// });

		// organize by state
		visibleAdIds.forEach(function (id) {
			if (adsMetadata[id]) {
				visibleHOLCMapsByState[adsMetadata[id].state] = visibleHOLCMapsByState[adsMetadata[id].state] ? visibleHOLCMapsByState[adsMetadata[id].state] : [];
				visibleHOLCMapsByState[adsMetadata[id].state].push(adsMetadata[id]);
			}
		});
		// alphabetize
		Object.keys(visibleHOLCMapsByState).forEach(function (the_state) {
			visibleHOLCMapsByState[the_state].sort(function (a, b) {
				return a.city > b.city;
			});
		});

		this.data.theMap = theMap;
		this.data.center = [theMap.getCenter().lat, theMap.getCenter().lng];
		this.data.zoom = theMap.getZoom();
		this.data.bounds = theBounds;
		this.data.visibleHOLCMaps = visibleHOLCMaps;
		this.data.visibleHOLCMapsIds = visibleHOLCMapsIds;
		this.data.visibleHOLCMapsByState = visibleHOLCMapsByState;
		this.data.visibleAdIds = visibleAdIds;

		this.data.hasLoaded = true;

		// console.log('MapStateStore finished loading');

		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setView: function setView(zoom, center) {
		this.data.zoom = zoom;
		this.data.center = center;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	getTheMap: function getTheMap() {
		return this.data.theMap;
	},

	getCenter: function getCenter() {
		return this.data.center;
	},

	getZoom: function getZoom() {
		return this.data.zoom;
	},

	getBounds: function getBounds() {
		return this.data.bounds;
	},

	getVisibleHOLCMaps: function getVisibleHOLCMaps() {
		return this.data.visibleHOLCMaps;
	},

	getVisibleHOLCMapsList: function getVisibleHOLCMapsList() {
		var _this = this;

		return Object.keys(this.data.visibleHOLCMaps).map(function (mapId) {
			return _this.data.visibleHOLCMaps[mapId];
		});
	},

	getVisibleHOLCMapsIds: function getVisibleHOLCMapsIds() {
		return this.data.visibleHOLCMapsIds;
	},

	getVisibleHOLCMapsByState: function getVisibleHOLCMapsByState() {
		return this.data.visibleHOLCMapsByState;
	},


	getVisibleAdIds: function getVisibleAdIds() {
		return this.data.visibleAdIds;
	},

	isAboveZoomThreshold: function isAboveZoomThreshold() {
		return this.data.zoom >= this.data.adZoomThreshold;
	}
};

// Mixin EventEmitter functionality
Object.assign(MapStateStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
MapStateStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.loadInitialData:
			// you have to wait for RasterStore and, if a city is requested in the hash, CityStore to finish their initial load
			var waitingInitialLoad = setInterval(function () {
				if (_RasterStore2.default.hasLoaded() && (!action.state.selectedCity || _CityStore2.default.hasLoaded())) {
					clearInterval(waitingInitialLoad);

					var zoom = void 0,
					    center = void 0;

					if (action.hashState.loc) {
						zoom = action.hashState.loc.zoom;
						center = action.hashState.loc.center;
					} else if (_CityStore2.default.getId()) {
						zoom = 12;
						center = _CityStore2.default.getPolygonsCenter() ? _CityStore2.default.getPolygonsCenter() : _RasterStore2.default.getCenter();
					} else {
						zoom = action.state.map.zoom;
						center = action.state.map.center;
					}

					MapStateStore.setView(zoom, center);
				}
			}, 100);
			break;

		case _AppActionCreator.AppActionTypes.mapInitialized:
			MapStateStore.loadData(action.theMap, action.rasters, action.adsMetadata);

			// if a city has been selected (though the hash), set the new bounds
			if (_CityStore2.default.getId()) {
				var bounds = _CityStore2.default.getPolygonsBounds() ? _CityStore2.default.getPolygonsBounds() : _RasterStore2.default.getMapBounds(),
				    newZoom = action.theMap.getBoundsZoom(bounds),
				    newCenter = _CityStore2.default.getPolygonsCenter() ? _CityStore2.default.getPolygonsCenter() : _RasterStore2.default.getCenter();
				//MapStateStore.setView(newZoom, newCenter);
			}
			break;

		case _AppActionCreator.AppActionTypes.mapMoved:
			MapStateStore.loadData(action.theMap, action.rasters, action.adsMetadata);
			break;

		case _AppActionCreator.AppActionTypes.citySelected:
			// you have to wait for CityStore and RasterStore to finish their initial load
			_AppDispatcher2.default.waitFor([_RasterStore2.default.dispatchToken]);

			var waitingId = setInterval(function () {
				if (action.value == _CityStore2.default.getId()) {
					clearInterval(waitingId);

					if (action.selectedByUser && MapStateStore.getTheMap() !== null) {
						var _bounds = _CityStore2.default.getPolygonsBounds() ? _CityStore2.default.getPolygonsBounds() : _RasterStore2.default.getMapBounds(),
						    _newZoom = MapStateStore.getTheMap().getBoundsZoom(_bounds),
						    _newCenter = _CityStore2.default.getPolygonsCenter() ? _CityStore2.default.getPolygonsCenter() : _RasterStore2.default.getCenter();
						MapStateStore.setView(_newZoom, _newCenter);
					}
				}
			}, 100);
			break;

		case _AppActionCreator.AppActionTypes.ADImageOpened:
			if (MapStateStore.getTheMap() !== null) {
				var _bounds2 = _AreaDescriptionsStore2.default.getNeighborhoodBoundingBox(action.adId, action.holcId),
				    _newZoom2 = -1 + MapStateStore.getTheMap().getBoundsZoom(_bounds2),
				    _newCenter2 = _AreaDescriptionsStore2.default.getNeighborhoodCenter(action.adId, action.holcId);
				MapStateStore.setView(_newZoom2, _newCenter2);
			}
	}
	return true;
});

exports.default = MapStateStore;

},{"../stores/AreaDescriptionsStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/AreaDescriptionsStore.js","../stores/CityStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/CityStore.js","../stores/RasterStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/RasterStore.js","../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/RasterStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

var _state_abbr = require('../../data/state_abbr.json');

var _state_abbr2 = _interopRequireDefault(_state_abbr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RasterStore = {

	data: {
		/**
   * Metadata about the maps
   * by year (third order), city (second order), and state, first order
   * {
   *   stateX: {
   *     cityX: {
   *       yearx: {
   *         url: 'str',
   *         bounds: 'latlngbounds',
   *         minZoom: int,
   *         maxtZoom: int
   *       },
   *       yearY: { ... }
   *     },
   *     cityY: { ... },
   *     name: 'str',
   *     description: 'str',
   *     units: 'str'
   *   },
   *   stateY: { ... },
   *   ...
   * }
   */
		maps: {},
		citiesWithPolygons: {},
		cityIdsWithADs: [],

		selectedCity: null,
		selectedState: null,
		loaded: false

	},

	// TODO: Make a generic DataLoader class to define an interface,
	// and let CartoDBLoader extend and implement that?
	// Basic idea is that anything with a query method that returns a Promise
	// that resolves with an array of response data or rejects with an error
	// can be used here.
	dataLoader: _CartoDBLoader2.default,

	loadInitialData: function loadInitialData(state) {
		var _this = this;

		this.dataLoader.query([{
			query: 'SELECT population_1940, population_1930, american_indian_eskimo_1930, american_indian_eskimo_1940, asian_pacific_ilslander_1930 as asian_pacific_islander_1930, asian_pacific_ilslander_1940 as asian_pacific_islander_1940, black_pop_1930, black_pop_1940, white_pop_1930, white_pop_1940, ad_id, holc_maps.*, st_xmin(holc_maps.the_geom) as minLng, st_xmax(holc_maps.the_geom) as maxLng, st_ymin(holc_maps.the_geom) as minLat, st_ymax(holc_maps.the_geom) as maxLat, st_x(st_centroid(holc_maps.the_geom)) as centerLng, st_y(st_centroid(holc_maps.the_geom)) as centerLat FROM holc_maps join holc_maps_ads_join hmaj on hmaj.map_id = holc_maps.map_id join holc_ads on holc_ads.city_id = hmaj.ad_id order by parent_id desc',
			format: 'JSON'
		}, {
			query: 'SELECT distinct(holc_ads.city_id), state, city FROM holc_ad_data join digitalscholarshiplab.holc_polygons on polygon_id = holc_polygons.neighborhood_id join holc_ads on holc_polygons.ad_id = holc_ads.city_id order by state, city',
			format: 'JSON'
		}, {
			query: "SELECT ad_id, sum(st_area(the_geom_webmercator)) / 1609.34^2 as total_area, sum(CASE WHEN holc_grade = 'A' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_a, sum(CASE WHEN holc_grade = 'B' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_b, sum(CASE WHEN holc_grade = 'C' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_c, sum(CASE WHEN holc_grade = 'D' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_d FROM digitalscholarshiplab.holc_polygons group by ad_id order by ad_id desc",
			format: 'JSON'
		}]).then(function (response) {
			_this.data.maps = _this.parseMapData(response[0], response[2], response[1]);
			_this.data.cityIdsWithADs = response[1].map(function (row) {
				return row.id;
			});

			_this.data.selectedCity = state.selectedCity;
			_this.data.selectedState = response[2][0].state;

			_this.data.loaded = true;

			// console.log('RasterStore finished loading');

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('RasterStore received error:', error);
			throw error;
		});
	},

	/**
  * The selected city for the whole application to display.
  */
	setSelectedCity: function setSelectedCity(cityId) {
		this.data.selectedCity = cityId;
	},

	setSelectedState: function setSelectedState(state) {
		if (typeof state !== 'undefined' && state !== this.data.selectedState) {
			this.data.selectedCity = undefined;
			this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}
	},

	getAllRasters: function getAllRasters() {
		return this.data.maps;
	},

	getSelectedCity: function getSelectedCity() {
		return this.data.selectedCity;
	},

	getAllCitiesWithPolygons: function getAllCitiesWithPolygons() {
		return this.data.citiesWithPolygons;
	},

	// returns everything or a specified attribute
	getSelectedCityMetadata: function getSelectedCityMetadata() {
		var key = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

		if (!this.getSelectedCity()) {
			return null;
		}
		return key ? this.data.maps[this.getSelectedCity()][key] : this.data.maps[this.getSelectedCity()];
	},

	getCityMetadata: function getCityMetadata(city_id) {
		var key = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		return this.data.maps[city_id] ? key && this.data.maps[city_id][key] ? this.data.maps[city_id][key] : this.data.maps[city_id] : null;
	},

	getSelectedState: function getSelectedState() {
		return this.data.selectedState;
	},


	getMapBounds: function getMapBounds() {
		return [[this.getSelectedCityMetadata('minLat'), this.getSelectedCityMetadata('minLng')], [this.getSelectedCityMetadata('maxLat'), this.getSelectedCityMetadata('maxLng')]];
	},

	getMapBoundsByAdId: function getMapBoundsByAdId(adId) {
		return [[this.data.maps[adId].minLat, this.data.maps[adId].minLng], [this.data.maps[adId].maxLat, this.data.maps[adId].maxLng]];
	},

	getCityNames: function getCityNames() {
		var _this2 = this;

		return Object.keys(this.data.maps).map(function (id) {
			return _this2.data.maps[id].city + ', ' + _state_abbr2.default[_this2.data.maps[id].state];
		});
	},

	getCityIdsWithNames: function getCityIdsWithNames() {
		var _this3 = this;

		var idsAndNames = {};

		Object.keys(this.data.maps).forEach(function (id) {
			idsAndNames[id] = _this3.data.maps[id].city + ', ' + _state_abbr2.default[_this3.data.maps[id].state];
		});

		return idsAndNames;
	},

	getCityIdsAndNames: function getCityIdsAndNames() {
		var _this4 = this;

		return Object.keys(this.data.maps).map(function (id) {
			return {
				id: parseInt(id),
				cityName: _this4.data.maps[id].city + ', ' + _state_abbr2.default[_this4.data.maps[id].state]
			};
		});
	},

	getCenter: function getCenter() {
		return [this.getSelectedCityMetadata('centerLat'), this.getSelectedCityMetadata('centerLng')];
	},

	getCenterOld: function getCenterOld() {
		var bounds = this.getMapBounds();
		return [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
	},

	getMapBoundsForState: function getMapBoundsForState(state) {
		var minLat = 90,
		    minLng = 0,
		    maxLat = 0,
		    maxLng = -180;
		var citiesForState = this.getCitiesForState(state);

		citiesForState.forEach(function (cityData) {
			minLat = cityData.minLat && cityData.minLat < minLat ? cityData.minLat : minLat;
			maxLat = cityData.maxLat && cityData.maxLat > maxLat ? cityData.maxLat : maxLat;
			minLng = cityData.minLng && cityData.minLng < minLng ? cityData.minLng : minLng;
			maxLng = cityData.maxLng && cityData.maxLng > maxLng ? cityData.maxLng : maxLng;
		});

		return [[minLat, minLng], [maxLat, maxLng]];
	},

	getCenterForState: function getCenterForState(state) {
		var bounds = this.getMapBoundsForState(state);
		return [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
	},

	getCitiesForState: function getCitiesForState(state) {
		return this.getCitiesList().filter(function (cityData) {
			return cityData.state == state;
		});
	},

	getMapUrl: function getMapUrl() {
		return this.getSelectedCityMetadata('mapurl');
	},

	getMapThumbnail: function getMapThumbnail() {
		return this.getSelectedCityMetadata('mapThumbnail');
	},

	// return a flat list of the HOLC maps for rendering
	getCitiesList: function getCitiesList() {
		var cities = this.combineCitiesLists();
		return Object.keys(cities).map(function (cityId) {
			return cities[cityId];
		});
	},

	getStatesObject: function getStatesObject() {
		var _this5 = this;

		var statesObject = {};
		Object.keys(this.data.maps).map(function (cityId) {
			statesObject[_this5.data.maps[cityId].state] = {
				id: _this5.data.maps[cityId].state,
				name: _state_abbr2.default[_this5.data.maps[cityId].state],
				citiesIds: _this5.getCitiesForState(_this5.data.maps[cityId].state).map(function (cityData) {
					return cityData.id;
				})
			};
		});
		return statesObject;
	},

	getStatesList: function getStatesList() {
		var states = this.getStatesObject();
		return Object.keys(states).map(function (stateAbbr) {
			return states[stateAbbr];
		});
	},

	getStatesWithFirstCities: function getStatesWithFirstCities() {
		var _this6 = this;

		var states = [],
		    cities = this.combineCitiesLists(),
		    stateInList = function stateInList(state) {
			var inList = false;
			states.map(function (cityData) {
				if (cityData.state == state) {
					inList = true;
				}
			});
			return inList;
		};

		Object.keys(cities).map(function (cityId) {
			if (!stateInList(_this6.data.maps[cityId].state)) {
				states.push(Object.assign({}, _this6.data.maps[cityId]));
			}
		});

		states.map(function (cityData) {
			cityData.name = _state_abbr2.default[cityData.state];
		});

		return states;
	},

	getFirstCityOfState: function getFirstCityOfState(state) {
		var statesWithFirstCities = this.getStatesWithFirstCities();
		for (var i in statesWithFirstCities) {
			if (statesWithFirstCities[i].state == state) {
				return statesWithFirstCities[i];
			}
		}
	},

	hasLoaded: function hasLoaded() {
		return this.data.loaded;
	},

	selectedHasPolygons: function selectedHasPolygons() {
		return this.data.maps[this.data.selectedCity] ? this.data.maps[this.data.selectedCity].hasPolygons : false;
	},

	calculateSimpleRingsRadii: function calculateSimpleRingsRadii(areaData) {
		var furthestRadius = 25000,
		    fullArea = Math.PI * furthestRadius * furthestRadius,
		    outerRadius = void 0,
		    innerRadius = 0,
		    donutArea = void 0,
		    gradeArea = void 0,
		    radii = {};

		['d', 'c', 'b', 'a'].forEach(function (grade) {
			var donutholeArea = Math.PI * innerRadius * innerRadius,
			    gradeArea = fullArea * (areaData[grade] / areaData.total),
			    outerRadius = Math.round(Math.sqrt((gradeArea + donutholeArea) / Math.PI));
			radii[grade] = {
				'inner': innerRadius,
				'outer': outerRadius
			};
			innerRadius = outerRadius;
		});

		return radii;
	},

	getSelectedMaps: function getSelectedMaps(requestedMapIds) {
		var selectedAd = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		var selectedMaps = [];
		var allMaps = this.getMapsList();

		allMaps.forEach(function (map) {
			if (requestedMapIds.indexOf(map.ad_id) !== -1 && map.ad_id !== selectedAd) {
				selectedMaps.push(map);
			}
		});

		allMaps.forEach(function (map) {
			if (requestedMapIds.indexOf(map.ad_id) !== -1 && map.ad_id == selectedAd) {
				selectedMaps.push(map);
			}
		});

		return selectedMaps;
	},

	// return a flat list of the HOLC maps for rendering
	getMapsList: function getMapsList() {
		var _this7 = this;

		return Object.keys(this.data.maps).map(function (cityId) {
			return _this7.data.maps[cityId];
		});
	},

	parseMapData: function parseMapData(citiesData, citiesWithPolygonsData, citiesWithADs) {
		var _this8 = this;

		var maps = {};

		citiesData.forEach(function (mapData) {
			maps[mapData.map_id] = {
				cityId: mapData.ad_id,
				id: mapData.map_id,
				ad_id: parseInt(mapData.ad_id),
				parent_id: mapData.parent_id,
				city: mapData.name,
				state: mapData.state,
				searchName: mapData.parent_id ? '' : mapData.name + ', ' + _state_abbr2.default[mapData.state],
				name: mapData.name, // + ", " + mapData.state,
				minZoom: mapData.minzoom,
				maxZoom: mapData.maxzoom,
				bounds: [[mapData.minlat, mapData.minlng], [mapData.maxlat, mapData.maxlng]],
				minLat: mapData.minlat,
				maxLat: mapData.maxlat,
				minLng: mapData.minlng,
				maxLng: mapData.maxlng,
				centerLat: mapData.centerlat,
				centerLng: mapData.centerlng,
				population_1930: mapData.population_1930,
				population_1940: mapData.population_1940,
				american_indian_eskimo_1930: mapData.american_indian_eskimo_1930,
				american_indian_eskimo_1940: mapData.american_indian_eskimo_1940,
				asian_pacific_islander_1930: mapData.asian_pacific_islander_1930,
				asian_pacific_islander_1940: mapData.asian_pacific_islander_1940,
				black_pop_1930: mapData.black_pop_1930,
				black_pop_1940: mapData.black_pop_1940,
				white_pop_1930: mapData.white_pop_1930,
				white_pop_1940: mapData.white_pop_1940,
				hasPolygons: false,
				hasADs: false,
				url: 'http://holc.s3-website-us-east-1.amazonaws.com/tiles/' + mapData.state + '/' + mapData.file_name.replace(/\s+/g, '') + '/' + mapData.year + '/{z}/{x}/{y}.png',
				mapurl: 'http://holc.s3-website-us-east-1.amazonaws.com/tiles/' + mapData.state + '/' + mapData.file_name.replace(/\s+/g, '') + '/' + mapData.year + '/holc-scan.jpg',
				mapThumbnail: '//holc.s3-website-us-east-1.amazonaws.com/tiles/' + mapData.state + '/' + mapData.file_name.replace(/\s+/g, '') + '/' + mapData.year + '/thumbnail.jpg'
			};
		});

		citiesWithPolygonsData.forEach(function (areaData) {
			if (maps[areaData.ad_id]) {
				maps[areaData.ad_id].hasPolygons = true, maps[areaData.ad_id].area = {
					'total': areaData.total_area,
					'a': areaData.area_a,
					'b': areaData.area_b,
					'c': areaData.area_c,
					'd': areaData.area_d
				}, maps[areaData.ad_id].radii = _this8.calculateSimpleRingsRadii(maps[areaData.ad_id].area);
			}
		});

		citiesWithADs.forEach(function (areaData) {
			if (maps[areaData.id]) {
				maps[areaData.id].hasADs = true;
			}
		});

		return maps;
	},

	parseCitiesWithPolygonsData: function parseCitiesWithPolygonsData(data) {
		var _this9 = this;

		var cities = {};

		data.forEach(function (citiesData) {
			cities[citiesData.id] = {
				adId: citiesData.id,
				id: citiesData.id,
				city: citiesData.city,
				state: citiesData.state,
				name: citiesData.city + (_this9.data.cityIdsWithADs.indexOf(citiesData.id) != -1 ? ' **' : ' *'), // ", " + stateAbbrs[citiesData.state] +
				minLat: citiesData.minlat,
				maxLat: citiesData.maxlat,
				minLng: citiesData.minlng,
				maxLng: citiesData.maxlng,
				centerLat: citiesData.centerlat,
				centerLng: citiesData.centerlng,
				hasPolygons: true,
				hasADs: _this9.data.cityIdsWithADs.indexOf(citiesData.id) != -1
			};
		});

		return cities;
	},

	combineCitiesLists: function combineCitiesLists() {
		var _this10 = this;

		var combinedList = {};
		Object.keys(this.data.maps).map(function (id, i) {
			combinedList[id] = _this10.data.citiesWithPolygons[id] ? _this10.data.citiesWithPolygons[id] : _this10.data.maps[id];
		});

		return combinedList;
	}

};

// Mixin EventEmitter functionality
Object.assign(RasterStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
RasterStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.loadInitialData:
			RasterStore.loadInitialData(action.state);
			if (action.state.selectedCity) {
				RasterStore.setSelectedCity(action.state.selectedCity);
			}
			break;

		case _AppActionCreator.AppActionTypes.citySelected:
			RasterStore.setSelectedCity(action.value);
			break;
	}

	return true;
});

exports.default = RasterStore;

},{"../../data/state_abbr.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/data/state_abbr.json","../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/CartoDBLoader.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/TextsStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextsStore = {

	data: {
		modal: {
			open: false,
			subject: null
		},
		about: ["<h2>Introduction</h2>", "<p><cite>Mapping Inequality</cite> updates the study of New Deal America, the federal government, housing, and inequality for the twenty-first century. It offers unprecedented online access to the national collection of \"	security maps\" and area descriptions produced between 1935 and 1940 by one of the New Deal's most important agencies, the Home Owners' Loan Corporation or HOLC (pronounced \"holk\"). </p>", "<p>HOLC recruited mortgage lenders, developers, and real estate appraisers in nearly 250 cities to create maps that color-coded credit worthiness and risk on neighborhood and metropolitan levels. These maps and their accompanying documentation helped set the rules for nearly a century of real estate practice. They have also served as critical evidence in countless urban studies in the fields of history, sociology, economics, and law.  Indeed, more than a half-century of research has shown housing to be for the twentieth century what slavery was to the antebellum period, namely the broad foundation of both American prosperity and racial inequality.  Through offering a digital library of the state's role in housing development, Mapping Inequality illustrates vividly the interplay between racism, administrative culture, economics, and the built environment.</p>", "<p><cite>Mapping Inequality</cite> introduces viewers to the records of the Home Owners Loan Corporation with accessibility and on a scale that is unprecedented. Visitors can browse over two-hundred interactive maps and get a view of Depression-era America as developers, realtors, tax assessors, and surveyors saw it&#8212;a set of interlocking color-lines, racial groups, and environmental risks.  They can also use the maps and area descriptions to draw connections between past state actions (and inactions) and contemporary American problems.</p>", "<h3>Archiving Inequality for the Digital Age</h3>", "<p>Like so many other government agencies during the New Deal, HOLC and its parent bureau, the Federal Home Loan Bank Board, shaped Americans' lives and livelihoods profoundly during and after the Great Depression of the 1930s. Both proved critical to protecting and expanding home ownership, to standardizing lending practices, and to encouraging residential and commercial real estate investment in a flagging economy.  Across the middle third of the twentieth century, arguably the most prosperous decades in American history, these agencies worked with public and private sector partners to create millions of jobs and help millions of Americans buy or keep their homes. At the very same time, federal housing programs helped codify and expand practices of racial and class segregation.  They ensured, moreover, that rampant real estate speculation and environmental degradation would accompany America's remarkable economic recovery and growth.</p>", "<p><cite>Mapping Inequality</cite> brings one of the country's most important archives to the public.  HOLC's documents contain a wealth of information about how government officials, lenders, and real estate interests surveyed and ensured the economic health of American cities.  And with the help of ongoing research, we continue to learn at what cost such measures were realized.</p>", "<p>Over the last thirty years especially, scholars have characterized HOLC's property assessment and risk management practices, as well as those of the Federal Housing Administration, Veterans Administration, and US. Housing Authority, as some of the most important factors in preserving racial segregation, intergenerational poverty, and the continued wealth gap between white Americans and most other groups in the U.S.  Many of these agencies operated under the influence of powerful real estate lobbies or wrote their policies steeped in what were, at the time, widespread assumptions about the profitability of racial segregation and the residential incompatibility of certain racial and ethnic groups.  Through HOLC, in particular, real estate appraisers used the apparent racial and cultural value of a community to determine its economic value.  <cite>Mapping Inequality</cite> offers a window into the New Deal era housing policies that helped set the course for contemporary America. This project provides visitors with a new view, and perhaps even a new language, for describing the relationship between wealth and poverty in America.</p>"],
		bibliograph: ["<h2>Bibliographic Note</h2>", "<p>The Home Owners Loan Corporation (HOLC) has long been seen as both a savior to the housing sector and a force for racial segregation.  As the economic collapse of the 1930s recedes beyond living memory, historians have focused more on the segregationist nature of housing policy—how racism helped save the American economy.  The legislation creating HOLC came out of the first 100 days of the Roosevelt administration and provided billions of dollars for the rescue of banks, thrifts, and distressed homeowners.  New Deal legislation was highly popular in the midst of an economic crisis—the Democratically-controlled House of Representatives passed the bill 383-4.</p>", "<p>HOLC helped restructure the American mortgage lending market by creating and standardizing several of its elements.  HOLC incorporated appraisal of home value into its lending processes, a practice only in its infancy at the time.  HOLC supported the training of home appraisers and employed hundreds of appraisers throughout the 1930s, working in concert with the nation’s realtors to inaugurate and advance real estate appraisal as a profession.  HOLC’s department of Research and Statistics drew upon its network of realtors, developers, lenders, and appraisers to create a neighborhood-by-neighborhood assessment of more than 200 cities in the country.  These assessments included demographic data, economic reports, and the color-coded Security Maps later deemed infamous as instruments of “redlining.”</p>", "<p>The mainstream white press—major daily newspapers and periodicals—greeted the agency and its programs with approval.  They explained the program and forecast upturns in the real estate and construction sectors, as the program enjoyed popular support.  In Chicago, seventeen thousand people stood in line at HOLC’s office the first day it opened in August of 1933 to inquire or apply for aid.  The corporation’s main lending phase ended after three years and the corporation receded from mainstream public view.  HOLC slowly reduced its operations during the 1940s to manage the loans and homes it acquired in its key phase of activity.</p>", "<p>African Americans lambasted HOLC staffing decisions and infrastructure that favored white homeowners and businesses at the expense of blacks.  However, discussion in black newspapers, such as the <cite>Chicago Defender</cite>, prompted only modest response by policy and media elites.  The Roosevelt administration rebuffed NAACP concerns about restrictive covenants, even when HOLC redlining was exposed in 1938.  Black housing officials often worked incrementally on a host of issues, including ending white terrorism and getting new black housing built, even if that meant operating within the segregationist strictures of federal policy.  Racial segregation in housing was not formally deemed illegal until the Fair Housing Act of 1968.</p>", "<p>Scholars viewed HOLC favorably, shaped by economist C. Lowell Harriss’ <cite>History and Policies of the Home Owners’ Loan Corporation</cite>, published in 1951 as the federal government unwound the agency.  HOLC had refinanced a million homes and returned a profit of $14 million to the U.S. Treasury.  It was a successful business venture for an agency created as emergency relief that helped stabilize and even resurrect a moribund mortgage market and stagnant home building sector.</p>", "<p>In the 1980s discovery of the HOLC security maps changed the way historians thought about HOLC and New Deal housing policy.  Housing activists in the 1960s and 1970s had criticized and protested discrimination in real estate lending and buying, coining the term “redlining” to illustrate the geographic dimensions of housing discrimination.  Historian Kenneth Jackson found the maps in the National Archives, stating in his award-winning book <cite>Crabgrass Frontier</cite> that HOLC “devised a rating system that undervalued neighborhoods that were dense, mixed, or aging,” and rather than creating racial discrimination, “applied [existing] notions of ethnic and racial worth to real-estate appraising on an unprecedented scale.”  Federal housing policy simply blocked African Americans from accessing real estate capital, leading to the creation of segregated mass suburbia and, neighborhood by neighborhood, opened residents to opportunity and wealth accumulation or closed citizens off from the American dream.  Following Jackson’s work, historian Thomas Sugrue wrote of the legacy of federal housing policy in Detroit: “geography is destiny.”  Outside of history, scholars and journalists, including sociologist Douglas Massey and writer Ta-Nehisi Coates, point to HOLC redlining as a key factor in racial disparities in wealth and opportunity that continue to the present day.</p>", "<p>When historians incorporated new data technology in their research, they began to draw new conclusions about HOLC’s legacy.  Mapping with geographic information systems (GIS) and quantitative statistical methods from the social sciences, scholars including Amy Hillier and James Greer have countered Jackson’s initial assessment.  Some African Americans did gain access to HOLC financing, and a neighborhood rating was neither a blanket guarantee nor proscription for New Deal aid—“C” and “D”-rated neighborhoods often received more mortgages than nearby “A” neighborhoods.  The ability to work with digital data and to transmit information over the web has opened many new avenues for scholarly inquiry, including assessing the importance of restrictive covenants and asking research questions about the whole program, rather than just individual cities.  Managing massive amounts of real estate and demographic data has been a herculean task up until recently but is now possible with mapping, visualization, and statistical tools.</p>", "<p><cite>Mapping Inequality</cite> opens the HOLC files at the National Archives to scholars, students, and residents and policy leaders in local communities.  This site makes the well-known security maps of HOLC available in digital form, as well as the data and textual assessments of the area descriptions that were created to go with the maps.  By bringing study of HOLC into the digital realm, <cite>Mapping Inequality</cite> embraces a big data approach that can simultaneously give a national view of the program or a neighborhood-level assessment of the 1930s real estate rescue.  Project researchers are providing access to some of the digital tools and interactive resources they are using in their own research, in the hope that the public will be able to understand the effects of federal housing policy and local implementation in their own communities.</p>", "<h2>Bibliography</h2>", "<h3>Textbooks and Manuals on Home Appraisal and Valuation</h3>", "<ul>", "<li><cite>FHA Underwriting Manual</cite> (Washington, DC: Federal Housing Administration, 1936)</li>", "<li>Frederick Babcock, <cite>The Valuation of Real Estate</cite> (McGraw Hill Book Co.: New York, 1932).</li>", "<li>Richard Ely and George Wehrwein, <cite>Land Economics</cite> (Madison, WI: University of Wisconsin Press, rev. 1964).</li>", "<li>Ernest Fisher, <cite>Principles of Real Estate Practice</cite> (New York: The MacMillan Co., 1924).</li>", "<li>Richard Hurd, <cite>Principles of City Land Values </cite>(New York: The Record and Guide, 1924).</li>", "</ul>", "<h3>Contemporaneous Studies of HOLC and Racial Segregation</h3>", "<ul>", "<li>Charles Abrams, <cite>Forbidden Neighbors: A Study of Prejudice in Housing </cite>(New York: Harper &amp; Brothers, 1955).</li>", "<li>C. Lowell Harriss, <cite>History and Policies of the Home Owners&rsquo; Loan Corporation</cite> (Washington, D.C., National Bureau of Economic Research, 1951).</li>", "<li>Robert C. Weaver, <cite>The Negro Ghetto </cite>(New York: Harcourt, Brace, 1948).</li>", "</ul>", "<h3>Historical Studies of HOLC, Segregation, and Home Finance</h3>", "<ul>", "<li>David M. P. Freund, <cite>Colored Property: State Policy and White Racial Politics in Suburban America</cite> (Chicago: University of Chicago Press, 2007).</li>", "<li>Margaret Garb, <cite>City of American Dreams: A History of Home Ownership and Housing Reform in Chicago, 1871-1919</cite>.&nbsp; (Chicago: University of Chicago Press, 2005).</li>", "<li>Amy E. Hillier, &ldquo;Redlining and the Home Owners&rsquo; Loan Corporation,&rdquo; <cite>Journal of Urban History</cite> 29, no. 4 (May 2003): 394-420.</li>", "<li>Amy E. Hillier, &ldquo;Residential Security Maps and Neighborhood Appraisals: The Home Owners&rsquo; Loan Corporation and the Case of Philadelphia,&rdquo; <cite>Social Science History</cite> 29, no. 2 (Summer 2005): XXXX</li>", "<li>Amy E. Hillier, &ldquo;Searching for Red Lines: Spatial Analysis of Lending Patterns in Philadelphia, 1940-1960,&rdquo; <cite>Pennsylvania History</cite> 72, no. 1 (Winter 2005): XXX</li>", "<li>Arnold R. Hirsch, &ldquo;Containment on the Home Front: Race and Federal Housing Policy from the New Deal to the Cold War,&rdquo; <cite>Journal of Urban History</cite> 26, no. 2 (January 2000): 158-189</li>", "<li>Kenneth T. Jackson, &ldquo;Race Ethnicity, and Real Estate Appraisal: The Home Owners Loan Corporation and the Federal Housing Administration,&rdquo; <cite>Journal of Urban History</cite> 6, no. 4 (August, 1980): 419-452.</li>", "<li>Kenneth T. Jackson, <cite>Crabgrass Frontier: The Suburbanization of the United States</cite> (Oxford: Oxford University Press, 1985).</li>", "<li>Jennifer S. Light, &ldquo;Nationality and Neighborhood Risk at the Origins of FHA Underwriting,&rdquo; <cite>Journal of Urban History</cite> 36 (5): 634-671.</li>", "<li>Louis Lee Woods II, &ldquo;The Federal Home Loan Bank Board, Redlining, and the National Proliferation of Racial Lending Discrimination, 1921-1950,&rdquo; <cite>Journal of Urban History</cite>; Volume 38, Issue 6 (November 2012): 1036-1059.</li>", "</ul>", "<h3>Historical Community Studies Featuring Analysis of HOLC</h3>", "<ul>", "<li>Wendell Pritchett, <cite>Brownsville, Brooklyn: Blacks, Jews, and the Changing Face of the Ghetto </cite>(Chicago: University of Chicago Press, 2002).</li>", "<li>Beryl Satter, <cite>Family Properties: Race, Real Estate, and the Exploitation of Black Urban America</cite> (Metropolitan Books, 2009).</li>", "<li>Robert O. Self, <cite>American Babylon, Race and the Struggle for Postwar Oakland</cite> (Princeton: Princeton University Press, 2003).</li>", "<li>Thomas J. Sugrue, <cite>Origins of the Urban Crisis: Race and Inequality in Postwar Detroit</cite> (Princeton: Princeton University Press, 1996).</li>", "<li>Craig Steven Wilder, <cite>Covenant With Color: Race and Social Power in Brooklyn</cite> (New York: Columbia University Press, 2001).</li>", "</ul>", "<h3>Sociological Studies of Racial Discrimination and Segregation</h3>", "<ul>", "<li>Rose Helper, <cite>Racial Policies and Practices of Real Estate Brokers</cite>. (Minneapolis: University of Minnesota Press, 1969).</li>", "<li>Douglas S. Massey and Nancy A. Denton, <cite>American Apartheid: Segregation and the Making of the Underclass</cite> (Cambridge: Harvard University Press, 1993).</li>", "</ul>"],
		"burgess": ["<p><strong>Inspired by the 1920s-era \"concentric zones theory\" of Ernest W. Burgess, this interactive visualization offers a view of how redlining concentrated populations, and did so along a generally consistent pattern.</strong></p>", "<p>An urban sociologist of the extraordinarily influential Chicago School of Sociology, Burgess expounded this theory in a 1925 study <cite>The City</cite>. According to Burgess, every city developed as a series of concentric circles.  Downtown business districts would be surrounded by factory zones.  Factory zones would transition to slums, followed then by progressively more affluent housing for working people and the investor class, before then reaching the final zone, from whence commuters came into the city. As the historian Elaine Lewinnek points out, \"Burgess adapted a half-century of Chicago maps and codified them in a model of abstraction and urban theory that has been called&#8212;with some hyperbole&#8212;'the most famous diagram in social science.'\" (<cite>The Working Man’s Reward: Chicago’s Early Suburbs and The Roots of American Sprawl</cite> (Oxford, 2014), 130.)</p>", "<img src='./static/burgess.png' />", "<p>In Burgess's model, each ring had cultural and economic features&#8212;features that he explicitly associated with ethnic and racial populations. Recent immigrants and black migrants occupied central slum districts rife with vice dens and run down rooming houses.  Second-generation European immigrants and factory and a shop workers, \"skilled and thrifty,\" lived on the outer edge of the slums and on the inner edge of the ring of well-kept apartment houses and \"workingmen's homes.\" Beyond them was the \"Promised Land\" of residential hotels and single-family homes.  In contrast to the swarthy, congested slums, these were \"bright light areas\" safely protected by restrictive covenants and high price points.</p>", "<figure><img src='./static/burgess-chicago.png' /><figcaption>Burgess's theory was drawn from and applied to Chicago.</figcaption></figure>", "<p>Burgess's model, in addition to reflecting the homes of real estate investor communities, served as an extension of wider segregationist thinking driving both sociology as a discipline and administrative practice during the progressive era.  Obsession with cities as \"organisms\" of society, they believed in what the sociologist Louis Wirth benignly described as the \"eugenics of the city.\"</p>", "<p>Many of the HOLC maps reflected both the categorical impulse and spatial organization of Burgess model with D and C neighborhoods more likely to be located around central business districts and A and B neighborhoods in increasingly suburban peripheries. The diagram visualizes the relative distribution of HOLC grades in relation to the center of the city. The opacity of the rings reflects the relative density of zoned areas on the map. Hovering over the rings will highlight areas for that grade.</p>", "<p>Our adaptation of Burgess diagrams is not meant to resuscitate his discredited theory.  Rather, we aim to show just how profoundly segregationist practices of redlining actually shaped American cities to resemble a roundly discredited social theory.  Segregation was not natural.  Quite the contrary, redlining greatly impeded the natural flows of people and capital.  Through federal action and local manipulation, life was made to imitate art.</p>"]
	},

	setShow: function setShow(subject) {
		this.data.modal = {
			open: subject !== null,
			subject: subject
		};
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	getModalContent: function getModalContent() {
		return this.data.modal.open ? this.parseModalCopy(this.data[this.data.modal.subject]) : null;
	},

	mainModalIsOpen: function mainModalIsOpen() {
		return this.data.modal.open;
	},

	parseModalCopy: function parseModalCopy(rawContent) {
		var modalCopy = '';

		try {
			modalCopy = rawContent.join('\n');
		} catch (error) {
			console.warn('Error parsing modal copy: ');
			modalCopy = 'Error parsing modal copy.';
		}

		// React requires this format to render a string as HTML,
		// via dangerouslySetInnerHTML.
		return {
			__html: modalCopy
		};
	}
};

// Mixin EventEmitter functionality
Object.assign(TextsStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
_AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.onModalClick:
			TextsStore.setShow(action.subject);
			break;

	}
	return true;
});

exports.default = TextsStore;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/UserLocationStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UserLocationStore = {

	data: {
		latLng: null,
		adId: null,
		city: null,
		neighborhood: null,
		offerZoomTo: false
	},

	dataLoader: _CartoDBLoader2.default,

	loadData: function loadData(point) {
		var _this = this;

		this.data.latLng = point;

		this.dataLoader.query([{
			query: 'SELECT ad_id, city, ST_distance(ST_setsrid(ST_MakePoint(holc_maps.looplng, holc_maps.looplat),4326), ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326)) as distance, st_xmin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmin, st_xmax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmax, st_ymin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymin, st_ymax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymax from holc_maps join holc_maps_ads_join on holc_maps.map_id = holc_maps_ads_join.map_id join holc_ads on holc_ads.id = holc_maps_ads_join.ad_id order by distance limit 1',
			format: 'JSON'
		}]).then(function (response) {
			_this.data.city = response[0][0].city;
			_this.data.adId = response[0][0].ad_id;
			_this.data.offerZoomTo = true;

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('Location received error:', error);
			throw error;
		});
	},

	setOfferZoomTo: function setOfferZoomTo(trueOrFalse) {
		this.data.offerZoomTo = trueOrFalse;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	getPoint: function getPoint() {
		return this.data.latLng;
	},

	getAdId: function getAdId() {
		return this.data.adId;
	},

	getCity: function getCity() {
		return this.data.city;
	},

	getNeighborhood: function getNeighborhood() {
		return this.data.neighborhood;
	},

	getOfferZoomTo: function getOfferZoomTo() {
		return this.data.offerZoomTo;
	}
};

// Mixin EventEmitter functionality
Object.assign(UserLocationStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
_AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.userLocated:
			if (action.point) {
				UserLocationStore.loadData(action.point);
			}
			break;

		case _AppActionCreator.AppActionTypes.userRespondedToZoomOffer:
			UserLocationStore.setOfferZoomTo(false);
			break;

	}
	return true;
});

exports.default = UserLocationStore;

},{"../utils/AppActionCreator":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/CartoDBLoader.js","events":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppActionCreator.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AppActions = exports.AppActionTypes = undefined;

var _AppDispatcher = require('./AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _RasterStore = require('../stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

var _AreaDescriptionsStore = require('../stores/AreaDescriptionsStore');

var _AreaDescriptionsStore2 = _interopRequireDefault(_AreaDescriptionsStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AppActionTypes = exports.AppActionTypes = {

	// Note: stores emit this type of event.
	// Though it is not actually an Action type;
	// it's enumerated here for ease of access.
	storeChanged: 'storeChanged',

	ADCategorySelected: 'ADCategorySelected',
	ADImageOpened: 'ADImageOpened',
	loadInitialData: 'loadInitialData',
	initialDataLoaded: 'initialDataLoaded',
	getInitialData: 'getInitialData',
	citySelected: 'citySelected',
	gradeSelected: 'gradeSelected',
	neighborhoodHighlighted: 'neighborhoodHighlighted',
	neighborhoodSelected: 'neighborhoodSelected',
	ringGradeSelected: 'ringGradeSelected',
	mapInitialized: 'mapInitialized',
	mapMoved: 'mapMoved',
	userLocated: 'userLocated',
	userRespondedToZoomOffer: 'userRespondedToZoomOffer',
	onModalClick: 'onModalClick',
	windowResized: 'windowResized'

};

var AppActions = exports.AppActions = {

	ADCategorySelected: function ADCategorySelected(value) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.ADCategorySelected,
			value: value
		});
	},

	/**
  * Load data needed by the application on init.
  */
	loadInitialData: function loadInitialData(state, hashState) {
		//console.log(`[1a] A '${ AppActionTypes.loadInitialData }' event is broadcast globally from AppActionCreator.loadInitialData().`);
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.loadInitialData,
			state: state,
			hashState: hashState
		});
	},

	initialDataLoaded: function initialDataLoaded(state) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.initialDataLoaded,
			state: state
		});
	},

	ADImageOpened: function ADImageOpened(holcId, adId) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.ADImageOpened,
			holcId: holcId,
			adId: adId
		});
	},

	citySelected: function citySelected(city) {
		var selectedByUser = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.citySelected,
			value: city,
			selectedByUser: true
		});
	},

	gradeSelected: function gradeSelected(grade) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.gradeSelected,
			value: grade
		});
	},

	neighborhoodHighlighted: function neighborhoodHighlighted(holcId, adId) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.neighborhoodHighlighted,
			holcId: holcId
		});
	},

	neighborhoodSelected: function neighborhoodSelected(holcId, adId) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.neighborhoodSelected,
			holcId: holcId,
			adId: adId
		});
	},

	stateSelected: function stateSelected(state) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.stateSelected,
			value: state
		});
	},

	ringGradeSelected: function ringGradeSelected(selectedRingGrade) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.ringGradeSelected,
			value: selectedRingGrade
		});
	},

	// mapMoved: (visibleAdIds, belowAdThreshold = false) => {
	// 	AppDispatcher.dispatch({
	// 		type: AppActionTypes.mapMoved,
	// 		value: visibleAdIds,
	// 		belowAdThreshold: belowAdThreshold
	// 	})
	// },

	onModalClick: function onModalClick(subject) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.onModalClick,
			subject: subject
		});
	},

	userLocated: function userLocated(point) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.userLocated,
			point: point
		});
	},

	userRespondedToZoomOffer: function userRespondedToZoomOffer() {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.userRespondedToZoomOffer
		});
	},

	mapInitialized: function mapInitialized(theMap) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.mapInitialized,
			theMap: theMap,
			rasters: _RasterStore2.default.getAllRasters(),
			adsMetadata: _AreaDescriptionsStore2.default.getADsMetadata()
		});
	},

	mapMoved: function mapMoved(theMap) {
		// this has fired repeatedly when it should fire only once.
		// I think this might be related to re-rendering happening
		// during leaflet animation.
		if (!_AppDispatcher2.default.isDispatching()) {
			_AppDispatcher2.default.dispatch({
				type: AppActionTypes.mapMoved,
				theMap: theMap,
				rasters: _RasterStore2.default.getAllRasters(),
				adsMetadata: _AreaDescriptionsStore2.default.getADsMetadata()
			});
		}
	},

	windowResized: function windowResized() {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.windowResized
		});
	}
};

},{"../stores/AreaDescriptionsStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/AreaDescriptionsStore.js","../stores/RasterStore":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/stores/RasterStore.js","./AppDispatcher":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/AppDispatcher.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flux = require('flux');

exports.default = new _flux.Dispatcher();

},{"flux":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/flux/index.js"}],"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/utils/CartoDBLoader.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _queueAsync = require('queue-async');

var _queueAsync2 = _interopRequireDefault(_queueAsync);

var _config = require('../../basemaps/cartodb/config.json');

var _config2 = _interopRequireDefault(_config);

var _cartodbClient = require('cartodb-client');

var _cartodbClient2 = _interopRequireDefault(_cartodbClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cartoDBClient = new _cartodbClient2.default(_config2.default.userId); /*
                                                                           * TODO: Move this into @panorama/toolkit.
                                                                           * 
                                                                           * Consider pulling cartodb-client into this and packaging the whole thing as a component,
                                                                           * leaving `query` as the only public method.
                                                                           * 
                                                                           * Also, note this is pretty similar to https://www.npmjs.com/package/cartodb already >.<
                                                                           */

var CartoDBLoader = {

	/** Use `queue-async` to defer() up an array of queries,
  * and return a Promise that is resolved when all requests have completed.
  * Accepts a list of objects formatted as { query, format }.
  */
	query: function query(queryConfigs) {
		var _this = this;

		return new Promise(function (resolve, reject) {

			// Run up to 3 requests in parallel
			var queue = (0, _queueAsync2.default)(3);
			queryConfigs.forEach(function (queryConfig) {
				queue.defer(_this.request, queryConfig);
			});

			queue.awaitAll(function (error) {
				for (var _len = arguments.length, responses = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					responses[_key - 1] = arguments[_key];
				}

				if (error) {
					reject(error);
				} else {
					resolve.apply(undefined, responses);
				}
			});
		});
	},

	request: function request(queryConfig, callback) {

		cartoDBClient.sqlRequest(queryConfig.query, function (err, response) {
			if (!err) {
				var innerResponse = void 0;
				switch (queryConfig.format.toLowerCase()) {
					case 'geojson':
						innerResponse = response.features;
						break;
					default:
						innerResponse = response.rows;
						break;
				}
				callback(null, innerResponse);
			} else {
				callback(err);
			}
		}, {
			'format': queryConfig.format,
			'dangerouslyExposedAPIKey': _config2.default.apiKey
		});
	}

};

exports.default = CartoDBLoader;

},{"../../basemaps/cartodb/config.json":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/basemaps/cartodb/config.json","cartodb-client":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/cartodb-client/index.js","queue-async":"/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/node_modules/queue-async/build/queue.js"}]},{},["/Users/rnelson2/Documents/projects/Digital Atlas/panorama/holc/src/main.jsx"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJiYXNlbWFwcy9jYXJ0b2RiL2Jhc2VtYXBzLmpzb24iLCJiYXNlbWFwcy9jYXJ0b2RiL2NvbmZpZy5qc29uIiwiYmFzZW1hcHMvdGlsZUxheWVycy5qc29uIiwiZGF0YS9mb3Jtc01ldGFkYXRhLmpzb24iLCJkYXRhL3Bhbm9yYW1hX25hdi5qc29uIiwiZGF0YS9zdGF0ZV9hYmJyLmpzb24iLCJub2RlX21vZHVsZXMvQHBhbm9yYW1hL3Rvb2xraXQvZGlzdC9jb21wb25lbnRzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXJ0b2RiLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYXJ0b2RiLWNsaWVudC9zcmMvY2FydG9kYi1jbGllbnQuanMiLCJub2RlX21vZHVsZXMvZDMvZDMuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9pbnRyby5qcy9pbnRyby5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvcXVldWUtYXN5bmMvYnVpbGQvcXVldWUuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL2xpYi9IYW5kbGUuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL2xpYi9NYXJrcy5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbGliL1NsaWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbGliL1N0ZXBzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9saWIvVHJhY2suanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL2xpYi9Ub29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL2xpYi9wbGFjZW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9saWIvTGF6eVJlbmRlckJveC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbGliL1BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbGliL1RyaWdnZXIuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbGliL0FsaWduLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbGliL2lzV2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvYWRqdXN0Rm9yVmlld3BvcnQuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbGlnbi9ub2RlX21vZHVsZXMvZG9tLWFsaWduL2xpYi9nZXRBbGlnbk9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbm9kZV9tb2R1bGVzL3JjLWFsaWduL25vZGVfbW9kdWxlcy9kb20tYWxpZ24vbGliL2dldEVsRnV0dXJlUG9zLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvZ2V0T2Zmc2V0UGFyZW50LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvZ2V0UmVnaW9uLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbGlnbi9ub2RlX21vZHVsZXMvZG9tLWFsaWduL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbm9kZV9tb2R1bGVzL3JjLWFuaW1hdGUvbGliL0FuaW1hdGUuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL2xpYi9BbmltYXRlQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL2xpYi9DaGlsZHJlblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYW5pbWF0ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYW5pbWF0ZS9ub2RlX21vZHVsZXMvY3NzLWFuaW1hdGlvbi9saWIvRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL25vZGVfbW9kdWxlcy9jc3MtYW5pbWF0aW9uL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbm9kZV9tb2R1bGVzL3JjLWFuaW1hdGUvbm9kZV9tb2R1bGVzL2Nzcy1hbmltYXRpb24vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1jbGFzc2VzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYW5pbWF0ZS9ub2RlX21vZHVsZXMvY3NzLWFuaW1hdGlvbi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWNsYXNzZXMvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdXRpbC9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL2xpYi9Eb20vY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL2xpYi9jcmVhdGVDaGFpbmVkRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL25vZGVfbW9kdWxlcy9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudEJhc2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL25vZGVfbW9kdWxlcy9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXV0aWwvbm9kZV9tb2R1bGVzL2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdXRpbC9ub2RlX21vZHVsZXMvYWRkLWRvbS1ldmVudC1saXN0ZW5lci9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9BdHRyaWJ1dGlvbkNvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvQmFzZVRpbGVMYXllci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9DYW52YXNUaWxlTGF5ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvQ2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL0NpcmNsZU1hcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9GZWF0dXJlR3JvdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvR2VvSnNvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9JbWFnZU92ZXJsYXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvTGF5ZXJHcm91cC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9MYXllcnNDb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL01hcC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXBDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvTWFwQ29udHJvbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXBMYXllci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXJrZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvTXVsdGlQb2x5Z29uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL011bHRpUG9seWxpbmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9Qb2x5Z29uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1BvbHlsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1JlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9TY2FsZUNvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvVGlsZUxheWVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1dNU1RpbGVMYXllci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9ab29tQ29udHJvbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi90eXBlcy9ib3VuZHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvdHlwZXMvY2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvdHlwZXMvY29udHJvbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL3R5cGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL3R5cGVzL2xhdGxuZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi90eXBlcy9sYXRsbmdMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL3R5cGVzL2xheWVyQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fUmVmbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYWRkU2V0RW50cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZURpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19jaGVja0dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRMZW5ndGguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pbmRleEtleXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pbmRleE9mTmFOLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19pdGVyYXRvclRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9mb3JFYWNoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvb21pdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvcGljay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC90b0ludGVnZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L25vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pcXVlSWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9jb21wb25lbnRzL01vZGFsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9jb21wb25lbnRzL01vZGFsUG9ydGFsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL2FyaWFBcHBIaWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9mb2N1c01hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvc2NvcGVUYWIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvdGFiYmFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9lbGVtZW50LWNsYXNzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9leGVudi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2Vhc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWNvcHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmluZGNhbGxiYWNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL25vZGVfbW9kdWxlcy9sb2Rhc2guX2lzaXRlcmF0ZWVjYWxsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL25vZGVfbW9kdWxlcy9sb2Rhc2gucmVzdHBhcmFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvbm9kZV9tb2R1bGVzL2xvZGFzaC5fZ2V0bmF0aXZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9ub2RlX21vZHVsZXMvbG9kYXNoLmlzYXJndW1lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9ub2RlX21vZHVsZXMvbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtdHlwZWFoZWFkL2xpYi9hY2Nlc3Nvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL2tleWV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9saWIvcmVhY3QtdHlwZWFoZWFkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9saWIvdG9rZW5pemVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9saWIvdG9rZW5pemVyL3Rva2VuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9saWIvdHlwZWFoZWFkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9saWIvdHlwZWFoZWFkL29wdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL3R5cGVhaGVhZC9zZWxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtdHlwZWFoZWFkL25vZGVfbW9kdWxlcy9mdXp6eS9saWIvZnV6enkuanMiLCJzcmMvQXBwLmpzeCIsInNyYy9jb21wb25lbnRzL0FEQ2F0LmpzeCIsInNyYy9jb21wb25lbnRzL0FyZWFEZXNjcmlwdGlvbi5qc3giLCJzcmMvY29tcG9uZW50cy9BcmVhUG9seWdvbi5qc3giLCJzcmMvY29tcG9uZW50cy9DaXR5U25pcHBldC5qc3giLCJzcmMvY29tcG9uZW50cy9DaXR5U3RhdHMuanN4Iiwic3JjL2NvbXBvbmVudHMvRG9udXQvRG9udXQuanN4Iiwic3JjL2NvbXBvbmVudHMvRG9udXQvTC5Eb251dC5qcyIsInNyYy9jb21wb25lbnRzL0Rvd25sb2FkZXIuanN4Iiwic3JjL2NvbXBvbmVudHMvSE9MQ01hcC5qc3giLCJzcmMvY29tcG9uZW50cy9TaWRlYmFyTWFwLmpzeCIsInNyYy9jb21wb25lbnRzL1NpZGViYXJOZWlnaGJvcmhvb2ROYXYuanN4Iiwic3JjL2NvbXBvbmVudHMvU2lkZWJhck5laWdoYm9yaG9vZFRpdGxlLmpzeCIsInNyYy9jb21wb25lbnRzL1N0YXRlU3RhdHMuanN4Iiwic3JjL2NvbXBvbmVudHMvVHlwZUFoZWFkQ2l0eVNuaXBwZXQuanN4Iiwic3JjL21haW4uanN4Iiwic3JjL3N0b3Jlcy9BcmVhRGVzY3JpcHRpb25zU3RvcmUuanMiLCJzcmMvc3RvcmVzL0NpdHlTdG9yZS5qcyIsInNyYy9zdG9yZXMvRGltZW5zaW9uc1N0b3JlLmpzIiwic3JjL3N0b3Jlcy9NYXBTdGF0ZVN0b3JlLmpzIiwic3JjL3N0b3Jlcy9SYXN0ZXJTdG9yZS5qcyIsInNyYy9zdG9yZXMvVGV4dHNTdG9yZS5qcyIsInNyYy9zdG9yZXMvVXNlckxvY2F0aW9uU3RvcmUuanMiLCJzcmMvdXRpbHMvQXBwQWN0aW9uQ3JlYXRvci5qcyIsInNyYy91dGlscy9BcHBEaXNwYXRjaGVyLmpzIiwic3JjL3V0aWxzL0NhcnRvREJMb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy84UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JiQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0FBWSxNQUFLLE9BQWpCLEVBQTBCLFdBQTFCO0FBQ0EsSUFGRDs7QUFJQSxTQUFNLFFBQU4sQ0FBZSxVQUFDLEtBQUQsRUFBeUI7QUFBQSxzQ0FBZCxTQUFjO0FBQWQsY0FBYztBQUFBOztBQUN2QyxRQUFJLEtBQUosRUFBVztBQUNWLFlBQU8sS0FBUDtBQUNBLEtBRkQsTUFFTztBQUNOLDhCQUFXLFNBQVg7QUFDQTtBQUNELElBTkQ7QUFRQSxHQWhCTSxDQUFQO0FBa0JBLEVBMUJvQjs7QUE0QnJCLFVBQVMsaUJBQVUsV0FBVixFQUF1QixRQUF2QixFQUFpQzs7QUFFekMsZ0JBQWMsVUFBZCxDQUF5QixZQUFZLEtBQXJDLEVBQTRDLFVBQVMsR0FBVCxFQUFjLFFBQWQsRUFBd0I7QUFDbkUsT0FBSSxDQUFDLEdBQUwsRUFBVTtBQUNULFFBQUksc0JBQUo7QUFDQSxZQUFRLFlBQVksTUFBWixDQUFtQixXQUFuQixFQUFSO0FBQ0MsVUFBSyxTQUFMO0FBQ0Msc0JBQWdCLFNBQVMsUUFBekI7QUFDQTtBQUNEO0FBQ0Msc0JBQWdCLFNBQVMsSUFBekI7QUFDQTtBQU5GO0FBUUEsYUFBUyxJQUFULEVBQWUsYUFBZjtBQUNBLElBWEQsTUFXTztBQUNOLGFBQVMsR0FBVDtBQUNBO0FBQ0QsR0FmRCxFQWVHO0FBQ0YsYUFBVSxZQUFZLE1BRHBCO0FBRUYsK0JBQTRCLGlCQUFPO0FBRmpDLEdBZkg7QUFvQkE7O0FBbERvQixDQUF0Qjs7a0JBc0RlLGEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHM9e1wibmFtZVwiOlwiUGFub3JhbWFCYXNlbWFwXCIsXCJ2ZXJzaW9uXCI6XCIwLjAuMVwiLFwibGF5ZXJncm91cFwiOntcInZlcnNpb25cIjpcIjEuMy4wXCIsXCJsYXllcnNcIjpbe1widHlwZVwiOlwibWFwbmlrXCIsXCJvcHRpb25zXCI6e1wic3FsXCI6XCJTRUxFQ1QgY2FydG9kYl9pZCwgY2l0eSwgU1RfVHJhbnNmb3JtKFNUX1NldFNSSUQoc3RfbWFrZXBvaW50KGxvb3BsbmcsbG9vcGxhdCksNDMyNiksIDM4NTcpIGFzIHRoZV9nZW9tX3dlYm1lcmNhdG9yIEZST00gaG9sY19hZHNcXG5cIixcImNhcnRvY3NzXCI6XCIjaG9sY19hZHM6OmxhYmVscyB7XFxuICB0ZXh0LW5hbWU6IFtjaXR5XTtcXG4gIHRleHQtZmFjZS1uYW1lOiAnRGVqYVZ1IFNhbnMgQm9vayc7XFxuICB0ZXh0LXNpemU6IDEwO1xcbiAgdGV4dC1sYWJlbC1wb3NpdGlvbi10b2xlcmFuY2U6IDA7XFxuICB0ZXh0LWZpbGw6ICMwRjNCODI7XFxuICB0ZXh0LWhhbG8tZmlsbDogI0ZGRjtcXG4gIHRleHQtaGFsby1yYWRpdXM6IDE7XFxuICB0ZXh0LWR5OiAtMTA7XFxuICB0ZXh0LWFsbG93LW92ZXJsYXA6IGZhbHNlO1xcbiAgdGV4dC1wbGFjZW1lbnQ6IHBvaW50O1xcbiAgdGV4dC1wbGFjZW1lbnQtdHlwZTogZHVtbXk7XFxufVwiLFwiY2FydG9jc3NfdmVyc2lvblwiOlwiMi4xLjFcIn19XSxcIm1pbnpvb21cIjoyLFwibWF4em9vbVwiOjl9fVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcInVzZXJJZFwiOiBcImRpZ2l0YWxzY2hvbGFyc2hpcGxhYlwiLFxuXHRcImFwaUtleVwiOiBcIlwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwibGF5ZXJzXCI6IFtcblx0XHR7XG5cdFx0XHRcInVybE5vTGFiZWxzXCI6IFwiaHR0cDovL3tzfS5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ucG5nXCIsXG5cdFx0XHRcInVybExhYmVsc1wiOiBcImh0dHA6Ly97c30uYmFzZW1hcHMuY2FydG9jZG4uY29tL2xpZ2h0X2FsbC97en0ve3h9L3t5fS5wbmdcIlxuXHRcdH1cblx0XVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIjE5MzcwMjAzXCI6IHtcblx0XHRcIjFcIjogW1xuXHRcdFx0XCJOYW1lIG9mIENpdHlcIixcblx0XHRcdFwiU2VjdXJpdHkgR3JhZGVcIixcblx0XHRcdFwiQXJlYSBOb1wiXG5cdFx0XSxcblx0XHRcIjJcIjogXCJEZXNjcmlwdGlvbiBvZiBUZXJyYWluXCIsXG5cdFx0XCIzXCI6IFwiRmF2b3JhYmxlIEluZmx1ZW5jZXNcIixcblx0XHRcIjRcIjogXCJEZXRyaW1lbnRhbCBJbmZsdWVuY2VzXCIsXG5cdFx0XCI1XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiSW5oYWJpdGFudHNcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIlR5cGVcIixcblx0XHRcdFx0XCJiXCI6IFwiRXN0aW1hdGVkIGFubnVhbCBmYW1pbHkgaW5jb21lXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkZvcmVpZ24tYm9yblwiLFxuXHRcdFx0XHRcImRcIjogXCJOZWdyb1wiLFxuXHRcdFx0XHRcImVcIjogXCJJbmZpbHRyYXRpb24gb2ZcIixcblx0XHRcdFx0XCJmXCI6IFwiUmVsaWVmIGZhbWlsaWVzXCIsXG5cdFx0XHRcdFwiZ1wiOiBcIlBvcHVsYXRpb24gaXNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI2XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiQnVpbGRpbmdzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJUeXBlIG9yIFR5cGVzXCIsXG5cdFx0XHRcdFwiYlwiOiBcIlR5cGUgb2YgQ29uc3RydWN0aW9uXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkF2ZXJhZ2UgYWdlXCIsXG5cdFx0XHRcdFwiZFwiOiBcIlJlcGFpclwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjhcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJPY2N1cGFuY3lcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIkxhbmRcIixcblx0XHRcdFx0XCJiXCI6IFwiRHdlbGxpbmcgdW5pdHNcIixcblx0XHRcdFx0XCJjXCI6IFwiSG9tZSBPd25lcnNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI5XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiU2FsZXMgRGVtYW5kXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJcIixcblx0XHRcdFx0XCJiXCI6IFwiXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkFjdGl2aXR5IGlzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTBcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJSZW50YWwgRGVtYW5kXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJcIixcblx0XHRcdFx0XCJiXCI6IFwiXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkFjdGl2aXR5IGlzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTFcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJOZXcgQ29uc3RydWN0aW9uXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJUeXBlc1wiLFxuXHRcdFx0XHRcImJcIjogXCJBbW91bnQgbGFzdCB5ZWFyXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTJcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJBdmFpbGFiaWxpdHkgb2YgTW9ydGdhZ2UgRnVuZHNcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIkhvbWUgcHVyY2hhc2VcIixcblx0XHRcdFx0XCJiXCI6IFwiSG9tZSBidWlsZGluZ1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjEzXCI6IFwiVHJlbmQgb2YgRGVzaXJlYWJpbGl0eSBOZXh0IDEwLTE1IFllYXJzXCIsXG5cdFx0XCIxNFwiOiBcIkNsYXJpZnlpbmcgUmVtYXJrc1wiLFxuXHRcdFwiMTVcIjogXCJJbmZvcm1hdGlvbiBmb3IgdGhpcyBmb3JtIHdhcyBvYnRhaW5lZCBmcm9tXCJcblx0fSxcblx0XCIxOTM3MDgyNlwiOiB7XG5cdFx0XCIxXCI6IFtcblx0XHRcdFwiTmFtZSBvZiBDaXR5XCIsXG5cdFx0XHRcIlNlY3VyaXR5IEdyYWRlXCIsXG5cdFx0XHRcIkFyZWEgTm9cIlxuXHRcdF0sXG5cdFx0XCIyXCI6IFwiRGVzY3JpcHRpb24gb2YgVGVycmFpblwiLFxuXHRcdFwiM1wiOiBcIkZhdm9yYWJsZSBJbmZsdWVuY2VzXCIsXG5cdFx0XCI0XCI6IFwiRGV0cmltZW50YWwgSW5mbHVlbmNlc1wiLFxuXHRcdFwiNVwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIkluaGFiaXRhbnRzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJUeXBlXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkVzdGltYXRlZCBhbm51YWwgZmFtaWx5IGluY29tZVwiLFxuXHRcdFx0XHRcImNcIjogXCJGb3JlaWduLWJvcm5cIixcblx0XHRcdFx0XCJkXCI6IFwiTmVncm9cIixcblx0XHRcdFx0XCJlXCI6IFwiSW5maWx0cmF0aW9uIG9mXCIsXG5cdFx0XHRcdFwiZlwiOiBcIlJlbGllZiBmYW1pbGllc1wiLFxuXHRcdFx0XHRcImdcIjogXCJQb3B1bGF0aW9uIGlzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiNlwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIkJ1aWxkaW5nc1wiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiVHlwZSBvciBUeXBlc1wiLFxuXHRcdFx0XHRcImJcIjogXCJUeXBlIG9mIENvbnN0cnVjdGlvblwiLFxuXHRcdFx0XHRcImNcIjogXCJBdmVyYWdlIGFnZVwiLFxuXHRcdFx0XHRcImRcIjogXCJSZXBhaXJcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI4XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiT2NjdXBhbmN5XCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJMYW5kXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkR3ZWxsaW5nIHVuaXRzXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkhvbWUgT3duZXJzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiOVwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIlNhbGVzIERlbWFuZFwiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiXCIsXG5cdFx0XHRcdFwiYlwiOiBcIlwiLFxuXHRcdFx0XHRcImNcIjogXCJBY3Rpdml0eSBpc1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjEwXCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiUmVudGFsIERlbWFuZFwiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiXCIsXG5cdFx0XHRcdFwiYlwiOiBcIlwiLFxuXHRcdFx0XHRcImNcIjogXCJBY3Rpdml0eSBpc1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjExXCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiTmV3IENvbnN0cnVjdGlvblwiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiVHlwZXNcIixcblx0XHRcdFx0XCJiXCI6IFwiQW1vdW50IGxhc3QgeWVhclwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjEyXCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiQXZhaWxhYmlsaXR5IG9mIE1vcnRnYWdlIEZ1bmRzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJIb21lIHB1cmNoYXNlXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkhvbWUgYnVpbGRpbmdcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIxM1wiOiBcIlRyZW5kIG9mIERlc2lyZWFiaWxpdHkgTmV4dCAxMC0xNSBZZWFyc1wiLFxuXHRcdFwiMTRcIjogXCJDbGFyaWZ5aW5nIFJlbWFya3NcIixcblx0XHRcIjE1XCI6IFwiSW5mb3JtYXRpb24gZm9yIHRoaXMgZm9ybSB3YXMgb2J0YWluZWQgZnJvbVwiXG5cdH0sXG5cdFwiMTkzNzEwMDFcIjoge1xuXHRcdFwiMVwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIkFyZWEgQ2hhcmFjdGVyaXN0aWNzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJEZXNjcmlwdGlvbiBvZiBUZXJyYWluXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkZhdm9yYWJsZSBJbmZsdWVuY2VzXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkRldHJpbWVudGFsIEluZmx1ZW5jZXNcIixcblx0XHRcdFx0XCJkXCI6IFwiUGVyY2VudGFnZSBvZiBsYW5kIGltcHJvdmVkXCIsXG5cdFx0XHRcdFwiZVwiOiBcIlRyZW5kIG9mIGRlc2lyZWFiaWxpdHkgbmV4dCAxMC0xNSB5cnMuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMlwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIkluaGFiaXRhbnRzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJPY2N1cGF0aW9uXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkVzdGltYXRlZCBBbm51YWwgRmFtaWx5IEluY29tZVwiLFxuXHRcdFx0XHRcImNcIjogXCJGb3JlaWduLWJvcm4gZmFtaWxpZXNcIixcblx0XHRcdFx0XCJkXCI6IFwiTmVncm9cIixcblx0XHRcdFx0XCJlXCI6IFwiSW5maWx0cmF0aW9uIG9mXCIsXG5cdFx0XHRcdFwiZlwiOiBcIlJlbGllZiBmYW1pbGllc1wiLFxuXHRcdFx0XHRcImdcIjogXCJQb3B1bGF0aW9uIGlzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiNFwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIkF2YWlsYWJpbGl0eSBvZiBNb3J0Z2FnZSBGdW5kc1wiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiSG9tZSBwdXJjaGFzZVwiLFxuXHRcdFx0XHRcImJcIjogXCJIb21lIGJ1aWxkaW5nXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiNVwiOiBcIkNsYXJpZnlpbmcgUmVtYXJrc1wiLFxuXHRcdFwiNlwiOiBbXG5cdFx0XHRcIk5hbWUgYW5kIExvY2F0aW9uXCIsXG5cdFx0XHRcIlNlY3VyaXR5IEdyYWRlXCIsXG5cdFx0XHRcIkFyZWEgTm8uXCJcblx0XHRdLFxuXHR9XG5cbn0iLCJtb2R1bGUuZXhwb3J0cz1bXG5cdHtcblx0XHRcInRpdGxlXCIgICAgICAgICA6IFwiVGhlIEZvcmNlZCBNaWdyYXRpb24gb2YgRW5zbGF2ZWQgUGVvcGxlXCIsXG5cdFx0XCJ1cmxcIiAgICAgICAgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL2ZvcmNlZG1pZ3JhdGlvbi9cIixcblx0XHRcInNjcmVlbnNob3RcIiAgICA6IFwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvc3RhdGljL2ltYWdlcy9mb3JjZWQtbWlncmF0aW9uLWltZy5wbmdcIixcblx0XHRcInN0YXJ0X3llYXJcIiAgICA6IDE4MTAsXG5cdFx0XCJlbmRfeWVhclwiICAgICAgOiAxODYwLFxuXHRcdFwidGFnc1wiICAgICAgICAgIDogW11cblx0fSxcblx0e1xuXHRcdFwidGl0bGVcIiAgICAgICAgIDogXCJUaGUgT3ZlcmxhbmQgVHJhaWxzXCIsXG5cdFx0XCJ1cmxcIiAgICAgICAgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL292ZXJsYW5kdHJhaWxzL1wiLFxuXHRcdFwic2NyZWVuc2hvdFwiICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9zdGF0aWMvaW1hZ2VzL292ZXJsYW5kLWltZy5wbmdcIixcblx0XHRcInN0YXJ0X3llYXJcIiAgICA6IDE4NDAsXG5cdFx0XCJlbmRfeWVhclwiICAgICAgOiAxODYwLFxuXHRcdFwidGFnc1wiICAgICAgICAgIDogW11cblx0fSxcblx0e1xuXHRcdFwidGl0bGVcIiAgICAgICAgIDogXCJGb3JlaWduLUJvcm4gUG9wdWxhdGlvblwiLFxuXHRcdFwidXJsXCIgICAgICAgICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9mb3JlaWduYm9ybi9cIixcblx0XHRcInNjcmVlbnNob3RcIiAgICA6IFwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvc3RhdGljL2ltYWdlcy9mb3JlaWduLWJvcm4taW1nLnBuZ1wiLFxuXHRcdFwic3RhcnRfeWVhclwiICAgIDogMTg1MCxcblx0XHRcImVuZF95ZWFyXCIgICAgICA6IDIwMTAsXG5cdFx0XCJ0YWdzXCIgICAgICAgICAgOiBbXVxuXHR9LFxuXHR7XG5cdFx0XCJ0aXRsZVwiICAgICAgICAgOiBcIkNhbmFsc1wiLFxuXHRcdFwidXJsXCIgICAgICAgICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9jYW5hbHMvXCIsXG5cdFx0XCJzY3JlZW5zaG90XCIgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL3N0YXRpYy9pbWFnZXMvY2FuYWwtaW1nLnBuZ1wiLFxuXHRcdFwic3RhcnRfeWVhclwiICAgIDogMTgwMCxcblx0XHRcImVuZF95ZWFyXCIgICAgICA6IDE4NjAsXG5cdFx0XCJ0YWdzXCIgICAgICAgICAgOiBbXVxuXHR9LFxuXHR7XG5cdFx0XCJ0aXRsZVwiICAgICAgICAgOiBcIk1hcHBpbmcgSW5lcXVhbGl0eVwiLFxuXHRcdFwidXJsXCIgICAgICAgICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9ob2xjL1wiLFxuXHRcdFwic2NyZWVuc2hvdFwiICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9zdGF0aWMvaW1hZ2VzL2hvbGMtaW1nLnBuZ1wiLFxuXHRcdFwic3RhcnRfeWVhclwiICAgIDogMTgwMCxcblx0XHRcImVuZF95ZWFyXCIgICAgICA6IDE4NjAsXG5cdFx0XCJ0YWdzXCIgICAgICAgICAgOiBbXVxuXHR9XG5dIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwiQUxcIjogXCJBbGFiYW1hXCIsXG4gICAgXCJBS1wiOiBcIkFsYXNrYVwiLFxuICAgIFwiQVNcIjogXCJBbWVyaWNhbiBTYW1vYVwiLFxuICAgIFwiQVpcIjogXCJBcml6b25hXCIsXG4gICAgXCJBUlwiOiBcIkFya2Fuc2FzXCIsXG4gICAgXCJDQVwiOiBcIkNhbGlmb3JuaWFcIixcbiAgICBcIkNPXCI6IFwiQ29sb3JhZG9cIixcbiAgICBcIkNUXCI6IFwiQ29ubmVjdGljdXRcIixcbiAgICBcIkRFXCI6IFwiRGVsYXdhcmVcIixcbiAgICBcIkRDXCI6IFwiRGlzdHJpY3QgT2YgQ29sdW1iaWFcIixcbiAgICBcIkZNXCI6IFwiRmVkZXJhdGVkIFN0YXRlcyBPZiBNaWNyb25lc2lhXCIsXG4gICAgXCJGTFwiOiBcIkZsb3JpZGFcIixcbiAgICBcIkdBXCI6IFwiR2VvcmdpYVwiLFxuICAgIFwiR1VcIjogXCJHdWFtXCIsXG4gICAgXCJISVwiOiBcIkhhd2FpaVwiLFxuICAgIFwiSURcIjogXCJJZGFob1wiLFxuICAgIFwiSUxcIjogXCJJbGxpbm9pc1wiLFxuICAgIFwiSU5cIjogXCJJbmRpYW5hXCIsXG4gICAgXCJJQVwiOiBcIklvd2FcIixcbiAgICBcIktTXCI6IFwiS2Fuc2FzXCIsXG4gICAgXCJLWVwiOiBcIktlbnR1Y2t5XCIsXG4gICAgXCJMQVwiOiBcIkxvdWlzaWFuYVwiLFxuICAgIFwiTUVcIjogXCJNYWluZVwiLFxuICAgIFwiTUhcIjogXCJNYXJzaGFsbCBJc2xhbmRzXCIsXG4gICAgXCJNRFwiOiBcIk1hcnlsYW5kXCIsXG4gICAgXCJNQVwiOiBcIk1hc3NhY2h1c2V0dHNcIixcbiAgICBcIk1JXCI6IFwiTWljaGlnYW5cIixcbiAgICBcIk1OXCI6IFwiTWlubmVzb3RhXCIsXG4gICAgXCJNU1wiOiBcIk1pc3Npc3NpcHBpXCIsXG4gICAgXCJNT1wiOiBcIk1pc3NvdXJpXCIsXG4gICAgXCJNVFwiOiBcIk1vbnRhbmFcIixcbiAgICBcIk5FXCI6IFwiTmVicmFza2FcIixcbiAgICBcIk5WXCI6IFwiTmV2YWRhXCIsXG4gICAgXCJOSFwiOiBcIk5ldyBIYW1wc2hpcmVcIixcbiAgICBcIk5KXCI6IFwiTmV3IEplcnNleVwiLFxuICAgIFwiTk1cIjogXCJOZXcgTWV4aWNvXCIsXG4gICAgXCJOWVwiOiBcIk5ldyBZb3JrXCIsXG4gICAgXCJOQ1wiOiBcIk5vcnRoIENhcm9saW5hXCIsXG4gICAgXCJORFwiOiBcIk5vcnRoIERha290YVwiLFxuICAgIFwiTVBcIjogXCJOb3J0aGVybiBNYXJpYW5hIElzbGFuZHNcIixcbiAgICBcIk9IXCI6IFwiT2hpb1wiLFxuICAgIFwiT0tcIjogXCJPa2xhaG9tYVwiLFxuICAgIFwiT1JcIjogXCJPcmVnb25cIixcbiAgICBcIlBXXCI6IFwiUGFsYXVcIixcbiAgICBcIlBBXCI6IFwiUGVubnN5bHZhbmlhXCIsXG4gICAgXCJQUlwiOiBcIlB1ZXJ0byBSaWNvXCIsXG4gICAgXCJSSVwiOiBcIlJob2RlIElzbGFuZFwiLFxuICAgIFwiU0NcIjogXCJTb3V0aCBDYXJvbGluYVwiLFxuICAgIFwiU0RcIjogXCJTb3V0aCBEYWtvdGFcIixcbiAgICBcIlROXCI6IFwiVGVubmVzc2VlXCIsXG4gICAgXCJUWFwiOiBcIlRleGFzXCIsXG4gICAgXCJVVFwiOiBcIlV0YWhcIixcbiAgICBcIlZUXCI6IFwiVmVybW9udFwiLFxuICAgIFwiVklcIjogXCJWaXJnaW4gSXNsYW5kc1wiLFxuICAgIFwiVkFcIjogXCJWaXJnaW5pYVwiLFxuICAgIFwiV0FcIjogXCJXYXNoaW5ndG9uXCIsXG4gICAgXCJXVlwiOiBcIldlc3QgVmlyZ2luaWFcIixcbiAgICBcIldJXCI6IFwiV2lzY29uc2luXCIsXG4gICAgXCJXWVwiOiBcIld5b21pbmdcIlxufSIsIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUocmVxdWlyZShcInJlYWN0XCIpLHJlcXVpcmUoXCJkM1wiKSxyZXF1aXJlKFwibGVhZmxldFwiKSxyZXF1aXJlKFwicmVhY3QtbGVhZmxldFwiKSxyZXF1aXJlKFwicmVhY3QtZG9tXCIpLHJlcXVpcmUoXCJjYXJ0b2RiLWNsaWVudFwiKSxyZXF1aXJlKFwiaW50cm8uanNcIikscmVxdWlyZShcInF1ZXVlLWFzeW5jXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInJlYWN0XCIsXCJkM1wiLFwibGVhZmxldFwiLFwicmVhY3QtbGVhZmxldFwiLFwicmVhY3QtZG9tXCIsXCJjYXJ0b2RiLWNsaWVudFwiLFwiaW50cm8uanNcIixcInF1ZXVlLWFzeW5jXCJdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHNbXCJAcGFub3JhbWEvdG9vbGtpdFwiXT1lKHJlcXVpcmUoXCJyZWFjdFwiKSxyZXF1aXJlKFwiZDNcIikscmVxdWlyZShcImxlYWZsZXRcIikscmVxdWlyZShcInJlYWN0LWxlYWZsZXRcIikscmVxdWlyZShcInJlYWN0LWRvbVwiKSxyZXF1aXJlKFwiY2FydG9kYi1jbGllbnRcIikscmVxdWlyZShcImludHJvLmpzXCIpLHJlcXVpcmUoXCJxdWV1ZS1hc3luY1wiKSk6dFtcIkBwYW5vcmFtYS90b29sa2l0XCJdPWUodC5SZWFjdCx0LmQzLHQubGVhZmxldCx0W1wicmVhY3QtbGVhZmxldFwiXSx0W1wicmVhY3QtZG9tXCJdLHRbXCJjYXJ0b2RiLWNsaWVudFwiXSx0W1wiaW50cm8uanNcIl0sdFtcInF1ZXVlLWFzeW5jXCJdKX0odGhpcyxmdW5jdGlvbih0LGUsbixvLGkscyxhLHUpe3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgbz1uW3JdPXtleHBvcnRzOnt9LGlkOnIsbG9hZGVkOiExfTtyZXR1cm4gdFtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxlKSxvLmxvYWRlZD0hMCxvLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIGUubT10LGUuYz1uLGUucD1cIlwiLGUoMCl9KGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpKXN3aXRjaCh0eXBlb2YgdFtlXSl7Y2FzZVwiZnVuY3Rpb25cIjpicmVhaztjYXNlXCJvYmplY3RcIjp0W2VdPWZ1bmN0aW9uKGUpe3ZhciBuPWUuc2xpY2UoMSkscj10W2VbMF1dO3JldHVybiBmdW5jdGlvbih0LGUsbyl7ci5hcHBseSh0aGlzLFt0LGUsb10uY29uY2F0KG4pKX19KHRbZV0pO2JyZWFrO2RlZmF1bHQ6dFtlXT10W3RbZV1dfXJldHVybiB0fShbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oNDUpLGk9cihvKSxzPW4oNzIpLGE9cihzKSx1PW4oNzMpLGw9cih1KSxjPW4oNzQpLHA9cihjKSxmPW4oNDYpLGg9cihmKSxkPW4oODEpLHk9cihkKSx2PW4oNzUpLG09cih2KSxnPW4oNzYpLHg9cihnKSxiPW4oNzgpLGs9cihiKSxfPW4oNzkpLFA9cihfKSxUPW4oODApLE89cihUKSx3PW4oODQpLE09cih3KSxFPW4oODUpLEM9cihFKSxTPW4oODcpLGo9cihTKSxBPW4oODkpLEw9cihBKSxJPW4oOTApLFI9cihJKSxEPW4oMzEpLE49big5MiksRj1yKE4pLEg9big5NyksVT1yKEgpLHE9big5MyksVz1yKHEpLEI9big4Myksej1yKEIpLEs9big5NSksRz1yKEspO2VbXCJkZWZhdWx0XCJdPXtBcmVhQ2hhcnQ6aVtcImRlZmF1bHRcIl0sQ2FydG9EQkxvYWRlcjphW1wiZGVmYXVsdFwiXSxDYXJ0b0RCVGlsZUxheWVyOmxbXCJkZWZhdWx0XCJdLENoYXJ0U2xpZGVyOnBbXCJkZWZhdWx0XCJdLERpc2NyZXRlQmFyQ2hhcnQ6aFtcImRlZmF1bHRcIl0sRG9udXQ6eVtcImRlZmF1bHRcIl0sSGFzaE1hbmFnZXI6bVtcImRlZmF1bHRcIl0sSG9yaXpvbnRhbERpc2NyZXRlQmFyQ2hhcnQ6eFtcImRlZmF1bHRcIl0sSW50cm9NYW5hZ2VyOmtbXCJkZWZhdWx0XCJdLEl0ZW1TZWxlY3RvcjpQW1wiZGVmYXVsdFwiXSxMZWFmbGV0Q2hvcm9wbGV0aDpPW1wiZGVmYXVsdFwiXSxMZWdlbmQ6TVtcImRlZmF1bHRcIl0sTGluZUNoYXJ0OkNbXCJkZWZhdWx0XCJdLE1hcENob3JvcGxldGg6altcImRlZmF1bHRcIl0sTmF2aWdhdGlvbjpMW1wiZGVmYXVsdFwiXSxPZmZzZXRBcmVhQ2hhcnQ6UltcImRlZmF1bHRcIl0sUGFub3JhbWFEaXNwYXRjaGVyOkQuUGFub3JhbWFEaXNwYXRjaGVyLFBhbm9yYW1hRXZlbnRUeXBlczpELlBhbm9yYW1hRXZlbnRUeXBlcyxQdW5jaGNhcmQ6RltcImRlZmF1bHRcIl0sVGltZUJhc2VkTWFya2VyczpVW1wiZGVmYXVsdFwiXSxUb29sdGlwOnpbXCJkZWZhdWx0XCJdLFNjYXR0ZXJQbG90OldbXCJkZWZhdWx0XCJdLFRleHR1cmFsTGlzdDpHW1wiZGVmYXVsdFwiXX0sdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2VbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7XCJkZWZhdWx0XCI6dH19LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMTAyKVtcImRlZmF1bHRcIl07ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBvPWVbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLHIodCxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksZS5fX2VzTW9kdWxlPSEwfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMDMpW1wiZGVmYXVsdFwiXTtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBvPSEwO287KXt2YXIgaT10LHM9ZSxhPW47bz0hMSxudWxsPT09aSYmKGk9RnVuY3Rpb24ucHJvdG90eXBlKTt2YXIgdT1yKGkscyk7aWYodm9pZCAwIT09dSl7aWYoXCJ2YWx1ZVwiaW4gdSlyZXR1cm4gdS52YWx1ZTt2YXIgbD11LmdldDtpZih2b2lkIDA9PT1sKXJldHVybjtyZXR1cm4gbC5jYWxsKGEpfXZhciBjPU9iamVjdC5nZXRQcm90b3R5cGVPZihpKTtpZihudWxsPT09YylyZXR1cm47dD1jLGU9cyxuPWEsbz0hMCx1PWM9dm9pZCAwfX0sZS5fX2VzTW9kdWxlPSEwfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMDEpW1wiZGVmYXVsdFwiXSxvPW4oMTA1KVtcImRlZmF1bHRcIl07ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9cihlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKG8/byh0LGUpOnQuX19wcm90b19fPWUpfSxlLl9fZXNNb2R1bGU9ITB9LGZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LGZ1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5leHBvcnRzPXt2ZXJzaW9uOlwiMS4yLjZcIn07XCJudW1iZXJcIj09dHlwZW9mIF9fZSYmKF9fZT1uKX0sZnVuY3Rpb24odCxlKXt2YXIgbj1PYmplY3Q7dC5leHBvcnRzPXtjcmVhdGU6bi5jcmVhdGUsZ2V0UHJvdG86bi5nZXRQcm90b3R5cGVPZixpc0VudW06e30ucHJvcGVydHlJc0VudW1lcmFibGUsZ2V0RGVzYzpuLmdldE93blByb3BlcnR5RGVzY3JpcHRvcixzZXREZXNjOm4uZGVmaW5lUHJvcGVydHksc2V0RGVzY3M6bi5kZWZpbmVQcm9wZXJ0aWVzLGdldEtleXM6bi5rZXlzLGdldE5hbWVzOm4uZ2V0T3duUHJvcGVydHlOYW1lcyxnZXRTeW1ib2xzOm4uZ2V0T3duUHJvcGVydHlTeW1ib2xzLGVhY2g6W10uZm9yRWFjaH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEzMikoXCJ3a3NcIiksbz1uKDEzOCksaT1uKDEyKS5TeW1ib2w7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByW3RdfHwoclt0XT1pJiZpW3RdfHwoaXx8bykoXCJTeW1ib2wuXCIrdCkpfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMjMpW1wiZGVmYXVsdFwiXTtlW1wiZGVmYXVsdFwiXT1yfHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1hcmd1bWVudHNbZV07Zm9yKHZhciByIGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scikmJih0W3JdPW5bcl0pfXJldHVybiB0fSxlLl9fZXNNb2R1bGU9ITB9LGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5leHBvcnRzPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1wibnVtYmVyXCI9PXR5cGVvZiBfX2cmJihfX2c9bil9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDMpW1wiZGVmYXVsdFwiXSxvPW4oMilbXCJkZWZhdWx0XCJdLGk9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9big3KSxhPWkocyksdT1uKDk4KSxsPWkodSksYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7byh0aGlzLHQpLHRoaXMuX3Byb3BzPWUsdGhpcy5yb290PW51bGwsdGhpcy5tb3VudGVkPSExLHRoaXMuYXhlcz1bXSx0aGlzLnRvb2x0aXA9bnVsbCx0aGlzLmRpc3BhdGNoPWFbXCJkZWZhdWx0XCJdLmRpc3BhdGNoKFwibW91bnRlZFwiLFwidXBkYXRlZFwiLFwibW91c2VPdmVyXCIsXCJtb3VzZU91dFwiLFwibW91c2VNb3ZlXCIsXCJjbGlja1wiKX1yZXR1cm4gcih0LFt7a2V5Olwid2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLm1vdW50ZWR8fCh0aGlzLmFkZEV2ZW50cygpLHRoaXMucm9vdD1hW1wiZGVmYXVsdFwiXS5zZWxlY3QodGhpcy5zZWxlY3RvciksdGhpcy5zdmc9dGhpcy5yb290LmFwcGVuZChcInN2Z1wiKS5jbGFzc2VkKFwiaW50ZXJhY3RpdmVcIix0aGlzLnByb3BzLmludGVyYWN0aXZlKSx0aGlzLnByb3BzLmludGVyYWN0aXZlJiZ0aGlzLnByb3BzLnRvb2x0aXAmJnRoaXMuc3ZnLm9uKFwibW91c2Vtb3ZlXCIsdGhpcy5kaXNwYXRjaC5tb3VzZU1vdmUpLHRoaXMuYmFzZT10aGlzLnN2Zy5hcHBlbmQoXCJnXCIpLHRoaXMudXBkYXRlRGltZW5zaW9ucygpLHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm9uTW91bnQodC5iYXNlKX0pLHRoaXMudG9vbHRpcFJlZiYmKHRoaXMudG9vbHRpcD1uZXcgbFtcImRlZmF1bHRcIl0odGhpcy50b29sdGlwUmVmLHRoaXMucHJvcHMudG9vbHRpcE9wdGlvbnN8fHt9KSx0aGlzLnRvb2x0aXAucmVsYXRpdmVDb250YWluZXI9dGhpcy5zdmcpLHRoaXMubW91bnRlZD0hMCx0aGlzLmRpc3BhdGNoLm1vdW50ZWQoKSl9fSx7a2V5Olwib25VcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubW91bnRlZCYmKHRoaXMudXBkYXRlRGltZW5zaW9ucygpLHRoaXMuX3JlbmRlcigpLHRoaXMuZGlzcGF0Y2gudXBkYXRlZCgpKX19LHtrZXk6XCJvblVuTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9uVW5Nb3VudCgpfSksdGhpcy5heGVzLmxlbmd0aD0wLHRoaXMucmVtb3ZlRXZlbnRzKCksdGhpcy5zdmcub24oXCJtb3ZlXCIsbnVsbCksdGhpcy5zdmcucmVtb3ZlKCksdGhpcy5yb290PXRoaXMuc3ZnPW51bGwsdGhpcy5tb3VudGVkPSExLHRoaXMucHJvcHM9bnVsbH19LHtrZXk6XCJhZGRFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGlzcGF0Y2gub24oXCJtb3VudGVkXCIsdGhpcy5vbk1vdW50ZWRIYW5kbGVyLmJpbmQodGhpcykpLHRoaXMuZGlzcGF0Y2gub24oXCJ1cGRhdGVkXCIsdGhpcy5vblVwZGF0ZWRIYW5kbGVyLmJpbmQodGhpcykpLHRoaXMuZGlzcGF0Y2gub24oXCJtb3VzZU92ZXJcIix0aGlzLm9uTW91c2VPdmVySGFuZGxlci5iaW5kKHRoaXMpKSx0aGlzLmRpc3BhdGNoLm9uKFwibW91c2VPdXRcIix0aGlzLm9uTW91c2VPdXRIYW5kbGVyLmJpbmQodGhpcykpLHRoaXMuZGlzcGF0Y2gub24oXCJjbGlja1wiLHRoaXMub25DbGlja0hhbmRsZXIuYmluZCh0aGlzKSksdGhpcy5kaXNwYXRjaC5vbihcIm1vdXNlTW92ZVwiLHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcykpfX0se2tleTpcInJlbW92ZUV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kaXNwYXRjaC5vbihcIm1vdW50ZWRcIixudWxsKSx0aGlzLmRpc3BhdGNoLm9uKFwidXBkYXRlZFwiLG51bGwpLHRoaXMuZGlzcGF0Y2gub24oXCJtb3VzZU92ZXJcIixudWxsKSx0aGlzLmRpc3BhdGNoLm9uKFwibW91c2VPdXRcIixudWxsKSx0aGlzLmRpc3BhdGNoLm9uKFwibW91c2VNb3ZlXCIsbnVsbCksdGhpcy5kaXNwYXRjaC5vbihcImNsaWNrXCIsbnVsbCl9fSx7a2V5Olwib25Nb3VudGVkSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50SGFuZGxlciYmdGhpcy5wcm9wcy5vbk1vdW50SGFuZGxlcigpfX0se2tleTpcIm9uVXBkYXRlZEhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbigpe1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMucHJvcHMub25VcGRhdGVkSGFuZGxlciYmdGhpcy5wcm9wcy5vblVwZGF0ZWRIYW5kbGVyKCl9fSx7a2V5Olwib25Nb3VzZU92ZXJIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy50b29sdGlwJiZ0aGlzLnRvb2x0aXAuc2hvdyhhW1wiZGVmYXVsdFwiXS5ldmVudCx0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnByb3BzLm9uTW91c2VPdmVySGFuZGxlciYmdGhpcy5wcm9wcy5vbk1vdXNlT3ZlckhhbmRsZXIodCl9fSx7a2V5Olwib25Nb3VzZU91dEhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnRvb2x0aXAmJnRoaXMudG9vbHRpcC5oaWRlKCksXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5wcm9wcy5vbk1vdXNlT3V0SGFuZGxlciYmdGhpcy5wcm9wcy5vbk1vdXNlT3V0SGFuZGxlcih0KX19LHtrZXk6XCJvbk1vdXNlTW92ZUhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudG9vbHRpcCYmdGhpcy50b29sdGlwLnNldFBvc2l0aW9uKGFbXCJkZWZhdWx0XCJdLmV2ZW50KX19LHtrZXk6XCJvbkNsaWNrSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMucHJvcHMub25DbGlja0hhbmRsZXImJnRoaXMucHJvcHMub25DbGlja0hhbmRsZXIodCl9fSx7a2V5Olwic2V0QXhpc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe1wiQXhpc1wiPT09dC50b1N0cmluZygpJiZ0aGlzLmF4ZXMucHVzaCh0KX19LHtrZXk6XCJ1cGRhdGVBeGlzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXhlc1t0XS51cGRhdGUoZSxuKX19LHtrZXk6XCJfcmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BzLmRhdGEmJih0aGlzLnByZVJlbmRlcigpLHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlbmRlcigpfSksdGhpcy5yZW5kZXIoKSx0aGlzLnBvc3RSZW5kZXIoKSl9fSx7a2V5OlwicHJlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXIgZnVuY3Rpb24gc2hvdWxkIGJlIGltcGxlbWVudGVkXCIpfX0se2tleTpcInBvc3RSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJ1cGRhdGVEaW1lbnNpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5wcm9wcyxuPWUud2lkdGgscj1lLmhlaWdodCxvPWUubWFyZ2luOyh0aGlzLndpZHRoIT09bnx8dGhpcy5oZWlnaHQhPT1yKSYmKHRoaXMud2lkdGg9bi1vLmxlZnQtby5yaWdodCx0aGlzLmhlaWdodD1yLW8udG9wLW8uYm90dG9tLHRoaXMuc3ZnLmF0dHIoXCJ3aWR0aFwiLG4pLmF0dHIoXCJoZWlnaHRcIixyKSx0aGlzLmJhc2UuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKFwiK28ubGVmdCtcIixcIitvLnRvcCtcIilcIiksdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS53aWR0aD10LndpZHRoLGUuaGVpZ2h0PXQuaGVpZ2h0fSkpfX0se2tleTpcInNlbGVjdG9yXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlbGVjdG9yfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fc2VsZWN0b3I9dH19LHtrZXk6XCJwcm9wc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9wc30sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3Byb3BzPXR9fSx7a2V5OlwidG9vbHRpcFJlZlwiLHNldDpmdW5jdGlvbih0KXt0aGlzLl90b29sdGlwUmVmPXR9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90b29sdGlwUmVmfX1dKSx0fSgpO2VbXCJkZWZhdWx0XCJdPWMsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPW4oMzIpO24oMTYzKTt2YXIgcD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuY2hhcnRDb25zdHJ1Y3Rvcil0aHJvdyBuZXcgRXJyb3IoXCJOZWVkIHRvIHNldCBjaGFydENvbnN0cnVjdG9yXCIpO3RoaXMuY2hhcnQ9bmV3IHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcih0aGlzLnByb3BzKSx0aGlzLmNoYXJ0LndpbGxNb3VudCgpfX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNoYXJ0LnNlbGVjdG9yPXRoaXMucmVmcy5jaGFydCx0aGlzLmNoYXJ0LnRvb2x0aXBSZWY9dGhpcy5yZWZzLnRvb2x0aXAsdGhpcy5jaGFydC5wcm9wcz10aGlzLnByb3BzLHRoaXMuY2hhcnQub25Nb3VudCgpfX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jaGFydC5wcm9wcz10aGlzLnByb3BzLHRoaXMuY2hhcnQub25VcGRhdGUoKX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jaGFydC5vblVuTW91bnQoKSx0aGlzLmNoYXJ0PW51bGx9fSx7a2V5OlwiZ2V0Q2xhc3NOYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jbGFzc05hbWU/XCIgXCIrdGhpcy5wcm9wcy5jbGFzc05hbWU6XCJcIn19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbm9yYW1hXCIrdGhpcy5nZXRDbGFzc05hbWUoKX0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6XCJjaGFydFwiLGNsYXNzTmFtZTpcInBhbm9yYW1hLS1jaGFydC1jb250YWluZXJcIn0sdGhpcy5wcm9wcy50b29sdGlwJiZsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3JlZjpcInRvb2x0aXBcIixjbGFzc05hbWU6XCJwYW5vcmFtYS0tdG9vbHRpcFwifSkpKX19XSxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOmMuRGVmYXVsdFR5cGVzLGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTpjLkRlZmF1bHRQcm9wcyxlbnVtZXJhYmxlOiEwfV0pLGV9KHUuQ29tcG9uZW50KTtlW1wiZGVmYXVsdFwiXT1wLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjUpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighcih0KSl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYW4gb2JqZWN0IVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXt9fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuISF0JiYoXCJvYmplY3RcIj09ZXx8XCJmdW5jdGlvblwiPT1lKX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMylbXCJkZWZhdWx0XCJdLG89bigyKVtcImRlZmF1bHRcIl0saT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKDcpLGE9aShzKSx1PW4oMzIpLGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsbil7byh0aGlzLHQpLHRoaXMuX29wdGlvbnM9ZSx0aGlzLmF4aXM9YVtcImRlZmF1bHRcIl0uc3ZnLmF4aXMoKS5zY2FsZShuKSx0aGlzLmVsZW1lbnQ9bnVsbH1yZXR1cm4gcih0LFt7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLm9wdGlvbnM9ZSx0aGlzLmF4aXMuc2NhbGUodCksdGhpcy5zZXRBeGlzTWV0aG9kcygpfX0se2tleTpcIm9uTW91bnRcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmVsZW1lbnQ9dC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLHRoaXMub3B0aW9ucy5jbGFzc05hbWV8fFwiXCIpLHRoaXMuc2V0QXhpc01ldGhvZHMoKSx0aGlzLmF4aXNMYWJlbCgpfX0se2tleTpcIm9uVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwib25Vbk1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQmJnRoaXMuZWxlbWVudC5yZW1vdmUoKSx0aGlzLl9vcHRpb25zPW51bGwsdGhpcy5lbGVtZW50PW51bGwsdGhpcy5heGlzPW51bGx9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNldFBvc2l0aW9uKCksdGhpcy5lbGVtZW50LmNhbGwodGhpcy5heGlzKSx0aGlzLnJlbmRlclRpY2tFeHRyYXMoKSx0aGlzLnJlbmRlckxhYmVsRXh0cmFzKCl9fSx7a2V5OlwicmVuZGVyVGlja0V4dHJhc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50LnNlbGVjdEFsbChcInRleHRcIik7dGhpcy5vcHRpb25zLmF0dHImJnQuYXR0cih0aGlzLm9wdGlvbnMuYXR0ciksdGhpcy5vcHRpb25zLnN0eWxlJiZ0LnN0eWxlKHRoaXMub3B0aW9ucy5zdHlsZSl9fSx7a2V5OlwicmVuZGVyTGFiZWxFeHRyYXNcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMubGFiZWwmJnRoaXMub3B0aW9ucy5sYWJlbCl7dmFyIHQ9dGhpcy5vcHRpb25zLmxhYmVsO3QuYXR0ciYmdGhpcy5sYWJlbC5hdHRyKHQuYXR0ciksdC5zdHlsZSYmdGhpcy5sYWJlbC5zdHlsZSh0LnN0eWxlKX19fSx7a2V5Olwic2V0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5wb3NpdGlvbjtpZih0KXN3aXRjaCh0KXtjYXNlXCJib3R0b21cIjp0aGlzLmVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKDAsXCIrdGhpcy5oZWlnaHQrXCIpXCIpO2JyZWFrO2Nhc2VcInJpZ2h0XCI6dGhpcy5lbGVtZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIit0aGlzLndpZHRoK1wiLDApXCIpfX19LHtrZXk6XCJzZXRBeGlzTWV0aG9kc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt1LmF4aXNNZXRob2RzLmZvckVhY2goZnVuY3Rpb24oZSl7dC5vcHRpb25zLmhhc093blByb3BlcnR5KGUpJiZ0LmF4aXNbZV0odC5vcHRpb25zW2VdKX0pfX0se2tleTpcImF4aXNMYWJlbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmxhYmVsJiYodGhpcy5sYWJlbD10aGlzLmVsZW1lbnQuYXBwZW5kKFwidGV4dFwiKS50ZXh0KHRoaXMub3B0aW9ucy5sYWJlbC50ZXh0KSl9fSx7a2V5OlwidG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVyblwiQXhpc1wifX0se2tleTpcIm9wdGlvbnNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3B0aW9uc30sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX29wdGlvbnM9dH19LHtrZXk6XCJ3aWR0aFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93aWR0aH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3dpZHRoPXR9fSx7a2V5OlwiaGVpZ2h0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hlaWdodH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX2hlaWdodD10fX1dKSx0fSgpO2VbXCJkZWZhdWx0XCJdPWwsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigzNCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXtpZihyKHQpLHZvaWQgMD09PWUpcmV0dXJuIHQ7c3dpdGNoKG4pe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHQuY2FsbChlLG4pfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scil7cmV0dXJuIHQuY2FsbChlLG4scil9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24obixyLG8pe3JldHVybiB0LmNhbGwoZSxuLHIsbyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMiksbz1uKDgpLGk9bigxOSkscz1cInByb3RvdHlwZVwiLGE9ZnVuY3Rpb24odCxlLG4pe3ZhciB1LGwsYyxwPXQmYS5GLGY9dCZhLkcsaD10JmEuUyxkPXQmYS5QLHk9dCZhLkIsdj10JmEuVyxtPWY/bzpvW2VdfHwob1tlXT17fSksZz1mP3I6aD9yW2VdOihyW2VdfHx7fSlbc107ZiYmKG49ZSk7Zm9yKHUgaW4gbilsPSFwJiZnJiZ1IGluIGcsbCYmdSBpbiBtfHwoYz1sP2dbdV06blt1XSxtW3VdPWYmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGdbdV0/blt1XTp5JiZsP2koYyxyKTp2JiZnW3VdPT1jP2Z1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgdD9uZXcgdChlKTp0KGUpfTtyZXR1cm4gZVtzXT10W3NdLGV9KGMpOmQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGM/aShGdW5jdGlvbi5jYWxsLGMpOmMsZCYmKChtW3NdfHwobVtzXT17fSkpW3VdPWMpKX07YS5GPTEsYS5HPTIsYS5TPTQsYS5QPTgsYS5CPTE2LGEuVz0zMix0LmV4cG9ydHM9YX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigxMTApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUpe3ZhciBuPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbi5jYWxsKHQpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT10eXBlb2YgdH19LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBudWxsIT10JiZpKG8odCkpfXZhciBvPW4oMTc0KSxpPW4oMjcpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJnQ+LTEmJnQlMT09MCYmcj49dH12YXIgcj05MDA3MTk5MjU0NzQwOTkxO3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT10eXBlb2YgdH10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNjMpLG89bigyNyksaT1uKDI4KSxzPVwiW29iamVjdCBBcnJheV1cIixhPU9iamVjdC5wcm90b3R5cGUsdT1hLnRvU3RyaW5nLGw9cihBcnJheSxcImlzQXJyYXlcIiksYz1sfHxmdW5jdGlvbih0KXtyZXR1cm4gaSh0KSYmbyh0Lmxlbmd0aCkmJnUuY2FsbCh0KT09c307dC5leHBvcnRzPWN9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDIzKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89big3MCksaT17TGVnZW5kOntzZWxlY3RlZDpcIkxlZ2VuZDpzZWxlY3RlZFwifSxJdGVtU2VsZWN0b3I6e3NlbGVjdGVkOlwiSXRlbVNlbGVjdG9yOnNlbGVjdGVkXCJ9LENoYXJ0U2xpZGVyOntzZWxlY3RlZDpcIkNoYXJ0U2xpZGVyOnNlbGVjdGVkXCJ9fTtlLlBhbm9yYW1hRXZlbnRUeXBlcz1pO3ZhciBzPXtMZWdlbmQ6e3NlbGVjdGVkOmZ1bmN0aW9uKHQsZSl7cy5lbWl0KGkuTGVnZW5kLnNlbGVjdGVkLHQsZSl9fSxJdGVtU2VsZWN0b3I6e3NlbGVjdGVkOmZ1bmN0aW9uKHQsZSl7cy5lbWl0KGkuSXRlbVNlbGVjdG9yLnNlbGVjdGVkLHQsZSl9fSxDaGFydFNsaWRlcjp7c2VsZWN0ZWQ6ZnVuY3Rpb24odCl7cy5lbWl0KGkuQ2hhcnRTbGlkZXIuc2VsZWN0ZWQsdCl9fX07ZS5QYW5vcmFtYURpc3BhdGNoZXI9cyxyKHMsby5FdmVudEVtaXR0ZXIucHJvdG90eXBlKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oNiksaT1uKDcpLHM9cihpKSxhPXt3aWR0aDpvLlByb3BUeXBlcy5udW1iZXIsaGVpZ2h0Om8uUHJvcFR5cGVzLm51bWJlcixtYXJnaW46by5Qcm9wVHlwZXMuc2hhcGUoe3RvcDpvLlByb3BUeXBlcy5udW1iZXIscmlnaHQ6by5Qcm9wVHlwZXMubnVtYmVyLGJvdHRvbTpvLlByb3BUeXBlcy5udW1iZXIsbGVmdDpvLlByb3BUeXBlcy5udW1iZXJ9KSx4QWNjZXNzb3I6by5Qcm9wVHlwZXMuZnVuYyx5QWNjZXNzb3I6by5Qcm9wVHlwZXMuZnVuYyxzZWxlY3Rpb25BY2Nlc3NvcjpvLlByb3BUeXBlcy5mdW5jLHhTY2FsZTpvLlByb3BUeXBlcy5mdW5jLHlTY2FsZTpvLlByb3BUeXBlcy5mdW5jLHhheGlzOm8uUHJvcFR5cGVzLm9iamVjdCx5YXhpczpvLlByb3BUeXBlcy5vYmplY3QsaW50ZXJhY3RpdmU6by5Qcm9wVHlwZXMuYm9vbCx0b29sdGlwOm8uUHJvcFR5cGVzLmJvb2x9O2UuRGVmYXVsdFR5cGVzPWE7dmFyIHU9e3dpZHRoOjk2MCxoZWlnaHQ6NTAwLG1hcmdpbjp7dG9wOjIwLHJpZ2h0OjMwLGJvdHRvbToyMCxsZWZ0OjMwfSxzZWxlY3Rpb25BY2Nlc3NvcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5rZXl9LHhBY2Nlc3NvcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5rZXl9LHlBY2Nlc3NvcjpmdW5jdGlvbih0KXtyZXR1cm4gdC52YWx1ZX0seFNjYWxlOnNbXCJkZWZhdWx0XCJdLnNjYWxlLmxpbmVhcigpLHlTY2FsZTpzW1wiZGVmYXVsdFwiXS5zY2FsZS5saW5lYXIoKSxpbnRlcmFjdGl2ZTohMCx0b29sdGlwOiExfTtlLkRlZmF1bHRQcm9wcz11O3ZhciBsPVtcIm9yaWVudFwiLFwidGlja3NcIixcInRpY2tWYWx1ZXNcIixcInRpY2tTaXplXCIsXCJpbm5lclRpY2tTaXplXCIsXCJvdXRlclRpY2tTaXplXCIsXCJ0aWNrUGFkZGluZ1wiLFwidGlja0Zvcm1hdFwiXTtlLmF4aXNNZXRob2RzPWw7dmFyIGM9e2Nsb3NlRGVsYXk6MTAwLGFsaWduOlwidG9wIGNlbnRlclwiLG9mZnNldDpbMCwtMTBdfTtlLnRvb2x0aXBEZWZhdWx0T3B0aW9ucz1jfSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2VbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQsZSl7dmFyIG49e307Zm9yKHZhciByIGluIHQpZS5pbmRleE9mKHIpPj0wfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG59LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYSBmdW5jdGlvbiFcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyNCksbz1uKDEwKShcInRvU3RyaW5nVGFnXCIpLGk9XCJBcmd1bWVudHNcIj09cihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZSxuLHM7cmV0dXJuIHZvaWQgMD09PXQ/XCJVbmRlZmluZWRcIjpudWxsPT09dD9cIk51bGxcIjpcInN0cmluZ1wiPT10eXBlb2Yobj0oZT1PYmplY3QodCkpW29dKT9uOmk/cihlKTpcIk9iamVjdFwiPT0ocz1yKGUpKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jYWxsZWU/XCJBcmd1bWVudHNcIjpzfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9IW4oMzgpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2goZSl7cmV0dXJuITB9fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOSksbz1uKDU0KTt0LmV4cG9ydHM9bigzNyk/ZnVuY3Rpb24odCxlLG4pe3JldHVybiByLnNldERlc2ModCxlLG8oMSxuKSl9OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdFtlXT1uLHR9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big5KS5zZXREZXNjLG89big0OSksaT1uKDEwKShcInRvU3RyaW5nVGFnXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dCYmIW8odD1uP3Q6dC5wcm90b3R5cGUsaSkmJnIodCxpLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZX0pfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMTM1KSghMCk7big1MSkoU3RyaW5nLFwiU3RyaW5nXCIsZnVuY3Rpb24odCl7dGhpcy5fdD1TdHJpbmcodCksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5fdCxuPXRoaXMuX2k7cmV0dXJuIG4+PWUubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KHQ9cihlLG4pLHRoaXMuX2krPXQubGVuZ3RoLHt2YWx1ZTp0LGRvbmU6ITF9KX0pfSxmdW5jdGlvbih0LGUsbil7bigxNDEpO3ZhciByPW4oMTYpO3IuTm9kZUxpc3Q9ci5IVE1MQ29sbGVjdGlvbj1yLkFycmF5fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gdD1cIm51bWJlclwiPT10eXBlb2YgdHx8ci50ZXN0KHQpPyt0Oi0xLGU9bnVsbD09ZT9vOmUsdD4tMSYmdCUxPT0wJiZlPnR9dmFyIHI9L15cXGQrJC8sbz05MDA3MTk5MjU0NzQwOTkxO3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gaSh0KSYmbyh0KSYmYS5jYWxsKHQsXCJjYWxsZWVcIikmJiF1LmNhbGwodCxcImNhbGxlZVwiKX12YXIgbz1uKDI2KSxpPW4oMjgpLHM9T2JqZWN0LnByb3RvdHlwZSxhPXMuaGFzT3duUHJvcGVydHksdT1zLnByb3BlcnR5SXNFbnVtZXJhYmxlO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDcpLGM9dShsKSxwPW4oNiksZj1uKDE0KSxoPXUoZiksZD1uKDcxKSx5PXUoZCk7bigxNDgpO3ZhciB2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj15W1wiZGVmYXVsdFwiXX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxoW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMse2ZpbGxDb2xvcjpwLlByb3BUeXBlcy5vbmVPZlR5cGUoW3AuUHJvcFR5cGVzLnN0cmluZyxwLlByb3BUeXBlcy5udW1iZXJdKSxmaWxsT3BhY2l0eTpwLlByb3BUeXBlcy5udW1iZXIsaW50ZXJwb2xhdGU6cC5Qcm9wVHlwZXMuc3RyaW5nfSksZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOmEoe30saFtcImRlZmF1bHRcIl0uZGVmYXVsdFByb3BzLHt4U2NhbGU6Y1tcImRlZmF1bHRcIl0uc2NhbGUub3JkaW5hbCgpLGNsYXNzTmFtZTpcImFyZWEtY2hhcnRcIixpbnRlcnBvbGF0ZTpcImJhc2lzXCIseGF4aXM6e2NsYXNzTmFtZTpcInggYXhpc1wiLG9yaWVudDpcImJvdHRvbVwiLHBvc2l0aW9uOlwiYm90dG9tXCIsYXR0cjp7ZHg6XCIwXCIsZHk6XCIwLjVlbVwifSxzdHlsZTp7XCJ0ZXh0LWFuY2hvclwiOlwibWlkZGxlXCJ9fSx5YXhpczp7Y2xhc3NOYW1lOlwieSBheGlzXCIsb3JpZW50OlwibGVmdFwifX0pLGVudW1lcmFibGU6ITB9XSksZX0oaFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDYpLGM9big3KSxwPXUoYyksZj1uKDE0KSxoPXUoZiksZD1uKDQ3KSx5PXUoZCk7bigxNTApO3ZhciB2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj15W1wiZGVmYXVsdFwiXX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxoW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMse2JhclNwYWNpbmc6bC5Qcm9wVHlwZXMubnVtYmVyfSksZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOmEoe30saFtcImRlZmF1bHRcIl0uZGVmYXVsdFByb3BzLHtiYXJTcGFjaW5nOi4xLHhTY2FsZTpwW1wiZGVmYXVsdFwiXS5zY2FsZS5vcmRpbmFsKCksY2xhc3NOYW1lOlwiYmFyLWNoYXJ0IHZlcnRpY2FsXCIseGF4aXM6e2NsYXNzTmFtZTpcInggYXhpc1wiLG9yaWVudDpcImJvdHRvbVwiLHBvc2l0aW9uOlwiYm90dG9tXCIsYXR0cjp7ZHg6XCIwXCIsZHk6XCIwLjVlbVwifSxzdHlsZTp7XCJ0ZXh0LWFuY2hvclwiOlwibWlkZGxlXCJ9fSx5YXhpczp7Y2xhc3NOYW1lOlwieSBheGlzXCIsb3JpZW50OlwibGVmdFwifX0pLGVudW1lcmFibGU6ITB9XSksZX0oaFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDEzKSxsPWEodSksYz1uKDcpLHA9YShjKSxmPW4oMTgpLGg9YShmKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oZSx0KSxpKGUsW3trZXk6XCJ3aWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMueGF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy54YXhpcyx0aGlzLnByb3BzLnhTY2FsZSkpLHRoaXMucHJvcHMueWF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy55YXhpcyx0aGlzLnByb3BzLnlTY2FsZSkpfX0se2tleTpcIm9uTW91bnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJvbk1vdW50XCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuX3JlbmRlcigpfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQuZGF0YSxuPXQueEFjY2Vzc29yLHI9dC55QWNjZXNzb3Isbz10LnhTY2FsZSxpPXQueVNjYWxlO28ucmFuZ2VSb3VuZEJhbmRzKFswLHRoaXMud2lkdGhdLHRoaXMuYmFyU3BhY2luZyksby5kb21haW4oZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCl9KSksaS5yYW5nZShbdGhpcy5oZWlnaHQsMF0pLGkuZG9tYWluKFswLHBbXCJkZWZhdWx0XCJdLm1heChlLGZ1bmN0aW9uKHQpe3JldHVybiByKHQpfSldKSx0aGlzLnVwZGF0ZUF4aXMoMCxvLHRoaXMucHJvcHMueGF4aXMpLHRoaXMudXBkYXRlQXhpcygxLGksdGhpcy5wcm9wcy55YXhpcyl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5wcm9wcyxuPWUuZGF0YSxyPWUueEFjY2Vzc29yLG89ZS55QWNjZXNzb3IsaT1lLnhTY2FsZSxzPWUueVNjYWxlLGE9dGhpcy5iYXNlLnNlbGVjdEFsbChcIi5iYXJcIikuZGF0YShuKTthLmV4aXQoKS5yZW1vdmUoKSxhLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIixcImJhclwiKSxhLmF0dHIoXCJ4XCIsZnVuY3Rpb24odCl7cmV0dXJuIGkocih0KSl9KS5hdHRyKFwieVwiLGZ1bmN0aW9uKHQpe3JldHVybiBzKG8odCkpfSkuYXR0cihcIndpZHRoXCIsaS5yYW5nZUJhbmQoKSkuYXR0cihcImhlaWdodFwiLGZ1bmN0aW9uKGUpe3JldHVybiB0LmhlaWdodC1zKG8oZSkpfSl9fSx7a2V5OlwicG9zdFJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQuc2VsZWN0ZWQsbj10LnNlbGVjdGlvbkFjY2Vzc29yLHI9dC5pbnRlcmFjdGl2ZSxvPXRoaXMuYmFzZS5zZWxlY3RBbGwoXCIuYmFyXCIpO3ImJm8ub24oXCJjbGlja1wiLHRoaXMuZGlzcGF0Y2guY2xpY2spLm9uKFwibW91c2VvdmVyXCIsdGhpcy5kaXNwYXRjaC5tb3VzZU92ZXIpLm9uKFwibW91c2VvdXRcIix0aGlzLmRpc3BhdGNoLm1vdXNlT3V0KSxlJiZvLmNsYXNzZWQoXCJzZWxlY3RlZFwiLGZ1bmN0aW9uKHQpe3JldHVybiBuKHQpPT09ZX0pfX0se2tleTpcImJhclNwYWNpbmdcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5iYXJTcGFjaW5nfHwuMX19XSksZX0obFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2VbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZVtcImRlZmF1bHRcIl09dCxlfSxlLl9fZXNNb2R1bGU9ITB9LGZ1bmN0aW9uKHQsZSl7dmFyIG49e30uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY2FsbCh0LGUpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjQpO3QuZXhwb3J0cz1PYmplY3QoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbih0KXtyZXR1cm5cIlN0cmluZ1wiPT1yKHQpP3Quc3BsaXQoXCJcIik6T2JqZWN0KHQpfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNTIpLG89bigyMCksaT1uKDU1KSxzPW4oMzkpLGE9big0OSksdT1uKDE2KSxsPW4oMTI0KSxjPW4oNDApLHA9big5KS5nZXRQcm90byxmPW4oMTApKFwiaXRlcmF0b3JcIiksaD0hKFtdLmtleXMmJlwibmV4dFwiaW5bXS5rZXlzKCkpLGQ9XCJAQGl0ZXJhdG9yXCIseT1cImtleXNcIix2PVwidmFsdWVzXCIsbT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4sZyx4LGIsayl7bChuLGUsZyk7dmFyIF8sUCxUPWZ1bmN0aW9uKHQpe2lmKCFoJiZ0IGluIEUpcmV0dXJuIEVbdF07c3dpdGNoKHQpe2Nhc2UgeTpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG4odGhpcyx0KX07Y2FzZSB2OnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbih0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG4odGhpcyx0KX19LE89ZStcIiBJdGVyYXRvclwiLHc9eD09dixNPSExLEU9dC5wcm90b3R5cGUsQz1FW2ZdfHxFW2RdfHx4JiZFW3hdLFM9Q3x8VCh4KTtpZihDKXt2YXIgaj1wKFMuY2FsbChuZXcgdCkpO2MoaixPLCEwKSwhciYmYShFLGQpJiZzKGosZixtKSx3JiZDLm5hbWUhPT12JiYoTT0hMCxTPWZ1bmN0aW9uKCl7cmV0dXJuIEMuY2FsbCh0aGlzKX0pfWlmKHImJiFrfHwhaCYmIU0mJkVbZl18fHMoRSxmLFMpLHVbZV09Uyx1W09dPW0seClpZihfPXt2YWx1ZXM6dz9TOlQodiksa2V5czpiP1M6VCh5KSxlbnRyaWVzOnc/VChcImVudHJpZXNcIik6U30saylmb3IoUCBpbiBfKVAgaW4gRXx8aShFLFAsX1tQXSk7ZWxzZSBvKG8uUCtvLkYqKGh8fE0pLGUsXyk7cmV0dXJuIF99fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz0hMH0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjApLG89big4KSxpPW4oMzgpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuPShvLk9iamVjdHx8e30pW3RdfHxPYmplY3RbdF0scz17fTtzW3RdPWUobikscihyLlMrci5GKmkoZnVuY3Rpb24oKXtuKDEpfSksXCJPYmplY3RcIixzKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJue2VudW1lcmFibGU6ISgxJnQpLGNvbmZpZ3VyYWJsZTohKDImdCksd3JpdGFibGU6ISg0JnQpLHZhbHVlOmV9fX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDM5KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOSkuZ2V0RGVzYyxvPW4oMjUpLGk9bigxNSkscz1mdW5jdGlvbih0LGUpe2lmKGkodCksIW8oZSkmJm51bGwhPT1lKXRocm93IFR5cGVFcnJvcihlK1wiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKX07dC5leHBvcnRzPXtzZXQ6T2JqZWN0LnNldFByb3RvdHlwZU9mfHwoXCJfX3Byb3RvX19cImlue30/ZnVuY3Rpb24odCxlLG8pe3RyeXtvPW4oMTkpKEZ1bmN0aW9uLmNhbGwscihPYmplY3QucHJvdG90eXBlLFwiX19wcm90b19fXCIpLnNldCwyKSxvKHQsW10pLGU9ISh0IGluc3RhbmNlb2YgQXJyYXkpfWNhdGNoKGkpe2U9ITB9cmV0dXJuIGZ1bmN0aW9uKHQsbil7cmV0dXJuIHModCxuKSxlP3QuX19wcm90b19fPW46byh0LG4pLHR9fSh7fSwhMSk6dm9pZCAwKSxjaGVjazpzfX0sZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLmNlaWwscj1NYXRoLmZsb29yO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaXNOYU4odD0rdCk/MDoodD4wP3I6bikodCl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1MCksbz1uKDM2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIobyh0KSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigzNik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Qocih0KSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigzNSksbz1uKDEwKShcIml0ZXJhdG9yXCIpLGk9bigxNik7dC5leHBvcnRzPW4oOCkuZ2V0SXRlcmF0b3JNZXRob2Q9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9dD90W29dfHx0W1wiQEBpdGVyYXRvclwiXXx8aVtyKHQpXTp2b2lkIDB9fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3Iocik7cmV0dXJuIGU9byh2b2lkIDA9PT1lP3QubGVuZ3RoLTE6K2V8fDAsMCksZnVuY3Rpb24oKXtmb3IodmFyIG49YXJndW1lbnRzLHI9LTEsaT1vKG4ubGVuZ3RoLWUsMCkscz1BcnJheShpKTsrK3I8aTspc1tyXT1uW2Urcl07c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdC5jYWxsKHRoaXMscyk7Y2FzZSAxOnJldHVybiB0LmNhbGwodGhpcyxuWzBdLHMpO2Nhc2UgMjpyZXR1cm4gdC5jYWxsKHRoaXMsblswXSxuWzFdLHMpfXZhciBhPUFycmF5KGUrMSk7Zm9yKHI9LTE7KytyPGU7KWFbcl09bltyXTtyZXR1cm4gYVtlXT1zLHQuYXBwbHkodGhpcyxhKX19dmFyIHI9XCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsbz1NYXRoLm1heDt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJuIG87aWYodm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gdC5jYWxsKGUsbil9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24obixyLG8pe3JldHVybiB0LmNhbGwoZSxuLHIsbyl9O2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24obixyLG8saSl7cmV0dXJuIHQuY2FsbChlLG4scixvLGkpfTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKG4scixvLGkscyl7cmV0dXJuIHQuY2FsbChlLG4scixvLGkscyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19dmFyIG89bigxODIpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuPW51bGw9PXQ/dm9pZCAwOnRbZV07cmV0dXJuIG8obik/bjp2b2lkIDB9dmFyIG89bigxODApO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbyh0KT90Ok9iamVjdCh0KX12YXIgbz1uKDE3KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTY1KSxvPW4oMTY2KSxpPW4oMTcyKSxzPWkoZnVuY3Rpb24odCxlLG4pe3JldHVybiBuP3IodCxlLG4pOm8odCxlKX0pO3QuZXhwb3J0cz1zfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big2Myksbz1uKDI2KSxpPW4oMTcpLHM9bigxNzgpLGE9cihPYmplY3QsXCJrZXlzXCIpLHU9YT9mdW5jdGlvbih0KXt2YXIgZT1udWxsPT10P3ZvaWQgMDp0LmNvbnN0cnVjdG9yO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUucHJvdG90eXBlPT09dHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbyh0KT9zKHQpOmkodCk/YSh0KTpbXX06czt0LmV4cG9ydHM9dX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7aWYobnVsbD09dClyZXR1cm5bXTt1KHQpfHwodD1PYmplY3QodCkpO3ZhciBlPXQubGVuZ3RoO2U9ZSYmYShlKSYmKGkodCl8fG8odCkpJiZlfHwwO2Zvcih2YXIgbj10LmNvbnN0cnVjdG9yLHI9LTEsbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiZuLnByb3RvdHlwZT09PXQscD1BcnJheShlKSxmPWU+MDsrK3I8ZTspcFtyXT1yK1wiXCI7Zm9yKHZhciBoIGluIHQpZiYmcyhoLGUpfHxcImNvbnN0cnVjdG9yXCI9PWgmJihsfHwhYy5jYWxsKHQsaCkpfHxwLnB1c2goaCk7cmV0dXJuIHB9dmFyIG89big0NCksaT1uKDI5KSxzPW4oNDMpLGE9bigyNyksdT1uKDE3KSxsPU9iamVjdC5wcm90b3R5cGUsYz1sLmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXt2YXIgbj10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdChuKT8hdC5kaXNhYmxlZDpcImFcIj09PW4/dC5ocmVmfHxlOmUpJiZvKHQpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIHQub2Zmc2V0V2lkdGg8PTAmJnQub2Zmc2V0SGVpZ2h0PD0wfHxcIm5vbmVcIj09PXQuc3R5bGUuZGlzcGxheX1mdW5jdGlvbiBvKHQpe2Zvcig7dCYmdCE9PWRvY3VtZW50LmJvZHk7KXtpZihyKHQpKXJldHVybiExO3Q9dC5wYXJlbnROb2RlfXJldHVybiEwfWZ1bmN0aW9uIGkodCl7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtudWxsPT09ZSYmKGU9dm9pZCAwKTt2YXIgcj1pc05hTihlKTtyZXR1cm4ocnx8ZT49MCkmJm4odCwhcil9ZnVuY3Rpb24gcyh0KXtyZXR1cm5bXS5zbGljZS5jYWxsKHQucXVlcnlTZWxlY3RvckFsbChcIipcIiksMCkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBpKHQpfSl9dC5leHBvcnRzPXN9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT92b2lkIDA6ZVt0XX19ZnVuY3Rpb24gbyh0KXtyZXR1cm4gbnVsbCE9dCYmcyhnKHQpKX1mdW5jdGlvbiBpKHQsZSl7cmV0dXJuIHQ9XCJudW1iZXJcIj09dHlwZW9mIHR8fGgudGVzdCh0KT8rdDotMSxlPW51bGw9PWU/bTplLHQ+LTEmJnQlMT09MCYmZT50fWZ1bmN0aW9uIHModCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJnQ+LTEmJnQlMT09MCYmbT49dH1mdW5jdGlvbiBhKHQpe2Zvcih2YXIgZT1sKHQpLG49ZS5sZW5ndGgscj1uJiZ0Lmxlbmd0aCxvPSEhciYmcyhyKSYmKGYodCl8fHAodCkpLGE9LTEsdT1bXTsrK2E8bjspe3ZhciBjPWVbYV07KG8mJmkoYyxyKXx8eS5jYWxsKHQsYykpJiZ1LnB1c2goYyl9cmV0dXJuIHV9ZnVuY3Rpb24gdSh0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfWZ1bmN0aW9uIGwodCl7aWYobnVsbD09dClyZXR1cm5bXTt1KHQpfHwodD1PYmplY3QodCkpO3ZhciBlPXQubGVuZ3RoO2U9ZSYmcyhlKSYmKGYodCl8fHAodCkpJiZlfHwwO2Zvcih2YXIgbj10LmNvbnN0cnVjdG9yLHI9LTEsbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiZuLnByb3RvdHlwZT09PXQsYT1BcnJheShlKSxsPWU+MDsrK3I8ZTspYVtyXT1yK1wiXCI7Zm9yKHZhciBjIGluIHQpbCYmaShjLGUpfHxcImNvbnN0cnVjdG9yXCI9PWMmJihvfHwheS5jYWxsKHQsYykpfHxhLnB1c2goYyk7cmV0dXJuIGF9dmFyIGM9bigxOTgpLHA9bigxOTkpLGY9bigyMDApLGg9L15cXGQrJC8sZD1PYmplY3QucHJvdG90eXBlLHk9ZC5oYXNPd25Qcm9wZXJ0eSx2PWMoT2JqZWN0LFwia2V5c1wiKSxtPTkwMDcxOTkyNTQ3NDA5OTEsZz1yKFwibGVuZ3RoXCIpLHg9dj9mdW5jdGlvbih0KXt2YXIgZT1udWxsPT10P3ZvaWQgMDp0LmNvbnN0cnVjdG9yO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUucHJvdG90eXBlPT09dHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbyh0KT9hKHQpOnUodCk/dih0KTpbXX06YTt0LmV4cG9ydHM9eH0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50c3x8e30sdGhpcy5fbWF4TGlzdGVuZXJzPXRoaXMuX21heExpc3RlbmVyc3x8dm9pZCAwfWZ1bmN0aW9uIHIodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH1mdW5jdGlvbiBvKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGkodCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10fWZ1bmN0aW9uIHModCl7cmV0dXJuIHZvaWQgMD09PXR9dC5leHBvcnRzPW4sbi5FdmVudEVtaXR0ZXI9bixuLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxuLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMCxuLmRlZmF1bHRNYXhMaXN0ZW5lcnM9MTAsbi5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKHQpe2lmKCFvKHQpfHwwPnR8fGlzTmFOKHQpKXRocm93IFR5cGVFcnJvcihcIm4gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPXQsdGhpc30sbi5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXt2YXIgZSxuLG8sYSx1LGw7aWYodGhpcy5fZXZlbnRzfHwodGhpcy5fZXZlbnRzPXt9KSxcImVycm9yXCI9PT10JiYoIXRoaXMuX2V2ZW50cy5lcnJvcnx8aSh0aGlzLl9ldmVudHMuZXJyb3IpJiYhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpe2lmKGU9YXJndW1lbnRzWzFdLGUgaW5zdGFuY2VvZiBFcnJvcil0aHJvdyBlO3Rocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKX1pZihuPXRoaXMuX2V2ZW50c1t0XSxzKG4pKXJldHVybiExO2lmKHIobikpc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMTpuLmNhbGwodGhpcyk7YnJlYWs7Y2FzZSAyOm4uY2FsbCh0aGlzLGFyZ3VtZW50c1sxXSk7YnJlYWs7Y2FzZSAzOm4uY2FsbCh0aGlzLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2JyZWFrO2RlZmF1bHQ6YT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbi5hcHBseSh0aGlzLGEpfWVsc2UgaWYoaShuKSlmb3IoYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbD1uLnNsaWNlKCksbz1sLmxlbmd0aCx1PTA7bz51O3UrKylsW3VdLmFwcGx5KHRoaXMsYSk7cmV0dXJuITB9LG4ucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIG87aWYoIXIoZSkpdGhyb3cgVHlwZUVycm9yKFwibGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3JldHVybiB0aGlzLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9e30pLHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lciYmdGhpcy5lbWl0KFwibmV3TGlzdGVuZXJcIix0LHIoZS5saXN0ZW5lcik/ZS5saXN0ZW5lcjplKSx0aGlzLl9ldmVudHNbdF0/aSh0aGlzLl9ldmVudHNbdF0pP3RoaXMuX2V2ZW50c1t0XS5wdXNoKGUpOnRoaXMuX2V2ZW50c1t0XT1bdGhpcy5fZXZlbnRzW3RdLGVdOnRoaXMuX2V2ZW50c1t0XT1lLGkodGhpcy5fZXZlbnRzW3RdKSYmIXRoaXMuX2V2ZW50c1t0XS53YXJuZWQmJihvPXModGhpcy5fbWF4TGlzdGVuZXJzKT9uLmRlZmF1bHRNYXhMaXN0ZW5lcnM6dGhpcy5fbWF4TGlzdGVuZXJzLG8mJm8+MCYmdGhpcy5fZXZlbnRzW3RdLmxlbmd0aD5vJiYodGhpcy5fZXZlbnRzW3RdLndhcm5lZD0hMCxjb25zb2xlLmVycm9yKFwiKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC5cIix0aGlzLl9ldmVudHNbdF0ubGVuZ3RoKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBjb25zb2xlLnRyYWNlJiZjb25zb2xlLnRyYWNlKCkpKSx0aGlzfSxuLnByb3RvdHlwZS5vbj1uLnByb3RvdHlwZS5hZGRMaXN0ZW5lcixuLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMucmVtb3ZlTGlzdGVuZXIodCxuKSxvfHwobz0hMCxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9aWYoIXIoZSkpdGhyb3cgVHlwZUVycm9yKFwibGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3ZhciBvPSExO3JldHVybiBuLmxpc3RlbmVyPWUsdGhpcy5vbih0LG4pLHRoaXN9LG4ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIG4sbyxzLGE7aWYoIXIoZSkpdGhyb3cgVHlwZUVycm9yKFwibGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO2lmKCF0aGlzLl9ldmVudHN8fCF0aGlzLl9ldmVudHNbdF0pcmV0dXJuIHRoaXM7aWYobj10aGlzLl9ldmVudHNbdF0scz1uLmxlbmd0aCxvPS0xLG49PT1lfHxyKG4ubGlzdGVuZXIpJiZuLmxpc3RlbmVyPT09ZSlkZWxldGUgdGhpcy5fZXZlbnRzW3RdLHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lciYmdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIix0LGUpO2Vsc2UgaWYoaShuKSl7Zm9yKGE9czthLS0gPjA7KWlmKG5bYV09PT1lfHxuW2FdLmxpc3RlbmVyJiZuW2FdLmxpc3RlbmVyPT09ZSl7bz1hO2JyZWFrfWlmKDA+bylyZXR1cm4gdGhpczsxPT09bi5sZW5ndGg/KG4ubGVuZ3RoPTAsZGVsZXRlIHRoaXMuX2V2ZW50c1t0XSk6bi5zcGxpY2UobywxKSx0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxlKX1yZXR1cm4gdGhpc30sbi5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3ZhciBlLG47aWYoIXRoaXMuX2V2ZW50cylyZXR1cm4gdGhpcztpZighdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLl9ldmVudHM9e306dGhpcy5fZXZlbnRzW3RdJiZkZWxldGUgdGhpcy5fZXZlbnRzW3RdLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihlIGluIHRoaXMuX2V2ZW50cylcInJlbW92ZUxpc3RlbmVyXCIhPT1lJiZ0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhlKTtyZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZW1vdmVMaXN0ZW5lclwiKSx0aGlzLl9ldmVudHM9e30sdGhpc31pZihuPXRoaXMuX2V2ZW50c1t0XSxyKG4pKXRoaXMucmVtb3ZlTGlzdGVuZXIodCxuKTtlbHNlIGlmKG4pZm9yKDtuLmxlbmd0aDspdGhpcy5yZW1vdmVMaXN0ZW5lcih0LG5bbi5sZW5ndGgtMV0pO3JldHVybiBkZWxldGUgdGhpcy5fZXZlbnRzW3RdLHRoaXN9LG4ucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT10aGlzLl9ldmVudHMmJnRoaXMuX2V2ZW50c1t0XT9yKHRoaXMuX2V2ZW50c1t0XSk/W3RoaXMuX2V2ZW50c1t0XV06dGhpcy5fZXZlbnRzW3RdLnNsaWNlKCk6W119LG4ucHJvdG90eXBlLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5fZXZlbnRzKXt2YXIgZT10aGlzLl9ldmVudHNbdF07aWYocihlKSlyZXR1cm4gMTtpZihlKXJldHVybiBlLmxlbmd0aH1yZXR1cm4gMH0sbi5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQubGlzdGVuZXJDb3VudChlKX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oMTMpLGw9YSh1KSxjPW4oNykscD1hKGMpLGY9bigxOCksaD1hKGYpLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcIndpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQueEFjY2Vzc29yLG49dC55QWNjZXNzb3Iscj10LnhTY2FsZSxvPXQueVNjYWxlLGk9dC5pbnRlcnBvbGF0ZTt0aGlzLnByb3BzLnhheGlzJiZ0aGlzLnNldEF4aXMobmV3IGhbXCJkZWZhdWx0XCJdKHRoaXMucHJvcHMueGF4aXMsdGhpcy5wcm9wcy54U2NhbGUpKSx0aGlzLnByb3BzLnlheGlzJiZ0aGlzLnNldEF4aXMobmV3IGhbXCJkZWZhdWx0XCJdKHRoaXMucHJvcHMueWF4aXMsdGhpcy5wcm9wcy55U2NhbGUpKSx0aGlzLnBvaW50cz1bXSx0aGlzLmFyZWFHZW5lcmF0b3I9cFtcImRlZmF1bHRcIl0uc3ZnLmFyZWEoKS5pbnRlcnBvbGF0ZShpKS54KGZ1bmN0aW9uKHQpe3JldHVybiByKGUodCkpfSkueTAoZnVuY3Rpb24odCl7cmV0dXJuIG8oMCl9KS55MShmdW5jdGlvbih0KXtyZXR1cm4gbyhuKHQpKX0pfX0se2tleTpcIm9uTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcIm9uTW91bnRcIix0aGlzKS5jYWxsKHRoaXMpLHRoaXMuYmFzZUxheWVyPXRoaXMuYmFzZS5hcHBlbmQoXCJnXCIpLmNsYXNzZWQoXCJhcmVhLWxheWVyXCIsITApLHRoaXMuX3JlbmRlcigpfX0se2tleTpcImdldENsb3Nlc3REYXRhSW5kZXhcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdGhpcy5wb2ludHMubGVuZ3RoKXJldHVybiBudWxsO3ZhciBlPXRoaXMucHJvcHM7ZS5kYXRhLGUueEFjY2Vzc29yO3JldHVybiB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZD1NYXRoLmFicyhlLngtdCl9KSx0aGlzLnBvaW50cy5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHBbXCJkZWZhdWx0XCJdLmFzY2VuZGluZyh0LmQsZS5kKX0pLHRoaXMucG9pbnRzWzBdLml9fSx7a2V5Olwib25Nb3VzZU1vdmVIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmhvdmVyJiZ0aGlzLnRvb2x0aXApe3ZhciB0PXBbXCJkZWZhdWx0XCJdLm1vdXNlKHRoaXMuYmFzZUxheWVyLm5vZGUoKSksZT0odGhpcy5wcm9wcy54U2NhbGUuaW52ZXJ0KHRbMF0pLHRoaXMuZ2V0Q2xvc2VzdERhdGFJbmRleCh0WzBdKSk7dGhpcy50b29sdGlwLnNldFBvc2l0aW9uKHBbXCJkZWZhdWx0XCJdLmV2ZW50KSxudWxsIT09ZSYmdGhpcy50b29sdGlwLnNldENvbnRlbnQodGhpcy5wcm9wcy5kYXRhWzBdW2VdKX19fSx7a2V5OlwicHJlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5wcm9wcyxuPWUuZGF0YSxyPWUueFNjYWxlLG89ZS55U2NhbGUsaT1lLmludGVycG9sYXRlLHM9ZS54QWNjZXNzb3IsYT1lLnlBY2Nlc3NvcjtyLnJhbmdlKFswLHRoaXMud2lkdGhdKSxvLnJhbmdlKFt0aGlzLmhlaWdodCwwXSksXG50aGlzLnVwZGF0ZUF4aXMoMCxyLHRoaXMucHJvcHMueGF4aXMpLHRoaXMudXBkYXRlQXhpcygxLG8sdGhpcy5wcm9wcy55YXhpcyksdGhpcy5hcmVhR2VuZXJhdG9yLmludGVycG9sYXRlKGkpLngoZnVuY3Rpb24odCl7cmV0dXJuIHIocyh0KSl9KS55MChmdW5jdGlvbih0KXtyZXR1cm4gbygwKX0pLnkxKGZ1bmN0aW9uKHQpe3JldHVybiBvKGEodCkpfSksdGhpcy5wb2ludHM9W10sbi5sZW5ndGgmJm5bMF0uZm9yRWFjaChmdW5jdGlvbihlLG4pe3ZhciBvPXIocyhlKSk7dC5wb2ludHMucHVzaCh7eDpvLGk6bn0pfSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5wcm9wcyxuPWUuZGF0YSxyPShlLnhBY2Nlc3NvcixlLnlBY2Nlc3NvcixlLnhTY2FsZSxlLnlTY2FsZSxlLmZpbGxDb2xvciksbz1lLmZpbGxPcGFjaXR5LGk9dGhpcy5iYXNlTGF5ZXIuc2VsZWN0QWxsKFwicGF0aC5hcmVhXCIpLmRhdGEobik7aS5leGl0KCkucmVtb3ZlKCksaS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsXCJhcmVhXCIpLGkuYXR0cihcImRcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5hcmVhR2VuZXJhdG9yKGUpfSkuc3R5bGUoXCJmaWxsXCIscikuc3R5bGUoXCJvcGFjaXR5XCIsbyl9fSx7a2V5OlwicG9zdFJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy5pbnRlcmFjdGl2ZSYmdGhpcy5iYXNlTGF5ZXIuc2VsZWN0QWxsKFwicGF0aC5hcmVhXCIpLm9uKFwibW91c2VvdmVyXCIsdGhpcy5vbk92ZXIuYmluZCh0aGlzKSkub24oXCJtb3VzZW91dFwiLHRoaXMub25PdXQuYmluZCh0aGlzKSl9fSx7a2V5Olwib25PdmVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhvdmVyPSEwLHRoaXMudG9vbHRpcCYmdGhpcy50b29sdGlwLnNob3coKX19LHtrZXk6XCJvbk91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ob3Zlcj0hMSx0aGlzLnRvb2x0aXAmJnRoaXMudG9vbHRpcC5oaWRlKCl9fV0pLGV9KGxbXCJkZWZhdWx0XCJdKTtlW1wiZGVmYXVsdFwiXT1kLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiBuZXcgbyhmdW5jdGlvbihlLG4pe3ZhciBvPSgwLGFbXCJkZWZhdWx0XCJdKSgzKTt0LmZvckVhY2goZnVuY3Rpb24odCl7by5kZWZlcihyLHQpfSksby5hd2FpdEFsbChmdW5jdGlvbih0KXtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCxvPUFycmF5KHI+MT9yLTE6MCksaT0xO3I+aTtpKyspb1tpLTFdPWFyZ3VtZW50c1tpXTt0P24odCk6ZS5hcHBseSh2b2lkIDAsbyl9KX0pfWZ1bmN0aW9uIHIodCxuKXtpLnNxbFJlcXVlc3QodC5xdWVyeSxmdW5jdGlvbihlLHIpe2lmKGUpbihlKTtlbHNle3ZhciBvPXZvaWQgMDtzd2l0Y2godC5mb3JtYXQudG9Mb3dlckNhc2UoKSl7Y2FzZVwiZ2VvanNvblwiOm89ci5mZWF0dXJlczticmVhaztkZWZhdWx0Om89ci5yb3dzfW4obnVsbCxvKX19LHtmb3JtYXQ6dC5mb3JtYXQsZGFuZ2Vyb3VzbHlFeHBvc2VkQVBJS2V5OmV9KX12YXIgaT1uZXcgbFtcImRlZmF1bHRcIl0odCk7cmV0dXJue3F1ZXJ5Om59fXZhciBvPW4oMTA2KVtcImRlZmF1bHRcIl0saT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlW1wiZGVmYXVsdFwiXT1yO3ZhciBzPW4oMjAzKSxhPWkocyksdT1uKDIwMSksbD1pKHUpO3QuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPW4oNiksdT1uKDIxKSxsPW4oMjIpLGM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYocihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29tcG9uZW50V2lsbE1vdW50XCIsdGhpcykuY2FsbCh0aGlzKSwhY2FydG9kYil0aHJvdyBuZXcgRXJyb3IoJ0NhcnRvREJUaWxlTGF5ZXIgcmVxdWlyZXMgYGNhcnRvZGJgLiBgY2FydG9kYmAgaXMgbm90IGN1cnJlbnRseSBhdmFpbGFibGUgYXMgYW4gbnBtIHBhY2thZ2UgYW5kIHRoZXJlZm9yZSBtdXN0IGJlIGxvYWRlZCBhcyBhIGdsb2JhbCwgZS5nLiB2aWEgYSBDRE4gc2NyaXB0IGluIHlvdXIgaW5kZXguaHRtbCwgc3VjaCBhcyA8c2NyaXB0IHNyYz1cImh0dHA6Ly9saWJzLmNhcnRvY2RuLmNvbS9jYXJ0b2RiLmpzL3YzLzMuMTUvY2FydG9kYi5jb3JlLmpzXCI+Jyk7dGhpcy5sZWFmbGV0RWxlbWVudD0oMCx1LnRpbGVMYXllcikoXCJcIix0aGlzLnByb3BzKSx0aGlzLl9nZXRDYXJ0b0RCVGlsZXNUZW1wbGF0ZXMoZnVuY3Rpb24odCxlKXt0P2NvbnNvbGUuZXJyb3IodCk6dGhpcy5sZWFmbGV0RWxlbWVudC5zZXRVcmwoZS50aWxlc1swXSl9LmJpbmQodGhpcykpfX0se2tleTpcIl9nZXRDYXJ0b0RCVGlsZXNUZW1wbGF0ZXNcIix2YWx1ZTpmdW5jdGlvbih0KXtjYXJ0b2RiLlRpbGVzLmdldFRpbGVzKHt0eXBlOlwiY2FydG9kYlwiLHVzZXJfbmFtZTp0aGlzLnByb3BzLnVzZXJJZCxzdWJsYXllcnM6W3tzcWw6dGhpcy5wcm9wcy5zcWwsY2FydG9jc3M6dGhpcy5wcm9wcy5jYXJ0b2Nzc31dfSxmdW5jdGlvbihlLG4peyFlfHxuPyhufHwobj1cIkVtcHR5IHJlc3BvbnNlLlwiKSx0KG4sZSkpOnQobnVsbCxlKX0pfX1dLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e3VzZXJJZDphLlByb3BUeXBlcy5zdHJpbmcsc3FsOmEuUHJvcFR5cGVzLnN0cmluZyxjYXJ0b2NzczphLlByb3BUeXBlcy5zdHJpbmd9LGVudW1lcmFibGU6ITB9XSksZX0obC5CYXNlVGlsZUxheWVyKTtlW1wiZGVmYXVsdFwiXT1jLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9big2KSxsPWEodSksYz1uKDMwKSxwPWEoYyksZj1uKDcpLGg9YShmKTtuKDE0OSk7dmFyIGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCl9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOnt3aWR0aDp1LlByb3BUeXBlcy5udW1iZXIsaGVpZ2h0OnUuUHJvcFR5cGVzLm51bWJlcixzY2FsZTp1LlByb3BUeXBlcy5mdW5jLG9yaWVudDp1LlByb3BUeXBlcy5zdHJpbmcsbWFyZ2luOnUuUHJvcFR5cGVzLnNoYXBlKHt0b3A6dS5Qcm9wVHlwZXMubnVtYmVyLHJpZ2h0OnUuUHJvcFR5cGVzLm51bWJlcixib3R0b206dS5Qcm9wVHlwZXMubnVtYmVyLGxlZnQ6dS5Qcm9wVHlwZXMubnVtYmVyfSksY2hpbGRyZW46bFtcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm5vZGUsc2VsZWN0ZWRWYWx1ZTp1LlByb3BUeXBlcy5udW1iZXIsb25DbGlja09yTW92ZTp1LlByb3BUeXBlcy5mdW5jfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e3NjYWxlOmhbXCJkZWZhdWx0XCJdLnNjYWxlLmxpbmVhcigpLmNsYW1wKCEwKSxvcmllbnQ6XCJib3R0b21cIixtYXJnaW46e3RvcDoyMCxyaWdodDozMCxib3R0b206MjAsbGVmdDozMH0sb25DbGlja09yTW92ZTpudWxsfSxlbnVtZXJhYmxlOiEwfV0pLGkoZSxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt5LmNyZWF0ZSh0aGlzLnJlZnMuYXhpcyx0aGlzLnByb3BzLnNjYWxlLHRoaXMucHJvcHMub3JpZW50LHRoaXMucHJvcHMubWFyZ2luLHRoaXMucHJvcHMub25DbGlja09yTW92ZSk7dHJ5e3RoaXMuY29udGFpbmVyTm9kZT1wW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzKX1jYXRjaCh0KXt9dGhpcy5mb3JjZVVwZGF0ZSgpfX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7eS51cGRhdGUodGhpcy5yZWZzLmF4aXMsdGhpcy5wcm9wcy5zY2FsZSx0aGlzLnByb3BzLm9yaWVudCx0aGlzLnByb3BzLm1hcmdpbix0aGlzLnByb3BzLnNlbGVjdGVkVmFsdWUsdGhpcy5wcm9wcy5vbkNsaWNrT3JNb3ZlKTt0cnl7dGhpcy5jb250YWluZXJOb2RlPXBbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpfWNhdGNoKHQpe319fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3kuZGVzdHJveSh0aGlzLnJlZnMuYXhpcyl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD11LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pO3JldHVybiB0PjEmJmNvbnNvbGUud2FybihcIkNoYXJ0U2xpZGVyIGlzIGRlc2lnbmVkIHRvIHdyYXAgb25seSBvbmUgY2hpbGQgY29tcG9uZW50LCBidXQgaXQgZm91bmQgXCIrdCtcIiBjaGlsZHJlbi5cIiksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJwYW5vcmFtYSBjaGFydC1zbGlkZXJcIn0sbFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY2hpbGRyZW4se3dpZHRoOnRoaXMuY29udGFpbmVyTm9kZT90aGlzLmNvbnRhaW5lck5vZGUub2Zmc2V0V2lkdGg6dGhpcy5wcm9wcy53aWR0aCxoZWlnaHQ6dGhpcy5wcm9wcy5oZWlnaHR9KSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInRvcC1ydWxlXCIsc3R5bGU6e21hcmdpbkxlZnQ6dGhpcy5wcm9wcy5tYXJnaW4ubGVmdCtcInB4XCIsbWFyZ2luUmlnaHQ6dGhpcy5wcm9wcy5tYXJnaW4ucmlnaHQrXCJweFwiLHdpZHRoOlwiY2FsYygxMDAlIC0gXCIrKHRoaXMucHJvcHMubWFyZ2luLmxlZnQrdGhpcy5wcm9wcy5tYXJnaW4ucmlnaHQpK1wicHgpXCJ9fSksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJkMy1jaGFydC1zbGlkZXJcIixyZWY6XCJheGlzXCJ9KSl9fV0pLGV9KGxbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7ZVtcImRlZmF1bHRcIl09ZDt2YXIgeT17Y3JlYXRlOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy5vbkJydXNoTW92ZWQ9dGhpcy5vbkJydXNoTW92ZWQuYmluZCh0aGlzKSx0aGlzLm5vZGU9dDt2YXIgaT0xMzt0aGlzLmF4aXNQcmltYXJ5PWhbXCJkZWZhdWx0XCJdLnN2Zy5heGlzKCkub3JpZW50KG4pLnRpY2tzKDUpLnRpY2tGb3JtYXQoU3RyaW5nKS50aWNrU2l6ZShpKSx0aGlzLmF4aXNTZWNvbmRhcnk9aFtcImRlZmF1bHRcIl0uc3ZnLmF4aXMoKS5vcmllbnQobikudGlja3MoMTApLnRpY2tGb3JtYXQoZnVuY3Rpb24odCl7cmV0dXJuXCJcIn0pLnRpY2tTaXplKGktMyksdGhpcy5heGlzVGVydGlhcnk9aFtcImRlZmF1bHRcIl0uc3ZnLmF4aXMoKS5vcmllbnQobikudGlja3MoNDApLnRpY2tGb3JtYXQoZnVuY3Rpb24odCl7cmV0dXJuXCJcIn0pLnRpY2tTaXplKGktNiksdGhpcy5icnVzaD1oW1wiZGVmYXVsdFwiXS5zdmcuYnJ1c2goKS5vbihcImJydXNoXCIsdGhpcy5vbkJydXNoTW92ZWQpO3ZhciBzPWhbXCJkZWZhdWx0XCJdLnNlbGVjdCh0KS5hcHBlbmQoXCJzdmdcIik7cy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLFwiYXhpcyB0ZXJ0aWFyeVwiKSxzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJheGlzIHNlY29uZGFyeVwiKSxzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJheGlzIHByaW1hcnlcIiksdGhpcy5oYW5kbGU9cy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLFwiaGFuZGxlXCIpO3ZhciBhPXQub2Zmc2V0SGVpZ2h0LXIuYm90dG9tK2krMyx1PXRoaXMuaGFuZGxlLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJoYW5kbGUtZWxlbWVudHNcIik7dS5hcHBlbmQoXCJsaW5lXCIpLmF0dHIoe3gxOjAseDI6MCx5MTowLHkyOmF9KTt2YXIgbD0xMDt1LmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIixcIk0gMzAgMCBMIDcwIDAgQyA4NSAwIDkzLjI5MTc5NjA2NzUwMDYzIDEzLjQxNjQwNzg2NDk5ODczOSA4Ni41ODM1OTIxMzUwMDEyNSAyNi44MzI4MTU3Mjk5OTc0NzggTCA2My40MTY0MDc4NjQ5OTg3MyA3My4xNjcxODQyNzAwMDI1MiBDIDU2LjcwODIwMzkzMjQ5OTM2NiA4Ni41ODM1OTIxMzUwMDEyNSA0My4yOTE3OTYwNjc1MDA2MyA4Ni41ODM1OTIxMzUwMDEyNSAzNi41ODM1OTIxMzUwMDEyNiA3My4xNjcxODQyNzAwMDI1MiBMIDEzLjQxNjQwNzg2NDk5ODczOSAyNi44MzI4MTU3Mjk5OTc0NzggQyA2LjcwODIwMzkzMjQ5OTM2OSAxMy40MTY0MDc4NjQ5OTg3MzkgMTUgMCAzMCAwIFogXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInNjYWxlKFwiK2wvMTAwK1wiKSB0cmFuc2xhdGUoLTUwLCAwKVwiKSx1LmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIixcIk0gMzAgMCBMIDcwIDAgQyA4NSAwIDkzLjI5MTc5NjA2NzUwMDYzIDEzLjQxNjQwNzg2NDk5ODczOSA4Ni41ODM1OTIxMzUwMDEyNSAyNi44MzI4MTU3Mjk5OTc0NzggTCA2My40MTY0MDc4NjQ5OTg3MyA3My4xNjcxODQyNzAwMDI1MiBDIDU2LjcwODIwMzkzMjQ5OTM2NiA4Ni41ODM1OTIxMzUwMDEyNSA0My4yOTE3OTYwNjc1MDA2MyA4Ni41ODM1OTIxMzUwMDEyNSAzNi41ODM1OTIxMzUwMDEyNiA3My4xNjcxODQyNzAwMDI1MiBMIDEzLjQxNjQwNzg2NDk5ODczOSAyNi44MzI4MTU3Mjk5OTc0NzggQyA2LjcwODIwMzkzMjQ5OTM2OSAxMy40MTY0MDc4NjQ5OTg3MzkgMTUgMCAzMCAwIFogXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInJvdGF0ZSgxODApIHNjYWxlKFwiK2wvMTAwK1wiKSB0cmFuc2xhdGUoLTUwLCBcIistKDEwMC9sKmEpK1wiKVwiKSx0aGlzLnVwZGF0ZSh0LGUsbixyKX0sdXBkYXRlOmZ1bmN0aW9uKHQsZSxuLHIsbyxpKXt0aGlzLm5vZGU9dCx0aGlzLm9uQ2xpY2tPck1vdmU9aSxlLnJhbmdlKFswLHQub2Zmc2V0V2lkdGgtci5sZWZ0LXIucmlnaHRdKSx0aGlzLmF4aXNQcmltYXJ5LnNjYWxlKGUpLHRoaXMuYXhpc1NlY29uZGFyeS5zY2FsZShlKSx0aGlzLmF4aXNUZXJ0aWFyeS5zY2FsZShlKSx0aGlzLmJydXNoLngoZSk7dmFyIHM9XCJ0cmFuc2xhdGUoXCIrci5sZWZ0K1wiLCBcIisodC5vZmZzZXRIZWlnaHQtci5ib3R0b20pK1wiKVwiLGE9aFtcImRlZmF1bHRcIl0uc2VsZWN0KHQpLnNlbGVjdChcInN2Z1wiKTthLmF0dHIoXCJ3aWR0aFwiLFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsXCIxMDAlXCIpLGEuc2VsZWN0KFwiLmF4aXMucHJpbWFyeVwiKS5jYWxsKHRoaXMuYXhpc1ByaW1hcnkpLmF0dHIoXCJ0cmFuc2Zvcm1cIixzKS5zZWxlY3RBbGwoXCJ0ZXh0XCIpLmF0dHIoXCJ5XCIsTWF0aC5mbG9vcigyLzMqci5ib3R0b20pKSxhLnNlbGVjdChcIi5heGlzLnNlY29uZGFyeVwiKS5jYWxsKHRoaXMuYXhpc1NlY29uZGFyeSkuYXR0cihcInRyYW5zZm9ybVwiLHMpLGEuc2VsZWN0KFwiLmF4aXMudGVydGlhcnlcIikuY2FsbCh0aGlzLmF4aXNUZXJ0aWFyeSkuYXR0cihcInRyYW5zZm9ybVwiLHMpLHRoaXMuaGFuZGxlLmNhbGwodGhpcy5icnVzaCkuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKFwiK3IubGVmdCtcIiwgMClcIikuc2VsZWN0KFwiLmJhY2tncm91bmRcIikub24oXCJtb3VzZWRvd24uYnJ1c2hcIix0aGlzLm9uQnJ1c2hNb3ZlZCkub24oXCJ0b3VjaHN0YXJ0LmJydXNoXCIsdGhpcy5vbkJydXNoTW92ZWQpLHRoaXMuaGFuZGxlLnNlbGVjdEFsbChcIi5iYWNrZ3JvdW5kXCIpLmF0dHIoXCJoZWlnaHRcIixcIjEwMCVcIiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG8mJnRoaXMub25TZWxlY3RlZFZhbHVlQ2hhbmdlZChvKX0sZGVzdHJveTpmdW5jdGlvbih0KXtoW1wiZGVmYXVsdFwiXS5zZWxlY3QodCkuaHRtbChcIlwiKSx0aGlzLm5vZGU9bnVsbCx0aGlzLmF4aXNQcmltYXJ5PW51bGwsdGhpcy5heGlzU2Vjb25kYXJ5PW51bGwsdGhpcy5heGlzVGVydGlhcnk9bnVsbCx0aGlzLmJydXNoPW51bGwsdGhpcy5oYW5kbGU9bnVsbH0sb25CcnVzaE1vdmVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5icnVzaC54KCksZT10LmRvbWFpbigpLG49aFtcImRlZmF1bHRcIl0ubW91c2UoaFtcImRlZmF1bHRcIl0uc2VsZWN0KHRoaXMubm9kZSkuc2VsZWN0KFwiLmF4aXNcIilbMF1bMF0pWzBdLHI9dC5pbnZlcnQobik7cj1NYXRoLnJvdW5kKE1hdGgubWF4KGVbMF0sTWF0aC5taW4oZVsxXSxyKSkpLHRoaXMub25DbGlja09yTW92ZSYmdGhpcy5vbkNsaWNrT3JNb3ZlKHIpfSxvblNlbGVjdGVkVmFsdWVDaGFuZ2VkOmZ1bmN0aW9uKHQpe3RoaXMuaGFuZGxlLmNhbGwodGhpcy5icnVzaC5leHRlbnQoW3QsdCsyXSkpO3ZhciBlPXRoaXMuYnJ1c2gueCgpKHQpO3RoaXMuaGFuZGxlLnNlbGVjdChcIi5oYW5kbGUtZWxlbWVudHNcIikuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKFwiK2UrXCIsIDApXCIpfX07dC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigyMylbXCJkZWZhdWx0XCJdLG89bigxMDQpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1uKDcwKSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgZT1yKHt9LGgsdCk7Zm9yKHZhciBuIGluIGUpbnVsbD09ZVtuXT9kZWxldGUgZVtuXTpuPT09cCYmKGVbbl09bChlW3BdKSk7dmFyIGk9XCIjXCIrbyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQrXCI9XCIrZVt0XX0pLmpvaW4oXCImXCIpO2RvY3VtZW50LmxvY2F0aW9uLmhhc2ghPT1pJiZkb2N1bWVudC5sb2NhdGlvbi5yZXBsYWNlKGkpfWZ1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPD0wfHx2b2lkIDA9PT1hcmd1bWVudHNbMF0/bnVsbDphcmd1bWVudHNbMF07cmV0dXJuIHQ/aFt0XTpyKHt9LGgpfWZ1bmN0aW9uIG4odCxlKXtoPXQsZXx8Zi5lbWl0KGMscih7fSxoKSl9ZnVuY3Rpb24gcygpe24oYSh3aW5kb3cubG9jYXRpb24uaGFzaCkpfWZ1bmN0aW9uIGEodCl7dmFyIGU9dC5yZXBsYWNlKC9eI1xcLz98XFwvJC9nLFwiXCIpLnNwbGl0KFwiJlwiKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gZT1lLnNwbGl0KFwiPVwiKSxlWzBdPT09cCYmKGVbMV09dShlWzFdKSksdFtlWzBdXT1lWzFdLHR9LHt9KTtyZXR1cm4gZX1mdW5jdGlvbiB1KHQpe2lmKHQ9dC5zcGxpdChcIi9cIiksMz09dC5sZW5ndGgpe3ZhciBlPXBhcnNlSW50KHRbMF0sMTApLG49cGFyc2VGbG9hdCh0WzFdKSxyPXBhcnNlRmxvYXQodFsyXSk7cmV0dXJuIGlzTmFOKGUpfHxpc05hTihuKXx8aXNOYU4ocik/ITE6e2NlbnRlcjpbbixyXSx6b29tOmV9fXJldHVybiExfWZ1bmN0aW9uIGwodCl7dmFyIGU9dm9pZCAwLG49dm9pZCAwLHI9dC56b29tLG89TWF0aC5tYXgoMCxNYXRoLmNlaWwoTWF0aC5sb2cocikvTWF0aC5MTjIpKTtyZXR1cm4gQXJyYXkuaXNBcnJheSh0LmNlbnRlcik/KGU9dC5jZW50ZXJbMF0sbj10LmNlbnRlclsxXSk6KGU9dC5jZW50ZXIubGF0LG49dC5jZW50ZXIubG5nKSxbcixlLnRvRml4ZWQobyksbi50b0ZpeGVkKG8pXS5qb2luKFwiL1wiKX12YXIgYz1cImhhc2hDaGFuZ2VkXCIscD1cImxvY1wiLGY9e30saD17fTtyZXR1cm4gcihmLGkuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIscyksbihhKHdpbmRvdy5sb2NhdGlvbi5oYXNoKSwhMCksZi5FVkVOVF9IQVNIX0NIQU5HRUQ9YyxmLk1BUF9TVEFURV9LRVk9cCxmLnVwZGF0ZUhhc2g9dCxmLmdldFN0YXRlPWUsZn0oKTtlW1wiZGVmYXVsdFwiXT1zLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxMSlbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9big3KSxjPXUobCkscD1uKDQ2KSxmPXUocCksaD1uKDc3KSxkPXUoaCkseT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLmNoYXJ0Q29uc3RydWN0b3I9ZFtcImRlZmF1bHRcIl19cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOmEoe30sZltcImRlZmF1bHRcIl0ucHJvcFR5cGVzKSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse3hTY2FsZTpjW1wiZGVmYXVsdFwiXS5zY2FsZS5saW5lYXIoKSx5U2NhbGU6Y1tcImRlZmF1bHRcIl0uc2NhbGUub3JkaW5hbCgpfSksZW51bWVyYWJsZTohMH1dKSxlfShmW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09eSx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oNyksbD1hKHUpLGM9big0NykscD1hKGMpLGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQuZGF0YSxuPXQueEFjY2Vzc29yLHI9dC55QWNjZXNzb3Isbz10LnhTY2FsZSxpPXQueVNjYWxlO2kucmFuZ2VSb3VuZEJhbmRzKFswLHRoaXMuaGVpZ2h0XSx0aGlzLmJhclNwYWNpbmcpLGkuZG9tYWluKGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiByKHQpfSkpLG8ucmFuZ2UoWzAsdGhpcy53aWR0aF0pLG8uZG9tYWluKFswLGxbXCJkZWZhdWx0XCJdLm1heChlLGZ1bmN0aW9uKHQpe3JldHVybiBuKHQpfSldKSx0aGlzLnVwZGF0ZUF4aXMoMCxvLHRoaXMucHJvcHMueGF4aXMpLHRoaXMudXBkYXRlQXhpcygxLGksdGhpcy5wcm9wcy55YXhpcyl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC54QWNjZXNzb3Iscj10LnlBY2Nlc3NvcixvPXQueFNjYWxlLGk9dC55U2NhbGUscz10aGlzLmJhc2Uuc2VsZWN0QWxsKFwiLmJhclwiKS5kYXRhKGUpO3MuZXhpdCgpLnJlbW92ZSgpLHMuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLFwiYmFyXCIpLHMuYXR0cihcInhcIixcIjBcIikuYXR0cihcInlcIixmdW5jdGlvbih0KXtyZXR1cm4gaShyKHQpKX0pLmF0dHIoXCJ3aWR0aFwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKG4odCkpfSkuYXR0cihcImhlaWdodFwiLGkucmFuZ2VCYW5kKCkpfX1dKSxlfShwW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09Zix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMjMpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oMjAyKSxjPW4oNikscD11KGMpO24oMTUxKTt2YXIgZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLm9uSW50cm9FeGl0PXRoaXMub25JbnRyb0V4aXQuYmluZCh0aGlzKSx0aGlzLmluaXRJbnRybygpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7b3BlbjpjLlByb3BUeXBlcy5ib29sLHN0ZXA6Yy5Qcm9wVHlwZXMub25lT2ZUeXBlKFtjLlByb3BUeXBlcy5udW1iZXIsYy5Qcm9wVHlwZXMuc3RyaW5nXSksc3RlcHM6Yy5Qcm9wVHlwZXMuYXJyYXlPZihjLlByb3BUeXBlcy5zaGFwZSh7ZWxlbWVudDpjLlByb3BUeXBlcy5zdHJpbmcsaW50cm86Yy5Qcm9wVHlwZXMuc3RyaW5nLHBvc2l0aW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4vdG9wfHJpZ2h0fGJvdHRvbXxsZWZ0Ly50ZXN0KHRbZV0pP3ZvaWQgMDpuZXcgRXJyb3IoXCJgcG9zaXRpb25gIG11c3QgYmUgb25lIG9mICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgb3IgJ2xlZnQnLlwiKX19KSkuaXNSZXF1aXJlZCxjb25maWc6Yy5Qcm9wVHlwZXMub2JqZWN0LG9uRXhpdDpjLlByb3BUeXBlcy5mdW5jfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e29wZW46ITEsc3RlcDowLHN0ZXBzOltdLGNvbmZpZzp7c2hvd1N0ZXBOdW1iZXJzOiExLHNraXBMYWJlbDpcIsOXXCIsbmV4dExhYmVsOlwi4p+pXCIscHJldkxhYmVsOlwi4p+oXCIsZG9uZUxhYmVsOlwiw5dcIn0sb25FeGl0Om51bGx9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5OlwiaW5pdEludHJvXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmludHJvPSgwLGwuaW50cm9KcykoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJvZHlcIikpLHRoaXMuaW50cm8ub25leGl0KHRoaXMub25JbnRyb0V4aXQpLHRoaXMuaW50cm8ub25jb21wbGV0ZSh0aGlzLm9uSW50cm9FeGl0KSx0aGlzLmludHJvSXNPcGVuPSExfX0se2tleTpcIm9uSW50cm9FeGl0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmludHJvSXNPcGVuPSExLHRoaXMucHJvcHMub25FeGl0JiZ0aGlzLnByb3BzLm9uRXhpdCgpfX0se2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucHJvcHMub3Blbil7aWYodGhpcy5pbnRyb0lzT3BlbilyZXR1cm47aWYodGhpcy5pbnRyby5faW50cm9JdGVtcyl0aGlzLnByb3BzLnN0ZXAmJjEhPT10aGlzLnByb3BzLnN0ZXA/dGhpcy5pbnRyby5nb1RvU3RlcCh0aGlzLnByb3BzLnN0ZXAtMSkuc3RhcnQoKTp0aGlzLmludHJvLnN0YXJ0KCk7ZWxzZXt2YXIgdD17c3RlcHM6dGhpcy5wcm9wcy5zdGVwc307dD1hKHQsdGhpcy5wcm9wcy5jb25maWcpLHRoaXMuaW50cm8uc2V0T3B0aW9ucyh0KSx0aGlzLmludHJvLmdvVG9TdGVwKHRoaXMucHJvcHMuc3RlcCkuc3RhcnQoKX10aGlzLmludHJvSXNPcGVuPSEwfWVsc2UgdGhpcy5pbnRyby5leGl0KCl9fSx7a2V5OlwiZ2V0RGVmYXVsdFN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm57fX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBwW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbm9yYW1hIGludHJvLW1hbmFnZXJcIn0pfX1dKSxlfShwW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO2VbXCJkZWZhdWx0XCJdPWYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPW4oMzEpO24oMTUyKTt2YXIgcD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLm9uSXRlbUNsaWNrPXRoaXMub25JdGVtQ2xpY2suYmluZCh0aGlzKSx0aGlzLm9uQXJyb3dNb3VzZURvd249dGhpcy5vbkFycm93TW91c2VEb3duLmJpbmQodGhpcyksdGhpcy5vbkFycm93TW91c2VVcD10aGlzLm9uQXJyb3dNb3VzZVVwLmJpbmQodGhpcyksdGhpcy5hbmltYXRlU2Nyb2xsUG9zaXRpb249dGhpcy5hbmltYXRlU2Nyb2xsUG9zaXRpb24uYmluZCh0aGlzKX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e3RpdGxlOnUuUHJvcFR5cGVzLnN0cmluZyxpdGVtczp1LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLHNlbGVjdGVkSW5kZXg6dS5Qcm9wVHlwZXMub25lT2ZUeXBlKFt1LlByb3BUeXBlcy5zdHJpbmcsdS5Qcm9wVHlwZXMubnVtYmVyXSksc2VsZWN0ZWRJdGVtOnUuUHJvcFR5cGVzLm9iamVjdCxvbkl0ZW1TZWxlY3RlZDp1LlByb3BUeXBlcy5mdW5jfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e3RpdGxlOlwiXCIsaXRlbXM6W10sc2VsZWN0ZWRJbmRleDpcIlwiLHNlbGVjdGVkSXRlbTpudWxsLG9uSXRlbVNlbGVjdGVkOm51bGx9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2Nyb2xsVG9TZWxlY3RlZEl0ZW0oKX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY3JvbGxUb1NlbGVjdGVkSXRlbSgpfX0se2tleTpcIm9uSXRlbUNsaWNrXCIsdmFsdWU6ZnVuY3Rpb24odCl7dC5jdXJyZW50VGFyZ2V0JiZ0LmN1cnJlbnRUYXJnZXQuZGF0YXNldCYmKHRoaXMucHJvcHMub25JdGVtU2VsZWN0ZWQmJnRoaXMucHJvcHMub25JdGVtU2VsZWN0ZWQodGhpcy5wcm9wcy5pdGVtc1t0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pbmRleF0sdC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaW5kZXgpLGMuUGFub3JhbWFEaXNwYXRjaGVyLkl0ZW1TZWxlY3Rvci5zZWxlY3RlZCh0aGlzLnByb3BzLml0ZW1zW3QuY3VycmVudFRhcmdldC5kYXRhc2V0LmluZGV4XSx0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pbmRleCkpfX0se2tleTpcIm9uQXJyb3dNb3VzZURvd25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA7aWYodC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidXAtYXJyb3dcIik/ZT0tMTp0LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJkb3duLWFycm93XCIpJiYoZT0xKSxlKXt2YXIgbj10aGlzLnJlZnNbXCJpdGVtLWxpc3RcIl0scj0xNixvPTAsaT1uLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSxzPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGkpLGE9aS5vZmZzZXRIZWlnaHQrKHM/cGFyc2VGbG9hdChzW1wibWFyZ2luLWJvdHRvbVwiXS5yZXBsYWNlKFwicHhcIixcIlwiKSk6MCk7dGhpcy5hcnJvd01vdXNlVXA9ITE7dmFyIHU9ZnVuY3Rpb24oKXtvLS08PTEmJih0aGlzLnNjcm9sbFRvUG9zaXRpb24obi5zY3JvbGxUb3ArZSphKSxvPXI9TWF0aC5tYXgoMSxNYXRoLmZsb29yKC43NSpyKSkpLHRoaXMuYXJyb3dNb3VzZVVwfHx3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHUpfS5iaW5kKHRoaXMpO3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodSl9fX0se2tleTpcIm9uQXJyb3dNb3VzZVVwXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5hcnJvd01vdXNlVXA9ITB9fSx7a2V5Olwic2Nyb2xsVG9Qb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLnRhcmdldFNjcm9sbFBvc2l0aW9uPyh0aGlzLnRhcmdldFNjcm9sbFBvc2l0aW9uPXQsdGhpcy5hbmltYXRlU2Nyb2xsUG9zaXRpb24oKSk6dGhpcy50YXJnZXRTY3JvbGxQb3NpdGlvbj10fX0se2tleTpcInNjcm9sbFRvU2VsZWN0ZWRJdGVtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJlZnNbXCJpdGVtLWxpc3RcIl0sZT10LnF1ZXJ5U2VsZWN0b3IoXCIuc2VsZWN0ZWRcIik7ZSYmdGhpcy5zY3JvbGxUb1Bvc2l0aW9uKGUub2Zmc2V0VG9wLXQub2Zmc2V0SGVpZ2h0KX19LHtrZXk6XCJhbmltYXRlU2Nyb2xsUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucmVmc1tcIml0ZW0tbGlzdFwiXSxlPXZvaWQgMDtcInVuZGVmaW5lZFwiPT10eXBlb2YgdGhpcy5zY3JvbGxQb3NpdGlvbiYmKHRoaXMuc2Nyb2xsUG9zaXRpb249dC5zY3JvbGxUb3ApLGU9dGhpcy50YXJnZXRTY3JvbGxQb3NpdGlvbi10aGlzLnNjcm9sbFBvc2l0aW9uLE1hdGguYWJzKGUpPjE/KHRoaXMuc2Nyb2xsUG9zaXRpb24rPS4yNSplLHQuc2Nyb2xsVG9wPXRoaXMuc2Nyb2xsUG9zaXRpb24sd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGVTY3JvbGxQb3NpdGlvbikpOih0LnNjcm9sbFRvcD10aGlzLnRhcmdldFNjcm9sbFBvc2l0aW9uLHRoaXMudGFyZ2V0U2Nyb2xsUG9zaXRpb249dm9pZCAwLHRoaXMuc2Nyb2xsUG9zaXRpb249dm9pZCAwKX19LHtrZXk6XCJnZXREZWZhdWx0U3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybnt9fX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXZvaWQgMDtyZXR1cm4gbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJwYW5vcmFtYSBpdGVtLXNlbGVjdG9yXCJ9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJoM1wiLG51bGwsdGhpcy5wcm9wcy50aXRsZSksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJzY3JvbGwtYXJyb3cgdXAtYXJyb3dcIixvbk1vdXNlRG93bjp0aGlzLm9uQXJyb3dNb3VzZURvd24sb25Nb3VzZVVwOnRoaXMub25BcnJvd01vdXNlVXB9KSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidWxcIix7cmVmOlwiaXRlbS1saXN0XCJ9LHRoaXMucHJvcHMuaXRlbXMubWFwKGZ1bmN0aW9uKG4scil7cmV0dXJuIGU9dC5wcm9wcy5zZWxlY3RlZEl0ZW0uaWQ9PW4uaWR8fHQucHJvcHMuc2VsZWN0ZWRJdGVtPT09bnx8dC5wcm9wcy5zZWxlY3RlZEluZGV4PT09cixsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGlcIix7Y2xhc3NOYW1lOlwiaXRlbVwiKyhlP1wiIHNlbGVjdGVkXCI6XCJcIikrKG4uY2xhc3NOYW1lP1wiIFwiK24uY2xhc3NOYW1lOlwiXCIpLFwiZGF0YS1pbmRleFwiOnIsa2V5OnIsb25DbGljazp0Lm9uSXRlbUNsaWNrfSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLG51bGwsbi5uYW1lKSl9KSksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJzY3JvbGwtYXJyb3cgZG93bi1hcnJvd1wiLG9uTW91c2VEb3duOnRoaXMub25BcnJvd01vdXNlRG93bixvbk1vdXNlVXA6dGhpcy5vbkFycm93TW91c2VVcH0pKX19XSksZX0obFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtlW1wiZGVmYXVsdFwiXT1wLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigzMylbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9big2KSxjPSh1KGwpLG4oMjIpKSxwPW4oMjEpLGY9bigxODEpLGg9dShmKSxkPW4oMTcpLHk9KHUoZCksbigyOSkpLHY9KHUoeSksbig2NSkpLG09KHUodiksW1wic3Ryb2tlXCIsXCJjb2xvclwiLFwid2VpZ2h0XCIsXCJvcGFjaXR5XCIsXCJmaWxsXCIsXCJmaWxsQ29sb3JcIixcImZpbGxPcGFjaXR5XCIsXCJmaWxsUnVsZVwiLFwiZGFzaEFycmF5XCIsXCJsaW5lQ2FwXCIsXCJsaW5lSm9pblwiLFwiY2xpY2thYmxlXCIsXCJwb2ludGVyRXZlbnRzXCIsXCJjbGFzc05hbWVcIl0pO24oMTUzKTt2YXIgZz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzKSx0aGlzLm1vdXNlVGltZXI9bnVsbCx0aGlzLmN1cnJlbnRJZD1udWxsLHRoaXMuaGFzVG9vbHRpcD0hMSx0aGlzLnN0YXRlPXtzaG93VG9vbHRpcDohMSx0b29sdGlwUG9zaXRpb246bnVsbCx0b29sdGlwQ29udGVudDpcIlwifX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwiUHJvcFR5cGVzXCIsdmFsdWU6e3N0eWxlcjpsLlByb3BUeXBlcy5mdW5jLG9uRWFjaEZlYXR1cmU6bC5Qcm9wVHlwZXMuZnVuYyxzZXRUb29sdGlwQ29udGVudDpsLlByb3BUeXBlcy5mdW5jLHNlbGVjdGVkU3R5bGU6bC5Qcm9wVHlwZXMub2JqZWN0LG9uRmVhdHVyZUNsaWNrOmwuUHJvcFR5cGVzLmZ1bmN9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7c2VsZWN0ZWRTdHlsZTp7fX0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJzaG91bGRDb21wb25lbnRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4hMH19LHtrZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbXBvbmVudFdpbGxNb3VudFwiLHRoaXMpLmNhbGwodGhpcyk7dmFyIHQ9dGhpcy5wcm9wcy5kYXRhLG49dGhpcy5zZXRHZW9KU09OT3B0aW9ucygpO3RoaXMuc2V0VG9vbHRpcEZsYWcoKSx0aGlzLmxlYWZsZXRFbGVtZW50PSgwLHAuZ2VvSnNvbikodCxuKX19LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcy5tYXA7dGhpcy5sZWFmbGV0RWxlbWVudC5hZGRUbyh0KSx0aGlzLmhhc1Rvb2x0aXAmJnQub24oXCJtb3VzZW1vdmVcIix0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9wcy5kYXRhO3QuZGF0YSE9PWUmJnRoaXMubGVhZmxldEVsZW1lbnQuYWRkRGF0YShlKX19LHtrZXk6XCJzZXRHZW9KU09OT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9YSh0aGlzLnByb3BzLFtdKTtyZXR1cm57c3R5bGU6dC5zdHlsZXx8bnVsbCxvbkVhY2hGZWF0dXJlOnQub25FYWNoRmVhdHVyZXx8dGhpcy5vbkVhY2hGZWF0dXJlLmJpbmQodGhpcyksZmlsdGVyOnQuZmlsdGVyfHxudWxsLHBvaW50VG9MYXllcjp0LnBvaW50VG9MYXllcnx8bnVsbCxjb29yZHNUb0xhdExuZzp0LmNvb3Jkc1RvTGF0TG5nfHxudWxsfX19LHtrZXk6XCJzZXRUb29sdGlwRmxhZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMucHJvcHMuY2hpbGRyZW47bC5DaGlsZHJlbi5mb3JFYWNoKGUsZnVuY3Rpb24oZSl7ZS50eXBlJiZlLnR5cGUubmFtZSYmXCJUb29sdGlwXCI9PT1lLnR5cGUubmFtZSYmKHQuaGFzVG9vbHRpcD0hMCl9KX19LHtrZXk6XCJnZXRQYXRoT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybigwLGhbXCJkZWZhdWx0XCJdKSh0LG0pfX0se2tleTpcImdldFRvb2x0aXBDb250ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5wcm9wcy5zZXRUb29sdGlwQ29udGVudD90aGlzLnByb3BzLnNldFRvb2x0aXBDb250ZW50KHQpOlwiXCJ9fSx7a2V5Olwib25Nb3VzZU92ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0aGlzLmN1cnJlbnRJZCE9PXQudGFyZ2V0KXtpZih0LnRhcmdldC5zZXRTdHlsZSh0aGlzLnByb3BzLnNlbGVjdGVkU3R5bGUpLHRoaXMuY3VycmVudElkIT09dC50YXJnZXQpe3RoaXMuY3VycmVudElkPXQudGFyZ2V0O3ZhciBlPXRoaXMuZ2V0VG9vbHRpcENvbnRlbnQodC50YXJnZXQuZmVhdHVyZSk7dGhpcy5zZXRTdGF0ZSh7c2hvd1Rvb2x0aXA6ITAsdG9vbHRpcFBvc2l0aW9uOnQubGF0bG5nLHRvb2x0aXBDb250ZW50OmV9KX1MLkJyb3dzZXIuaWV8fEwuQnJvd3Nlci5vcGVyYXx8dC50YXJnZXQuYnJpbmdUb0Zyb250KCl9fX0se2tleTpcIm9uTW91c2VPdXRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMubGVhZmxldEVsZW1lbnQucmVzZXRTdHlsZSh0LnRhcmdldCksdGhpcy5jdXJyZW50SWQ9bnVsbCxjbGVhclRpbWVvdXQodGhpcy5tb3VzZVRpbWVyKSx0aGlzLm1vdXNlVGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe251bGw9PT1lLmN1cnJlbnRJZCYmKGUuY3VycmVudElkPW51bGwsZS5zZXRTdGF0ZSh7c2hvd1Rvb2x0aXA6ITF9KSl9LDIwMCl9fSx7a2V5Olwib25Nb3VzZU1vdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmN1cnJlbnRJZCYmKHAuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKHQpLHRoaXMuc2V0U3RhdGUoe3Rvb2x0aXBQb3NpdGlvbjp0LmxhdGxuZ30pKX19LHtrZXk6XCJvbkNsaWNrXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5wcm9wcy5vbkZlYXR1cmVDbGljayYmdGhpcy5wcm9wcy5vbkZlYXR1cmVDbGljayh0LnRhcmdldCx0aGlzLnByb3BzLm1hcCl9fSx7a2V5Olwib25FYWNoRmVhdHVyZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5oYXNUb29sdGlwJiZlLm9uKHttb3VzZW92ZXI6dGhpcy5vbk1vdXNlT3Zlci5iaW5kKHRoaXMpLG1vdXNlb3V0OnRoaXMub25Nb3VzZU91dC5iaW5kKHRoaXMpfSksZS5vbihcImNsaWNrXCIsdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVuZGVyQ2hpbGRyZW5XaXRoUHJvcHMoe3Rvb2x0aXBDb250YWluZXI6dGhpcy5sZWFmbGV0RWxlbWVudCxwb3B1cENvbnRhaW5lcjp0aGlzLmxlYWZsZXRFbGVtZW50LHBvc2l0aW9uOnRoaXMuc3RhdGUudG9vbHRpcFBvc2l0aW9uLGlzT3Blbjp0aGlzLnN0YXRlLnNob3dUb29sdGlwLGNvbnRlbnQ6dGhpcy5zdGF0ZS50b29sdGlwQ29udGVudH0pfX1dKSxlfShjLk1hcExheWVyKTtlW1wiZGVmYXVsdFwiXT1nLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigzMylbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9big2KSxjPSh1KGwpLG4oMjIpKSxwPShuKDIxKSxuKDgyKSksZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzKX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e2NlbnRlcjpjLlByb3BUeXBlcy5sYXRsbmcuaXNSZXF1aXJlZCxvdXRlclJhZGl1czpsLlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxpbm5lclJhZGl1czpsLlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZH0sZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOnt9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLG49dC5jZW50ZXIsbz10Lm91dGVyUmFkaXVzLGk9dC5pbm5lclJhZGl1cyxzPWEodCxbXCJjZW50ZXJcIixcIm91dGVyUmFkaXVzXCIsXCJpbm5lclJhZGl1c1wiXSk7cihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29tcG9uZW50V2lsbE1vdW50XCIsdGhpcykuY2FsbCh0aGlzKSx0aGlzLmxlYWZsZXRFbGVtZW50PW5ldyBwLkxlYWZsZXREb251dChuLG8saSx0aGlzLmdldFBhdGhPcHRpb25zKHMpKX19LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnByb3BzLmNlbnRlciE9PXQuY2VudGVyJiZ0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZyh0aGlzLnByb3BzLmNlbnRlciksKHRoaXMucHJvcHMub3V0ZXJSYWRpdXMhPT10Lm91dGVyUmFkaXVzfHx0aGlzLnByb3BzLmlubmVyUmFkaXVzIT09dC5pbm5lclJhZGl1cykmJnRoaXMubGVhZmxldEVsZW1lbnQuc2V0UmFkaXVzKHRoaXMucHJvcHMub3V0ZXJSYWRpdXMsdGhpcy5wcm9wcy5pbm5lclJhZGl1cyksdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZCh0LHRoaXMucHJvcHMpfX1dKSxlfShjLlBhdGgpO2VbXCJkZWZhdWx0XCJdPWYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89big0OClbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oMjEpLHM9byhpKSxhPWZ1bmN0aW9uKHQpe3JldHVybiB0LkNpcmNsZS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24oZSxuLHIsbyl7dC5QYXRoLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyxvKSx0aGlzLl9sYXRsbmc9dC5sYXRMbmcoZSksdGhpcy5fbU91dGVyUmFkaXVzPW4sdGhpcy5fbUlubmVyUmFkaXVzPXRoaXMuX3ZhbGlkYXRlSW5uZXJSYWRpdXMobixyKX0sc2V0UmFkaXVzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX21PdXRlclJhZGl1cz10LHRoaXMuX21Jbm5lclJhZGl1cz10aGlzLl92YWxpZGF0ZUlubmVyUmFkaXVzKHQsZSksdGhpcy5yZWRyYXcoKX0scHJvamVjdExhdGxuZ3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9nZXRMbmdSYWRpdXMoKSxlPXRoaXMuX2xhdGxuZyxuPXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoW2UubGF0LGUubG5nLXRbMF1dKSxyPXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoW2UubGF0LGUubG5nLXRbMV1dKTt0aGlzLl9wb2ludD10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGUpLHRoaXMuX291dGVyUmFkaXVzPU1hdGgubWF4KHRoaXMuX3BvaW50Lngtbi54LDEpLHRoaXMuX2lubmVyUmFkaXVzPU1hdGgubWF4KHRoaXMuX3BvaW50Lngtci54LDEpfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9nZXRMbmdSYWRpdXMoKVswXSxuPXRoaXMuX2dldExhdFJhZGl1cygpWzBdLHI9dGhpcy5fbGF0bG5nO3JldHVybiBuZXcgdC5MYXRMbmdCb3VuZHMoW3IubGF0LW4sci5sbmctZV0sW3IubGF0K24sci5sbmcrZV0pfSxnZXRSYWRpdXM6ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5fbU91dGVyUmFkaXVzLHRoaXMuX21Jbm5lclJhZGl1c119LF9nZXRMYXRSYWRpdXM6ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5fbU91dGVyUmFkaXVzLzQwMDc1MDE3KjM2MCx0aGlzLl9tSW5uZXJSYWRpdXMvNDAwNzUwMTcqMzYwXX0sX2dldExuZ1JhZGl1czpmdW5jdGlvbigpe3ZhciBlPXRoaXMuX2dldExhdFJhZGl1cygpO3JldHVybltlWzBdL01hdGguY29zKHQuTGF0TG5nLkRFR19UT19SQUQqdGhpcy5fbGF0bG5nLmxhdCksZVsxXS9NYXRoLmNvcyh0LkxhdExuZy5ERUdfVE9fUkFEKnRoaXMuX2xhdGxuZy5sYXQpXX0sX2NoZWNrSWZFbXB0eTpmdW5jdGlvbigpe2lmKCF0aGlzLl9tYXApcmV0dXJuITE7dmFyIHQ9dGhpcy5fbWFwLl9wYXRoVmlld3BvcnQsZT10aGlzLl9vdXRlclJhZGl1cyxuPXRoaXMuX3BvaW50O3JldHVybiBuLngtZT50Lm1heC54fHxuLnktZT50Lm1heC55fHxuLngrZTx0Lm1pbi54fHxuLnkrZTx0Lm1pbi55fSxfdmFsaWRhdGVJbm5lclJhZGl1czpmdW5jdGlvbih0LGUpe3JldHVybiBlPj10P3QtMTplfSxnZXRBcmM6ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQueC0uMDEsbz10LnktZSxpPXQueS1uO3JldHVybltcIk1cIix0LngsbyxcIkFcIixlLGUsMCwxLDEscixvLFwiTVwiLHIsaSxcIkFcIixuLG4sMCwxLDAsdC54LGksXCJaXCJdLmpvaW4oXCIgXCIpfSxnZXRQYXRoU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fcG9pbnQsbj10aGlzLl9vdXRlclJhZGl1cyxvPXRoaXMuX2lubmVyUmFkaXVzO3JldHVybiB0aGlzLl9jaGVja0lmRW1wdHkoKT9cIlwiOnQuQnJvd3Nlci5zdmc/dGhpcy5nZXRBcmMoZSxuLG8pOihlLl9yb3VuZCgpLHI9TWF0aC5yb3VuZChyKSxcIkFMIFwiK2UueCtcIixcIitlLnkrXCIgXCIrbitcIixcIituK1wiIDAsMjM1OTI2MDBcIil9fSl9KHMpO2UuTGVhZmxldERvbnV0PWF9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMzMpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oNiksYz1uKDIyKSxwPW4oMjEpLGY9big2NSksaD11KGYpLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29tcG9uZW50V2lsbE1vdW50XCIsdGhpcykuY2FsbCh0aGlzKTt2YXIgdD10aGlzLnByb3BzLG49KHQuY2hpbGRyZW4sdC5tYXAsYSh0LFtcImNoaWxkcmVuXCIsXCJtYXBcIl0pKSxvPSgwLGhbXCJkZWZhdWx0XCJdKSh7fSxuKTtvLmNsYXNzTmFtZT1vLmNsYXNzTmFtZT9vLmNsYXNzTmFtZStcIiBwYW5vcmFtYS1sZWFmbGV0LXRpcFwiOlwicGFub3JhbWEtbGVhZmxldC10aXBcIixvLmNsb3NlQnV0dG9uPSExLG8ub2Zmc2V0PW8ub2Zmc2V0fHxbMCwtM10sdGhpcy5sZWFmbGV0RWxlbWVudD0oMCxwLnBvcHVwKShvKX19LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJvcHMsbj1lLm1hcCxyPWUucG9zaXRpb24sbz1lLmlzT3BlbixpPWUuY29udGVudDtyIT09dC5wb3NpdGlvbiYmdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmcociksaSE9PXQuY29udGVudCYmdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRDb250ZW50KGkpLG8hPT10LmlzT3BlbiYmKG8/KHRoaXMubGVhZmxldEVsZW1lbnQub3Blbk9uKG4pLHRoaXMucmVuZGVyUG9wdXBDb250ZW50KCkpOihuLmNsb3NlUG9wdXAoKSx0aGlzLnJlbW92ZVBvcHVwQ29udGVudCgpKSl9fV0sW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7Y2hpbGRyZW46bC5Qcm9wVHlwZXMubm9kZSxtYXA6bC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihwLk1hcCksdG9vbHRpcENvbnRhaW5lcjpsLlByb3BUeXBlcy5vYmplY3QscG9zaXRpb246Yy5Qcm9wVHlwZXMubGF0bG5nfSxlbnVtZXJhYmxlOiEwfV0pLGV9KGMuUG9wdXApO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPW4oMzEpO24oMTU0KTt2YXIgcD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLm9uSXRlbUNsaWNrPXRoaXMub25JdGVtQ2xpY2suYmluZCh0aGlzKSx0aGlzLm9uSXRlbUVudGVyPXRoaXMub25JdGVtRW50ZXIuYmluZCh0aGlzKSx0aGlzLm9uSXRlbUxlYXZlPXRoaXMub25JdGVtTGVhdmUuYmluZCh0aGlzKX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e2l0ZW1zOnUuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsc2VsZWN0ZWRJdGVtOnUuUHJvcFR5cGVzLnN0cmluZyxvbkl0ZW1TZWxlY3RlZDp1LlByb3BUeXBlcy5mdW5jfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e2l0ZW1zOltdLHNlbGVjdGVkSXRlbTpcIlwiLG9uSXRlbVNlbGVjdGVkOm51bGx9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcIm9uSXRlbUNsaWNrXCIsdmFsdWU6ZnVuY3Rpb24odCl7dC5jdXJyZW50VGFyZ2V0JiZ0LmN1cnJlbnRUYXJnZXQuZGF0YXNldCYmKHRoaXMucHJvcHMub25JdGVtU2VsZWN0ZWQmJnRoaXMucHJvcHMub25JdGVtU2VsZWN0ZWQodC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaXRlbSx0aGlzLnByb3BzLml0ZW1zLmluZGV4T2YodC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaXRlbSkpLGMuUGFub3JhbWFEaXNwYXRjaGVyLkxlZ2VuZC5zZWxlY3RlZCh0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pdGVtLHRoaXMucHJvcHMuaXRlbXMuaW5kZXhPZih0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pdGVtKSkpfX0se2tleTpcIm9uSXRlbUVudGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dC5jdXJyZW50VGFyZ2V0JiZ0LmN1cnJlbnRUYXJnZXQuZGF0YXNldCYmdGhpcy5wcm9wcy5vbkl0ZW1FbnRlciYmdGhpcy5wcm9wcy5vbkl0ZW1FbnRlcih0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pdGVtLHRoaXMucHJvcHMuaXRlbXMuaW5kZXhPZih0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pdGVtKSl9fSx7a2V5Olwib25JdGVtTGVhdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt0LmN1cnJlbnRUYXJnZXQmJnQuY3VycmVudFRhcmdldC5kYXRhc2V0JiZ0aGlzLnByb3BzLm9uSXRlbUxlYXZlJiZ0aGlzLnByb3BzLm9uSXRlbUxlYXZlKHQuY3VycmVudFRhcmdldC5kYXRhc2V0Lml0ZW0sdGhpcy5wcm9wcy5pdGVtcy5pbmRleE9mKHQuY3VycmVudFRhcmdldC5kYXRhc2V0Lml0ZW0pKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicGFub3JhbWEgbGVnZW5kIFwiK3RoaXMucHJvcHMuY2xhc3NOYW1lfSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidWxcIixudWxsLHRoaXMucHJvcHMuaXRlbXMubWFwKGZ1bmN0aW9uKGUsbil7dmFyIHI9dC5wcm9wcy5zZWxlY3RlZEl0ZW09PT1lfHx0LnByb3BzLnNlbGVjdGVkSXRlbT09bjtyZXR1cm4gbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIse2NsYXNzTmFtZTpcIml0ZW1cIisocj9cIiBzZWxlY3RlZFwiOlwiXCIpLFwiZGF0YS1pdGVtXCI6ZSxrZXk6ZSxvbkNsaWNrOnQub25JdGVtQ2xpY2ssb25Nb3VzZUVudGVyOnQub25JdGVtRW50ZXIsb25Nb3VzZUxlYXZlOnQub25JdGVtTGVhdmV9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCx0LmNhcGl0YWxpemUoZSkpKX0pKSl9fSx7a2V5OlwiY2FwaXRhbGl6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9fV0pLGV9KGxbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7ZVtcImRlZmF1bHRcIl09cCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMTEpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oNyksYz0odShsKSxuKDYpKSxwPW4oMTQpLGY9dShwKSxoPW4oODYpLGQ9dShoKTtuKDE1NSk7dmFyIHk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5jaGFydENvbnN0cnVjdG9yPWRbXCJkZWZhdWx0XCJdfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTphKHt9LGZbXCJkZWZhdWx0XCJdLnByb3BUeXBlcyx7c3Ryb2tlQ29sb3I6Yy5Qcm9wVHlwZXMub25lT2ZUeXBlKFtjLlByb3BUeXBlcy5zdHJpbmcsYy5Qcm9wVHlwZXMubnVtYmVyXSksc3Ryb2tlT3BhY2l0eTpjLlByb3BUeXBlcy5udW1iZXIsaXNJbnRlcnBvbGF0ZWQ6Yy5Qcm9wVHlwZXMuYm9vbCxpbnRlcnBvbGF0ZTpjLlByb3BUeXBlcy5zdHJpbmd9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse2NsYXNzTmFtZTpcImxpbmUtY2hhcnRcIixpc0ludGVycG9sYXRlZDohMSxpbnRlcnBvbGF0ZTpcImJhc2lzXCIseGF4aXM6e2NsYXNzTmFtZTpcInggYXhpc1wiLG9yaWVudDpcImJvdHRvbVwiLHBvc2l0aW9uOlwiYm90dG9tXCIsYXR0cjp7ZHg6XCIwXCIsZHk6XCIwLjVlbVwifSxzdHlsZTp7XCJ0ZXh0LWFuY2hvclwiOlwibWlkZGxlXCJ9fSx5YXhpczp7Y2xhc3NOYW1lOlwieSBheGlzXCIsb3JpZW50OlwibGVmdFwifX0pLGVudW1lcmFibGU6ITB9XSksZX0oZltcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXksdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDEzKSxsPWEodSksYz1uKDcpLHA9YShjKSxmPW4oMTgpLGg9YShmKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oZSx0KSxpKGUsW3trZXk6XCJ3aWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMueGF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy54YXhpcyx0aGlzLnByb3BzLnhTY2FsZSkpLHRoaXMucHJvcHMueWF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy55YXhpcyx0aGlzLnByb3BzLnlTY2FsZSkpLHRoaXMubGluZUdlbmVyYXRvcj1wW1wiZGVmYXVsdFwiXS5zdmcubGluZSgpfX0se2tleTpcIm9uTW91bnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJvbk1vdW50XCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMubGluZUxheWVyPXRoaXMuYmFzZS5hcHBlbmQoXCJnXCIpLmNsYXNzZWQoXCJsaW5lLWxheWVyXCIsITApLHRoaXMuX3JlbmRlcigpfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPSh0LmRhdGEsdC54QWNjZXNzb3IpLG49dC55QWNjZXNzb3Iscj10LnhTY2FsZSxvPXQueVNjYWxlLGk9dC5pc0ludGVycG9sYXRlZCxzPXQuaW50ZXJwb2xhdGU7ci5yYW5nZShbMCx0aGlzLndpZHRoXSksby5yYW5nZShbdGhpcy5oZWlnaHQsMF0pLHRoaXMudXBkYXRlQXhpcygwLHIsdGhpcy5wcm9wcy54YXhpcyksdGhpcy51cGRhdGVBeGlzKDEsbyx0aGlzLnByb3BzLnlheGlzKTt2YXIgYT1pP3M6XCJsaW5lYXJcIjt0aGlzLmxpbmVHZW5lcmF0b3IuaW50ZXJwb2xhdGUoYSkueChmdW5jdGlvbih0KXtyZXR1cm4gcihlKHQpKX0pLnkoZnVuY3Rpb24odCl7cmV0dXJuIG8obih0KSl9KX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5kYXRhLHI9KGUueEFjY2Vzc29yLGUueUFjY2Vzc29yLGUueFNjYWxlLGUueVNjYWxlLGUuc3Ryb2tlQ29sb3IpLG89ZS5zdHJva2VPcGFjaXR5LGk9dGhpcy5saW5lTGF5ZXIuc2VsZWN0QWxsKFwicGF0aC5saW5lXCIpLmRhdGEobik7aS5leGl0KCkucmVtb3ZlKCksaS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsXCJsaW5lXCIpLGkuYXR0cihcImRcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5saW5lR2VuZXJhdG9yKGUpfSkuc3R5bGUoe3N0cm9rZTpyLHN0cm9rZU9wYWNpdHk6b30pfX0se2tleTpcInBvc3RSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319XSksZX0obFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDcpLGM9KHUobCksbig2KSkscD1uKDE0KSxmPXUocCksaD1uKDg4KSxkPXUoaCk7bigxNTYpO3ZhciB5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj1kW1wiZGVmYXVsdFwiXX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMse3Byb2plY3Rpb246Yy5Qcm9wVHlwZXMuc3RyaW5nLG1hcFNjYWxlOmMuUHJvcFR5cGVzLm9uZU9mVHlwZShbYy5Qcm9wVHlwZXMubnVtYmVyLGMuUHJvcFR5cGVzLnN0cmluZ10pLHNlbGVjdGVkOmMuUHJvcFR5cGVzLmFueSxzZWxlY3RlZEFjY2Vzc29yOmMuUHJvcFR5cGVzLmZ1bmMsaG92ZXJTdHlsZTpjLlByb3BUeXBlcy5vYmplY3R9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse3Byb2plY3Rpb246XCJhbGJlcnNVc2FcIixjbGFzc05hbWU6XCJtYXAgY2hvcm9wbGV0aFwiLG1hcFNjYWxlOjUwMH0pLGVudW1lcmFibGU6ITB9XSksZX0oZltcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXksdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEwNylbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9bigxMyksYz11KGwpLHA9big3KSxmPXUocCksaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5Olwid2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcIm9uTW91bnRcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5fcGF0aD1mW1wiZGVmYXVsdFwiXS5nZW8ucGF0aCgpLHRoaXMuX3Byb2plY3Rpb249ZltcImRlZmF1bHRcIl0uZ2VvW3RoaXMucHJvcHMucHJvamVjdGlvbl0oKSx0aGlzLl9yZW5kZXIoKSx0aGlzLl9zZWxlY3RlZD1udWxsLHRoaXMuX2hvdmVyRWxlbWVudD1udWxsfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy51cGRhdGVQcm9qZWN0aW9uKCk7XG59fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC5zdHlsZXIscj10LmludGVyYWN0aXZlLG89dC5zZWxlY3RlZCxpPXQuc2VsZWN0ZWRBY2Nlc3NvcjtpZihlJiZlLmZlYXR1cmVzKXt2YXIgcz10aGlzLGE9dGhpcy5iYXNlLnNlbGVjdEFsbChcInBhdGhcIikuZGF0YShlLmZlYXR1cmVzKTthLmV4aXQoKS5yZW1vdmUoKSxhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIixcImdlb21ldHJ5XCIpLmF0dHIoXCJkXCIsdGhpcy5fcGF0aCksYS5lYWNoKGZ1bmN0aW9uKHQpe2ZbXCJkZWZhdWx0XCJdLnNlbGVjdCh0aGlzKS5zdHlsZShuKHQpKX0pLHImJihmW1wiZGVmYXVsdFwiXS5zZWxlY3RBbGwoXCIuaG92ZXItZHVwZVwiKS5yZW1vdmUoKSx0aGlzLl9ob3ZlckVsZW1lbnQ9bnVsbCxhLm9uKFwiY2xpY2tcIixudWxsKS5vbihcIm1vdXNlb3ZlclwiLG51bGwpLm9uKFwibW91c2VvdXRcIixudWxsKS5vbihcImNsaWNrXCIsdGhpcy5kaXNwYXRjaC5jbGljaykub24oXCJtb3VzZWVudGVyXCIsZnVuY3Rpb24odCl7aSh0KSE9PW8mJihzLl9ob3ZlckVsZW1lbnQ9cy5icmluZ1RvVG9wKHRoaXMsXCJob3Zlci1kdXBlIHNlbC1cIitpKHQpLHMucHJvcHMuaG92ZXJTdHlsZXx8bnVsbCkscy5kaXNwYXRjaC5tb3VzZU92ZXIodCkpfSkub24oXCJtb3VzZWxlYXZlXCIsZnVuY3Rpb24odCl7cy5faG92ZXJFbGVtZW50JiZzLl9ob3ZlckVsZW1lbnQucmVtb3ZlKCkscy5faG92ZXJFbGVtZW50PW51bGwscy5kaXNwYXRjaC5tb3VzZU91dCh0KX0pKSxvJiZvIT09dGhpcy5fc2VsZWN0ZWQmJih0aGlzLl9zZWxlY3RlZD1vLGZbXCJkZWZhdWx0XCJdLnNlbGVjdEFsbChcIi5zZWxlY3RlZC1kdXBlXCIpLnJlbW92ZSgpLGEuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBpKHQpPT09b30pLmVhY2goZnVuY3Rpb24oKXtzLmJyaW5nVG9Ub3AodGhpcyxcInNlbGVjdGVkLWR1cGVcIil9KSl9fX0se2tleTpcInBvc3RSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJicmluZ1RvVG9wXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWZbXCJkZWZhdWx0XCJdLnNlbGVjdCh0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodC5jbG9uZU5vZGUoITApLHQubmV4dFNpYmxpbmcpKS5jbGFzc2VkKGUsITApO3JldHVybiBuJiZyLnN0eWxlKG4pLHJ9fSx7a2V5OlwidXBkYXRlUHJvamVjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQuZGF0YSxuPXQubWFwU2NhbGUscj10LnByb2plY3Rpb24sbz1uLGk9W3RoaXMud2lkdGgvMix0aGlzLmhlaWdodC8yXTtpZihcImF1dG9cIj09PW4pe3ZhciBzPXRoaXMuZml0TWFwKGUpLHU9YShzLDIpO289dVswXSxpPXVbMV19dGhpcy5fcHJvamVjdGlvbj1mW1wiZGVmYXVsdFwiXS5nZW9bcl0oKS5zY2FsZShvKS50cmFuc2xhdGUoaSksdGhpcy5fcGF0aC5wcm9qZWN0aW9uKHRoaXMuX3Byb2plY3Rpb24pfX0se2tleTpcImZpdE1hcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJvcHMucHJvamVjdGlvbixuPWZbXCJkZWZhdWx0XCJdLmdlb1tlXSgpLnNjYWxlKDEpLnRyYW5zbGF0ZShbMCwwXSkscj1mW1wiZGVmYXVsdFwiXS5nZW8ucGF0aCgpLnByb2plY3Rpb24obiksbz1yLmJvdW5kcyh0KSxpPS45NS9NYXRoLm1heCgob1sxXVswXS1vWzBdWzBdKS90aGlzLndpZHRoLChvWzFdWzFdLW9bMF1bMV0pL3RoaXMuaGVpZ2h0KSxzPVsodGhpcy53aWR0aC1pKihvWzFdWzBdK29bMF1bMF0pKS8yLCh0aGlzLmhlaWdodC1pKihvWzFdWzFdK29bMF1bMV0pKS8yXTtyZXR1cm5baSxzXX19XSksZX0oY1tcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPWgsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPW4oMTg4KSxwPWEoYyk7bigxNTcpO3ZhciBmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7bmF2X2RhdGE6dS5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxzaG93X21lbnU6dS5Qcm9wVHlwZXMuYm9vbCxvbl9oYW1idXJnZXJfY2xpY2s6dS5Qcm9wVHlwZXMuZnVuYyxzdHlsZTp1LlByb3BUeXBlcy5vYmplY3QsdGl0bGU6dS5Qcm9wVHlwZXMuc3RyaW5nLGhvbWVfdXJsOnUuUHJvcFR5cGVzLnN0cmluZyxsaW5rczp1LlByb3BUeXBlcy5hcnJheSxsaW5rX3NlcGFyYXRvcjp1LlByb3BUeXBlcy5zdHJpbmd9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7dGl0bGU6XCJBbWVyaWNhbiBQYW5vcmFtYVwiLGhvbWVfdXJsOlwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWFcIixsaW5rczpbXSxsaW5rX3NlcGFyYXRvcjpcIiBcIixuYXZfZGF0YTp7fSxzaG93X21lbnU6ITEsb25faGFtYnVyZ2VyX2NsaWNrOm51bGwsc3R5bGU6e292ZXJsYXk6e3Bvc2l0aW9uOlwiZml4ZWRcIix0b3A6MCxsZWZ0OjAsYmFja2dyb3VuZENvbG9yOlwicmdiYSgwLDAsMCwwLjUpXCJ9LGNvbnRlbnQ6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6MCxsZWZ0OjAsYm90dG9tOlwiYXV0b1wiLHJpZ2h0OlwiYXV0b1wiLGJvcmRlcjowLGJhY2tncm91bmQ6XCJyZ2JhKDAsMCwwLDAuNSlcIixvdmVyZmxvdzpcImF1dG9cIixXZWJraXRPdmVyZmxvd1Njcm9sbGluZzpcInRvdWNoXCIsYm9yZGVyUmFkaXVzOlwiNHB4XCIsb3V0bGluZTpcIm5vbmVcIixwYWRkaW5nOjB9fX0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcHV0ZURpbWVuc2lvbnNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybih3aW5kb3cuaW5uZXJXaWR0aC00MCp0aGlzLnByb3BzLm5hdl9kYXRhLmxlbmd0aCkvdGhpcy5wcm9wcy5uYXZfZGF0YS5sZW5ndGh9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsbnVsbCxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2lkOlwiaGFtYnVyZ2VyXCJ9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOlwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvc3RhdGljL2ltYWdlcy9tZW51LnN2Z1wiLG9uQ2xpY2s6dGhpcy5wcm9wcy5vbl9oYW1idXJnZXJfY2xpY2t9KSksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChwW1wiZGVmYXVsdFwiXSx7aXNPcGVuOnRoaXMucHJvcHMuc2hvd19tZW51LG9uUmVxdWVzdENsb3NlOnRoaXMucHJvcHMub25faGFtYnVyZ2VyX2NsaWNrLGNsYXNzTmFtZTpcIm5hdl9oZWFkZXJcIixzdHlsZTp0aGlzLnByb3BzLnN0eWxlfSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2lkOlwibmF2X2hlYWRlclwifSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2lkOlwibmF2YnVyZ2VyXCJ9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOlwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvc3RhdGljL2ltYWdlcy9tZW51LWNsb3NlLnN2Z1wiLG9uQ2xpY2s6dGhpcy5wcm9wcy5vbl9oYW1idXJnZXJfY2xpY2t9KSksdGhpcy5wcm9wcy50aXRsZSYmdGhpcy5wcm9wcy5ob21lX3VybD9sW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiaDFcIixudWxsLGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJhXCIse2hyZWY6dGhpcy5wcm9wcy5ob21lX3VybH0sdGhpcy5wcm9wcy50aXRsZSkpOlwiXCIsbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImgyXCIsbnVsbCx0aGlzLnByb3BzLmxpbmtzLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYVwiLHtocmVmOmUudXJsLGtleTpcInBhbl9uYXZfbGlua3NfXCIrbn0sbjx0LnByb3BzLmxpbmtzLmxlbmd0aC0xP2UubmFtZSt0LnByb3BzLmxpbmtfc2VwYXJhdG9yOmUubmFtZSl9KSksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtpZDpcIm1hcHNcIn0sdGhpcy5wcm9wcy5uYXZfZGF0YS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJwYW5fbmF2X2l0ZW1cIixrZXk6XCJwYW5fbmF2X2l0ZW1fXCIrbixzdHlsZTp7d2lkdGg6dC5jb21wdXRlRGltZW5zaW9ucygpK1wicHhcIn19LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJhXCIse2hyZWY6ZS51cmx9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOmUuc2NyZWVuc2hvdCxzdHlsZTp7d2lkdGg6dC5jb21wdXRlRGltZW5zaW9ucygpK1wicHhcIn19KSksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJyXCIsbnVsbCksbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImg0XCIsbnVsbCxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYVwiLHtocmVmOmUudXJsfSxlLnRpdGxlKSkpfSkpKSkpfX1dKSxlfShsW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO2VbXCJkZWZhdWx0XCJdPWYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDYpLGM9KHUobCksbig3KSkscD0odShjKSxuKDE0KSksZj11KHApLGg9big0NSksZD0odShoKSxuKDkxKSkseT11KGQpO24oMTU4KTt2YXIgdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLmNoYXJ0Q29uc3RydWN0b3I9eVtcImRlZmF1bHRcIl0sdGhpcy5jaGFydElkQWNjZXNzb3I9dC5jaGFydElkQWNjZXNzb3J9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOmEoe30sZltcImRlZmF1bHRcIl0ucHJvcFR5cGVzLHthcmVhQ2hhcnREYXRhOmwuUHJvcFR5cGVzLmFycmF5LGNoYXJ0U3BhY2luZzpsLlByb3BUeXBlcy5udW1iZXIsY29sb3JQYWxldHRlOmwuUHJvcFR5cGVzLmFycmF5LHNlbGVjdGVkQ2hhcnRJZDpsLlByb3BUeXBlcy5vbmVPZlR5cGUoW2wuUHJvcFR5cGVzLnN0cmluZyxsLlByb3BUeXBlcy5udW1iZXJdKSxjaGFydElkQWNjZXNzb3I6bC5Qcm9wVHlwZXMuZnVuYyxtZXRhZGF0YUFjY2Vzc29yOmwuUHJvcFR5cGVzLmZ1bmMsaW50ZXJwb2xhdGU6bC5Qcm9wVHlwZXMuc3RyaW5nLGNpcmNsZVJhZGl1czpsLlByb3BUeXBlcy5udW1iZXJ9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse2NsYXNzTmFtZTpcIm9mZnNldC1hcmVhLWNoYXJ0XCIsYXJlYUNoYXJ0RGF0YTpbXSxjaGFydFNwYWNpbmc6NCxjb2xvclBhbGV0dGU6bnVsbCxzZWxlY3RlZENoYXJ0SWQ6bnVsbCxjaGFydElkQWNjZXNzb3I6bnVsbCxtZXRhZGF0YUFjY2Vzc29yOm51bGwsaW50ZXJwb2xhdGU6XCJiYXNpc1wiLGNpcmNsZVJhZGl1czoyfSksZW51bWVyYWJsZTohMH1dKSxlfShmW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09dix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oMTMpLGw9YSh1KSxjPW4oNykscD1hKGMpLGY9bigxOCksaD0oYShmKSxmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5Olwid2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC54QWNjZXNzb3Isbj10LnlBY2Nlc3NvcixyPXQueFNjYWxlLG89dC55U2NhbGUsaT10LmludGVycG9sYXRlO3RoaXMuYXJlYUdlbmVyYXRvcj1wW1wiZGVmYXVsdFwiXS5zdmcuYXJlYSgpLmludGVycG9sYXRlKGkpLngoZnVuY3Rpb24odCl7cmV0dXJuIHIoZSh0KSl9KS55MChmdW5jdGlvbih0KXtyZXR1cm4gbygwKX0pLnkxKGZ1bmN0aW9uKHQpe3JldHVybiBvKG4odCkpfSl9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwib25Nb3VudFwiLHRoaXMpLmNhbGwodGhpcyksdGhpcy5saW5lTGF5ZXI9dGhpcy5iYXNlLmFwcGVuZChcImdcIikuY2xhc3NlZChcIm9mZnNldC1hcmVhLWxpbmVzXCIsITApLHRoaXMuX3JlbmRlcigpfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQueFNjYWxlLG49dC55U2NhbGUscj0odC54QWNjZXNzb3IsdC55QWNjZXNzb3IsdC5hcmVhQ2hhcnRDb25maWcpLG89dC5pbnRlcnBvbGF0ZSxpPXRoaXMuaGVpZ2h0LXRoaXMucHJvcHMuYXJlYUNoYXJ0RGF0YS5sZW5ndGgqdGhpcy5wcm9wcy5jaGFydFNwYWNpbmc7ZS5yYW5nZShbMCx0aGlzLndpZHRoXSksbi5yYW5nZShbaSwwXSksdGhpcy5hcmVhR2VuZXJhdG9yPXBbXCJkZWZhdWx0XCJdLnN2Zy5hcmVhKCkuaW50ZXJwb2xhdGUobykueChmdW5jdGlvbih0KXtyZXR1cm4gZShyLnhBY2Nlc3Nvcih0KSl9KS55MChmdW5jdGlvbih0KXtyZXR1cm4gbigwKX0pLnkxKGZ1bmN0aW9uKHQpe3JldHVybiBuKHIueUFjY2Vzc29yKHQpKX0pfX0se2tleTpcImFyZWFPZmZzZXRUcmFuc2xhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJvcHMuY2hhcnRTcGFjaW5nO3JldHVyblwidHJhbnNsYXRlKDAsXCIrZSp0K1wiKVwifX0se2tleTpcImxpbmVPZmZzZXRUcmFuc2xhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJvcHMsbj1lLmRhdGEscj1lLmNoYXJ0U3BhY2luZyxvPWUueVNjYWxlLGk9KG8oMCksbi5sZW5ndGgtdCkscz0tcippO3JldHVyblwidHJhbnNsYXRlKDAsXCIrcytcIilcIn19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5kYXRhLHI9ZS54QWNjZXNzb3Isbz0oZS55QWNjZXNzb3IsZS54U2NhbGUpLGk9ZS55U2NhbGUscz0oZS5maWxsQ29sb3IsZS5maWxsT3BhY2l0eSxlLmFyZWFDaGFydERhdGEpLGE9ZS5jb2xvclBhbGV0dGUsdT1lLm1ldGFkYXRhQWNjZXNzb3IsbD1lLmNoYXJ0SWRBY2Nlc3NvcixjPWUuc2VsZWN0ZWRDaGFydElkLHA9ZS5jaXJjbGVSYWRpdXMsZj0oZS5pbnRlcmFjdGl2ZSx0aGlzLmJhc2Uuc2VsZWN0QWxsKFwiZy5hcmVhLWNvbnRhaW5lclwiKS5kYXRhKHMpKTtmLmV4aXQoKS5yZW1vdmUoKSxmLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcImFyZWEtY29udGFpbmVyXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsXCJhcmVhXCIpLGYuYXR0cihcInRyYW5zZm9ybVwiLGZ1bmN0aW9uKGUsbil7cmV0dXJuIHQuYXJlYU9mZnNldFRyYW5zbGF0aW9uKG4pfSkuY2xhc3NlZChcInNlbGVjdGVkXCIsZnVuY3Rpb24odCl7cmV0dXJuIGwodCk9PT1jPyEwOiExfSkuc2VsZWN0QWxsKFwicGF0aFwiKS5hdHRyKFwiZFwiLGZ1bmN0aW9uKGUpe3JldHVybiB0LmFyZWFHZW5lcmF0b3IoZSl9KS5hdHRyKFwiZmlsbFwiLGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gYVtuJWEubGVuZ3RoXX0pO3ZhciBoPWkoMCkrdGhpcy5wcm9wcy5hcmVhQ2hhcnREYXRhLmxlbmd0aCp0aGlzLnByb3BzLmNoYXJ0U3BhY2luZyxkPW8uZG9tYWluKCk7dGhpcy5saW5lTGF5ZXIuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKDAsIFwiK2grXCIpXCIpO3ZhciB5PXRoaXMubGluZUxheWVyLnNlbGVjdEFsbChcImcubGluZS1ncm91cFwiKS5kYXRhKG4pO3kuZXhpdCgpLnJlbW92ZSgpLHkuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLFwibGluZS1ncm91cFwiKS5hcHBlbmQoXCJsaW5lXCIpLmF0dHIoXCJjbGFzc1wiLFwibGlmZXNwYW5cIikseS5hdHRyKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5saW5lT2Zmc2V0VHJhbnNsYXRpb24obil9KS5jbGFzc2VkKFwic2VsZWN0ZWRcIixmdW5jdGlvbih0KXtyZXR1cm4gbCh0KT09Yz8hMDohMX0pLnNlbGVjdEFsbChcImxpbmVcIikuYXR0cihcIngxXCIsZnVuY3Rpb24odCl7cmV0dXJuIG8oTWF0aC5tYXgocih0LDApLGRbMF0pKX0pLmF0dHIoXCJ4MlwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKE1hdGgubWluKHIodCwxKSxkWzFdKSl9KS5hdHRyKFwieTFcIiwwKS5hdHRyKFwieTJcIiwwKS5zdHlsZShcInN0cm9rZVwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFbZSVhLmxlbmd0aF19KTt2YXIgdj15LnNlbGVjdEFsbChcImNpcmNsZVwiKS5kYXRhKGZ1bmN0aW9uKHQpe3JldHVybiB1KHQpfSk7di5leGl0KCkucmVtb3ZlKCksdi5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKSx2LmF0dHIoXCJjeFwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKE1hdGgubWF4KHQsZFswXSkpfSkuYXR0cihcImN5XCIsMCkuYXR0cihcInJcIixwKS5zdHlsZShcImZpbGxcIixmdW5jdGlvbih0LGUsbil7cmV0dXJuIGFbbiVhLmxlbmd0aF19KX19LHtrZXk6XCJwb3N0UmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fV0pLGV9KGxbXCJkZWZhdWx0XCJdKSk7ZVtcImRlZmF1bHRcIl09aCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMTEpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdLGw9big0OClbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBjPW4oNikscD11KGMpLGY9big3KSxoPWwoZik7bigxNTkpO3ZhciBkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7ZGF0YTpjLlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLG9uSXRlbUNsaWNrOmMuUHJvcFR5cGVzLmZ1bmMsbG9hZGluZzpjLlByb3BUeXBlcy5ib29sLG5vRGF0YUF2YWlsYWJsZU1zZzpjLlByb3BUeXBlcy5zdHJpbmcscHVuY2hjYXJkT3B0aW9uczpjLlByb3BUeXBlcy5vYmplY3Qsc2VsZWN0QWNjZXNzb3I6Yy5Qcm9wVHlwZXMuZnVuYyx0ZXh0VmFsdWVGb3JtYXR0ZXI6Yy5Qcm9wVHlwZXMuZnVuYyxoZWFkZXJNYXJnaW46Yy5Qcm9wVHlwZXMubnVtYmVyfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e2RhdGE6W10sb25JdGVtQ2xpY2s6bnVsbCxsb2FkaW5nOiEwLG5vRGF0YUF2YWlsYWJsZU1zZzpcIk5vIGNvbW1vZGl0aWVzIGRhdGEgYXZhaWxhYmxlIGZvciB0aGlzIGNhbmFsIGluIHRoZSBzZWxlY3RlZCB5ZWFyLlwiLHJhZGl1c0V4dGVudDpbMiwxMF0sdGV4dFZhbHVlRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxoZWFkZXJNYXJnaW46MH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZW5kZXJWaXN1YWxpemF0aW9uKCl9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt5LmRlc3Ryb3kodGhpcy5yZWZzLmNvbnRlbnQpLHRoaXMucmVuZGVyVmlzdWFsaXphdGlvbigpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt5LmRlc3Ryb3kodGhpcy5yZWZzLmNvbnRlbnQpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHBbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicGFub3JhbWEgcHVuY2hjYXJkXCJ9LHRoaXMucmVuZGVyUGxhY2Vob2xkZXIoKSxwW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcImNvbnRlbnRcIixyZWY6XCJjb250ZW50XCIsc3R5bGU6e21hcmdpblRvcDp0aGlzLnByb3BzLmhlYWRlck1hcmdpbitcInB4XCJ9fSkpfX0se2tleTpcInJlbmRlclZpc3VhbGl6YXRpb25cIix2YWx1ZTpmdW5jdGlvbigpeyF0aGlzLmlzRW1wdHkodGhpcy5wcm9wcy5kYXRhKSYmdGhpcy5yZWZzLmNvbnRlbnQmJnkudXBkYXRlKHRoaXMucmVmcy5jb250ZW50LGEoe30sdGhpcy5wcm9wcykpfX0se2tleTpcInJlbmRlclBsYWNlaG9sZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5sb2FkaW5nLG49dC5ub0RhdGFBdmFpbGFibGVNc2c7cmV0dXJuIGU/cFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJwbGFjZWhvbGRlclwiLHJlZjpcInBsYWNlaG9sZGVyXCJ9LHBbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJoNFwiLG51bGwsXCJMb2FkaW5nLi4uXCIpKTohdGhpcy5wcm9wcy5sb2FkaW5nJiZ0aGlzLmlzRW1wdHkodGhpcy5wcm9wcy5kYXRhKT9wW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBsYWNlaG9sZGVyXCIscmVmOlwicGxhY2Vob2xkZXJcIn0scFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImg0XCIsbnVsbCxuKSk6bnVsbH19LHtrZXk6XCJpc0VtcHR5XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPDF9fV0pLGV9KHBbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7ZVtcImRlZmF1bHRcIl09ZDt2YXIgeT17X3NldFRleHRWYWx1ZUZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdH0sc2V0VGV4dFZhbHVlRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3RoaXMuX3NldFRleHRWYWx1ZUZvcm1hdHRlcj10fSxST1dfSEVJR0hUOjI1LENPTU1PRElUWV9URVhUX09GRlNFVF9ZOjUsdXBkYXRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxyPWUuY29sb3JTY2FsZSxvPWUudmFsdWVBY2Nlc3NvcixpPWUub25JdGVtQ2xpY2sscz1lLnRleHRWYWx1ZUZvcm1hdHRlcixhPWUuc2VsZWN0ZWQsdT1lLnNlbGVjdEFjY2Vzc29yO1wiZnVuY3Rpb25cIj09dHlwZW9mIHMmJnRoaXMuc2V0VGV4dFZhbHVlRm9ybWF0dGVyKHMpO3ZhciBsPWUucmFkaXVzRXh0ZW50WzFdLGM9dGhpcyxwPWguc2NhbGUuc3FydCgpLnJhbmdlKGUucmFkaXVzRXh0ZW50KS5kb21haW4oWzEsZS5yYWRpdXNNYXhWYWx1ZV0pLGY9cC5kb21haW4oKSxkPWZbMF0rTWF0aC5zcXJ0KC4yNSkqKGZbMV0tZlswXSkseT1oLnNlbGVjdCh0KS5zZWxlY3RBbGwoXCJkaXZcIikuZGF0YShlLmRhdGEpLmVudGVyKCkuYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJzdHlsZVwiLGZ1bmN0aW9uKHQpe3JldHVyblwiY29sb3I6IFwiK3IoZS5jb2xvckFjY2Vzc29yKHQpKStcIjtcIn0pLmF0dHIoXCJjbGFzc1wiLFwiY2F0ZWdvcnlcIik7eS5hcHBlbmQoXCJoNFwiKS50ZXh0KGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSx5PXkuYXBwZW5kKFwic3ZnXCIpLmF0dHIoXCJoZWlnaHRcIixmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21tb2RpdGllcy5sZW5ndGgqYy5ST1dfSEVJR0hUfSkuc3R5bGUoXCJzdHJva2VcIixmdW5jdGlvbih0KXtyZXR1cm4gcihlLmNvbG9yQWNjZXNzb3IodCkpfSkuc3R5bGUoXCJmaWxsXCIsZnVuY3Rpb24odCl7cmV0dXJuIHIoZS5jb2xvckFjY2Vzc29yKHQpKX0pLHRoaXMuY2F0ZWdvcnlOb2RlV2lkdGg9KHkubm9kZSgpLm9mZnNldFdpZHRofHx5Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCktMi41KnRoaXMuUk9XX0hFSUdIVDt2YXIgdj15LnNlbGVjdEFsbChcImdcIikuZGF0YShmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21tb2RpdGllc30pLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTt2LmNsYXNzZWQoXCJzZWxlY3RlZFwiLGZ1bmN0aW9uKHQpe3JldHVybiB1KHQpPT09YX0pLHYuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyXCIsZnVuY3Rpb24odCl7dmFyIGU9byh0KTtyZXR1cm4gZT9wKGUpOmR9KS5zdHlsZShcImZpbGxcIixmdW5jdGlvbih0KXtyZXR1cm4gbyh0KT9udWxsOlwibm9uZVwifSkuc3R5bGUoXCJzdHJva2VcIixmdW5jdGlvbih0KXtyZXR1cm4gbyh0KT9cIm5vbmVcIjpudWxsfSkuc3R5bGUoXCJzdHJva2Utd2lkdGhcIixmdW5jdGlvbih0KXtyZXR1cm4gbyh0KT9udWxsOjJ9KSx2LmFwcGVuZChcInRleHRcIikudGV4dChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkuc3R5bGUoXCJzdHJva2VcIixcIm5vbmVcIikuYXR0cihcInhcIiwyKmMuUk9XX0hFSUdIVCkuYXR0cihcInlcIixjLkNPTU1PRElUWV9URVhUX09GRlNFVF9ZKS5jYWxsKHRoaXMud3JhcCx0aGlzLmNhdGVnb3J5Tm9kZVdpZHRoKTt2YXIgbT12b2lkIDA7eS5lYWNoKGZ1bmN0aW9uKHQsZSl7aC5zZWxlY3QodGhpcykuc2VsZWN0QWxsKFwiZ1wiKS5lYWNoKGZ1bmN0aW9uKHQsZSl7ZXx8KG09MCk7dmFyIG49aC5zZWxlY3QodGhpcyk7bi5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrLjUqYy5ST1dfSEVJR0hUK1wiLCBcIisoZSsuNSttKSpjLlJPV19IRUlHSFQrXCIpXCIpLG0rPW4uc2VsZWN0QWxsKFwidHNwYW5cIikuc2l6ZSgpLTF9KTt2YXIgbj1oLnNlbGVjdCh0aGlzKTtuLmF0dHIoXCJoZWlnaHRcIixwYXJzZUZsb2F0KG4uYXR0cihcImhlaWdodFwiKSkrbSpjLlJPV19IRUlHSFQpfSksdi5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsLWwpLmF0dHIoXCJ5XCIsLWwpLmF0dHIoXCJ3aWR0aFwiLHRoaXMuY2F0ZWdvcnlOb2RlV2lkdGgrMi41KnRoaXMuUk9XX0hFSUdIVCkuYXR0cihcImhlaWdodFwiLHRoaXMuUk9XX0hFSUdIVCkub24oXCJtb3VzZW92ZXJcIixmdW5jdGlvbih0LGUpe2Mub25JdGVtTW91c2VPdmVyKHRoaXMsdCxlKX0pLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbih0LGUpe2Mub25JdGVtTW91c2VPdXQodGhpcyx0LGUpfSkub24oXCJjbGlja1wiLGZ1bmN0aW9uKHQsZSl7XCJmdW5jdGlvblwiPT10eXBlb2YgaSYmaS5jYWxsKG4sdCxlKX0pfSxvbkl0ZW1Nb3VzZU92ZXI6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWguc2VsZWN0KHQucGFyZW50Tm9kZSk7ci5zZWxlY3QoXCJ0ZXh0XCIpLnRleHQoKGUucHJldHR5VmFsdWV8fHRoaXMuX3NldFRleHRWYWx1ZUZvcm1hdHRlcihlLnZhbHVlKSkrKGUudW5pdHM/XCIgXCIrZS51bml0czpcIlwiKSkuc3R5bGUoXCJmb250LXdlaWdodFwiLDQwMCl9LG9uSXRlbU1vdXNlT3V0OmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1oLnNlbGVjdCh0LnBhcmVudE5vZGUpO3Iuc2VsZWN0KFwidGV4dFwiKS50ZXh0KGUubmFtZSkuc3R5bGUoXCJmb250LXdlaWdodFwiLG51bGwpLmNhbGwodGhpcy53cmFwLHRoaXMuY2F0ZWdvcnlOb2RlV2lkdGgpfSxkZXN0cm95OmZ1bmN0aW9uKHQpe2guc2VsZWN0KHQpLmh0bWwoXCJcIil9LHdyYXA6ZnVuY3Rpb24odCxlKXt0LmVhY2goZnVuY3Rpb24oKXt2YXIgdD1bXCIvXCIsXCImXCJdLG49aC5zZWxlY3QodGhpcykscj1uLnRleHQoKSxvPXZvaWQgMDt0LmZvckVhY2goZnVuY3Rpb24odCl7cj1yLnJlcGxhY2UodCx0K1wiIFwiKX0pO2Zvcih2YXIgaT1yLnNwbGl0KC9cXHMrLykucmV2ZXJzZSgpLHM9dm9pZCAwLGE9W10sdT0wLGw9MS4xLGM9bi5hdHRyKFwieFwiKSxwPW4uYXR0cihcInlcIiksZj1wYXJzZUZsb2F0KG4uYXR0cihcImR5XCIpfHwwKSxkPW4udGV4dChudWxsKS5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwieFwiLGMpLmF0dHIoXCJ5XCIscCkuYXR0cihcImR5XCIsZitcImVtXCIpO3M9aS5wb3AoKTspYS5wdXNoKHMpLGQudGV4dChhLmpvaW4oXCIgXCIpKSxkLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKT5lJiYoYS5wb3AoKSxvPWEuam9pbihcIiBcIiksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe289by5yZXBsYWNlKHQrXCIgXCIsdCl9KSxkLnRleHQobyksYT1bc10sZD1uLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsYykuYXR0cihcInlcIixwKS5hdHRyKFwiZHlcIiwrK3UqbCtmK1wiZW1cIikudGV4dChzKSl9KX19O3QuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxMSlbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9big3KSxjPXUobCkscD1uKDYpLGY9bigxNCksaD11KGYpLGQ9big5NCkseT11KGQpO24oMTYwKTt2YXIgdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLmNoYXJ0Q29uc3RydWN0b3I9eVtcImRlZmF1bHRcIl19cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOmEoe30saFtcImRlZmF1bHRcIl0ucHJvcFR5cGVzLHtkb3RSYWRpdXNTY2FsZTpwLlByb3BUeXBlcy5mdW5jLGRvdFJhZGl1czpwLlByb3BUeXBlcy5udW1iZXIsZG90UmFkaXVzQWNjZXNzb3I6cC5Qcm9wVHlwZXMuZnVuYyxkb3RDb2xvclNjYWxlOnAuUHJvcFR5cGVzLmZ1bmMsZG90Q29sb3JBY2Nlc3NvcjpwLlByb3BUeXBlcy5mdW5jfSksZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOmEoe30saFtcImRlZmF1bHRcIl0uZGVmYXVsdFByb3BzLHt4U2NhbGU6Y1tcImRlZmF1bHRcIl0uc2NhbGUubGluZWFyKCkseVNjYWxlOmNbXCJkZWZhdWx0XCJdLnNjYWxlLmxpbmVhcigpLGNsYXNzTmFtZTpcInNjYXR0ZXJwbG90XCIsZG90UmFkaXVzOjMseGF4aXM6e2NsYXNzTmFtZTpcInggYXhpc1wiLG9yaWVudDpcImJvdHRvbVwiLHBvc2l0aW9uOlwiYm90dG9tXCIsYXR0cjp7ZHg6XCIwXCIsZHk6XCIwLjVlbVwifSxzdHlsZTp7XCJ0ZXh0LWFuY2hvclwiOlwibWlkZGxlXCJ9fSx5YXhpczp7Y2xhc3NOYW1lOlwieSBheGlzXCIsb3JpZW50OlwibGVmdFwifX0pLGVudW1lcmFibGU6ITB9XSksZX0oaFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDEzKSxsPWEodSksYz1uKDcpLHA9YShjKSxmPW4oMTgpLGg9YShmKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oZSx0KSxpKGUsW3trZXk6XCJ3aWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMueGF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy54YXhpcyx0aGlzLnByb3BzLnhTY2FsZSkpLHRoaXMucHJvcHMueWF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy55YXhpcyx0aGlzLnByb3BzLnlTY2FsZSkpfX0se2tleTpcIm9uTW91bnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJvbk1vdW50XCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuX3JlbmRlcigpfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQuZGF0YSxuPXQueEFjY2Vzc29yLHI9dC55QWNjZXNzb3Isbz10LnhTY2FsZSxpPXQueVNjYWxlLHM9dC5kb3RSYWRpdXNTY2FsZSxhPXQuZG90UmFkaXVzQWNjZXNzb3I7by5yYW5nZShbMCx0aGlzLndpZHRoXSksby5kb21haW4ocFtcImRlZmF1bHRcIl0uZXh0ZW50KGUsZnVuY3Rpb24odCl7cmV0dXJuIG4odCl9KSkubmljZSgpLGkucmFuZ2UoW3RoaXMuaGVpZ2h0LDBdKSxpLmRvbWFpbihwW1wiZGVmYXVsdFwiXS5leHRlbnQoZSxmdW5jdGlvbih0KXtyZXR1cm4gcih0KX0pKS5uaWNlKCkscyYmYSYmcy5kb21haW4ocFtcImRlZmF1bHRcIl0uZXh0ZW50KGUsZnVuY3Rpb24odCl7cmV0dXJuIGEodCl9KSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC54QWNjZXNzb3Iscj10LnlBY2Nlc3NvcixvPXQueFNjYWxlLGk9dC55U2NhbGUscz10LmRvdFJhZGl1cyxhPXQuZG90UmFkaXVzU2NhbGUsdT10LmRvdFJhZGl1c0FjY2Vzc29yLGw9dC5kb3RDb2xvclNjYWxlLGM9dC5kb3RDb2xvckFjY2Vzc29yLHA9dGhpcy5iYXNlLnNlbGVjdEFsbChcIi5kb3RcIikuZGF0YShlKTtwLmV4aXQoKS5yZW1vdmUoKSxwLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJjbGFzc1wiLFwiZG90XCIpLHAuYXR0cihcInJcIixmdW5jdGlvbih0KXtyZXR1cm4gYXx8dT9hKHUodCkpOnN9KS5hdHRyKFwiY3hcIixmdW5jdGlvbih0KXtyZXR1cm4gbyhuKHQpKX0pLmF0dHIoXCJjeVwiLGZ1bmN0aW9uKHQpe3JldHVybiBpKHIodCkpfSkuc3R5bGUoXCJmaWxsXCIsZnVuY3Rpb24odCl7cmV0dXJuIGwmJmM/bChjKHQpKTpcImxpbWVcIn0pfX0se2tleTpcInBvc3RSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsZT10LnNlbGVjdGVkLG49dC5zZWxlY3Rpb25BY2Nlc3NvcixyPXQuaW50ZXJhY3RpdmUsbz10aGlzLmJhc2Uuc2VsZWN0QWxsKFwiLmRvdFwiKTtyJiZvLm9uKFwiY2xpY2tcIix0aGlzLmRpc3BhdGNoLmNsaWNrKS5vbihcIm1vdXNlb3ZlclwiLHRoaXMuZGlzcGF0Y2gubW91c2VPdmVyKS5vbihcIm1vdXNlb3V0XCIsdGhpcy5kaXNwYXRjaC5tb3VzZU91dCksZSYmby5jbGFzc2VkKFwic2VsZWN0ZWRcIixmdW5jdGlvbih0KXtyZXR1cm4gbih0KT09PWV9KX19XSksZX0obFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPW4oMzApLHA9YShjKSxmPW4oOTYpLGg9YShmKTtuKDE2MSk7dmFyIGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5zZWxlY3RlZEtleT1udWxsLHRoaXMuY3VycmVudEtleT1udWxsLHRoaXMuaGFuZGxlU2Nyb2xsPXRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcyksdGhpcy5vbkNsaWNrSGFuZGxlcj10aGlzLm9uQ2xpY2tIYW5kbGVyLmJpbmQodGhpcyl9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOntpdGVtczp1LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLGtleUFjY2Vzc29yOnUuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxyZW5kZXJJdGVtOnUuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxvbkl0ZW1DbGlja2VkOnUuUHJvcFR5cGVzLmZ1bmMsc2VsZWN0ZWQ6dS5Qcm9wVHlwZXMuc3RyaW5nLGhlaWdodDp1LlByb3BUeXBlcy5hbnksaXNJdGVtRGlydHk6dS5Qcm9wVHlwZXMuZnVuYyxvblN0b3J5U2Nyb2xsOnUuUHJvcFR5cGVzLmZ1bmMsc2Vuc2l0aXZpdHk6dS5Qcm9wVHlwZXMubnVtYmVyfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e3NlbGVjdGVkOm51bGwsaGVpZ2h0OjQwMCxzZW5zaXRpdml0eTozMH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5saXN0Q29udGFpbmVyPXBbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMucmVmcy5saXN0KSx0aGlzLmxpc3RDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuaGFuZGxlU2Nyb2xsLCExKX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5saXN0Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLmhhbmRsZVNjcm9sbCl9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLnNlbGVjdGVkO3RoaXMuYnVpbGRJdGVtQ2FjaGUoKSx0aGlzLmFuY2hvcnMubGVuZ3RoJiZ0IT09dGhpcy5zZWxlY3RlZEtleSYmKHRoaXMuc2VsZWN0ZWRLZXk9dCx0aGlzLnNldFNjcm9sbFBvc2l0aW9uKCkpfX0se2tleTpcImJ1aWxkSXRlbUNhY2hlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYW5jaG9ycz1bXSx0aGlzLmFuY2hvck1hcD17fTt2YXIgZT10aGlzLmxpc3RDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi50ZXh0dXJhbC1saXN0LS1pdGVtXCIpO1tdLmZvckVhY2guY2FsbChlLGZ1bmN0aW9uKGUpe3ZhciBuPXt0OmUub2Zmc2V0VG9wLGtleTplLmdldEF0dHJpYnV0ZShcImRhdGEtaWRcIil9O3QuYW5jaG9yTWFwW24ua2V5XT1lLHQuYW5jaG9ycy5wdXNoKG4pfSl9fSx7a2V5Olwic2V0U2Nyb2xsUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuc2VsZWN0ZWRLZXkmJnRoaXMubGlzdENvbnRhaW5lcil7dmFyIHQ9dGhpcy5zZWxlY3RlZEtleSBpbiB0aGlzLmFuY2hvck1hcD90aGlzLmFuY2hvck1hcFt0aGlzLnNlbGVjdGVkS2V5XS5vZmZzZXRUb3A6bnVsbDt0JiYodGhpcy5saXN0Q29udGFpbmVyLnNjcm9sbFRvcD10KX19fSx7a2V5OlwiaGFuZGxlU2Nyb2xsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5wcm9wcyxuPWUub25TdG9yeVNjcm9sbCxyPWUuc2Vuc2l0aXZpdHksbz10aGlzLmxpc3RDb250YWluZXIuc2Nyb2xsVG9wLGk9dGhpcy5jdXJyZW50S2V5LHM9dGhpcy5saXN0Q29udGFpbmVyLnNjcm9sbEhlaWdodCxhPXRoaXMubGlzdENvbnRhaW5lci5jbGllbnRIZWlnaHQsdT12b2lkIDA7dGhpcy5hbmNob3JzJiYoMD49bz90aGlzLmN1cnJlbnRLZXk9dGhpcy5hbmNob3JzWzBdLmtleTpzLW89PT1hP3RoaXMuY3VycmVudEtleT10aGlzLmFuY2hvcnNbdGhpcy5hbmNob3JzLmxlbmd0aC0xXS5rZXk6dGhpcy5hbmNob3JzLmZvckVhY2goZnVuY3Rpb24oZSl7dT1vLWUudCxyPnUmJnU+LXImJnQuY3VycmVudEtleSE9PWUua2V5JiYodC5jdXJyZW50S2V5PWUua2V5KX0pLGkhPT10aGlzLmN1cnJlbnRLZXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJm4odGhpcy5jdXJyZW50S2V5KSl9fSx7a2V5OlwiZ2V0Q2xvc2VzdEl0ZW1Ob2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKDt0JiZ0IT09ZG9jdW1lbnQ7dD10LnBhcmVudE5vZGUpaWYodC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0ZXh0dXJhbC1saXN0LS1pdGVtXCIpKXJldHVybiB0O3JldHVybiExfX0se2tleTpcImdldERhdGFJdGVtRm9yS2V5XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMucHJvcHMscj1uLml0ZW1zLG89bi5rZXlBY2Nlc3NvcixpPXIuZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBlLmNvZXJjZUtleShvKG4pKT09PXR9KTtyZXR1cm4gaS5sZW5ndGg/aTpudWxsfX0se2tleTpcIm9uQ2xpY2tIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9wcy5vbkl0ZW1DbGlja2VkLG49dC50YXJnZXR8fG51bGw7aWYobil7dmFyIHI9bi5jbGFzc0xpc3QuY29udGFpbnMoXCJ0ZXh0dXJhbC1saXN0LS1pdGVtXCIpP246dGhpcy5nZXRDbG9zZXN0SXRlbU5vZGUobik7aWYocil7dmFyIG89ci5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpO2lmKG8pe3ZhciBpPXRoaXMuZ2V0RGF0YUl0ZW1Gb3JLZXkobyk7aS5sZW5ndGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoaSl9fX19fSx7a2V5OlwicmVuZGVySXRlbXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5yZW5kZXJJdGVtLHI9ZS5pdGVtcyxvPWUua2V5QWNjZXNzb3IsaT1lLmlzSXRlbURpcnR5LHM9XCJmdW5jdGlvblwiPT10eXBlb2Ygbz8hMDohMSxhPVwiZnVuY3Rpb25cIj09dHlwZW9mIGk/ITA6ITE7cmV0dXJuIHIubWFwKGZ1bmN0aW9uKGUscil7dmFyIHU9YT9pKGUpOiEwLGM9cz9vKGUpOnI7cmV0dXJuIGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoaFtcImRlZmF1bHRcIl0se2tleTpjLHJlbmRlckl0ZW06bixpbmRleDpyLGlkZW50aWZpZXI6dC5jb2VyY2VLZXkoYyksZGlydHk6dX0pfSl9fSx7a2V5OlwiY29lcmNlS2V5XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJcIit0fX0se2tleTpcImlzTnVtZXJpY1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiFpc05hTih0KX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMuaGVpZ2h0LGU9dGhpcy5pc051bWVyaWModCk/e21heEhlaWdodDp0fTpudWxsO3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbm9yYW1hIHRleHR1cmFsLWxpc3RcIn0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6XCJsaXN0XCIsY2xhc3NOYW1lOlwidGV4dHVyYWwtbGlzdC0taW5uZXJcIixzdHlsZTplLG9uQ2xpY2s6dGhpcy5vbkNsaWNrSGFuZGxlcn0sdGhpcy5yZW5kZXJJdGVtcygpKSl9fV0pLGV9KHUuQ29tcG9uZW50KTtlW1wiZGVmYXVsdFwiXT1kLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9big2KSxsPWEodSksYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e3JlbmRlckl0ZW06dS5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLGluZGV4OnUuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLGRpcnR5OnUuUHJvcFR5cGVzLmJvb2wsaWRlbnRpZmllcjp1LlByb3BUeXBlcy5zdHJpbmd9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7ZGlydHk6ITB9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5Olwic2hvdWxkQ29tcG9uZW50VXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5kaXJ0eX19LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5yZW5kZXJJdGVtLG49dC5pbmRleCxyPXQuaWRlbnRpZmllcjtyZXR1cm4gbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJ0ZXh0dXJhbC1saXN0LS1pdGVtXCIsXCJkYXRhLWlkXCI6cn0sZShuKSl9fV0pLGV9KHUuQ29tcG9uZW50KTtlW1wiZGVmYXVsdFwiXT1jLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9big2KSxsPW4oMjIpLGM9big3KSxwPWEoYyk7bigxNjIpO3ZhciBmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMubWFwPW51bGx9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOntmZWF0dXJlczp1LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxjdXJyZW50RGF0ZTp1LlByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e2ZlYXR1cmVzOnt9LGN1cnJlbnREYXRlOm51bGx9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubWFya2Vycz1bXSx0aGlzLm1hcD10aGlzLnByb3BzLm1hcCx0aGlzLl9lbD1MLkRvbVV0aWwuY3JlYXRlKFwiZGl2XCIsXCJwYW5vcmFtYSB0aW1lLWJhc2VkLW1hcmtlcnMtbGF5ZXIgbGVhZmxldC16b29tLWhpZGUgbGVhZmxldC1kMy1vdmVybGF5XCIpLHRoaXMubWFwLmdldFBhbmVzKCkub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fZWwpLHRoaXMuc3ZnPXBbXCJkZWZhdWx0XCJdLnNlbGVjdCh0aGlzLl9lbCkuYXBwZW5kKFwic3ZnXCIpLHRoaXMuY29udGFpbmVyPXRoaXMuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJwYW5vcmFtYSB0aW1lLWJhc2VkLW1hcmtlcnMtY29udGFpbmVyXCIpLHRoaXMuc2V0T3ZlcmxheVBvc2l0aW9uKCksdGhpcy5tYXAub24oXCJ2aWV3cmVzZXRcIix0aGlzLl9yZXNldCx0aGlzKSx0aGlzLmRpcnR5JiZ0aGlzLmRyYXcodGhpcy5wcm9wcy5mZWF0dXJlcyl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubWFwLmdldFBhbmVzKCkub3ZlcmxheVBhbmUucmVtb3ZlQ2hpbGQodGhpcy5fZWwpLHRoaXMubWFwLm9mZihcInZpZXdyZXNldFwiLHRoaXMuX3Jlc2V0LHRoaXMpLHRoaXMubWFya2Vycz1bXSx0aGlzLmxpbmU9bnVsbH19LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5wcm9wcy5mZWF0dXJlcyYmdGhpcy5wcm9wcy5mZWF0dXJlcy5mZWF0dXJlcy5sZW5ndGgmJiF0aGlzLmxvYWRlZCYmdGhpcy5kcmF3KHRoaXMucHJvcHMuZmVhdHVyZXMpLHRoaXMucHJvcHMuY3VycmVudERhdGUhPT10aGlzLmN1cnJlbnREYXRlJiYodGhpcy5jdXJyZW50RGF0ZT10aGlzLnByb3BzLmN1cnJlbnREYXRlLHRoaXMuZmlsdGVyKCkpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0Lm1hcC5nZXRQYW5lcygpLm92ZXJsYXlQYW5lLmFwcGVuZENoaWxkKHQuX2VsKX0sMSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19LHtrZXk6XCJzZXRPdmVybGF5UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWFwLmdldEJvdW5kcygpLGU9dGhpcy5tYXAubGF0TG5nVG9MYXllclBvaW50KHQuZ2V0Tm9ydGhXZXN0KCkpO3RoaXMubWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0LmdldFNvdXRoRWFzdCgpKTt0aGlzLnN2ZyYmKHBbXCJkZWZhdWx0XCJdLnNlbGVjdCh0aGlzLl9lbCkuc3R5bGUoXCJ3aWR0aFwiLHRoaXMubWFwLmdldFNpemUoKS54K1wicHhcIikuc3R5bGUoXCJoZWlnaHRcIix0aGlzLm1hcC5nZXRTaXplKCkueStcInB4XCIpLnN0eWxlKFwibWFyZ2luLWxlZnRcIixcIjBweFwiKS5zdHlsZShcIm1hcmdpbi10b3BcIixcIjBweFwiKS5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrLWUueCtcIixcIistZS55K1wiKVwiKSx0aGlzLnN2Zy5zdHlsZShcIndpZHRoXCIsdGhpcy5tYXAuZ2V0U2l6ZSgpLngrXCJweFwiKS5zdHlsZShcImhlaWdodFwiLHRoaXMubWFwLmdldFNpemUoKS55K1wicHhcIikpfX0se2tleTpcIl9yZXNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXRPdmVybGF5UG9zaXRpb24oKSx0aGlzLmZpbHRlcigpLHRoaXMucG9zaXRpb24oKX19LHtrZXk6XCJmaWx0ZXJcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMubWFwKXt2YXIgdD10aGlzLnByb3BzLmN1cnJlbnREYXRlfHxudWxsLGU9dGhpcy5tYXAuZ2V0Wm9vbSgpLG49ITE7dGhpcy5tYXJrZXJzLmZvckVhY2goZnVuY3Rpb24ocil7ci5zaG93PVwibm9uZVwiLHQmJmU+PXIuem9vbVN0YXJ0JiZlPD1yLnpvb21FbmQmJihyLnN0YXJ0PyFyLmVuZCYmdD49ci5zdGFydD8oci5zaG93PVwiYmxvY2tcIixuPSEwKTp0Pj1yLnN0YXJ0JiZ0PD1yLmVuZCYmKHIuc2hvdz1cImJsb2NrXCIsbj0hMCk6KHIuc2hvdz1cImJsb2NrXCIsbj0hMCkpLHIuZWxtLnN0eWxlKFwiZGlzcGxheVwiLHIuc2hvdyl9KSxuJiZ0aGlzLnBvc2l0aW9uKCl9fX0se2tleTpcInBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLm1hcmtlcnMmJnRoaXMubWFwKXt2YXIgdD10aGlzO3RoaXMubWFya2Vycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKFwibm9uZVwiIT09ZS5zaG93KXt2YXIgbjtcImljb25cIj09PWUubWFya2VyVHlwZT8obj10Lm1hcC5sYXRMbmdUb0xheWVyUG9pbnQoZS5jb29yZHMpLGUuZWxtLmF0dHIoXCJjeFwiLG4ueCtcInB4XCIpLmF0dHIoXCJjeVwiLG4ueStcInB4XCIpKTpcImxhYmVsXCI9PT1lLm1hcmtlclR5cGU/KG49dC5tYXAubGF0TG5nVG9MYXllclBvaW50KGUuY29vcmRzKSxlLmVsbS5hdHRyKFwieFwiLG4ueCtcInB4XCIpLmF0dHIoXCJ5XCIsbi55K1wicHhcIikpOlwibGluZVwiPT09ZS5tYXJrZXJUeXBlJiZlLmVsbS5hdHRyKFwiZFwiLHQubGluZShlLmNvb3JkcykpfX0pfX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe3JldHVybiBpLmNvbnRhaW5lci5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImNsYXNzXCIsXCJ0aW1lLWJhc2VkLVwiK1tlLm1hcHR5cGUsZS50eXBlXS5qb2luKFwiIFwiKSkuYXR0cihcImN4XCIsdC54K1wicHhcIikuYXR0cihcImN5XCIsdC55K1wicHhcIikuYXR0cihcInJcIiwzKX1mdW5jdGlvbiBuKHQsZSl7dmFyIG49XCJsZWZ0XCI9PT1lLmp1c3RpZnk/XCJzdGFydFwiOlwiZW5kXCI7cmV0dXJuIGkuY29udGFpbmVyLmFwcGVuZChcInRleHRcIikuYXR0cihcImNsYXNzXCIsXCJ3aXRoLW91dGxpbmVzIHRpbWUtYmFzZWQtXCIrW2UubWFwdHlwZSxlLnR5cGVdLmpvaW4oXCIgXCIpKS5hdHRyKFwieFwiLHQueCtcInB4XCIpLmF0dHIoXCJ5XCIsdC55K1wicHhcIikuYXR0cihcInRleHQtYW5jaG9yXCIsbikudGV4dChlLmxvY2F0aW9uKX1mdW5jdGlvbiByKHQsZSl7cmV0dXJuIGkuY29udGFpbmVyLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsXCJ0aW1lLWJhc2VkLVwiK1tlLm1hcHR5cGUsZS50eXBlXS5qb2luKFwiIFwiKSkuYXR0cihcImRcIixpLmxpbmUodCkpfWZ1bmN0aW9uIG8obyl7dC5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBzLGEsdSxsPXQucHJvcGVydGllcyxjPXQuZ2VvbWV0cnkudHlwZTtsLm1hcHR5cGU9PT1vJiYoXCJpY29uXCI9PT1sLm1hcHR5cGU/KHM9dC5nZW9tZXRyeS5jb29yZGluYXRlcy5yZXZlcnNlKCksdT1pLm1hcC5sYXRMbmdUb0xheWVyUG9pbnQocyksYT1lKHUsbCkpOlwibGFiZWxcIj09PWwubWFwdHlwZT8ocz10Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLnJldmVyc2UoKSx1PWkubWFwLmxhdExuZ1RvTGF5ZXJQb2ludChzKSxhPW4odSxsKSk6XCJsaW5lXCI9PT1sLm1hcHR5cGUmJihzPXQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMscy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucmV2ZXJzZSgpfSksYT1yKHMsbCkpLGE/aS5tYXJrZXJzLnB1c2goe2VsbTphLGNvb3JkczpzLGdlb21ldHJ5VHlwZTpjLG1hcmtlclR5cGU6bC5tYXB0eXBlfHxcIlwiLHN0YXJ0Omwuc3RhcnRfeWVhcj9uZXcgRGF0ZShsLnN0YXJ0X3llYXIpOm51bGwsZW5kOmwuZW5kX3llYXI/bmV3IERhdGUobC5lbmRfeWVhcik6bnVsbCx6b29tU3RhcnQ6bC5zdGFydHpvb20/K2wuc3RhcnR6b29tOmkubWFwLm1pblpvb20sem9vbUVuZDpsLmVuZHpvb20/K2wuZW5kem9vbTppLm1hcC5tYXhab29tfSk6Y29uc29sZS5lcnJvcihcIlVua25vd24gZmVhdHVyZTogXCIsdCkpfSl9aWYodCYmIXRoaXMubG9hZGVkKXtpZih0aGlzLmxvYWRlZD0hMCwhdGhpcy5tYXApcmV0dXJuIHZvaWQodGhpcy5kaXJ0eT0hMCk7dGhpcy5kaXJ0eT0hMTt2YXIgaT10aGlzO2lmKHRoaXMubWFya2Vycy5sZW5ndGgpcmV0dXJuIHBvc2l0aW9uKCk7dGhpcy5saW5lPXBbXCJkZWZhdWx0XCJdLnN2Zy5saW5lKCkueChmdW5jdGlvbih0KXtyZXR1cm4gaS5tYXAubGF0TG5nVG9MYXllclBvaW50KHQpLnh9KS55KGZ1bmN0aW9uKHQpe3JldHVybiBpLm1hcC5sYXRMbmdUb0xheWVyUG9pbnQodCkueX0pLmludGVycG9sYXRlKFwibGluZWFyXCIpLHRoaXMubWFya2Vycz1bXSxvKFwibGFiZWxcIiksbyhcImxpbmVcIiksbyhcImljb25cIiksdGhpcy5maWx0ZXIoKX19fV0pLGV9KGwuTWFwTGF5ZXIpO2VbXCJkZWZhdWx0XCJdPWYsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigzKVtcImRlZmF1bHRcIl0sbz1uKDIpW1wiZGVmYXVsdFwiXSxpPW4oMTEpW1wiZGVmYXVsdFwiXSxzPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPW4oNyksdT1zKGEpLGw9bigzMiksYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxuKXtvKHRoaXMsdCksdGhpcy5fb3B0aW9ucz1pKHt9LGwudG9vbHRpcERlZmF1bHRPcHRpb25zLG4pLHRoaXMuX2VsZW1lbnQ9dVtcImRlZmF1bHRcIl0uc2VsZWN0KGUpLHRoaXMuY2xvc2VUaW1lcj1udWxsfXJldHVybiByKHQsW3trZXk6XCJ1bk1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9vcHRpb25zPXt9LHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl9yZWxhdGl2ZUNvbnRhaW5lcj1udWxsLHRoaXMuY2xvc2VUaW1lciYmKGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpLHRoaXMuY2xvc2VUaW1lcj1udWxsKX19LHtrZXk6XCJzZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNTaG93aW5nKXt2YXIgZT10aGlzLmNhbGNQb3NpdGlvbih0KTt0aGlzLmVsZW1lbnQuc3R5bGUoXCJsZWZ0XCIsZVswXStcInB4XCIpLnN0eWxlKFwidG9wXCIsZVsxXStcInB4XCIpfX19LHtrZXk6XCJjYWxjUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wdGlvbnMsbj1lLm9mZnNldCxyPWUuYWxpZ24sbz1yLnNwbGl0KFwiIFwiKSxpPXRoaXMuZWxlbWVudC5ub2RlKCkub2Zmc2V0V2lkdGgscz10aGlzLmVsZW1lbnQubm9kZSgpLm9mZnNldEhlaWdodCxhPXRoaXMucmVsYXRpdmVDb250YWluZXJ8fHQudGFyZ2V0fHx0LnNyY0VsZW1lbnQsdT1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGw9dC5jbGllbnRYLXUubGVmdCxjPXQuY2xpZW50WS11LnRvcDtzd2l0Y2gob1swXSl7Y2FzZVwidG9wXCI6Yy09cy1uWzFdO2JyZWFrO2Nhc2VcImJvdHRvbVwiOmRlZmF1bHQ6Yy09blsxXX1zd2l0Y2gob1sxXSl7Y2FzZVwiY2VudGVyXCI6bC09aS8yK25bMF07YnJlYWs7Y2FzZVwicmlnaHRcIjpsLT1pK25bMF07YnJlYWs7Y2FzZVwibGVmdFwiOmRlZmF1bHQ6bCs9blswXX1yZXR1cm5bbCxjXX19LHtrZXk6XCJzZXRDb250ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLm9uU2V0VG9vbHRpcENvbnRlbnQ/dGhpcy5vcHRpb25zLm9uU2V0VG9vbHRpcENvbnRlbnQodGhpcy5lbGVtZW50LHQpOnRoaXMuZWxlbWVudC50ZXh0KFwiXCIpLHRoaXN9fSx7a2V5Olwic2hvd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuaXNTaG93aW5nP3ZvaWQgMDoodGhpcy5pc1Nob3dpbmc9ITAsdGhpcy5lbGVtZW50LmNsYXNzZWQoXCJhY3RpdmVcIiwhMCksdCYmdGhpcy5zZXRQb3NpdGlvbih0KSxlJiZ0aGlzLnNldENvbnRlbnQoZSksdGhpcyl9fSx7a2V5OlwiaGlkZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodGhpcy5pc1Nob3dpbmcpcmV0dXJuIHRoaXMuY2xvc2VUaW1lciYmKGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpLHRoaXMuY2xvc2VUaW1lcj1udWxsKSx0aGlzLmlzU2hvd2luZz0hMSx0fHx0aGlzLm9wdGlvbnMuY2xvc2VEZWxheTwxP3RoaXMuc2V0QWN0aXZlVG9GYWxzZSgpOnRoaXMuY2xvc2VUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5pc1Nob3dpbmd8fGUuc2V0QWN0aXZlVG9GYWxzZSgpfSx0aGlzLm9wdGlvbnMuY2xvc2VEZWxheSksdGhpc319LHtrZXk6XCJzZXRBY3RpdmVUb0ZhbHNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNsb3NlVGltZXI9bnVsbCx0aGlzLmVsZW1lbnQuY2xhc3NlZChcImFjdGl2ZVwiLCExKX19LHtrZXk6XCJ0b1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJUb29sdGlwXCJ9fSx7a2V5OlwiZWxlbWVudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbGVtZW50fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fZWxlbWVudD11W1wiZGVmYXVsdFwiXS5zZWxlY3QodCl9fSx7a2V5Olwib3B0aW9uc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcHRpb25zfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fb3B0aW9ucz1pKHt9LHRoaXMub3B0aW9ucyx7b2JqOnR9KX19LHtrZXk6XCJyZWxhdGl2ZUNvbnRhaW5lclwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWxhdGl2ZUNvbnRhaW5lcn0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3JlbGF0aXZlQ29udGFpbmVyPXQubm9kZT90Lm5vZGUoKTp0fX1dKSx0fSgpO2VbXCJkZWZhdWx0XCJdPWMsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDEwOCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTA5KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigxMTEpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDExMiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTEzKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigxMTQpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDExNSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTE2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oOTkpW1wiZGVmYXVsdFwiXSxvPW4oMTAwKVtcImRlZmF1bHRcIl07ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49W10sbz0hMCxpPSExLHM9dm9pZCAwO3RyeXtmb3IodmFyIGEsdT1yKHQpOyEobz0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7bz0hMCk7fWNhdGNoKGwpe2k9ITAscz1sfWZpbmFsbHl7dHJ5eyFvJiZ1W1wicmV0dXJuXCJdJiZ1W1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihpKXRocm93IHN9fXJldHVybiBufXJldHVybiBmdW5jdGlvbihlLG4pe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7aWYobyhPYmplY3QoZSkpKXJldHVybiB0KGUsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9fSgpLGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlLG4pe24oNDIpLG4oNDEpLHQuZXhwb3J0cz1uKDEzOSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDQyKSxuKDQxKSx0LmV4cG9ydHM9bigxNDApfSxmdW5jdGlvbih0LGUsbil7bigxNDIpLHQuZXhwb3J0cz1uKDgpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDkpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiByLmNyZWF0ZSh0LGUpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gci5zZXREZXNjKHQsZSxuKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDkpO24oMTQzKSx0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5nZXREZXNjKHQsZSl9fSxmdW5jdGlvbih0LGUsbil7bigxNDQpLHQuZXhwb3J0cz1uKDgpLk9iamVjdC5rZXlzfSxmdW5jdGlvbih0LGUsbil7bigxNDUpLHQuZXhwb3J0cz1uKDgpLk9iamVjdC5zZXRQcm90b3R5cGVPZn0sZnVuY3Rpb24odCxlLG4pe24oMTQ2KSxuKDQxKSxuKDQyKSxuKDE0NyksdC5leHBvcnRzPW4oOCkuUHJvbWlzZX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyNSksbz1uKDEyKS5kb2N1bWVudCxpPXIobykmJnIoby5jcmVhdGVFbGVtZW50KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGk/by5jcmVhdGVFbGVtZW50KHQpOnt9fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTkpLG89bigxMjMpLGk9bigxMjIpLHM9bigxNSksYT1uKDEzNyksdT1uKDYwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4sbCl7dmFyIGMscCxmLGg9dSh0KSxkPXIobixsLGU/MjoxKSx5PTA7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaCl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgaXRlcmFibGUhXCIpO2lmKGkoaCkpZm9yKGM9YSh0Lmxlbmd0aCk7Yz55O3krKyllP2QocyhwPXRbeV0pWzBdLHBbMV0pOmQodFt5XSk7ZWxzZSBmb3IoZj1oLmNhbGwodCk7IShwPWYubmV4dCgpKS5kb25lOylvKGYsZCxwLnZhbHVlLGUpfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDEyKS5kb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dmFyIHI9dm9pZCAwPT09bjtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gcj90KCk6dC5jYWxsKG4pO2Nhc2UgMTpyZXR1cm4gcj90KGVbMF0pOnQuY2FsbChuLGVbMF0pO2Nhc2UgMjpyZXR1cm4gcj90KGVbMF0sZVsxXSk6dC5jYWxsKG4sZVswXSxlWzFdKTtjYXNlIDM6cmV0dXJuIHI/dChlWzBdLGVbMV0sZVsyXSk6dC5jYWxsKG4sZVswXSxlWzFdLGVbMl0pO2Nhc2UgNDpyZXR1cm4gcj90KGVbMF0sZVsxXSxlWzJdLGVbM10pOnQuY2FsbChuLGVbMF0sZVsxXSxlWzJdLGVbM10pfXJldHVybiB0LmFwcGx5KG4sZSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNiksbz1uKDEwKShcIml0ZXJhdG9yXCIpLGk9QXJyYXkucHJvdG90eXBlO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dCYmKHIuQXJyYXk9PT10fHxpW29dPT09dCl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLG8pe3RyeXtyZXR1cm4gbz9lKHIobilbMF0sblsxXSk6ZShuKX1jYXRjaChpKXt2YXIgcz10W1wicmV0dXJuXCJdO3Rocm93IHZvaWQgMCE9PXMmJnIocy5jYWxsKHQpKSxpfX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDkpLG89big1NCksaT1uKDQwKSxzPXt9O24oMzkpKHMsbigxMCkoXCJpdGVyYXRvclwiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksdC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZT1yLmNyZWF0ZShzLHtuZXh0Om8oMSxuKX0pLGkodCxlK1wiIEl0ZXJhdG9yXCIpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTApKFwiaXRlcmF0b3JcIiksbz0hMTtcbnRyeXt2YXIgaT1bN11bcl0oKTtpW1wicmV0dXJuXCJdPWZ1bmN0aW9uKCl7bz0hMH0sQXJyYXkuZnJvbShpLGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoKHMpe310LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZighZSYmIW8pcmV0dXJuITE7dmFyIG49ITE7dHJ5e3ZhciBpPVs3XSxzPWlbcl0oKTtzLm5leHQ9ZnVuY3Rpb24oKXtuPSEwfSxpW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHN9LHQoaSl9Y2F0Y2goYSl7fXJldHVybiBufX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57dmFsdWU6ZSxkb25lOiEhdH19fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxpLHM9bigxMiksYT1uKDEzNikuc2V0LHU9cy5NdXRhdGlvbk9ic2VydmVyfHxzLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsbD1zLnByb2Nlc3MsYz1zLlByb21pc2UscD1cInByb2Nlc3NcIj09bigyNCkobCksZj1mdW5jdGlvbigpe3ZhciB0LGUsbjtmb3IocCYmKHQ9bC5kb21haW4pJiYobC5kb21haW49bnVsbCx0LmV4aXQoKSk7cjspZT1yLmRvbWFpbixuPXIuZm4sZSYmZS5lbnRlcigpLG4oKSxlJiZlLmV4aXQoKSxyPXIubmV4dDtvPXZvaWQgMCx0JiZ0LmVudGVyKCl9O2lmKHApaT1mdW5jdGlvbigpe2wubmV4dFRpY2soZil9O2Vsc2UgaWYodSl7dmFyIGg9MSxkPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO25ldyB1KGYpLm9ic2VydmUoZCx7Y2hhcmFjdGVyRGF0YTohMH0pLGk9ZnVuY3Rpb24oKXtkLmRhdGE9aD0taH19ZWxzZSBpPWMmJmMucmVzb2x2ZT9mdW5jdGlvbigpe2MucmVzb2x2ZSgpLnRoZW4oZil9OmZ1bmN0aW9uKCl7YS5jYWxsKHMsZil9O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT17Zm46dCxuZXh0OnZvaWQgMCxkb21haW46cCYmbC5kb21haW59O28mJihvLm5leHQ9ZSkscnx8KHI9ZSxpKCkpLG89ZX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDkpLG89big1OSksaT1uKDUwKTt0LmV4cG9ydHM9bigzOCkoZnVuY3Rpb24oKXt2YXIgdD1PYmplY3QuYXNzaWduLGU9e30sbj17fSxyPVN5bWJvbCgpLG89XCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO3JldHVybiBlW3JdPTcsby5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe25bdF09dH0pLDchPXQoe30sZSlbcl18fE9iamVjdC5rZXlzKHQoe30sbikpLmpvaW4oXCJcIikhPW99KT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1vKHQpLHM9YXJndW1lbnRzLGE9cy5sZW5ndGgsdT0xLGw9ci5nZXRLZXlzLGM9ci5nZXRTeW1ib2xzLHA9ci5pc0VudW07YT51Oylmb3IodmFyIGYsaD1pKHNbdSsrXSksZD1jP2woaCkuY29uY2F0KGMoaCkpOmwoaCkseT1kLmxlbmd0aCx2PTA7eT52OylwLmNhbGwoaCxmPWRbdisrXSkmJihuW2ZdPWhbZl0pO3JldHVybiBufTpPYmplY3QuYXNzaWdufSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1NSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpcih0LG4sZVtuXSk7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1PYmplY3QuaXN8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1lPzAhPT10fHwxL3Q9PT0xL2U6dCE9dCYmZSE9ZX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDgpLG89big5KSxpPW4oMzcpLHM9bigxMCkoXCJzcGVjaWVzXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1yW3RdO2kmJmUmJiFlW3NdJiZvLnNldERlc2MoZSxzLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMiksbz1cIl9fY29yZS1qc19zaGFyZWRfX1wiLGk9cltvXXx8KHJbb109e30pO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaVt0XXx8KGlbdF09e30pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTUpLG89bigzNCksaT1uKDEwKShcInNwZWNpZXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scz1yKHQpLmNvbnN0cnVjdG9yO3JldHVybiB2b2lkIDA9PT1zfHx2b2lkIDA9PShuPXIocylbaV0pP2U6byhuKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBUeXBlRXJyb3IobitcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1Nyksbz1uKDM2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbil7dmFyIGkscyxhPVN0cmluZyhvKGUpKSx1PXIobiksbD1hLmxlbmd0aDtyZXR1cm4gMD51fHx1Pj1sP3Q/XCJcIjp2b2lkIDA6KGk9YS5jaGFyQ29kZUF0KHUpLDU1Mjk2Pml8fGk+NTYzMTl8fHUrMT09PWx8fChzPWEuY2hhckNvZGVBdCh1KzEpKTw1NjMyMHx8cz41NzM0Mz90P2EuY2hhckF0KHUpOmk6dD9hLnNsaWNlKHUsdSsyKTooaS01NTI5Njw8MTApKyhzLTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByLG8saSxzPW4oMTkpLGE9bigxMjEpLHU9bigxMjApLGw9bigxMTgpLGM9bigxMikscD1jLnByb2Nlc3MsZj1jLnNldEltbWVkaWF0ZSxoPWMuY2xlYXJJbW1lZGlhdGUsZD1jLk1lc3NhZ2VDaGFubmVsLHk9MCx2PXt9LG09XCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixnPWZ1bmN0aW9uKCl7dmFyIHQ9K3RoaXM7aWYodi5oYXNPd25Qcm9wZXJ0eSh0KSl7dmFyIGU9dlt0XTtkZWxldGUgdlt0XSxlKCl9fSx4PWZ1bmN0aW9uKHQpe2cuY2FsbCh0LmRhdGEpfTtmJiZofHwoZj1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0xO2FyZ3VtZW50cy5sZW5ndGg+bjspZS5wdXNoKGFyZ3VtZW50c1tuKytdKTtyZXR1cm4gdlsrK3ldPWZ1bmN0aW9uKCl7YShcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6RnVuY3Rpb24odCksZSl9LHIoeSkseX0saD1mdW5jdGlvbih0KXtkZWxldGUgdlt0XX0sXCJwcm9jZXNzXCI9PW4oMjQpKHApP3I9ZnVuY3Rpb24odCl7cC5uZXh0VGljayhzKGcsdCwxKSl9OmQ/KG89bmV3IGQsaT1vLnBvcnQyLG8ucG9ydDEub25tZXNzYWdlPXgscj1zKGkucG9zdE1lc3NhZ2UsaSwxKSk6Yy5hZGRFdmVudExpc3RlbmVyJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBwb3N0TWVzc2FnZSYmIWMuaW1wb3J0U2NyaXB0cz8ocj1mdW5jdGlvbih0KXtjLnBvc3RNZXNzYWdlKHQrXCJcIixcIipcIil9LGMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix4LCExKSk6cj1tIGluIGwoXCJzY3JpcHRcIik/ZnVuY3Rpb24odCl7dS5hcHBlbmRDaGlsZChsKFwic2NyaXB0XCIpKVttXT1mdW5jdGlvbigpe3UucmVtb3ZlQ2hpbGQodGhpcyksZy5jYWxsKHQpfX06ZnVuY3Rpb24odCl7c2V0VGltZW91dChzKGcsdCwxKSwwKX0pLHQuZXhwb3J0cz17c2V0OmYsY2xlYXI6aH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDU3KSxvPU1hdGgubWluO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdD4wP28ocih0KSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24odCxlKXt2YXIgbj0wLHI9TWF0aC5yYW5kb20oKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJTeW1ib2woXCIuY29uY2F0KHZvaWQgMD09PXQ/XCJcIjp0LFwiKV9cIiwoKytuK3IpLnRvU3RyaW5nKDM2KSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNSksbz1uKDYwKTt0LmV4cG9ydHM9big4KS5nZXRJdGVyYXRvcj1mdW5jdGlvbih0KXt2YXIgZT1vKHQpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgVHlwZUVycm9yKHQrXCIgaXMgbm90IGl0ZXJhYmxlIVwiKTtyZXR1cm4gcihlLmNhbGwodCkpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMzUpLG89bigxMCkoXCJpdGVyYXRvclwiKSxpPW4oMTYpO3QuZXhwb3J0cz1uKDgpLmlzSXRlcmFibGU9ZnVuY3Rpb24odCl7dmFyIGU9T2JqZWN0KHQpO3JldHVybiB2b2lkIDAhPT1lW29dfHxcIkBAaXRlcmF0b3JcImluIGV8fGkuaGFzT3duUHJvcGVydHkocihlKSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMTcpLG89bigxMjYpLGk9bigxNikscz1uKDU4KTt0LmV4cG9ydHM9big1MSkoQXJyYXksXCJBcnJheVwiLGZ1bmN0aW9uKHQsZSl7dGhpcy5fdD1zKHQpLHRoaXMuX2k9MCx0aGlzLl9rPWV9LGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fdCxlPXRoaXMuX2ssbj10aGlzLl9pKys7cmV0dXJuIXR8fG4+PXQubGVuZ3RoPyh0aGlzLl90PXZvaWQgMCxvKDEpKTpcImtleXNcIj09ZT9vKDAsbik6XCJ2YWx1ZXNcIj09ZT9vKDAsdFtuXSk6bygwLFtuLHRbbl1dKX0sXCJ2YWx1ZXNcIiksaS5Bcmd1bWVudHM9aS5BcnJheSxyKFwia2V5c1wiKSxyKFwidmFsdWVzXCIpLHIoXCJlbnRyaWVzXCIpfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyMCk7cihyLlMrci5GLFwiT2JqZWN0XCIse2Fzc2lnbjpuKDEyOCl9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTgpO24oNTMpKFwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbil7cmV0dXJuIHQocihlKSxuKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTkpO24oNTMpKFwia2V5c1wiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdChyKGUpKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjApO3Ioci5TLFwiT2JqZWN0XCIse3NldFByb3RvdHlwZU9mOm4oNTYpLnNldH0pfSxmdW5jdGlvbih0LGUpe30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByLG89big5KSxpPW4oNTIpLHM9bigxMiksYT1uKDE5KSx1PW4oMzUpLGw9bigyMCksYz1uKDI1KSxwPW4oMTUpLGY9bigzNCksaD1uKDEzNCksZD1uKDExOSkseT1uKDU2KS5zZXQsdj1uKDEzMCksbT1uKDEwKShcInNwZWNpZXNcIiksZz1uKDEzMykseD1uKDEyNyksYj1cIlByb21pc2VcIixrPXMucHJvY2VzcyxfPVwicHJvY2Vzc1wiPT11KGspLFA9c1tiXSxUPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBQKGZ1bmN0aW9uKCl7fSk7cmV0dXJuIHQmJihlLmNvbnN0cnVjdG9yPU9iamVjdCksUC5yZXNvbHZlKGUpPT09ZX0sTz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dmFyIG49bmV3IFAoZSk7cmV0dXJuIHkobix0LnByb3RvdHlwZSksbn12YXIgZT0hMTt0cnl7aWYoZT1QJiZQLnJlc29sdmUmJlQoKSx5KHQsUCksdC5wcm90b3R5cGU9by5jcmVhdGUoUC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0fX0pLHQucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSlpbnN0YW5jZW9mIHR8fChlPSExKSxlJiZuKDM3KSl7dmFyIHI9ITE7UC5yZXNvbHZlKG8uc2V0RGVzYyh7fSxcInRoZW5cIix7Z2V0OmZ1bmN0aW9uKCl7cj0hMH19KSksZT1yfX1jYXRjaChpKXtlPSExfXJldHVybiBlfSgpLHc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaSYmdD09PVAmJmU9PT1yPyEwOnYodCxlKX0sTT1mdW5jdGlvbih0KXt2YXIgZT1wKHQpW21dO3JldHVybiB2b2lkIDAhPWU/ZTp0fSxFPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBjKHQpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihlPXQudGhlbik/ZTohMX0sQz1mdW5jdGlvbih0KXt2YXIgZSxuO3RoaXMucHJvbWlzZT1uZXcgdChmdW5jdGlvbih0LHIpe2lmKHZvaWQgMCE9PWV8fHZvaWQgMCE9PW4pdGhyb3cgVHlwZUVycm9yKFwiQmFkIFByb21pc2UgY29uc3RydWN0b3JcIik7ZT10LG49cn0pLHRoaXMucmVzb2x2ZT1mKGUpLHRoaXMucmVqZWN0PWYobil9LFM9ZnVuY3Rpb24odCl7dHJ5e3QoKX1jYXRjaChlKXtyZXR1cm57ZXJyb3I6ZX19fSxqPWZ1bmN0aW9uKHQsZSl7aWYoIXQubil7dC5uPSEwO3ZhciBuPXQuYzt4KGZ1bmN0aW9uKCl7Zm9yKHZhciByPXQudixvPTE9PXQucyxpPTAsYT1mdW5jdGlvbihlKXt2YXIgbixpLHM9bz9lLm9rOmUuZmFpbCxhPWUucmVzb2x2ZSx1PWUucmVqZWN0O3RyeXtzPyhvfHwodC5oPSEwKSxuPXM9PT0hMD9yOnMociksbj09PWUucHJvbWlzZT91KFR5cGVFcnJvcihcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpOihpPUUobikpP2kuY2FsbChuLGEsdSk6YShuKSk6dShyKX1jYXRjaChsKXt1KGwpfX07bi5sZW5ndGg+aTspYShuW2krK10pO24ubGVuZ3RoPTAsdC5uPSExLGUmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgZSxuLG89dC5wO0EobykmJihfP2suZW1pdChcInVuaGFuZGxlZFJlamVjdGlvblwiLHIsbyk6KGU9cy5vbnVuaGFuZGxlZHJlamVjdGlvbik/ZSh7cHJvbWlzZTpvLHJlYXNvbjpyfSk6KG49cy5jb25zb2xlKSYmbi5lcnJvciYmbi5lcnJvcihcIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvblwiLHIpKSx0LmE9dm9pZCAwfSwxKX0pfX0sQT1mdW5jdGlvbih0KXt2YXIgZSxuPXQuX2Qscj1uLmF8fG4uYyxvPTA7aWYobi5oKXJldHVybiExO2Zvcig7ci5sZW5ndGg+bzspaWYoZT1yW28rK10sZS5mYWlsfHwhQShlLnByb21pc2UpKXJldHVybiExO3JldHVybiEwfSxMPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7ZS5kfHwoZS5kPSEwLGU9ZS5yfHxlLGUudj10LGUucz0yLGUuYT1lLmMuc2xpY2UoKSxqKGUsITApKX0sST1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXM7aWYoIW4uZCl7bi5kPSEwLG49bi5yfHxuO3RyeXtpZihuLnA9PT10KXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpOyhlPUUodCkpP3goZnVuY3Rpb24oKXt2YXIgcj17cjpuLGQ6ITF9O3RyeXtlLmNhbGwodCxhKEksciwxKSxhKEwsciwxKSl9Y2F0Y2gobyl7TC5jYWxsKHIsbyl9fSk6KG4udj10LG4ucz0xLGoobiwhMSkpfWNhdGNoKHIpe0wuY2FsbCh7cjpuLGQ6ITF9LHIpfX19O098fChQPWZ1bmN0aW9uKHQpe2YodCk7dmFyIGU9dGhpcy5fZD17cDpoKHRoaXMsUCxiKSxjOltdLGE6dm9pZCAwLHM6MCxkOiExLHY6dm9pZCAwLGg6ITEsbjohMX07dHJ5e3QoYShJLGUsMSksYShMLGUsMSkpfWNhdGNoKG4pe0wuY2FsbChlLG4pfX0sbigxMjkpKFAucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEMoZyh0aGlzLFApKSxyPW4ucHJvbWlzZSxvPXRoaXMuX2Q7cmV0dXJuIG4ub2s9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90OiEwLG4uZmFpbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLG8uYy5wdXNoKG4pLG8uYSYmby5hLnB1c2gobiksby5zJiZqKG8sITEpLHJ9LFwiY2F0Y2hcIjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCx0KX19KSksbChsLkcrbC5XK2wuRiohTyx7UHJvbWlzZTpQfSksbig0MCkoUCxiKSxuKDEzMSkoYikscj1uKDgpW2JdLGwobC5TK2wuRiohTyxiLHtyZWplY3Q6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEModGhpcyksbj1lLnJlamVjdDtyZXR1cm4gbih0KSxlLnByb21pc2V9fSksbChsLlMrbC5GKighT3x8VCghMCkpLGIse3Jlc29sdmU6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFAmJncodC5jb25zdHJ1Y3Rvcix0aGlzKSlyZXR1cm4gdDt2YXIgZT1uZXcgQyh0aGlzKSxuPWUucmVzb2x2ZTtyZXR1cm4gbih0KSxlLnByb21pc2V9fSksbChsLlMrbC5GKiEoTyYmbigxMjUpKGZ1bmN0aW9uKHQpe1AuYWxsKHQpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oKXt9KX0pKSxiLHthbGw6ZnVuY3Rpb24odCl7dmFyIGU9TSh0aGlzKSxuPW5ldyBDKGUpLHI9bi5yZXNvbHZlLGk9bi5yZWplY3Qscz1bXSxhPVMoZnVuY3Rpb24oKXtkKHQsITEscy5wdXNoLHMpO3ZhciBuPXMubGVuZ3RoLGE9QXJyYXkobik7bj9vLmVhY2guY2FsbChzLGZ1bmN0aW9uKHQsbyl7dmFyIHM9ITE7ZS5yZXNvbHZlKHQpLnRoZW4oZnVuY3Rpb24odCl7c3x8KHM9ITAsYVtvXT10LC0tbnx8cihhKSl9LGkpfSk6cihhKX0pO3JldHVybiBhJiZpKGEuZXJyb3IpLG4ucHJvbWlzZX0scmFjZTpmdW5jdGlvbih0KXt2YXIgZT1NKHRoaXMpLG49bmV3IEMoZSkscj1uLnJlamVjdCxvPVMoZnVuY3Rpb24oKXtkKHQsITEsZnVuY3Rpb24odCl7ZS5yZXNvbHZlKHQpLnRoZW4obi5yZXNvbHZlLHIpfSl9KTtyZXR1cm4gbyYmcihvLmVycm9yKSxuLnByb21pc2V9fSl9LGZ1bmN0aW9uKHQsZSl7fSwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtmb3IodmFyIG49LTEscj1lLmxlbmd0aCxvPXQubGVuZ3RoOysrbjxyOyl0W28rbl09ZVtuXTtyZXR1cm4gdH10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe2Zvcih2YXIgcj0tMSxpPW8oZSkscz1pLmxlbmd0aDsrK3I8czspe3ZhciBhPWlbcl0sdT10W2FdLGw9bih1LGVbYV0sYSx0LGUpOyhsPT09bD9sPT09dTp1IT09dSkmJih2b2lkIDAhPT11fHxhIGluIHQpfHwodFthXT1sKX1yZXR1cm4gdH12YXIgbz1uKDY2KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlKXtyZXR1cm4gbnVsbD09ZT90Om8oZSxpKGUpLHQpfXZhciBvPW4oMTY3KSxpPW4oNjYpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlLG4pe258fChuPXt9KTtmb3IodmFyIHI9LTEsbz1lLmxlbmd0aDsrK3I8bzspe3ZhciBpPWVbcl07bltpXT10W2ldfXJldHVybiBufXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbixsKXtsfHwobD1bXSk7Zm9yKHZhciBjPS0xLHA9dC5sZW5ndGg7KytjPHA7KXt2YXIgZj10W2NdO3UoZikmJmEoZikmJihufHxzKGYpfHxpKGYpKT9lP3IoZixlLG4sbCk6byhsLGYpOm58fChsW2wubGVuZ3RoXT1mKX1yZXR1cm4gbH12YXIgbz1uKDE2NCksaT1uKDQ0KSxzPW4oMjkpLGE9bigyNiksdT1uKDI4KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTczKSxvPXIoKTt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlKXtyZXR1cm4gbyh0LGUsaSl9dmFyIG89bigxNjkpLGk9big2Nyk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/dm9pZCAwOmVbdF19fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gcyhmdW5jdGlvbihlLG4pe3ZhciByPS0xLHM9bnVsbD09ZT8wOm4ubGVuZ3RoLGE9cz4yP25bcy0yXTp2b2lkIDAsdT1zPjI/blsyXTp2b2lkIDAsbD1zPjE/bltzLTFdOnZvaWQgMDtmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgYT8oYT1vKGEsbCw1KSxzLT0yKTooYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2w6dm9pZCAwLHMtPWE/MTowKSx1JiZpKG5bMF0sblsxXSx1KSYmKGE9Mz5zP3ZvaWQgMDphLHM9MSk7KytyPHM7KXt2YXIgYz1uW3JdO2MmJnQoZSxjLGEpfXJldHVybiBlfSl9dmFyIG89big2MiksaT1uKDE3NSkscz1uKDYxKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtmb3IodmFyIGk9byhlKSxzPXIoZSksYT1zLmxlbmd0aCx1PXQ/YTotMTt0P3UtLTorK3U8YTspe3ZhciBsPXNbdV07aWYobihpW2xdLGwsaSk9PT0hMSlicmVha31yZXR1cm4gZX19dmFyIG89big2NCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE3MSksbz1yKFwibGVuZ3RoXCIpO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7aWYoIXMobikpcmV0dXJuITE7dmFyIHI9dHlwZW9mIGU7aWYoXCJudW1iZXJcIj09cj9vKG4pJiZpKGUsbi5sZW5ndGgpOlwic3RyaW5nXCI9PXImJmUgaW4gbil7dmFyIGE9bltlXTtyZXR1cm4gdD09PXQ/dD09PWE6YSE9PWF9cmV0dXJuITF9dmFyIG89bigyNiksaT1uKDQzKSxzPW4oMTcpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3Q9byh0KTtmb3IodmFyIG49LTEscj1lLmxlbmd0aCxpPXt9OysrbjxyOyl7dmFyIHM9ZVtuXTtzIGluIHQmJihpW3NdPXRbc10pfXJldHVybiBpfXZhciBvPW4oNjQpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuPXt9O3JldHVybiBvKHQsZnVuY3Rpb24odCxyLG8pe2UodCxyLG8pJiYobltyXT10KX0pLG59dmFyIG89bigxNzApO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtmb3IodmFyIGU9dSh0KSxuPWUubGVuZ3RoLHI9biYmdC5sZW5ndGgsbD0hIXImJmEocikmJihpKHQpfHxvKHQpKSxwPS0xLGY9W107KytwPG47KXt2YXIgaD1lW3BdOyhsJiZzKGgscil8fGMuY2FsbCh0LGgpKSYmZi5wdXNoKGgpfXJldHVybiBmfXZhciBvPW4oNDQpLGk9bigyOSkscz1uKDQzKSxhPW4oMjcpLHU9big2NyksbD1PYmplY3QucHJvdG90eXBlLGM9bC5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIG8odCkmJmEuY2FsbCh0KT09aX12YXIgbz1uKDE3KSxpPVwiW29iamVjdCBGdW5jdGlvbl1cIixzPU9iamVjdC5wcm90b3R5cGUsYT1zLnRvU3RyaW5nO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbnVsbD09dD8hMTpvKHQpP2MudGVzdCh1LmNhbGwodCkpOmkodCkmJnMudGVzdCh0KX12YXIgbz1uKDE3OSksaT1uKDI4KSxzPS9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sYT1PYmplY3QucHJvdG90eXBlLHU9RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLGw9YS5oYXNPd25Qcm9wZXJ0eSxjPVJlZ0V4cChcIl5cIit1LmNhbGwobCkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZyxcIiQxLio/XCIpK1wiJFwiKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTY4KSxvPW4oNjIpLGk9bigxNzYpLHM9bigxNzcpLGE9big2MSksdT1hKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PXQ/e306XCJmdW5jdGlvblwiPT10eXBlb2YgZVswXT9zKHQsbyhlWzBdLGVbMV0sMykpOmkodCxyKGUpKX0pO3QuZXhwb3J0cz11fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIHR9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe2RlbGV0ZSB0LnJlZn12YXIgbz1uKDYpLGk9bigzMCkscz1uKDE5MCksYT1vLmNyZWF0ZUZhY3RvcnkobigxODQpKSx1PW4oMTg1KSxsPW4oMTg5KSxjPW4oMzApLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLHA9cy5jYW5Vc2VET00/d2luZG93LkhUTUxFbGVtZW50Ont9O3QuZXhwb3J0cz1vLmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTpcIk1vZGFsXCIsc3RhdGljczp7c2V0QXBwRWxlbWVudDp1LnNldEVsZW1lbnQsaW5qZWN0Q1NTOmZ1bmN0aW9uKCl7fX0scHJvcFR5cGVzOntpc09wZW46by5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLHN0eWxlOm8uUHJvcFR5cGVzLnNoYXBlKHtjb250ZW50Om8uUHJvcFR5cGVzLm9iamVjdCxvdmVybGF5Om8uUHJvcFR5cGVzLm9iamVjdH0pLGFwcEVsZW1lbnQ6by5Qcm9wVHlwZXMuaW5zdGFuY2VPZihwKSxvblJlcXVlc3RDbG9zZTpvLlByb3BUeXBlcy5mdW5jLGNsb3NlVGltZW91dE1TOm8uUHJvcFR5cGVzLm51bWJlcixhcmlhSGlkZUFwcDpvLlByb3BUeXBlcy5ib29sfSxnZXREZWZhdWx0UHJvcHM6ZnVuY3Rpb24oKXtyZXR1cm57aXNPcGVuOiExLGFyaWFIaWRlQXBwOiEwLGNsb3NlVGltZW91dE1TOjB9fSxjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpe3RoaXMubm9kZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMubm9kZS5jbGFzc05hbWU9XCJSZWFjdE1vZGFsUG9ydGFsXCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpLHRoaXMucmVuZGVyUG9ydGFsKHRoaXMucHJvcHMpfSxjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOmZ1bmN0aW9uKHQpe3RoaXMucmVuZGVyUG9ydGFsKHQpfSxjb21wb25lbnRXaWxsVW5tb3VudDpmdW5jdGlvbigpe2kudW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLm5vZGUpLGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKX0scmVuZGVyUG9ydGFsOmZ1bmN0aW9uKHQpe3QuaXNPcGVuP2woZG9jdW1lbnQuYm9keSkuYWRkKFwiUmVhY3RNb2RhbF9fQm9keS0tb3BlblwiKTpsKGRvY3VtZW50LmJvZHkpLnJlbW92ZShcIlJlYWN0TW9kYWxfX0JvZHktLW9wZW5cIiksdC5hcmlhSGlkZUFwcCYmdS50b2dnbGUodC5pc09wZW4sdC5hcHBFbGVtZW50KSxyKHQpLHRoaXMucG9ydGFsPWModGhpcyxhKHQpLHRoaXMubm9kZSl9LHJlbmRlcjpmdW5jdGlvbigpe3JldHVybiBvLkRPTS5ub3NjcmlwdCgpfX0pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt0LnN0b3BQcm9wYWdhdGlvbigpfXZhciBvPW4oNiksaT1vLkRPTS5kaXYscz1uKDE4NiksYT1uKDE4NyksdT1uKDE5MSksbD17b3ZlcmxheTp7YmFzZTpcIlJlYWN0TW9kYWxfX092ZXJsYXlcIixhZnRlck9wZW46XCJSZWFjdE1vZGFsX19PdmVybGF5LS1hZnRlci1vcGVuXCIsYmVmb3JlQ2xvc2U6XCJSZWFjdE1vZGFsX19PdmVybGF5LS1iZWZvcmUtY2xvc2VcIn0sY29udGVudDp7YmFzZTpcIlJlYWN0TW9kYWxfX0NvbnRlbnRcIixhZnRlck9wZW46XCJSZWFjdE1vZGFsX19Db250ZW50LS1hZnRlci1vcGVuXCIsYmVmb3JlQ2xvc2U6XCJSZWFjdE1vZGFsX19Db250ZW50LS1iZWZvcmUtY2xvc2VcIn19LGM9e292ZXJsYXk6e3Bvc2l0aW9uOlwiZml4ZWRcIix0b3A6MCxsZWZ0OjAscmlnaHQ6MCxib3R0b206MCxiYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpXCJ9LGNvbnRlbnQ6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCI0MHB4XCIsbGVmdDpcIjQwcHhcIixyaWdodDpcIjQwcHhcIixib3R0b206XCI0MHB4XCIsYm9yZGVyOlwiMXB4IHNvbGlkICNjY2NcIixiYWNrZ3JvdW5kOlwiI2ZmZlwiLG92ZXJmbG93OlwiYXV0b1wiLFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOlwidG91Y2hcIixib3JkZXJSYWRpdXM6XCI0cHhcIixvdXRsaW5lOlwibm9uZVwiLHBhZGRpbmc6XCIyMHB4XCJ9fTt0LmV4cG9ydHM9by5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6XCJNb2RhbFBvcnRhbFwiLGdldERlZmF1bHRQcm9wczpmdW5jdGlvbigpe3JldHVybntzdHlsZTp7b3ZlcmxheTp7fSxjb250ZW50Ont9fX19LGdldEluaXRpYWxTdGF0ZTpmdW5jdGlvbigpe3JldHVybnthZnRlck9wZW46ITEsYmVmb3JlQ2xvc2U6ITF9fSxjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpe3RoaXMucHJvcHMuaXNPcGVuJiYodGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKCEwKSx0aGlzLm9wZW4oKSl9LGNvbXBvbmVudFdpbGxVbm1vdW50OmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcil9LGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ZnVuY3Rpb24odCl7IXRoaXMucHJvcHMuaXNPcGVuJiZ0LmlzT3Blbj8odGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKCEwKSx0aGlzLm9wZW4oKSk6dGhpcy5wcm9wcy5pc09wZW4mJiF0LmlzT3BlbiYmdGhpcy5jbG9zZSgpfSxjb21wb25lbnREaWRVcGRhdGU6ZnVuY3Rpb24oKXt0aGlzLmZvY3VzQWZ0ZXJSZW5kZXImJih0aGlzLmZvY3VzQ29udGVudCgpLHRoaXMuc2V0Rm9jdXNBZnRlclJlbmRlcighMSkpfSxzZXRGb2N1c0FmdGVyUmVuZGVyOmZ1bmN0aW9uKHQpe3RoaXMuZm9jdXNBZnRlclJlbmRlcj10fSxvcGVuOmZ1bmN0aW9uKCl7cy5zZXR1cFNjb3BlZEZvY3VzKHRoaXMubm9kZSkscy5tYXJrRm9yRm9jdXNMYXRlcigpLHRoaXMuc2V0U3RhdGUoe2lzT3BlbjohMH0sZnVuY3Rpb24oKXt0aGlzLnNldFN0YXRlKHthZnRlck9wZW46ITB9KX0uYmluZCh0aGlzKSl9LGNsb3NlOmZ1bmN0aW9uKCl7dGhpcy5vd25lckhhbmRsZXNDbG9zZSgpJiYodGhpcy5wcm9wcy5jbG9zZVRpbWVvdXRNUz4wP3RoaXMuY2xvc2VXaXRoVGltZW91dCgpOnRoaXMuY2xvc2VXaXRob3V0VGltZW91dCgpKX0sZm9jdXNDb250ZW50OmZ1bmN0aW9uKCl7dGhpcy5yZWZzLmNvbnRlbnQuZm9jdXMoKX0sY2xvc2VXaXRoVGltZW91dDpmdW5jdGlvbigpe3RoaXMuc2V0U3RhdGUoe2JlZm9yZUNsb3NlOiEwfSxmdW5jdGlvbigpe3RoaXMuY2xvc2VUaW1lcj1zZXRUaW1lb3V0KHRoaXMuY2xvc2VXaXRob3V0VGltZW91dCx0aGlzLnByb3BzLmNsb3NlVGltZW91dE1TKX0uYmluZCh0aGlzKSl9LGNsb3NlV2l0aG91dFRpbWVvdXQ6ZnVuY3Rpb24oKXt0aGlzLnNldFN0YXRlKHthZnRlck9wZW46ITEsYmVmb3JlQ2xvc2U6ITF9LHRoaXMuYWZ0ZXJDbG9zZSl9LGFmdGVyQ2xvc2U6ZnVuY3Rpb24oKXtzLnJldHVybkZvY3VzKCkscy50ZWFyZG93blNjb3BlZEZvY3VzKCl9LGhhbmRsZUtleURvd246ZnVuY3Rpb24odCl7OT09dC5rZXlDb2RlJiZhKHRoaXMucmVmcy5jb250ZW50LHQpLDI3PT10LmtleUNvZGUmJnRoaXMucmVxdWVzdENsb3NlKCl9LGhhbmRsZU92ZXJsYXlDbGljazpmdW5jdGlvbigpe3RoaXMub3duZXJIYW5kbGVzQ2xvc2UoKT90aGlzLnJlcXVlc3RDbG9zZSgpOnRoaXMuZm9jdXNDb250ZW50KCl9LHJlcXVlc3RDbG9zZTpmdW5jdGlvbigpe3RoaXMub3duZXJIYW5kbGVzQ2xvc2UoKSYmdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZSgpfSxvd25lckhhbmRsZXNDbG9zZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLm9uUmVxdWVzdENsb3NlfSxzaG91bGRCZUNsb3NlZDpmdW5jdGlvbigpe3JldHVybiF0aGlzLnByb3BzLmlzT3BlbiYmIXRoaXMuc3RhdGUuYmVmb3JlQ2xvc2V9LGJ1aWxkQ2xhc3NOYW1lOmZ1bmN0aW9uKHQsZSl7dmFyIG49bFt0XS5iYXNlO3JldHVybiB0aGlzLnN0YXRlLmFmdGVyT3BlbiYmKG4rPVwiIFwiK2xbdF0uYWZ0ZXJPcGVuKSx0aGlzLnN0YXRlLmJlZm9yZUNsb3NlJiYobis9XCIgXCIrbFt0XS5iZWZvcmVDbG9zZSksZT9uK1wiIFwiK2U6bn0scmVuZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hvdWxkQmVDbG9zZWQoKT9pKCk6aSh7cmVmOlwib3ZlcmxheVwiLGNsYXNzTmFtZTp0aGlzLmJ1aWxkQ2xhc3NOYW1lKFwib3ZlcmxheVwiLHRoaXMucHJvcHMub3ZlcmxheUNsYXNzTmFtZSksc3R5bGU6dSh7fSxjLm92ZXJsYXksdGhpcy5wcm9wcy5zdHlsZS5vdmVybGF5fHx7fSksb25DbGljazp0aGlzLmhhbmRsZU92ZXJsYXlDbGlja30saSh7cmVmOlwiY29udGVudFwiLHN0eWxlOnUoe30sYy5jb250ZW50LHRoaXMucHJvcHMuc3R5bGUuY29udGVudHx8e30pLGNsYXNzTmFtZTp0aGlzLmJ1aWxkQ2xhc3NOYW1lKFwiY29udGVudFwiLHRoaXMucHJvcHMuY2xhc3NOYW1lKSx0YWJJbmRleDpcIi0xXCIsb25DbGljazpyLG9uS2V5RG93bjp0aGlzLmhhbmRsZUtleURvd259LHRoaXMucHJvcHMuY2hpbGRyZW4pKX19KX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpO3Q9XCJsZW5ndGhcImluIGU/ZVswXTplfXU9dHx8dX1mdW5jdGlvbiByKHQpe3ModCksKHR8fHUpLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpfWZ1bmN0aW9uIG8odCl7cyh0KSwodHx8dSkucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIil9ZnVuY3Rpb24gaSh0LGUpe3Q/cihlKTpvKGUpfWZ1bmN0aW9uIHModCl7aWYoIXQmJiF1KXRocm93IG5ldyBFcnJvcihcInJlYWN0LW1vZGFsOiBZb3UgbXVzdCBzZXQgYW4gZWxlbWVudCB3aXRoIGBNb2RhbC5zZXRBcHBFbGVtZW50KGVsKWAgdG8gbWFrZSB0aGlzIGFjY2Vzc2libGVcIil9ZnVuY3Rpb24gYSgpe3U9ZG9jdW1lbnQuYm9keX12YXIgdT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQuYm9keTpudWxsO2UudG9nZ2xlPWksZS5zZXRFbGVtZW50PW4sZS5zaG93PW8sZS5oaWRlPXIsZS5yZXNldEZvclRlc3Rpbmc9YX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dT0hMH1mdW5jdGlvbiBvKHQpe2lmKHUpe2lmKHU9ITEsIXMpcmV0dXJuO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtpZighcy5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSl7dmFyIHQ9aShzKVswXXx8czt0LmZvY3VzKCl9fSwwKX19dmFyIGk9big2OCkscz1udWxsLGE9bnVsbCx1PSExO2UubWFya0ZvckZvY3VzTGF0ZXI9ZnVuY3Rpb24oKXthPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnR9LGUucmV0dXJuRm9jdXM9ZnVuY3Rpb24oKXt0cnl7YS5mb2N1cygpfWNhdGNoKHQpe2NvbnNvbGUud2FybihcIllvdSB0cmllZCB0byByZXR1cm4gZm9jdXMgdG8gXCIrYStcIiBidXQgaXQgaXMgbm90IGluIHRoZSBET00gYW55bW9yZVwiKX1hPW51bGx9LGUuc2V0dXBTY29wZWRGb2N1cz1mdW5jdGlvbih0KXtzPXQsd2luZG93LmFkZEV2ZW50TGlzdGVuZXI/KHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLHIsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLG8sITApKTood2luZG93LmF0dGFjaEV2ZW50KFwib25CbHVyXCIsciksZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbkZvY3VzXCIsbykpfSxlLnRlYXJkb3duU2NvcGVkRm9jdXM9ZnVuY3Rpb24oKXtzPW51bGwsd2luZG93LmFkZEV2ZW50TGlzdGVuZXI/KHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHIpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLG8pKTood2luZG93LmRldGFjaEV2ZW50KFwib25CbHVyXCIsciksZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvbkZvY3VzXCIsbykpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNjgpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuPXIodCksbz1uW2Uuc2hpZnRLZXk/MDpuLmxlbmd0aC0xXSxpPW89PT1kb2N1bWVudC5hY3RpdmVFbGVtZW50fHx0PT09ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtpZihpKXtlLnByZXZlbnREZWZhdWx0KCk7dmFyIHM9bltlLnNoaWZ0S2V5P24ubGVuZ3RoLTE6MF07cy5mb2N1cygpfX19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9bigxODMpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtpZih0LmluZGV4T2YpcmV0dXJuIHQuaW5kZXhPZihlKTtmb3IodmFyIG49MCxyPXQubGVuZ3RoO3I+bjtuKyspaWYodFtuXT09PWUpcmV0dXJuIG47cmV0dXJuLTF9ZnVuY3Rpb24gcih0KXtpZighKHRoaXMgaW5zdGFuY2VvZiByKSlyZXR1cm4gbmV3IHIodCk7dHx8KHQ9e30pLHQubm9kZVR5cGUmJih0PXtlbDp0fSksdGhpcy5vcHRzPXQsdGhpcy5lbD10LmVsfHxkb2N1bWVudC5ib2R5LFwib2JqZWN0XCIhPXR5cGVvZiB0aGlzLmVsJiYodGhpcy5lbD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZWwpKX10LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyByKHQpfSxyLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lbDtpZihlKXtpZihcIlwiPT09ZS5jbGFzc05hbWUpcmV0dXJuIGUuY2xhc3NOYW1lPXQ7dmFyIHI9ZS5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO3JldHVybiBuKHIsdCk+LTE/cjooci5wdXNoKHQpLGUuY2xhc3NOYW1lPXIuam9pbihcIiBcIikscil9fSxyLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lbDtpZihlJiZcIlwiIT09ZS5jbGFzc05hbWUpe3ZhciByPWUuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSxvPW4ocix0KTtyZXR1cm4gbz4tMSYmci5zcGxpY2UobywxKSxlLmNsYXNzTmFtZT1yLmpvaW4oXCIgXCIpLHJ9fSxyLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lbDtpZihlKXt2YXIgcj1lLmNsYXNzTmFtZS5zcGxpdChcIiBcIik7cmV0dXJuIG4ocix0KT4tMX19LHIucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmVsO2UmJih0aGlzLmhhcyh0KT90aGlzLnJlbW92ZSh0KTp0aGlzLmFkZCh0KSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI7IWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89IShcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93fHwhd2luZG93LmRvY3VtZW50fHwhd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpLGk9e2NhblVzZURPTTpvLGNhblVzZVdvcmtlcnM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdvcmtlcixjYW5Vc2VFdmVudExpc3RlbmVyczpvJiYhKCF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciYmIXdpbmRvdy5hdHRhY2hFdmVudCksY2FuVXNlVmlld3BvcnQ6byYmISF3aW5kb3cuc2NyZWVufTtyPWZ1bmN0aW9uKCl7cmV0dXJuIGl9LmNhbGwoZSxuLGUsdCksISh2b2lkIDAhPT1yJiYodC5leHBvcnRzPXIpKX0oKX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe2Zvcih2YXIgcj0tMSxvPXMoZSksaT1vLmxlbmd0aDsrK3I8aTspe3ZhciBhPW9bcl0sdT10W2FdLGw9bih1LGVbYV0sYSx0LGUpOyhsPT09bD9sPT09dTp1IT09dSkmJih2b2lkIDAhPT11fHxhIGluIHQpfHwodFthXT1sKX1yZXR1cm4gdH12YXIgbz1uKDE5MiksaT1uKDE5NCkscz1uKDY5KSxhPWkoZnVuY3Rpb24odCxlLG4pe3JldHVybiBuP3IodCxlLG4pOm8odCxlKX0pO3QuZXhwb3J0cz1hfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3JldHVybiBudWxsPT1lP3Q6byhlLGkoZSksdCl9dmFyIG89bigxOTMpLGk9big2OSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUsbil7bnx8KG49e30pO2Zvcih2YXIgcj0tMSxvPWUubGVuZ3RoOysrcjxvOyl7dmFyIGk9ZVtyXTtuW2ldPXRbaV19cmV0dXJuIG59dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBzKGZ1bmN0aW9uKGUsbil7dmFyIHI9LTEscz1udWxsPT1lPzA6bi5sZW5ndGgsYT1zPjI/bltzLTJdOnZvaWQgMCx1PXM+Mj9uWzJdOnZvaWQgMCxsPXM+MT9uW3MtMV06dm9pZCAwO2ZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhPyhhPW8oYSxsLDUpLHMtPTIpOihhPVwiZnVuY3Rpb25cIj09dHlwZW9mIGw/bDp2b2lkIDAscy09YT8xOjApLHUmJmkoblswXSxuWzFdLHUpJiYoYT0zPnM/dm9pZCAwOmEscz0xKTsrK3I8czspe3ZhciBjPW5bcl07YyYmdChlLGMsYSl9cmV0dXJuIGV9KX12YXIgbz1uKDE5NSksaT1uKDE5Nikscz1uKDE5Nyk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUsbil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm4gcjtpZih2b2lkIDA9PT1lKXJldHVybiB0O3N3aXRjaChuKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB0LmNhbGwoZSxuKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQuY2FsbChlLG4scixvKX07Y2FzZSA0OnJldHVybiBmdW5jdGlvbihuLHIsbyxpKXtyZXR1cm4gdC5jYWxsKGUsbixyLG8saSl9O2Nhc2UgNTpyZXR1cm4gZnVuY3Rpb24obixyLG8saSxzKXtyZXR1cm4gdC5jYWxsKGUsbixyLG8saSxzKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX1mdW5jdGlvbiByKHQpe3JldHVybiB0fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP3ZvaWQgMDplW3RdfX1mdW5jdGlvbiByKHQpe3JldHVybiBudWxsIT10JiZzKGModCkpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gdD1cIm51bWJlclwiPT10eXBlb2YgdHx8dS50ZXN0KHQpPyt0Oi0xLGU9bnVsbD09ZT9sOmUsdD4tMSYmdCUxPT0wJiZlPnR9ZnVuY3Rpb24gaSh0LGUsbil7aWYoIWEobikpcmV0dXJuITE7dmFyIGk9dHlwZW9mIGU7aWYoXCJudW1iZXJcIj09aT9yKG4pJiZvKGUsbi5sZW5ndGgpOlwic3RyaW5nXCI9PWkmJmUgaW4gbil7dmFyIHM9bltlXTtyZXR1cm4gdD09PXQ/dD09PXM6cyE9PXN9cmV0dXJuITF9ZnVuY3Rpb24gcyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmdD4tMSYmdCUxPT0wJiZsPj10fWZ1bmN0aW9uIGEodCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuISF0JiYoXCJvYmplY3RcIj09ZXx8XCJmdW5jdGlvblwiPT1lKX12YXIgdT0vXlxcZCskLyxsPTkwMDcxOTkyNTQ3NDA5OTEsYz1uKFwibGVuZ3RoXCIpO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3Iocik7cmV0dXJuIGU9byh2b2lkIDA9PT1lP3QubGVuZ3RoLTE6K2V8fDAsMCksZnVuY3Rpb24oKXtmb3IodmFyIG49YXJndW1lbnRzLHI9LTEsaT1vKG4ubGVuZ3RoLWUsMCkscz1BcnJheShpKTsrK3I8aTspc1tyXT1uW2Urcl07c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gdC5jYWxsKHRoaXMscyk7Y2FzZSAxOnJldHVybiB0LmNhbGwodGhpcyxuWzBdLHMpO2Nhc2UgMjpyZXR1cm4gdC5jYWxsKHRoaXMsblswXSxuWzFdLHMpfXZhciBhPUFycmF5KGUrMSk7Zm9yKHI9LTE7KytyPGU7KWFbcl09bltyXTtyZXR1cm4gYVtlXT1zLHQuYXBwbHkodGhpcyxhKX19dmFyIHI9XCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsbz1NYXRoLm1heDt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiEhdCYmXCJvYmplY3RcIj09dHlwZW9mIHR9ZnVuY3Rpb24gcih0LGUpe3ZhciBuPW51bGw9PXQ/dm9pZCAwOnRbZV07cmV0dXJuIHMobik/bjp2b2lkIDB9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gaSh0KSYmZi5jYWxsKHQpPT1hfWZ1bmN0aW9uIGkodCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuISF0JiYoXCJvYmplY3RcIj09ZXx8XCJmdW5jdGlvblwiPT1lKX1mdW5jdGlvbiBzKHQpe3JldHVybiBudWxsPT10PyExOm8odCk/aC50ZXN0KGMuY2FsbCh0KSk6bih0KSYmdS50ZXN0KHQpfXZhciBhPVwiW29iamVjdCBGdW5jdGlvbl1cIix1PS9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sbD1PYmplY3QucHJvdG90eXBlLGM9RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLHA9bC5oYXNPd25Qcm9wZXJ0eSxmPWwudG9TdHJpbmcsaD1SZWdFeHAoXCJeXCIrYy5jYWxsKHApLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csXCIkMS4qP1wiKStcIiRcIik7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4hIXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fWZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP3ZvaWQgMDplW3RdfX1mdW5jdGlvbiBvKHQpe3JldHVybiBudWxsIT10JiZpKHAodCkpfWZ1bmN0aW9uIGkodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJnQ+LTEmJnQlMT09MCYmYz49dH1mdW5jdGlvbiBzKHQpe3JldHVybiBuKHQpJiZvKHQpJiZ1LmNhbGwodCxcImNhbGxlZVwiKSYmIWwuY2FsbCh0LFwiY2FsbGVlXCIpfXZhciBhPU9iamVjdC5wcm90b3R5cGUsdT1hLmhhc093blByb3BlcnR5LGw9YS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxjPTkwMDcxOTkyNTQ3NDA5OTEscD1yKFwibGVuZ3RoXCIpO3QuZXhwb3J0cz1zfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT10eXBlb2YgdH1mdW5jdGlvbiByKHQsZSl7dmFyIG49bnVsbD09dD92b2lkIDA6dFtlXTtyZXR1cm4gYShuKT9uOnZvaWQgMH1mdW5jdGlvbiBvKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZ0Pi0xJiZ0JTE9PTAmJm0+PXR9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gcyh0KSYmZC5jYWxsKHQpPT1sfWZ1bmN0aW9uIHModCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuISF0JiYoXCJvYmplY3RcIj09ZXx8XCJmdW5jdGlvblwiPT1lKX1mdW5jdGlvbiBhKHQpe3JldHVybiBudWxsPT10PyExOmkodCk/eS50ZXN0KGYuY2FsbCh0KSk6bih0KSYmYy50ZXN0KHQpfXZhciB1PVwiW29iamVjdCBBcnJheV1cIixsPVwiW29iamVjdCBGdW5jdGlvbl1cIixjPS9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8scD1PYmplY3QucHJvdG90eXBlLGY9RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLGg9cC5oYXNPd25Qcm9wZXJ0eSxkPXAudG9TdHJpbmcseT1SZWdFeHAoXCJeXCIrZi5jYWxsKGgpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csXCIkMS4qP1wiKStcIiRcIiksdj1yKEFycmF5LFwiaXNBcnJheVwiKSxtPTkwMDcxOTkyNTQ3NDA5OTEsZz12fHxmdW5jdGlvbih0KXtyZXR1cm4gbih0KSYmbyh0Lmxlbmd0aCkmJmQuY2FsbCh0KT09dX07dC5leHBvcnRzPWd9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXN9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWF9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXV9XSkpfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnRzLm1pbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2NhcnRvZGItY2xpZW50XCIpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBmdW5jdGlvbiBDYXJ0b0RCQ2xpZW50KGFjY291bnROYW1lLG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgb3B0aW9ucy5hcGlyb290ICAgICA9IG9wdGlvbnMuYXBpcm9vdCAgICAgIHx8IFwiaHR0cDovL3thY2NvdW50TmFtZX0uY2FydG9kYi5jb20vYXBpL3YyL1wiO1xuICAgIG9wdGlvbnMuZm9ybWF0ICAgICAgPSBvcHRpb25zLmZvcm1hdCAgICAgICB8fCBcIkdlb0pTT05cIjtcbiAgICBvcHRpb25zLmFjY291bnROYW1lID0gb3B0aW9ucy5hY2NvdW50TmFtZSAgfHwgYWNjb3VudE5hbWU7XG5cbiAgICAvL1xuICAgIC8vIFJlcXVlc3QgcmVtb3RlIGRhdGFcbiAgICAvL1xuICAgIGZ1bmN0aW9uIHJlcXVlc3QodXJpLCBjYWxsYmFjaykge1xuXG4gICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICB2YXIgeG1sSHR0cCA9IG51bGw7XG5cbiAgICAgICAgeG1sSHR0cCA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgoeG1sSHR0cC5yZWFkeVN0YXRlfDApID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoKHhtbEh0dHAuc3RhdHVzfDApID09PSAyMDAgKSB7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeG1sSHR0cCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjayh4bWxIdHRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeG1sSHR0cC5vcGVuKCBcIkdFVFwiLCB1cmksIHRydWUgKTtcbiAgICAgICAgcmV0dXJuIHhtbEh0dHAuc2VuZCggbnVsbCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQnVpbGQgYSBzdHJpbmcgZnJvbSBhIHRlbXBsYXRlIGFuZCBkYXRhXG4gICAgLy9cbiAgICBmdW5jdGlvbiBidWlsZFRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgICB2YXIgb3V0U3RyaW5nID0gdGVtcGxhdGU7XG5cbiAgICAgIGZvciAodmFyIGkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIG91dFN0cmluZyA9IG91dFN0cmluZy5zcGxpdChcIntcIiArIGkgKyBcIn1cIikuam9pbihkYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0U3RyaW5nO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVxdWVzdCBmcm9tIHRoZSBDYXJ0b0RiIFNRTCBlbmRwb2ludFxuICAgIC8vXG4gICAgZnVuY3Rpb24gc3FsUmVxdWVzdChzcWwsIGNhbGxiYWNrLCBfb3B0aW9ucykge1xuXG4gICAgICBfb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9O1xuXG4gICAgICAvL1xuICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgIC8vXG4gICAgICBpZiAoT2JqZWN0LmtleXMoX29wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIF9vcHRpb25zKSB7XG5cbiAgICAgICAgICBpZiAoX29wdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcblxuICAgICAgICAgICAgb3B0aW9uc1tpXSA9IF9vcHRpb25zW2ldO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVybCA9IGJ1aWxkVGVtcGxhdGUoW1xuICAgICAgICBidWlsZFRlbXBsYXRlKG9wdGlvbnMuYXBpcm9vdCwgb3B0aW9ucyksXG4gICAgICAgIFwic3FsXCIsXG4gICAgICAgIFwiP2Zvcm1hdD1cIiArIG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICBcIiZxPVwiICsgc3FsXG4gICAgICBdLmpvaW4oXCJcIiksIG9wdGlvbnMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5kYW5nZXJvdXNseUV4cG9zZWRBUElLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRXhwb3NpbmcgQVBJIGtleSBpbiBVUkwhIERvIG5vdCBwdXNoIHRoaXMgdG8gcHJvZHVjdGlvbi5cIik7XG4gICAgICAgIHVybCArPSAoXCImYXBpX2tleT1cIiArIG9wdGlvbnMuZGFuZ2Vyb3VzbHlFeHBvc2VkQVBJS2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcXVlc3QodXJsLFxuICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpLCByZXNwb25zZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUHJvbWlzZSByZXF1ZXN0XG4gICAgZnVuY3Rpb24gcmVxdWVzdFByb21pc2UocGFyYW1zKSB7XG4gICAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMocGFyYW1zLm9wdGlvbnMpO1xuXG4gICAgICB2YXIgdXJsID0gKHBhcmFtcy5zcWwpID8gYnVpbGRUZW1wbGF0ZShbXG4gICAgICAgICAgICAgICAgICBidWlsZFRlbXBsYXRlKG9wdHMuYXBpcm9vdCwgb3B0cyksXG4gICAgICAgICAgICAgICAgICBcInNxbFwiLFxuICAgICAgICAgICAgICAgICAgXCI/Zm9ybWF0PVwiICsgb3B0cy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgICBcIiZxPVwiICsgcGFyYW1zLnNxbFxuICAgICAgICAgICAgICAgIF0uam9pbihcIlwiKSwgb3B0cykgOiBwYXJhbXMudXJsO1xuXG4gICAgICB2YXIga2V5ID0gcGFyYW1zLmtleTtcblxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAvLyBEbyB0aGUgdXN1YWwgWEhSIHN0dWZmXG4gICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwpO1xuXG4gICAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBjYWxsZWQgZXZlbiBvbiA0MDQgZXRjXG4gICAgICAgICAgICAvLyBzbyBjaGVjayB0aGUgc3RhdHVzXG4gICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoIHRoZSByZXNwb25zZSB0ZXh0XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiByZXEucmVzcG9uc2UgfHwgcmVxLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICBpZDoga2V5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZWplY3Qgd2l0aCB0aGUgc3RhdHVzIHRleHRcbiAgICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBob3BlZnVsbHkgYmUgYSBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogRXJyb3IocmVxLnN0YXR1c1RleHQpLFxuICAgICAgICAgICAgICAgIGlkOiBrZXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEhhbmRsZSBuZXR3b3JrIGVycm9yc1xuICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICBwYXlsb2FkOiBFcnJvcihcIk5ldHdvcmsgRXJyb3JcIiksXG4gICAgICAgICAgICAgIGlkOiBrZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBNYWtlIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxLnNlbmQoKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBwYXlsb2FkOiBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IG5vdCBzdXBwb3J0ZWRcIiksXG4gICAgICAgICAgICBpZDoga2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG5cblxuICAgIH1cblxuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIF9vcHRpb25zID0gX29wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciByc3AgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IChfb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSA/IF9vcHRpb25zW2tleV0gOiBvcHRpb25zW2tleV07XG4gICAgICAgIHJzcFtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByc3A7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBQdWJsaWMgaW50ZXJmYWNlXG4gICAgLy9cbiAgICB0aGF0LnNxbFJlcXVlc3QgPSBzcWxSZXF1ZXN0O1xuICAgIHRoYXQucmVxdWVzdFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZTtcbiAgICB0aGF0LnJlcXVlc3RQcm9taXNlUGFyYWxsZWwgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICBxdWV1ZS5tYXAoZnVuY3Rpb24ocSl7XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3RQcm9taXNlKHEpLnRoZW4oZnVuY3Rpb24ocnNwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByZXNwb25zZTogcnNwLFxuICAgICAgICAgICAgICBrZXk6IHJzcC5pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfTtcblxuICAgIHRoYXQucmVxdWVzdFByb21pc2VKU09OID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdFByb21pc2UocGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJzcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3BvbnNlOiBKU09OLnBhcnNlKHJzcC5wYXlsb2FkKSxcbiAgICAgICAgICBrZXk6IHJzcC5pZFxuICAgICAgICB9O1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhhdC5yZXF1ZXN0UHJvbWlzZVBhcmFsbGVsSlNPTiA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHF1ZXVlLm1hcCh0aGF0LnJlcXVlc3RQcm9taXNlSlNPTilcbiAgICAgIClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoYXQ7XG5cbiAgfVxuXG5cblxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0b0RCQ2xpZW50O1xuICB9XG5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBhbiBBTUQgbW9kdWxlXG4gIC8vXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbmUoQ2FydG9EQkNsaWVudCk7XG4gIH1cblxuICAvL1xuICAvLyBJZiBqdXN0IGV4cG9ydHMgYW5kIGl0J3MgYW4gb2JqZWN0XG4gIC8vXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZXhwb3J0cy5DYXJ0b0RCQ2xpZW50ID0gQ2FydG9EQkNsaWVudDtcbiAgfVxuXG4gIC8vXG4gIC8vIElmIG5vbmUgb2YgdGhvc2UsIGFkZCBpdCB0byBXaW5kb3cgKGFzIGxvbmcgYXMgdGhlcmUgaXMgbm90aGluZyBuYW1lZCBzYW1lc2llcylcbiAgLy9cbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKCF3aW5kb3cuU1RNTikge1xuICAgICAgd2luZG93LlNUTU4gPSB7fTtcbiAgICB9XG4gICAgd2luZG93LlNUTU4uQ2FydG9EQkNsaWVudCA9IENhcnRvREJDbGllbnQ7XG4gIH1cblxufSgpKTsiLCIhZnVuY3Rpb24oKSB7XG4gIHZhciBkMyA9IHtcbiAgICB2ZXJzaW9uOiBcIjMuNS4xN1wiXG4gIH07XG4gIHZhciBkM19hcnJheVNsaWNlID0gW10uc2xpY2UsIGQzX2FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuICAgIHJldHVybiBkM19hcnJheVNsaWNlLmNhbGwobGlzdCk7XG4gIH07XG4gIHZhciBkM19kb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG4gIGZ1bmN0aW9uIGQzX2RvY3VtZW50RWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlLmRvY3VtZW50IHx8IG5vZGUpLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICBmdW5jdGlvbiBkM193aW5kb3cobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG5vZGUuZG9jdW1lbnQgJiYgbm9kZSB8fCBub2RlLmRlZmF1bHRWaWV3KTtcbiAgfVxuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgZDNfYXJyYXkoZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNoaWxkTm9kZXMpWzBdLm5vZGVUeXBlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGQzX2FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuICAgICAgICB2YXIgaSA9IGxpc3QubGVuZ3RoLCBhcnJheSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgd2hpbGUgKGktLSkgYXJyYXlbaV0gPSBsaXN0W2ldO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAoIURhdGUubm93KSBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgfTtcbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGQzX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIikuc3R5bGUuc2V0UHJvcGVydHkoXCJvcGFjaXR5XCIsIDAsIFwiXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2YXIgZDNfZWxlbWVudF9wcm90b3R5cGUgPSB0aGlzLkVsZW1lbnQucHJvdG90eXBlLCBkM19lbGVtZW50X3NldEF0dHJpYnV0ZSA9IGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZSwgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGVOUyA9IGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TLCBkM19zdHlsZV9wcm90b3R5cGUgPSB0aGlzLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLCBkM19zdHlsZV9zZXRQcm9wZXJ0eSA9IGQzX3N0eWxlX3Byb3RvdHlwZS5zZXRQcm9wZXJ0eTtcbiAgICAgIGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsdWUgKyBcIlwiKTtcbiAgICAgIH07XG4gICAgICBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uKHNwYWNlLCBsb2NhbCwgdmFsdWUpIHtcbiAgICAgICAgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIHNwYWNlLCBsb2NhbCwgdmFsdWUgKyBcIlwiKTtcbiAgICAgIH07XG4gICAgICBkM19zdHlsZV9wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgZDNfc3R5bGVfc2V0UHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSArIFwiXCIsIHByaW9yaXR5KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGQzLmFzY2VuZGluZyA9IGQzX2FzY2VuZGluZztcbiAgZnVuY3Rpb24gZDNfYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gIH1cbiAgZDMuZGVzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG4gIH07XG4gIGQzLm1pbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBkMy5tYXggPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgZDMuZXh0ZW50ID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiLCBjO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYyA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbIGEsIGMgXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbnVtYmVyKHgpIHtcbiAgICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xuICB9XG4gIGZ1bmN0aW9uIGQzX251bWVyaWMoeCkge1xuICAgIHJldHVybiAhaXNOYU4oeCk7XG4gIH1cbiAgZDMuc3VtID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSArYXJyYXlbaV0pKSBzICs9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gK2YuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkgcyArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcbiAgZDMubWVhbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTEsIGogPSBuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH1cbiAgICBpZiAoaikgcmV0dXJuIHMgLyBqO1xuICB9O1xuICBkMy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgcCkge1xuICAgIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLCBoID0gTWF0aC5mbG9vcihIKSwgdiA9ICt2YWx1ZXNbaCAtIDFdLCBlID0gSCAtIGg7XG4gICAgcmV0dXJuIGUgPyB2ICsgZSAqICh2YWx1ZXNbaF0gLSB2KSA6IHY7XG4gIH07XG4gIGQzLm1lZGlhbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIG51bWJlcnMgPSBbXSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG4gICAgaWYgKG51bWJlcnMubGVuZ3RoKSByZXR1cm4gZDMucXVhbnRpbGUobnVtYmVycy5zb3J0KGQzX2FzY2VuZGluZyksIC41KTtcbiAgfTtcbiAgZDMudmFyaWFuY2UgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoLCBtID0gMCwgYSwgZCwgcyA9IDAsIGkgPSAtMSwgaiA9IDA7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIHtcbiAgICAgICAgICBkID0gYSAtIG07XG4gICAgICAgICAgbSArPSBkIC8gKytqO1xuICAgICAgICAgIHMgKz0gZCAqIChhIC0gbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGogPiAxKSByZXR1cm4gcyAvIChqIC0gMSk7XG4gIH07XG4gIGQzLmRldmlhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZDMudmFyaWFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Jpc2VjdG9yKGNvbXBhcmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgbG8gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTsgZWxzZSBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9LFxuICAgICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGxvID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDsgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Jpc2VjdCA9IGQzX2Jpc2VjdG9yKGQzX2FzY2VuZGluZyk7XG4gIGQzLmJpc2VjdExlZnQgPSBkM19iaXNlY3QubGVmdDtcbiAgZDMuYmlzZWN0ID0gZDMuYmlzZWN0UmlnaHQgPSBkM19iaXNlY3QucmlnaHQ7XG4gIGQzLmJpc2VjdG9yID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBkM19iaXNlY3RvcihmLmxlbmd0aCA9PT0gMSA/IGZ1bmN0aW9uKGQsIHgpIHtcbiAgICAgIHJldHVybiBkM19hc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgfSA6IGYpO1xuICB9O1xuICBkMy5zaHVmZmxlID0gZnVuY3Rpb24oYXJyYXksIGkwLCBpMSkge1xuICAgIGlmICgobSA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMykge1xuICAgICAgaTEgPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobSA8IDIpIGkwID0gMDtcbiAgICB9XG4gICAgdmFyIG0gPSBpMSAtIGkwLCB0LCBpO1xuICAgIHdoaWxlIChtKSB7XG4gICAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgICB0ID0gYXJyYXlbbSArIGkwXSwgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF0sIGFycmF5W2kgKyBpMF0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG4gIGQzLnBlcm11dGUgPSBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gICAgcmV0dXJuIHBlcm11dGVzO1xuICB9O1xuICBkMy5wYWlycyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcDAsIHAxID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICAgIHdoaWxlIChpIDwgbikgcGFpcnNbaV0gPSBbIHAwID0gcDEsIHAxID0gYXJyYXlbKytpXSBdO1xuICAgIHJldHVybiBwYWlycztcbiAgfTtcbiAgZDMudHJhbnNwb3NlID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgaWYgKCEobiA9IG1hdHJpeC5sZW5ndGgpKSByZXR1cm4gW107XG4gICAgZm9yICh2YXIgaSA9IC0xLCBtID0gZDMubWluKG1hdHJpeCwgZDNfdHJhbnNwb3NlTGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOyApIHtcbiAgICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3NlO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc3Bvc2VMZW5ndGgoZCkge1xuICAgIHJldHVybiBkLmxlbmd0aDtcbiAgfVxuICBkMy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMudHJhbnNwb3NlKGFyZ3VtZW50cyk7XG4gIH07XG4gIGQzLmtleXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuICBkMy52YWx1ZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG4gIGQzLmVudHJpZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIGVudHJpZXMucHVzaCh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiBtYXBba2V5XVxuICAgIH0pO1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9O1xuICBkMy5tZXJnZSA9IGZ1bmN0aW9uKGFycmF5cykge1xuICAgIHZhciBuID0gYXJyYXlzLmxlbmd0aCwgbSwgaSA9IC0xLCBqID0gMCwgbWVyZ2VkLCBhcnJheTtcbiAgICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9O1xuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIGQzLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKFwiaW5maW5pdGUgcmFuZ2VcIik7XG4gICAgdmFyIHJhbmdlID0gW10sIGsgPSBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoYWJzKHN0ZXApKSwgaSA9IC0xLCBqO1xuICAgIHN0YXJ0ICo9IGssIHN0b3AgKj0gaywgc3RlcCAqPSBrO1xuICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaiAvIGspOyBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGogLyBrKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JhbmdlX2ludGVnZXJTY2FsZSh4KSB7XG4gICAgdmFyIGsgPSAxO1xuICAgIHdoaWxlICh4ICogayAlIDEpIGsgKj0gMTA7XG4gICAgcmV0dXJuIGs7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY2xhc3MoY3RvciwgcHJvcGVydGllcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGQzLm1hcCA9IGZ1bmN0aW9uKG9iamVjdCwgZikge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCk7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIGQzX01hcCkge1xuICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoLCBvO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7IGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZi5jYWxsKG9iamVjdCwgbyA9IG9iamVjdFtpXSwgaSksIG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuICBmdW5jdGlvbiBkM19NYXAoKSB7XG4gICAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICB2YXIgZDNfbWFwX3Byb3RvID0gXCJfX3Byb3RvX19cIiwgZDNfbWFwX3plcm8gPSBcIlxceDAwXCI7XG4gIGQzX2NsYXNzKGQzX01hcCwge1xuICAgIGhhczogZDNfbWFwX2hhcyxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5KV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAgICBrZXlzOiBkM19tYXBfa2V5cyxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgdmFsdWVzLnB1c2godGhpcy5fW2tleV0pO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGVudHJpZXMucHVzaCh7XG4gICAgICAgIGtleTogZDNfbWFwX3VuZXNjYXBlKGtleSksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9ba2V5XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZW50cmllcztcbiAgICB9LFxuICAgIHNpemU6IGQzX21hcF9zaXplLFxuICAgIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpLCB0aGlzLl9ba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZDNfbWFwX2VzY2FwZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSArPSBcIlwiKSA9PT0gZDNfbWFwX3Byb3RvIHx8IGtleVswXSA9PT0gZDNfbWFwX3plcm8gPyBkM19tYXBfemVybyArIGtleSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfdW5lc2NhcGUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgKz0gXCJcIilbMF0gPT09IGQzX21hcF96ZXJvID8ga2V5LnNsaWNlKDEpIDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9oYXMoa2V5KSB7XG4gICAgcmV0dXJuIGQzX21hcF9lc2NhcGUoa2V5KSBpbiB0aGlzLl87XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3JlbW92ZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSA9IGQzX21hcF9lc2NhcGUoa2V5KSkgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba2V5XTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfa2V5cygpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGtleXMucHVzaChkM19tYXBfdW5lc2NhcGUoa2V5KSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3NpemUoKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pICsrc2l6ZTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfZW1wdHkoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGQzLm5lc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmVzdCA9IHt9LCBrZXlzID0gW10sIHNvcnRLZXlzID0gW10sIHNvcnRWYWx1ZXMsIHJvbGx1cDtcbiAgICBmdW5jdGlvbiBtYXAobWFwVHlwZSwgYXJyYXksIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiByb2xsdXAgPyByb2xsdXAuY2FsbChuZXN0LCBhcnJheSkgOiBzb3J0VmFsdWVzID8gYXJyYXkuc29ydChzb3J0VmFsdWVzKSA6IGFycmF5O1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwga2V5ID0ga2V5c1tkZXB0aCsrXSwga2V5VmFsdWUsIG9iamVjdCwgc2V0dGVyLCB2YWx1ZXNCeUtleSA9IG5ldyBkM19NYXAoKSwgdmFsdWVzO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9IHZhbHVlc0J5S2V5LmdldChrZXlWYWx1ZSA9IGtleShvYmplY3QgPSBhcnJheVtpXSkpKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFsgb2JqZWN0IF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFwVHlwZSkge1xuICAgICAgICBvYmplY3QgPSBtYXBUeXBlKCk7XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGtleVZhbHVlLCB2YWx1ZXMpIHtcbiAgICAgICAgICBvYmplY3Quc2V0KGtleVZhbHVlLCBtYXAobWFwVHlwZSwgdmFsdWVzLCBkZXB0aCkpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGtleVZhbHVlLCB2YWx1ZXMpIHtcbiAgICAgICAgICBvYmplY3Rba2V5VmFsdWVdID0gbWFwKG1hcFR5cGUsIHZhbHVlcywgZGVwdGgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWVzQnlLZXkuZm9yRWFjaChzZXR0ZXIpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50cmllcyhtYXAsIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XG4gICAgICB2YXIgYXJyYXkgPSBbXSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoKytdO1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24oa2V5LCBrZXlNYXApIHtcbiAgICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWVzOiBlbnRyaWVzKGtleU1hcCwgZGVwdGgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydEtleSA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpO1xuICAgICAgfSkgOiBhcnJheTtcbiAgICB9XG4gICAgbmVzdC5tYXAgPSBmdW5jdGlvbihhcnJheSwgbWFwVHlwZSkge1xuICAgICAgcmV0dXJuIG1hcChtYXBUeXBlLCBhcnJheSwgMCk7XG4gICAgfTtcbiAgICBuZXN0LmVudHJpZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgcmV0dXJuIGVudHJpZXMobWFwKGQzLm1hcCwgYXJyYXksIDApLCAwKTtcbiAgICB9O1xuICAgIG5lc3Qua2V5ID0gZnVuY3Rpb24oZCkge1xuICAgICAga2V5cy5wdXNoKGQpO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnNvcnRLZXlzID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgIHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5zb3J0VmFsdWVzID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgIHNvcnRWYWx1ZXMgPSBvcmRlcjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5yb2xsdXAgPSBmdW5jdGlvbihmKSB7XG4gICAgICByb2xsdXAgPSBmO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gbmVzdDtcbiAgfTtcbiAgZDMuc2V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgc2V0ID0gbmV3IGQzX1NldCgpO1xuICAgIGlmIChhcnJheSkgZm9yICh2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGg7IGkgPCBuOyArK2kpIHNldC5hZGQoYXJyYXlbaV0pO1xuICAgIHJldHVybiBzZXQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX1NldCgpIHtcbiAgICB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGQzX2NsYXNzKGQzX1NldCwge1xuICAgIGhhczogZDNfbWFwX2hhcyxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5ICs9IFwiXCIpXSA9IHRydWU7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBkM19tYXBfcmVtb3ZlLFxuICAgIHZhbHVlczogZDNfbWFwX2tleXMsXG4gICAgc2l6ZTogZDNfbWFwX3NpemUsXG4gICAgZW1wdHk6IGQzX21hcF9lbXB0eSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBmLmNhbGwodGhpcywgZDNfbWFwX3VuZXNjYXBlKGtleSkpO1xuICAgIH1cbiAgfSk7XG4gIGQzLmJlaGF2aW9yID0ge307XG4gIGZ1bmN0aW9uIGQzX2lkZW50aXR5KGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuICBkMy5yZWJpbmQgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldGhvZDtcbiAgICB3aGlsZSAoKytpIDwgbikgdGFyZ2V0W21ldGhvZCA9IGFyZ3VtZW50c1tpXV0gPSBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIHNvdXJjZVttZXRob2RdKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHZhbHVlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdmVuZG9yU3ltYm9sKG9iamVjdCwgbmFtZSkge1xuICAgIGlmIChuYW1lIGluIG9iamVjdCkgcmV0dXJuIG5hbWU7XG4gICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZDNfdmVuZG9yUHJlZml4ZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcHJlZml4TmFtZSA9IGQzX3ZlbmRvclByZWZpeGVzW2ldICsgbmFtZTtcbiAgICAgIGlmIChwcmVmaXhOYW1lIGluIG9iamVjdCkgcmV0dXJuIHByZWZpeE5hbWU7XG4gICAgfVxuICB9XG4gIHZhciBkM192ZW5kb3JQcmVmaXhlcyA9IFsgXCJ3ZWJraXRcIiwgXCJtc1wiLCBcIm1velwiLCBcIk1velwiLCBcIm9cIiwgXCJPXCIgXTtcbiAgZnVuY3Rpb24gZDNfbm9vcCgpIHt9XG4gIGQzLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoKCksIGkgPSAtMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaCgpIHt9XG4gIGQzX2Rpc3BhdGNoLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCBuYW1lID0gXCJcIjtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBuYW1lID0gdHlwZS5zbGljZShpICsgMSk7XG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHRoaXNbdHlwZV0ub24obmFtZSkgOiB0aGlzW3R5cGVdLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIGZvciAodHlwZSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHR5cGUpKSB0aGlzW3R5cGVdLm9uKG5hbWUsIG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXSwgbGlzdGVuZXJCeU5hbWUgPSBuZXcgZDNfTWFwKCk7XG4gICAgZnVuY3Rpb24gZXZlbnQoKSB7XG4gICAgICB2YXIgeiA9IGxpc3RlbmVycywgaSA9IC0xLCBuID0gei5sZW5ndGgsIGw7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGwgPSB6W2ldLm9uKSBsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2g7XG4gICAgfVxuICAgIGV2ZW50Lm9uID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsID0gbGlzdGVuZXJCeU5hbWUuZ2V0KG5hbWUpLCBpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gbCAmJiBsLm9uO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgbC5vbiA9IG51bGw7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgwLCBpID0gbGlzdGVuZXJzLmluZGV4T2YobCkpLmNvbmNhdChsaXN0ZW5lcnMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgbGlzdGVuZXJCeU5hbWUucmVtb3ZlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lckJ5TmFtZS5zZXQobmFtZSwge1xuICAgICAgICBvbjogbGlzdGVuZXJcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaDtcbiAgICB9O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBkMy5ldmVudCA9IG51bGw7XG4gIGZ1bmN0aW9uIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKSB7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19ldmVudFNvdXJjZSgpIHtcbiAgICB2YXIgZSA9IGQzLmV2ZW50LCBzO1xuICAgIHdoaWxlIChzID0gZS5zb3VyY2VFdmVudCkgZSA9IHM7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZXZlbnREaXNwYXRjaCh0YXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2goKSwgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkaXNwYXRjaFthcmd1bWVudHNbaV1dID0gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpO1xuICAgIGRpc3BhdGNoLm9mID0gZnVuY3Rpb24odGhpeiwgYXJndW1lbnR6KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZTEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZTAgPSBlMS5zb3VyY2VFdmVudCA9IGQzLmV2ZW50O1xuICAgICAgICAgIGUxLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICBkMy5ldmVudCA9IGUxO1xuICAgICAgICAgIGRpc3BhdGNoW2UxLnR5cGVdLmFwcGx5KHRoaXosIGFyZ3VtZW50eik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDMuZXZlbnQgPSBlMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBkaXNwYXRjaDtcbiAgfVxuICBkMy5yZXF1b3RlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoZDNfcmVxdW90ZV9yZSwgXCJcXFxcJCZcIik7XG4gIH07XG4gIHZhciBkM19yZXF1b3RlX3JlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuICB2YXIgZDNfc3ViY2xhc3MgPSB7fS5fX3Byb3RvX18gPyBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gIH0gOiBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3RvdHlwZSkgb2JqZWN0W3Byb3BlcnR5XSA9IHByb3RvdHlwZVtwcm9wZXJ0eV07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbihncm91cHMpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3NlbGVjdGlvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgIHJldHVybiBuLnF1ZXJ5U2VsZWN0b3Iocyk7XG4gIH0sIGQzX3NlbGVjdEFsbCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICByZXR1cm4gbi5xdWVyeVNlbGVjdG9yQWxsKHMpO1xuICB9LCBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykge1xuICAgIHZhciBkM19zZWxlY3RNYXRjaGVyID0gbi5tYXRjaGVzIHx8IG5bZDNfdmVuZG9yU3ltYm9sKG4sIFwibWF0Y2hlc1NlbGVjdG9yXCIpXTtcbiAgICBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXIuY2FsbChuLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVzKG4sIHMpO1xuICB9O1xuICBpZiAodHlwZW9mIFNpenpsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgICAgcmV0dXJuIFNpenpsZShzLCBuKVswXSB8fCBudWxsO1xuICAgIH07XG4gICAgZDNfc2VsZWN0QWxsID0gU2l6emxlO1xuICAgIGQzX3NlbGVjdE1hdGNoZXMgPSBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yO1xuICB9XG4gIGQzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zZWxlY3QoZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvblByb3RvdHlwZSA9IGQzLnNlbGVjdGlvbi5wcm90b3R5cGUgPSBbXTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgZ3JvdXAsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IChncm91cCA9IHRoaXNbal0pLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgICAgICAgaWYgKHN1Ym5vZGUgJiYgXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdChzZWxlY3RvciwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IGQzX2FycmF5KHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKTtcbiAgICAgICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0QWxsKHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19uc1hodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIHZhciBkM19uc1ByZWZpeCA9IHtcbiAgICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB4aHRtbDogZDNfbnNYaHRtbCxcbiAgICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcbiAgZDMubnMgPSB7XG4gICAgcHJlZml4OiBkM19uc1ByZWZpeCxcbiAgICBxdWFsaWZ5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIjpcIiksIHByZWZpeCA9IG5hbWU7XG4gICAgICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gICAgICByZXR1cm4gZDNfbnNQcmVmaXguaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtcbiAgICAgICAgc3BhY2U6IGQzX25zUHJlZml4W3ByZWZpeF0sXG4gICAgICAgIGxvY2FsOiBuYW1lXG4gICAgICB9IDogbmFtZTtcbiAgICB9XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgICAgICBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWUubG9jYWwgPyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpIDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fYXR0cih2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSk7XG4gICAgZnVuY3Rpb24gYXR0ck51bGwoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ck51bGxOUygpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJDb25zdGFudCgpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7IGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTsgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIHgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5hbWUubG9jYWwgPyBhdHRyTnVsbE5TIDogYXR0ck51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbiA6IG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudDtcbiAgfVxuICBmdW5jdGlvbiBkM19jb2xsYXBzZShzKSB7XG4gICAgcmV0dXJuIHMudHJpbSgpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5jbGFzc2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpLCBuID0gKG5hbWUgPSBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKSkubGVuZ3RoLCBpID0gLTE7XG4gICAgICAgIGlmICh2YWx1ZSA9IG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghdmFsdWUuY29udGFpbnMobmFtZVtpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lW2ldKS50ZXN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2NsYXNzZWQodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58XFxcXHMrKVwiICsgZDMucmVxdW90ZShuYW1lKSArIFwiKD86XFxcXHMrfCQpXCIsIFwiZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKSB7XG4gICAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKS5tYXAoZDNfc2VsZWN0aW9uX2NsYXNzZWROYW1lKTtcbiAgICB2YXIgbiA9IG5hbWUubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIGNsYXNzZWRDb25zdGFudCgpIHtcbiAgICAgIHZhciBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikgbmFtZVtpXSh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gLTEsIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG5hbWVbaV0odGhpcywgeCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNsYXNzZWRGdW5jdGlvbiA6IGNsYXNzZWRDb25zdGFudDtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZE5hbWUobmFtZSkge1xuICAgIHZhciByZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAoYyA9IG5vZGUuY2xhc3NMaXN0KSByZXR1cm4gdmFsdWUgPyBjLmFkZChuYW1lKSA6IGMucmVtb3ZlKG5hbWUpO1xuICAgICAgdmFyIGMgPSBub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKCFyZS50ZXN0KGMpKSBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGQzX2NvbGxhcHNlKGMgKyBcIiBcIiArIG5hbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZDNfY29sbGFwc2UoYy5yZXBsYWNlKHJlLCBcIiBcIikpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIHZhbHVlID0gXCJcIjtcbiAgICAgICAgZm9yIChwcmlvcml0eSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3N0eWxlKHByaW9yaXR5LCBuYW1lW3ByaW9yaXR5XSwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgICAgcmV0dXJuIGQzX3dpbmRvdyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgICB9XG4gICAgICBwcmlvcml0eSA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgZnVuY3Rpb24gc3R5bGVOdWxsKCkge1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVDb25zdGFudCgpIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7IGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB4LCBwcmlvcml0eSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gc3R5bGVOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZUZ1bmN0aW9uIDogc3R5bGVDb25zdGFudDtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUucHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSByZXR1cm4gdGhpcy5ub2RlKClbbmFtZV07XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fcHJvcGVydHkodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gcHJvcGVydHlOdWxsKCkge1xuICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQoKSB7XG4gICAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTsgZWxzZSB0aGlzW25hbWVdID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBwcm9wZXJ0eU51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BlcnR5RnVuY3Rpb24gOiBwcm9wZXJ0eUNvbnN0YW50O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH0gOiB2YWx1ZSA9PSBudWxsID8gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfSkgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH0gOiB2YWx1ZSA9PSBudWxsID8gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9KSA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQobmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCwgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlID09PSBkM19uc1hodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IGQzX25zWGh0bWwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5TKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IChuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKSkubG9jYWwgPyBjcmVhdGVOUyA6IGNyZWF0ZTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIGJlZm9yZSA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihiZWZvcmUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShuYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGJlZm9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICAgIH0pO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25SZW1vdmUpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25SZW1vdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCBncm91cCwgbm9kZTtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFycmF5KG4gPSAoZ3JvdXAgPSB0aGlzWzBdKS5sZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHZhbHVlW2ldID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiaW5kKGdyb3VwLCBncm91cERhdGEpIHtcbiAgICAgIHZhciBpLCBuID0gZ3JvdXAubGVuZ3RoLCBtID0gZ3JvdXBEYXRhLmxlbmd0aCwgbjAgPSBNYXRoLm1pbihuLCBtKSwgdXBkYXRlTm9kZXMgPSBuZXcgQXJyYXkobSksIGVudGVyTm9kZXMgPSBuZXcgQXJyYXkobSksIGV4aXROb2RlcyA9IG5ldyBBcnJheShuKSwgbm9kZSwgbm9kZURhdGE7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciBub2RlQnlLZXlWYWx1ZSA9IG5ldyBkM19NYXAoKSwga2V5VmFsdWVzID0gbmV3IEFycmF5KG4pLCBrZXlWYWx1ZTtcbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47ICkge1xuICAgICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUgPSBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKSkpIHtcbiAgICAgICAgICAgICAgZXhpdE5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG07ICkge1xuICAgICAgICAgIGlmICghKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUgPSBrZXkuY2FsbChncm91cERhdGEsIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldLCBpKSkpKSB7XG4gICAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKG5vZGVEYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjsgKSB7XG4gICAgICAgICAgaWYgKGkgaW4ga2V5VmFsdWVzICYmIG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuMDsgKSB7XG4gICAgICAgICAgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICAgIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLl9fZGF0YV9fID0gbm9kZURhdGE7XG4gICAgICAgICAgICB1cGRhdGVOb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDtpIDwgbTsgKytpKSB7XG4gICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShncm91cERhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW50ZXJOb2Rlcy51cGRhdGUgPSB1cGRhdGVOb2RlcztcbiAgICAgIGVudGVyTm9kZXMucGFyZW50Tm9kZSA9IHVwZGF0ZU5vZGVzLnBhcmVudE5vZGUgPSBleGl0Tm9kZXMucGFyZW50Tm9kZSA9IGdyb3VwLnBhcmVudE5vZGU7XG4gICAgICBlbnRlci5wdXNoKGVudGVyTm9kZXMpO1xuICAgICAgdXBkYXRlLnB1c2godXBkYXRlTm9kZXMpO1xuICAgICAgZXhpdC5wdXNoKGV4aXROb2Rlcyk7XG4gICAgfVxuICAgIHZhciBlbnRlciA9IGQzX3NlbGVjdGlvbl9lbnRlcihbXSksIHVwZGF0ZSA9IGQzX3NlbGVjdGlvbihbXSksIGV4aXQgPSBkM19zZWxlY3Rpb24oW10pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlLmNhbGwoZ3JvdXAsIGdyb3VwLnBhcmVudE5vZGUuX19kYXRhX18sIGkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlLmVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW50ZXI7XG4gICAgfTtcbiAgICB1cGRhdGUuZXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4aXQ7XG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZGF0YU5vZGUoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBfX2RhdGFfXzogZGF0YVxuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdHVtID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSkgOiB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIik7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fZmlsdGVyKGZpbHRlcik7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZmlsdGVyKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXModGhpcywgc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBub2RlLm5leHRTaWJsaW5nKSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkgdGhpc1tqXS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIHJldHVybiB0aGlzLm9yZGVyKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zb3J0Q29tcGFyYXRvcihjb21wYXJhdG9yKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBjb21wYXJhdG9yID0gZDNfYXNjZW5kaW5nO1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyYXRvcihhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lYWNoKGdyb3VwcywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjayhub2RlLCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ3MgPSBkM19hcnJheShhcmd1bWVudHMpO1xuICAgIGNhbGxiYWNrLmFwcGx5KGFyZ3NbMF0gPSB0aGlzLCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXIoc2VsZWN0aW9uKSB7XG4gICAgZDNfc3ViY2xhc3Moc2VsZWN0aW9uLCBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgdmFyIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSA9IFtdO1xuICBkMy5zZWxlY3Rpb24uZW50ZXIgPSBkM19zZWxlY3Rpb25fZW50ZXI7XG4gIGQzLnNlbGVjdGlvbi5lbnRlci5wcm90b3R5cGUgPSBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5hcHBlbmQgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXBwZW5kO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuZW1wdHkgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHk7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5jYWxsID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGw7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5zaXplID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIHVwZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHVwZ3JvdXAgPSAoZ3JvdXAgPSB0aGlzW2pdKS51cGRhdGU7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBncm91cC5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2godXBncm91cFtpXSA9IHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKGdyb3VwLnBhcmVudE5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICAgICAgICBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgYmVmb3JlID0gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKHRoaXMpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcywgbmFtZSwgYmVmb3JlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKGVudGVyKSB7XG4gICAgdmFyIGkwLCBqMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgaikge1xuICAgICAgdmFyIGdyb3VwID0gZW50ZXJbal0udXBkYXRlLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlO1xuICAgICAgaWYgKGogIT0gajApIGowID0gaiwgaTAgPSAwO1xuICAgICAgaWYgKGkgPj0gaTApIGkwID0gaSArIDE7XG4gICAgICB3aGlsZSAoIShub2RlID0gZ3JvdXBbaTBdKSAmJiArK2kwIDwgbikgO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuICBkMy5zZWxlY3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGdyb3VwO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZ3JvdXAgPSBbIGQzX3NlbGVjdChub2RlLCBkM19kb2N1bWVudCkgXTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gWyBub2RlIF07XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIGQzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgdmFyIGdyb3VwO1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdyb3VwID0gZDNfYXJyYXkoZDNfc2VsZWN0QWxsKG5vZGVzLCBkM19kb2N1bWVudCkpO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSBkM19hcnJheShub2Rlcyk7XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihbIGdyb3VwIF0pO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIGxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAoY2FwdHVyZSBpbiB0eXBlKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX29uKGNhcHR1cmUsIHR5cGVbY2FwdHVyZV0sIGxpc3RlbmVyKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCAyKSByZXR1cm4gKG4gPSB0aGlzLm5vZGUoKVtcIl9fb25cIiArIHR5cGVdKSAmJiBuLl87XG4gICAgICBjYXB0dXJlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIHZhciBuYW1lID0gXCJfX29uXCIgKyB0eXBlLCBpID0gdHlwZS5pbmRleE9mKFwiLlwiKSwgd3JhcCA9IGQzX3NlbGVjdGlvbl9vbkxpc3RlbmVyO1xuICAgIGlmIChpID4gMCkgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMuZ2V0KHR5cGUpO1xuICAgIGlmIChmaWx0ZXIpIHR5cGUgPSBmaWx0ZXIsIHdyYXAgPSBkM19zZWxlY3Rpb25fb25GaWx0ZXI7XG4gICAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG4gICAgICB2YXIgbCA9IHRoaXNbbmFtZV07XG4gICAgICBpZiAobCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbCwgbC4kKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWRkKCkge1xuICAgICAgdmFyIGwgPSB3cmFwKGxpc3RlbmVyLCBkM19hcnJheShhcmd1bWVudHMpKTtcbiAgICAgIG9uUmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpc1tuYW1lXSA9IGwsIGwuJCA9IGNhcHR1cmUpO1xuICAgICAgbC5fID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJeX19vbihbXi5dKylcIiArIGQzLnJlcXVvdGUodHlwZSkgKyBcIiRcIiksIG1hdGNoO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgIGlmIChtYXRjaCA9IG5hbWUubWF0Y2gocmUpKSB7XG4gICAgICAgICAgdmFyIGwgPSB0aGlzW25hbWVdO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihtYXRjaFsxXSwgbCwgbC4kKTtcbiAgICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaSA/IGxpc3RlbmVyID8gb25BZGQgOiBvblJlbW92ZSA6IGxpc3RlbmVyID8gZDNfbm9vcCA6IHJlbW92ZUFsbDtcbiAgfVxuICB2YXIgZDNfc2VsZWN0aW9uX29uRmlsdGVycyA9IGQzLm1hcCh7XG4gICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbiAgfSk7XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoXCJvblwiICsgayBpbiBkM19kb2N1bWVudCkgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5yZW1vdmUoayk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXIobGlzdGVuZXIsIGFyZ3VtZW50eikge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgbyA9IGQzLmV2ZW50O1xuICAgICAgZDMuZXZlbnQgPSBlO1xuICAgICAgYXJndW1lbnR6WzBdID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50eik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkMy5ldmVudCA9IG87XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb25GaWx0ZXIobGlzdGVuZXIsIGFyZ3VtZW50eikge1xuICAgIHZhciBsID0gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXIobGlzdGVuZXIsIGFyZ3VtZW50eik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgaWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGFyZ2V0KSAmIDgpKSB7XG4gICAgICAgIGwuY2FsbCh0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdmFyIGQzX2V2ZW50X2RyYWdTZWxlY3QsIGQzX2V2ZW50X2RyYWdJZCA9IDA7XG4gIGZ1bmN0aW9uIGQzX2V2ZW50X2RyYWdTdXBwcmVzcyhub2RlKSB7XG4gICAgdmFyIG5hbWUgPSBcIi5kcmFnc3VwcHJlc3MtXCIgKyArK2QzX2V2ZW50X2RyYWdJZCwgY2xpY2sgPSBcImNsaWNrXCIgKyBuYW1lLCB3ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyhub2RlKSkub24oXCJ0b3VjaG1vdmVcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpLm9uKFwiZHJhZ3N0YXJ0XCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KS5vbihcInNlbGVjdHN0YXJ0XCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KTtcbiAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCA9PSBudWxsKSB7XG4gICAgICBkM19ldmVudF9kcmFnU2VsZWN0ID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gbm9kZSA/IGZhbHNlIDogZDNfdmVuZG9yU3ltYm9sKG5vZGUuc3R5bGUsIFwidXNlclNlbGVjdFwiKTtcbiAgICB9XG4gICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QpIHtcbiAgICAgIHZhciBzdHlsZSA9IGQzX2RvY3VtZW50RWxlbWVudChub2RlKS5zdHlsZSwgc2VsZWN0ID0gc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF07XG4gICAgICBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oc3VwcHJlc3NDbGljaykge1xuICAgICAgdy5vbihuYW1lLCBudWxsKTtcbiAgICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0KSBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XSA9IHNlbGVjdDtcbiAgICAgIGlmIChzdXBwcmVzc0NsaWNrKSB7XG4gICAgICAgIHZhciBvZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3Lm9uKGNsaWNrLCBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdy5vbihjbGljaywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG9mZigpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dChvZmYsIDApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDMubW91c2UgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICByZXR1cm4gZDNfbW91c2VQb2ludChjb250YWluZXIsIGQzX2V2ZW50U291cmNlKCkpO1xuICB9O1xuICB2YXIgZDNfbW91c2VfYnVnNDQwODMgPSB0aGlzLm5hdmlnYXRvciAmJiAvV2ViS2l0Ly50ZXN0KHRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAtMSA6IDA7XG4gIGZ1bmN0aW9uIGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCBlKSB7XG4gICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIGUgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBzdmcgPSBjb250YWluZXIub3duZXJTVkdFbGVtZW50IHx8IGNvbnRhaW5lcjtcbiAgICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIGlmIChkM19tb3VzZV9idWc0NDA4MyA8IDApIHtcbiAgICAgICAgdmFyIHdpbmRvdyA9IGQzX3dpbmRvdyhjb250YWluZXIpO1xuICAgICAgICBpZiAod2luZG93LnNjcm9sbFggfHwgd2luZG93LnNjcm9sbFkpIHtcbiAgICAgICAgICBzdmcgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInN2Z1wiKS5zdHlsZSh7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgICAgICAgfSwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgdmFyIGN0bSA9IHN2Z1swXVswXS5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICBkM19tb3VzZV9idWc0NDA4MyA9ICEoY3RtLmYgfHwgY3RtLmUpO1xuICAgICAgICAgIHN2Zy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGQzX21vdXNlX2J1ZzQ0MDgzKSBwb2ludC54ID0gZS5wYWdlWCwgcG9pbnQueSA9IGUucGFnZVk7IGVsc2UgcG9pbnQueCA9IGUuY2xpZW50WCwgXG4gICAgICBwb2ludC55ID0gZS5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oY29udGFpbmVyLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gWyBwb2ludC54LCBwb2ludC55IF07XG4gICAgfVxuICAgIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBbIGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LCBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3AgXTtcbiAgfVxuICBkMy50b3VjaCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgdG91Y2hlcywgaWRlbnRpZmllcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBkM19ldmVudFNvdXJjZSgpLmNoYW5nZWRUb3VjaGVzO1xuICAgIGlmICh0b3VjaGVzKSBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMubGVuZ3RoLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0b3VjaCA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCB0b3VjaCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBkMy5iZWhhdmlvci5kcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaChkcmFnLCBcImRyYWdcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcmFnZW5kXCIpLCBvcmlnaW4gPSBudWxsLCBtb3VzZWRvd24gPSBkcmFnc3RhcnQoZDNfbm9vcCwgZDMubW91c2UsIGQzX3dpbmRvdywgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCIpLCB0b3VjaHN0YXJ0ID0gZHJhZ3N0YXJ0KGQzX2JlaGF2aW9yX2RyYWdUb3VjaElkLCBkMy50b3VjaCwgZDNfaWRlbnRpdHksIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIik7XG4gICAgZnVuY3Rpb24gZHJhZygpIHtcbiAgICAgIHRoaXMub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd24pLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmFnc3RhcnQoaWQsIHBvc2l0aW9uLCBzdWJqZWN0LCBtb3ZlLCBlbmQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCB0YXJnZXQgPSBkMy5ldmVudC50YXJnZXQuY29ycmVzcG9uZGluZ0VsZW1lbnQgfHwgZDMuZXZlbnQudGFyZ2V0LCBwYXJlbnQgPSB0aGF0LnBhcmVudE5vZGUsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgZHJhZ2dlZCA9IDAsIGRyYWdJZCA9IGlkKCksIGRyYWdOYW1lID0gXCIuZHJhZ1wiICsgKGRyYWdJZCA9PSBudWxsID8gXCJcIiA6IFwiLVwiICsgZHJhZ0lkKSwgZHJhZ09mZnNldCwgZHJhZ1N1YmplY3QgPSBkMy5zZWxlY3Qoc3ViamVjdCh0YXJnZXQpKS5vbihtb3ZlICsgZHJhZ05hbWUsIG1vdmVkKS5vbihlbmQgKyBkcmFnTmFtZSwgZW5kZWQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0YXJnZXQpLCBwb3NpdGlvbjAgPSBwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCk7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gb3JpZ2luLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IFsgZHJhZ09mZnNldC54IC0gcG9zaXRpb24wWzBdLCBkcmFnT2Zmc2V0LnkgLSBwb3NpdGlvbjBbMV0gXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gWyAwLCAwIF07XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbjEgPSBwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCksIGR4LCBkeTtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uMSkgcmV0dXJuO1xuICAgICAgICAgIGR4ID0gcG9zaXRpb24xWzBdIC0gcG9zaXRpb24wWzBdO1xuICAgICAgICAgIGR5ID0gcG9zaXRpb24xWzFdIC0gcG9zaXRpb24wWzFdO1xuICAgICAgICAgIGRyYWdnZWQgfD0gZHggfCBkeTtcbiAgICAgICAgICBwb3NpdGlvbjAgPSBwb3NpdGlvbjE7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogXCJkcmFnXCIsXG4gICAgICAgICAgICB4OiBwb3NpdGlvbjFbMF0gKyBkcmFnT2Zmc2V0WzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb24xWzFdICsgZHJhZ09mZnNldFsxXSxcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICAgIGlmICghcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpKSByZXR1cm47XG4gICAgICAgICAgZHJhZ1N1YmplY3Qub24obW92ZSArIGRyYWdOYW1lLCBudWxsKS5vbihlbmQgKyBkcmFnTmFtZSwgbnVsbCk7XG4gICAgICAgICAgZHJhZ1Jlc3RvcmUoZHJhZ2dlZCk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogXCJkcmFnZW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZHJhZy5vcmlnaW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmlnaW47XG4gICAgICBvcmlnaW4gPSB4O1xuICAgICAgcmV0dXJuIGRyYWc7XG4gICAgfTtcbiAgICByZXR1cm4gZDMucmViaW5kKGRyYWcsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19iZWhhdmlvcl9kcmFnVG91Y2hJZCgpIHtcbiAgICByZXR1cm4gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgfVxuICBkMy50b3VjaGVzID0gZnVuY3Rpb24oY29udGFpbmVyLCB0b3VjaGVzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB0b3VjaGVzID0gZDNfZXZlbnRTb3VyY2UoKS50b3VjaGVzO1xuICAgIHJldHVybiB0b3VjaGVzID8gZDNfYXJyYXkodG91Y2hlcykubWFwKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgdG91Y2gpO1xuICAgICAgcG9pbnQuaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSkgOiBbXTtcbiAgfTtcbiAgdmFyIM61ID0gMWUtNiwgzrUyID0gzrUgKiDOtSwgz4AgPSBNYXRoLlBJLCDPhCA9IDIgKiDPgCwgz4TOtSA9IM+EIC0gzrUsIGhhbGbPgCA9IM+AIC8gMiwgZDNfcmFkaWFucyA9IM+AIC8gMTgwLCBkM19kZWdyZWVzID0gMTgwIC8gz4A7XG4gIGZ1bmN0aW9uIGQzX3Nnbih4KSB7XG4gICAgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Nyb3NzMmQoYSwgYiwgYykge1xuICAgIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChiWzFdIC0gYVsxXSkgKiAoY1swXSAtIGFbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Fjb3MoeCkge1xuICAgIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyDPgCA6IE1hdGguYWNvcyh4KTtcbiAgfVxuICBmdW5jdGlvbiBkM19hc2luKHgpIHtcbiAgICByZXR1cm4geCA+IDEgPyBoYWxmz4AgOiB4IDwgLTEgPyAtaGFsZs+AIDogTWF0aC5hc2luKHgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NpbmgoeCkge1xuICAgIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Nvc2goeCkge1xuICAgIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RhbmgoeCkge1xuICAgIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2hhdmVyc2luKHgpIHtcbiAgICByZXR1cm4gKHggPSBNYXRoLnNpbih4IC8gMikpICogeDtcbiAgfVxuICB2YXIgz4EgPSBNYXRoLlNRUlQyLCDPgTIgPSAyLCDPgTQgPSA0O1xuICBkMy5pbnRlcnBvbGF0ZVpvb20gPSBmdW5jdGlvbihwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLCB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sIGR4ID0gdXgxIC0gdXgwLCBkeSA9IHV5MSAtIHV5MCwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSwgaSwgUztcbiAgICBpZiAoZDIgPCDOtTIpIHtcbiAgICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIM+BO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFsgdXgwICsgdCAqIGR4LCB1eTAgKyB0ICogZHksIHcwICogTWF0aC5leHAoz4EgKiB0ICogUykgXTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgz4E0ICogZDIpIC8gKDIgKiB3MCAqIM+BMiAqIGQxKSwgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSDPgTQgKiBkMikgLyAoMiAqIHcxICogz4EyICogZDEpLCByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICAgIFMgPSAocjEgLSByMCkgLyDPgTtcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsIGNvc2hyMCA9IGQzX2Nvc2gocjApLCB1ID0gdzAgLyAoz4EyICogZDEpICogKGNvc2hyMCAqIGQzX3Rhbmgoz4EgKiBzICsgcjApIC0gZDNfc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gWyB1eDAgKyB1ICogZHgsIHV5MCArIHUgKiBkeSwgdzAgKiBjb3NocjAgLyBkM19jb3NoKM+BICogcyArIHIwKSBdO1xuICAgICAgfTtcbiAgICB9XG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxZTM7XG4gICAgcmV0dXJuIGk7XG4gIH07XG4gIGQzLmJlaGF2aW9yLnpvb20gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmlldyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgazogMVxuICAgIH0sIHRyYW5zbGF0ZTAsIGNlbnRlcjAsIGNlbnRlciwgc2l6ZSA9IFsgOTYwLCA1MDAgXSwgc2NhbGVFeHRlbnQgPSBkM19iZWhhdmlvcl96b29tSW5maW5pdHksIGR1cmF0aW9uID0gMjUwLCB6b29taW5nID0gMCwgbW91c2Vkb3duID0gXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZW1vdmUgPSBcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNldXAgPSBcIm1vdXNldXAuem9vbVwiLCBtb3VzZXdoZWVsVGltZXIsIHRvdWNoc3RhcnQgPSBcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHRpbWUsIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaCh6b29tLCBcInpvb21zdGFydFwiLCBcInpvb21cIiwgXCJ6b29tZW5kXCIpLCB4MCwgeDEsIHkwLCB5MTtcbiAgICBpZiAoIWQzX2JlaGF2aW9yX3pvb21XaGVlbCkge1xuICAgICAgZDNfYmVoYXZpb3Jfem9vbVdoZWVsID0gXCJvbndoZWVsXCIgaW4gZDNfZG9jdW1lbnQgPyAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAtZDMuZXZlbnQuZGVsdGFZICogKGQzLmV2ZW50LmRlbHRhTW9kZSA/IDEyMCA6IDEpO1xuICAgICAgfSwgXCJ3aGVlbFwiKSA6IFwib25tb3VzZXdoZWVsXCIgaW4gZDNfZG9jdW1lbnQgPyAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkMy5ldmVudC53aGVlbERlbHRhO1xuICAgICAgfSwgXCJtb3VzZXdoZWVsXCIpIDogKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLWQzLmV2ZW50LmRldGFpbDtcbiAgICAgIH0sIFwiTW96TW91c2VQaXhlbFNjcm9sbFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbShnKSB7XG4gICAgICBnLm9uKG1vdXNlZG93biwgbW91c2Vkb3duZWQpLm9uKGQzX2JlaGF2aW9yX3pvb21XaGVlbCArIFwiLnpvb21cIiwgbW91c2V3aGVlbGVkKS5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZCkub24odG91Y2hzdGFydCwgdG91Y2hzdGFydGVkKTtcbiAgICB9XG4gICAgem9vbS5ldmVudCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKSwgdmlldzEgPSB2aWV3O1xuICAgICAgICBpZiAoZDNfdHJhbnNpdGlvbkluaGVyaXRJZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZWFjaChcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5fX2NoYXJ0X18gfHwge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICBrOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pLnR3ZWVuKFwiem9vbTp6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGR4ID0gc2l6ZVswXSwgZHkgPSBzaXplWzFdLCBjeCA9IGNlbnRlcjAgPyBjZW50ZXIwWzBdIDogZHggLyAyLCBjeSA9IGNlbnRlcjAgPyBjZW50ZXIwWzFdIDogZHkgLyAyLCBpID0gZDMuaW50ZXJwb2xhdGVab29tKFsgKGN4IC0gdmlldy54KSAvIHZpZXcuaywgKGN5IC0gdmlldy55KSAvIHZpZXcuaywgZHggLyB2aWV3LmsgXSwgWyAoY3ggLSB2aWV3MS54KSAvIHZpZXcxLmssIChjeSAtIHZpZXcxLnkpIC8gdmlldzEuaywgZHggLyB2aWV3MS5rIF0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBpKHQpLCBrID0gZHggLyBsWzJdO1xuICAgICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHZpZXcgPSB7XG4gICAgICAgICAgICAgICAgeDogY3ggLSBsWzBdICogayxcbiAgICAgICAgICAgICAgICB5OiBjeSAtIGxbMV0gKiBrLFxuICAgICAgICAgICAgICAgIGs6IGtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuZWFjaChcImludGVycnVwdC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KS5lYWNoKFwiZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19jaGFydF9fID0gdmlldztcbiAgICAgICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHpvb20udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB2aWV3LngsIHZpZXcueSBdO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogK19bMF0sXG4gICAgICAgIHk6ICtfWzFdLFxuICAgICAgICBrOiB2aWV3LmtcbiAgICAgIH07XG4gICAgICByZXNjYWxlKCk7XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2aWV3Lms7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiB2aWV3LngsXG4gICAgICAgIHk6IHZpZXcueSxcbiAgICAgICAgazogbnVsbFxuICAgICAgfTtcbiAgICAgIHNjYWxlVG8oK18pO1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGVFeHRlbnQ7XG4gICAgICBzY2FsZUV4dGVudCA9IF8gPT0gbnVsbCA/IGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSA6IFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VudGVyO1xuICAgICAgY2VudGVyID0gXyAmJiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IF8gJiYgWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgZHVyYXRpb24gPSArXztcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDE7XG4gICAgICB4MSA9IHo7XG4gICAgICB4MCA9IHouY29weSgpO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgazogMVxuICAgICAgfTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTE7XG4gICAgICB5MSA9IHo7XG4gICAgICB5MCA9IHouY29weSgpO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgazogMVxuICAgICAgfTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbG9jYXRpb24ocCkge1xuICAgICAgcmV0dXJuIFsgKHBbMF0gLSB2aWV3LngpIC8gdmlldy5rLCAocFsxXSAtIHZpZXcueSkgLyB2aWV3LmsgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnQobCkge1xuICAgICAgcmV0dXJuIFsgbFswXSAqIHZpZXcuayArIHZpZXcueCwgbFsxXSAqIHZpZXcuayArIHZpZXcueSBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVRvKHMpIHtcbiAgICAgIHZpZXcuayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVUbyhwLCBsKSB7XG4gICAgICBsID0gcG9pbnQobCk7XG4gICAgICB2aWV3LnggKz0gcFswXSAtIGxbMF07XG4gICAgICB2aWV3LnkgKz0gcFsxXSAtIGxbMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21Ubyh0aGF0LCBwLCBsLCBrKSB7XG4gICAgICB0aGF0Ll9fY2hhcnRfXyA9IHtcbiAgICAgICAgeDogdmlldy54LFxuICAgICAgICB5OiB2aWV3LnksXG4gICAgICAgIGs6IHZpZXcua1xuICAgICAgfTtcbiAgICAgIHNjYWxlVG8oTWF0aC5wb3coMiwgaykpO1xuICAgICAgdHJhbnNsYXRlVG8oY2VudGVyMCA9IHAsIGwpO1xuICAgICAgdGhhdCA9IGQzLnNlbGVjdCh0aGF0KTtcbiAgICAgIGlmIChkdXJhdGlvbiA+IDApIHRoYXQgPSB0aGF0LnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICB0aGF0LmNhbGwoem9vbS5ldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBpZiAoeDEpIHgxLmRvbWFpbih4MC5yYW5nZSgpLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoeCAtIHZpZXcueCkgLyB2aWV3Lms7XG4gICAgICB9KS5tYXAoeDAuaW52ZXJ0KSk7XG4gICAgICBpZiAoeTEpIHkxLmRvbWFpbih5MC5yYW5nZSgpLm1hcChmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiAoeSAtIHZpZXcueSkgLyB2aWV3Lms7XG4gICAgICB9KS5tYXAoeTAuaW52ZXJ0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21zdGFydGVkKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoIXpvb21pbmcrKykgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21zdGFydFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbWVkKGRpc3BhdGNoKSB7XG4gICAgICByZXNjYWxlKCk7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbVwiLFxuICAgICAgICBzY2FsZTogdmlldy5rLFxuICAgICAgICB0cmFuc2xhdGU6IFsgdmlldy54LCB2aWV3LnkgXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21lbmRlZChkaXNwYXRjaCkge1xuICAgICAgaWYgKCEtLXpvb21pbmcpIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tZW5kXCJcbiAgICAgIH0pLCBjZW50ZXIwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgZHJhZ2dlZCA9IDAsIHN1YmplY3QgPSBkMy5zZWxlY3QoZDNfd2luZG93KHRoYXQpKS5vbihtb3VzZW1vdmUsIG1vdmVkKS5vbihtb3VzZXVwLCBlbmRlZCksIGxvY2F0aW9uMCA9IGxvY2F0aW9uKGQzLm1vdXNlKHRoYXQpKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGhhdCk7XG4gICAgICBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhhdCk7XG4gICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgZHJhZ2dlZCA9IDE7XG4gICAgICAgIHRyYW5zbGF0ZVRvKGQzLm1vdXNlKHRoYXQpLCBsb2NhdGlvbjApO1xuICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgIHN1YmplY3Qub24obW91c2Vtb3ZlLCBudWxsKS5vbihtb3VzZXVwLCBudWxsKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoZHJhZ2dlZCk7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcywgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBsb2NhdGlvbnMwID0ge30sIGRpc3RhbmNlMCA9IDAsIHNjYWxlMCwgem9vbU5hbWUgPSBcIi56b29tLVwiICsgZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllciwgdG91Y2htb3ZlID0gXCJ0b3VjaG1vdmVcIiArIHpvb21OYW1lLCB0b3VjaGVuZCA9IFwidG91Y2hlbmRcIiArIHpvb21OYW1lLCB0YXJnZXRzID0gW10sIHN1YmplY3QgPSBkMy5zZWxlY3QodGhhdCksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRoYXQpO1xuICAgICAgc3RhcnRlZCgpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgc3ViamVjdC5vbihtb3VzZWRvd24sIG51bGwpLm9uKHRvdWNoc3RhcnQsIHN0YXJ0ZWQpO1xuICAgICAgZnVuY3Rpb24gcmVsb2NhdGUoKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZDMudG91Y2hlcyh0aGF0KTtcbiAgICAgICAgc2NhbGUwID0gdmlldy5rO1xuICAgICAgICB0b3VjaGVzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgIGlmICh0LmlkZW50aWZpZXIgaW4gbG9jYXRpb25zMCkgbG9jYXRpb25zMFt0LmlkZW50aWZpZXJdID0gbG9jYXRpb24odCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG91Y2hlcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0ZWQoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkMy5ldmVudC50YXJnZXQ7XG4gICAgICAgIGQzLnNlbGVjdCh0YXJnZXQpLm9uKHRvdWNobW92ZSwgbW92ZWQpLm9uKHRvdWNoZW5kLCBlbmRlZCk7XG4gICAgICAgIHRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoYW5nZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgbG9jYXRpb25zMFtjaGFuZ2VkW2ldLmlkZW50aWZpZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2hlcyA9IHJlbG9jYXRlKCksIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChub3cgLSB0b3VjaHRpbWUgPCA1MDApIHtcbiAgICAgICAgICAgIHZhciBwID0gdG91Y2hlc1swXTtcbiAgICAgICAgICAgIHpvb21Ubyh0aGF0LCBwLCBsb2NhdGlvbnMwW3AuaWRlbnRpZmllcl0sIE1hdGguZmxvb3IoTWF0aC5sb2codmlldy5rKSAvIE1hdGguTE4yKSArIDEpO1xuICAgICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3VjaHRpbWUgPSBub3c7XG4gICAgICAgIH0gZWxzZSBpZiAodG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHAgPSB0b3VjaGVzWzBdLCBxID0gdG91Y2hlc1sxXSwgZHggPSBwWzBdIC0gcVswXSwgZHkgPSBwWzFdIC0gcVsxXTtcbiAgICAgICAgICBkaXN0YW5jZTAgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZDMudG91Y2hlcyh0aGF0KSwgcDAsIGwwLCBwMSwgbDE7XG4gICAgICAgIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGF0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IG47ICsraSwgbDEgPSBudWxsKSB7XG4gICAgICAgICAgcDEgPSB0b3VjaGVzW2ldO1xuICAgICAgICAgIGlmIChsMSA9IGxvY2F0aW9uczBbcDEuaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGlmIChsMCkgYnJlYWs7XG4gICAgICAgICAgICBwMCA9IHAxLCBsMCA9IGwxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobDEpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UxID0gKGRpc3RhbmNlMSA9IHAxWzBdIC0gcDBbMF0pICogZGlzdGFuY2UxICsgKGRpc3RhbmNlMSA9IHAxWzFdIC0gcDBbMV0pICogZGlzdGFuY2UxLCBzY2FsZTEgPSBkaXN0YW5jZTAgJiYgTWF0aC5zcXJ0KGRpc3RhbmNlMSAvIGRpc3RhbmNlMCk7XG4gICAgICAgICAgcDAgPSBbIChwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDIgXTtcbiAgICAgICAgICBsMCA9IFsgKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMiBdO1xuICAgICAgICAgIHNjYWxlVG8oc2NhbGUxICogc2NhbGUwKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaHRpbWUgPSBudWxsO1xuICAgICAgICB0cmFuc2xhdGVUbyhwMCwgbDApO1xuICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjaGFuZ2VkID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGFuZ2VkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvY2F0aW9uczBbY2hhbmdlZFtpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaWRlbnRpZmllciBpbiBsb2NhdGlvbnMwKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCByZWxvY2F0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkMy5zZWxlY3RBbGwodGFyZ2V0cykub24oem9vbU5hbWUsIG51bGwpO1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlZG93biwgbW91c2Vkb3duZWQpLm9uKHRvdWNoc3RhcnQsIHRvdWNoc3RhcnRlZCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKCk7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdXNld2hlZWxlZCgpIHtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAobW91c2V3aGVlbFRpbWVyKSBjbGVhclRpbWVvdXQobW91c2V3aGVlbFRpbWVyKTsgZWxzZSBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhpcyksIFxuICAgICAgdHJhbnNsYXRlMCA9IGxvY2F0aW9uKGNlbnRlcjAgPSBjZW50ZXIgfHwgZDMubW91c2UodGhpcykpLCB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBtb3VzZXdoZWVsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3VzZXdoZWVsVGltZXIgPSBudWxsO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfSwgNTApO1xuICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2NhbGVUbyhNYXRoLnBvdygyLCBkM19iZWhhdmlvcl96b29tRGVsdGEoKSAqIC4wMDIpICogdmlldy5rKTtcbiAgICAgIHRyYW5zbGF0ZVRvKGNlbnRlcjAsIHRyYW5zbGF0ZTApO1xuICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcbiAgICAgIHZhciBwID0gZDMubW91c2UodGhpcyksIGsgPSBNYXRoLmxvZyh2aWV3LmspIC8gTWF0aC5MTjI7XG4gICAgICB6b29tVG8odGhpcywgcCwgbG9jYXRpb24ocCksIGQzLmV2ZW50LnNoaWZ0S2V5ID8gTWF0aC5jZWlsKGspIC0gMSA6IE1hdGguZmxvb3IoaykgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzLnJlYmluZCh6b29tLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgdmFyIGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSA9IFsgMCwgSW5maW5pdHkgXSwgZDNfYmVoYXZpb3Jfem9vbURlbHRhLCBkM19iZWhhdmlvcl96b29tV2hlZWw7XG4gIGQzLmNvbG9yID0gZDNfY29sb3I7XG4gIGZ1bmN0aW9uIGQzX2NvbG9yKCkge31cbiAgZDNfY29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICB9O1xuICBkMy5oc2wgPSBkM19oc2w7XG4gIGZ1bmN0aW9uIGQzX2hzbChoLCBzLCBsKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19oc2wgPyB2b2lkICh0aGlzLmggPSAraCwgdGhpcy5zID0gK3MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gaCBpbnN0YW5jZW9mIGQzX2hzbCA/IG5ldyBkM19oc2woaC5oLCBoLnMsIGgubCkgOiBkM19yZ2JfcGFyc2UoXCJcIiArIGgsIGQzX3JnYl9oc2wsIGQzX2hzbCkgOiBuZXcgZDNfaHNsKGgsIHMsIGwpO1xuICB9XG4gIHZhciBkM19oc2xQcm90b3R5cGUgPSBkM19oc2wucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2hzbFByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19oc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAvIGspO1xuICB9O1xuICBkM19oc2xQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgayAqIHRoaXMubCk7XG4gIH07XG4gIGQzX2hzbFByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaHNsX3JnYih0aGlzLmgsIHRoaXMucywgdGhpcy5sKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaHNsX3JnYihoLCBzLCBsKSB7XG4gICAgdmFyIG0xLCBtMjtcbiAgICBoID0gaXNOYU4oaCkgPyAwIDogKGggJT0gMzYwKSA8IDAgPyBoICsgMzYwIDogaDtcbiAgICBzID0gaXNOYU4ocykgPyAwIDogcyA8IDAgPyAwIDogcyA+IDEgPyAxIDogcztcbiAgICBsID0gbCA8IDAgPyAwIDogbCA+IDEgPyAxIDogbDtcbiAgICBtMiA9IGwgPD0gLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgbTEgPSAyICogbCAtIG0yO1xuICAgIGZ1bmN0aW9uIHYoaCkge1xuICAgICAgaWYgKGggPiAzNjApIGggLT0gMzYwOyBlbHNlIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICBpZiAoaCA8IDYwKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjA7XG4gICAgICBpZiAoaCA8IDE4MCkgcmV0dXJuIG0yO1xuICAgICAgaWYgKGggPCAyNDApIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwO1xuICAgICAgcmV0dXJuIG0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2dihoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2KGgpICogMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IodnYoaCArIDEyMCksIHZ2KGgpLCB2dihoIC0gMTIwKSk7XG4gIH1cbiAgZDMuaGNsID0gZDNfaGNsO1xuICBmdW5jdGlvbiBkM19oY2woaCwgYywgbCkge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaGNsID8gdm9pZCAodGhpcy5oID0gK2gsIHRoaXMuYyA9ICtjLCB0aGlzLmwgPSArbCkgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGggaW5zdGFuY2VvZiBkM19oY2wgPyBuZXcgZDNfaGNsKGguaCwgaC5jLCBoLmwpIDogaCBpbnN0YW5jZW9mIGQzX2xhYiA/IGQzX2xhYl9oY2woaC5sLCBoLmEsIGguYikgOiBkM19sYWJfaGNsKChoID0gZDNfcmdiX2xhYigoaCA9IGQzLnJnYihoKSkuciwgaC5nLCBoLmIpKS5sLCBoLmEsIGguYikgOiBuZXcgZDNfaGNsKGgsIGMsIGwpO1xuICB9XG4gIHZhciBkM19oY2xQcm90b3R5cGUgPSBkM19oY2wucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2hjbFByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2hjbCh0aGlzLmgsIHRoaXMuYywgTWF0aC5taW4oMTAwLCB0aGlzLmwgKyBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSk7XG4gIH07XG4gIGQzX2hjbFByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19oY2wodGhpcy5oLCB0aGlzLmMsIE1hdGgubWF4KDAsIHRoaXMubCAtIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpKTtcbiAgfTtcbiAgZDNfaGNsUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19oY2xfbGFiKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwpLnJnYigpO1xuICB9O1xuICBmdW5jdGlvbiBkM19oY2xfbGFiKGgsIGMsIGwpIHtcbiAgICBpZiAoaXNOYU4oaCkpIGggPSAwO1xuICAgIGlmIChpc05hTihjKSkgYyA9IDA7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIobCwgTWF0aC5jb3MoaCAqPSBkM19yYWRpYW5zKSAqIGMsIE1hdGguc2luKGgpICogYyk7XG4gIH1cbiAgZDMubGFiID0gZDNfbGFiO1xuICBmdW5jdGlvbiBkM19sYWIobCwgYSwgYikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfbGFiID8gdm9pZCAodGhpcy5sID0gK2wsIHRoaXMuYSA9ICthLCB0aGlzLmIgPSArYikgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGwgaW5zdGFuY2VvZiBkM19sYWIgPyBuZXcgZDNfbGFiKGwubCwgbC5hLCBsLmIpIDogbCBpbnN0YW5jZW9mIGQzX2hjbCA/IGQzX2hjbF9sYWIobC5oLCBsLmMsIGwubCkgOiBkM19yZ2JfbGFiKChsID0gZDNfcmdiKGwpKS5yLCBsLmcsIGwuYikgOiBuZXcgZDNfbGFiKGwsIGEsIGIpO1xuICB9XG4gIHZhciBkM19sYWJfSyA9IDE4O1xuICB2YXIgZDNfbGFiX1ggPSAuOTUwNDcsIGQzX2xhYl9ZID0gMSwgZDNfbGFiX1ogPSAxLjA4ODgzO1xuICB2YXIgZDNfbGFiUHJvdG90eXBlID0gZDNfbGFiLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19sYWJQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIoTWF0aC5taW4oMTAwLCB0aGlzLmwgKyBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBkM19sYWJQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfbGFiKE1hdGgubWF4KDAsIHRoaXMubCAtIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGQzX2xhYlByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfbGFiX3JnYih0aGlzLmwsIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGFiX3JnYihsLCBhLCBiKSB7XG4gICAgdmFyIHkgPSAobCArIDE2KSAvIDExNiwgeCA9IHkgKyBhIC8gNTAwLCB6ID0geSAtIGIgLyAyMDA7XG4gICAgeCA9IGQzX2xhYl94eXooeCkgKiBkM19sYWJfWDtcbiAgICB5ID0gZDNfbGFiX3h5eih5KSAqIGQzX2xhYl9ZO1xuICAgIHogPSBkM19sYWJfeHl6KHopICogZDNfbGFiX1o7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoZDNfeHl6X3JnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIC40OTg1MzE0ICogeiksIGQzX3h5el9yZ2IoLS45NjkyNjYgKiB4ICsgMS44NzYwMTA4ICogeSArIC4wNDE1NTYgKiB6KSwgZDNfeHl6X3JnYiguMDU1NjQzNCAqIHggLSAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGFiX2hjbChsLCBhLCBiKSB7XG4gICAgcmV0dXJuIGwgPiAwID8gbmV3IGQzX2hjbChNYXRoLmF0YW4yKGIsIGEpICogZDNfZGVncmVlcywgTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpLCBsKSA6IG5ldyBkM19oY2woTmFOLCBOYU4sIGwpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xhYl94eXooeCkge1xuICAgIHJldHVybiB4ID4gLjIwNjg5MzAzNCA/IHggKiB4ICogeCA6ICh4IC0gNCAvIDI5KSAvIDcuNzg3MDM3O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3h5el9sYWIoeCkge1xuICAgIHJldHVybiB4ID4gLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6IDcuNzg3MDM3ICogeCArIDQgLyAyOTtcbiAgfVxuICBmdW5jdGlvbiBkM194eXpfcmdiKHIpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgyNTUgKiAociA8PSAuMDAzMDQgPyAxMi45MiAqIHIgOiAxLjA1NSAqIE1hdGgucG93KHIsIDEgLyAyLjQpIC0gLjA1NSkpO1xuICB9XG4gIGQzLnJnYiA9IGQzX3JnYjtcbiAgZnVuY3Rpb24gZDNfcmdiKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX3JnYiA/IHZvaWQgKHRoaXMuciA9IH5+ciwgdGhpcy5nID0gfn5nLCB0aGlzLmIgPSB+fmIpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyByIGluc3RhbmNlb2YgZDNfcmdiID8gbmV3IGQzX3JnYihyLnIsIHIuZywgci5iKSA6IGQzX3JnYl9wYXJzZShcIlwiICsgciwgZDNfcmdiLCBkM19oc2xfcmdiKSA6IG5ldyBkM19yZ2IociwgZywgYik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IodmFsdWUgPj4gMTYsIHZhbHVlID4+IDggJiAyNTUsIHZhbHVlICYgMjU1KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gZDNfcmdiTnVtYmVyKHZhbHVlKSArIFwiXCI7XG4gIH1cbiAgdmFyIGQzX3JnYlByb3RvdHlwZSA9IGQzX3JnYi5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfcmdiUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICB2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYiwgaSA9IDMwO1xuICAgIGlmICghciAmJiAhZyAmJiAhYikgcmV0dXJuIG5ldyBkM19yZ2IoaSwgaSwgaSk7XG4gICAgaWYgKHIgJiYgciA8IGkpIHIgPSBpO1xuICAgIGlmIChnICYmIGcgPCBpKSBnID0gaTtcbiAgICBpZiAoYiAmJiBiIDwgaSkgYiA9IGk7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoTWF0aC5taW4oMjU1LCByIC8gayksIE1hdGgubWluKDI1NSwgZyAvIGspLCBNYXRoLm1pbigyNTUsIGIgLyBrKSk7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKGsgKiB0aGlzLnIsIGsgKiB0aGlzLmcsIGsgKiB0aGlzLmIpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUuaHNsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3JnYl9oc2wodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgodGhpcy5yKSArIGQzX3JnYl9oZXgodGhpcy5nKSArIGQzX3JnYl9oZXgodGhpcy5iKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfcmdiX2hleCh2KSB7XG4gICAgcmV0dXJuIHYgPCAxNiA/IFwiMFwiICsgTWF0aC5tYXgoMCwgdikudG9TdHJpbmcoMTYpIDogTWF0aC5taW4oMjU1LCB2KS50b1N0cmluZygxNik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3BhcnNlKGZvcm1hdCwgcmdiLCBoc2wpIHtcbiAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMCwgbTEsIG0yLCBjb2xvcjtcbiAgICBtMSA9IC8oW2Etel0rKVxcKCguKilcXCkvLmV4ZWMoZm9ybWF0ID0gZm9ybWF0LnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChtMSkge1xuICAgICAgbTIgPSBtMVsyXS5zcGxpdChcIixcIik7XG4gICAgICBzd2l0Y2ggKG0xWzFdKSB7XG4gICAgICAgY2FzZSBcImhzbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGhzbChwYXJzZUZsb2F0KG0yWzBdKSwgcGFyc2VGbG9hdChtMlsxXSkgLyAxMDAsIHBhcnNlRmxvYXQobTJbMl0pIC8gMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgY2FzZSBcInJnYlwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHJnYihkM19yZ2JfcGFyc2VOdW1iZXIobTJbMF0pLCBkM19yZ2JfcGFyc2VOdW1iZXIobTJbMV0pLCBkM19yZ2JfcGFyc2VOdW1iZXIobTJbMl0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sb3IgPSBkM19yZ2JfbmFtZXMuZ2V0KGZvcm1hdCkpIHtcbiAgICAgIHJldHVybiByZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQuY2hhckF0KDApID09PSBcIiNcIiAmJiAhaXNOYU4oY29sb3IgPSBwYXJzZUludChmb3JtYXQuc2xpY2UoMSksIDE2KSkpIHtcbiAgICAgIGlmIChmb3JtYXQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHIgPSAoY29sb3IgJiAzODQwKSA+PiA0O1xuICAgICAgICByID0gciA+PiA0IHwgcjtcbiAgICAgICAgZyA9IGNvbG9yICYgMjQwO1xuICAgICAgICBnID0gZyA+PiA0IHwgZztcbiAgICAgICAgYiA9IGNvbG9yICYgMTU7XG4gICAgICAgIGIgPSBiIDw8IDQgfCBiO1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHIgPSAoY29sb3IgJiAxNjcxMTY4MCkgPj4gMTY7XG4gICAgICAgIGcgPSAoY29sb3IgJiA2NTI4MCkgPj4gODtcbiAgICAgICAgYiA9IGNvbG9yICYgMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiKHIsIGcsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9oc2wociwgZywgYikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyIC89IDI1NSwgZyAvPSAyNTUsIGIgLz0gMjU1KSwgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIGQgPSBtYXggLSBtaW4sIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgaWYgKGQpIHtcbiAgICAgIHMgPSBsIDwgLjUgPyBkIC8gKG1heCArIG1pbikgOiBkIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgaWYgKHIgPT0gbWF4KSBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGVsc2UgaWYgKGcgPT0gbWF4KSBoID0gKGIgLSByKSAvIGQgKyAyOyBlbHNlIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gTmFOO1xuICAgICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZDNfaHNsKGgsIHMsIGwpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9sYWIociwgZywgYikge1xuICAgIHIgPSBkM19yZ2JfeHl6KHIpO1xuICAgIGcgPSBkM19yZ2JfeHl6KGcpO1xuICAgIGIgPSBkM19yZ2JfeHl6KGIpO1xuICAgIHZhciB4ID0gZDNfeHl6X2xhYigoLjQxMjQ1NjQgKiByICsgLjM1NzU3NjEgKiBnICsgLjE4MDQzNzUgKiBiKSAvIGQzX2xhYl9YKSwgeSA9IGQzX3h5el9sYWIoKC4yMTI2NzI5ICogciArIC43MTUxNTIyICogZyArIC4wNzIxNzUgKiBiKSAvIGQzX2xhYl9ZKSwgeiA9IGQzX3h5el9sYWIoKC4wMTkzMzM5ICogciArIC4xMTkxOTIgKiBnICsgLjk1MDMwNDEgKiBiKSAvIGQzX2xhYl9aKTtcbiAgICByZXR1cm4gZDNfbGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3h5eihyKSB7XG4gICAgcmV0dXJuIChyIC89IDI1NSkgPD0gLjA0MDQ1ID8gciAvIDEyLjkyIDogTWF0aC5wb3coKHIgKyAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9wYXJzZU51bWJlcihjKSB7XG4gICAgdmFyIGYgPSBwYXJzZUZsb2F0KGMpO1xuICAgIHJldHVybiBjLmNoYXJBdChjLmxlbmd0aCAtIDEpID09PSBcIiVcIiA/IE1hdGgucm91bmQoZiAqIDIuNTUpIDogZjtcbiAgfVxuICB2YXIgZDNfcmdiX25hbWVzID0gZDMubWFwKHtcbiAgICBhbGljZWJsdWU6IDE1NzkyMzgzLFxuICAgIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gICAgYXF1YTogNjU1MzUsXG4gICAgYXF1YW1hcmluZTogODM4ODU2NCxcbiAgICBhenVyZTogMTU3OTQxNzUsXG4gICAgYmVpZ2U6IDE2MTE5MjYwLFxuICAgIGJpc3F1ZTogMTY3NzAyNDQsXG4gICAgYmxhY2s6IDAsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LFxuICAgIGJsdWU6IDI1NSxcbiAgICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICAgIGJyb3duOiAxMDgyNDIzNCxcbiAgICBidXJseXdvb2Q6IDE0NTk2MjMxLFxuICAgIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgICBjaGFydHJldXNlOiA4Mzg4MzUyLFxuICAgIGNob2NvbGF0ZTogMTM3ODk0NzAsXG4gICAgY29yYWw6IDE2NzQ0MjcyLFxuICAgIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLFxuICAgIGNvcm5zaWxrOiAxNjc3NTM4OCxcbiAgICBjcmltc29uOiAxNDQyMzEwMCxcbiAgICBjeWFuOiA2NTUzNSxcbiAgICBkYXJrYmx1ZTogMTM5LFxuICAgIGRhcmtjeWFuOiAzNTcyMyxcbiAgICBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSxcbiAgICBkYXJrZ3JheTogMTExMTkwMTcsXG4gICAgZGFya2dyZWVuOiAyNTYwMCxcbiAgICBkYXJrZ3JleTogMTExMTkwMTcsXG4gICAgZGFya2toYWtpOiAxMjQzMzI1OSxcbiAgICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgICBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSxcbiAgICBkYXJrb3JhbmdlOiAxNjc0NzUyMCxcbiAgICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgICBkYXJrcmVkOiA5MTA5NTA0LFxuICAgIGRhcmtzYWxtb246IDE1MzA4NDEwLFxuICAgIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgICBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LFxuICAgIGRhcmtzbGF0ZWdyYXk6IDMxMDA0OTUsXG4gICAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgICBkYXJrdHVycXVvaXNlOiA1Mjk0NSxcbiAgICBkYXJrdmlvbGV0OiA5Njk5NTM5LFxuICAgIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgICBkZWVwc2t5Ymx1ZTogNDkxNTEsXG4gICAgZGltZ3JheTogNjkwODI2NSxcbiAgICBkaW1ncmV5OiA2OTA4MjY1LFxuICAgIGRvZGdlcmJsdWU6IDIwMDMxOTksXG4gICAgZmlyZWJyaWNrOiAxMTY3NDE0NixcbiAgICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gICAgZm9yZXN0Z3JlZW46IDIyNjM4NDIsXG4gICAgZnVjaHNpYTogMTY3MTE5MzUsXG4gICAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgICBnaG9zdHdoaXRlOiAxNjMxNjY3MSxcbiAgICBnb2xkOiAxNjc2NjcyMCxcbiAgICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICAgIGdyYXk6IDg0MjE1MDQsXG4gICAgZ3JlZW46IDMyNzY4LFxuICAgIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcbiAgICBncmV5OiA4NDIxNTA0LFxuICAgIGhvbmV5ZGV3OiAxNTc5NDE2MCxcbiAgICBob3RwaW5rOiAxNjczODc0MCxcbiAgICBpbmRpYW5yZWQ6IDEzNDU4NTI0LFxuICAgIGluZGlnbzogNDkxNTMzMCxcbiAgICBpdm9yeTogMTY3NzcyMDAsXG4gICAga2hha2k6IDE1Nzg3NjYwLFxuICAgIGxhdmVuZGVyOiAxNTEzMjQxMCxcbiAgICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgICBsYXduZ3JlZW46IDgxOTA5NzYsXG4gICAgbGVtb25jaGlmZm9uOiAxNjc3NTg4NSxcbiAgICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICAgIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LFxuICAgIGxpZ2h0Y3lhbjogMTQ3NDU1OTksXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICAgIGxpZ2h0Z3JheTogMTM4ODIzMjMsXG4gICAgbGlnaHRncmVlbjogOTQ5ODI1NixcbiAgICBsaWdodGdyZXk6IDEzODgyMzIzLFxuICAgIGxpZ2h0cGluazogMTY3NTg0NjUsXG4gICAgbGlnaHRzYWxtb246IDE2NzUyNzYyLFxuICAgIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gICAgbGlnaHRza3libHVlOiA4OTAwMzQ2LFxuICAgIGxpZ2h0c2xhdGVncmF5OiA3ODMzNzUzLFxuICAgIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCxcbiAgICBsaWdodHllbGxvdzogMTY3NzcxODQsXG4gICAgbGltZTogNjUyODAsXG4gICAgbGltZWdyZWVuOiAzMzI5MzMwLFxuICAgIGxpbmVuOiAxNjQ0NTY3MCxcbiAgICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgICBtYXJvb246IDgzODg2MDgsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogNjczNzMyMixcbiAgICBtZWRpdW1ibHVlOiAyMDUsXG4gICAgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NyxcbiAgICBtZWRpdW1wdXJwbGU6IDk2NjI2ODMsXG4gICAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gICAgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiA2NDE1NCxcbiAgICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MyxcbiAgICBtaWRuaWdodGJsdWU6IDE2NDQ5MTIsXG4gICAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgICBtaXN0eXJvc2U6IDE2NzcwMjczLFxuICAgIG1vY2Nhc2luOiAxNjc3MDIyOSxcbiAgICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gICAgbmF2eTogMTI4LFxuICAgIG9sZGxhY2U6IDE2NjQzNTU4LFxuICAgIG9saXZlOiA4NDIxMzc2LFxuICAgIG9saXZlZHJhYjogNzA0ODczOSxcbiAgICBvcmFuZ2U6IDE2NzUzOTIwLFxuICAgIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gICAgb3JjaGlkOiAxNDMxNTczNCxcbiAgICBwYWxlZ29sZGVucm9kOiAxNTY1NzEzMCxcbiAgICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICAgIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LFxuICAgIHBhbGV2aW9sZXRyZWQ6IDE0MzgxMjAzLFxuICAgIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICAgIHBlYWNocHVmZjogMTY3Njc2NzMsXG4gICAgcGVydTogMTM0Njg5OTEsXG4gICAgcGluazogMTY3NjEwMzUsXG4gICAgcGx1bTogMTQ1MjQ2MzcsXG4gICAgcG93ZGVyYmx1ZTogMTE1OTE5MTAsXG4gICAgcHVycGxlOiA4Mzg4NzM2LFxuICAgIHJlYmVjY2FwdXJwbGU6IDY2OTc4ODEsXG4gICAgcmVkOiAxNjcxMTY4MCxcbiAgICByb3N5YnJvd246IDEyMzU3NTE5LFxuICAgIHJveWFsYmx1ZTogNDI4Njk0NSxcbiAgICBzYWRkbGVicm93bjogOTEyNzE4NyxcbiAgICBzYWxtb246IDE2NDE2ODgyLFxuICAgIHNhbmR5YnJvd246IDE2MDMyODY0LFxuICAgIHNlYWdyZWVuOiAzMDUwMzI3LFxuICAgIHNlYXNoZWxsOiAxNjc3NDYzOCxcbiAgICBzaWVubmE6IDEwNTA2Nzk3LFxuICAgIHNpbHZlcjogMTI2MzIyNTYsXG4gICAgc2t5Ymx1ZTogODkwMDMzMSxcbiAgICBzbGF0ZWJsdWU6IDY5NzAwNjEsXG4gICAgc2xhdGVncmF5OiA3MzcyOTQ0LFxuICAgIHNsYXRlZ3JleTogNzM3Mjk0NCxcbiAgICBzbm93OiAxNjc3NTkzMCxcbiAgICBzcHJpbmdncmVlbjogNjU0MDcsXG4gICAgc3RlZWxibHVlOiA0NjIwOTgwLFxuICAgIHRhbjogMTM4MDg3ODAsXG4gICAgdGVhbDogMzI4OTYsXG4gICAgdGhpc3RsZTogMTQyMDQ4ODgsXG4gICAgdG9tYXRvOiAxNjczNzA5NSxcbiAgICB0dXJxdW9pc2U6IDQyNTE4NTYsXG4gICAgdmlvbGV0OiAxNTYzMTA4NixcbiAgICB3aGVhdDogMTYxMTMzMzEsXG4gICAgd2hpdGU6IDE2Nzc3MjE1LFxuICAgIHdoaXRlc21va2U6IDE2MTE5Mjg1LFxuICAgIHllbGxvdzogMTY3NzY5NjAsXG4gICAgeWVsbG93Z3JlZW46IDEwMTQ1MDc0XG4gIH0pO1xuICBkM19yZ2JfbmFtZXMuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgZDNfcmdiX25hbWVzLnNldChrZXksIGQzX3JnYk51bWJlcih2YWx1ZSkpO1xuICB9KTtcbiAgZnVuY3Rpb24gZDNfZnVuY3Rvcih2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgPyB2IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICB9XG4gIGQzLmZ1bmN0b3IgPSBkM19mdW5jdG9yO1xuICBkMy54aHIgPSBkM194aHJUeXBlKGQzX2lkZW50aXR5KTtcbiAgZnVuY3Rpb24gZDNfeGhyVHlwZShyZXNwb25zZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih1cmwsIG1pbWVUeXBlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG1pbWVUeXBlID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrID0gbWltZVR5cGUsIFxuICAgICAgbWltZVR5cGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGQzX3hocih1cmwsIG1pbWVUeXBlLCByZXNwb25zZSwgY2FsbGJhY2spO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSB7fSwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaChcImJlZm9yZXNlbmRcIiwgXCJwcm9ncmVzc1wiLCBcImxvYWRcIiwgXCJlcnJvclwiKSwgaGVhZGVycyA9IHt9LCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksIHJlc3BvbnNlVHlwZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuWERvbWFpblJlcXVlc3QgJiYgIShcIndpdGhDcmVkZW50aWFsc1wiIGluIHJlcXVlc3QpICYmIC9eKGh0dHAocyk/Oik/XFwvXFwvLy50ZXN0KHVybCkpIHJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICBcIm9ubG9hZFwiIGluIHJlcXVlc3QgPyByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmQgOiByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5yZWFkeVN0YXRlID4gMyAmJiByZXNwb25kKCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZXNwb25kKCkge1xuICAgICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzLCByZXN1bHQ7XG4gICAgICBpZiAoIXN0YXR1cyAmJiBkM194aHJIYXNSZXNwb25zZShyZXF1ZXN0KSB8fCBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRpc3BhdGNoLmVycm9yLmNhbGwoeGhyLCBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2gubG9hZC5jYWxsKHhociwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoLmVycm9yLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBvID0gZDMuZXZlbnQ7XG4gICAgICBkMy5ldmVudCA9IGV2ZW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGlzcGF0Y2gucHJvZ3Jlc3MuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDMuZXZlbnQgPSBvO1xuICAgICAgfVxuICAgIH07XG4gICAgeGhyLmhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBuYW1lID0gKG5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gaGVhZGVyc1tuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSBkZWxldGUgaGVhZGVyc1tuYW1lXTsgZWxzZSBoZWFkZXJzW25hbWVdID0gdmFsdWUgKyBcIlwiO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5taW1lVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW1lVHlwZTtcbiAgICAgIG1pbWVUeXBlID0gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZSArIFwiXCI7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByZXNwb25zZVR5cGU7XG4gICAgICByZXNwb25zZVR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIucmVzcG9uc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzcG9uc2UgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBbIFwiZ2V0XCIsIFwicG9zdFwiIF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHhoclttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB4aHIuc2VuZC5hcHBseSh4aHIsIFsgbWV0aG9kIF0uY29uY2F0KGQzX2FycmF5KGFyZ3VtZW50cykpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgeGhyLnNlbmQgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICAgICAgcmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgIGlmIChtaW1lVHlwZSAhPSBudWxsICYmICEoXCJhY2NlcHRcIiBpbiBoZWFkZXJzKSkgaGVhZGVyc1tcImFjY2VwdFwiXSA9IG1pbWVUeXBlICsgXCIsKi8qXCI7XG4gICAgICBpZiAocmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKSBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgIGlmIChtaW1lVHlwZSAhPSBudWxsICYmIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSkgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKG1pbWVUeXBlKTtcbiAgICAgIGlmIChyZXNwb25zZVR5cGUgIT0gbnVsbCkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgeGhyLm9uKFwiZXJyb3JcIiwgY2FsbGJhY2spLm9uKFwibG9hZFwiLCBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgICBkaXNwYXRjaC5iZWZvcmVzZW5kLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIHJlcXVlc3Quc2VuZChkYXRhID09IG51bGwgPyBudWxsIDogZGF0YSk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgZDMucmViaW5kKHhociwgZGlzcGF0Y2gsIFwib25cIik7XG4gICAgcmV0dXJuIGNhbGxiYWNrID09IG51bGwgPyB4aHIgOiB4aHIuZ2V0KGQzX3hocl9maXhDYWxsYmFjayhjYWxsYmFjaykpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hocl9maXhDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHJldHVybiBjYWxsYmFjay5sZW5ndGggPT09IDEgPyBmdW5jdGlvbihlcnJvciwgcmVxdWVzdCkge1xuICAgICAgY2FsbGJhY2soZXJyb3IgPT0gbnVsbCA/IHJlcXVlc3QgOiBudWxsKTtcbiAgICB9IDogY2FsbGJhY2s7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIHZhciB0eXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gXCJ0ZXh0XCIgPyByZXF1ZXN0LnJlc3BvbnNlIDogcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbiAgZDMuZHN2ID0gZnVuY3Rpb24oZGVsaW1pdGVyLCBtaW1lVHlwZSkge1xuICAgIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoJ1tcIicgKyBkZWxpbWl0ZXIgKyBcIlxcbl1cIiksIGRlbGltaXRlckNvZGUgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcbiAgICBmdW5jdGlvbiBkc3YodXJsLCByb3csIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGNhbGxiYWNrID0gcm93LCByb3cgPSBudWxsO1xuICAgICAgdmFyIHhociA9IGQzX3hocih1cmwsIG1pbWVUeXBlLCByb3cgPT0gbnVsbCA/IHJlc3BvbnNlIDogdHlwZWRSZXNwb25zZShyb3cpLCBjYWxsYmFjayk7XG4gICAgICB4aHIucm93ID0gZnVuY3Rpb24oXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHhoci5yZXNwb25zZSgocm93ID0gXykgPT0gbnVsbCA/IHJlc3BvbnNlIDogdHlwZWRSZXNwb25zZShfKSkgOiByb3c7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2UocmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGRzdi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVkUmVzcG9uc2UoZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIGRzdi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCwgZik7XG4gICAgICB9O1xuICAgIH1cbiAgICBkc3YucGFyc2UgPSBmdW5jdGlvbih0ZXh0LCBmKSB7XG4gICAgICB2YXIgbztcbiAgICAgIHJldHVybiBkc3YucGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgICBpZiAobykgcmV0dXJuIG8ocm93LCBpIC0gMSk7XG4gICAgICAgIHZhciBhID0gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyByb3cubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl1cIjtcbiAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG4gICAgICAgIG8gPSBmID8gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGYoYShyb3cpLCBpKTtcbiAgICAgICAgfSA6IGE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGRzdi5wYXJzZVJvd3MgPSBmdW5jdGlvbih0ZXh0LCBmKSB7XG4gICAgICB2YXIgRU9MID0ge30sIEVPRiA9IHt9LCByb3dzID0gW10sIE4gPSB0ZXh0Lmxlbmd0aCwgSSA9IDAsIG4gPSAwLCB0LCBlb2w7XG4gICAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgICAgaWYgKEkgPj0gTikgcmV0dXJuIEVPRjtcbiAgICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG4gICAgICAgIHZhciBqID0gSTtcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gMzQpIHtcbiAgICAgICAgICB2YXIgaSA9IGo7XG4gICAgICAgICAgd2hpbGUgKGkrKyA8IE4pIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDM0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNCkgYnJlYWs7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSSA9IGkgKyAyO1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSA9PT0gMTApICsrSTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDEwKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSkucmVwbGFjZSgvXCJcIi9nLCAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChJKyspLCBrID0gMTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTApIGVvbCA9IHRydWU7IGVsc2UgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gMTApICsrSSwgKytrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gZGVsaW1pdGVyQ29kZSkgY29udGludWU7XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgSSAtIGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGopO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikge1xuICAgICAgICAgIGEucHVzaCh0KTtcbiAgICAgICAgICB0ID0gdG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiAmJiAoYSA9IGYoYSwgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIHJvd3MucHVzaChhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgZHN2LmZvcm1hdCA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3NbMF0pKSByZXR1cm4gZHN2LmZvcm1hdFJvd3Mocm93cyk7XG4gICAgICB2YXIgZmllbGRTZXQgPSBuZXcgZDNfU2V0KCksIGZpZWxkcyA9IFtdO1xuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiByb3cpIHtcbiAgICAgICAgICBpZiAoIWZpZWxkU2V0LmhhcyhmaWVsZCkpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkU2V0LmFkZChmaWVsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gWyBmaWVsZHMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcikgXS5jb25jYXQocm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiBmaWVsZHMubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tmaWVsZF0pO1xuICAgICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgICB9KSkuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIGRzdi5mb3JtYXRSb3dzID0gZnVuY3Rpb24ocm93cykge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcbiAgICAgIHJldHVybiByZUZvcm1hdC50ZXN0KHRleHQpID8gJ1wiJyArIHRleHQucmVwbGFjZSgvXFxcIi9nLCAnXCJcIicpICsgJ1wiJyA6IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBkc3Y7XG4gIH07XG4gIGQzLmNzdiA9IGQzLmRzdihcIixcIiwgXCJ0ZXh0L2NzdlwiKTtcbiAgZDMudHN2ID0gZDMuZHN2KFwiXHRcIiwgXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCIpO1xuICB2YXIgZDNfdGltZXJfcXVldWVIZWFkLCBkM190aW1lcl9xdWV1ZVRhaWwsIGQzX3RpbWVyX2ludGVydmFsLCBkM190aW1lcl90aW1lb3V0LCBkM190aW1lcl9mcmFtZSA9IHRoaXNbZDNfdmVuZG9yU3ltYm9sKHRoaXMsIFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpXSB8fCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE3KTtcbiAgfTtcbiAgZDMudGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBkM190aW1lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM190aW1lcihjYWxsYmFjaywgZGVsYXksIHRoZW4pIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAyKSBkZWxheSA9IDA7XG4gICAgaWYgKG4gPCAzKSB0aGVuID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZSA9IHRoZW4gKyBkZWxheSwgdGltZXIgPSB7XG4gICAgICBjOiBjYWxsYmFjayxcbiAgICAgIHQ6IHRpbWUsXG4gICAgICBuOiBudWxsXG4gICAgfTtcbiAgICBpZiAoZDNfdGltZXJfcXVldWVUYWlsKSBkM190aW1lcl9xdWV1ZVRhaWwubiA9IHRpbWVyOyBlbHNlIGQzX3RpbWVyX3F1ZXVlSGVhZCA9IHRpbWVyO1xuICAgIGQzX3RpbWVyX3F1ZXVlVGFpbCA9IHRpbWVyO1xuICAgIGlmICghZDNfdGltZXJfaW50ZXJ2YWwpIHtcbiAgICAgIGQzX3RpbWVyX3RpbWVvdXQgPSBjbGVhclRpbWVvdXQoZDNfdGltZXJfdGltZW91dCk7XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDE7XG4gICAgICBkM190aW1lcl9mcmFtZShkM190aW1lcl9zdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX3N0ZXAoKSB7XG4gICAgdmFyIG5vdyA9IGQzX3RpbWVyX21hcmsoKSwgZGVsYXkgPSBkM190aW1lcl9zd2VlcCgpIC0gbm93O1xuICAgIGlmIChkZWxheSA+IDI0KSB7XG4gICAgICBpZiAoaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkM190aW1lcl90aW1lb3V0KTtcbiAgICAgICAgZDNfdGltZXJfdGltZW91dCA9IHNldFRpbWVvdXQoZDNfdGltZXJfc3RlcCwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDE7XG4gICAgICBkM190aW1lcl9mcmFtZShkM190aW1lcl9zdGVwKTtcbiAgICB9XG4gIH1cbiAgZDMudGltZXIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBkM190aW1lcl9tYXJrKCk7XG4gICAgZDNfdGltZXJfc3dlZXAoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdGltZXJfbWFyaygpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKSwgdGltZXIgPSBkM190aW1lcl9xdWV1ZUhlYWQ7XG4gICAgd2hpbGUgKHRpbWVyKSB7XG4gICAgICBpZiAobm93ID49IHRpbWVyLnQgJiYgdGltZXIuYyhub3cgLSB0aW1lci50KSkgdGltZXIuYyA9IG51bGw7XG4gICAgICB0aW1lciA9IHRpbWVyLm47XG4gICAgfVxuICAgIHJldHVybiBub3c7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZXJfc3dlZXAoKSB7XG4gICAgdmFyIHQwLCB0MSA9IGQzX3RpbWVyX3F1ZXVlSGVhZCwgdGltZSA9IEluZmluaXR5O1xuICAgIHdoaWxlICh0MSkge1xuICAgICAgaWYgKHQxLmMpIHtcbiAgICAgICAgaWYgKHQxLnQgPCB0aW1lKSB0aW1lID0gdDEudDtcbiAgICAgICAgdDEgPSAodDAgPSB0MSkubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQxID0gdDAgPyB0MC5uID0gdDEubiA6IGQzX3RpbWVyX3F1ZXVlSGVhZCA9IHQxLm47XG4gICAgICB9XG4gICAgfVxuICAgIGQzX3RpbWVyX3F1ZXVlVGFpbCA9IHQwO1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCwgcCkge1xuICAgIHJldHVybiBwIC0gKHggPyBNYXRoLmNlaWwoTWF0aC5sb2coeCkgLyBNYXRoLkxOMTApIDogMSk7XG4gIH1cbiAgZDMucm91bmQgPSBmdW5jdGlvbih4LCBuKSB7XG4gICAgcmV0dXJuIG4gPyBNYXRoLnJvdW5kKHggKiAobiA9IE1hdGgucG93KDEwLCBuKSkpIC8gbiA6IE1hdGgucm91bmQoeCk7XG4gIH07XG4gIHZhciBkM19mb3JtYXRQcmVmaXhlcyA9IFsgXCJ5XCIsIFwielwiLCBcImFcIiwgXCJmXCIsIFwicFwiLCBcIm5cIiwgXCLCtVwiLCBcIm1cIiwgXCJcIiwgXCJrXCIsIFwiTVwiLCBcIkdcIiwgXCJUXCIsIFwiUFwiLCBcIkVcIiwgXCJaXCIsIFwiWVwiIF0ubWFwKGQzX2Zvcm1hdFByZWZpeCk7XG4gIGQzLmZvcm1hdFByZWZpeCA9IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSAqPSAtMTtcbiAgICAgIGlmIChwcmVjaXNpb24pIHZhbHVlID0gZDMucm91bmQodmFsdWUsIGQzX2Zvcm1hdF9wcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikpO1xuICAgICAgaSA9IDEgKyBNYXRoLmZsb29yKDFlLTEyICsgTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwKTtcbiAgICAgIGkgPSBNYXRoLm1heCgtMjQsIE1hdGgubWluKDI0LCBNYXRoLmZsb29yKChpIC0gMSkgLyAzKSAqIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX2Zvcm1hdFByZWZpeGVzWzggKyBpIC8gM107XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Zvcm1hdFByZWZpeChkLCBpKSB7XG4gICAgdmFyIGsgPSBNYXRoLnBvdygxMCwgYWJzKDggLSBpKSAqIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogaSA+IDggPyBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkIC8gaztcbiAgICAgIH0gOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkICogaztcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6IGRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xvY2FsZV9udW1iZXJGb3JtYXQobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwsIGxvY2FsZV90aG91c2FuZHMgPSBsb2NhbGUudGhvdXNhbmRzLCBsb2NhbGVfZ3JvdXBpbmcgPSBsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZV9jdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSwgZm9ybWF0R3JvdXAgPSBsb2NhbGVfZ3JvdXBpbmcgJiYgbG9jYWxlX3Rob3VzYW5kcyA/IGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsIHQgPSBbXSwgaiA9IDAsIGcgPSBsb2NhbGVfZ3JvdXBpbmdbMF0sIGxlbmd0aCA9IDA7XG4gICAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICAgIGcgPSBsb2NhbGVfZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBsb2NhbGVfZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKGxvY2FsZV90aG91c2FuZHMpO1xuICAgIH0gOiBkM19pZGVudGl0eTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkM19mb3JtYXRfcmUuZXhlYyhzcGVjaWZpZXIpLCBmaWxsID0gbWF0Y2hbMV0gfHwgXCIgXCIsIGFsaWduID0gbWF0Y2hbMl0gfHwgXCI+XCIsIHNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIiwgc3ltYm9sID0gbWF0Y2hbNF0gfHwgXCJcIiwgemZpbGwgPSBtYXRjaFs1XSwgd2lkdGggPSArbWF0Y2hbNl0sIGNvbW1hID0gbWF0Y2hbN10sIHByZWNpc2lvbiA9IG1hdGNoWzhdLCB0eXBlID0gbWF0Y2hbOV0sIHNjYWxlID0gMSwgcHJlZml4ID0gXCJcIiwgc3VmZml4ID0gXCJcIiwgaW50ZWdlciA9IGZhbHNlLCBleHBvbmVudCA9IHRydWU7XG4gICAgICBpZiAocHJlY2lzaW9uKSBwcmVjaXNpb24gPSArcHJlY2lzaW9uLnN1YnN0cmluZygxKTtcbiAgICAgIGlmICh6ZmlsbCB8fCBmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpIHtcbiAgICAgICAgemZpbGwgPSBmaWxsID0gXCIwXCI7XG4gICAgICAgIGFsaWduID0gXCI9XCI7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICBjb21tYSA9IHRydWU7XG4gICAgICAgIHR5cGUgPSBcImdcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBzY2FsZSA9IDEwMDtcbiAgICAgICAgc3VmZml4ID0gXCIlXCI7XG4gICAgICAgIHR5cGUgPSBcImZcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBzY2FsZSA9IDEwMDtcbiAgICAgICAgc3VmZml4ID0gXCIlXCI7XG4gICAgICAgIHR5cGUgPSBcInJcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgY2FzZSBcInhcIjpcbiAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICBpZiAoc3ltYm9sID09PSBcIiNcIikgcHJlZml4ID0gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICBleHBvbmVudCA9IGZhbHNlO1xuXG4gICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgaW50ZWdlciA9IHRydWU7XG4gICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgc2NhbGUgPSAtMTtcbiAgICAgICAgdHlwZSA9IFwiclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2wgPT09IFwiJFwiKSBwcmVmaXggPSBsb2NhbGVfY3VycmVuY3lbMF0sIHN1ZmZpeCA9IGxvY2FsZV9jdXJyZW5jeVsxXTtcbiAgICAgIGlmICh0eXBlID09IFwiclwiICYmICFwcmVjaXNpb24pIHR5cGUgPSBcImdcIjtcbiAgICAgIGlmIChwcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZSA9PSBcImdcIikgcHJlY2lzaW9uID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpOyBlbHNlIGlmICh0eXBlID09IFwiZVwiIHx8IHR5cGUgPT0gXCJmXCIpIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSBkM19mb3JtYXRfdHlwZXMuZ2V0KHR5cGUpIHx8IGQzX2Zvcm1hdF90eXBlRGVmYXVsdDtcbiAgICAgIHZhciB6Y29tbWEgPSB6ZmlsbCAmJiBjb21tYTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZnVsbFN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgaWYgKGludGVnZXIgJiYgdmFsdWUgJSAxKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIG5lZ2F0aXZlID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAodmFsdWUgPSAtdmFsdWUsIFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiID8gXCJcIiA6IHNpZ247XG4gICAgICAgIGlmIChzY2FsZSA8IDApIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IGQzLmZvcm1hdFByZWZpeCh2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICB2YWx1ZSA9IHVuaXQuc2NhbGUodmFsdWUpO1xuICAgICAgICAgIGZ1bGxTdWZmaXggPSB1bml0LnN5bWJvbCArIHN1ZmZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSAqPSBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHR5cGUodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgIHZhciBpID0gdmFsdWUubGFzdEluZGV4T2YoXCIuXCIpLCBiZWZvcmUsIGFmdGVyO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICB2YXIgaiA9IGV4cG9uZW50ID8gdmFsdWUubGFzdEluZGV4T2YoXCJlXCIpIDogLTE7XG4gICAgICAgICAgaWYgKGogPCAwKSBiZWZvcmUgPSB2YWx1ZSwgYWZ0ZXIgPSBcIlwiOyBlbHNlIGJlZm9yZSA9IHZhbHVlLnN1YnN0cmluZygwLCBqKSwgYWZ0ZXIgPSB2YWx1ZS5zdWJzdHJpbmcoaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gdmFsdWUuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgIGFmdGVyID0gbG9jYWxlX2RlY2ltYWwgKyB2YWx1ZS5zdWJzdHJpbmcoaSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghemZpbGwgJiYgY29tbWEpIGJlZm9yZSA9IGZvcm1hdEdyb3VwKGJlZm9yZSwgSW5maW5pdHkpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIGJlZm9yZS5sZW5ndGggKyBhZnRlci5sZW5ndGggKyAoemNvbW1hID8gMCA6IG5lZ2F0aXZlLmxlbmd0aCksIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheShsZW5ndGggPSB3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuICAgICAgICBpZiAoemNvbW1hKSBiZWZvcmUgPSBmb3JtYXRHcm91cChwYWRkaW5nICsgYmVmb3JlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gYWZ0ZXIubGVuZ3RoIDogSW5maW5pdHkpO1xuICAgICAgICBuZWdhdGl2ZSArPSBwcmVmaXg7XG4gICAgICAgIHZhbHVlID0gYmVmb3JlICsgYWZ0ZXI7XG4gICAgICAgIHJldHVybiAoYWxpZ24gPT09IFwiPFwiID8gbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmcgOiBhbGlnbiA9PT0gXCI+XCIgPyBwYWRkaW5nICsgbmVnYXRpdmUgKyB2YWx1ZSA6IGFsaWduID09PSBcIl5cIiA/IHBhZGRpbmcuc3Vic3RyaW5nKDAsIGxlbmd0aCA+Pj0gMSkgKyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZy5zdWJzdHJpbmcobGVuZ3RoKSA6IG5lZ2F0aXZlICsgKHpjb21tYSA/IHZhbHVlIDogcGFkZGluZyArIHZhbHVlKSkgKyBmdWxsU3VmZml4O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19mb3JtYXRfcmUgPSAvKD86KFtee10pPyhbPD49Xl0pKT8oWytcXC0gXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC4tP1xcZCspPyhbYS16JV0pPy9pO1xuICB2YXIgZDNfZm9ybWF0X3R5cGVzID0gZDMubWFwKHtcbiAgICBiOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZygyKTtcbiAgICB9LFxuICAgIGM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoOCk7XG4gICAgfSxcbiAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZygxNik7XG4gICAgfSxcbiAgICBYOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIGc6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvUHJlY2lzaW9uKHApO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9FeHBvbmVudGlhbChwKTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQocCk7XG4gICAgfSxcbiAgICByOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4gKHggPSBkMy5yb3VuZCh4LCBkM19mb3JtYXRfcHJlY2lzaW9uKHgsIHApKSkudG9GaXhlZChNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgZDNfZm9ybWF0X3ByZWNpc2lvbih4ICogKDEgKyAxZS0xNSksIHApKSkpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2Zvcm1hdF90eXBlRGVmYXVsdCh4KSB7XG4gICAgcmV0dXJuIHggKyBcIlwiO1xuICB9XG4gIHZhciBkM190aW1lID0gZDMudGltZSA9IHt9LCBkM19kYXRlID0gRGF0ZTtcbiAgZnVuY3Rpb24gZDNfZGF0ZV91dGMoKSB7XG4gICAgdGhpcy5fID0gbmV3IERhdGUoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBEYXRlLlVUQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdKTtcbiAgfVxuICBkM19kYXRlX3V0Yy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0RGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0RhdGUoKTtcbiAgICB9LFxuICAgIGdldERheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0RheSgpO1xuICAgIH0sXG4gICAgZ2V0RnVsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENGdWxsWWVhcigpO1xuICAgIH0sXG4gICAgZ2V0SG91cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENIb3VycygpO1xuICAgIH0sXG4gICAgZ2V0TWlsbGlzZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgfSxcbiAgICBnZXRNaW51dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTWludXRlcygpO1xuICAgIH0sXG4gICAgZ2V0TW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNb250aCgpO1xuICAgIH0sXG4gICAgZ2V0U2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ1NlY29uZHMoKTtcbiAgICB9LFxuICAgIGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRUaW1lKCk7XG4gICAgfSxcbiAgICBnZXRUaW1lem9uZU9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy52YWx1ZU9mKCk7XG4gICAgfSxcbiAgICBzZXREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0RhdGUuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0RheS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRGdWxsWWVhcjogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENGdWxsWWVhci5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRIb3VyczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENIb3Vycy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNaWxsaXNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTWlsbGlzZWNvbmRzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1pbnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTWludXRlcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNb250aDogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNb250aC5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRTZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ1NlY29uZHMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRUaW1lLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIHZhciBkM190aW1lX3Byb3RvdHlwZSA9IERhdGUucHJvdG90eXBlO1xuICBmdW5jdGlvbiBkM190aW1lX2ludGVydmFsKGxvY2FsLCBzdGVwLCBudW1iZXIpIHtcbiAgICBmdW5jdGlvbiByb3VuZChkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBsb2NhbChkYXRlKSwgZDEgPSBvZmZzZXQoZDAsIDEpO1xuICAgICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlaWwoZGF0ZSkge1xuICAgICAgc3RlcChkYXRlID0gbG9jYWwobmV3IGQzX2RhdGUoZGF0ZSAtIDEpKSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2Zmc2V0KGRhdGUsIGspIHtcbiAgICAgIHN0ZXAoZGF0ZSA9IG5ldyBkM19kYXRlKCtkYXRlKSwgayk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2UodDAsIHQxLCBkdCkge1xuICAgICAgdmFyIHRpbWUgPSBjZWlsKHQwKSwgdGltZXMgPSBbXTtcbiAgICAgIGlmIChkdCA+IDEpIHtcbiAgICAgICAgd2hpbGUgKHRpbWUgPCB0MSkge1xuICAgICAgICAgIGlmICghKG51bWJlcih0aW1lKSAlIGR0KSkgdGltZXMucHVzaChuZXcgRGF0ZSgrdGltZSkpO1xuICAgICAgICAgIHN0ZXAodGltZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlICh0aW1lIDwgdDEpIHRpbWVzLnB1c2gobmV3IERhdGUoK3RpbWUpKSwgc3RlcCh0aW1lLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VfdXRjKHQwLCB0MSwgZHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlX3V0YygpO1xuICAgICAgICB1dGMuXyA9IHQwO1xuICAgICAgICByZXR1cm4gcmFuZ2UodXRjLCB0MSwgZHQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGxvY2FsLmZsb29yID0gbG9jYWw7XG4gICAgbG9jYWwucm91bmQgPSByb3VuZDtcbiAgICBsb2NhbC5jZWlsID0gY2VpbDtcbiAgICBsb2NhbC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgbG9jYWwucmFuZ2UgPSByYW5nZTtcbiAgICB2YXIgdXRjID0gbG9jYWwudXRjID0gZDNfdGltZV9pbnRlcnZhbF91dGMobG9jYWwpO1xuICAgIHV0Yy5mbG9vciA9IHV0YztcbiAgICB1dGMucm91bmQgPSBkM190aW1lX2ludGVydmFsX3V0Yyhyb3VuZCk7XG4gICAgdXRjLmNlaWwgPSBkM190aW1lX2ludGVydmFsX3V0YyhjZWlsKTtcbiAgICB1dGMub2Zmc2V0ID0gZDNfdGltZV9pbnRlcnZhbF91dGMob2Zmc2V0KTtcbiAgICB1dGMucmFuZ2UgPSByYW5nZV91dGM7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfaW50ZXJ2YWxfdXRjKG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlLCBrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZV91dGMoKTtcbiAgICAgICAgdXRjLl8gPSBkYXRlO1xuICAgICAgICByZXR1cm4gbWV0aG9kKHV0YywgaykuXztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDNfdGltZS55ZWFyID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuICBkM190aW1lLnllYXJzID0gZDNfdGltZS55ZWFyLnJhbmdlO1xuICBkM190aW1lLnllYXJzLnV0YyA9IGQzX3RpbWUueWVhci51dGMucmFuZ2U7XG4gIGQzX3RpbWUuZGF5ID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGRheSA9IG5ldyBkM19kYXRlKDJlMywgMCk7XG4gICAgZGF5LnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgcmV0dXJuIGRheTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldERhdGUoKSAtIDE7XG4gIH0pO1xuICBkM190aW1lLmRheXMgPSBkM190aW1lLmRheS5yYW5nZTtcbiAgZDNfdGltZS5kYXlzLnV0YyA9IGQzX3RpbWUuZGF5LnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5kYXlPZlllYXIgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIHllYXIgPSBkM190aW1lLnllYXIoZGF0ZSk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUgLSB5ZWFyIC0gKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHllYXIuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTUpO1xuICB9O1xuICBbIFwic3VuZGF5XCIsIFwibW9uZGF5XCIsIFwidHVlc2RheVwiLCBcIndlZG5lc2RheVwiLCBcInRodXJzZGF5XCIsIFwiZnJpZGF5XCIsIFwic2F0dXJkYXlcIiBdLmZvckVhY2goZnVuY3Rpb24oZGF5LCBpKSB7XG4gICAgaSA9IDcgLSBpO1xuICAgIHZhciBpbnRlcnZhbCA9IGQzX3RpbWVbZGF5XSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgKGRhdGUgPSBkM190aW1lLmRheShkYXRlKSkuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgaSkgJSA3KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGRheSA9IGQzX3RpbWUueWVhcihkYXRlKS5nZXREYXkoKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChkM190aW1lLmRheU9mWWVhcihkYXRlKSArIChkYXkgKyBpKSAlIDcpIC8gNykgLSAoZGF5ICE9PSBpKTtcbiAgICB9KTtcbiAgICBkM190aW1lW2RheSArIFwic1wiXSA9IGludGVydmFsLnJhbmdlO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJzXCJdLnV0YyA9IGludGVydmFsLnV0Yy5yYW5nZTtcbiAgICBkM190aW1lW2RheSArIFwiT2ZZZWFyXCJdID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGRheSA9IGQzX3RpbWUueWVhcihkYXRlKS5nZXREYXkoKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChkM190aW1lLmRheU9mWWVhcihkYXRlKSArIChkYXkgKyBpKSAlIDcpIC8gNyk7XG4gICAgfTtcbiAgfSk7XG4gIGQzX3RpbWUud2VlayA9IGQzX3RpbWUuc3VuZGF5O1xuICBkM190aW1lLndlZWtzID0gZDNfdGltZS5zdW5kYXkucmFuZ2U7XG4gIGQzX3RpbWUud2Vla3MudXRjID0gZDNfdGltZS5zdW5kYXkudXRjLnJhbmdlO1xuICBkM190aW1lLndlZWtPZlllYXIgPSBkM190aW1lLnN1bmRheU9mWWVhcjtcbiAgZnVuY3Rpb24gZDNfbG9jYWxlX3RpbWVGb3JtYXQobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSwgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSwgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSwgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcywgbG9jYWxlX2RheXMgPSBsb2NhbGUuZGF5cywgbG9jYWxlX3Nob3J0RGF5cyA9IGxvY2FsZS5zaG9ydERheXMsIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLCBsb2NhbGVfc2hvcnRNb250aHMgPSBsb2NhbGUuc2hvcnRNb250aHM7XG4gICAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXQodGVtcGxhdGUpIHtcbiAgICAgIHZhciBuID0gdGVtcGxhdGUubGVuZ3RoO1xuICAgICAgZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IFtdLCBpID0gLTEsIGogPSAwLCBjLCBwLCBmO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgICAgc3RyaW5nLnB1c2godGVtcGxhdGUuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwID0gZDNfdGltZV9mb3JtYXRQYWRzW2MgPSB0ZW1wbGF0ZS5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSB0ZW1wbGF0ZS5jaGFyQXQoKytpKTtcbiAgICAgICAgICAgIGlmIChmID0gZDNfdGltZV9mb3JtYXRzW2NdKSBjID0gZihkYXRlLCBwID09IG51bGwgPyBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCIgOiBwKTtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcucHVzaCh0ZW1wbGF0ZS5zbGljZShqLCBpKSk7XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgZCA9IHtcbiAgICAgICAgICB5OiAxOTAwLFxuICAgICAgICAgIG06IDAsXG4gICAgICAgICAgZDogMSxcbiAgICAgICAgICBIOiAwLFxuICAgICAgICAgIE06IDAsXG4gICAgICAgICAgUzogMCxcbiAgICAgICAgICBMOiAwLFxuICAgICAgICAgIFo6IG51bGxcbiAgICAgICAgfSwgaSA9IGQzX3RpbWVfcGFyc2UoZCwgdGVtcGxhdGUsIHN0cmluZywgMCk7XG4gICAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcbiAgICAgICAgdmFyIGxvY2FsWiA9IGQuWiAhPSBudWxsICYmIGQzX2RhdGUgIT09IGQzX2RhdGVfdXRjLCBkYXRlID0gbmV3IChsb2NhbFogPyBkM19kYXRlX3V0YyA6IGQzX2RhdGUpKCk7XG4gICAgICAgIGlmIChcImpcIiBpbiBkKSBkYXRlLnNldEZ1bGxZZWFyKGQueSwgMCwgZC5qKTsgZWxzZSBpZiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSB7XG4gICAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IFwiV1wiIGluIGQgPyAxIDogMDtcbiAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSwgMCwgMSk7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXRlLmdldERheSgpICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXRlLmdldERheSgpICsgNikgJSA3KTtcbiAgICAgICAgfSBlbHNlIGRhdGUuc2V0RnVsbFllYXIoZC55LCBkLm0sIGQuZCk7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoZC5IICsgKGQuWiAvIDEwMCB8IDApLCBkLk0gKyBkLlogJSAxMDAsIGQuUywgZC5MKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsWiA/IGRhdGUuXyA6IGRhdGU7XG4gICAgICB9O1xuICAgICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlKGRhdGUsIHRlbXBsYXRlLCBzdHJpbmcsIGopIHtcbiAgICAgIHZhciBjLCBwLCB0LCBpID0gMCwgbiA9IHRlbXBsYXRlLmxlbmd0aCwgbSA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgICBjID0gdGVtcGxhdGUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgICB0ID0gdGVtcGxhdGUuY2hhckF0KGkrKyk7XG4gICAgICAgICAgcCA9IGQzX3RpbWVfcGFyc2Vyc1t0IGluIGQzX3RpbWVfZm9ybWF0UGFkcyA/IHRlbXBsYXRlLmNoYXJBdChpKyspIDogdF07XG4gICAgICAgICAgaWYgKCFwIHx8IChqID0gcChkYXRlLCBzdHJpbmcsIGopKSA8IDApIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBqO1xuICAgIH1cbiAgICBkM190aW1lX2Zvcm1hdC51dGMgPSBmdW5jdGlvbih0ZW1wbGF0ZSkge1xuICAgICAgdmFyIGxvY2FsID0gZDNfdGltZV9mb3JtYXQodGVtcGxhdGUpO1xuICAgICAgZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlKCk7XG4gICAgICAgICAgdXRjLl8gPSBkYXRlO1xuICAgICAgICAgIHJldHVybiBsb2NhbCh1dGMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3JtYXQucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgICAgdmFyIGRhdGUgPSBsb2NhbC5wYXJzZShzdHJpbmcpO1xuICAgICAgICAgIHJldHVybiBkYXRlICYmIGRhdGUuXztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGxvY2FsLnRvU3RyaW5nO1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9O1xuICAgIGQzX3RpbWVfZm9ybWF0Lm11bHRpID0gZDNfdGltZV9mb3JtYXQudXRjLm11bHRpID0gZDNfdGltZV9mb3JtYXRNdWx0aTtcbiAgICB2YXIgZDNfdGltZV9wZXJpb2RMb29rdXAgPSBkMy5tYXAoKSwgZDNfdGltZV9kYXlSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX2RheXMpLCBkM190aW1lX2RheUxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9kYXlzKSwgZDNfdGltZV9kYXlBYmJyZXZSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX3Nob3J0RGF5cyksIGQzX3RpbWVfZGF5QWJicmV2TG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0RGF5cyksIGQzX3RpbWVfbW9udGhSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX21vbnRocyksIGQzX3RpbWVfbW9udGhMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfbW9udGhzKSwgZDNfdGltZV9tb250aEFiYnJldlJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLCBkM190aW1lX21vbnRoQWJicmV2TG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcbiAgICBsb2NhbGVfcGVyaW9kcy5mb3JFYWNoKGZ1bmN0aW9uKHAsIGkpIHtcbiAgICAgIGQzX3RpbWVfcGVyaW9kTG9va3VwLnNldChwLnRvTG93ZXJDYXNlKCksIGkpO1xuICAgIH0pO1xuICAgIHZhciBkM190aW1lX2Zvcm1hdHMgPSB7XG4gICAgICBhOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfc2hvcnREYXlzW2QuZ2V0RGF5KCldO1xuICAgICAgfSxcbiAgICAgIEE6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9kYXlzW2QuZ2V0RGF5KCldO1xuICAgICAgfSxcbiAgICAgIGI6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgICAgfSxcbiAgICAgIEI6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgICAgIH0sXG4gICAgICBjOiBkM190aW1lX2Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUpLFxuICAgICAgZDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIGU6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBIOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEhvdXJzKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIEk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBqOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZCgxICsgZDNfdGltZS5kYXlPZlllYXIoZCksIHAsIDMpO1xuICAgICAgfSxcbiAgICAgIEw6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBwOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0U2Vjb25kcygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBVOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkM190aW1lLnN1bmRheU9mWWVhcihkKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5nZXREYXkoKTtcbiAgICAgIH0sXG4gICAgICBXOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkM190aW1lLm1vbmRheU9mWWVhcihkKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgeDogZDNfdGltZV9mb3JtYXQobG9jYWxlX2RhdGUpLFxuICAgICAgWDogZDNfdGltZV9mb3JtYXQobG9jYWxlX3RpbWUpLFxuICAgICAgeTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBZOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEZ1bGxZZWFyKCkgJSAxZTQsIHAsIDQpO1xuICAgICAgfSxcbiAgICAgIFo6IGQzX3RpbWVfem9uZSxcbiAgICAgIFwiJVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGQzX3RpbWVfcGFyc2VycyA9IHtcbiAgICAgIGE6IGQzX3RpbWVfcGFyc2VXZWVrZGF5QWJicmV2LFxuICAgICAgQTogZDNfdGltZV9wYXJzZVdlZWtkYXksXG4gICAgICBiOiBkM190aW1lX3BhcnNlTW9udGhBYmJyZXYsXG4gICAgICBCOiBkM190aW1lX3BhcnNlTW9udGgsXG4gICAgICBjOiBkM190aW1lX3BhcnNlTG9jYWxlRnVsbCxcbiAgICAgIGQ6IGQzX3RpbWVfcGFyc2VEYXksXG4gICAgICBlOiBkM190aW1lX3BhcnNlRGF5LFxuICAgICAgSDogZDNfdGltZV9wYXJzZUhvdXIyNCxcbiAgICAgIEk6IGQzX3RpbWVfcGFyc2VIb3VyMjQsXG4gICAgICBqOiBkM190aW1lX3BhcnNlRGF5T2ZZZWFyLFxuICAgICAgTDogZDNfdGltZV9wYXJzZU1pbGxpc2Vjb25kcyxcbiAgICAgIG06IGQzX3RpbWVfcGFyc2VNb250aE51bWJlcixcbiAgICAgIE06IGQzX3RpbWVfcGFyc2VNaW51dGVzLFxuICAgICAgcDogZDNfdGltZV9wYXJzZUFtUG0sXG4gICAgICBTOiBkM190aW1lX3BhcnNlU2Vjb25kcyxcbiAgICAgIFU6IGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgdzogZDNfdGltZV9wYXJzZVdlZWtkYXlOdW1iZXIsXG4gICAgICBXOiBkM190aW1lX3BhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICAgIHg6IGQzX3RpbWVfcGFyc2VMb2NhbGVEYXRlLFxuICAgICAgWDogZDNfdGltZV9wYXJzZUxvY2FsZVRpbWUsXG4gICAgICB5OiBkM190aW1lX3BhcnNlWWVhcixcbiAgICAgIFk6IGQzX3RpbWVfcGFyc2VGdWxsWWVhcixcbiAgICAgIFo6IGQzX3RpbWVfcGFyc2Vab25lLFxuICAgICAgXCIlXCI6IGQzX3RpbWVfcGFyc2VMaXRlcmFsUGVyY2VudFxuICAgIH07XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtkYXlBYmJyZXYoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX2RheUFiYnJldlJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfZGF5QWJicmV2UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS53ID0gZDNfdGltZV9kYXlBYmJyZXZMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtkYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX2RheVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS53ID0gZDNfdGltZV9kYXlMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1vbnRoQWJicmV2KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9tb250aEFiYnJldlJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfbW9udGhBYmJyZXZSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLm0gPSBkM190aW1lX21vbnRoQWJicmV2TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfbW9udGhSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX21vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gZDNfdGltZV9tb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlRnVsbChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy5jLnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVEYXRlKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLngudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZVRpbWUoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMuWC50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlQW1QbShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gZDNfdGltZV9wZXJpb2RMb29rdXAuZ2V0KHN0cmluZy5zbGljZShpLCBpICs9IDIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IC0xIDogKGRhdGUucCA9IG4sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdGltZV9mb3JtYXQ7XG4gIH1cbiAgdmFyIGQzX3RpbWVfZm9ybWF0UGFkcyA9IHtcbiAgICBcIi1cIjogXCJcIixcbiAgICBfOiBcIiBcIixcbiAgICBcIjBcIjogXCIwXCJcbiAgfSwgZDNfdGltZV9udW1iZXJSZSA9IC9eXFxzKlxcZCsvLCBkM190aW1lX3BlcmNlbnRSZSA9IC9eJS87XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0UGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLCBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdFJlKG5hbWVzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBuYW1lcy5tYXAoZDMucmVxdW90ZSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBkM19NYXAoKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KG5hbWVzW2ldLnRvTG93ZXJDYXNlKCksIGkpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtkYXlOdW1iZXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJTdW5kYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla051bWJlck1vbmRheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VGdWxsWWVhcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlWWVhcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS55ID0gZDNfdGltZV9leHBhbmRZZWFyKCtuWzBdKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2Vab25lKGRhdGUsIHN0cmluZywgaSkge1xuICAgIHJldHVybiAvXlsrLV1cXGR7NH0kLy50ZXN0KHN0cmluZyA9IHN0cmluZy5zbGljZShpLCBpICsgNSkpID8gKGRhdGUuWiA9IC1zdHJpbmcsIFxuICAgIGkgKyA1KSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZXhwYW5kWWVhcihkKSB7XG4gICAgcmV0dXJuIGQgKyAoZCA+IDY4ID8gMTkwMCA6IDJlMyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1vbnRoTnVtYmVyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VEYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZURheU9mWWVhcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5qID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlSG91cjI0KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNaW51dGVzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VTZWNvbmRzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNaWxsaXNlY29uZHMoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGRhdGUuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV96b25lKGQpIHtcbiAgICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKSwgenMgPSB6ID4gMCA/IFwiLVwiIDogXCIrXCIsIHpoID0gYWJzKHopIC8gNjAgfCAwLCB6bSA9IGFicyh6KSAlIDYwO1xuICAgIHJldHVybiB6cyArIGQzX3RpbWVfZm9ybWF0UGFkKHpoLCBcIjBcIiwgMikgKyBkM190aW1lX2Zvcm1hdFBhZCh6bSwgXCIwXCIsIDIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMaXRlcmFsUGVyY2VudChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX3BlcmNlbnRSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9wZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0TXVsdGkoZm9ybWF0cykge1xuICAgIHZhciBuID0gZm9ybWF0cy5sZW5ndGgsIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbikgZm9ybWF0c1tpXVswXSA9IHRoaXMoZm9ybWF0c1tpXVswXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBpID0gMCwgZiA9IGZvcm1hdHNbaV07XG4gICAgICB3aGlsZSAoIWZbMV0oZGF0ZSkpIGYgPSBmb3JtYXRzWysraV07XG4gICAgICByZXR1cm4gZlswXShkYXRlKTtcbiAgICB9O1xuICB9XG4gIGQzLmxvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXJGb3JtYXQ6IGQzX2xvY2FsZV9udW1iZXJGb3JtYXQobG9jYWxlKSxcbiAgICAgIHRpbWVGb3JtYXQ6IGQzX2xvY2FsZV90aW1lRm9ybWF0KGxvY2FsZSlcbiAgICB9O1xuICB9O1xuICB2YXIgZDNfbG9jYWxlX2VuVVMgPSBkMy5sb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFsgMyBdLFxuICAgIGN1cnJlbmN5OiBbIFwiJFwiLCBcIlwiIF0sXG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVtLyVkLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFsgXCJBTVwiLCBcIlBNXCIgXSxcbiAgICBkYXlzOiBbIFwiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiBdLFxuICAgIHNob3J0RGF5czogWyBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiIF0sXG4gICAgbW9udGhzOiBbIFwiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIiBdLFxuICAgIHNob3J0TW9udGhzOiBbIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCIgXVxuICB9KTtcbiAgZDMuZm9ybWF0ID0gZDNfbG9jYWxlX2VuVVMubnVtYmVyRm9ybWF0O1xuICBkMy5nZW8gPSB7fTtcbiAgZnVuY3Rpb24gZDNfYWRkZXIoKSB7fVxuICBkM19hZGRlci5wcm90b3R5cGUgPSB7XG4gICAgczogMCxcbiAgICB0OiAwLFxuICAgIGFkZDogZnVuY3Rpb24oeSkge1xuICAgICAgZDNfYWRkZXJTdW0oeSwgdGhpcy50LCBkM19hZGRlclRlbXApO1xuICAgICAgZDNfYWRkZXJTdW0oZDNfYWRkZXJUZW1wLnMsIHRoaXMucywgdGhpcyk7XG4gICAgICBpZiAodGhpcy5zKSB0aGlzLnQgKz0gZDNfYWRkZXJUZW1wLnQ7IGVsc2UgdGhpcy5zID0gZDNfYWRkZXJUZW1wLnQ7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnMgPSB0aGlzLnQgPSAwO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX2FkZGVyVGVtcCA9IG5ldyBkM19hZGRlcigpO1xuICBmdW5jdGlvbiBkM19hZGRlclN1bShhLCBiLCBvKSB7XG4gICAgdmFyIHggPSBvLnMgPSBhICsgYiwgYnYgPSB4IC0gYSwgYXYgPSB4IC0gYnY7XG4gICAgby50ID0gYSAtIGF2ICsgKGIgLSBidik7XG4gIH1cbiAgZDMuZ2VvLnN0cmVhbSA9IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICBpZiAob2JqZWN0ICYmIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgICAgZDNfZ2VvX3N0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIGxpc3RlbmVyKSB7XG4gICAgaWYgKGdlb21ldHJ5ICYmIGQzX2dlb19zdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgdmFyIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlID0ge1xuICAgIEZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1HZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX2dlb19zdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gICAgU3BoZXJlOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lci5zcGhlcmUoKTtcbiAgICB9LFxuICAgIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgICBsaXN0ZW5lci5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICB9LFxuICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lci5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICB9LFxuICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1MaW5lKG9iamVjdC5jb29yZGluYXRlcywgbGlzdGVuZXIsIDApO1xuICAgIH0sXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIsIDApO1xuICAgIH0sXG4gICAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbVBvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlcywgbGlzdGVuZXIsIGNsb3NlZCkge1xuICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIucG9pbnQoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSk7XG4gICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBsaXN0ZW5lcikge1xuICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lciwgMSk7XG4gICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICB9XG4gIGQzLmdlby5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2FyZWFTdW0gPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fYXJlYSk7XG4gICAgcmV0dXJuIGQzX2dlb19hcmVhU3VtO1xuICB9O1xuICB2YXIgZDNfZ2VvX2FyZWFTdW0sIGQzX2dlb19hcmVhUmluZ1N1bSA9IG5ldyBkM19hZGRlcigpO1xuICB2YXIgZDNfZ2VvX2FyZWEgPSB7XG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19hcmVhU3VtICs9IDQgKiDPgDtcbiAgICB9LFxuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCA9IGQzX2dlb19hcmVhUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJlYSA9IDIgKiBkM19nZW9fYXJlYVJpbmdTdW07XG4gICAgICBkM19nZW9fYXJlYVN1bSArPSBhcmVhIDwgMCA/IDQgKiDPgCArIGFyZWEgOiBhcmVhO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX2FyZWEubGluZUVuZCA9IGQzX2dlb19hcmVhLnBvaW50ID0gZDNfbm9vcDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19hcmVhUmluZ1N0YXJ0KCkge1xuICAgIHZhciDOuzAwLCDPhjAwLCDOuzAsIGNvc8+GMCwgc2luz4YwO1xuICAgIGQzX2dlb19hcmVhLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICBkM19nZW9fYXJlYS5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIM67MCA9ICjOuzAwID0gzrspICogZDNfcmFkaWFucywgY29zz4YwID0gTWF0aC5jb3Moz4YgPSAoz4YwMCA9IM+GKSAqIGQzX3JhZGlhbnMgLyAyICsgz4AgLyA0KSwgXG4gICAgICBzaW7PhjAgPSBNYXRoLnNpbijPhik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgz4YgPSDPhiAqIGQzX3JhZGlhbnMgLyAyICsgz4AgLyA0O1xuICAgICAgdmFyIGTOuyA9IM67IC0gzrswLCBzZM67ID0gZM67ID49IDAgPyAxIDogLTEsIGFkzrsgPSBzZM67ICogZM67LCBjb3PPhiA9IE1hdGguY29zKM+GKSwgc2luz4YgPSBNYXRoLnNpbijPhiksIGsgPSBzaW7PhjAgKiBzaW7PhiwgdSA9IGNvc8+GMCAqIGNvc8+GICsgayAqIE1hdGguY29zKGFkzrspLCB2ID0gayAqIHNkzrsgKiBNYXRoLnNpbihhZM67KTtcbiAgICAgIGQzX2dlb19hcmVhUmluZ1N1bS5hZGQoTWF0aC5hdGFuMih2LCB1KSk7XG4gICAgICDOuzAgPSDOuywgY29zz4YwID0gY29zz4YsIHNpbs+GMCA9IHNpbs+GO1xuICAgIH1cbiAgICBkM19nZW9fYXJlYS5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQozrswMCwgz4YwMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuKHNwaGVyaWNhbCkge1xuICAgIHZhciDOuyA9IHNwaGVyaWNhbFswXSwgz4YgPSBzcGhlcmljYWxbMV0sIGNvc8+GID0gTWF0aC5jb3Moz4YpO1xuICAgIHJldHVybiBbIGNvc8+GICogTWF0aC5jb3MozrspLCBjb3PPhiAqIE1hdGguc2luKM67KSwgTWF0aC5zaW4oz4YpIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICAgIHJldHVybiBbIGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF0gXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuQWRkKGEsIGIpIHtcbiAgICBhWzBdICs9IGJbMF07XG4gICAgYVsxXSArPSBiWzFdO1xuICAgIGFbMl0gKz0gYlsyXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gICAgcmV0dXJuIFsgdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICogayBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoZCkge1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV0gKyBkWzJdICogZFsyXSk7XG4gICAgZFswXSAvPSBsO1xuICAgIGRbMV0gLz0gbDtcbiAgICBkWzJdIC89IGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3NwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgICByZXR1cm4gWyBNYXRoLmF0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgZDNfYXNpbihjYXJ0ZXNpYW5bMl0pIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IM61ICYmIGFicyhhWzFdIC0gYlsxXSkgPCDOtTtcbiAgfVxuICBkMy5nZW8uYm91bmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIM67MCwgz4YwLCDOuzEsIM+GMSwgzrtfLCDOu19fLCDPhl9fLCBwMCwgZM67U3VtLCByYW5nZXMsIHJhbmdlO1xuICAgIHZhciBib3VuZCA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGJvdW5kLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgICBib3VuZC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIGJvdW5kLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICBkzrtTdW0gPSAwO1xuICAgICAgICBkM19nZW9fYXJlYS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZDNfZ2VvX2FyZWEucG9seWdvbkVuZCgpO1xuICAgICAgICBib3VuZC5wb2ludCA9IHBvaW50O1xuICAgICAgICBib3VuZC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGJvdW5kLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBpZiAoZDNfZ2VvX2FyZWFSaW5nU3VtIDwgMCkgzrswID0gLSjOuzEgPSAxODApLCDPhjAgPSAtKM+GMSA9IDkwKTsgZWxzZSBpZiAoZM67U3VtID4gzrUpIM+GMSA9IDkwOyBlbHNlIGlmIChkzrtTdW0gPCAtzrUpIM+GMCA9IC05MDtcbiAgICAgICAgcmFuZ2VbMF0gPSDOuzAsIHJhbmdlWzFdID0gzrsxO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnQozrssIM+GKSB7XG4gICAgICByYW5nZXMucHVzaChyYW5nZSA9IFsgzrswID0gzrssIM67MSA9IM67IF0pO1xuICAgICAgaWYgKM+GIDwgz4YwKSDPhjAgPSDPhjtcbiAgICAgIGlmICjPhiA+IM+GMSkgz4YxID0gz4Y7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludCjOuywgz4YpIHtcbiAgICAgIHZhciBwID0gZDNfZ2VvX2NhcnRlc2lhbihbIM67ICogZDNfcmFkaWFucywgz4YgKiBkM19yYWRpYW5zIF0pO1xuICAgICAgaWYgKHAwKSB7XG4gICAgICAgIHZhciBub3JtYWwgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MocDAsIHApLCBlcXVhdG9yaWFsID0gWyBub3JtYWxbMV0sIC1ub3JtYWxbMF0sIDAgXSwgaW5mbGVjdGlvbiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhlcXVhdG9yaWFsLCBub3JtYWwpO1xuICAgICAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGluZmxlY3Rpb24pO1xuICAgICAgICBpbmZsZWN0aW9uID0gZDNfZ2VvX3NwaGVyaWNhbChpbmZsZWN0aW9uKTtcbiAgICAgICAgdmFyIGTOuyA9IM67IC0gzrtfLCBzID0gZM67ID4gMCA/IDEgOiAtMSwgzrtpID0gaW5mbGVjdGlvblswXSAqIGQzX2RlZ3JlZXMgKiBzLCBhbnRpbWVyaWRpYW4gPSBhYnMoZM67KSA+IDE4MDtcbiAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIChzICogzrtfIDwgzrtpICYmIM67aSA8IHMgKiDOuykpIHtcbiAgICAgICAgICB2YXIgz4ZpID0gaW5mbGVjdGlvblsxXSAqIGQzX2RlZ3JlZXM7XG4gICAgICAgICAgaWYgKM+GaSA+IM+GMSkgz4YxID0gz4ZpO1xuICAgICAgICB9IGVsc2UgaWYgKM67aSA9ICjOu2kgKyAzNjApICUgMzYwIC0gMTgwLCBhbnRpbWVyaWRpYW4gXiAocyAqIM67XyA8IM67aSAmJiDOu2kgPCBzICogzrspKSB7XG4gICAgICAgICAgdmFyIM+GaSA9IC1pbmZsZWN0aW9uWzFdICogZDNfZGVncmVlcztcbiAgICAgICAgICBpZiAoz4ZpIDwgz4YwKSDPhjAgPSDPhmk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKM+GIDwgz4YwKSDPhjAgPSDPhjtcbiAgICAgICAgICBpZiAoz4YgPiDPhjEpIM+GMSA9IM+GO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4pIHtcbiAgICAgICAgICBpZiAozrsgPCDOu18pIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSjOuzAsIM67KSA+IGFuZ2xlKM67MCwgzrsxKSkgzrsxID0gzrs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSjOuywgzrsxKSA+IGFuZ2xlKM67MCwgzrsxKSkgzrswID0gzrs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICjOuzEgPj0gzrswKSB7XG4gICAgICAgICAgICBpZiAozrsgPCDOuzApIM67MCA9IM67O1xuICAgICAgICAgICAgaWYgKM67ID4gzrsxKSDOuzEgPSDOuztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKM67ID4gzrtfKSB7XG4gICAgICAgICAgICAgIGlmIChhbmdsZSjOuzAsIM67KSA+IGFuZ2xlKM67MCwgzrsxKSkgzrsxID0gzrs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYW5nbGUozrssIM67MSkgPiBhbmdsZSjOuzAsIM67MSkpIM67MCA9IM67O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnQozrssIM+GKTtcbiAgICAgIH1cbiAgICAgIHAwID0gcCwgzrtfID0gzrs7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGJvdW5kLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmFuZ2VbMF0gPSDOuzAsIHJhbmdlWzFdID0gzrsxO1xuICAgICAgYm91bmQucG9pbnQgPSBwb2ludDtcbiAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KM67LCDPhikge1xuICAgICAgaWYgKHAwKSB7XG4gICAgICAgIHZhciBkzrsgPSDOuyAtIM67XztcbiAgICAgICAgZM67U3VtICs9IGFicyhkzrspID4gMTgwID8gZM67ICsgKGTOuyA+IDAgPyAzNjAgOiAtMzYwKSA6IGTOuztcbiAgICAgIH0gZWxzZSDOu19fID0gzrssIM+GX18gPSDPhjtcbiAgICAgIGQzX2dlb19hcmVhLnBvaW50KM67LCDPhik7XG4gICAgICBsaW5lUG9pbnQozrssIM+GKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgZDNfZ2VvX2FyZWEubGluZVN0YXJ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICByaW5nUG9pbnQozrtfXywgz4ZfXyk7XG4gICAgICBkM19nZW9fYXJlYS5saW5lRW5kKCk7XG4gICAgICBpZiAoYWJzKGTOu1N1bSkgPiDOtSkgzrswID0gLSjOuzEgPSAxODApO1xuICAgICAgcmFuZ2VbMF0gPSDOuzAsIHJhbmdlWzFdID0gzrsxO1xuICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbmdsZSjOuzAsIM67MSkge1xuICAgICAgcmV0dXJuICjOuzEgLT0gzrswKSA8IDAgPyDOuzEgKyAzNjAgOiDOuzE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aXRoaW5SYW5nZSh4LCByYW5nZSkge1xuICAgICAgcmV0dXJuIHJhbmdlWzBdIDw9IHJhbmdlWzFdID8gcmFuZ2VbMF0gPD0geCAmJiB4IDw9IHJhbmdlWzFdIDogeCA8IHJhbmdlWzBdIHx8IHJhbmdlWzFdIDwgeDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIM+GMSA9IM67MSA9IC0ozrswID0gz4YwID0gSW5maW5pdHkpO1xuICAgICAgcmFuZ2VzID0gW107XG4gICAgICBkMy5nZW8uc3RyZWFtKGZlYXR1cmUsIGJvdW5kKTtcbiAgICAgIHZhciBuID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIHJhbmdlcy5zb3J0KGNvbXBhcmVSYW5nZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgYSA9IHJhbmdlc1swXSwgYiwgbWVyZ2VkID0gWyBhIF07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgICAgIGlmICh3aXRoaW5SYW5nZShiWzBdLCBhKSB8fCB3aXRoaW5SYW5nZShiWzFdLCBhKSkge1xuICAgICAgICAgICAgaWYgKGFuZ2xlKGFbMF0sIGJbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMV0gPSBiWzFdO1xuICAgICAgICAgICAgaWYgKGFuZ2xlKGJbMF0sIGFbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMF0gPSBiWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChhID0gYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBiZXN0ID0gLUluZmluaXR5LCBkzrs7XG4gICAgICAgIGZvciAodmFyIG4gPSBtZXJnZWQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBtZXJnZWRbbl0sIGI7IGkgPD0gbjsgYSA9IGIsICsraSkge1xuICAgICAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICAgICAgaWYgKChkzrsgPSBhbmdsZShhWzFdLCBiWzBdKSkgPiBiZXN0KSBiZXN0ID0gZM67LCDOuzAgPSBiWzBdLCDOuzEgPSBhWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByYW5nZXMgPSByYW5nZSA9IG51bGw7XG4gICAgICByZXR1cm4gzrswID09PSBJbmZpbml0eSB8fCDPhjAgPT09IEluZmluaXR5ID8gWyBbIE5hTiwgTmFOIF0sIFsgTmFOLCBOYU4gXSBdIDogWyBbIM67MCwgz4YwIF0sIFsgzrsxLCDPhjEgXSBdO1xuICAgIH07XG4gIH0oKTtcbiAgZDMuZ2VvLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2NlbnRyb2lkVzAgPSBkM19nZW9fY2VudHJvaWRXMSA9IGQzX2dlb19jZW50cm9pZFgwID0gZDNfZ2VvX2NlbnRyb2lkWTAgPSBkM19nZW9fY2VudHJvaWRaMCA9IGQzX2dlb19jZW50cm9pZFgxID0gZDNfZ2VvX2NlbnRyb2lkWTEgPSBkM19nZW9fY2VudHJvaWRaMSA9IGQzX2dlb19jZW50cm9pZFgyID0gZDNfZ2VvX2NlbnRyb2lkWTIgPSBkM19nZW9fY2VudHJvaWRaMiA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19jZW50cm9pZCk7XG4gICAgdmFyIHggPSBkM19nZW9fY2VudHJvaWRYMiwgeSA9IGQzX2dlb19jZW50cm9pZFkyLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjIsIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgaWYgKG0gPCDOtTIpIHtcbiAgICAgIHggPSBkM19nZW9fY2VudHJvaWRYMSwgeSA9IGQzX2dlb19jZW50cm9pZFkxLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjE7XG4gICAgICBpZiAoZDNfZ2VvX2NlbnRyb2lkVzEgPCDOtSkgeCA9IGQzX2dlb19jZW50cm9pZFgwLCB5ID0gZDNfZ2VvX2NlbnRyb2lkWTAsIHogPSBkM19nZW9fY2VudHJvaWRaMDtcbiAgICAgIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgICBpZiAobSA8IM61MikgcmV0dXJuIFsgTmFOLCBOYU4gXTtcbiAgICB9XG4gICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5LCB4KSAqIGQzX2RlZ3JlZXMsIGQzX2FzaW4oeiAvIE1hdGguc3FydChtKSkgKiBkM19kZWdyZWVzIF07XG4gIH07XG4gIHZhciBkM19nZW9fY2VudHJvaWRXMCwgZDNfZ2VvX2NlbnRyb2lkVzEsIGQzX2dlb19jZW50cm9pZFgwLCBkM19nZW9fY2VudHJvaWRZMCwgZDNfZ2VvX2NlbnRyb2lkWjAsIGQzX2dlb19jZW50cm9pZFgxLCBkM19nZW9fY2VudHJvaWRZMSwgZDNfZ2VvX2NlbnRyb2lkWjEsIGQzX2dlb19jZW50cm9pZFgyLCBkM19nZW9fY2VudHJvaWRZMiwgZDNfZ2VvX2NlbnRyb2lkWjI7XG4gIHZhciBkM19nZW9fY2VudHJvaWQgPSB7XG4gICAgc3BoZXJlOiBkM19ub29wLFxuICAgIHBvaW50OiBkM19nZW9fY2VudHJvaWRQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19jZW50cm9pZExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19nZW9fY2VudHJvaWRMaW5lRW5kLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fY2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX2NlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fY2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX2NlbnRyb2lkTGluZVN0YXJ0O1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkUG9pbnQozrssIM+GKSB7XG4gICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWihjb3PPhiAqIE1hdGguY29zKM67KSwgY29zz4YgKiBNYXRoLnNpbijOuyksIE1hdGguc2luKM+GKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeCwgeSwgeikge1xuICAgICsrZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWDAgKz0gKHggLSBkM19nZW9fY2VudHJvaWRYMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRZMCArPSAoeSAtIGQzX2dlb19jZW50cm9pZFkwKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFowICs9ICh6IC0gZDNfZ2VvX2NlbnRyb2lkWjApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgIHZhciB4MCwgeTAsIHowO1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgICAgeDAgPSBjb3PPhiAqIE1hdGguY29zKM67KTtcbiAgICAgIHkwID0gY29zz4YgKiBNYXRoLnNpbijOuyk7XG4gICAgICB6MCA9IE1hdGguc2luKM+GKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpLCB4ID0gY29zz4YgKiBNYXRoLmNvcyjOuyksIHkgPSBjb3PPhiAqIE1hdGguc2luKM67KSwgeiA9IE1hdGguc2luKM+GKSwgdyA9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh3ID0geTAgKiB6IC0gejAgKiB5KSAqIHcgKyAodyA9IHowICogeCAtIHgwICogeikgKiB3ICsgKHcgPSB4MCAqIHkgLSB5MCAqIHgpICogdyksIHgwICogeCArIHkwICogeSArIHowICogeik7XG4gICAgICBkM19nZW9fY2VudHJvaWRXMSArPSB3O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZExpbmVFbmQoKSB7XG4gICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX2NlbnRyb2lkUG9pbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgIHZhciDOuzAwLCDPhjAwLCB4MCwgeTAsIHowO1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrswMCA9IM67LCDPhjAwID0gz4Y7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgICB4MCA9IGNvc8+GICogTWF0aC5jb3MozrspO1xuICAgICAgeTAgPSBjb3PPhiAqIE1hdGguc2luKM67KTtcbiAgICAgIHowID0gTWF0aC5zaW4oz4YpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfTtcbiAgICBkM19nZW9fY2VudHJvaWQubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KM67MDAsIM+GMDApO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVFbmQgPSBkM19nZW9fY2VudHJvaWRMaW5lRW5kO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX2NlbnRyb2lkUG9pbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyksIHggPSBjb3PPhiAqIE1hdGguY29zKM67KSwgeSA9IGNvc8+GICogTWF0aC5zaW4ozrspLCB6ID0gTWF0aC5zaW4oz4YpLCBjeCA9IHkwICogeiAtIHowICogeSwgY3kgPSB6MCAqIHggLSB4MCAqIHosIGN6ID0geDAgKiB5IC0geTAgKiB4LCBtID0gTWF0aC5zcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksIHUgPSB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHosIHYgPSBtICYmIC1kM19hY29zKHUpIC8gbSwgdyA9IE1hdGguYXRhbjIobSwgdSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMiArPSB2ICogY3g7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMiArPSB2ICogY3k7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMiArPSB2ICogY3o7XG4gICAgICBkM19nZW9fY2VudHJvaWRXMSArPSB3O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb21wb3NlKGEsIGIpIHtcbiAgICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgICB9XG4gICAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gICAgfTtcbiAgICByZXR1cm4gY29tcG9zZTtcbiAgfVxuICBmdW5jdGlvbiBkM190cnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZSwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgc3ViamVjdCA9IFtdLCBjbGlwID0gW107XG4gICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXTtcbiAgICAgIGlmIChkM19nZW9fc3BoZXJpY2FsRXF1YWwocDAsIHAxKSkge1xuICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGxpc3RlbmVyLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGEgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSwgYiA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDAsIG51bGwsIGEsIGZhbHNlKTtcbiAgICAgIGEubyA9IGI7XG4gICAgICBzdWJqZWN0LnB1c2goYSk7XG4gICAgICBjbGlwLnB1c2goYik7XG4gICAgICBhID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpO1xuICAgICAgYiA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDEsIG51bGwsIGEsIHRydWUpO1xuICAgICAgYS5vID0gYjtcbiAgICAgIHN1YmplY3QucHVzaChhKTtcbiAgICAgIGNsaXAucHVzaChiKTtcbiAgICB9KTtcbiAgICBjbGlwLnNvcnQoY29tcGFyZSk7XG4gICAgZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKHN1YmplY3QpO1xuICAgIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihjbGlwKTtcbiAgICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDAsIGVudHJ5ID0gY2xpcFN0YXJ0SW5zaWRlLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNsaXBbaV0uZSA9IGVudHJ5ID0gIWVudHJ5O1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLCBwb2ludHMsIHBvaW50O1xuICAgIHdoaWxlICgxKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHN0YXJ0LCBpc1N1YmplY3QgPSB0cnVlO1xuICAgICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgZG8ge1xuICAgICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoYXJyYXkpIHtcbiAgICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBuLCBpID0gMCwgYSA9IGFycmF5WzBdLCBiO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgICBiLnAgPSBhO1xuICAgICAgYSA9IGI7XG4gICAgfVxuICAgIGEubiA9IGIgPSBhcnJheVswXTtcbiAgICBiLnAgPSBhO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgICB0aGlzLnggPSBwb2ludDtcbiAgICB0aGlzLnogPSBwb2ludHM7XG4gICAgdGhpcy5vID0gb3RoZXI7XG4gICAgdGhpcy5lID0gZW50cnk7XG4gICAgdGhpcy52ID0gZmFsc2U7XG4gICAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcChwb2ludFZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgY2xpcFN0YXJ0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJvdGF0ZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaW5lID0gY2xpcExpbmUobGlzdGVuZXIpLCByb3RhdGVkQ2xpcFN0YXJ0ID0gcm90YXRlLmludmVydChjbGlwU3RhcnRbMF0sIGNsaXBTdGFydFsxXSk7XG4gICAgICB2YXIgY2xpcCA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICAgIGNsaXAubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICAgIHNlZ21lbnRzID0gZDMubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICAgIHZhciBjbGlwU3RhcnRJbnNpZGUgPSBkM19nZW9fcG9pbnRJblBvbHlnb24ocm90YXRlZENsaXBTdGFydCwgcG9seWdvbik7XG4gICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgZDNfZ2VvX2NsaXBTb3J0LCBjbGlwU3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGlwU3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uRW5kKCksIHBvbHlnb25TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBvaW50KM67LCDPhikge1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgaWYgKHBvaW50VmlzaWJsZSjOuyA9IHBvaW50WzBdLCDPhiA9IHBvaW50WzFdKSkgbGlzdGVuZXIucG9pbnQozrssIM+GKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50TGluZSjOuywgz4YpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIGxpbmUucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VnbWVudHM7XG4gICAgICB2YXIgYnVmZmVyID0gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpLCByaW5nTGlzdGVuZXIgPSBjbGlwTGluZShidWZmZXIpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLCBwb2x5Z29uLCByaW5nO1xuICAgICAgZnVuY3Rpb24gcG9pbnRSaW5nKM67LCDPhikge1xuICAgICAgICByaW5nLnB1c2goWyDOuywgz4YgXSk7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICByaW5nTGlzdGVuZXIucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgcmluZ0xpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICByaW5nID0gW107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIHZhciBjbGVhbiA9IHJpbmdMaXN0ZW5lci5jbGVhbigpLCByaW5nU2VnbWVudHMgPSBidWZmZXIuYnVmZmVyKCksIHNlZ21lbnQsIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICByaW5nLnBvcCgpO1xuICAgICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICAgIHJpbmcgPSBudWxsO1xuICAgICAgICBpZiAoIW4pIHJldHVybjtcbiAgICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgICAgdmFyIG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEsIGkgPSAtMSwgcG9pbnQ7XG4gICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKGQzX2dlb19jbGlwU2VnbWVudExlbmd0aDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBTZWdtZW50TGVuZ3RoMShzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEJ1ZmZlckxpc3RlbmVyKCkge1xuICAgIHZhciBsaW5lcyA9IFtdLCBsaW5lO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgICBsaW5lLnB1c2goWyDOuywgz4YgXSk7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICAgIGJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBsaW5lcztcbiAgICAgICAgbGluZXMgPSBbXTtcbiAgICAgICAgbGluZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICB9LFxuICAgICAgcmVqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwU29ydChhLCBiKSB7XG4gICAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGbPgCAtIM61IDogaGFsZs+AIC0gYVsxXSkgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmz4AgLSDOtSA6IGhhbGbPgCAtIGJbMV0pO1xuICB9XG4gIHZhciBkM19nZW9fY2xpcEFudGltZXJpZGlhbiA9IGQzX2dlb19jbGlwKGQzX3RydWUsIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuTGluZSwgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSwgWyAtz4AsIC3PgCAvIDIgXSk7XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuTGluZShsaXN0ZW5lcikge1xuICAgIHZhciDOuzAgPSBOYU4sIM+GMCA9IE5hTiwgc867MCA9IE5hTiwgY2xlYW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICBjbGVhbiA9IDE7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67MSwgz4YxKSB7XG4gICAgICAgIHZhciBzzrsxID0gzrsxID4gMCA/IM+AIDogLc+ALCBkzrsgPSBhYnMozrsxIC0gzrswKTtcbiAgICAgICAgaWYgKGFicyhkzrsgLSDPgCkgPCDOtSkge1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KM67MCwgz4YwID0gKM+GMCArIM+GMSkgLyAyID4gMCA/IGhhbGbPgCA6IC1oYWxmz4ApO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzAsIM+GMCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzEsIM+GMCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQozrsxLCDPhjApO1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzzrswICE9PSBzzrsxICYmIGTOuyA+PSDPgCkge1xuICAgICAgICAgIGlmIChhYnMozrswIC0gc867MCkgPCDOtSkgzrswIC09IHPOuzAgKiDOtTtcbiAgICAgICAgICBpZiAoYWJzKM67MSAtIHPOuzEpIDwgzrUpIM67MSAtPSBzzrsxICogzrU7XG4gICAgICAgICAgz4YwID0gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QozrswLCDPhjAsIM67MSwgz4YxKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrswLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrsxLCDPhjApO1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzAgPSDOuzEsIM+GMCA9IM+GMSk7XG4gICAgICAgIHPOuzAgPSBzzrsxO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIM67MCA9IM+GMCA9IE5hTjtcbiAgICAgIH0sXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAyIC0gY2xlYW47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVyc2VjdCjOuzAsIM+GMCwgzrsxLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwLCBjb3PPhjEsIHNpbs67MF/OuzEgPSBNYXRoLnNpbijOuzAgLSDOuzEpO1xuICAgIHJldHVybiBhYnMoc2luzrswX867MSkgPiDOtSA/IE1hdGguYXRhbigoTWF0aC5zaW4oz4YwKSAqIChjb3PPhjEgPSBNYXRoLmNvcyjPhjEpKSAqIE1hdGguc2luKM67MSkgLSBNYXRoLnNpbijPhjEpICogKGNvc8+GMCA9IE1hdGguY29zKM+GMCkpICogTWF0aC5zaW4ozrswKSkgLyAoY29zz4YwICogY29zz4YxICogc2luzrswX867MSkpIDogKM+GMCArIM+GMSkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICB2YXIgz4Y7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgz4YgPSBkaXJlY3Rpb24gKiBoYWxmz4A7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KDAsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KM+ALCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgMCk7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgLc+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KDAsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIDApO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCDPhik7XG4gICAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IM61KSB7XG4gICAgICB2YXIgcyA9IGZyb21bMF0gPCB0b1swXSA/IM+AIDogLc+AO1xuICAgICAgz4YgPSBkaXJlY3Rpb24gKiBzIC8gMjtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC1zLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludChzLCDPhik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RlbmVyLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICAgIHZhciBtZXJpZGlhbiA9IHBvaW50WzBdLCBwYXJhbGxlbCA9IHBvaW50WzFdLCBtZXJpZGlhbk5vcm1hbCA9IFsgTWF0aC5zaW4obWVyaWRpYW4pLCAtTWF0aC5jb3MobWVyaWRpYW4pLCAwIF0sIHBvbGFyQW5nbGUgPSAwLCB3aW5kaW5nID0gMDtcbiAgICBkM19nZW9fYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcmluZyA9IHBvbHlnb25baV0sIG0gPSByaW5nLmxlbmd0aDtcbiAgICAgIGlmICghbSkgY29udGludWU7XG4gICAgICB2YXIgcG9pbnQwID0gcmluZ1swXSwgzrswID0gcG9pbnQwWzBdLCDPhjAgPSBwb2ludDBbMV0gLyAyICsgz4AgLyA0LCBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBqID0gMTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChqID09PSBtKSBqID0gMDtcbiAgICAgICAgcG9pbnQgPSByaW5nW2pdO1xuICAgICAgICB2YXIgzrsgPSBwb2ludFswXSwgz4YgPSBwb2ludFsxXSAvIDIgKyDPgCAvIDQsIHNpbs+GID0gTWF0aC5zaW4oz4YpLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgZM67ID0gzrsgLSDOuzAsIHNkzrsgPSBkzrsgPj0gMCA/IDEgOiAtMSwgYWTOuyA9IHNkzrsgKiBkzrssIGFudGltZXJpZGlhbiA9IGFkzrsgPiDPgCwgayA9IHNpbs+GMCAqIHNpbs+GO1xuICAgICAgICBkM19nZW9fYXJlYVJpbmdTdW0uYWRkKE1hdGguYXRhbjIoayAqIHNkzrsgKiBNYXRoLnNpbihhZM67KSwgY29zz4YwICogY29zz4YgKyBrICogTWF0aC5jb3MoYWTOuykpKTtcbiAgICAgICAgcG9sYXJBbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkzrsgKyBzZM67ICogz4QgOiBkzrs7XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiDOuzAgPj0gbWVyaWRpYW4gXiDOuyA+PSBtZXJpZGlhbikge1xuICAgICAgICAgIHZhciBhcmMgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoZDNfZ2VvX2NhcnRlc2lhbihwb2ludDApLCBkM19nZW9fY2FydGVzaWFuKHBvaW50KSk7XG4gICAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShhcmMpO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MobWVyaWRpYW5Ob3JtYWwsIGFyYyk7XG4gICAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgIHZhciDPhmFyYyA9IChhbnRpbWVyaWRpYW4gXiBkzrsgPj0gMCA/IC0xIDogMSkgKiBkM19hc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgICAgaWYgKHBhcmFsbGVsID4gz4ZhcmMgfHwgcGFyYWxsZWwgPT09IM+GYXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkzrsgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqKyspIGJyZWFrO1xuICAgICAgICDOuzAgPSDOuywgc2luz4YwID0gc2luz4YsIGNvc8+GMCA9IGNvc8+GLCBwb2ludDAgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChwb2xhckFuZ2xlIDwgLc61IHx8IHBvbGFyQW5nbGUgPCDOtSAmJiBkM19nZW9fYXJlYVJpbmdTdW0gPCAtzrUpIF4gd2luZGluZyAmIDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBDaXJjbGUocmFkaXVzKSB7XG4gICAgdmFyIGNyID0gTWF0aC5jb3MocmFkaXVzKSwgc21hbGxSYWRpdXMgPSBjciA+IDAsIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gzrUsIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKHJhZGl1cywgNiAqIGQzX3JhZGlhbnMpO1xuICAgIHJldHVybiBkM19nZW9fY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWyAwLCAtcmFkaXVzIF0gOiBbIC3PgCwgcmFkaXVzIC0gz4AgXSk7XG4gICAgZnVuY3Rpb24gdmlzaWJsZSjOuywgz4YpIHtcbiAgICAgIHJldHVybiBNYXRoLmNvcyjOuykgKiBNYXRoLmNvcyjPhikgPiBjcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcExpbmUobGlzdGVuZXIpIHtcbiAgICAgIHZhciBwb2ludDAsIGMwLCB2MCwgdjAwLCBjbGVhbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgICBjbGVhbiA9IDE7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgICB2YXIgcG9pbnQxID0gWyDOuywgz4YgXSwgcG9pbnQyLCB2ID0gdmlzaWJsZSjOuywgz4YpLCBjID0gc21hbGxSYWRpdXMgPyB2ID8gMCA6IGNvZGUozrssIM+GKSA6IHYgPyBjb2RlKM67ICsgKM67IDwgMCA/IM+AIDogLc+AKSwgz4YpIDogMDtcbiAgICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgaWYgKGQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDAsIHBvaW50MikgfHwgZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xuICAgICAgICAgICAgICBwb2ludDFbMF0gKz0gzrU7XG4gICAgICAgICAgICAgIHBvaW50MVsxXSArPSDOtTtcbiAgICAgICAgICAgICAgdiA9IHZpc2libGUocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodjApIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFuIHwgKHYwMCAmJiB2MCkgPDwgMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgICAgdmFyIHBhID0gZDNfZ2VvX2NhcnRlc2lhbihhKSwgcGIgPSBkM19nZW9fY2FydGVzaWFuKGIpO1xuICAgICAgdmFyIG4xID0gWyAxLCAwLCAwIF0sIG4yID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHBhLCBwYiksIG4ybjIgPSBkM19nZW9fY2FydGVzaWFuRG90KG4yLCBuMiksIG4xbjIgPSBuMlswXSwgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG4gICAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xuICAgICAgdmFyIGMxID0gY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LCBuMXhuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLCBBID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKG4xLCBjMSksIEIgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQoQSwgQik7XG4gICAgICB2YXIgdSA9IG4xeG4yLCB3ID0gZDNfZ2VvX2NhcnRlc2lhbkRvdChBLCB1KSwgdXUgPSBkM19nZW9fY2FydGVzaWFuRG90KHUsIHUpLCB0MiA9IHcgKiB3IC0gdXUgKiAoZDNfZ2VvX2NhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuICAgICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xuICAgICAgdmFyIHQgPSBNYXRoLnNxcnQodDIpLCBxID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChxLCBBKTtcbiAgICAgIHEgPSBkM19nZW9fc3BoZXJpY2FsKHEpO1xuICAgICAgaWYgKCF0d28pIHJldHVybiBxO1xuICAgICAgdmFyIM67MCA9IGFbMF0sIM67MSA9IGJbMF0sIM+GMCA9IGFbMV0sIM+GMSA9IGJbMV0sIHo7XG4gICAgICBpZiAozrsxIDwgzrswKSB6ID0gzrswLCDOuzAgPSDOuzEsIM67MSA9IHo7XG4gICAgICB2YXIgzrTOuyA9IM67MSAtIM67MCwgcG9sYXIgPSBhYnMozrTOuyAtIM+AKSA8IM61LCBtZXJpZGlhbiA9IHBvbGFyIHx8IM60zrsgPCDOtTtcbiAgICAgIGlmICghcG9sYXIgJiYgz4YxIDwgz4YwKSB6ID0gz4YwLCDPhjAgPSDPhjEsIM+GMSA9IHo7XG4gICAgICBpZiAobWVyaWRpYW4gPyBwb2xhciA/IM+GMCArIM+GMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gzrswKSA8IM61ID8gz4YwIDogz4YxKSA6IM+GMCA8PSBxWzFdICYmIHFbMV0gPD0gz4YxIDogzrTOuyA+IM+AIF4gKM67MCA8PSBxWzBdICYmIHFbMF0gPD0gzrsxKSkge1xuICAgICAgICB2YXIgcTEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQocTEsIEEpO1xuICAgICAgICByZXR1cm4gWyBxLCBkM19nZW9fc3BoZXJpY2FsKHExKSBdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb2RlKM67LCDPhikge1xuICAgICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IM+AIC0gcmFkaXVzLCBjb2RlID0gMDtcbiAgICAgIGlmICjOuyA8IC1yKSBjb2RlIHw9IDE7IGVsc2UgaWYgKM67ID4gcikgY29kZSB8PSAyO1xuICAgICAgaWYgKM+GIDwgLXIpIGNvZGUgfD0gNDsgZWxzZSBpZiAoz4YgPiByKSBjb2RlIHw9IDg7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9jbGlwTGluZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgYSA9IGxpbmUuYSwgYiA9IGxpbmUuYiwgYXggPSBhLngsIGF5ID0gYS55LCBieCA9IGIueCwgYnkgPSBiLnksIHQwID0gMCwgdDEgPSAxLCBkeCA9IGJ4IC0gYXgsIGR5ID0gYnkgLSBheSwgcjtcbiAgICAgIHIgPSB4MCAtIGF4O1xuICAgICAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeDtcbiAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB4MSAtIGF4O1xuICAgICAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeDtcbiAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB5MCAtIGF5O1xuICAgICAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeTtcbiAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB5MSAtIGF5O1xuICAgICAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeTtcbiAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH1cbiAgICAgIGlmICh0MCA+IDApIGxpbmUuYSA9IHtcbiAgICAgICAgeDogYXggKyB0MCAqIGR4LFxuICAgICAgICB5OiBheSArIHQwICogZHlcbiAgICAgIH07XG4gICAgICBpZiAodDEgPCAxKSBsaW5lLmIgPSB7XG4gICAgICAgIHg6IGF4ICsgdDEgKiBkeCxcbiAgICAgICAgeTogYXkgKyB0MSAqIGR5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBFeHRlbnRNQVggPSAxZTk7XG4gIGQzLmdlby5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHgwLCB5MCwgeDEsIHkxLCBzdHJlYW0sIGNsaXAsIGNsaXBFeHRlbnQgPSB7XG4gICAgICBzdHJlYW06IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtID0gY2xpcChvdXRwdXQpO1xuICAgICAgICBzdHJlYW0udmFsaWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXTtcbiAgICAgICAgY2xpcCA9IGQzX2dlb19jbGlwRXh0ZW50KHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pO1xuICAgICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZSwgc3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNsaXBFeHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2xpcEV4dGVudC5leHRlbnQoWyBbIDAsIDAgXSwgWyA5NjAsIDUwMCBdIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEV4dGVudCh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3RlbmVyXyA9IGxpc3RlbmVyLCBidWZmZXJMaXN0ZW5lciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgY2xpcExpbmUgPSBkM19nZW9tX2NsaXBMaW5lKHgwLCB5MCwgeDEsIHkxKSwgc2VnbWVudHMsIHBvbHlnb24sIHJpbmc7XG4gICAgICB2YXIgY2xpcCA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGJ1ZmZlckxpc3RlbmVyO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICAgIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcl87XG4gICAgICAgICAgc2VnbWVudHMgPSBkMy5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgdmFyIGNsaXBTdGFydEluc2lkZSA9IGluc2lkZVBvbHlnb24oWyB4MCwgeTEgXSksIGluc2lkZSA9IGNsZWFuICYmIGNsaXBTdGFydEluc2lkZSwgdmlzaWJsZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBpbnNpZGVQb2x5Z29uKHApIHtcbiAgICAgICAgdmFyIHduID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoLCB5ID0gcFsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMSwgdiA9IHBvbHlnb25baV0sIG0gPSB2Lmxlbmd0aCwgYSA9IHZbMF0sIGI7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGIgPSB2W2pdO1xuICAgICAgICAgICAgaWYgKGFbMV0gPD0geSkge1xuICAgICAgICAgICAgICBpZiAoYlsxXSA+IHkgJiYgZDNfY3Jvc3MyZChhLCBiLCBwKSA+IDApICsrd247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYlsxXSA8PSB5ICYmIGQzX2Nyb3NzMmQoYSwgYiwgcCkgPCAwKSAtLXduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3biAhPT0gMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpIHx8IGNvbXBhcmVQb2ludHMoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgICAgIH0gd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnRWaXNpYmxlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUoeCwgeSkpIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgfVxuICAgICAgdmFyIHhfXywgeV9fLCB2X18sIHhfLCB5Xywgdl8sIGZpcnN0LCBjbGVhbjtcbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgIHZfID0gZmFsc2U7XG4gICAgICAgIHhfID0geV8gPSBOYU47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICAgIGlmICh2X18gJiYgdl8pIGJ1ZmZlckxpc3RlbmVyLnJlam9pbigpO1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyTGlzdGVuZXIuYnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgaWYgKHZfKSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoLWQzX2dlb19jbGlwRXh0ZW50TUFYLCBNYXRoLm1pbihkM19nZW9fY2xpcEV4dGVudE1BWCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoLWQzX2dlb19jbGlwRXh0ZW50TUFYLCBNYXRoLm1pbihkM19nZW9fY2xpcEV4dGVudE1BWCwgeSkpO1xuICAgICAgICB2YXIgdiA9IHBvaW50VmlzaWJsZSh4LCB5KTtcbiAgICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbIHgsIHkgXSk7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgJiYgdl8pIGxpc3RlbmVyLnBvaW50KHgsIHkpOyBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsID0ge1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgeDogeF8sXG4gICAgICAgICAgICAgICAgeTogeV9cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNsaXBMaW5lKGwpKSB7XG4gICAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChsLmEueCwgbC5hLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGwuYi54LCBsLmIueSk7XG4gICAgICAgICAgICAgIGlmICghdikgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMCA6IDMgOiBhYnMocFswXSAtIHgxKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxIDogYWJzKHBbMV0gLSB5MCkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMCA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLngsIGIueCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVQb2ludHMoYSwgYikge1xuICAgICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLCBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXSA6IGNhID09PSAxID8gYVswXSAtIGJbMF0gOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdIDogYlswXSAtIGFbMF07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pYyhwcm9qZWN0QXQpIHtcbiAgICB2YXIgz4YwID0gMCwgz4YxID0gz4AgLyAzLCBtID0gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksIHAgPSBtKM+GMCwgz4YxKTtcbiAgICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgz4YwIC8gz4AgKiAxODAsIM+GMSAvIM+AICogMTgwIF07XG4gICAgICByZXR1cm4gbSjPhjAgPSBfWzBdICogz4AgLyAxODAsIM+GMSA9IF9bMV0gKiDPgCAvIDE4MCk7XG4gICAgfTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29uaWNFcXVhbEFyZWEoz4YwLCDPhjEpIHtcbiAgICB2YXIgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgbiA9IChzaW7PhjAgKyBNYXRoLnNpbijPhjEpKSAvIDIsIEMgPSAxICsgc2luz4YwICogKDIgKiBuIC0gc2luz4YwKSwgz4EwID0gTWF0aC5zcXJ0KEMpIC8gbjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgdmFyIM+BID0gTWF0aC5zcXJ0KEMgLSAyICogbiAqIE1hdGguc2luKM+GKSkgLyBuO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbijOuyAqPSBuKSwgz4EwIC0gz4EgKiBNYXRoLmNvcyjOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSDPgTAgLSB5O1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCBkM19hc2luKChDIC0gKHggKiB4ICsgz4EwX3kgKiDPgTBfeSkgKiBuICogbikgLyAoMiAqIG4pKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0VxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljRXF1YWxBcmVhKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljRXF1YWxBcmVhO1xuICBkMy5nZW8uYWxiZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDk2LCAwIF0pLmNlbnRlcihbIC0uNiwgMzguNyBdKS5wYXJhbGxlbHMoWyAyOS41LCA0NS41IF0pLnNjYWxlKDEwNzApO1xuICB9O1xuICBkMy5nZW8uYWxiZXJzVXNhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvd2VyNDggPSBkMy5nZW8uYWxiZXJzKCk7XG4gICAgdmFyIGFsYXNrYSA9IGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDE1NCwgMCBdKS5jZW50ZXIoWyAtMiwgNTguNSBdKS5wYXJhbGxlbHMoWyA1NSwgNjUgXSk7XG4gICAgdmFyIGhhd2FpaSA9IGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDE1NywgMCBdKS5jZW50ZXIoWyAtMywgMTkuOSBdKS5wYXJhbGxlbHMoWyA4LCAxOCBdKTtcbiAgICB2YXIgcG9pbnQsIHBvaW50U3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcG9pbnQgPSBbIHgsIHkgXTtcbiAgICAgIH1cbiAgICB9LCBsb3dlcjQ4UG9pbnQsIGFsYXNrYVBvaW50LCBoYXdhaWlQb2ludDtcbiAgICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIChsb3dlcjQ4UG9pbnQoeCwgeSksIHBvaW50KSB8fCAoYWxhc2thUG9pbnQoeCwgeSksIHBvaW50KSB8fCBoYXdhaWlQb2ludCh4LCB5KTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICByZXR1cm4gKHkgPj0gLjEyICYmIHkgPCAuMjM0ICYmIHggPj0gLS40MjUgJiYgeCA8IC0uMjE0ID8gYWxhc2thIDogeSA+PSAuMTY2ICYmIHkgPCAuMjM0ICYmIHggPj0gLS4yMTQgJiYgeCA8IC0uMTE1ID8gaGF3YWlpIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBsb3dlcjQ4U3RyZWFtID0gbG93ZXI0OC5zdHJlYW0oc3RyZWFtKSwgYWxhc2thU3RyZWFtID0gYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWlTdHJlYW0gPSBoYXdhaWkuc3RyZWFtKHN0cmVhbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pO1xuICAgICAgYWxhc2thLnByZWNpc2lvbihfKTtcbiAgICAgIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgICAgbG93ZXI0OC5zY2FsZShfKTtcbiAgICAgIGFsYXNrYS5zY2FsZShfICogLjM1KTtcbiAgICAgIGhhd2FpaS5zY2FsZShfKTtcbiAgICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4LnRyYW5zbGF0ZShfKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjQ1NSAqIGssIHkgLSAuMjM4ICogayBdLCBbIHggKyAuNDU1ICogaywgeSArIC4yMzggKiBrIF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIGFsYXNrYVBvaW50ID0gYWxhc2thLnRyYW5zbGF0ZShbIHggLSAuMzA3ICogaywgeSArIC4yMDEgKiBrIF0pLmNsaXBFeHRlbnQoWyBbIHggLSAuNDI1ICogayArIM61LCB5ICsgLjEyICogayArIM61IF0sIFsgeCAtIC4yMTQgKiBrIC0gzrUsIHkgKyAuMjM0ICogayAtIM61IF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpLnRyYW5zbGF0ZShbIHggLSAuMjA1ICogaywgeSArIC4yMTIgKiBrIF0pLmNsaXBFeHRlbnQoWyBbIHggLSAuMjE0ICogayArIM61LCB5ICsgLjE2NiAqIGsgKyDOtSBdLCBbIHggLSAuMTE1ICogayAtIM61LCB5ICsgLjIzNCAqIGsgLSDOtSBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgIH07XG4gICAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbiAgfTtcbiAgdmFyIGQzX2dlb19wYXRoQXJlYVN1bSwgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiwgZDNfZ2VvX3BhdGhBcmVhID0ge1xuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFQb2x5Z29uID0gMDtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5saW5lU3RhcnQgPSBkM19nZW9fcGF0aEFyZWFSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5saW5lU3RhcnQgPSBkM19nZW9fcGF0aEFyZWEubGluZUVuZCA9IGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgICBkM19nZW9fcGF0aEFyZWFTdW0gKz0gYWJzKGQzX2dlb19wYXRoQXJlYVBvbHlnb24gLyAyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgeDAwLCB5MDAsIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFQb2x5Z29uICs9IHkwICogeCAtIHgwICogeTtcbiAgICAgIHgwID0geCwgeTAgPSB5O1xuICAgIH1cbiAgICBkM19nZW9fcGF0aEFyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KHgwMCwgeTAwKTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19nZW9fcGF0aEJvdW5kc1gwLCBkM19nZW9fcGF0aEJvdW5kc1kwLCBkM19nZW9fcGF0aEJvdW5kc1gxLCBkM19nZW9fcGF0aEJvdW5kc1kxO1xuICB2YXIgZDNfZ2VvX3BhdGhCb3VuZHMgPSB7XG4gICAgcG9pbnQ6IGQzX2dlb19wYXRoQm91bmRzUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBkM19ub29wLFxuICAgIHBvbHlnb25FbmQ6IGQzX25vb3BcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCb3VuZHNQb2ludCh4LCB5KSB7XG4gICAgaWYgKHggPCBkM19nZW9fcGF0aEJvdW5kc1gwKSBkM19nZW9fcGF0aEJvdW5kc1gwID0geDtcbiAgICBpZiAoeCA+IGQzX2dlb19wYXRoQm91bmRzWDEpIGQzX2dlb19wYXRoQm91bmRzWDEgPSB4O1xuICAgIGlmICh5IDwgZDNfZ2VvX3BhdGhCb3VuZHNZMCkgZDNfZ2VvX3BhdGhCb3VuZHNZMCA9IHk7XG4gICAgaWYgKHkgPiBkM19nZW9fcGF0aEJvdW5kc1kxKSBkM19nZW9fcGF0aEJvdW5kc1kxID0geTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJ1ZmZlcigpIHtcbiAgICB2YXIgcG9pbnRDaXJjbGUgPSBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZSg0LjUpLCBidWZmZXIgPSBbXTtcbiAgICB2YXIgc3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lU3RhcnQ7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZFBvbHlnb247XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcG9pbnRDaXJjbGUgPSBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZShfKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBidWZmZXIuam9pbihcIlwiKTtcbiAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHBvaW50Q2lyY2xlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lU3RhcnQoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTFwiLCB4LCBcIixcIiwgeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZFBvbHlnb24oKSB7XG4gICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUocmFkaXVzKSB7XG4gICAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXMgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAyICogcmFkaXVzICsgXCJ6XCI7XG4gIH1cbiAgdmFyIGQzX2dlb19wYXRoQ2VudHJvaWQgPSB7XG4gICAgcG9pbnQ6IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZUVuZCA9IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgsIHkpIHtcbiAgICBkM19nZW9fY2VudHJvaWRYMCArPSB4O1xuICAgIGQzX2dlb19jZW50cm9pZFkwICs9IHk7XG4gICAgKytkM19nZW9fY2VudHJvaWRaMDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgIHZhciB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB6O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQoKSB7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgIHZhciB4MDAsIHkwMCwgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gejtcbiAgICAgIHogPSB5MCAqIHggLSB4MCAqIHk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMiArPSB6ICogKHgwICsgeCk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMiArPSB6ICogKHkwICsgeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMiArPSB6ICogMztcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfVxuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KHgwMCwgeTAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgdmFyIHBvaW50UmFkaXVzID0gNC41O1xuICAgIHZhciBzdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmVTdGFydDtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kUG9seWdvbjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIH0sXG4gICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgICAgICBwb2ludFJhZGl1cyA9IF87XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgcmVzdWx0OiBkM19ub29wXG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgcG9pbnRSYWRpdXMsIHkpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgcG9pbnRSYWRpdXMsIDAsIM+EKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lU3RhcnQoeCwgeSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZSh4LCB5KSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kUG9seWdvbigpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Jlc2FtcGxlKHByb2plY3QpIHtcbiAgICB2YXIgzrQyID0gLjUsIGNvc01pbkRpc3RhbmNlID0gTWF0aC5jb3MoMzAgKiBkM19yYWRpYW5zKSwgbWF4RGVwdGggPSAxNjtcbiAgICBmdW5jdGlvbiByZXNhbXBsZShzdHJlYW0pIHtcbiAgICAgIHJldHVybiAobWF4RGVwdGggPyByZXNhbXBsZVJlY3Vyc2l2ZSA6IHJlc2FtcGxlTm9uZSkoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVOb25lKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZVJlY3Vyc2l2ZShzdHJlYW0pIHtcbiAgICAgIHZhciDOuzAwLCDPhjAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgzrswLCB4MCwgeTAsIGEwLCBiMCwgYzA7XG4gICAgICB2YXIgcmVzYW1wbGUgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIHJlc2FtcGxlLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICByZXNhbXBsZS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIHgwID0gTmFOO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVBvaW50KM67LCDPhikge1xuICAgICAgICB2YXIgYyA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuywgz4YgXSksIHAgPSBwcm9qZWN0KM67LCDPhik7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgzrswID0gzrssIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIGxpbmVTdGFydCgpO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgcmVzYW1wbGUubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nUG9pbnQozrssIM+GKSB7XG4gICAgICAgIGxpbmVQb2ludCjOuzAwID0gzrssIM+GMDAgPSDPhiksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDAwLCB5MDAsIM67MDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICByZXNhbXBsZS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgbGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc2FtcGxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDEsIHkxLCDOuzEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICAgIHZhciBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MCwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA+IDQgKiDOtDIgJiYgZGVwdGgtLSkge1xuICAgICAgICB2YXIgYSA9IGEwICsgYTEsIGIgPSBiMCArIGIxLCBjID0gYzAgKyBjMSwgbSA9IE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpLCDPhjIgPSBNYXRoLmFzaW4oYyAvPSBtKSwgzrsyID0gYWJzKGFicyhjKSAtIDEpIDwgzrUgfHwgYWJzKM67MCAtIM67MSkgPCDOtSA/ICjOuzAgKyDOuzEpIC8gMiA6IE1hdGguYXRhbjIoYiwgYSksIHAgPSBwcm9qZWN0KM67Miwgz4YyKSwgeDIgPSBwWzBdLCB5MiA9IHBbMV0sIGR4MiA9IHgyIC0geDAsIGR5MiA9IHkyIC0geTAsIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgICAgaWYgKGR6ICogZHogLyBkMiA+IM60MiB8fCBhYnMoKGR4ICogZHgyICsgZHkgKiBkeTIpIC8gZDIgLSAuNSkgPiAuMyB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkge1xuICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MiwgeTIsIM67MiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgzrsyLCBhLCBiLCBjLCB4MSwgeTEsIM67MSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzYW1wbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KM60Mik7XG4gICAgICBtYXhEZXB0aCA9ICjOtDIgPSBfICogXykgPiAwICYmIDE2O1xuICAgICAgcmV0dXJuIHJlc2FtcGxlO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2FtcGxlO1xuICB9XG4gIGQzLmdlby5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBvaW50UmFkaXVzID0gNC41LCBwcm9qZWN0aW9uLCBjb250ZXh0LCBwcm9qZWN0U3RyZWFtLCBjb250ZXh0U3RyZWFtLCBjYWNoZVN0cmVhbTtcbiAgICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoIWNhY2hlU3RyZWFtIHx8ICFjYWNoZVN0cmVhbS52YWxpZCkgY2FjaGVTdHJlYW0gPSBwcm9qZWN0U3RyZWFtKGNvbnRleHRTdHJlYW0pO1xuICAgICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgY2FjaGVTdHJlYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gICAgfVxuICAgIHBhdGguYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhU3VtID0gMDtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQXJlYSkpO1xuICAgICAgcmV0dXJuIGQzX2dlb19wYXRoQXJlYVN1bTtcbiAgICB9O1xuICAgIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgwID0gZDNfZ2VvX2NlbnRyb2lkWTAgPSBkM19nZW9fY2VudHJvaWRaMCA9IGQzX2dlb19jZW50cm9pZFgxID0gZDNfZ2VvX2NlbnRyb2lkWTEgPSBkM19nZW9fY2VudHJvaWRaMSA9IGQzX2dlb19jZW50cm9pZFgyID0gZDNfZ2VvX2NlbnRyb2lkWTIgPSBkM19nZW9fY2VudHJvaWRaMiA9IDA7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aENlbnRyb2lkKSk7XG4gICAgICByZXR1cm4gZDNfZ2VvX2NlbnRyb2lkWjIgPyBbIGQzX2dlb19jZW50cm9pZFgyIC8gZDNfZ2VvX2NlbnRyb2lkWjIsIGQzX2dlb19jZW50cm9pZFkyIC8gZDNfZ2VvX2NlbnRyb2lkWjIgXSA6IGQzX2dlb19jZW50cm9pZFoxID8gWyBkM19nZW9fY2VudHJvaWRYMSAvIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRZMSAvIGQzX2dlb19jZW50cm9pZFoxIF0gOiBkM19nZW9fY2VudHJvaWRaMCA/IFsgZDNfZ2VvX2NlbnRyb2lkWDAgLyBkM19nZW9fY2VudHJvaWRaMCwgZDNfZ2VvX2NlbnRyb2lkWTAgLyBkM19nZW9fY2VudHJvaWRaMCBdIDogWyBOYU4sIE5hTiBdO1xuICAgIH07XG4gICAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19wYXRoQm91bmRzWDEgPSBkM19nZW9fcGF0aEJvdW5kc1kxID0gLShkM19nZW9fcGF0aEJvdW5kc1gwID0gZDNfZ2VvX3BhdGhCb3VuZHNZMCA9IEluZmluaXR5KTtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQm91bmRzKSk7XG4gICAgICByZXR1cm4gWyBbIGQzX2dlb19wYXRoQm91bmRzWDAsIGQzX2dlb19wYXRoQm91bmRzWTAgXSwgWyBkM19nZW9fcGF0aEJvdW5kc1gxLCBkM19nZW9fcGF0aEJvdW5kc1kxIF0gXTtcbiAgICB9O1xuICAgIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICBwcm9qZWN0U3RyZWFtID0gKHByb2plY3Rpb24gPSBfKSA/IF8uc3RyZWFtIHx8IGQzX2dlb19wYXRoUHJvamVjdFN0cmVhbShfKSA6IGQzX2lkZW50aXR5O1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgICAgY29udGV4dFN0cmVhbSA9IChjb250ZXh0ID0gXykgPT0gbnVsbCA/IG5ldyBkM19nZW9fcGF0aEJ1ZmZlcigpIDogbmV3IGQzX2dlb19wYXRoQ29udGV4dChfKTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihkMy5nZW8uYWxiZXJzVXNhKCkpLmNvbnRleHQobnVsbCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoUHJvamVjdFN0cmVhbShwcm9qZWN0KSB7XG4gICAgdmFyIHJlc2FtcGxlID0gZDNfZ2VvX3Jlc2FtcGxlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0KFsgeCAqIGQzX2RlZ3JlZXMsIHkgKiBkM19kZWdyZWVzIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMocmVzYW1wbGUoc3RyZWFtKSk7XG4gICAgfTtcbiAgfVxuICBkMy5nZW8udHJhbnNmb3JtID0gZnVuY3Rpb24obWV0aG9kcykge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IGQzX2dlb190cmFuc2Zvcm0oc3RyZWFtKTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBtZXRob2RzKSB0cmFuc2Zvcm1ba10gPSBtZXRob2RzW2tdO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc2Zvcm0oc3RyZWFtKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cbiAgZDNfZ2VvX3RyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnNwaGVyZSgpO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5saW5lRW5kKCk7XG4gICAgfSxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIHBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgICAgIH0sXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDMuZ2VvLnByb2plY3Rpb24gPSBkM19nZW9fcHJvamVjdGlvbjtcbiAgZDMuZ2VvLnByb2plY3Rpb25NdXRhdG9yID0gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yO1xuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH0pKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICAgIHZhciBwcm9qZWN0LCByb3RhdGUsIHByb2plY3RSb3RhdGUsIHByb2plY3RSZXNhbXBsZSA9IGQzX2dlb19yZXNhbXBsZShmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHJldHVybiBbIHhbMF0gKiBrICsgzrR4LCDOtHkgLSB4WzFdICogayBdO1xuICAgIH0pLCBrID0gMTUwLCB4ID0gNDgwLCB5ID0gMjUwLCDOuyA9IDAsIM+GID0gMCwgzrTOuyA9IDAsIM60z4YgPSAwLCDOtM6zID0gMCwgzrR4LCDOtHksIHByZWNsaXAgPSBkM19nZW9fY2xpcEFudGltZXJpZGlhbiwgcG9zdGNsaXAgPSBkM19pZGVudGl0eSwgY2xpcEFuZ2xlID0gbnVsbCwgY2xpcEV4dGVudCA9IG51bGwsIHN0cmVhbTtcbiAgICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUocG9pbnRbMF0gKiBkM19yYWRpYW5zLCBwb2ludFsxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIFsgcG9pbnRbMF0gKiBrICsgzrR4LCDOtHkgLSBwb2ludFsxXSAqIGsgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUuaW52ZXJ0KChwb2ludFswXSAtIM60eCkgLyBrLCAozrR5IC0gcG9pbnRbMV0pIC8gayk7XG4gICAgICByZXR1cm4gcG9pbnQgJiYgWyBwb2ludFswXSAqIGQzX2RlZ3JlZXMsIHBvaW50WzFdICogZDNfZGVncmVlcyBdO1xuICAgIH1cbiAgICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2U7XG4gICAgICBzdHJlYW0gPSBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMocHJlY2xpcChyb3RhdGUsIHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChvdXRwdXQpKSkpO1xuICAgICAgc3RyZWFtLnZhbGlkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBBbmdsZTtcbiAgICAgIHByZWNsaXAgPSBfID09IG51bGwgPyAoY2xpcEFuZ2xlID0gXywgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4pIDogZDNfZ2VvX2NsaXBDaXJjbGUoKGNsaXBBbmdsZSA9ICtfKSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQ7XG4gICAgICBjbGlwRXh0ZW50ID0gXztcbiAgICAgIHBvc3RjbGlwID0gXyA/IGQzX2dlb19jbGlwRXh0ZW50KF9bMF1bMF0sIF9bMF1bMV0sIF9bMV1bMF0sIF9bMV1bMV0pIDogZDNfaWRlbnRpdHk7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGs7XG4gICAgICBrID0gK187XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB4LCB5IF07XG4gICAgICB4ID0gK19bMF07XG4gICAgICB5ID0gK19bMV07XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDOuyAqIGQzX2RlZ3JlZXMsIM+GICogZDNfZGVncmVlcyBdO1xuICAgICAgzrsgPSBfWzBdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM+GID0gX1sxXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDOtM67ICogZDNfZGVncmVlcywgzrTPhiAqIGQzX2RlZ3JlZXMsIM60zrMgKiBkM19kZWdyZWVzIF07XG4gICAgICDOtM67ID0gX1swXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDOtM+GID0gX1sxXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDOtM6zID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIGQzX3JhZGlhbnMgOiAwO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBkMy5yZWJpbmQocHJvamVjdGlvbiwgcHJvamVjdFJlc2FtcGxlLCBcInByZWNpc2lvblwiKTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHByb2plY3RSb3RhdGUgPSBkM19nZW9fY29tcG9zZShyb3RhdGUgPSBkM19nZW9fcm90YXRpb24ozrTOuywgzrTPhiwgzrTOsyksIHByb2plY3QpO1xuICAgICAgdmFyIGNlbnRlciA9IHByb2plY3QozrssIM+GKTtcbiAgICAgIM60eCA9IHggLSBjZW50ZXJbMF0gKiBrO1xuICAgICAgzrR5ID0geSArIGNlbnRlclsxXSAqIGs7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2UsIHN0cmVhbSA9IG51bGw7XG4gICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhzdHJlYW0pIHtcbiAgICByZXR1cm4gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgc3RyZWFtLnBvaW50KHggKiBkM19yYWRpYW5zLCB5ICogZDNfcmFkaWFucyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuywgz4YgXTtcbiAgfVxuICAoZDMuZ2VvLmVxdWlyZWN0YW5ndWxhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fZXF1aXJlY3Rhbmd1bGFyKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhci5pbnZlcnQgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICBkMy5nZW8ucm90YXRpb24gPSBmdW5jdGlvbihyb3RhdGUpIHtcbiAgICByb3RhdGUgPSBkM19nZW9fcm90YXRpb24ocm90YXRlWzBdICUgMzYwICogZDNfcmFkaWFucywgcm90YXRlWzFdICogZDNfcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiBkM19yYWRpYW5zIDogMCk7XG4gICAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiBkM19yYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiBkM19yYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19pZGVudGl0eVJvdGF0aW9uKM67LCDPhikge1xuICAgIHJldHVybiBbIM67ID4gz4AgPyDOuyAtIM+EIDogzrsgPCAtz4AgPyDOuyArIM+EIDogzrssIM+GIF07XG4gIH1cbiAgZDNfZ2VvX2lkZW50aXR5Um90YXRpb24uaW52ZXJ0ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uKM60zrssIM60z4YsIM60zrMpIHtcbiAgICByZXR1cm4gzrTOuyA/IM60z4YgfHwgzrTOsyA/IGQzX2dlb19jb21wb3NlKGQzX2dlb19yb3RhdGlvbs67KM60zrspLCBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpKSA6IGQzX2dlb19yb3RhdGlvbs67KM60zrspIDogzrTPhiB8fCDOtM6zID8gZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSA6IGQzX2dlb19pZGVudGl0eVJvdGF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19mb3J3YXJkUm90YXRpb27OuyjOtM67KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgcmV0dXJuIM67ICs9IM60zrssIFsgzrsgPiDPgCA/IM67IC0gz4QgOiDOuyA8IC3PgCA/IM67ICsgz4QgOiDOuywgz4YgXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbs67KM60zrspIHtcbiAgICB2YXIgcm90YXRpb24gPSBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsozrTOuyk7XG4gICAgcm90YXRpb24uaW52ZXJ0ID0gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KC3OtM67KTtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSB7XG4gICAgdmFyIGNvc860z4YgPSBNYXRoLmNvcyjOtM+GKSwgc2luzrTPhiA9IE1hdGguc2luKM60z4YpLCBjb3POtM6zID0gTWF0aC5jb3MozrTOsyksIHNpbs60zrMgPSBNYXRoLnNpbijOtM6zKTtcbiAgICBmdW5jdGlvbiByb3RhdGlvbijOuywgz4YpIHtcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GKSwgeCA9IE1hdGguY29zKM67KSAqIGNvc8+GLCB5ID0gTWF0aC5zaW4ozrspICogY29zz4YsIHogPSBNYXRoLnNpbijPhiksIGsgPSB6ICogY29zzrTPhiArIHggKiBzaW7OtM+GO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5ICogY29zzrTOsyAtIGsgKiBzaW7OtM6zLCB4ICogY29zzrTPhiAtIHogKiBzaW7OtM+GKSwgZDNfYXNpbihrICogY29zzrTOsyArIHkgKiBzaW7OtM6zKSBdO1xuICAgIH1cbiAgICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GKSwgeCA9IE1hdGguY29zKM67KSAqIGNvc8+GLCB5ID0gTWF0aC5zaW4ozrspICogY29zz4YsIHogPSBNYXRoLnNpbijPhiksIGsgPSB6ICogY29zzrTOsyAtIHkgKiBzaW7OtM6zO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5ICogY29zzrTOsyArIHogKiBzaW7OtM6zLCB4ICogY29zzrTPhiArIGsgKiBzaW7OtM+GKSwgZDNfYXNpbihrICogY29zzrTPhiAtIHggKiBzaW7OtM+GKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG4gIGQzLmdlby5jaXJjbGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luID0gWyAwLCAwIF0sIGFuZ2xlLCBwcmVjaXNpb24gPSA2LCBpbnRlcnBvbGF0ZTtcbiAgICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgICB2YXIgY2VudGVyID0gdHlwZW9mIG9yaWdpbiA9PT0gXCJmdW5jdGlvblwiID8gb3JpZ2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvcmlnaW4sIHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbigtY2VudGVyWzBdICogZDNfcmFkaWFucywgLWNlbnRlclsxXSAqIGQzX3JhZGlhbnMsIDApLmludmVydCwgcmluZyA9IFtdO1xuICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwge1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICAgICAgICB4WzBdICo9IGQzX2RlZ3JlZXMsIHhbMV0gKj0gZDNfZGVncmVlcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgcmluZyBdXG4gICAgICB9O1xuICAgIH1cbiAgICBjaXJjbGUub3JpZ2luID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luO1xuICAgICAgb3JpZ2luID0geDtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICBjaXJjbGUuYW5nbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhbmdsZTtcbiAgICAgIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKChhbmdsZSA9ICt4KSAqIGQzX3JhZGlhbnMsIHByZWNpc2lvbiAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgICBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShhbmdsZSAqIGQzX3JhZGlhbnMsIChwcmVjaXNpb24gPSArXykgKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICByZXR1cm4gY2lyY2xlLmFuZ2xlKDkwKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKHJhZGl1cywgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGNyID0gTWF0aC5jb3MocmFkaXVzKSwgc3IgPSBNYXRoLnNpbihyYWRpdXMpO1xuICAgIHJldHVybiBmdW5jdGlvbihmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIHN0ZXAgPSBkaXJlY3Rpb24gKiBwcmVjaXNpb247XG4gICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIGZyb20pO1xuICAgICAgICB0byA9IGQzX2dlb19jaXJjbGVBbmdsZShjciwgdG8pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCA/IGZyb20gPCB0byA6IGZyb20gPiB0bykgZnJvbSArPSBkaXJlY3Rpb24gKiDPhDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSByYWRpdXMgKyBkaXJlY3Rpb24gKiDPhDtcbiAgICAgICAgdG8gPSByYWRpdXMgLSAuNSAqIHN0ZXA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwb2ludCwgdCA9IGZyb207IGRpcmVjdGlvbiA+IDAgPyB0ID4gdG8gOiB0IDwgdG87IHQgLT0gc3RlcCkge1xuICAgICAgICBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBkM19nZW9fc3BoZXJpY2FsKFsgY3IsIC1zciAqIE1hdGguY29zKHQpLCAtc3IgKiBNYXRoLnNpbih0KSBdKSlbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jaXJjbGVBbmdsZShjciwgcG9pbnQpIHtcbiAgICB2YXIgYSA9IGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQpO1xuICAgIGFbMF0gLT0gY3I7XG4gICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShhKTtcbiAgICB2YXIgYW5nbGUgPSBkM19hY29zKC1hWzFdKTtcbiAgICByZXR1cm4gKCgtYVsyXSA8IDAgPyAtYW5nbGUgOiBhbmdsZSkgKyAyICogTWF0aC5QSSAtIM61KSAlICgyICogTWF0aC5QSSk7XG4gIH1cbiAgZDMuZ2VvLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciDOlM67ID0gKGJbMF0gLSBhWzBdKSAqIGQzX3JhZGlhbnMsIM+GMCA9IGFbMV0gKiBkM19yYWRpYW5zLCDPhjEgPSBiWzFdICogZDNfcmFkaWFucywgc2luzpTOuyA9IE1hdGguc2luKM6UzrspLCBjb3POlM67ID0gTWF0aC5jb3MozpTOuyksIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIHNpbs+GMSA9IE1hdGguc2luKM+GMSksIGNvc8+GMSA9IE1hdGguY29zKM+GMSksIHQ7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh0ID0gY29zz4YxICogc2luzpTOuykgKiB0ICsgKHQgPSBjb3PPhjAgKiBzaW7PhjEgLSBzaW7PhjAgKiBjb3PPhjEgKiBjb3POlM67KSAqIHQpLCBzaW7PhjAgKiBzaW7PhjEgKyBjb3PPhjAgKiBjb3PPhjEgKiBjb3POlM67KTtcbiAgfTtcbiAgZDMuZ2VvLmdyYXRpY3VsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4MSwgeDAsIFgxLCBYMCwgeTEsIHkwLCBZMSwgWTAsIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLCB4LCB5LCBYLCBZLCBwcmVjaXNpb24gPSAyLjU7XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGxpbmVzKClcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKE1hdGguY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGFicyh4ICUgRFgpID4gzrU7XG4gICAgICB9KS5tYXAoeCkpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gYWJzKHkgJSBEWSkgPiDOtTtcbiAgICAgIH0pLm1hcCh5KSk7XG4gICAgfVxuICAgIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgWChYMCkuY29uY2F0KFkoWTEpLnNsaWNlKDEpLCBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSkgXVxuICAgICAgfTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUubWlub3JFeHRlbnQoKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JFeHRlbnQoXykubWlub3JFeHRlbnQoXyk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWFqb3JFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgWDAsIFkwIF0sIFsgWDEsIFkxIF0gXTtcbiAgICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5taW5vckV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdO1xuICAgICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgICBpZiAoeTAgPiB5MSkgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUubWlub3JTdGVwKCk7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yU3RlcChfKS5taW5vclN0ZXAoXyk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWFqb3JTdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBEWCwgRFkgXTtcbiAgICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1pbm9yU3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgZHgsIGR5IF07XG4gICAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgICBwcmVjaXNpb24gPSArXztcbiAgICAgIHggPSBkM19nZW9fZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICAgIHkgPSBkM19nZW9fZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgICBYID0gZDNfZ2VvX2dyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgICBZID0gZDNfZ2VvX2dyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JFeHRlbnQoWyBbIC0xODAsIC05MCArIM61IF0sIFsgMTgwLCA5MCAtIM61IF0gXSkubWlub3JFeHRlbnQoWyBbIC0xODAsIC04MCAtIM61IF0sIFsgMTgwLCA4MCArIM61IF0gXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19ncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgICB2YXIgeSA9IGQzLnJhbmdlKHkwLCB5MSAtIM61LCBkeSkuY29uY2F0KHkxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gICAgdmFyIHggPSBkMy5yYW5nZSh4MCwgeDEgLSDOtSwgZHgpLmNvbmNhdCh4MSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc291cmNlKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGFyZ2V0KGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH1cbiAgZDMuZ2VvLmdyZWF0QXJjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgc291cmNlXywgdGFyZ2V0ID0gZDNfdGFyZ2V0LCB0YXJnZXRfO1xuICAgIGZ1bmN0aW9uIGdyZWF0QXJjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIHNvdXJjZV8gfHwgc291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRhcmdldF8gfHwgdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgXVxuICAgICAgfTtcbiAgICB9XG4gICAgZ3JlYXRBcmMuZGlzdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkMy5nZW8uZGlzdGFuY2Uoc291cmNlXyB8fCBzb3VyY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGFyZ2V0XyB8fCB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBncmVhdEFyYy5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBfLCBzb3VyY2VfID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIGdyZWF0QXJjO1xuICAgIH07XG4gICAgZ3JlYXRBcmMudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gXywgdGFyZ2V0XyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBudWxsIDogXztcbiAgICAgIHJldHVybiBncmVhdEFyYztcbiAgICB9O1xuICAgIGdyZWF0QXJjLnByZWNpc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBncmVhdEFyYyA6IDA7XG4gICAgfTtcbiAgICByZXR1cm4gZ3JlYXRBcmM7XG4gIH07XG4gIGQzLmdlby5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGQzX2dlb19pbnRlcnBvbGF0ZShzb3VyY2VbMF0gKiBkM19yYWRpYW5zLCBzb3VyY2VbMV0gKiBkM19yYWRpYW5zLCB0YXJnZXRbMF0gKiBkM19yYWRpYW5zLCB0YXJnZXRbMV0gKiBkM19yYWRpYW5zKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2ludGVycG9sYXRlKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgdmFyIGN5MCA9IE1hdGguY29zKHkwKSwgc3kwID0gTWF0aC5zaW4oeTApLCBjeTEgPSBNYXRoLmNvcyh5MSksIHN5MSA9IE1hdGguc2luKHkxKSwga3gwID0gY3kwICogTWF0aC5jb3MoeDApLCBreTAgPSBjeTAgKiBNYXRoLnNpbih4MCksIGt4MSA9IGN5MSAqIE1hdGguY29zKHgxKSwga3kxID0gY3kxICogTWF0aC5zaW4oeDEpLCBkID0gMiAqIE1hdGguYXNpbihNYXRoLnNxcnQoZDNfaGF2ZXJzaW4oeTEgLSB5MCkgKyBjeTAgKiBjeTEgKiBkM19oYXZlcnNpbih4MSAtIHgwKSkpLCBrID0gMSAvIE1hdGguc2luKGQpO1xuICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgQiA9IE1hdGguc2luKHQgKj0gZCkgKiBrLCBBID0gTWF0aC5zaW4oZCAtIHQpICogaywgeCA9IEEgKiBreDAgKyBCICoga3gxLCB5ID0gQSAqIGt5MCArIEIgKiBreTEsIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBNYXRoLmF0YW4yKHosIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSkgKiBkM19kZWdyZWVzIF07XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFsgeDAgKiBkM19kZWdyZWVzLCB5MCAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9O1xuICAgIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGU7XG4gIH1cbiAgZDMuZ2VvLmxlbmd0aCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19sZW5ndGhTdW0gPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fbGVuZ3RoKTtcbiAgICByZXR1cm4gZDNfZ2VvX2xlbmd0aFN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19sZW5ndGhTdW07XG4gIHZhciBkM19nZW9fbGVuZ3RoID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19sZW5ndGhMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGQzX25vb3AsXG4gICAgcG9seWdvbkVuZDogZDNfbm9vcFxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fbGVuZ3RoTGluZVN0YXJ0KCkge1xuICAgIHZhciDOuzAsIHNpbs+GMCwgY29zz4YwO1xuICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MCA9IM67ICogZDNfcmFkaWFucywgc2luz4YwID0gTWF0aC5zaW4oz4YgKj0gZDNfcmFkaWFucyksIGNvc8+GMCA9IE1hdGguY29zKM+GKTtcbiAgICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgfTtcbiAgICBkM19nZW9fbGVuZ3RoLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBkM19nZW9fbGVuZ3RoLmxpbmVFbmQgPSBkM19ub29wO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgdmFyIHNpbs+GID0gTWF0aC5zaW4oz4YgKj0gZDNfcmFkaWFucyksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB0ID0gYWJzKCjOuyAqPSBkM19yYWRpYW5zKSAtIM67MCksIGNvc86UzrsgPSBNYXRoLmNvcyh0KTtcbiAgICAgIGQzX2dlb19sZW5ndGhTdW0gKz0gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHQgPSBjb3PPhiAqIE1hdGguc2luKHQpKSAqIHQgKyAodCA9IGNvc8+GMCAqIHNpbs+GIC0gc2luz4YwICogY29zz4YgKiBjb3POlM67KSAqIHQpLCBzaW7PhjAgKiBzaW7PhiArIGNvc8+GMCAqIGNvc8+GICogY29zzpTOuyk7XG4gICAgICDOuzAgPSDOuywgc2luz4YwID0gc2luz4YsIGNvc8+GMCA9IGNvc8+GO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fYXppbXV0aGFsKHNjYWxlLCBhbmdsZSkge1xuICAgIGZ1bmN0aW9uIGF6aW11dGhhbCjOuywgz4YpIHtcbiAgICAgIHZhciBjb3POuyA9IE1hdGguY29zKM67KSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGsgPSBzY2FsZShjb3POuyAqIGNvc8+GKTtcbiAgICAgIHJldHVybiBbIGsgKiBjb3PPhiAqIE1hdGguc2luKM67KSwgayAqIE1hdGguc2luKM+GKSBdO1xuICAgIH1cbiAgICBhemltdXRoYWwuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjID0gYW5nbGUoz4EpLCBzaW5jID0gTWF0aC5zaW4oYyksIGNvc2MgPSBNYXRoLmNvcyhjKTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCAqIHNpbmMsIM+BICogY29zYyksIE1hdGguYXNpbijPgSAmJiB5ICogc2luYyAvIM+BKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGF6aW11dGhhbDtcbiAgfVxuICB2YXIgZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYSA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMiAvICgxICsgY29zzrtjb3PPhikpO1xuICB9LCBmdW5jdGlvbijPgSkge1xuICAgIHJldHVybiAyICogTWF0aC5hc2luKM+BIC8gMik7XG4gIH0pO1xuICAoZDMuZ2VvLmF6aW11dGhhbEVxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYTtcbiAgdmFyIGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudCA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHZhciBjID0gTWF0aC5hY29zKGNvc867Y29zz4YpO1xuICAgIHJldHVybiBjICYmIGMgLyBNYXRoLnNpbihjKTtcbiAgfSwgZDNfaWRlbnRpdHkpO1xuICAoZDMuZ2VvLmF6aW11dGhhbEVxdWlkaXN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudCk7XG4gIH0pLnJhdyA9IGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudDtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljQ29uZm9ybWFsKM+GMCwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIHQgPSBmdW5jdGlvbijPhikge1xuICAgICAgcmV0dXJuIE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMik7XG4gICAgfSwgbiA9IM+GMCA9PT0gz4YxID8gTWF0aC5zaW4oz4YwKSA6IE1hdGgubG9nKGNvc8+GMCAvIE1hdGguY29zKM+GMSkpIC8gTWF0aC5sb2codCjPhjEpIC8gdCjPhjApKSwgRiA9IGNvc8+GMCAqIE1hdGgucG93KHQoz4YwKSwgbikgLyBuO1xuICAgIGlmICghbikgcmV0dXJuIGQzX2dlb19tZXJjYXRvcjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgaWYgKEYgPiAwKSB7XG4gICAgICAgIGlmICjPhiA8IC1oYWxmz4AgKyDOtSkgz4YgPSAtaGFsZs+AICsgzrU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoz4YgPiBoYWxmz4AgLSDOtSkgz4YgPSBoYWxmz4AgLSDOtTtcbiAgICAgIH1cbiAgICAgIHZhciDPgSA9IEYgLyBNYXRoLnBvdyh0KM+GKSwgbik7XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKG4gKiDOuyksIEYgLSDPgSAqIE1hdGguY29zKG4gKiDOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSBGIC0geSwgz4EgPSBkM19zZ24obikgKiBNYXRoLnNxcnQoeCAqIHggKyDPgTBfeSAqIM+BMF95KTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgMiAqIE1hdGguYXRhbihNYXRoLnBvdyhGIC8gz4EsIDEgLyBuKSkgLSBoYWxmz4AgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNDb25mb3JtYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0NvbmZvcm1hbCk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0NvbmZvcm1hbDtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQoz4YwLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgbiA9IM+GMCA9PT0gz4YxID8gTWF0aC5zaW4oz4YwKSA6IChjb3PPhjAgLSBNYXRoLmNvcyjPhjEpKSAvICjPhjEgLSDPhjApLCBHID0gY29zz4YwIC8gbiArIM+GMDtcbiAgICBpZiAoYWJzKG4pIDwgzrUpIHJldHVybiBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICB2YXIgz4EgPSBHIC0gz4Y7XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKG4gKiDOuyksIEcgLSDPgSAqIE1hdGguY29zKG4gKiDOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSBHIC0geTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgRyAtIGQzX3NnbihuKSAqIE1hdGguc3FydCh4ICogeCArIM+BMF95ICogz4EwX3kpIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0VxdWlkaXN0YW50KTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQ7XG4gIHZhciBkM19nZW9fZ25vbW9uaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gMSAvIGNvc867Y29zz4Y7XG4gIH0sIE1hdGguYXRhbik7XG4gIChkMy5nZW8uZ25vbW9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2dub21vbmljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2dub21vbmljO1xuICBmdW5jdGlvbiBkM19nZW9fbWVyY2F0b3IozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrssIE1hdGgubG9nKE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMikpIF07XG4gIH1cbiAgZDNfZ2VvX21lcmNhdG9yLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyB4LCAyICogTWF0aC5hdGFuKE1hdGguZXhwKHkpKSAtIGhhbGbPgCBdO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICB2YXIgbSA9IGQzX2dlb19wcm9qZWN0aW9uKHByb2plY3QpLCBzY2FsZSA9IG0uc2NhbGUsIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLCBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LCBjbGlwQXV0bztcbiAgICBtLnNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHNjYWxlLmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdiA9PT0gbSA/IGNsaXBBdXRvID8gbS5jbGlwRXh0ZW50KG51bGwpIDogbSA6IHY7XG4gICAgfTtcbiAgICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB0cmFuc2xhdGUuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2ID09PSBtID8gY2xpcEF1dG8gPyBtLmNsaXBFeHRlbnQobnVsbCkgOiBtIDogdjtcbiAgICB9O1xuICAgIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciB2ID0gY2xpcEV4dGVudC5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT09IG0pIHtcbiAgICAgICAgaWYgKGNsaXBBdXRvID0gXyA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGsgPSDPgCAqIHNjYWxlKCksIHQgPSB0cmFuc2xhdGUoKTtcbiAgICAgICAgICBjbGlwRXh0ZW50KFsgWyB0WzBdIC0gaywgdFsxXSAtIGsgXSwgWyB0WzBdICsgaywgdFsxXSArIGsgXSBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGlwQXV0bykge1xuICAgICAgICB2ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgcmV0dXJuIG0uY2xpcEV4dGVudChudWxsKTtcbiAgfVxuICAoZDMuZ2VvLm1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24oZDNfZ2VvX21lcmNhdG9yKTtcbiAgfSkucmF3ID0gZDNfZ2VvX21lcmNhdG9yO1xuICB2YXIgZDNfZ2VvX29ydGhvZ3JhcGhpYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sIE1hdGguYXNpbik7XG4gIChkMy5nZW8ub3J0aG9ncmFwaGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19vcnRob2dyYXBoaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fb3J0aG9ncmFwaGljO1xuICB2YXIgZDNfZ2VvX3N0ZXJlb2dyYXBoaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gMSAvICgxICsgY29zzrtjb3PPhik7XG4gIH0sIGZ1bmN0aW9uKM+BKSB7XG4gICAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oz4EpO1xuICB9KTtcbiAgKGQzLmdlby5zdGVyZW9ncmFwaGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19zdGVyZW9ncmFwaGljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX3N0ZXJlb2dyYXBoaWM7XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5sb2coTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKSksIC3OuyBdO1xuICB9XG4gIGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbIC15LCAyICogTWF0aC5hdGFuKE1hdGguZXhwKHgpKSAtIGhhbGbPgCBdO1xuICB9O1xuICAoZDMuZ2VvLnRyYW5zdmVyc2VNZXJjYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9qZWN0aW9uID0gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yKSwgY2VudGVyID0gcHJvamVjdGlvbi5jZW50ZXIsIHJvdGF0ZSA9IHByb2plY3Rpb24ucm90YXRlO1xuICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIF8gPyBjZW50ZXIoWyAtX1sxXSwgX1swXSBdKSA6IChfID0gY2VudGVyKCksIFsgX1sxXSwgLV9bMF0gXSk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBfID8gcm90YXRlKFsgX1swXSwgX1sxXSwgXy5sZW5ndGggPiAyID8gX1syXSArIDkwIDogOTAgXSkgOiAoXyA9IHJvdGF0ZSgpLCBcbiAgICAgIFsgX1swXSwgX1sxXSwgX1syXSAtIDkwIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdGF0ZShbIDAsIDAsIDkwIF0pO1xuICB9KS5yYXcgPSBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yO1xuICBkMy5nZW9tID0ge307XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9pbnRYKGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvaW50WShkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH1cbiAgZDMuZ2VvbS5odWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBodWxsKHZlcnRpY2VzKTtcbiAgICBmdW5jdGlvbiBodWxsKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDMpIHJldHVybiBbXTtcbiAgICAgIHZhciBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KSwgaSwgbiA9IGRhdGEubGVuZ3RoLCBwb2ludHMgPSBbXSwgZmxpcHBlZFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaChbICtmeC5jYWxsKHRoaXMsIGRhdGFbaV0sIGkpLCArZnkuY2FsbCh0aGlzLCBkYXRhW2ldLCBpKSwgaSBdKTtcbiAgICAgIH1cbiAgICAgIHBvaW50cy5zb3J0KGQzX2dlb21faHVsbE9yZGVyKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGZsaXBwZWRQb2ludHMucHVzaChbIHBvaW50c1tpXVswXSwgLXBvaW50c1tpXVsxXSBdKTtcbiAgICAgIHZhciB1cHBlciA9IGQzX2dlb21faHVsbFVwcGVyKHBvaW50cyksIGxvd2VyID0gZDNfZ2VvbV9odWxsVXBwZXIoZmxpcHBlZFBvaW50cyk7XG4gICAgICB2YXIgc2tpcExlZnQgPSBsb3dlclswXSA9PT0gdXBwZXJbMF0sIHNraXBSaWdodCA9IGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdID09PSB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgcG9seWdvbiA9IFtdO1xuICAgICAgZm9yIChpID0gdXBwZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHBvbHlnb24ucHVzaChkYXRhW3BvaW50c1t1cHBlcltpXV1bMl1dKTtcbiAgICAgIGZvciAoaSA9ICtza2lwTGVmdDsgaSA8IGxvd2VyLmxlbmd0aCAtIHNraXBSaWdodDsgKytpKSBwb2x5Z29uLnB1c2goZGF0YVtwb2ludHNbbG93ZXJbaV1dWzJdXSk7XG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9XG4gICAgaHVsbC54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IF8sIGh1bGwpIDogeDtcbiAgICB9O1xuICAgIGh1bGwueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBfLCBodWxsKSA6IHk7XG4gICAgfTtcbiAgICByZXR1cm4gaHVsbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9odWxsVXBwZXIocG9pbnRzKSB7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLCBodWxsID0gWyAwLCAxIF0sIGhzID0gMjtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IG47IGkrKykge1xuICAgICAgd2hpbGUgKGhzID4gMSAmJiBkM19jcm9zczJkKHBvaW50c1todWxsW2hzIC0gMl1dLCBwb2ludHNbaHVsbFtocyAtIDFdXSwgcG9pbnRzW2ldKSA8PSAwKSAtLWhzO1xuICAgICAgaHVsbFtocysrXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBodWxsLnNsaWNlKDAsIGhzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX2h1bGxPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xuICB9XG4gIGQzLmdlb20ucG9seWdvbiA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgZDNfc3ViY2xhc3MoY29vcmRpbmF0ZXMsIGQzX2dlb21fcG9seWdvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9O1xuICB2YXIgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlID0gZDMuZ2VvbS5wb2x5Z29uLnByb3RvdHlwZSA9IFtdO1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgYSwgYiA9IHRoaXNbbiAtIDFdLCBhcmVhID0gMDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGFyZWEgKz0gYVsxXSAqIGJbMF0gLSBhWzBdICogYlsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZWEgKiAuNTtcbiAgfTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmNlbnRyb2lkID0gZnVuY3Rpb24oaykge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgeCA9IDAsIHkgPSAwLCBhLCBiID0gdGhpc1tuIC0gMV0sIGM7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBrID0gLTEgLyAoNiAqIHRoaXMuYXJlYSgpKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGMgPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuICAgICAgeCArPSAoYVswXSArIGJbMF0pICogYztcbiAgICAgIHkgKz0gKGFbMV0gKyBiWzFdKSAqIGM7XG4gICAgfVxuICAgIHJldHVybiBbIHggKiBrLCB5ICogayBdO1xuICB9O1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uKHN1YmplY3QpIHtcbiAgICB2YXIgaW5wdXQsIGNsb3NlZCA9IGQzX2dlb21fcG9seWdvbkNsb3NlZChzdWJqZWN0KSwgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGggLSBkM19nZW9tX3BvbHlnb25DbG9zZWQodGhpcyksIGosIG0sIGEgPSB0aGlzW24gLSAxXSwgYiwgYywgZDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaW5wdXQgPSBzdWJqZWN0LnNsaWNlKCk7XG4gICAgICBzdWJqZWN0Lmxlbmd0aCA9IDA7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGMgPSBpbnB1dFsobSA9IGlucHV0Lmxlbmd0aCAtIGNsb3NlZCkgLSAxXTtcbiAgICAgIGogPSAtMTtcbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgIGQgPSBpbnB1dFtqXTtcbiAgICAgICAgaWYgKGQzX2dlb21fcG9seWdvbkluc2lkZShkLCBhLCBiKSkge1xuICAgICAgICAgIGlmICghZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGMsIGEsIGIpKSB7XG4gICAgICAgICAgICBzdWJqZWN0LnB1c2goZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3ViamVjdC5wdXNoKGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGQzX2dlb21fcG9seWdvbkluc2lkZShjLCBhLCBiKSkge1xuICAgICAgICAgIHN1YmplY3QucHVzaChkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikpO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBkO1xuICAgICAgfVxuICAgICAgaWYgKGNsb3NlZCkgc3ViamVjdC5wdXNoKHN1YmplY3RbMF0pO1xuICAgICAgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBzdWJqZWN0O1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25JbnNpZGUocCwgYSwgYikge1xuICAgIHJldHVybiAoYlswXSAtIGFbMF0pICogKHBbMV0gLSBhWzFdKSA8IChiWzFdIC0gYVsxXSkgKiAocFswXSAtIGFbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSB7XG4gICAgdmFyIHgxID0gY1swXSwgeDMgPSBhWzBdLCB4MjEgPSBkWzBdIC0geDEsIHg0MyA9IGJbMF0gLSB4MywgeTEgPSBjWzFdLCB5MyA9IGFbMV0sIHkyMSA9IGRbMV0gLSB5MSwgeTQzID0gYlsxXSAtIHkzLCB1YSA9ICh4NDMgKiAoeTEgLSB5MykgLSB5NDMgKiAoeDEgLSB4MykpIC8gKHk0MyAqIHgyMSAtIHg0MyAqIHkyMSk7XG4gICAgcmV0dXJuIFsgeDEgKyB1YSAqIHgyMSwgeTEgKyB1YSAqIHkyMSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkNsb3NlZChjb29yZGluYXRlcykge1xuICAgIHZhciBhID0gY29vcmRpbmF0ZXNbMF0sIGIgPSBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gIShhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSk7XG4gIH1cbiAgdmFyIGQzX2dlb21fdm9yb25vaUVkZ2VzLCBkM19nZW9tX3Zvcm9ub2lDZWxscywgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcywgZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sID0gW10sIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlLCBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLCBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sID0gW107XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUJlYWNoKCkge1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgICB0aGlzLmVkZ2UgPSB0aGlzLnNpdGUgPSB0aGlzLmNpcmNsZSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2goc2l0ZSkge1xuICAgIHZhciBiZWFjaCA9IGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbC5wb3AoKSB8fCBuZXcgZDNfZ2VvbV92b3Jvbm9pQmVhY2goKTtcbiAgICBiZWFjaC5zaXRlID0gc2l0ZTtcbiAgICByZXR1cm4gYmVhY2g7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2goYmVhY2gpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUoYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMucmVtb3ZlKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wucHVzaChiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKGJlYWNoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZW1vdmVCZWFjaChiZWFjaCkge1xuICAgIHZhciBjaXJjbGUgPSBiZWFjaC5jaXJjbGUsIHggPSBjaXJjbGUueCwgeSA9IGNpcmNsZS5jeSwgdmVydGV4ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9LCBwcmV2aW91cyA9IGJlYWNoLlAsIG5leHQgPSBiZWFjaC5OLCBkaXNhcHBlYXJpbmcgPSBbIGJlYWNoIF07XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2goYmVhY2gpO1xuICAgIHZhciBsQXJjID0gcHJldmlvdXM7XG4gICAgd2hpbGUgKGxBcmMuY2lyY2xlICYmIGFicyh4IC0gbEFyYy5jaXJjbGUueCkgPCDOtSAmJiBhYnMoeSAtIGxBcmMuY2lyY2xlLmN5KSA8IM61KSB7XG4gICAgICBwcmV2aW91cyA9IGxBcmMuUDtcbiAgICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2gobEFyYyk7XG4gICAgICBsQXJjID0gcHJldmlvdXM7XG4gICAgfVxuICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICB2YXIgckFyYyA9IG5leHQ7XG4gICAgd2hpbGUgKHJBcmMuY2lyY2xlICYmIGFicyh4IC0gckFyYy5jaXJjbGUueCkgPCDOtSAmJiBhYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IM61KSB7XG4gICAgICBuZXh0ID0gckFyYy5OO1xuICAgICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChyQXJjKTtcbiAgICAgIHJBcmMgPSBuZXh0O1xuICAgIH1cbiAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUockFyYyk7XG4gICAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCwgaUFyYztcbiAgICBmb3IgKGlBcmMgPSAxOyBpQXJjIDwgbkFyY3M7ICsraUFyYykge1xuICAgICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcbiAgICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxBcmMuc2l0ZSwgckFyYy5zaXRlLCB2ZXJ0ZXgpO1xuICAgIH1cbiAgICBsQXJjID0gZGlzYXBwZWFyaW5nWzBdO1xuICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbbkFyY3MgLSAxXTtcbiAgICByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgckFyYy5zaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQWRkQmVhY2goc2l0ZSkge1xuICAgIHZhciB4ID0gc2l0ZS54LCBkaXJlY3RyaXggPSBzaXRlLnksIGxBcmMsIHJBcmMsIGR4bCwgZHhyLCBub2RlID0gZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5fO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBkeGwgPSBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpIC0geDtcbiAgICAgIGlmIChkeGwgPiDOtSkgbm9kZSA9IG5vZGUuTDsgZWxzZSB7XG4gICAgICAgIGR4ciA9IHggLSBkM19nZW9tX3Zvcm9ub2lSaWdodEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KTtcbiAgICAgICAgaWYgKGR4ciA+IM61KSB7XG4gICAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLlI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGR4bCA+IC3OtSkge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICAgIHJBcmMgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZHhyID4gLc61KSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxBcmMgPSByQXJjID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld0FyYyA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKHNpdGUpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMuaW5zZXJ0KGxBcmMsIG5ld0FyYyk7XG4gICAgaWYgKCFsQXJjICYmICFyQXJjKSByZXR1cm47XG4gICAgaWYgKGxBcmMgPT09IHJBcmMpIHtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICAgIHJBcmMgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChsQXJjLnNpdGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5pbnNlcnQobmV3QXJjLCByQXJjKTtcbiAgICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFyQXJjKSB7XG4gICAgICBuZXdBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUockFyYyk7XG4gICAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLCBheCA9IGxTaXRlLngsIGF5ID0gbFNpdGUueSwgYnggPSBzaXRlLnggLSBheCwgYnkgPSBzaXRlLnkgLSBheSwgclNpdGUgPSByQXJjLnNpdGUsIGN4ID0gclNpdGUueCAtIGF4LCBjeSA9IHJTaXRlLnkgLSBheSwgZCA9IDIgKiAoYnggKiBjeSAtIGJ5ICogY3gpLCBoYiA9IGJ4ICogYnggKyBieSAqIGJ5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB2ZXJ0ZXggPSB7XG4gICAgICB4OiAoY3kgKiBoYiAtIGJ5ICogaGMpIC8gZCArIGF4LFxuICAgICAgeTogKGJ4ICogaGMgLSBjeCAqIGhiKSAvIGQgKyBheVxuICAgIH07XG4gICAgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KTtcbiAgICBuZXdBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobFNpdGUsIHNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gICAgdmFyIHNpdGUgPSBhcmMuc2l0ZSwgcmZvY3ggPSBzaXRlLngsIHJmb2N5ID0gc2l0ZS55LCBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG4gICAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG4gICAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgICBpZiAoIWxBcmMpIHJldHVybiAtSW5maW5pdHk7XG4gICAgc2l0ZSA9IGxBcmMuc2l0ZTtcbiAgICB2YXIgbGZvY3ggPSBzaXRlLngsIGxmb2N5ID0gc2l0ZS55LCBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuICAgIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcbiAgICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LCBhYnkyID0gMSAvIHBieTIgLSAxIC8gcGxieTIsIGIgPSBobCAvIHBsYnkyO1xuICAgIGlmIChhYnkyKSByZXR1cm4gKC1iICsgTWF0aC5zcXJ0KGIgKiBiIC0gMiAqIGFieTIgKiAoaGwgKiBobCAvICgtMiAqIHBsYnkyKSAtIGxmb2N5ICsgcGxieTIgLyAyICsgcmZvY3kgLSBwYnkyIC8gMikpKSAvIGFieTIgKyByZm9jeDtcbiAgICByZXR1cm4gKHJmb2N4ICsgbGZvY3gpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICB2YXIgckFyYyA9IGFyYy5OO1xuICAgIGlmIChyQXJjKSByZXR1cm4gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQockFyYywgZGlyZWN0cml4KTtcbiAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICAgIHJldHVybiBzaXRlLnkgPT09IGRpcmVjdHJpeCA/IHNpdGUueCA6IEluZmluaXR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNlbGwoc2l0ZSkge1xuICAgIHRoaXMuc2l0ZSA9IHNpdGU7XG4gICAgdGhpcy5lZGdlcyA9IFtdO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaUNlbGwucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFsZkVkZ2VzID0gdGhpcy5lZGdlcywgaUhhbGZFZGdlID0gaGFsZkVkZ2VzLmxlbmd0aCwgZWRnZTtcbiAgICB3aGlsZSAoaUhhbGZFZGdlLS0pIHtcbiAgICAgIGVkZ2UgPSBoYWxmRWRnZXNbaUhhbGZFZGdlXS5lZGdlO1xuICAgICAgaWYgKCFlZGdlLmIgfHwgIWVkZ2UuYSkgaGFsZkVkZ2VzLnNwbGljZShpSGFsZkVkZ2UsIDEpO1xuICAgIH1cbiAgICBoYWxmRWRnZXMuc29ydChkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKTtcbiAgICByZXR1cm4gaGFsZkVkZ2VzLmxlbmd0aDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2xvc2VDZWxscyhleHRlbnQpIHtcbiAgICB2YXIgeDAgPSBleHRlbnRbMF1bMF0sIHgxID0gZXh0ZW50WzFdWzBdLCB5MCA9IGV4dGVudFswXVsxXSwgeTEgPSBleHRlbnRbMV1bMV0sIHgyLCB5MiwgeDMsIHkzLCBjZWxscyA9IGQzX2dlb21fdm9yb25vaUNlbGxzLCBpQ2VsbCA9IGNlbGxzLmxlbmd0aCwgY2VsbCwgaUhhbGZFZGdlLCBoYWxmRWRnZXMsIG5IYWxmRWRnZXMsIHN0YXJ0LCBlbmQ7XG4gICAgd2hpbGUgKGlDZWxsLS0pIHtcbiAgICAgIGNlbGwgPSBjZWxsc1tpQ2VsbF07XG4gICAgICBpZiAoIWNlbGwgfHwgIWNlbGwucHJlcGFyZSgpKSBjb250aW51ZTtcbiAgICAgIGhhbGZFZGdlcyA9IGNlbGwuZWRnZXM7XG4gICAgICBuSGFsZkVkZ2VzID0gaGFsZkVkZ2VzLmxlbmd0aDtcbiAgICAgIGlIYWxmRWRnZSA9IDA7XG4gICAgICB3aGlsZSAoaUhhbGZFZGdlIDwgbkhhbGZFZGdlcykge1xuICAgICAgICBlbmQgPSBoYWxmRWRnZXNbaUhhbGZFZGdlXS5lbmQoKSwgeDMgPSBlbmQueCwgeTMgPSBlbmQueTtcbiAgICAgICAgc3RhcnQgPSBoYWxmRWRnZXNbKytpSGFsZkVkZ2UgJSBuSGFsZkVkZ2VzXS5zdGFydCgpLCB4MiA9IHN0YXJ0LngsIHkyID0gc3RhcnQueTtcbiAgICAgICAgaWYgKGFicyh4MyAtIHgyKSA+IM61IHx8IGFicyh5MyAtIHkyKSA+IM61KSB7XG4gICAgICAgICAgaGFsZkVkZ2VzLnNwbGljZShpSGFsZkVkZ2UsIDAsIG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShkM19nZW9tX3Zvcm9ub2lDcmVhdGVCb3JkZXJFZGdlKGNlbGwuc2l0ZSwgZW5kLCBhYnMoeDMgLSB4MCkgPCDOtSAmJiB5MSAtIHkzID4gzrUgPyB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGFicyh4MiAtIHgwKSA8IM61ID8geTIgOiB5MVxuICAgICAgICAgIH0gOiBhYnMoeTMgLSB5MSkgPCDOtSAmJiB4MSAtIHgzID4gzrUgPyB7XG4gICAgICAgICAgICB4OiBhYnMoeTIgLSB5MSkgPCDOtSA/IHgyIDogeDEsXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH0gOiBhYnMoeDMgLSB4MSkgPCDOtSAmJiB5MyAtIHkwID4gzrUgPyB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGFicyh4MiAtIHgxKSA8IM61ID8geTIgOiB5MFxuICAgICAgICAgIH0gOiBhYnMoeTMgLSB5MCkgPCDOtSAmJiB4MyAtIHgwID4gzrUgPyB7XG4gICAgICAgICAgICB4OiBhYnMoeTIgLSB5MCkgPCDOtSA/IHgyIDogeDAsXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH0gOiBudWxsKSwgY2VsbC5zaXRlLCBudWxsKSk7XG4gICAgICAgICAgKytuSGFsZkVkZ2VzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBiLmFuZ2xlIC0gYS5hbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDaXJjbGUoKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMuYXJjID0gdGhpcy5zaXRlID0gdGhpcy5jeSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGFyYykge1xuICAgIHZhciBsQXJjID0gYXJjLlAsIHJBcmMgPSBhcmMuTjtcbiAgICBpZiAoIWxBcmMgfHwgIXJBcmMpIHJldHVybjtcbiAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGNTaXRlID0gYXJjLnNpdGUsIHJTaXRlID0gckFyYy5zaXRlO1xuICAgIGlmIChsU2l0ZSA9PT0gclNpdGUpIHJldHVybjtcbiAgICB2YXIgYnggPSBjU2l0ZS54LCBieSA9IGNTaXRlLnksIGF4ID0gbFNpdGUueCAtIGJ4LCBheSA9IGxTaXRlLnkgLSBieSwgY3ggPSByU2l0ZS54IC0gYngsIGN5ID0gclNpdGUueSAtIGJ5O1xuICAgIHZhciBkID0gMiAqIChheCAqIGN5IC0gYXkgKiBjeCk7XG4gICAgaWYgKGQgPj0gLc61MikgcmV0dXJuO1xuICAgIHZhciBoYSA9IGF4ICogYXggKyBheSAqIGF5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB4ID0gKGN5ICogaGEgLSBheSAqIGhjKSAvIGQsIHkgPSAoYXggKiBoYyAtIGN4ICogaGEpIC8gZCwgY3kgPSB5ICsgYnk7XG4gICAgdmFyIGNpcmNsZSA9IGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wucG9wKCkgfHwgbmV3IGQzX2dlb21fdm9yb25vaUNpcmNsZSgpO1xuICAgIGNpcmNsZS5hcmMgPSBhcmM7XG4gICAgY2lyY2xlLnNpdGUgPSBjU2l0ZTtcbiAgICBjaXJjbGUueCA9IHggKyBieDtcbiAgICBjaXJjbGUueSA9IGN5ICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNpcmNsZS5jeSA9IGN5O1xuICAgIGFyYy5jaXJjbGUgPSBjaXJjbGU7XG4gICAgdmFyIGJlZm9yZSA9IG51bGwsIG5vZGUgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLl87XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCBjaXJjbGUueSA9PT0gbm9kZS55ICYmIGNpcmNsZS54IDw9IG5vZGUueCkge1xuICAgICAgICBpZiAobm9kZS5MKSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBub2RlLlA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLlIpIG5vZGUgPSBub2RlLlI7IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5pbnNlcnQoYmVmb3JlLCBjaXJjbGUpO1xuICAgIGlmICghYmVmb3JlKSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSA9IGNpcmNsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUoYXJjKSB7XG4gICAgdmFyIGNpcmNsZSA9IGFyYy5jaXJjbGU7XG4gICAgaWYgKGNpcmNsZSkge1xuICAgICAgaWYgKCFjaXJjbGUuUCkgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUgPSBjaXJjbGUuTjtcbiAgICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMucmVtb3ZlKGNpcmNsZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sLnB1c2goY2lyY2xlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShjaXJjbGUpO1xuICAgICAgYXJjLmNpcmNsZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNsaXBFZGdlcyhleHRlbnQpIHtcbiAgICB2YXIgZWRnZXMgPSBkM19nZW9tX3Zvcm9ub2lFZGdlcywgY2xpcCA9IGQzX2dlb21fY2xpcExpbmUoZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVswXSwgZXh0ZW50WzFdWzFdKSwgaSA9IGVkZ2VzLmxlbmd0aCwgZTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlID0gZWRnZXNbaV07XG4gICAgICBpZiAoIWQzX2dlb21fdm9yb25vaUNvbm5lY3RFZGdlKGUsIGV4dGVudCkgfHwgIWNsaXAoZSkgfHwgYWJzKGUuYS54IC0gZS5iLngpIDwgzrUgJiYgYWJzKGUuYS55IC0gZS5iLnkpIDwgzrUpIHtcbiAgICAgICAgZS5hID0gZS5iID0gbnVsbDtcbiAgICAgICAgZWRnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDb25uZWN0RWRnZShlZGdlLCBleHRlbnQpIHtcbiAgICB2YXIgdmIgPSBlZGdlLmI7XG4gICAgaWYgKHZiKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgdmEgPSBlZGdlLmEsIHgwID0gZXh0ZW50WzBdWzBdLCB4MSA9IGV4dGVudFsxXVswXSwgeTAgPSBleHRlbnRbMF1bMV0sIHkxID0gZXh0ZW50WzFdWzFdLCBsU2l0ZSA9IGVkZ2UubCwgclNpdGUgPSBlZGdlLnIsIGx4ID0gbFNpdGUueCwgbHkgPSBsU2l0ZS55LCByeCA9IHJTaXRlLngsIHJ5ID0gclNpdGUueSwgZnggPSAobHggKyByeCkgLyAyLCBmeSA9IChseSArIHJ5KSAvIDIsIGZtLCBmYjtcbiAgICBpZiAocnkgPT09IGx5KSB7XG4gICAgICBpZiAoZnggPCB4MCB8fCBmeCA+PSB4MSkgcmV0dXJuO1xuICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTBcbiAgICAgICAgfTsgZWxzZSBpZiAodmEueSA+PSB5MSkgcmV0dXJuO1xuICAgICAgICB2YiA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTFcbiAgICAgICAgfTsgZWxzZSBpZiAodmEueSA8IHkwKSByZXR1cm47XG4gICAgICAgIHZiID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZtID0gKGx4IC0gcngpIC8gKHJ5IC0gbHkpO1xuICAgICAgZmIgPSBmeSAtIGZtICogZng7XG4gICAgICBpZiAoZm0gPCAtMSB8fCBmbSA+IDEpIHtcbiAgICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6ICh5MCAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS55ID49IHkxKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiAoeTEgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6ICh5MSAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS55IDwgeTApIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6ICh5MCAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobHkgPCByeSkge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBmbSAqIHgwICsgZmJcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS54ID49IHgxKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGZtICogeDEgKyBmYlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGZtICogeDEgKyBmYlxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnggPCB4MCkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBmbSAqIHgwICsgZmJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVkZ2UuYSA9IHZhO1xuICAgIGVkZ2UuYiA9IHZiO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIHJTaXRlKSB7XG4gICAgdGhpcy5sID0gbFNpdGU7XG4gICAgdGhpcy5yID0gclNpdGU7XG4gICAgdGhpcy5hID0gdGhpcy5iID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxTaXRlLCByU2l0ZSwgdmEsIHZiKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgclNpdGUpO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgaWYgKHZhKSBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIGxTaXRlLCByU2l0ZSwgdmEpO1xuICAgIGlmICh2YikgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCByU2l0ZSwgbFNpdGUsIHZiKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tsU2l0ZS5pXS5lZGdlcy5wdXNoKG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCBsU2l0ZSwgclNpdGUpKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tyU2l0ZS5pXS5lZGdlcy5wdXNoKG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCByU2l0ZSwgbFNpdGUpKTtcbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCb3JkZXJFZGdlKGxTaXRlLCB2YSwgdmIpIHtcbiAgICB2YXIgZWRnZSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCBudWxsKTtcbiAgICBlZGdlLmEgPSB2YTtcbiAgICBlZGdlLmIgPSB2YjtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpIHtcbiAgICBpZiAoIWVkZ2UuYSAmJiAhZWRnZS5iKSB7XG4gICAgICBlZGdlLmEgPSB2ZXJ0ZXg7XG4gICAgICBlZGdlLmwgPSBsU2l0ZTtcbiAgICAgIGVkZ2UuciA9IHJTaXRlO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5sID09PSByU2l0ZSkge1xuICAgICAgZWRnZS5iID0gdmVydGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlLmEgPSB2ZXJ0ZXg7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIGxTaXRlLCByU2l0ZSkge1xuICAgIHZhciB2YSA9IGVkZ2UuYSwgdmIgPSBlZGdlLmI7XG4gICAgdGhpcy5lZGdlID0gZWRnZTtcbiAgICB0aGlzLnNpdGUgPSBsU2l0ZTtcbiAgICB0aGlzLmFuZ2xlID0gclNpdGUgPyBNYXRoLmF0YW4yKHJTaXRlLnkgLSBsU2l0ZS55LCByU2l0ZS54IC0gbFNpdGUueCkgOiBlZGdlLmwgPT09IGxTaXRlID8gTWF0aC5hdGFuMih2Yi54IC0gdmEueCwgdmEueSAtIHZiLnkpIDogTWF0aC5hdGFuMih2YS54IC0gdmIueCwgdmIueSAtIHZhLnkpO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlLnByb3RvdHlwZSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlLmwgPT09IHRoaXMuc2l0ZSA/IHRoaXMuZWRnZS5hIDogdGhpcy5lZGdlLmI7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZS5sID09PSB0aGlzLnNpdGUgPyB0aGlzLmVkZ2UuYiA6IHRoaXMuZWRnZS5hO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCkge1xuICAgIHRoaXMuXyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKG5vZGUpIHtcbiAgICBub2RlLlUgPSBub2RlLkMgPSBub2RlLkwgPSBub2RlLlIgPSBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZS5wcm90b3R5cGUgPSB7XG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhZnRlciwgbm9kZSkge1xuICAgICAgdmFyIHBhcmVudCwgZ3JhbmRwYSwgdW5jbGU7XG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgbm9kZS5QID0gYWZ0ZXI7XG4gICAgICAgIG5vZGUuTiA9IGFmdGVyLk47XG4gICAgICAgIGlmIChhZnRlci5OKSBhZnRlci5OLlAgPSBub2RlO1xuICAgICAgICBhZnRlci5OID0gbm9kZTtcbiAgICAgICAgaWYgKGFmdGVyLlIpIHtcbiAgICAgICAgICBhZnRlciA9IGFmdGVyLlI7XG4gICAgICAgICAgd2hpbGUgKGFmdGVyLkwpIGFmdGVyID0gYWZ0ZXIuTDtcbiAgICAgICAgICBhZnRlci5MID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZnRlci5SID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fKSB7XG4gICAgICAgIGFmdGVyID0gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdCh0aGlzLl8pO1xuICAgICAgICBub2RlLlAgPSBudWxsO1xuICAgICAgICBub2RlLk4gPSBhZnRlcjtcbiAgICAgICAgYWZ0ZXIuUCA9IGFmdGVyLkwgPSBub2RlO1xuICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gICAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLkwgPSBub2RlLlIgPSBudWxsO1xuICAgICAgbm9kZS5VID0gcGFyZW50O1xuICAgICAgbm9kZS5DID0gdHJ1ZTtcbiAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LkMpIHtcbiAgICAgICAgZ3JhbmRwYSA9IHBhcmVudC5VO1xuICAgICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcbiAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcbiAgICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5jbGUgPSBncmFuZHBhLkw7XG4gICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICB9XG4gICAgICB0aGlzLl8uQyA9IGZhbHNlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5OKSBub2RlLk4uUCA9IG5vZGUuUDtcbiAgICAgIGlmIChub2RlLlApIG5vZGUuUC5OID0gbm9kZS5OO1xuICAgICAgbm9kZS5OID0gbm9kZS5QID0gbnVsbDtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLlUsIHNpYmxpbmcsIGxlZnQgPSBub2RlLkwsIHJpZ2h0ID0gbm9kZS5SLCBuZXh0LCByZWQ7XG4gICAgICBpZiAoIWxlZnQpIG5leHQgPSByaWdodDsgZWxzZSBpZiAoIXJpZ2h0KSBuZXh0ID0gbGVmdDsgZWxzZSBuZXh0ID0gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdChyaWdodCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuTCA9PT0gbm9kZSkgcGFyZW50LkwgPSBuZXh0OyBlbHNlIHBhcmVudC5SID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuXyA9IG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICByZWQgPSBuZXh0LkM7XG4gICAgICAgIG5leHQuQyA9IG5vZGUuQztcbiAgICAgICAgbmV4dC5MID0gbGVmdDtcbiAgICAgICAgbGVmdC5VID0gbmV4dDtcbiAgICAgICAgaWYgKG5leHQgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgcGFyZW50ID0gbmV4dC5VO1xuICAgICAgICAgIG5leHQuVSA9IG5vZGUuVTtcbiAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICAgIHBhcmVudC5MID0gbm9kZTtcbiAgICAgICAgICBuZXh0LlIgPSByaWdodDtcbiAgICAgICAgICByaWdodC5VID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0LlUgPSBwYXJlbnQ7XG4gICAgICAgICAgcGFyZW50ID0gbmV4dDtcbiAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWQgPSBub2RlLkM7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUpIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgIGlmIChyZWQpIHJldHVybjtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuQykge1xuICAgICAgICBub2RlLkMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKSBicmVhaztcbiAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMgfHwgc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcuUiB8fCAhc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgICAgc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2libGluZy5MICYmIHNpYmxpbmcuTC5DIHx8IHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5VO1xuICAgICAgfSB3aGlsZSAoIW5vZGUuQyk7XG4gICAgICBpZiAobm9kZSkgbm9kZS5DID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodHJlZSwgbm9kZSkge1xuICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuUiwgcGFyZW50ID0gcC5VO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxOyBlbHNlIHBhcmVudC5SID0gcTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZS5fID0gcTtcbiAgICB9XG4gICAgcS5VID0gcGFyZW50O1xuICAgIHAuVSA9IHE7XG4gICAgcC5SID0gcS5MO1xuICAgIGlmIChwLlIpIHAuUi5VID0gcDtcbiAgICBxLkwgPSBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xuICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuTCwgcGFyZW50ID0gcC5VO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxOyBlbHNlIHBhcmVudC5SID0gcTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZS5fID0gcTtcbiAgICB9XG4gICAgcS5VID0gcGFyZW50O1xuICAgIHAuVSA9IHE7XG4gICAgcC5MID0gcS5SO1xuICAgIGlmIChwLkwpIHAuTC5VID0gcDtcbiAgICBxLlIgPSBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pKHNpdGVzLCBiYm94KSB7XG4gICAgdmFyIHNpdGUgPSBzaXRlcy5zb3J0KGQzX2dlb21fdm9yb25vaVZlcnRleE9yZGVyKS5wb3AoKSwgeDAsIHkwLCBjaXJjbGU7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMgPSBbXTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxscyA9IG5ldyBBcnJheShzaXRlcy5sZW5ndGgpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcyA9IG5ldyBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY2lyY2xlID0gZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGU7XG4gICAgICBpZiAoc2l0ZSAmJiAoIWNpcmNsZSB8fCBzaXRlLnkgPCBjaXJjbGUueSB8fCBzaXRlLnkgPT09IGNpcmNsZS55ICYmIHNpdGUueCA8IGNpcmNsZS54KSkge1xuICAgICAgICBpZiAoc2l0ZS54ICE9PSB4MCB8fCBzaXRlLnkgIT09IHkwKSB7XG4gICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbc2l0ZS5pXSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lDZWxsKHNpdGUpO1xuICAgICAgICAgIGQzX2dlb21fdm9yb25vaUFkZEJlYWNoKHNpdGUpO1xuICAgICAgICAgIHgwID0gc2l0ZS54LCB5MCA9IHNpdGUueTtcbiAgICAgICAgfVxuICAgICAgICBzaXRlID0gc2l0ZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKGNpcmNsZSkge1xuICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZW1vdmVCZWFjaChjaXJjbGUuYXJjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmJveCkgZDNfZ2VvbV92b3Jvbm9pQ2xpcEVkZ2VzKGJib3gpLCBkM19nZW9tX3Zvcm9ub2lDbG9zZUNlbGxzKGJib3gpO1xuICAgIHZhciBkaWFncmFtID0ge1xuICAgICAgY2VsbHM6IGQzX2dlb21fdm9yb25vaUNlbGxzLFxuICAgICAgZWRnZXM6IGQzX2dlb21fdm9yb25vaUVkZ2VzXG4gICAgfTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcyA9IGQzX2dlb21fdm9yb25vaUVkZ2VzID0gZDNfZ2VvbV92b3Jvbm9pQ2VsbHMgPSBudWxsO1xuICAgIHJldHVybiBkaWFncmFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVZlcnRleE9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYi55IC0gYS55IHx8IGIueCAtIGEueDtcbiAgfVxuICBkMy5nZW9tLnZvcm9ub2kgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGZ4ID0geCwgZnkgPSB5LCBjbGlwRXh0ZW50ID0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudDtcbiAgICBpZiAocG9pbnRzKSByZXR1cm4gdm9yb25vaShwb2ludHMpO1xuICAgIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xuICAgICAgdmFyIHBvbHlnb25zID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKSwgeDAgPSBjbGlwRXh0ZW50WzBdWzBdLCB5MCA9IGNsaXBFeHRlbnRbMF1bMV0sIHgxID0gY2xpcEV4dGVudFsxXVswXSwgeTEgPSBjbGlwRXh0ZW50WzFdWzFdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpLCBjbGlwRXh0ZW50KS5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gY2VsbC5lZGdlcywgc2l0ZSA9IGNlbGwuc2l0ZSwgcG9seWdvbiA9IHBvbHlnb25zW2ldID0gZWRnZXMubGVuZ3RoID8gZWRnZXMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcyA9IGUuc3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gWyBzLngsIHMueSBdO1xuICAgICAgICB9KSA6IHNpdGUueCA+PSB4MCAmJiBzaXRlLnggPD0geDEgJiYgc2l0ZS55ID49IHkwICYmIHNpdGUueSA8PSB5MSA/IFsgWyB4MCwgeTEgXSwgWyB4MSwgeTEgXSwgWyB4MSwgeTAgXSwgWyB4MCwgeTAgXSBdIDogW107XG4gICAgICAgIHBvbHlnb24ucG9pbnQgPSBkYXRhW2ldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpdGVzKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZChmeChkLCBpKSAvIM61KSAqIM61LFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoZnkoZCwgaSkgLyDOtSkgKiDOtSxcbiAgICAgICAgICBpOiBpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgdm9yb25vaS5saW5rcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSkpLmVkZ2VzLmZpbHRlcihmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmwgJiYgZWRnZS5yO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IGRhdGFbZWRnZS5sLmldLFxuICAgICAgICAgIHRhcmdldDogZGF0YVtlZGdlLnIuaV1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgdHJpYW5nbGVzID0gW107XG4gICAgICBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSkpLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSwgZWRnZXMgPSBjZWxsLmVkZ2VzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlciksIGogPSAtMSwgbSA9IGVkZ2VzLmxlbmd0aCwgZTAsIHMwLCBlMSA9IGVkZ2VzW20gLSAxXS5lZGdlLCBzMSA9IGUxLmwgPT09IHNpdGUgPyBlMS5yIDogZTEubDtcbiAgICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgICBlMCA9IGUxO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgZTEgPSBlZGdlc1tqXS5lZGdlO1xuICAgICAgICAgIHMxID0gZTEubCA9PT0gc2l0ZSA/IGUxLnIgOiBlMS5sO1xuICAgICAgICAgIGlmIChpIDwgczAuaSAmJiBpIDwgczEuaSAmJiBkM19nZW9tX3Zvcm9ub2lUcmlhbmdsZUFyZWEoc2l0ZSwgczAsIHMxKSA8IDApIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKFsgZGF0YVtpXSwgZGF0YVtzMC5pXSwgZGF0YVtzMS5pXSBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgICB9O1xuICAgIHZvcm9ub2kueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZ4ID0gZDNfZnVuY3Rvcih4ID0gXyksIHZvcm9ub2kpIDogeDtcbiAgICB9O1xuICAgIHZvcm9ub2kueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZ5ID0gZDNfZnVuY3Rvcih5ID0gXyksIHZvcm9ub2kpIDogeTtcbiAgICB9O1xuICAgIHZvcm9ub2kuY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQgPT09IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPyBudWxsIDogY2xpcEV4dGVudDtcbiAgICAgIGNsaXBFeHRlbnQgPSBfID09IG51bGwgPyBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50IDogXztcbiAgICAgIHJldHVybiB2b3Jvbm9pO1xuICAgIH07XG4gICAgdm9yb25vaS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudCA9PT0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA/IG51bGwgOiBjbGlwRXh0ZW50ICYmIGNsaXBFeHRlbnRbMV07XG4gICAgICByZXR1cm4gdm9yb25vaS5jbGlwRXh0ZW50KF8gJiYgWyBbIDAsIDAgXSwgXyBdKTtcbiAgICB9O1xuICAgIHJldHVybiB2b3Jvbm9pO1xuICB9O1xuICB2YXIgZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA9IFsgWyAtMWU2LCAtMWU2IF0sIFsgMWU2LCAxZTYgXSBdO1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lUcmlhbmdsZUFyZWEoYSwgYiwgYykge1xuICAgIHJldHVybiAoYS54IC0gYy54KSAqIChiLnkgLSBhLnkpIC0gKGEueCAtIGIueCkgKiAoYy55IC0gYS55KTtcbiAgfVxuICBkMy5nZW9tLmRlbGF1bmF5ID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICByZXR1cm4gZDMuZ2VvbS52b3Jvbm9pKCkudHJpYW5nbGVzKHZlcnRpY2VzKTtcbiAgfTtcbiAgZDMuZ2VvbS5xdWFkdHJlZSA9IGZ1bmN0aW9uKHBvaW50cywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGNvbXBhdDtcbiAgICBpZiAoY29tcGF0ID0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeCA9IGQzX2dlb21fcXVhZHRyZWVDb21wYXRYO1xuICAgICAgeSA9IGQzX2dlb21fcXVhZHRyZWVDb21wYXRZO1xuICAgICAgaWYgKGNvbXBhdCA9PT0gMykge1xuICAgICAgICB5MiA9IHkxO1xuICAgICAgICB4MiA9IHgxO1xuICAgICAgICB5MSA9IHgxID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWFkdHJlZShwb2ludHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWFkdHJlZShkYXRhKSB7XG4gICAgICB2YXIgZCwgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSksIHhzLCB5cywgaSwgbiwgeDFfLCB5MV8sIHgyXywgeTJfO1xuICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgeDFfID0geDEsIHkxXyA9IHkxLCB4Ml8gPSB4MiwgeTJfID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4Ml8gPSB5Ml8gPSAtKHgxXyA9IHkxXyA9IEluZmluaXR5KTtcbiAgICAgICAgeHMgPSBbXSwgeXMgPSBbXTtcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoY29tcGF0KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgaWYgKGQueCA8IHgxXykgeDFfID0gZC54O1xuICAgICAgICAgIGlmIChkLnkgPCB5MV8pIHkxXyA9IGQueTtcbiAgICAgICAgICBpZiAoZC54ID4geDJfKSB4Ml8gPSBkLng7XG4gICAgICAgICAgaWYgKGQueSA+IHkyXykgeTJfID0gZC55O1xuICAgICAgICAgIHhzLnB1c2goZC54KTtcbiAgICAgICAgICB5cy5wdXNoKGQueSk7XG4gICAgICAgIH0gZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgdmFyIHhfID0gK2Z4KGQgPSBkYXRhW2ldLCBpKSwgeV8gPSArZnkoZCwgaSk7XG4gICAgICAgICAgaWYgKHhfIDwgeDFfKSB4MV8gPSB4XztcbiAgICAgICAgICBpZiAoeV8gPCB5MV8pIHkxXyA9IHlfO1xuICAgICAgICAgIGlmICh4XyA+IHgyXykgeDJfID0geF87XG4gICAgICAgICAgaWYgKHlfID4geTJfKSB5Ml8gPSB5XztcbiAgICAgICAgICB4cy5wdXNoKHhfKTtcbiAgICAgICAgICB5cy5wdXNoKHlfKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGR4ID0geDJfIC0geDFfLCBkeSA9IHkyXyAtIHkxXztcbiAgICAgIGlmIChkeCA+IGR5KSB5Ml8gPSB5MV8gKyBkeDsgZWxzZSB4Ml8gPSB4MV8gKyBkeTtcbiAgICAgIGZ1bmN0aW9uIGluc2VydChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybjtcbiAgICAgICAgaWYgKG4ubGVhZikge1xuICAgICAgICAgIHZhciBueCA9IG4ueCwgbnkgPSBuLnk7XG4gICAgICAgICAgaWYgKG54ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChhYnMobnggLSB4KSArIGFicyhueSAtIHkpIDwgLjAxKSB7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBuUG9pbnQgPSBuLnBvaW50O1xuICAgICAgICAgICAgICBuLnggPSBuLnkgPSBuLnBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgblBvaW50LCBueCwgbnksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnggPSB4LCBuLnkgPSB5LCBuLnBvaW50ID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW0sIGkgPSBiZWxvdyA8PCAxIHwgcmlnaHQ7XG4gICAgICAgIG4ubGVhZiA9IGZhbHNlO1xuICAgICAgICBuID0gbi5ub2Rlc1tpXSB8fCAobi5ub2Rlc1tpXSA9IGQzX2dlb21fcXVhZHRyZWVOb2RlKCkpO1xuICAgICAgICBpZiAocmlnaHQpIHgxID0geG07IGVsc2UgeDIgPSB4bTtcbiAgICAgICAgaWYgKGJlbG93KSB5MSA9IHltOyBlbHNlIHkyID0geW07XG4gICAgICAgIGluc2VydChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICB9XG4gICAgICB2YXIgcm9vdCA9IGQzX2dlb21fcXVhZHRyZWVOb2RlKCk7XG4gICAgICByb290LmFkZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaW5zZXJ0KHJvb3QsIGQsICtmeChkLCArK2kpLCArZnkoZCwgaSksIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgcm9vdC52aXNpdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIHJvb3QsIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgcm9vdC5maW5kID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGQzX2dlb21fcXVhZHRyZWVGaW5kKHJvb3QsIHBvaW50WzBdLCBwb2ludFsxXSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICBpID0gLTE7XG4gICAgICBpZiAoeDEgPT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGluc2VydChyb290LCBkYXRhW2ldLCB4c1tpXSwgeXNbaV0sIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICAgIH1cbiAgICAgICAgLS1pO1xuICAgICAgfSBlbHNlIGRhdGEuZm9yRWFjaChyb290LmFkZCk7XG4gICAgICB4cyA9IHlzID0gZGF0YSA9IGQgPSBudWxsO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHF1YWR0cmVlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXywgcXVhZHRyZWUpIDogeDtcbiAgICB9O1xuICAgIHF1YWR0cmVlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gXywgcXVhZHRyZWUpIDogeTtcbiAgICB9O1xuICAgIHF1YWR0cmVlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxID09IG51bGwgPyBudWxsIDogWyBbIHgxLCB5MSBdLCBbIHgyLCB5MiBdIF07XG4gICAgICBpZiAoXyA9PSBudWxsKSB4MSA9IHkxID0geDIgPSB5MiA9IG51bGw7IGVsc2UgeDEgPSArX1swXVswXSwgeTEgPSArX1swXVsxXSwgeDIgPSArX1sxXVswXSwgXG4gICAgICB5MiA9ICtfWzFdWzFdO1xuICAgICAgcmV0dXJuIHF1YWR0cmVlO1xuICAgIH07XG4gICAgcXVhZHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxID09IG51bGwgPyBudWxsIDogWyB4MiAtIHgxLCB5MiAtIHkxIF07XG4gICAgICBpZiAoXyA9PSBudWxsKSB4MSA9IHkxID0geDIgPSB5MiA9IG51bGw7IGVsc2UgeDEgPSB5MSA9IDAsIHgyID0gK19bMF0sIHkyID0gK19bMV07XG4gICAgICByZXR1cm4gcXVhZHRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gcXVhZHRyZWU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVDb21wYXRYKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVDb21wYXRZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVOb2RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWFmOiB0cnVlLFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgcG9pbnQ6IG51bGwsXG4gICAgICB4OiBudWxsLFxuICAgICAgeTogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIG5vZGUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKCFmKG5vZGUsIHgxLCB5MSwgeDIsIHkyKSkge1xuICAgICAgdmFyIHN4ID0gKHgxICsgeDIpICogLjUsIHN5ID0gKHkxICsgeTIpICogLjUsIGNoaWxkcmVuID0gbm9kZS5ub2RlcztcbiAgICAgIGlmIChjaGlsZHJlblswXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzBdLCB4MSwgeTEsIHN4LCBzeSk7XG4gICAgICBpZiAoY2hpbGRyZW5bMV0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblsxXSwgc3gsIHkxLCB4Miwgc3kpO1xuICAgICAgaWYgKGNoaWxkcmVuWzJdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMl0sIHgxLCBzeSwgc3gsIHkyKTtcbiAgICAgIGlmIChjaGlsZHJlblszXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzNdLCBzeCwgc3ksIHgyLCB5Mik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVGaW5kKHJvb3QsIHgsIHksIHgwLCB5MCwgeDMsIHkzKSB7XG4gICAgdmFyIG1pbkRpc3RhbmNlMiA9IEluZmluaXR5LCBjbG9zZXN0UG9pbnQ7XG4gICAgKGZ1bmN0aW9uIGZpbmQobm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGlmICh4MSA+IHgzIHx8IHkxID4geTMgfHwgeDIgPCB4MCB8fCB5MiA8IHkwKSByZXR1cm47XG4gICAgICBpZiAocG9pbnQgPSBub2RlLnBvaW50KSB7XG4gICAgICAgIHZhciBwb2ludCwgZHggPSB4IC0gbm9kZS54LCBkeSA9IHkgLSBub2RlLnksIGRpc3RhbmNlMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZGlzdGFuY2UyIDwgbWluRGlzdGFuY2UyKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlMiA9IGRpc3RhbmNlMik7XG4gICAgICAgICAgeDAgPSB4IC0gZGlzdGFuY2UsIHkwID0geSAtIGRpc3RhbmNlO1xuICAgICAgICAgIHgzID0geCArIGRpc3RhbmNlLCB5MyA9IHkgKyBkaXN0YW5jZTtcbiAgICAgICAgICBjbG9zZXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5ub2RlcywgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW07XG4gICAgICBmb3IgKHZhciBpID0gYmVsb3cgPDwgMSB8IHJpZ2h0LCBqID0gaSArIDQ7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBjaGlsZHJlbltpICYgM10pIHN3aXRjaCAoaSAmIDMpIHtcbiAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBmaW5kKG5vZGUsIHgxLCB5MSwgeG0sIHltKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGZpbmQobm9kZSwgeG0sIHkxLCB4MiwgeW0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZmluZChub2RlLCB4MSwgeW0sIHhtLCB5Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5bSwgeDIsIHkyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKHJvb3QsIHgwLCB5MCwgeDMsIHkzKTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xuICB9XG4gIGQzLmludGVycG9sYXRlUmdiID0gZDNfaW50ZXJwb2xhdGVSZ2I7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUmdiKGEsIGIpIHtcbiAgICBhID0gZDMucmdiKGEpO1xuICAgIGIgPSBkMy5yZ2IoYik7XG4gICAgdmFyIGFyID0gYS5yLCBhZyA9IGEuZywgYWIgPSBhLmIsIGJyID0gYi5yIC0gYXIsIGJnID0gYi5nIC0gYWcsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhciArIGJyICogdCkpICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFnICsgYmcgKiB0KSkgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYWIgKyBiYiAqIHQpKTtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlT2JqZWN0ID0gZDNfaW50ZXJwb2xhdGVPYmplY3Q7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlT2JqZWN0KGEsIGIpIHtcbiAgICB2YXIgaSA9IHt9LCBjID0ge30sIGs7XG4gICAgZm9yIChrIGluIGEpIHtcbiAgICAgIGlmIChrIGluIGIpIHtcbiAgICAgICAgaVtrXSA9IGQzX2ludGVycG9sYXRlKGFba10sIGJba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY1trXSA9IGFba107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayBpbiBiKSB7XG4gICAgICBpZiAoIShrIGluIGEpKSB7XG4gICAgICAgIGNba10gPSBiW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZU51bWJlciA9IGQzX2ludGVycG9sYXRlTnVtYmVyO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gICAgYSA9ICthLCBiID0gK2I7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVTdHJpbmcgPSBkM19pbnRlcnBvbGF0ZVN0cmluZztcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTdHJpbmcoYSwgYikge1xuICAgIHZhciBiaSA9IGQzX2ludGVycG9sYXRlX251bWJlckEubGFzdEluZGV4ID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXggPSAwLCBhbSwgYm0sIGJzLCBpID0gLTEsIHMgPSBbXSwgcSA9IFtdO1xuICAgIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuICAgIHdoaWxlICgoYW0gPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJBLmV4ZWMoYSkpICYmIChibSA9IGQzX2ludGVycG9sYXRlX251bWJlckIuZXhlYyhiKSkpIHtcbiAgICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkge1xuICAgICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgICB9XG4gICAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IGVsc2Ugc1srK2ldID0gYm07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzWysraV0gPSBudWxsO1xuICAgICAgICBxLnB1c2goe1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoYW0sIGJtKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJpID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIHJldHVybiBzLmxlbmd0aCA8IDIgPyBxWzBdID8gKGIgPSBxWzBdLngsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgICB9KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIHZhciBkM19pbnRlcnBvbGF0ZV9udW1iZXJBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLCBkM19pbnRlcnBvbGF0ZV9udW1iZXJCID0gbmV3IFJlZ0V4cChkM19pbnRlcnBvbGF0ZV9udW1iZXJBLnNvdXJjZSwgXCJnXCIpO1xuICBkMy5pbnRlcnBvbGF0ZSA9IGQzX2ludGVycG9sYXRlO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0b3JzLmxlbmd0aCwgZjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgIShmID0gZDMuaW50ZXJwb2xhdG9yc1tpXShhLCBiKSkpIDtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBkMy5pbnRlcnBvbGF0b3JzID0gWyBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgYjtcbiAgICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBkM19yZ2JfbmFtZXMuaGFzKGIudG9Mb3dlckNhc2UoKSkgfHwgL14oI3xyZ2JcXCh8aHNsXFwoKS9pLnRlc3QoYikgPyBkM19pbnRlcnBvbGF0ZVJnYiA6IGQzX2ludGVycG9sYXRlU3RyaW5nIDogYiBpbnN0YW5jZW9mIGQzX2NvbG9yID8gZDNfaW50ZXJwb2xhdGVSZ2IgOiBBcnJheS5pc0FycmF5KGIpID8gZDNfaW50ZXJwb2xhdGVBcnJheSA6IHQgPT09IFwib2JqZWN0XCIgJiYgaXNOYU4oYikgPyBkM19pbnRlcnBvbGF0ZU9iamVjdCA6IGQzX2ludGVycG9sYXRlTnVtYmVyKShhLCBiKTtcbiAgfSBdO1xuICBkMy5pbnRlcnBvbGF0ZUFycmF5ID0gZDNfaW50ZXJwb2xhdGVBcnJheTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVBcnJheShhLCBiKSB7XG4gICAgdmFyIHggPSBbXSwgYyA9IFtdLCBuYSA9IGEubGVuZ3RoLCBuYiA9IGIubGVuZ3RoLCBuMCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIHgucHVzaChkM19pbnRlcnBvbGF0ZShhW2ldLCBiW2ldKSk7XG4gICAgZm9yICg7aSA8IG5hOyArK2kpIGNbaV0gPSBhW2ldO1xuICAgIGZvciAoO2kgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZWFzZV9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2lkZW50aXR5O1xuICB9O1xuICB2YXIgZDNfZWFzZSA9IGQzLm1hcCh7XG4gICAgbGluZWFyOiBkM19lYXNlX2RlZmF1bHQsXG4gICAgcG9seTogZDNfZWFzZV9wb2x5LFxuICAgIHF1YWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfcXVhZDtcbiAgICB9LFxuICAgIGN1YmljOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2N1YmljO1xuICAgIH0sXG4gICAgc2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3NpbjtcbiAgICB9LFxuICAgIGV4cDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9leHA7XG4gICAgfSxcbiAgICBjaXJjbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfY2lyY2xlO1xuICAgIH0sXG4gICAgZWxhc3RpYzogZDNfZWFzZV9lbGFzdGljLFxuICAgIGJhY2s6IGQzX2Vhc2VfYmFjayxcbiAgICBib3VuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfYm91bmNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBkM19lYXNlX21vZGUgPSBkMy5tYXAoe1xuICAgIFwiaW5cIjogZDNfaWRlbnRpdHksXG4gICAgb3V0OiBkM19lYXNlX3JldmVyc2UsXG4gICAgXCJpbi1vdXRcIjogZDNfZWFzZV9yZWZsZWN0LFxuICAgIFwib3V0LWluXCI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3JlZmxlY3QoZDNfZWFzZV9yZXZlcnNlKGYpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5lYXNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLVwiKSwgdCA9IGkgPj0gMCA/IG5hbWUuc2xpY2UoMCwgaSkgOiBuYW1lLCBtID0gaSA+PSAwID8gbmFtZS5zbGljZShpICsgMSkgOiBcImluXCI7XG4gICAgdCA9IGQzX2Vhc2UuZ2V0KHQpIHx8IGQzX2Vhc2VfZGVmYXVsdDtcbiAgICBtID0gZDNfZWFzZV9tb2RlLmdldChtKSB8fCBkM19pZGVudGl0eTtcbiAgICByZXR1cm4gZDNfZWFzZV9jbGFtcChtKHQuYXBwbHkobnVsbCwgZDNfYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY2xhbXAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCA8PSAwID8gMCA6IHQgPj0gMSA/IDEgOiBmKHQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9yZXZlcnNlKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIDEgLSBmKDEgLSB0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcmVmbGVjdChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAuNSAqICh0IDwgLjUgPyBmKDIgKiB0KSA6IDIgLSBmKDIgLSAyICogdCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9xdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2N1YmljSW5PdXQodCkge1xuICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuICAgIGlmICh0ID49IDEpIHJldHVybiAxO1xuICAgIHZhciB0MiA9IHQgKiB0LCB0MyA9IHQyICogdDtcbiAgICByZXR1cm4gNCAqICh0IDwgLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gLjc1KTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3BvbHkoZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3Npbih0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZs+AKTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2V4cCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jaXJjbGUodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9lbGFzdGljKGEsIHApIHtcbiAgICB2YXIgcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHAgPSAuNDU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHMgPSBwIC8gz4QgKiBNYXRoLmFzaW4oMSAvIGEpOyBlbHNlIGEgPSAxLCBzID0gcCAvIDQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAxICsgYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIM+EIC8gcCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2JhY2socykge1xuICAgIGlmICghcykgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9ib3VuY2UodCkge1xuICAgIHJldHVybiB0IDwgMSAvIDIuNzUgPyA3LjU2MjUgKiB0ICogdCA6IHQgPCAyIC8gMi43NSA/IDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIC43NSA6IHQgPCAyLjUgLyAyLjc1ID8gNy41NjI1ICogKHQgLT0gMi4yNSAvIDIuNzUpICogdCArIC45Mzc1IDogNy41NjI1ICogKHQgLT0gMi42MjUgLyAyLjc1KSAqIHQgKyAuOTg0Mzc1O1xuICB9XG4gIGQzLmludGVycG9sYXRlSGNsID0gZDNfaW50ZXJwb2xhdGVIY2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSGNsKGEsIGIpIHtcbiAgICBhID0gZDMuaGNsKGEpO1xuICAgIGIgPSBkMy5oY2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhYyA9IGEuYywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJjID0gYi5jIC0gYWMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJjKSkgYmMgPSAwLCBhYyA9IGlzTmFOKGFjKSA/IGIuYyA6IGFjO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oY2xfbGFiKGFoICsgYmggKiB0LCBhYyArIGJjICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlSHNsID0gZDNfaW50ZXJwb2xhdGVIc2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSHNsKGEsIGIpIHtcbiAgICBhID0gZDMuaHNsKGEpO1xuICAgIGIgPSBkMy5oc2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhcyA9IGEucywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJzID0gYi5zIC0gYXMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJzKSkgYnMgPSAwLCBhcyA9IGlzTmFOKGFzKSA/IGIucyA6IGFzO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oc2xfcmdiKGFoICsgYmggKiB0LCBhcyArIGJzICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlTGFiID0gZDNfaW50ZXJwb2xhdGVMYWI7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlTGFiKGEsIGIpIHtcbiAgICBhID0gZDMubGFiKGEpO1xuICAgIGIgPSBkMy5sYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLCBhYSA9IGEuYSwgYWIgPSBhLmIsIGJsID0gYi5sIC0gYWwsIGJhID0gYi5hIC0gYWEsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19sYWJfcmdiKGFsICsgYmwgKiB0LCBhYSArIGJhICogdCwgYWIgKyBiYiAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlUm91bmQgPSBkM19pbnRlcnBvbGF0ZVJvdW5kO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdW5kKGEsIGIpIHtcbiAgICBiIC09IGE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gICAgfTtcbiAgfVxuICBkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZyA9IGQzX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhkMy5ucy5wcmVmaXguc3ZnLCBcImdcIik7XG4gICAgcmV0dXJuIChkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdHJpbmcpO1xuICAgICAgICB2YXIgdCA9IGcudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZDNfdHJhbnNmb3JtKHQgPyB0Lm1hdHJpeCA6IGQzX3RyYW5zZm9ybUlkZW50aXR5KTtcbiAgICB9KShzdHJpbmcpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2Zvcm0obSkge1xuICAgIHZhciByMCA9IFsgbS5hLCBtLmIgXSwgcjEgPSBbIG0uYywgbS5kIF0sIGt4ID0gZDNfdHJhbnNmb3JtTm9ybWFsaXplKHIwKSwga3ogPSBkM190cmFuc2Zvcm1Eb3QocjAsIHIxKSwga3kgPSBkM190cmFuc2Zvcm1Ob3JtYWxpemUoZDNfdHJhbnNmb3JtQ29tYmluZShyMSwgcjAsIC1reikpIHx8IDA7XG4gICAgaWYgKHIwWzBdICogcjFbMV0gPCByMVswXSAqIHIwWzFdKSB7XG4gICAgICByMFswXSAqPSAtMTtcbiAgICAgIHIwWzFdICo9IC0xO1xuICAgICAga3ggKj0gLTE7XG4gICAgICBreiAqPSAtMTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGUgPSAoa3ggPyBNYXRoLmF0YW4yKHIwWzFdLCByMFswXSkgOiBNYXRoLmF0YW4yKC1yMVswXSwgcjFbMV0pKSAqIGQzX2RlZ3JlZXM7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBbIG0uZSwgbS5mIF07XG4gICAgdGhpcy5zY2FsZSA9IFsga3gsIGt5IF07XG4gICAgdGhpcy5za2V3ID0ga3kgPyBNYXRoLmF0YW4yKGt6LCBreSkgKiBkM19kZWdyZWVzIDogMDtcbiAgfVxuICBkM190cmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy50cmFuc2xhdGUgKyBcIilyb3RhdGUoXCIgKyB0aGlzLnJvdGF0ZSArIFwiKXNrZXdYKFwiICsgdGhpcy5za2V3ICsgXCIpc2NhbGUoXCIgKyB0aGlzLnNjYWxlICsgXCIpXCI7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybURvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtTm9ybWFsaXplKGEpIHtcbiAgICB2YXIgayA9IE1hdGguc3FydChkM190cmFuc2Zvcm1Eb3QoYSwgYSkpO1xuICAgIGlmIChrKSB7XG4gICAgICBhWzBdIC89IGs7XG4gICAgICBhWzFdIC89IGs7XG4gICAgfVxuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybUNvbWJpbmUoYSwgYiwgaykge1xuICAgIGFbMF0gKz0gayAqIGJbMF07XG4gICAgYVsxXSArPSBrICogYlsxXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2YXIgZDNfdHJhbnNmb3JtSWRlbnRpdHkgPSB7XG4gICAgYTogMSxcbiAgICBiOiAwLFxuICAgIGM6IDAsXG4gICAgZDogMSxcbiAgICBlOiAwLFxuICAgIGY6IDBcbiAgfTtcbiAgZDMuaW50ZXJwb2xhdGVUcmFuc2Zvcm0gPSBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIixcIiA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2xhdGUodGEsIHRiLCBzLCBxKSB7XG4gICAgaWYgKHRhWzBdICE9PSB0YlswXSB8fCB0YVsxXSAhPT0gdGJbMV0pIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzBdLCB0YlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogaSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzFdLCB0YlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGJbMF0gfHwgdGJbMV0pIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHRiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdGF0ZShyYSwgcmIsIHMsIHEpIHtcbiAgICBpZiAocmEgIT09IHJiKSB7XG4gICAgICBpZiAocmEgLSByYiA+IDE4MCkgcmIgKz0gMzYwOyBlbHNlIGlmIChyYiAtIHJhID4gMTgwKSByYSArPSAzNjA7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgXCIpXCIpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIocmEsIHJiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyYikge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJyb3RhdGUoXCIgKyByYiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTa2V3KHdhLCB3YiwgcywgcSkge1xuICAgIGlmICh3YSAhPT0gd2IpIHtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2tld1goXCIsIG51bGwsIFwiKVwiKSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHdhLCB3YilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAod2IpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2tld1goXCIgKyB3YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTY2FsZShrYSwga2IsIHMsIHEpIHtcbiAgICBpZiAoa2FbMF0gIT09IGtiWzBdIHx8IGthWzFdICE9PSBrYlsxXSkge1xuICAgICAgdmFyIGkgPSBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzBdLCBrYlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogaSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzFdLCBrYlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2JbMF0gIT09IDEgfHwga2JbMV0gIT09IDEpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2NhbGUoXCIgKyBrYiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0oYSwgYikge1xuICAgIHZhciBzID0gW10sIHEgPSBbXTtcbiAgICBhID0gZDMudHJhbnNmb3JtKGEpLCBiID0gZDMudHJhbnNmb3JtKGIpO1xuICAgIGQzX2ludGVycG9sYXRlVHJhbnNsYXRlKGEudHJhbnNsYXRlLCBiLnRyYW5zbGF0ZSwgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVSb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVNrZXcoYS5za2V3LCBiLnNrZXcsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlU2NhbGUoYS5zY2FsZSwgYi5zY2FsZSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3VuaW50ZXJwb2xhdGVOdW1iZXIoYSwgYikge1xuICAgIGIgPSAoYiAtPSBhID0gK2EpIHx8IDEgLyBiO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gKHggLSBhKSAvIGI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM191bmludGVycG9sYXRlQ2xhbXAoYSwgYikge1xuICAgIGIgPSAoYiAtPSBhID0gK2EpIHx8IDEgLyBiO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHggLSBhKSAvIGIpKTtcbiAgICB9O1xuICB9XG4gIGQzLmxheW91dCA9IHt9O1xuICBkMy5sYXlvdXQuYnVuZGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmtzKSB7XG4gICAgICB2YXIgcGF0aHMgPSBbXSwgaSA9IC0xLCBuID0gbGlua3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHBhdGhzLnB1c2goZDNfbGF5b3V0X2J1bmRsZVBhdGgobGlua3NbaV0pKTtcbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlUGF0aChsaW5rKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2UsIGVuZCA9IGxpbmsudGFyZ2V0LCBsY2EgPSBkM19sYXlvdXRfYnVuZGxlTGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSwgcG9pbnRzID0gWyBzdGFydCBdO1xuICAgIHdoaWxlIChzdGFydCAhPT0gbGNhKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcbiAgICAgIHBvaW50cy5wdXNoKHN0YXJ0KTtcbiAgICB9XG4gICAgdmFyIGsgPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlIChlbmQgIT09IGxjYSkge1xuICAgICAgcG9pbnRzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgICAgZW5kID0gZW5kLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW10sIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlTGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICAgIHZhciBhTm9kZXMgPSBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKGEpLCBiTm9kZXMgPSBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKGIpLCBhTm9kZSA9IGFOb2Rlcy5wb3AoKSwgYk5vZGUgPSBiTm9kZXMucG9wKCksIHNoYXJlZE5vZGUgPSBudWxsO1xuICAgIHdoaWxlIChhTm9kZSA9PT0gYk5vZGUpIHtcbiAgICAgIHNoYXJlZE5vZGUgPSBhTm9kZTtcbiAgICAgIGFOb2RlID0gYU5vZGVzLnBvcCgpO1xuICAgICAgYk5vZGUgPSBiTm9kZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBzaGFyZWROb2RlO1xuICB9XG4gIGQzLmxheW91dC5jaG9yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaG9yZCA9IHt9LCBjaG9yZHMsIGdyb3VwcywgbWF0cml4LCBuLCBwYWRkaW5nID0gMCwgc29ydEdyb3Vwcywgc29ydFN1Ymdyb3Vwcywgc29ydENob3JkcztcbiAgICBmdW5jdGlvbiByZWxheW91dCgpIHtcbiAgICAgIHZhciBzdWJncm91cHMgPSB7fSwgZ3JvdXBTdW1zID0gW10sIGdyb3VwSW5kZXggPSBkMy5yYW5nZShuKSwgc3ViZ3JvdXBJbmRleCA9IFtdLCBrLCB4LCB4MCwgaSwgajtcbiAgICAgIGNob3JkcyA9IFtdO1xuICAgICAgZ3JvdXBzID0gW107XG4gICAgICBrID0gMCwgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgeCA9IDAsIGogPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB4ICs9IG1hdHJpeFtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgICBncm91cFN1bXMucHVzaCh4KTtcbiAgICAgICAgc3ViZ3JvdXBJbmRleC5wdXNoKGQzLnJhbmdlKG4pKTtcbiAgICAgICAgayArPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHNvcnRHcm91cHMpIHtcbiAgICAgICAgZ3JvdXBJbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gc29ydEdyb3Vwcyhncm91cFN1bXNbYV0sIGdyb3VwU3Vtc1tiXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNvcnRTdWJncm91cHMpIHtcbiAgICAgICAgc3ViZ3JvdXBJbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICBkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRTdWJncm91cHMobWF0cml4W2ldW2FdLCBtYXRyaXhbaV1bYl0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGsgPSAoz4QgLSBwYWRkaW5nICogbikgLyBrO1xuICAgICAgeCA9IDAsIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHgwID0geCwgaiA9IC0xO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHZhciBkaSA9IGdyb3VwSW5kZXhbaV0sIGRqID0gc3ViZ3JvdXBJbmRleFtkaV1bal0sIHYgPSBtYXRyaXhbZGldW2RqXSwgYTAgPSB4LCBhMSA9IHggKz0gdiAqIGs7XG4gICAgICAgICAgc3ViZ3JvdXBzW2RpICsgXCItXCIgKyBkal0gPSB7XG4gICAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgICBzdWJpbmRleDogZGosXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHNbZGldID0ge1xuICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiB4MCxcbiAgICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgICB2YWx1ZTogZ3JvdXBTdW1zW2RpXVxuICAgICAgICB9O1xuICAgICAgICB4ICs9IHBhZGRpbmc7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBqID0gaSAtIDE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tpICsgXCItXCIgKyBqXSwgdGFyZ2V0ID0gc3ViZ3JvdXBzW2ogKyBcIi1cIiArIGldO1xuICAgICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBjaG9yZHMucHVzaChzb3VyY2UudmFsdWUgPCB0YXJnZXQudmFsdWUgPyB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGFyZ2V0LFxuICAgICAgICAgICAgICB0YXJnZXQ6IHNvdXJjZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb3J0Q2hvcmRzKSByZXNvcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb3J0KCkge1xuICAgICAgY2hvcmRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydENob3JkcygoYS5zb3VyY2UudmFsdWUgKyBhLnRhcmdldC52YWx1ZSkgLyAyLCAoYi5zb3VyY2UudmFsdWUgKyBiLnRhcmdldC52YWx1ZSkgLyAyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaG9yZC5tYXRyaXggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXRyaXg7XG4gICAgICBuID0gKG1hdHJpeCA9IHgpICYmIG1hdHJpeC5sZW5ndGg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0geDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0R3JvdXBzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydEdyb3VwcztcbiAgICAgIHNvcnRHcm91cHMgPSB4O1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRTdWJncm91cHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0U3ViZ3JvdXBzO1xuICAgICAgc29ydFN1Ymdyb3VwcyA9IHg7XG4gICAgICBjaG9yZHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydENob3JkcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRDaG9yZHM7XG4gICAgICBzb3J0Q2hvcmRzID0geDtcbiAgICAgIGlmIChjaG9yZHMpIHJlc29ydCgpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuY2hvcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNob3JkcykgcmVsYXlvdXQoKTtcbiAgICAgIHJldHVybiBjaG9yZHM7XG4gICAgfTtcbiAgICBjaG9yZC5ncm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZ3JvdXBzKSByZWxheW91dCgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9O1xuICAgIHJldHVybiBjaG9yZDtcbiAgfTtcbiAgZDMubGF5b3V0LmZvcmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcmNlID0ge30sIGV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcInRpY2tcIiwgXCJlbmRcIiksIHRpbWVyLCBzaXplID0gWyAxLCAxIF0sIGRyYWcsIGFscGhhLCBmcmljdGlvbiA9IC45LCBsaW5rRGlzdGFuY2UgPSBkM19sYXlvdXRfZm9yY2VMaW5rRGlzdGFuY2UsIGxpbmtTdHJlbmd0aCA9IGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCwgY2hhcmdlID0gLTMwLCBjaGFyZ2VEaXN0YW5jZTIgPSBkM19sYXlvdXRfZm9yY2VDaGFyZ2VEaXN0YW5jZTIsIGdyYXZpdHkgPSAuMSwgdGhldGEyID0gLjY0LCBub2RlcyA9IFtdLCBsaW5rcyA9IFtdLCBkaXN0YW5jZXMsIHN0cmVuZ3RocywgY2hhcmdlcztcbiAgICBmdW5jdGlvbiByZXB1bHNlKG5vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihxdWFkLCB4MSwgXywgeDIpIHtcbiAgICAgICAgaWYgKHF1YWQucG9pbnQgIT09IG5vZGUpIHtcbiAgICAgICAgICB2YXIgZHggPSBxdWFkLmN4IC0gbm9kZS54LCBkeSA9IHF1YWQuY3kgLSBub2RlLnksIGR3ID0geDIgLSB4MSwgZG4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICBpZiAoZHcgKiBkdyAvIHRoZXRhMiA8IGRuKSB7XG4gICAgICAgICAgICBpZiAoZG4gPCBjaGFyZ2VEaXN0YW5jZTIpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBxdWFkLmNoYXJnZSAvIGRuO1xuICAgICAgICAgICAgICBub2RlLnB4IC09IGR4ICogaztcbiAgICAgICAgICAgICAgbm9kZS5weSAtPSBkeSAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHF1YWQucG9pbnQgJiYgZG4gJiYgZG4gPCBjaGFyZ2VEaXN0YW5jZTIpIHtcbiAgICAgICAgICAgIHZhciBrID0gcXVhZC5wb2ludENoYXJnZSAvIGRuO1xuICAgICAgICAgICAgbm9kZS5weCAtPSBkeCAqIGs7XG4gICAgICAgICAgICBub2RlLnB5IC09IGR5ICogaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFxdWFkLmNoYXJnZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZvcmNlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgoYWxwaGEgKj0gLjk5KSA8IC4wMDUpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBldmVudC5lbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgYWxwaGE6IGFscGhhID0gMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aCwgbSA9IGxpbmtzLmxlbmd0aCwgcSwgaSwgbywgcywgdCwgbCwgaywgeCwgeTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbyA9IGxpbmtzW2ldO1xuICAgICAgICBzID0gby5zb3VyY2U7XG4gICAgICAgIHQgPSBvLnRhcmdldDtcbiAgICAgICAgeCA9IHQueCAtIHMueDtcbiAgICAgICAgeSA9IHQueSAtIHMueTtcbiAgICAgICAgaWYgKGwgPSB4ICogeCArIHkgKiB5KSB7XG4gICAgICAgICAgbCA9IGFscGhhICogc3RyZW5ndGhzW2ldICogKChsID0gTWF0aC5zcXJ0KGwpKSAtIGRpc3RhbmNlc1tpXSkgLyBsO1xuICAgICAgICAgIHggKj0gbDtcbiAgICAgICAgICB5ICo9IGw7XG4gICAgICAgICAgdC54IC09IHggKiAoayA9IHMud2VpZ2h0ICsgdC53ZWlnaHQgPyBzLndlaWdodCAvIChzLndlaWdodCArIHQud2VpZ2h0KSA6IC41KTtcbiAgICAgICAgICB0LnkgLT0geSAqIGs7XG4gICAgICAgICAgcy54ICs9IHggKiAoayA9IDEgLSBrKTtcbiAgICAgICAgICBzLnkgKz0geSAqIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrID0gYWxwaGEgKiBncmF2aXR5KSB7XG4gICAgICAgIHggPSBzaXplWzBdIC8gMjtcbiAgICAgICAgeSA9IHNpemVbMV0gLyAyO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIGlmIChrKSB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgICBvLnggKz0gKHggLSBvLngpICogaztcbiAgICAgICAgICBvLnkgKz0gKHkgLSBvLnkpICogaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYXJnZSkge1xuICAgICAgICBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKHEgPSBkMy5nZW9tLnF1YWR0cmVlKG5vZGVzKSwgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKCEobyA9IG5vZGVzW2ldKS5maXhlZCkge1xuICAgICAgICAgICAgcS52aXNpdChyZXB1bHNlKG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG8uZml4ZWQpIHtcbiAgICAgICAgICBvLnggPSBvLnB4O1xuICAgICAgICAgIG8ueSA9IG8ucHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby54IC09IChvLnB4IC0gKG8ucHggPSBvLngpKSAqIGZyaWN0aW9uO1xuICAgICAgICAgIG8ueSAtPSAoby5weSAtIChvLnB5ID0gby55KSkgKiBmcmljdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudGljayh7XG4gICAgICAgIHR5cGU6IFwidGlja1wiLFxuICAgICAgICBhbHBoYTogYWxwaGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yY2Uubm9kZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcbiAgICAgIG5vZGVzID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgICBsaW5rcyA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UubGlua0Rpc3RhbmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua0Rpc3RhbmNlO1xuICAgICAgbGlua0Rpc3RhbmNlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmRpc3RhbmNlID0gZm9yY2UubGlua0Rpc3RhbmNlO1xuICAgIGZvcmNlLmxpbmtTdHJlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtTdHJlbmd0aDtcbiAgICAgIGxpbmtTdHJlbmd0aCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5mcmljdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyaWN0aW9uO1xuICAgICAgZnJpY3Rpb24gPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmNoYXJnZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJnZTtcbiAgICAgIGNoYXJnZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5jaGFyZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydChjaGFyZ2VEaXN0YW5jZTIpO1xuICAgICAgY2hhcmdlRGlzdGFuY2UyID0geCAqIHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5ncmF2aXR5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3Jhdml0eTtcbiAgICAgIGdyYXZpdHkgPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnRoZXRhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KHRoZXRhMik7XG4gICAgICB0aGV0YTIgPSB4ICogeDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmFscGhhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYWxwaGE7XG4gICAgICB4ID0gK3g7XG4gICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgYWxwaGEgPSB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVyLmMgPSBudWxsLCB0aW1lci50ID0gTmFOLCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgZXZlbnQuZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEgPSAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeCA+IDApIHtcbiAgICAgICAgZXZlbnQuc3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFwic3RhcnRcIixcbiAgICAgICAgICBhbHBoYTogYWxwaGEgPSB4XG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lciA9IGQzX3RpbWVyKGZvcmNlLnRpY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2Uuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBtID0gbGlua3MubGVuZ3RoLCB3ID0gc2l6ZVswXSwgaCA9IHNpemVbMV0sIG5laWdoYm9ycywgbztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgKG8gPSBub2Rlc1tpXSkuaW5kZXggPSBpO1xuICAgICAgICBvLndlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIG8gPSBsaW5rc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnNvdXJjZSA9PSBcIm51bWJlclwiKSBvLnNvdXJjZSA9IG5vZGVzW28uc291cmNlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnRhcmdldCA9PSBcIm51bWJlclwiKSBvLnRhcmdldCA9IG5vZGVzW28udGFyZ2V0XTtcbiAgICAgICAgKytvLnNvdXJjZS53ZWlnaHQ7XG4gICAgICAgICsrby50YXJnZXQud2VpZ2h0O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChpc05hTihvLngpKSBvLnggPSBwb3NpdGlvbihcInhcIiwgdyk7XG4gICAgICAgIGlmIChpc05hTihvLnkpKSBvLnkgPSBwb3NpdGlvbihcInlcIiwgaCk7XG4gICAgICAgIGlmIChpc05hTihvLnB4KSkgby5weCA9IG8ueDtcbiAgICAgICAgaWYgKGlzTmFOKG8ucHkpKSBvLnB5ID0gby55O1xuICAgICAgfVxuICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGxpbmtEaXN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBkaXN0YW5jZXNbaV0gPSArbGlua0Rpc3RhbmNlLmNhbGwodGhpcywgbGlua3NbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIGRpc3RhbmNlc1tpXSA9IGxpbmtEaXN0YW5jZTtcbiAgICAgIHN0cmVuZ3RocyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rU3RyZW5ndGggPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc3RyZW5ndGhzW2ldID0gK2xpbmtTdHJlbmd0aC5jYWxsKHRoaXMsIGxpbmtzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzdHJlbmd0aHNbaV0gPSBsaW5rU3RyZW5ndGg7XG4gICAgICBjaGFyZ2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGNoYXJnZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gK2NoYXJnZS5jYWxsKHRoaXMsIG5vZGVzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gY2hhcmdlO1xuICAgICAgZnVuY3Rpb24gcG9zaXRpb24oZGltZW5zaW9uLCBzaXplKSB7XG4gICAgICAgIGlmICghbmVpZ2hib3JzKSB7XG4gICAgICAgICAgbmVpZ2hib3JzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIG5laWdoYm9yc1tqXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGxpbmtzW2pdO1xuICAgICAgICAgICAgbmVpZ2hib3JzW28uc291cmNlLmluZGV4XS5wdXNoKG8udGFyZ2V0KTtcbiAgICAgICAgICAgIG5laWdoYm9yc1tvLnRhcmdldC5pbmRleF0ucHVzaChvLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gbmVpZ2hib3JzW2ldLCBqID0gLTEsIGwgPSBjYW5kaWRhdGVzLmxlbmd0aCwgeDtcbiAgICAgICAgd2hpbGUgKCsraiA8IGwpIGlmICghaXNOYU4oeCA9IGNhbmRpZGF0ZXNbal1bZGltZW5zaW9uXSkpIHJldHVybiB4O1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yY2UucmVzdW1lKCk7XG4gICAgfTtcbiAgICBmb3JjZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JjZS5hbHBoYSguMSk7XG4gICAgfTtcbiAgICBmb3JjZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9yY2UuYWxwaGEoMCk7XG4gICAgfTtcbiAgICBmb3JjZS5kcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWRyYWcpIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCkub3JpZ2luKGQzX2lkZW50aXR5KS5vbihcImRyYWdzdGFydC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQpLm9uKFwiZHJhZy5mb3JjZVwiLCBkcmFnbW92ZSkub24oXCJkcmFnZW5kLmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZURyYWdlbmQpO1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHJhZztcbiAgICAgIHRoaXMub24oXCJtb3VzZW92ZXIuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlTW91c2VvdmVyKS5vbihcIm1vdXNlb3V0LmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZU1vdXNlb3V0KS5jYWxsKGRyYWcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZHJhZ21vdmUoZCkge1xuICAgICAgZC5weCA9IGQzLmV2ZW50LngsIGQucHkgPSBkMy5ldmVudC55O1xuICAgICAgZm9yY2UucmVzdW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoZm9yY2UsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQoZCkge1xuICAgIGQuZml4ZWQgfD0gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnZW5kKGQpIHtcbiAgICBkLmZpeGVkICY9IH42O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZU1vdXNlb3ZlcihkKSB7XG4gICAgZC5maXhlZCB8PSA0O1xuICAgIGQucHggPSBkLngsIGQucHkgPSBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlTW91c2VvdXQoZCkge1xuICAgIGQuZml4ZWQgJj0gfjQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShxdWFkLCBhbHBoYSwgY2hhcmdlcykge1xuICAgIHZhciBjeCA9IDAsIGN5ID0gMDtcbiAgICBxdWFkLmNoYXJnZSA9IDA7XG4gICAgaWYgKCFxdWFkLmxlYWYpIHtcbiAgICAgIHZhciBub2RlcyA9IHF1YWQubm9kZXMsIG4gPSBub2Rlcy5sZW5ndGgsIGkgPSAtMSwgYztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGMgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUoYywgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBxdWFkLmNoYXJnZSArPSBjLmNoYXJnZTtcbiAgICAgICAgY3ggKz0gYy5jaGFyZ2UgKiBjLmN4O1xuICAgICAgICBjeSArPSBjLmNoYXJnZSAqIGMuY3k7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWFkLnBvaW50KSB7XG4gICAgICBpZiAoIXF1YWQubGVhZikge1xuICAgICAgICBxdWFkLnBvaW50LnggKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgICBxdWFkLnBvaW50LnkgKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBhbHBoYSAqIGNoYXJnZXNbcXVhZC5wb2ludC5pbmRleF07XG4gICAgICBxdWFkLmNoYXJnZSArPSBxdWFkLnBvaW50Q2hhcmdlID0gaztcbiAgICAgIGN4ICs9IGsgKiBxdWFkLnBvaW50Lng7XG4gICAgICBjeSArPSBrICogcXVhZC5wb2ludC55O1xuICAgIH1cbiAgICBxdWFkLmN4ID0gY3ggLyBxdWFkLmNoYXJnZTtcbiAgICBxdWFkLmN5ID0gY3kgLyBxdWFkLmNoYXJnZTtcbiAgfVxuICB2YXIgZDNfbGF5b3V0X2ZvcmNlTGlua0Rpc3RhbmNlID0gMjAsIGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCA9IDEsIGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiA9IEluZmluaXR5O1xuICBkMy5sYXlvdXQuaGllcmFyY2h5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvcnQgPSBkM19sYXlvdXRfaGllcmFyY2h5U29ydCwgY2hpbGRyZW4gPSBkM19sYXlvdXRfaGllcmFyY2h5Q2hpbGRyZW4sIHZhbHVlID0gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlO1xuICAgIGZ1bmN0aW9uIGhpZXJhcmNoeShyb290KSB7XG4gICAgICB2YXIgc3RhY2sgPSBbIHJvb3QgXSwgbm9kZXMgPSBbXSwgbm9kZTtcbiAgICAgIHJvb3QuZGVwdGggPSAwO1xuICAgICAgd2hpbGUgKChub2RlID0gc3RhY2sucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKChjaGlsZHMgPSBjaGlsZHJlbi5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgbiwgY2hpbGRzLCBjaGlsZDtcbiAgICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQgPSBjaGlsZHNbbl0pO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUpIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcywgcGFyZW50O1xuICAgICAgICBpZiAoc29ydCAmJiAoY2hpbGRzID0gbm9kZS5jaGlsZHJlbikpIGNoaWxkcy5zb3J0KHNvcnQpO1xuICAgICAgICBpZiAodmFsdWUgJiYgKHBhcmVudCA9IG5vZGUucGFyZW50KSkgcGFyZW50LnZhbHVlICs9IG5vZGUudmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgaGllcmFyY2h5LnNvcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0O1xuICAgICAgc29ydCA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LmNoaWxkcmVuID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnJldmFsdWUgPSBmdW5jdGlvbihyb290KSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgaWYgKHBhcmVudCA9IG5vZGUucGFyZW50KSBwYXJlbnQudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIHJldHVybiBoaWVyYXJjaHk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQob2JqZWN0LCBoaWVyYXJjaHkpIHtcbiAgICBkMy5yZWJpbmQob2JqZWN0LCBoaWVyYXJjaHksIFwic29ydFwiLCBcImNoaWxkcmVuXCIsIFwidmFsdWVcIik7XG4gICAgb2JqZWN0Lm5vZGVzID0gb2JqZWN0O1xuICAgIG9iamVjdC5saW5rcyA9IGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcztcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdO1xuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIGlmICgoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIG5vZGVzLnB1c2goY2hpbGRyZW5bbl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdLCBub2RlczIgPSBbXTtcbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgbm9kZXMyLnB1c2gobm9kZSk7XG4gICAgICBpZiAoKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzMi5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlDaGlsZHJlbihkKSB7XG4gICAgcmV0dXJuIGQuY2hpbGRyZW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlKGQpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcyhub2Rlcykge1xuICAgIHJldHVybiBkMy5tZXJnZShub2Rlcy5tYXAoZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gKHBhcmVudC5jaGlsZHJlbiB8fCBbXSkubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBwYXJlbnQsXG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG4gIGQzLmxheW91dC5wYXJ0aXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLCBzaXplID0gWyAxLCAxIF07XG4gICAgZnVuY3Rpb24gcG9zaXRpb24obm9kZSwgeCwgZHgsIGR5KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS54ID0geDtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgICAgIG5vZGUuZHggPSBkeDtcbiAgICAgIG5vZGUuZHkgPSBkeTtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiwgYywgZDtcbiAgICAgICAgZHggPSBub2RlLnZhbHVlID8gZHggLyBub2RlLnZhbHVlIDogMDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBwb3NpdGlvbihjID0gY2hpbGRyZW5baV0sIHgsIGQgPSBjLnZhbHVlICogZHgsIGR5KTtcbiAgICAgICAgICB4ICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVwdGgobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgZCA9IDA7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG47XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBkID0gTWF0aC5tYXgoZCwgZGVwdGgoY2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxICsgZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgcG9zaXRpb24obm9kZXNbMF0sIDAsIHNpemVbMF0sIHNpemVbMV0gLyBkZXB0aChub2Rlc1swXSkpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiBwYXJ0aXRpb247XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChwYXJ0aXRpb24sIGhpZXJhcmNoeSk7XG4gIH07XG4gIGQzLmxheW91dC5waWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBOdW1iZXIsIHNvcnQgPSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUsIHN0YXJ0QW5nbGUgPSAwLCBlbmRBbmdsZSA9IM+ELCBwYWRBbmdsZSA9IDA7XG4gICAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIHZhbHVlcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICt2YWx1ZS5jYWxsKHBpZSwgZCwgaSk7XG4gICAgICB9KSwgYSA9ICsodHlwZW9mIHN0YXJ0QW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHN0YXJ0QW5nbGUpLCBkYSA9ICh0eXBlb2YgZW5kQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBlbmRBbmdsZSkgLSBhLCBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgKyh0eXBlb2YgcGFkQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwYWRBbmdsZSkpLCBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSwgc3VtID0gZDMuc3VtKHZhbHVlcyksIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMCwgaW5kZXggPSBkMy5yYW5nZShuKSwgYXJjcyA9IFtdLCB2O1xuICAgICAgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChzb3J0ID09PSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPyBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbal0gLSB2YWx1ZXNbaV07XG4gICAgICB9IDogZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTtcbiAgICAgIH0pO1xuICAgICAgaW5kZXguZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGFyY3NbaV0gPSB7XG4gICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICB2YWx1ZTogdiA9IHZhbHVlc1tpXSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBhLFxuICAgICAgICAgIGVuZEFuZ2xlOiBhICs9IHYgKiBrICsgcGEsXG4gICAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfVxuICAgIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydDtcbiAgICAgIHNvcnQgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHJldHVybiBwaWU7XG4gIH07XG4gIHZhciBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPSB7fTtcbiAgZDMubGF5b3V0LnN0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IGQzX2lkZW50aXR5LCBvcmRlciA9IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdCwgb2Zmc2V0ID0gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybywgb3V0ID0gZDNfbGF5b3V0X3N0YWNrT3V0LCB4ID0gZDNfbGF5b3V0X3N0YWNrWCwgeSA9IGQzX2xheW91dF9zdGFja1k7XG4gICAgZnVuY3Rpb24gc3RhY2soZGF0YSwgaW5kZXgpIHtcbiAgICAgIGlmICghKG4gPSBkYXRhLmxlbmd0aCkpIHJldHVybiBkYXRhO1xuICAgICAgdmFyIHNlcmllcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5jYWxsKHN0YWNrLCBkLCBpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50cyA9IHNlcmllcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgIHJldHVybiBbIHguY2FsbChzdGFjaywgdiwgaSksIHkuY2FsbChzdGFjaywgdiwgaSkgXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvcmRlcnMgPSBvcmRlci5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHNlcmllcyA9IGQzLnBlcm11dGUoc2VyaWVzLCBvcmRlcnMpO1xuICAgICAgcG9pbnRzID0gZDMucGVybXV0ZShwb2ludHMsIG9yZGVycyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG9mZnNldC5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHZhciBtID0gc2VyaWVzWzBdLmxlbmd0aCwgbiwgaSwgaiwgbztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgb3V0LmNhbGwoc3RhY2ssIHNlcmllc1swXVtqXSwgbyA9IG9mZnNldHNbal0sIHBvaW50c1swXVtqXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBvdXQuY2FsbChzdGFjaywgc2VyaWVzW2ldW2pdLCBvICs9IHBvaW50c1tpIC0gMV1bal1bMV0sIHBvaW50c1tpXVtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBzdGFjay52YWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXM7XG4gICAgICB2YWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmRlcjtcbiAgICAgIG9yZGVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBkM19sYXlvdXRfc3RhY2tPcmRlcnMuZ2V0KHgpIHx8IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdDtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9mZnNldDtcbiAgICAgIG9mZnNldCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cy5nZXQoeCkgfHwgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybztcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3V0ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0O1xuICAgICAgb3V0ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrWChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja091dChkLCB5MCwgeSkge1xuICAgIGQueTAgPSB5MDtcbiAgICBkLnkgPSB5O1xuICB9XG4gIHZhciBkM19sYXlvdXRfc3RhY2tPcmRlcnMgPSBkMy5tYXAoe1xuICAgIFwiaW5zaWRlLW91dFwiOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBpLCBqLCBtYXggPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tNYXhJbmRleCksIHN1bXMgPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0pLCBpbmRleCA9IGQzLnJhbmdlKG4pLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gbWF4W2FdIC0gbWF4W2JdO1xuICAgICAgfSksIHRvcCA9IDAsIGJvdHRvbSA9IDAsIHRvcHMgPSBbXSwgYm90dG9tcyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBqID0gaW5kZXhbaV07XG4gICAgICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgICAgICB0b3BzLnB1c2goaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRhdGEubGVuZ3RoKS5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0XG4gIH0pO1xuICB2YXIgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cyA9IGQzLm1hcCh7XG4gICAgc2lsaG91ZXR0ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBzdW1zID0gW10sIG1heCA9IDAsIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvID4gbWF4KSBtYXggPSBvO1xuICAgICAgICBzdW1zLnB1c2gobyk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHkwW2pdID0gKG1heCAtIHN1bXNbal0pIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIHdpZ2dsZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgeCA9IGRhdGFbMF0sIG0gPSB4Lmxlbmd0aCwgaSwgaiwgaywgczEsIHMyLCBzMywgZHgsIG8sIG8wLCB5MCA9IFtdO1xuICAgICAgeTBbMF0gPSBvID0gbzAgPSAwO1xuICAgICAgZm9yIChqID0gMTsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBzMSA9IDA7IGkgPCBuOyArK2kpIHMxICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGZvciAoaSA9IDAsIHMyID0gMCwgZHggPSB4W2pdWzBdIC0geFtqIC0gMV1bMF07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKGsgPSAwLCBzMyA9IChkYXRhW2ldW2pdWzFdIC0gZGF0YVtpXVtqIC0gMV1bMV0pIC8gKDIgKiBkeCk7IGsgPCBpOyArK2spIHtcbiAgICAgICAgICAgIHMzICs9IChkYXRhW2tdW2pdWzFdIC0gZGF0YVtrXVtqIC0gMV1bMV0pIC8gZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMyICs9IHMzICogZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5MFtqXSA9IG8gLT0gczEgPyBzMiAvIHMxICogZHggOiAwO1xuICAgICAgICBpZiAobyA8IG8wKSBvMCA9IG87XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSAtPSBvMDtcbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBrID0gMSAvIG4sIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvKSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkYXRhW2ldW2pdWzFdIC89IG87IGVsc2UgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZGF0YVtpXVtqXVsxXSA9IGs7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSA9IDA7XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICB6ZXJvOiBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvXG4gIH0pO1xuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQoZGF0YSkge1xuICAgIHJldHVybiBkMy5yYW5nZShkYXRhLmxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybyhkYXRhKSB7XG4gICAgdmFyIGogPSAtMSwgbSA9IGRhdGFbMF0ubGVuZ3RoLCB5MCA9IFtdO1xuICAgIHdoaWxlICgrK2ogPCBtKSB5MFtqXSA9IDA7XG4gICAgcmV0dXJuIHkwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja01heEluZGV4KGFycmF5KSB7XG4gICAgdmFyIGkgPSAxLCBqID0gMCwgdiA9IGFycmF5WzBdWzFdLCBrLCBuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoayA9IGFycmF5W2ldWzFdKSA+IHYpIHtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIHYgPSBrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gajtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0oZCkge1xuICAgIHJldHVybiBkLnJlZHVjZShkM19sYXlvdXRfc3RhY2tTdW0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1N1bShwLCBkKSB7XG4gICAgcmV0dXJuIHAgKyBkWzFdO1xuICB9XG4gIGQzLmxheW91dC5oaXN0b2dyYW0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJlcXVlbmN5ID0gdHJ1ZSwgdmFsdWVyID0gTnVtYmVyLCByYW5nZXIgPSBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UsIGJpbm5lciA9IGQzX2xheW91dF9oaXN0b2dyYW1CaW5TdHVyZ2VzO1xuICAgIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhLCBpKSB7XG4gICAgICB2YXIgYmlucyA9IFtdLCB2YWx1ZXMgPSBkYXRhLm1hcCh2YWx1ZXIsIHRoaXMpLCByYW5nZSA9IHJhbmdlci5jYWxsKHRoaXMsIHZhbHVlcywgaSksIHRocmVzaG9sZHMgPSBiaW5uZXIuY2FsbCh0aGlzLCByYW5nZSwgdmFsdWVzLCBpKSwgYmluLCBpID0gLTEsIG4gPSB2YWx1ZXMubGVuZ3RoLCBtID0gdGhyZXNob2xkcy5sZW5ndGggLSAxLCBrID0gZnJlcXVlbmN5ID8gMSA6IDEgLyBuLCB4O1xuICAgICAgd2hpbGUgKCsraSA8IG0pIHtcbiAgICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgICBiaW4uZHggPSB0aHJlc2hvbGRzW2kgKyAxXSAtIChiaW4ueCA9IHRocmVzaG9sZHNbaV0pO1xuICAgICAgICBiaW4ueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICAgICAgaWYgKHggPj0gcmFuZ2VbMF0gJiYgeCA8PSByYW5nZVsxXSkge1xuICAgICAgICAgICAgYmluID0gYmluc1tkMy5iaXNlY3QodGhyZXNob2xkcywgeCwgMSwgbSkgLSAxXTtcbiAgICAgICAgICAgIGJpbi55ICs9IGs7XG4gICAgICAgICAgICBiaW4ucHVzaChkYXRhW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5zO1xuICAgIH1cbiAgICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXI7XG4gICAgICB2YWx1ZXIgPSB4O1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlcjtcbiAgICAgIHJhbmdlciA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmJpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiaW5uZXI7XG4gICAgICBiaW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIHgpO1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmZyZXF1ZW5jeSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyZXF1ZW5jeTtcbiAgICAgIGZyZXF1ZW5jeSA9ICEheDtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtQmluU3R1cmdlcyhyYW5nZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIgKyAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCBuKSB7XG4gICAgdmFyIHggPSAtMSwgYiA9ICtyYW5nZVswXSwgbSA9IChyYW5nZVsxXSAtIGIpIC8gbiwgZiA9IFtdO1xuICAgIHdoaWxlICgrK3ggPD0gbikgZlt4XSA9IG0gKiB4ICsgYjtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UodmFsdWVzKSB7XG4gICAgcmV0dXJuIFsgZDMubWluKHZhbHVlcyksIGQzLm1heCh2YWx1ZXMpIF07XG4gIH1cbiAgZDMubGF5b3V0LnBhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQoZDNfbGF5b3V0X3BhY2tTb3J0KSwgcGFkZGluZyA9IDAsIHNpemUgPSBbIDEsIDEgXSwgcmFkaXVzO1xuICAgIGZ1bmN0aW9uIHBhY2soZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QgPSBub2Rlc1swXSwgdyA9IHNpemVbMF0sIGggPSBzaXplWzFdLCByID0gcmFkaXVzID09IG51bGwgPyBNYXRoLnNxcnQgOiB0eXBlb2YgcmFkaXVzID09PSBcImZ1bmN0aW9uXCIgPyByYWRpdXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICAgIH07XG4gICAgICByb290LnggPSByb290LnkgPSAwO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICBkLnIgPSArcihkLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyk7XG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICB2YXIgZHIgPSBwYWRkaW5nICogKHJhZGl1cyA/IDEgOiBNYXRoLm1heCgyICogcm9vdC5yIC8gdywgMiAqIHJvb3QuciAvIGgpKSAvIDI7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkLnIgKz0gZHI7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBkM19sYXlvdXRfcGFja1NpYmxpbmdzKTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGQuciAtPSBkcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShyb290LCB3IC8gMiwgaCAvIDIsIHJhZGl1cyA/IDEgOiAxIC8gTWF0aC5tYXgoMiAqIHJvb3QuciAvIHcsIDIgKiByb290LnIgLyBoKSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpdXM7XG4gICAgICByYWRpdXMgPSBfID09IG51bGwgfHwgdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIHBhZGRpbmcgPSArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQocGFjaywgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYikge1xuICAgIHZhciBjID0gYS5fcGFja19uZXh0O1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgICBiLl9wYWNrX25leHQgPSBjO1xuICAgIGMuX3BhY2tfcHJldiA9IGI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYikge1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoYSwgYikge1xuICAgIHZhciBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnksIGRyID0gYS5yICsgYi5yO1xuICAgIHJldHVybiAuOTk5ICogZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU2libGluZ3Mobm9kZSkge1xuICAgIGlmICghKG5vZGVzID0gbm9kZS5jaGlsZHJlbikgfHwgIShuID0gbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBub2RlcywgeE1pbiA9IEluZmluaXR5LCB4TWF4ID0gLUluZmluaXR5LCB5TWluID0gSW5maW5pdHksIHlNYXggPSAtSW5maW5pdHksIGEsIGIsIGMsIGksIGosIGssIG47XG4gICAgZnVuY3Rpb24gYm91bmQobm9kZSkge1xuICAgICAgeE1pbiA9IE1hdGgubWluKG5vZGUueCAtIG5vZGUuciwgeE1pbik7XG4gICAgICB4TWF4ID0gTWF0aC5tYXgobm9kZS54ICsgbm9kZS5yLCB4TWF4KTtcbiAgICAgIHlNaW4gPSBNYXRoLm1pbihub2RlLnkgLSBub2RlLnIsIHlNaW4pO1xuICAgICAgeU1heCA9IE1hdGgubWF4KG5vZGUueSArIG5vZGUuciwgeU1heCk7XG4gICAgfVxuICAgIG5vZGVzLmZvckVhY2goZDNfbGF5b3V0X3BhY2tMaW5rKTtcbiAgICBhID0gbm9kZXNbMF07XG4gICAgYS54ID0gLWEucjtcbiAgICBhLnkgPSAwO1xuICAgIGJvdW5kKGEpO1xuICAgIGlmIChuID4gMSkge1xuICAgICAgYiA9IG5vZGVzWzFdO1xuICAgICAgYi54ID0gYi5yO1xuICAgICAgYi55ID0gMDtcbiAgICAgIGJvdW5kKGIpO1xuICAgICAgaWYgKG4gPiAyKSB7XG4gICAgICAgIGMgPSBub2Rlc1syXTtcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjKTtcbiAgICAgICAgYm91bmQoYyk7XG4gICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGMpO1xuICAgICAgICBhLl9wYWNrX3ByZXYgPSBjO1xuICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChjLCBiKTtcbiAgICAgICAgYiA9IGEuX3BhY2tfbmV4dDtcbiAgICAgICAgZm9yIChpID0gMzsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYyA9IG5vZGVzW2ldKTtcbiAgICAgICAgICB2YXIgaXNlY3QgPSAwLCBzMSA9IDEsIHMyID0gMTtcbiAgICAgICAgICBmb3IgKGogPSBiLl9wYWNrX25leHQ7IGogIT09IGI7IGogPSBqLl9wYWNrX25leHQsIHMxKyspIHtcbiAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaiwgYykpIHtcbiAgICAgICAgICAgICAgaXNlY3QgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzZWN0ID09IDEpIHtcbiAgICAgICAgICAgIGZvciAoayA9IGEuX3BhY2tfcHJldjsgayAhPT0gai5fcGFja19wcmV2OyBrID0gay5fcGFja19wcmV2LCBzMisrKSB7XG4gICAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaywgYykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNlY3QpIHtcbiAgICAgICAgICAgIGlmIChzMSA8IHMyIHx8IHMxID09IHMyICYmIGIuciA8IGEucikgZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYiA9IGopOyBlbHNlIGQzX2xheW91dF9wYWNrU3BsaWNlKGEgPSBrLCBiKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYyk7XG4gICAgICAgICAgICBiID0gYztcbiAgICAgICAgICAgIGJvdW5kKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY3ggPSAoeE1pbiArIHhNYXgpIC8gMiwgY3kgPSAoeU1pbiArIHlNYXgpIC8gMiwgY3IgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgIGMueCAtPSBjeDtcbiAgICAgIGMueSAtPSBjeTtcbiAgICAgIGNyID0gTWF0aC5tYXgoY3IsIGMuciArIE1hdGguc3FydChjLnggKiBjLnggKyBjLnkgKiBjLnkpKTtcbiAgICB9XG4gICAgbm9kZS5yID0gY3I7XG4gICAgbm9kZXMuZm9yRWFjaChkM19sYXlvdXRfcGFja1VubGluayk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tMaW5rKG5vZGUpIHtcbiAgICBub2RlLl9wYWNrX25leHQgPSBub2RlLl9wYWNrX3ByZXYgPSBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrVW5saW5rKG5vZGUpIHtcbiAgICBkZWxldGUgbm9kZS5fcGFja19uZXh0O1xuICAgIGRlbGV0ZSBub2RlLl9wYWNrX3ByZXY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0obm9kZSwgeCwgeSwgaykge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgbm9kZS54ID0geCArPSBrICogbm9kZS54O1xuICAgIG5vZGUueSA9IHkgKz0gayAqIG5vZGUueTtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0oY2hpbGRyZW5baV0sIHgsIHksIGspO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMpIHtcbiAgICB2YXIgZGIgPSBhLnIgKyBjLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICBpZiAoZGIgJiYgKGR4IHx8IGR5KSkge1xuICAgICAgdmFyIGRhID0gYi5yICsgYy5yLCBkYyA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgZGEgKj0gZGE7XG4gICAgICBkYiAqPSBkYjtcbiAgICAgIHZhciB4ID0gLjUgKyAoZGIgLSBkYSkgLyAoMiAqIGRjKSwgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCAyICogZGEgKiAoZGIgKyBkYykgLSAoZGIgLT0gZGMpICogZGIgLSBkYSAqIGRhKSkgLyAoMiAqIGRjKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCArIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSAtIHkgKiBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgYy54ID0gYS54ICsgZGI7XG4gICAgICBjLnkgPSBhLnk7XG4gICAgfVxuICB9XG4gIGQzLmxheW91dC50cmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KG51bGwpLnZhbHVlKG51bGwpLCBzZXBhcmF0aW9uID0gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uLCBzaXplID0gWyAxLCAxIF0sIG5vZGVTaXplID0gbnVsbDtcbiAgICBmdW5jdGlvbiB0cmVlKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290MCA9IG5vZGVzWzBdLCByb290MSA9IHdyYXBUcmVlKHJvb3QwKTtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QxLCBmaXJzdFdhbGspLCByb290MS5wYXJlbnQubSA9IC1yb290MS56O1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QxLCBzZWNvbmRXYWxrKTtcbiAgICAgIGlmIChub2RlU2l6ZSkgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBzaXplTm9kZSk7IGVsc2Uge1xuICAgICAgICB2YXIgbGVmdCA9IHJvb3QwLCByaWdodCA9IHJvb3QwLCBib3R0b20gPSByb290MDtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgICBpZiAobm9kZS5kZXB0aCA+IGJvdHRvbS5kZXB0aCkgYm90dG9tID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0eCA9IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiAtIGxlZnQueCwga3ggPSBzaXplWzBdIC8gKHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDIgKyB0eCksIGt5ID0gc2l6ZVsxXSAvIChib3R0b20uZGVwdGggfHwgMSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cmFwVHJlZShyb290MCkge1xuICAgICAgdmFyIHJvb3QxID0ge1xuICAgICAgICBBOiBudWxsLFxuICAgICAgICBjaGlsZHJlbjogWyByb290MCBdXG4gICAgICB9LCBxdWV1ZSA9IFsgcm9vdDEgXSwgbm9kZTE7XG4gICAgICB3aGlsZSAoKG5vZGUxID0gcXVldWUucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBub2RlMS5jaGlsZHJlbiwgY2hpbGQsIGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgcXVldWUucHVzaCgoY2hpbGRyZW5baV0gPSBjaGlsZCA9IHtcbiAgICAgICAgICAgIF86IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgcGFyZW50OiBub2RlMSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoY2hpbGQgPSBjaGlsZHJlbltpXS5jaGlsZHJlbikgJiYgY2hpbGQuc2xpY2UoKSB8fCBbXSxcbiAgICAgICAgICAgIEE6IG51bGwsXG4gICAgICAgICAgICBhOiBudWxsLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIG06IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICBpOiBpXG4gICAgICAgICAgfSkuYSA9IGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3QxLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbiwgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgZDNfbGF5b3V0X3RyZWVTaGlmdCh2KTtcbiAgICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgIH1cbiAgICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgICAgdi5tICs9IHYucGFyZW50Lm07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdmFyIHZpcCA9IHYsIHZvcCA9IHYsIHZpbSA9IHcsIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sIHNpcCA9IHZpcC5tLCBzb3AgPSB2b3AubSwgc2ltID0gdmltLm0sIHNvbSA9IHZvbS5tLCBzaGlmdDtcbiAgICAgICAgd2hpbGUgKHZpbSA9IGQzX2xheW91dF90cmVlUmlnaHQodmltKSwgdmlwID0gZDNfbGF5b3V0X3RyZWVMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgICB2b20gPSBkM19sYXlvdXRfdHJlZUxlZnQodm9tKTtcbiAgICAgICAgICB2b3AgPSBkM19sYXlvdXRfdHJlZVJpZ2h0KHZvcCk7XG4gICAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgICBkM19sYXlvdXRfdHJlZU1vdmUoZDNfbGF5b3V0X3RyZWVBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbSAmJiAhZDNfbGF5b3V0X3RyZWVSaWdodCh2b3ApKSB7XG4gICAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgICAgdm9wLm0gKz0gc2ltIC0gc29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXAgJiYgIWQzX2xheW91dF90cmVlTGVmdCh2b20pKSB7XG4gICAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgICBub2RlLnggKj0gc2l6ZVswXTtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBzaXplWzFdO1xuICAgIH1cbiAgICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZXBhcmF0aW9uO1xuICAgICAgc2VwYXJhdGlvbiA9IHg7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gbnVsbCA6IHNpemU7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IHNpemVOb2RlIDogbnVsbDtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gc2l6ZSA6IG51bGw7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IG51bGwgOiBzaXplTm9kZTtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQodHJlZSwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wYXJlbnQgPT0gYi5wYXJlbnQgPyAxIDogMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUxlZnQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdIDogdi50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlUmlnaHQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIG47XG4gICAgcmV0dXJuIChuID0gY2hpbGRyZW4ubGVuZ3RoKSA/IGNoaWxkcmVuW24gLSAxXSA6IHYudDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZU1vdmUod20sIHdwLCBzaGlmdCkge1xuICAgIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gICAgd3AuYyAtPSBjaGFuZ2U7XG4gICAgd3AucyArPSBzaGlmdDtcbiAgICB3bS5jICs9IGNoYW5nZTtcbiAgICB3cC56ICs9IHNoaWZ0O1xuICAgIHdwLm0gKz0gc2hpZnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTaGlmdCh2KSB7XG4gICAgdmFyIHNoaWZ0ID0gMCwgY2hhbmdlID0gMCwgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBpID0gY2hpbGRyZW4ubGVuZ3RoLCB3O1xuICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgdy56ICs9IHNoaWZ0O1xuICAgICAgdy5tICs9IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgICByZXR1cm4gdmltLmEucGFyZW50ID09PSB2LnBhcmVudCA/IHZpbS5hIDogYW5jZXN0b3I7XG4gIH1cbiAgZDMubGF5b3V0LmNsdXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQobnVsbCkudmFsdWUobnVsbCksIHNlcGFyYXRpb24gPSBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24sIHNpemUgPSBbIDEsIDEgXSwgbm9kZVNpemUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjbHVzdGVyKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290ID0gbm9kZXNbMF0sIHByZXZpb3VzTm9kZSwgeCA9IDA7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLnggPSBkM19sYXlvdXRfY2x1c3RlclgoY2hpbGRyZW4pO1xuICAgICAgICAgIG5vZGUueSA9IGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbGVmdCA9IGQzX2xheW91dF9jbHVzdGVyTGVmdChyb290KSwgcmlnaHQgPSBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KHJvb3QpLCB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiwgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgbm9kZVNpemUgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogc2l6ZVswXTtcbiAgICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBzaXplWzFdO1xuICAgICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIHNpemVbMF07XG4gICAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIHNpemVbMV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VwYXJhdGlvbjtcbiAgICAgIHNlcGFyYXRpb24gPSB4O1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IG51bGwgOiBzaXplO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IHNpemUgOiBudWxsO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpICE9IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKGNsdXN0ZXIsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbikge1xuICAgIHJldHVybiAxICsgZDMubWF4KGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJYKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbih4LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHggKyBjaGlsZC54O1xuICAgIH0sIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyTGVmdChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID8gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KGNoaWxkcmVuWzBdKSA6IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpID8gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChjaGlsZHJlbltuIC0gMV0pIDogbm9kZTtcbiAgfVxuICBkMy5sYXlvdXQudHJlZW1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCksIHJvdW5kID0gTWF0aC5yb3VuZCwgc2l6ZSA9IFsgMSwgMSBdLCBwYWRkaW5nID0gbnVsbCwgcGFkID0gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsLCBzdGlja3kgPSBmYWxzZSwgc3RpY2tpZXMsIG1vZGUgPSBcInNxdWFyaWZ5XCIsIHJhdGlvID0gLjUgKiAoMSArIE1hdGguc3FydCg1KSk7XG4gICAgZnVuY3Rpb24gc2NhbGUoY2hpbGRyZW4sIGspIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGgsIGNoaWxkLCBhcmVhO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYXJlYSA9IChjaGlsZCA9IGNoaWxkcmVuW2ldKS52YWx1ZSAqIChrIDwgMCA/IDAgOiBrKTtcbiAgICAgICAgY2hpbGQuYXJlYSA9IGlzTmFOKGFyZWEpIHx8IGFyZWEgPD0gMCA/IDAgOiBhcmVhO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzcXVhcmlmeShub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHBhZChub2RlKSwgcm93ID0gW10sIHJlbWFpbmluZyA9IGNoaWxkcmVuLnNsaWNlKCksIGNoaWxkLCBiZXN0ID0gSW5maW5pdHksIHNjb3JlLCB1ID0gbW9kZSA9PT0gXCJzbGljZVwiID8gcmVjdC5keCA6IG1vZGUgPT09IFwiZGljZVwiID8gcmVjdC5keSA6IG1vZGUgPT09IFwic2xpY2UtZGljZVwiID8gbm9kZS5kZXB0aCAmIDEgPyByZWN0LmR5IDogcmVjdC5keCA6IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpLCBuO1xuICAgICAgICBzY2FsZShyZW1haW5pbmcsIHJlY3QuZHggKiByZWN0LmR5IC8gbm9kZS52YWx1ZSk7XG4gICAgICAgIHJvdy5hcmVhID0gMDtcbiAgICAgICAgd2hpbGUgKChuID0gcmVtYWluaW5nLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgcm93LnB1c2goY2hpbGQgPSByZW1haW5pbmdbbiAtIDFdKTtcbiAgICAgICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xuICAgICAgICAgIGlmIChtb2RlICE9PSBcInNxdWFyaWZ5XCIgfHwgKHNjb3JlID0gd29yc3Qocm93LCB1KSkgPD0gYmVzdCkge1xuICAgICAgICAgICAgcmVtYWluaW5nLnBvcCgpO1xuICAgICAgICAgICAgYmVzdCA9IHNjb3JlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3cuYXJlYSAtPSByb3cucG9wKCkuYXJlYTtcbiAgICAgICAgICAgIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgdSA9IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICAgIGJlc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgICAgICBwb3NpdGlvbihyb3csIHUsIHJlY3QsIHRydWUpO1xuICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzcXVhcmlmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0aWNraWZ5KG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gcGFkKG5vZGUpLCByZW1haW5pbmcgPSBjaGlsZHJlbi5zbGljZSgpLCBjaGlsZCwgcm93ID0gW107XG4gICAgICAgIHNjYWxlKHJlbWFpbmluZywgcmVjdC5keCAqIHJlY3QuZHkgLyBub2RlLnZhbHVlKTtcbiAgICAgICAgcm93LmFyZWEgPSAwO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSByZW1haW5pbmcucG9wKCkpIHtcbiAgICAgICAgICByb3cucHVzaChjaGlsZCk7XG4gICAgICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgICAgICBpZiAoY2hpbGQueiAhPSBudWxsKSB7XG4gICAgICAgICAgICBwb3NpdGlvbihyb3csIGNoaWxkLnogPyByZWN0LmR4IDogcmVjdC5keSwgcmVjdCwgIXJlbWFpbmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzdGlja2lmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcnN0KHJvdywgdSkge1xuICAgICAgdmFyIHMgPSByb3cuYXJlYSwgciwgcm1heCA9IDAsIHJtaW4gPSBJbmZpbml0eSwgaSA9IC0xLCBuID0gcm93Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICghKHIgPSByb3dbaV0uYXJlYSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAociA8IHJtaW4pIHJtaW4gPSByO1xuICAgICAgICBpZiAociA+IHJtYXgpIHJtYXggPSByO1xuICAgICAgfVxuICAgICAgcyAqPSBzO1xuICAgICAgdSAqPSB1O1xuICAgICAgcmV0dXJuIHMgPyBNYXRoLm1heCh1ICogcm1heCAqIHJhdGlvIC8gcywgcyAvICh1ICogcm1pbiAqIHJhdGlvKSkgOiBJbmZpbml0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb24ocm93LCB1LCByZWN0LCBmbHVzaCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHJvdy5sZW5ndGgsIHggPSByZWN0LngsIHkgPSByZWN0LnksIHYgPSB1ID8gcm91bmQocm93LmFyZWEgLyB1KSA6IDAsIG87XG4gICAgICBpZiAodSA9PSByZWN0LmR4KSB7XG4gICAgICAgIGlmIChmbHVzaCB8fCB2ID4gcmVjdC5keSkgdiA9IHJlY3QuZHk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IHJvd1tpXTtcbiAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgIG8ueSA9IHk7XG4gICAgICAgICAgby5keSA9IHY7XG4gICAgICAgICAgeCArPSBvLmR4ID0gTWF0aC5taW4ocmVjdC54ICsgcmVjdC5keCAtIHgsIHYgPyByb3VuZChvLmFyZWEgLyB2KSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIG8ueiA9IHRydWU7XG4gICAgICAgIG8uZHggKz0gcmVjdC54ICsgcmVjdC5keCAtIHg7XG4gICAgICAgIHJlY3QueSArPSB2O1xuICAgICAgICByZWN0LmR5IC09IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmx1c2ggfHwgdiA+IHJlY3QuZHgpIHYgPSByZWN0LmR4O1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSByb3dbaV07XG4gICAgICAgICAgby54ID0geDtcbiAgICAgICAgICBvLnkgPSB5O1xuICAgICAgICAgIG8uZHggPSB2O1xuICAgICAgICAgIHkgKz0gby5keSA9IE1hdGgubWluKHJlY3QueSArIHJlY3QuZHkgLSB5LCB2ID8gcm91bmQoby5hcmVhIC8gdikgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBvLnogPSBmYWxzZTtcbiAgICAgICAgby5keSArPSByZWN0LnkgKyByZWN0LmR5IC0geTtcbiAgICAgICAgcmVjdC54ICs9IHY7XG4gICAgICAgIHJlY3QuZHggLT0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJlZW1hcChkKSB7XG4gICAgICB2YXIgbm9kZXMgPSBzdGlja2llcyB8fCBoaWVyYXJjaHkoZCksIHJvb3QgPSBub2Rlc1swXTtcbiAgICAgIHJvb3QueCA9IHJvb3QueSA9IDA7XG4gICAgICBpZiAocm9vdC52YWx1ZSkgcm9vdC5keCA9IHNpemVbMF0sIHJvb3QuZHkgPSBzaXplWzFdOyBlbHNlIHJvb3QuZHggPSByb290LmR5ID0gMDtcbiAgICAgIGlmIChzdGlja2llcykgaGllcmFyY2h5LnJldmFsdWUocm9vdCk7XG4gICAgICBzY2FsZShbIHJvb3QgXSwgcm9vdC5keCAqIHJvb3QuZHkgLyByb290LnZhbHVlKTtcbiAgICAgIChzdGlja2llcyA/IHN0aWNraWZ5IDogc3F1YXJpZnkpKHJvb3QpO1xuICAgICAgaWYgKHN0aWNreSkgc3RpY2tpZXMgPSBub2RlcztcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgZnVuY3Rpb24gcGFkRnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHguY2FsbCh0cmVlbWFwLCBub2RlLCBub2RlLmRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHAgPT0gbnVsbCA/IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbChub2RlKSA6IGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHR5cGVvZiBwID09PSBcIm51bWJlclwiID8gWyBwLCBwLCBwLCBwIF0gOiBwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhZENvbnN0YW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHgpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGU7XG4gICAgICBwYWQgPSAocGFkZGluZyA9IHgpID09IG51bGwgPyBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwgOiAodHlwZSA9IHR5cGVvZiB4KSA9PT0gXCJmdW5jdGlvblwiID8gcGFkRnVuY3Rpb24gOiB0eXBlID09PSBcIm51bWJlclwiID8gKHggPSBbIHgsIHgsIHgsIHggXSwgXG4gICAgICBwYWRDb25zdGFudCkgOiBwYWRDb25zdGFudDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJvdW5kICE9IE51bWJlcjtcbiAgICAgIHJvdW5kID0geCA/IE1hdGgucm91bmQgOiBOdW1iZXI7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAuc3RpY2t5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RpY2t5O1xuICAgICAgc3RpY2t5ID0geDtcbiAgICAgIHN0aWNraWVzID0gbnVsbDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhdGlvO1xuICAgICAgcmF0aW8gPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLm1vZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtb2RlO1xuICAgICAgbW9kZSA9IHggKyBcIlwiO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZCh0cmVlbWFwLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwobm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBub2RlLngsXG4gICAgICB5OiBub2RlLnksXG4gICAgICBkeDogbm9kZS5keCxcbiAgICAgIGR5OiBub2RlLmR5XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCBwYWRkaW5nKSB7XG4gICAgdmFyIHggPSBub2RlLnggKyBwYWRkaW5nWzNdLCB5ID0gbm9kZS55ICsgcGFkZGluZ1swXSwgZHggPSBub2RlLmR4IC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sIGR5ID0gbm9kZS5keSAtIHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdO1xuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHggKz0gZHggLyAyO1xuICAgICAgZHggPSAwO1xuICAgIH1cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICB5ICs9IGR5IC8gMjtcbiAgICAgIGR5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgZHg6IGR4LFxuICAgICAgZHk6IGR5XG4gICAgfTtcbiAgfVxuICBkMy5yYW5kb20gPSB7XG4gICAgbm9ybWFsOiBmdW5jdGlvbijCtSwgz4MpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChuIDwgMikgz4MgPSAxO1xuICAgICAgaWYgKG4gPCAxKSDCtSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4LCB5LCByO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgeCA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICB5ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgIHIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG4gICAgICAgIHJldHVybiDCtSArIM+DICogeCAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgbG9nTm9ybWFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYW5kb20gPSBkMy5yYW5kb20ubm9ybWFsLmFwcGx5KGQzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAocmFuZG9tKCkpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGJhdGVzOiBmdW5jdGlvbihtKSB7XG4gICAgICB2YXIgcmFuZG9tID0gZDMucmFuZG9tLmlyd2luSGFsbChtKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbSgpIC8gbTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBpcndpbkhhbGw6IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGogPSAwOyBqIDwgbTsgaisrKSBzICs9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGQzLnNjYWxlID0ge307XG4gIGZ1bmN0aW9uIGQzX3NjYWxlRXh0ZW50KGRvbWFpbikge1xuICAgIHZhciBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFsgc3RhcnQsIHN0b3AgXSA6IFsgc3RvcCwgc3RhcnQgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZVJhbmdlKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlLnJhbmdlRXh0ZW50ID8gc2NhbGUucmFuZ2VFeHRlbnQoKSA6IGQzX3NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2JpbGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gICAgdmFyIHUgPSB1bmludGVycG9sYXRlKGRvbWFpblswXSwgZG9tYWluWzFdKSwgaSA9IGludGVycG9sYXRlKHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBpKHUoeCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbmljZShkb21haW4sIG5pY2UpIHtcbiAgICB2YXIgaTAgPSAwLCBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLCB4MCA9IGRvbWFpbltpMF0sIHgxID0gZG9tYWluW2kxXSwgZHg7XG4gICAgaWYgKHgxIDwgeDApIHtcbiAgICAgIGR4ID0gaTAsIGkwID0gaTEsIGkxID0gZHg7XG4gICAgICBkeCA9IHgwLCB4MCA9IHgxLCB4MSA9IGR4O1xuICAgIH1cbiAgICBkb21haW5baTBdID0gbmljZS5mbG9vcih4MCk7XG4gICAgZG9tYWluW2kxXSA9IG5pY2UuY2VpbCh4MSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9uaWNlU3RlcChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXAgPyB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfVxuICAgIH0gOiBkM19zY2FsZV9uaWNlSWRlbnRpdHk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX25pY2VJZGVudGl0eSA9IHtcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG9seWxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciB1ID0gW10sIGkgPSBbXSwgaiA9IDAsIGsgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMTtcbiAgICBpZiAoZG9tYWluW2tdIDwgZG9tYWluWzBdKSB7XG4gICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB3aGlsZSAoKytqIDw9IGspIHtcbiAgICAgIHUucHVzaCh1bmludGVycG9sYXRlKGRvbWFpbltqIC0gMV0sIGRvbWFpbltqXSkpO1xuICAgICAgaS5wdXNoKGludGVycG9sYXRlKHJhbmdlW2ogLSAxXSwgcmFuZ2Vbal0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBqID0gZDMuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaykgLSAxO1xuICAgICAgcmV0dXJuIGlbal0odVtqXSh4KSk7XG4gICAgfTtcbiAgfVxuICBkMy5zY2FsZS5saW5lYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKFsgMCwgMSBdLCBbIDAsIDEgXSwgZDNfaW50ZXJwb2xhdGUsIGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCkge1xuICAgIHZhciBvdXRwdXQsIGlucHV0O1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgbGluZWFyID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSA+IDIgPyBkM19zY2FsZV9wb2x5bGluZWFyIDogZDNfc2NhbGVfYmlsaW5lYXIsIHVuaW50ZXJwb2xhdGUgPSBjbGFtcCA/IGQzX3VuaW50ZXJwb2xhdGVDbGFtcCA6IGQzX3VuaW50ZXJwb2xhdGVOdW1iZXI7XG4gICAgICBvdXRwdXQgPSBsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICAgICAgaW5wdXQgPSBsaW5lYXIocmFuZ2UsIGRvbWFpbiwgdW5pbnRlcnBvbGF0ZSwgZDNfaW50ZXJwb2xhdGUpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gb3V0cHV0KHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gaW5wdXQoeSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChOdW1iZXIpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBzY2FsZS5yYW5nZSh4KS5pbnRlcnBvbGF0ZShkM19pbnRlcnBvbGF0ZVJvdW5kKTtcbiAgICB9O1xuICAgIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xhbXA7XG4gICAgICBjbGFtcCA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICAgIGludGVycG9sYXRlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKSB7XG4gICAgcmV0dXJuIGQzLnJlYmluZChzY2FsZSwgbGluZWFyLCBcInJhbmdlXCIsIFwicmFuZ2VSb3VuZFwiLCBcImludGVycG9sYXRlXCIsIFwiY2xhbXBcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pIHtcbiAgICBkM19zY2FsZV9uaWNlKGRvbWFpbiwgZDNfc2NhbGVfbmljZVN0ZXAoZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSlbMl0pKTtcbiAgICBkM19zY2FsZV9uaWNlKGRvbWFpbiwgZDNfc2NhbGVfbmljZVN0ZXAoZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSlbMl0pKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pIHtcbiAgICBpZiAobSA9PSBudWxsKSBtID0gMTA7XG4gICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIHN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzcGFuIC8gbSkgLyBNYXRoLkxOMTApKSwgZXJyID0gbSAvIHNwYW4gKiBzdGVwO1xuICAgIGlmIChlcnIgPD0gLjE1KSBzdGVwICo9IDEwOyBlbHNlIGlmIChlcnIgPD0gLjM1KSBzdGVwICo9IDU7IGVsc2UgaWYgKGVyciA8PSAuNzUpIHN0ZXAgKj0gMjtcbiAgICBleHRlbnRbMF0gPSBNYXRoLmNlaWwoZXh0ZW50WzBdIC8gc3RlcCkgKiBzdGVwO1xuICAgIGV4dGVudFsxXSA9IE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gc3RlcCkgKiBzdGVwICsgc3RlcCAqIC41O1xuICAgIGV4dGVudFsyXSA9IHN0ZXA7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pIHtcbiAgICByZXR1cm4gZDMucmFuZ2UuYXBwbHkoZDMsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KSB7XG4gICAgdmFyIHJhbmdlID0gZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSk7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgdmFyIG1hdGNoID0gZDNfZm9ybWF0X3JlLmV4ZWMoZm9ybWF0KTtcbiAgICAgIG1hdGNoLnNoaWZ0KCk7XG4gICAgICBpZiAobWF0Y2hbOF0gPT09IFwic1wiKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBkMy5mb3JtYXRQcmVmaXgoTWF0aC5tYXgoYWJzKHJhbmdlWzBdKSwgYWJzKHJhbmdlWzFdKSkpO1xuICAgICAgICBpZiAoIW1hdGNoWzddKSBtYXRjaFs3XSA9IFwiLlwiICsgZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHByZWZpeC5zY2FsZShyYW5nZVsyXSkpO1xuICAgICAgICBtYXRjaFs4XSA9IFwiZlwiO1xuICAgICAgICBmb3JtYXQgPSBkMy5mb3JtYXQobWF0Y2guam9pbihcIlwiKSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdChwcmVmaXguc2NhbGUoZCkpICsgcHJlZml4LnN5bWJvbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2hbN10pIG1hdGNoWzddID0gXCIuXCIgKyBkM19zY2FsZV9saW5lYXJGb3JtYXRQcmVjaXNpb24obWF0Y2hbOF0sIHJhbmdlKTtcbiAgICAgIGZvcm1hdCA9IG1hdGNoLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdCA9IFwiLC5cIiArIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihyYW5nZVsyXSkgKyBcImZcIjtcbiAgICB9XG4gICAgcmV0dXJuIGQzLmZvcm1hdChmb3JtYXQpO1xuICB9XG4gIHZhciBkM19zY2FsZV9saW5lYXJGb3JtYXRTaWduaWZpY2FudCA9IHtcbiAgICBzOiAxLFxuICAgIGc6IDEsXG4gICAgcDogMSxcbiAgICByOiAxLFxuICAgIGU6IDFcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCArIC4wMSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyRm9ybWF0UHJlY2lzaW9uKHR5cGUsIHJhbmdlKSB7XG4gICAgdmFyIHAgPSBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocmFuZ2VbMl0pO1xuICAgIHJldHVybiB0eXBlIGluIGQzX3NjYWxlX2xpbmVhckZvcm1hdFNpZ25pZmljYW50ID8gTWF0aC5hYnMocCAtIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihNYXRoLm1heChhYnMocmFuZ2VbMF0pLCBhYnMocmFuZ2VbMV0pKSkpICsgKyh0eXBlICE9PSBcImVcIikgOiBwIC0gKHR5cGUgPT09IFwiJVwiKSAqIDI7XG4gIH1cbiAgZDMuc2NhbGUubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xvZyhkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWyAwLCAxIF0pLCAxMCwgdHJ1ZSwgWyAxLCAxMCBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbG9nKGxpbmVhciwgYmFzZSwgcG9zaXRpdmUsIGRvbWFpbikge1xuICAgIGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICByZXR1cm4gKHBvc2l0aXZlID8gTWF0aC5sb2coeCA8IDAgPyAwIDogeCkgOiAtTWF0aC5sb2coeCA+IDAgPyAwIDogLXgpKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3coeCkge1xuICAgICAgcmV0dXJuIHBvc2l0aXZlID8gTWF0aC5wb3coYmFzZSwgeCkgOiAtTWF0aC5wb3coYmFzZSwgLXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKGxvZyh4KSk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBwb3cobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBwb3NpdGl2ZSA9IHhbMF0gPj0gMDtcbiAgICAgIGxpbmVhci5kb21haW4oKGRvbWFpbiA9IHgubWFwKE51bWJlcikpLm1hcChsb2cpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYXNlO1xuICAgICAgYmFzZSA9ICtfO1xuICAgICAgbGluZWFyLmRvbWFpbihkb21haW4ubWFwKGxvZykpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5pY2VkID0gZDNfc2NhbGVfbmljZShkb21haW4ubWFwKGxvZyksIHBvc2l0aXZlID8gTWF0aCA6IGQzX3NjYWxlX2xvZ05pY2VOZWdhdGl2ZSk7XG4gICAgICBsaW5lYXIuZG9tYWluKG5pY2VkKTtcbiAgICAgIGRvbWFpbiA9IG5pY2VkLm1hcChwb3cpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCB0aWNrcyA9IFtdLCB1ID0gZXh0ZW50WzBdLCB2ID0gZXh0ZW50WzFdLCBpID0gTWF0aC5mbG9vcihsb2codSkpLCBqID0gTWF0aC5jZWlsKGxvZyh2KSksIG4gPSBiYXNlICUgMSA/IDIgOiBiYXNlO1xuICAgICAgaWYgKGlzRmluaXRlKGogLSBpKSkge1xuICAgICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgICBmb3IgKDtpIDwgajsgaSsrKSBmb3IgKHZhciBrID0gMTsgayA8IG47IGsrKykgdGlja3MucHVzaChwb3coaSkgKiBrKTtcbiAgICAgICAgICB0aWNrcy5wdXNoKHBvdyhpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja3MucHVzaChwb3coaSkpO1xuICAgICAgICAgIGZvciAoO2krKyA8IGo7ICkgZm9yICh2YXIgayA9IG4gLSAxOyBrID4gMDsgay0tKSB0aWNrcy5wdXNoKHBvdyhpKSAqIGspO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IHRpY2tzW2ldIDwgdTsgaSsrKSB7fVxuICAgICAgICBmb3IgKGogPSB0aWNrcy5sZW5ndGg7IHRpY2tzW2ogLSAxXSA+IHY7IGotLSkge31cbiAgICAgICAgdGlja3MgPSB0aWNrcy5zbGljZShpLCBqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrcztcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihuLCBmb3JtYXQpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGQzX3NjYWxlX2xvZ0Zvcm1hdDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgZm9ybWF0ID0gZDNfc2NhbGVfbG9nRm9ybWF0OyBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9PSBcImZ1bmN0aW9uXCIpIGZvcm1hdCA9IGQzLmZvcm1hdChmb3JtYXQpO1xuICAgICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogbiAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpID0gZCAvIHBvdyhNYXRoLnJvdW5kKGxvZyhkKSkpO1xuICAgICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gLjUpIGkgKj0gYmFzZTtcbiAgICAgICAgcmV0dXJuIGkgPD0gayA/IGZvcm1hdChkKSA6IFwiXCI7XG4gICAgICB9O1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xvZyhsaW5lYXIuY29weSgpLCBiYXNlLCBwb3NpdGl2ZSwgZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX2xvZ0Zvcm1hdCA9IGQzLmZvcm1hdChcIi4wZVwiKSwgZDNfc2NhbGVfbG9nTmljZU5lZ2F0aXZlID0ge1xuICAgIGZsb29yOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLU1hdGguY2VpbCgteCk7XG4gICAgfSxcbiAgICBjZWlsOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLU1hdGguZmxvb3IoLXgpO1xuICAgIH1cbiAgfTtcbiAgZDMuc2NhbGUucG93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3BvdyhkMy5zY2FsZS5saW5lYXIoKSwgMSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9wb3cobGluZWFyLCBleHBvbmVudCwgZG9tYWluKSB7XG4gICAgdmFyIHBvd3AgPSBkM19zY2FsZV9wb3dQb3coZXhwb25lbnQpLCBwb3diID0gZDNfc2NhbGVfcG93UG93KDEgLyBleHBvbmVudCk7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcihwb3dwKHgpKTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBvd2IobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBsaW5lYXIuZG9tYWluKChkb21haW4gPSB4Lm1hcChOdW1iZXIpKS5tYXAocG93cCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gc2NhbGUuZG9tYWluKGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKSk7XG4gICAgfTtcbiAgICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGV4cG9uZW50O1xuICAgICAgcG93cCA9IGQzX3NjYWxlX3Bvd1BvdyhleHBvbmVudCA9IHgpO1xuICAgICAgcG93YiA9IGQzX3NjYWxlX3Bvd1BvdygxIC8gZXhwb25lbnQpO1xuICAgICAgbGluZWFyLmRvbWFpbihkb21haW4ubWFwKHBvd3ApKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9wb3cobGluZWFyLmNvcHkoKSwgZXhwb25lbnQsIGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3Bvd1BvdyhlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZSkgOiBNYXRoLnBvdyh4LCBlKTtcbiAgICB9O1xuICB9XG4gIGQzLnNjYWxlLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUucG93KCkuZXhwb25lbnQoLjUpO1xuICB9O1xuICBkMy5zY2FsZS5vcmRpbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX29yZGluYWwoW10sIHtcbiAgICAgIHQ6IFwicmFuZ2VcIixcbiAgICAgIGE6IFsgW10gXVxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9vcmRpbmFsKGRvbWFpbiwgcmFuZ2VyKSB7XG4gICAgdmFyIGluZGV4LCByYW5nZSwgcmFuZ2VCYW5kO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiByYW5nZVsoKGluZGV4LmdldCh4KSB8fCAocmFuZ2VyLnQgPT09IFwicmFuZ2VcIiA/IGluZGV4LnNldCh4LCBkb21haW4ucHVzaCh4KSkgOiBOYU4pKSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcHMoc3RhcnQsIHN0ZXApIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShkb21haW4ubGVuZ3RoKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBzdGVwICogaTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSBbXTtcbiAgICAgIGluZGV4ID0gbmV3IGQzX01hcCgpO1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHgubGVuZ3RoLCB4aTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4Lmhhcyh4aSA9IHhbaV0pKSBpbmRleC5zZXQoeGksIGRvbWFpbi5wdXNoKHhpKSk7XG4gICAgICByZXR1cm4gc2NhbGVbcmFuZ2VyLnRdLmFwcGx5KHNjYWxlLCByYW5nZXIuYSk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVwiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVBvaW50cyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICB2YXIgc3RhcnQgPSB4WzBdLCBzdG9wID0geFsxXSwgc3RlcCA9IGRvbWFpbi5sZW5ndGggPCAyID8gKHN0YXJ0ID0gKHN0YXJ0ICsgc3RvcCkgLyAyLCBcbiAgICAgIDApIDogKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBzdGVwICogcGFkZGluZyAvIDIsIHN0ZXApO1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVBvaW50c1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kUG9pbnRzID0gZnVuY3Rpb24oeCwgcGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIHZhciBzdGFydCA9IHhbMF0sIHN0b3AgPSB4WzFdLCBzdGVwID0gZG9tYWluLmxlbmd0aCA8IDIgPyAoc3RhcnQgPSBzdG9wID0gTWF0aC5yb3VuZCgoc3RhcnQgKyBzdG9wKSAvIDIpLCBcbiAgICAgIDApIDogKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKSB8IDA7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgTWF0aC5yb3VuZChzdGVwICogcGFkZGluZyAvIDIgKyAoc3RvcCAtIHN0YXJ0IC0gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZykgKiBzdGVwKSAvIDIpLCBzdGVwKTtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VSb3VuZFBvaW50c1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUJhbmRzID0gZnVuY3Rpb24oeCwgcGFkZGluZywgb3V0ZXJQYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBvdXRlclBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdmFyIHJldmVyc2UgPSB4WzFdIDwgeFswXSwgc3RhcnQgPSB4W3JldmVyc2UgLSAwXSwgc3RvcCA9IHhbMSAtIHJldmVyc2VdLCBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcgKyAyICogb3V0ZXJQYWRkaW5nKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBzdGVwICogb3V0ZXJQYWRkaW5nLCBzdGVwKTtcbiAgICAgIGlmIChyZXZlcnNlKSByYW5nZS5yZXZlcnNlKCk7XG4gICAgICByYW5nZUJhbmQgPSBzdGVwICogKDEgLSBwYWRkaW5nKTtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZUJhbmRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcsIG91dGVyUGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgb3V0ZXJQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIHZhciByZXZlcnNlID0geFsxXSA8IHhbMF0sIHN0YXJ0ID0geFtyZXZlcnNlIC0gMF0sIHN0b3AgPSB4WzEgLSByZXZlcnNlXSwgc3RlcCA9IE1hdGguZmxvb3IoKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcgKyAyICogb3V0ZXJQYWRkaW5nKSk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgTWF0aC5yb3VuZCgoc3RvcCAtIHN0YXJ0IC0gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nKSAqIHN0ZXApIC8gMiksIHN0ZXApO1xuICAgICAgaWYgKHJldmVyc2UpIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlQmFuZCA9IE1hdGgucm91bmQoc3RlcCAqICgxIC0gcGFkZGluZykpO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUm91bmRCYW5kc1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUJhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5nZUJhbmQ7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlRXh0ZW50KHJhbmdlci5hWzBdKTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9vcmRpbmFsKGRvbWFpbiwgcmFuZ2VyKTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgfVxuICBkMy5zY2FsZS5jYXRlZ29yeTEwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTEwKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMCk7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjBiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwYik7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjBjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwYyk7XG4gIH07XG4gIHZhciBkM19jYXRlZ29yeTEwID0gWyAyMDYyMjYwLCAxNjc0NDIwNiwgMjkyNDU4OCwgMTQwMzQ3MjgsIDk3MjU4ODUsIDkxOTcxMzEsIDE0OTA3MzMwLCA4MzU1NzExLCAxMjM2OTE4NiwgMTU1NjE3NSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMCA9IFsgMjA2MjI2MCwgMTE0NTQ0NDAsIDE2NzQ0MjA2LCAxNjc1OTY3MiwgMjkyNDU4OCwgMTAwMTg2OTgsIDE0MDM0NzI4LCAxNjc1MDc0MiwgOTcyNTg4NSwgMTI5NTU4NjEsIDkxOTcxMzEsIDEyODg1MTQwLCAxNDkwNzMzMCwgMTYyMzQxOTQsIDgzNTU3MTEsIDEzMDkyODA3LCAxMjM2OTE4NiwgMTQ0MDg1ODksIDE1NTYxNzUsIDEwNDEwNzI1IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwYiA9IFsgMzc1MDc3NywgNTM5NTYxOSwgNzA0MDcxOSwgMTAyNjQyODYsIDY1MTkwOTcsIDkyMTY1OTQsIDExOTE1MTE1LCAxMzU1NjYzNiwgOTIwMjk5MywgMTI0MjY4MDksIDE1MTg2NTE0LCAxNTE5MDkzMiwgODY2NjE2OSwgMTEzNTY0OTAsIDE0MDQ5NjQzLCAxNTE3NzM3MiwgODA3NzY4MywgMTA4MzQzMjQsIDEzNTI4NTA5LCAxNDU4OTY1NCBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMGMgPSBbIDMyNDQ3MzMsIDcwNTcxMTAsIDEwNDA2NjI1LCAxMzAzMjQzMSwgMTUwOTUwNTMsIDE2NjE2NzY0LCAxNjYyNTI1OSwgMTY2MzQwMTgsIDMyNTMwNzYsIDc2NTI0NzAsIDEwNjA3MDAzLCAxMzEwMTUwNCwgNzY5NTI4MSwgMTAzOTQzMTIsIDEyMzY5MzcyLCAxNDM0Mjg5MSwgNjUxMzUwNywgOTg2ODk1MCwgMTI0MzQ4NzcsIDE0Mjc3MDgxIF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIGQzLnNjYWxlLnF1YW50aWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aWxlKFtdLCBbXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3F1YW50aWxlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICB2YXIgdGhyZXNob2xkcztcbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGsgPSAwLCBxID0gcmFuZ2UubGVuZ3RoO1xuICAgICAgdGhyZXNob2xkcyA9IFtdO1xuICAgICAgd2hpbGUgKCsrayA8IHEpIHRocmVzaG9sZHNbayAtIDFdID0gZDMucXVhbnRpbGUoZG9tYWluLCBrIC8gcSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIHJhbmdlW2QzLmJpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKGQzX251bWJlcikuZmlsdGVyKGQzX251bWVyaWMpLnNvcnQoZDNfYXNjZW5kaW5nKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZHM7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiB5IDwgMCA/IFsgTmFOLCBOYU4gXSA6IFsgeSA+IDAgPyB0aHJlc2hvbGRzW3kgLSAxXSA6IGRvbWFpblswXSwgeSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1t5XSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9xdWFudGlsZShkb21haW4sIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZDMuc2NhbGUucXVhbnRpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpemUoMCwgMSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9xdWFudGl6ZSh4MCwgeDEsIHJhbmdlKSB7XG4gICAgdmFyIGt4LCBpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihpLCBNYXRoLmZsb29yKGt4ICogKHggLSB4MCkpKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAga3ggPSByYW5nZS5sZW5ndGggLyAoeDEgLSB4MCk7XG4gICAgICBpID0gcmFuZ2UubGVuZ3RoIC0gMTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB4MCwgeDEgXTtcbiAgICAgIHgwID0gK3hbMF07XG4gICAgICB4MSA9ICt4W3gubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHkgPSB5IDwgMCA/IE5hTiA6IHkgLyBreCArIHgwO1xuICAgICAgcmV0dXJuIFsgeSwgeSArIDEgLyBreCBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aXplKHgwLCB4MSwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBkMy5zY2FsZS50aHJlc2hvbGQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfdGhyZXNob2xkKFsgLjUgXSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV90aHJlc2hvbGQoZG9tYWluLCByYW5nZSkge1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZVtkMy5iaXNlY3QoZG9tYWluLCB4KV07XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IF87XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSBfO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICByZXR1cm4gWyBkb21haW5beSAtIDFdLCBkb21haW5beV0gXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV90aHJlc2hvbGQoZG9tYWluLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cbiAgZDMuc2NhbGUuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfaWRlbnRpdHkoWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9pZGVudGl0eShkb21haW4pIHtcbiAgICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgICByZXR1cm4gK3g7XG4gICAgfVxuICAgIGlkZW50aXR5LmludmVydCA9IGlkZW50aXR5O1xuICAgIGlkZW50aXR5LmRvbWFpbiA9IGlkZW50aXR5LnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoaWRlbnRpdHkpO1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH07XG4gICAgaWRlbnRpdHkudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIGlkZW50aXR5LnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIGlkZW50aXR5LmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9pZGVudGl0eShkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGQzLnN2ZyA9IHt9O1xuICBmdW5jdGlvbiBkM196ZXJvKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGQzLnN2Zy5hcmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSBkM19zdmdfYXJjSW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzID0gZDNfc3ZnX2FyY091dGVyUmFkaXVzLCBjb3JuZXJSYWRpdXMgPSBkM196ZXJvLCBwYWRSYWRpdXMgPSBkM19zdmdfYXJjQXV0bywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZSwgcGFkQW5nbGUgPSBkM19zdmdfYXJjUGFkQW5nbGU7XG4gICAgZnVuY3Rpb24gYXJjKCkge1xuICAgICAgdmFyIHIwID0gTWF0aC5tYXgoMCwgK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByMSA9IE1hdGgubWF4KDAsICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmz4AsIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGbPgCwgZGEgPSBNYXRoLmFicyhhMSAtIGEwKSwgY3cgPSBhMCA+IGExID8gMCA6IDE7XG4gICAgICBpZiAocjEgPCByMCkgcmMgPSByMSwgcjEgPSByMCwgcjAgPSByYztcbiAgICAgIGlmIChkYSA+PSDPhM61KSByZXR1cm4gY2lyY2xlU2VnbWVudChyMSwgY3cpICsgKHIwID8gY2lyY2xlU2VnbWVudChyMCwgMSAtIGN3KSA6IFwiXCIpICsgXCJaXCI7XG4gICAgICB2YXIgcmMsIGNyLCBycCwgYXAsIHAwID0gMCwgcDEgPSAwLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHBhdGggPSBbXTtcbiAgICAgIGlmIChhcCA9ICgrcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwKSAvIDIpIHtcbiAgICAgICAgcnAgPSBwYWRSYWRpdXMgPT09IGQzX3N2Z19hcmNBdXRvID8gTWF0aC5zcXJ0KHIwICogcjAgKyByMSAqIHIxKSA6ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFjdykgcDEgKj0gLTE7XG4gICAgICAgIGlmIChyMSkgcDEgPSBkM19hc2luKHJwIC8gcjEgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgICBpZiAocjApIHAwID0gZDNfYXNpbihycCAvIHIwICogTWF0aC5zaW4oYXApKTtcbiAgICAgIH1cbiAgICAgIGlmIChyMSkge1xuICAgICAgICB4MCA9IHIxICogTWF0aC5jb3MoYTAgKyBwMSk7XG4gICAgICAgIHkwID0gcjEgKiBNYXRoLnNpbihhMCArIHAxKTtcbiAgICAgICAgeDEgPSByMSAqIE1hdGguY29zKGExIC0gcDEpO1xuICAgICAgICB5MSA9IHIxICogTWF0aC5zaW4oYTEgLSBwMSk7XG4gICAgICAgIHZhciBsMSA9IE1hdGguYWJzKGExIC0gYTAgLSAyICogcDEpIDw9IM+AID8gMCA6IDE7XG4gICAgICAgIGlmIChwMSAmJiBkM19zdmdfYXJjU3dlZXAoeDAsIHkwLCB4MSwgeTEpID09PSBjdyBeIGwxKSB7XG4gICAgICAgICAgdmFyIGgxID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICB4MCA9IHIxICogTWF0aC5jb3MoaDEpO1xuICAgICAgICAgIHkwID0gcjEgKiBNYXRoLnNpbihoMSk7XG4gICAgICAgICAgeDEgPSB5MSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwID0geTAgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHIwKSB7XG4gICAgICAgIHgyID0gcjAgKiBNYXRoLmNvcyhhMSAtIHAwKTtcbiAgICAgICAgeTIgPSByMCAqIE1hdGguc2luKGExIC0gcDApO1xuICAgICAgICB4MyA9IHIwICogTWF0aC5jb3MoYTAgKyBwMCk7XG4gICAgICAgIHkzID0gcjAgKiBNYXRoLnNpbihhMCArIHAwKTtcbiAgICAgICAgdmFyIGwwID0gTWF0aC5hYnMoYTAgLSBhMSArIDIgKiBwMCkgPD0gz4AgPyAwIDogMTtcbiAgICAgICAgaWYgKHAwICYmIGQzX3N2Z19hcmNTd2VlcCh4MiwgeTIsIHgzLCB5MykgPT09IDEgLSBjdyBeIGwwKSB7XG4gICAgICAgICAgdmFyIGgwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICB4MiA9IHIwICogTWF0aC5jb3MoaDApO1xuICAgICAgICAgIHkyID0gcjAgKiBNYXRoLnNpbihoMCk7XG4gICAgICAgICAgeDMgPSB5MyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0geTIgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGRhID4gzrUgJiYgKHJjID0gTWF0aC5taW4oTWF0aC5hYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSA+IC4wMDEpIHtcbiAgICAgICAgY3IgPSByMCA8IHIxIF4gY3cgPyAwIDogMTtcbiAgICAgICAgdmFyIHJjMSA9IHJjLCByYzAgPSByYztcbiAgICAgICAgaWYgKGRhIDwgz4ApIHtcbiAgICAgICAgICB2YXIgb2MgPSB4MyA9PSBudWxsID8gWyB4MiwgeTIgXSA6IHgxID09IG51bGwgPyBbIHgwLCB5MCBdIDogZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KFsgeDAsIHkwIF0sIFsgeDMsIHkzIF0sIFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0pLCBheCA9IHgwIC0gb2NbMF0sIGF5ID0geTAgLSBvY1sxXSwgYnggPSB4MSAtIG9jWzBdLCBieSA9IHkxIC0gb2NbMV0sIGtjID0gMSAvIE1hdGguc2luKE1hdGguYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSwgbGMgPSBNYXRoLnNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IE1hdGgubWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0MzAgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoeDMgPT0gbnVsbCA/IFsgeDIsIHkyIF0gOiBbIHgzLCB5MyBdLCBbIHgwLCB5MCBdLCByMSwgcmMxLCBjdyksIHQxMiA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgxLCB5MSBdLCBbIHgyLCB5MiBdLCByMSwgcmMxLCBjdyk7XG4gICAgICAgICAgaWYgKHJjID09PSByYzEpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgdDMwWzBdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDMwWzFdLCBcIkFcIiwgcjEsIFwiLFwiLCByMSwgXCIgMCBcIiwgMSAtIGN3IF4gZDNfc3ZnX2FyY1N3ZWVwKHQzMFsxXVswXSwgdDMwWzFdWzFdLCB0MTJbMV1bMF0sIHQxMlsxXVsxXSksIFwiLFwiLCBjdywgXCIgXCIsIHQxMlsxXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQxMlswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgdDMwWzBdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDEsXCIsIGNyLCBcIiBcIiwgdDEyWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB4MCwgXCIsXCIsIHkwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDMgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0MDMgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MCwgeTAgXSwgWyB4MywgeTMgXSwgcjAsIC1yYzAsIGN3KSwgdDIxID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDIsIHkyIF0sIHgxID09IG51bGwgPyBbIHgwLCB5MCBdIDogWyB4MSwgeTEgXSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgICBpZiAocmMgPT09IHJjMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB0MjFbMF0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MjFbMV0sIFwiQVwiLCByMCwgXCIsXCIsIHIwLCBcIiAwIFwiLCBjdyBeIGQzX3N2Z19hcmNTd2VlcCh0MjFbMV1bMF0sIHQyMVsxXVsxXSwgdDAzWzFdWzBdLCB0MDNbMV1bMV0pLCBcIixcIiwgMSAtIGN3LCBcIiBcIiwgdDAzWzFdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDAzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB0MjFbMF0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MDNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHgyLCBcIixcIiwgeTIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHgwLCBcIixcIiwgeTApO1xuICAgICAgICBpZiAoeDEgIT0gbnVsbCkgcGF0aC5wdXNoKFwiQVwiLCByMSwgXCIsXCIsIHIxLCBcIiAwIFwiLCBsMSwgXCIsXCIsIGN3LCBcIiBcIiwgeDEsIFwiLFwiLCB5MSk7XG4gICAgICAgIHBhdGgucHVzaChcIkxcIiwgeDIsIFwiLFwiLCB5Mik7XG4gICAgICAgIGlmICh4MyAhPSBudWxsKSBwYXRoLnB1c2goXCJBXCIsIHIwLCBcIixcIiwgcjAsIFwiIDAgXCIsIGwwLCBcIixcIiwgMSAtIGN3LCBcIiBcIiwgeDMsIFwiLFwiLCB5Myk7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goXCJaXCIpO1xuICAgICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2lyY2xlU2VnbWVudChyMSwgY3cpIHtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcjEgKyBcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiIDAgMSxcIiArIGN3ICsgXCIgMCxcIiArIC1yMSArIFwiQVwiICsgcjEgKyBcIixcIiArIHIxICsgXCIgMCAxLFwiICsgY3cgKyBcIiAwLFwiICsgcjE7XG4gICAgfVxuICAgIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dGVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb3JuZXJSYWRpdXM7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRSYWRpdXM7XG4gICAgICBwYWRSYWRpdXMgPSB2ID09IGQzX3N2Z19hcmNBdXRvID8gZDNfc3ZnX2FyY0F1dG8gOiBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLCBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgTWF0aC5jb3MoYSkgKiByLCBNYXRoLnNpbihhKSAqIHIgXTtcbiAgICB9O1xuICAgIHJldHVybiBhcmM7XG4gIH07XG4gIHZhciBkM19zdmdfYXJjQXV0byA9IFwiYXV0b1wiO1xuICBmdW5jdGlvbiBkM19zdmdfYXJjSW5uZXJSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLmlubmVyUmFkaXVzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNPdXRlclJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUoZCkge1xuICAgIHJldHVybiBkLnN0YXJ0QW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0VuZEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZC5lbmRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjUGFkQW5nbGUoZCkge1xuICAgIHJldHVybiBkICYmIGQucGFkQW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1N3ZWVwKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuICh4MCAtIHgxKSAqIHkwIC0gKHkwIC0geTEpICogeDAgPiAwID8gMCA6IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKHAwLCBwMSwgcjEsIHJjLCBjdykge1xuICAgIHZhciB4MDEgPSBwMFswXSAtIHAxWzBdLCB5MDEgPSBwMFsxXSAtIHAxWzFdLCBsbyA9IChjdyA/IHJjIDogLXJjKSAvIE1hdGguc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLCBveCA9IGxvICogeTAxLCBveSA9IC1sbyAqIHgwMSwgeDEgPSBwMFswXSArIG94LCB5MSA9IHAwWzFdICsgb3ksIHgyID0gcDFbMF0gKyBveCwgeTIgPSBwMVsxXSArIG95LCB4MyA9ICh4MSArIHgyKSAvIDIsIHkzID0gKHkxICsgeTIpIC8gMiwgZHggPSB4MiAtIHgxLCBkeSA9IHkyIC0geTEsIGQyID0gZHggKiBkeCArIGR5ICogZHksIHIgPSByMSAtIHJjLCBEID0geDEgKiB5MiAtIHgyICogeTEsIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIE1hdGguc3FydChNYXRoLm1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSwgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMiwgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLCBkeDAgPSBjeDAgLSB4MywgZHkwID0gY3kwIC0geTMsIGR4MSA9IGN4MSAtIHgzLCBkeTEgPSBjeTEgLSB5MztcbiAgICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcbiAgICByZXR1cm4gWyBbIGN4MCAtIG94LCBjeTAgLSBveSBdLCBbIGN4MCAqIHIxIC8gciwgY3kwICogcjEgLyByIF0gXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZShwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBkZWZpbmVkID0gZDNfdHJ1ZSwgaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUxpbmVhciwgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZS5rZXksIHRlbnNpb24gPSAuNztcbiAgICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBwb2ludHMgPSBbXSwgaSA9IC0xLCBuID0gZGF0YS5sZW5ndGgsIGQsIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpO1xuICAgICAgZnVuY3Rpb24gc2VnbWVudCgpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChcIk1cIiwgaW50ZXJwb2xhdGUocHJvamVjdGlvbihwb2ludHMpLCB0ZW5zaW9uKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZCwgaSksICtmeS5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiKSBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlID0gXzsgZWxzZSBpbnRlcnBvbGF0ZUtleSA9IChpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5nZXQoXykgfHwgZDNfc3ZnX2xpbmVMaW5lYXIpLmtleTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS50ZW5zaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGVuc2lvbjtcbiAgICAgIHRlbnNpb24gPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICBkMy5zdmcubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zdmdfbGluZShkM19pZGVudGl0eSk7XG4gIH07XG4gIHZhciBkM19zdmdfbGluZUludGVycG9sYXRvcnMgPSBkMy5tYXAoe1xuICAgIGxpbmVhcjogZDNfc3ZnX2xpbmVMaW5lYXIsXG4gICAgXCJsaW5lYXItY2xvc2VkXCI6IGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkLFxuICAgIHN0ZXA6IGQzX3N2Z19saW5lU3RlcCxcbiAgICBcInN0ZXAtYmVmb3JlXCI6IGQzX3N2Z19saW5lU3RlcEJlZm9yZSxcbiAgICBcInN0ZXAtYWZ0ZXJcIjogZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIsXG4gICAgYmFzaXM6IGQzX3N2Z19saW5lQmFzaXMsXG4gICAgXCJiYXNpcy1vcGVuXCI6IGQzX3N2Z19saW5lQmFzaXNPcGVuLFxuICAgIFwiYmFzaXMtY2xvc2VkXCI6IGQzX3N2Z19saW5lQmFzaXNDbG9zZWQsXG4gICAgYnVuZGxlOiBkM19zdmdfbGluZUJ1bmRsZSxcbiAgICBjYXJkaW5hbDogZDNfc3ZnX2xpbmVDYXJkaW5hbCxcbiAgICBcImNhcmRpbmFsLW9wZW5cIjogZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4sXG4gICAgXCJjYXJkaW5hbC1jbG9zZWRcIjogZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZCxcbiAgICBtb25vdG9uZTogZDNfc3ZnX2xpbmVNb25vdG9uZVxuICB9KTtcbiAgZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhbHVlLmtleSA9IGtleTtcbiAgICB2YWx1ZS5jbG9zZWQgPSAvLWNsb3NlZCQvLnRlc3Qoa2V5KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoID4gMSA/IHBvaW50cy5qb2luKFwiTFwiKSA6IHBvaW50cyArIFwiWlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMuam9pbihcIkxcIikgKyBcIlpcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXAocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiSFwiLCAocFswXSArIChwID0gcG9pbnRzW2ldKVswXSkgLyAyLCBcIlZcIiwgcFsxXSk7XG4gICAgaWYgKG4gPiAxKSBwYXRoLnB1c2goXCJIXCIsIHBbMF0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwQmVmb3JlKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIlZcIiwgKHAgPSBwb2ludHNbaV0pWzFdLCBcIkhcIiwgcFswXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXBBZnRlcihwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJIXCIsIChwID0gcG9pbnRzW2ldKVswXSwgXCJWXCIsIHBbMV0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4ocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCA0ID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1sxXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMuc2xpY2UoMSwgLTEpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZChwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhckNsb3NlZChwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKChwb2ludHMucHVzaChwb2ludHNbMF0pLCBcbiAgICBwb2ludHMpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMoWyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdIF0uY29uY2F0KHBvaW50cywgWyBwb2ludHNbMV0gXSksIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgdGFuZ2VudHMpIHtcbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoIDwgMSB8fCBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCAmJiBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCArIDIpIHtcbiAgICAgIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIH1cbiAgICB2YXIgcXVhZCA9IHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoLCBwYXRoID0gXCJcIiwgcDAgPSBwb2ludHNbMF0sIHAgPSBwb2ludHNbMV0sIHQwID0gdGFuZ2VudHNbMF0sIHQgPSB0MCwgcGkgPSAxO1xuICAgIGlmIChxdWFkKSB7XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gLSB0MFswXSAqIDIgLyAzKSArIFwiLFwiICsgKHBbMV0gLSB0MFsxXSAqIDIgLyAzKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIHAwID0gcG9pbnRzWzFdO1xuICAgICAgcGkgPSAyO1xuICAgIH1cbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoID4gMSkge1xuICAgICAgdCA9IHRhbmdlbnRzWzFdO1xuICAgICAgcCA9IHBvaW50c1twaV07XG4gICAgICBwaSsrO1xuICAgICAgcGF0aCArPSBcIkNcIiArIChwMFswXSArIHQwWzBdKSArIFwiLFwiICsgKHAwWzFdICsgdDBbMV0pICsgXCIsXCIgKyAocFswXSAtIHRbMF0pICsgXCIsXCIgKyAocFsxXSAtIHRbMV0pICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB0YW5nZW50cy5sZW5ndGg7IGkrKywgcGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW3BpXTtcbiAgICAgICAgdCA9IHRhbmdlbnRzW2ldO1xuICAgICAgICBwYXRoICs9IFwiU1wiICsgKHBbMF0gLSB0WzBdKSArIFwiLFwiICsgKHBbMV0gLSB0WzFdKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWQpIHtcbiAgICAgIHZhciBscCA9IHBvaW50c1twaV07XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gKyB0WzBdICogMiAvIDMpICsgXCIsXCIgKyAocFsxXSArIHRbMV0gKiAyIC8gMykgKyBcIixcIiArIGxwWzBdICsgXCIsXCIgKyBscFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBhID0gKDEgLSB0ZW5zaW9uKSAvIDIsIHAwLCBwMSA9IHBvaW50c1swXSwgcDIgPSBwb2ludHNbMV0sIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHBvaW50c1tpXTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBhICogKHAyWzBdIC0gcDBbMF0pLCBhICogKHAyWzFdIC0gcDBbMV0pIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFuZ2VudHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpcyhwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpID0gcG9pbnRzWzBdLCB4MCA9IHBpWzBdLCB5MCA9IHBpWzFdLCBweCA9IFsgeDAsIHgwLCB4MCwgKHBpID0gcG9pbnRzWzFdKVswXSBdLCBweSA9IFsgeTAsIHkwLCB5MCwgcGlbMV0gXSwgcGF0aCA9IFsgeDAsIFwiLFwiLCB5MCwgXCJMXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkgXTtcbiAgICBwb2ludHMucHVzaChwb2ludHNbbiAtIDFdKTtcbiAgICB3aGlsZSAoKytpIDw9IG4pIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICBwb2ludHMucG9wKCk7XG4gICAgcGF0aC5wdXNoKFwiTFwiLCBwaSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzT3Blbihwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDQpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBwYXRoID0gW10sIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpLCBweCA9IFsgMCBdLCBweSA9IFsgMCBdO1xuICAgIHdoaWxlICgrK2kgPCAzKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgfVxuICAgIHBhdGgucHVzaChkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSArIFwiLFwiICsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkpO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc0Nsb3NlZChwb2ludHMpIHtcbiAgICB2YXIgcGF0aCwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgbSA9IG4gKyA0LCBwaSwgcHggPSBbXSwgcHkgPSBbXTtcbiAgICB3aGlsZSAoKytpIDwgNCkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICB9XG4gICAgcGF0aCA9IFsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSBdO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbSkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQnVuZGxlKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciB4MCA9IHBvaW50c1swXVswXSwgeTAgPSBwb2ludHNbMF1bMV0sIGR4ID0gcG9pbnRzW25dWzBdIC0geDAsIGR5ID0gcG9pbnRzW25dWzFdIC0geTAsIGkgPSAtMSwgcCwgdDtcbiAgICAgIHdoaWxlICgrK2kgPD0gbikge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICB0ID0gaSAvIG47XG4gICAgICAgIHBbMF0gPSB0ZW5zaW9uICogcFswXSArICgxIC0gdGVuc2lvbikgKiAoeDAgKyB0ICogZHgpO1xuICAgICAgICBwWzFdID0gdGVuc2lvbiAqIHBbMV0gKyAoMSAtIHRlbnNpb24pICogKHkwICsgdCAqIGR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lQmFzaXMocG9pbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZURvdDQoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbiAgfVxuICB2YXIgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEgPSBbIDAsIDIgLyAzLCAxIC8gMywgMCBdLCBkM19zdmdfbGluZUJhc2lzQmV6aWVyMiA9IFsgMCwgMSAvIDMsIDIgLyAzLCAwIF0sIGQzX3N2Z19saW5lQmFzaXNCZXppZXIzID0gWyAwLCAxIC8gNiwgMiAvIDMsIDEgLyA2IF07XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgeCwgeSkge1xuICAgIHBhdGgucHVzaChcIkNcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIxLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMSwgeSksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIyLCB5KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHkpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVNsb3BlKHAwLCBwMSkge1xuICAgIHJldHVybiAocDFbMV0gLSBwMFsxXSkgLyAocDFbMF0gLSBwMFswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIGogPSBwb2ludHMubGVuZ3RoIC0gMSwgbSA9IFtdLCBwMCA9IHBvaW50c1swXSwgcDEgPSBwb2ludHNbMV0sIGQgPSBtWzBdID0gZDNfc3ZnX2xpbmVTbG9wZShwMCwgcDEpO1xuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBtW2ldID0gKGQgKyAoZCA9IGQzX3N2Z19saW5lU2xvcGUocDAgPSBwMSwgcDEgPSBwb2ludHNbaSArIDFdKSkpIC8gMjtcbiAgICB9XG4gICAgbVtpXSA9IGQ7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVNb25vdG9uZVRhbmdlbnRzKHBvaW50cykge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBkLCBhLCBiLCBzLCBtID0gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpLCBpID0gLTEsIGogPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgZCA9IGQzX3N2Z19saW5lU2xvcGUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIGlmIChhYnMoZCkgPCDOtSkge1xuICAgICAgICBtW2ldID0gbVtpICsgMV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IG1baV0gLyBkO1xuICAgICAgICBiID0gbVtpICsgMV0gLyBkO1xuICAgICAgICBzID0gYSAqIGEgKyBiICogYjtcbiAgICAgICAgaWYgKHMgPiA5KSB7XG4gICAgICAgICAgcyA9IGQgKiAzIC8gTWF0aC5zcXJ0KHMpO1xuICAgICAgICAgIG1baV0gPSBzICogYTtcbiAgICAgICAgICBtW2kgKyAxXSA9IHMgKiBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgIHMgPSAocG9pbnRzW01hdGgubWluKGosIGkgKyAxKV1bMF0gLSBwb2ludHNbTWF0aC5tYXgoMCwgaSAtIDEpXVswXSkgLyAoNiAqICgxICsgbVtpXSAqIG1baV0pKTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBzIHx8IDAsIG1baV0gKiBzIHx8IDAgXSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZU1vbm90b25lKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZU1vbm90b25lVGFuZ2VudHMocG9pbnRzKSk7XG4gIH1cbiAgZDMuc3ZnLmxpbmUucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbmUgPSBkM19zdmdfbGluZShkM19zdmdfbGluZVJhZGlhbCk7XG4gICAgbGluZS5yYWRpdXMgPSBsaW5lLngsIGRlbGV0ZSBsaW5lLng7XG4gICAgbGluZS5hbmdsZSA9IGxpbmUueSwgZGVsZXRlIGxpbmUueTtcbiAgICByZXR1cm4gbGluZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVSYWRpYWwocG9pbnRzKSB7XG4gICAgdmFyIHBvaW50LCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCByLCBhO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHIgPSBwb2ludFswXTtcbiAgICAgIGEgPSBwb2ludFsxXSAtIGhhbGbPgDtcbiAgICAgIHBvaW50WzBdID0gciAqIE1hdGguY29zKGEpO1xuICAgICAgcG9pbnRbMV0gPSByICogTWF0aC5zaW4oYSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyZWEocHJvamVjdGlvbikge1xuICAgIHZhciB4MCA9IGQzX2dlb21fcG9pbnRYLCB4MSA9IGQzX2dlb21fcG9pbnRYLCB5MCA9IDAsIHkxID0gZDNfZ2VvbV9wb2ludFksIGRlZmluZWQgPSBkM190cnVlLCBpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lTGluZWFyLCBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlLmtleSwgaW50ZXJwb2xhdGVSZXZlcnNlID0gaW50ZXJwb2xhdGUsIEwgPSBcIkxcIiwgdGVuc2lvbiA9IC43O1xuICAgIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHBvaW50czAgPSBbXSwgcG9pbnRzMSA9IFtdLCBpID0gLTEsIG4gPSBkYXRhLmxlbmd0aCwgZCwgZngwID0gZDNfZnVuY3Rvcih4MCksIGZ5MCA9IGQzX2Z1bmN0b3IoeTApLCBmeDEgPSB4MCA9PT0geDEgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9IDogZDNfZnVuY3Rvcih4MSksIGZ5MSA9IHkwID09PSB5MSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHkxKSwgeCwgeTtcbiAgICAgIGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goXCJNXCIsIGludGVycG9sYXRlKHByb2plY3Rpb24ocG9pbnRzMSksIHRlbnNpb24pLCBMLCBpbnRlcnBvbGF0ZVJldmVyc2UocHJvamVjdGlvbihwb2ludHMwLnJldmVyc2UoKSksIHRlbnNpb24pLCBcIlpcIik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50czAucHVzaChbIHggPSArZngwLmNhbGwodGhpcywgZCwgaSksIHkgPSArZnkwLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgICAgcG9pbnRzMS5wdXNoKFsgK2Z4MS5jYWxsKHRoaXMsIGQsIGkpLCArZnkxLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzMC5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzMCA9IFtdO1xuICAgICAgICAgIHBvaW50czEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvaW50czAubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDAgPSB4MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MDtcbiAgICAgIHgwID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkwID0geTEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTA7XG4gICAgICB5MCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmaW5lZDtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGVLZXk7XG4gICAgICBpZiAodHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIikgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZSA9IF87IGVsc2UgaW50ZXJwb2xhdGVLZXkgPSAoaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZ2V0KF8pIHx8IGQzX3N2Z19saW5lTGluZWFyKS5rZXk7XG4gICAgICBpbnRlcnBvbGF0ZVJldmVyc2UgPSBpbnRlcnBvbGF0ZS5yZXZlcnNlIHx8IGludGVycG9sYXRlO1xuICAgICAgTCA9IGludGVycG9sYXRlLmNsb3NlZCA/IFwiTVwiIDogXCJMXCI7XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEudGVuc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRlbnNpb247XG4gICAgICB0ZW5zaW9uID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbiAgZDNfc3ZnX2xpbmVTdGVwQmVmb3JlLnJldmVyc2UgPSBkM19zdmdfbGluZVN0ZXBBZnRlcjtcbiAgZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIucmV2ZXJzZSA9IGQzX3N2Z19saW5lU3RlcEJlZm9yZTtcbiAgZDMuc3ZnLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc3ZnX2FyZWEoZDNfaWRlbnRpdHkpO1xuICB9O1xuICBkMy5zdmcuYXJlYS5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYSA9IGQzX3N2Z19hcmVhKGQzX3N2Z19saW5lUmFkaWFsKTtcbiAgICBhcmVhLnJhZGl1cyA9IGFyZWEueCwgZGVsZXRlIGFyZWEueDtcbiAgICBhcmVhLmlubmVyUmFkaXVzID0gYXJlYS54MCwgZGVsZXRlIGFyZWEueDA7XG4gICAgYXJlYS5vdXRlclJhZGl1cyA9IGFyZWEueDEsIGRlbGV0ZSBhcmVhLngxO1xuICAgIGFyZWEuYW5nbGUgPSBhcmVhLnksIGRlbGV0ZSBhcmVhLnk7XG4gICAgYXJlYS5zdGFydEFuZ2xlID0gYXJlYS55MCwgZGVsZXRlIGFyZWEueTA7XG4gICAgYXJlYS5lbmRBbmdsZSA9IGFyZWEueTEsIGRlbGV0ZSBhcmVhLnkxO1xuICAgIHJldHVybiBhcmVhO1xuICB9O1xuICBkMy5zdmcuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCB0YXJnZXQgPSBkM190YXJnZXQsIHJhZGl1cyA9IGQzX3N2Z19jaG9yZFJhZGl1cywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZTtcbiAgICBmdW5jdGlvbiBjaG9yZChkLCBpKSB7XG4gICAgICB2YXIgcyA9IHN1Ymdyb3VwKHRoaXMsIHNvdXJjZSwgZCwgaSksIHQgPSBzdWJncm91cCh0aGlzLCB0YXJnZXQsIGQsIGkpO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcy5wMCArIGFyYyhzLnIsIHMucDEsIHMuYTEgLSBzLmEwKSArIChlcXVhbHMocywgdCkgPyBjdXJ2ZShzLnIsIHMucDEsIHMuciwgcy5wMCkgOiBjdXJ2ZShzLnIsIHMucDEsIHQuciwgdC5wMCkgKyBhcmModC5yLCB0LnAxLCB0LmExIC0gdC5hMCkgKyBjdXJ2ZSh0LnIsIHQucDEsIHMuciwgcy5wMCkpICsgXCJaXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1Ymdyb3VwKHNlbGYsIGYsIGQsIGkpIHtcbiAgICAgIHZhciBzdWJncm91cCA9IGYuY2FsbChzZWxmLCBkLCBpKSwgciA9IHJhZGl1cy5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSwgYTAgPSBzdGFydEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+ALCBhMSA9IGVuZEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogcixcbiAgICAgICAgYTA6IGEwLFxuICAgICAgICBhMTogYTEsXG4gICAgICAgIHAwOiBbIHIgKiBNYXRoLmNvcyhhMCksIHIgKiBNYXRoLnNpbihhMCkgXSxcbiAgICAgICAgcDE6IFsgciAqIE1hdGguY29zKGExKSwgciAqIE1hdGguc2luKGExKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIGEuYTAgPT0gYi5hMCAmJiBhLmExID09IGIuYTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyYyhyLCBwLCBhKSB7XG4gICAgICByZXR1cm4gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCBcIiArICsoYSA+IM+AKSArIFwiLDEgXCIgKyBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJ2ZShyMCwgcDAsIHIxLCBwMSkge1xuICAgICAgcmV0dXJuIFwiUSAwLDAgXCIgKyBwMTtcbiAgICB9XG4gICAgY2hvcmQucmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFkaXVzO1xuICAgICAgcmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvdXJjZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC50YXJnZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLmVuZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICByZXR1cm4gY2hvcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19jaG9yZFJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQucmFkaXVzO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHRhcmdldCA9IGQzX3RhcmdldCwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb247XG4gICAgZnVuY3Rpb24gZGlhZ29uYWwoZCwgaSkge1xuICAgICAgdmFyIHAwID0gc291cmNlLmNhbGwodGhpcywgZCwgaSksIHAzID0gdGFyZ2V0LmNhbGwodGhpcywgZCwgaSksIG0gPSAocDAueSArIHAzLnkpIC8gMiwgcCA9IFsgcDAsIHtcbiAgICAgICAgeDogcDAueCxcbiAgICAgICAgeTogbVxuICAgICAgfSwge1xuICAgICAgICB4OiBwMy54LFxuICAgICAgICB5OiBtXG4gICAgICB9LCBwMyBdO1xuICAgICAgcCA9IHAubWFwKHByb2plY3Rpb24pO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcFswXSArIFwiQ1wiICsgcFsxXSArIFwiIFwiICsgcFsyXSArIFwiIFwiICsgcFszXTtcbiAgICB9XG4gICAgZGlhZ29uYWwuc291cmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIGRpYWdvbmFsLnRhcmdldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3Rpb24gPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uKGQpIHtcbiAgICByZXR1cm4gWyBkLngsIGQueSBdO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbC5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlhZ29uYWwgPSBkMy5zdmcuZGlhZ29uYWwoKSwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb24sIHByb2plY3Rpb25fID0gZGlhZ29uYWwucHJvamVjdGlvbjtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBwcm9qZWN0aW9uXyhkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24gPSB4KSkgOiBwcm9qZWN0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IHByb2plY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgciA9IGRbMF0sIGEgPSBkWzFdIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgciAqIE1hdGguY29zKGEpLCByICogTWF0aC5zaW4oYSkgXTtcbiAgICB9O1xuICB9XG4gIGQzLnN2Zy5zeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHlwZSA9IGQzX3N2Z19zeW1ib2xUeXBlLCBzaXplID0gZDNfc3ZnX3N5bWJvbFNpemU7XG4gICAgZnVuY3Rpb24gc3ltYm9sKGQsIGkpIHtcbiAgICAgIHJldHVybiAoZDNfc3ZnX3N5bWJvbHMuZ2V0KHR5cGUuY2FsbCh0aGlzLCBkLCBpKSkgfHwgZDNfc3ZnX3N5bWJvbENpcmNsZSkoc2l6ZS5jYWxsKHRoaXMsIGQsIGkpKTtcbiAgICB9XG4gICAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0eXBlO1xuICAgICAgdHlwZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbFNpemUoKSB7XG4gICAgcmV0dXJuIDY0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xUeXBlKCkge1xuICAgIHJldHVybiBcImNpcmNsZVwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xDaXJjbGUoc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyDPgCk7XG4gICAgcmV0dXJuIFwiTTAsXCIgKyByICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIC1yICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIHIgKyBcIlpcIjtcbiAgfVxuICB2YXIgZDNfc3ZnX3N5bWJvbHMgPSBkMy5tYXAoe1xuICAgIGNpcmNsZTogZDNfc3ZnX3N5bWJvbENpcmNsZSxcbiAgICBjcm9zczogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC0zICogciArIFwiLFwiICsgLXIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyAtMyAqIHIgKyBcIkhcIiArIHIgKyBcIlZcIiArIC1yICsgXCJIXCIgKyAzICogciArIFwiVlwiICsgciArIFwiSFwiICsgciArIFwiVlwiICsgMyAqIHIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyByICsgXCJIXCIgKyAtMyAqIHIgKyBcIlpcIjtcbiAgICB9LFxuICAgIGRpYW1vbmQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiBkM19zdmdfc3ltYm9sVGFuMzApKSwgcnggPSByeSAqIGQzX3N2Z19zeW1ib2xUYW4zMDtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgLXJ5ICsgXCJMXCIgKyByeCArIFwiLDBcIiArIFwiIDAsXCIgKyByeSArIFwiIFwiICsgLXJ4ICsgXCIsMFwiICsgXCJaXCI7XG4gICAgfSxcbiAgICBzcXVhcmU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC1yICsgXCIsXCIgKyAtciArIFwiTFwiICsgciArIFwiLFwiICsgLXIgKyBcIiBcIiArIHIgKyBcIixcIiArIHIgKyBcIiBcIiArIC1yICsgXCIsXCIgKyByICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLWRvd25cIjogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBkM19zdmdfc3ltYm9sU3FydDMpLCByeSA9IHJ4ICogZDNfc3ZnX3N5bWJvbFNxcnQzIC8gMjtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcnkgKyBcIkxcIiArIHJ4ICsgXCIsXCIgKyAtcnkgKyBcIiBcIiArIC1yeCArIFwiLFwiICsgLXJ5ICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLXVwXCI6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeCA9IE1hdGguc3FydChzaXplIC8gZDNfc3ZnX3N5bWJvbFNxcnQzKSwgcnkgPSByeCAqIGQzX3N2Z19zeW1ib2xTcXJ0MyAvIDI7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIC1yeSArIFwiTFwiICsgcnggKyBcIixcIiArIHJ5ICsgXCIgXCIgKyAtcnggKyBcIixcIiArIHJ5ICsgXCJaXCI7XG4gICAgfVxuICB9KTtcbiAgZDMuc3ZnLnN5bWJvbFR5cGVzID0gZDNfc3ZnX3N5bWJvbHMua2V5cygpO1xuICB2YXIgZDNfc3ZnX3N5bWJvbFNxcnQzID0gTWF0aC5zcXJ0KDMpLCBkM19zdmdfc3ltYm9sVGFuMzAgPSBNYXRoLnRhbigzMCAqIGQzX3JhZGlhbnMpO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkIHx8ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSksIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgbm9kZSwgdHJhbnNpdGlvbiA9IGQzX3RyYW5zaXRpb25Jbmhlcml0IHx8IHtcbiAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICBlYXNlOiBkM19lYXNlX2N1YmljSW5PdXQsXG4gICAgICBkZWxheTogMCxcbiAgICAgIGR1cmF0aW9uOiAyNTBcbiAgICB9O1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lID09IG51bGwgPyBkM19zZWxlY3Rpb25faW50ZXJydXB0IDogZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSkpKTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQgPSBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMoZDNfdHJhbnNpdGlvbk5hbWVzcGFjZSgpKTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKG5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvY2ssIGFjdGl2ZUlkLCBhY3RpdmU7XG4gICAgICBpZiAoKGxvY2sgPSB0aGlzW25zXSkgJiYgKGFjdGl2ZSA9IGxvY2tbYWN0aXZlSWQgPSBsb2NrLmFjdGl2ZV0pKSB7XG4gICAgICAgIGFjdGl2ZS50aW1lci5jID0gbnVsbDtcbiAgICAgICAgYWN0aXZlLnRpbWVyLnQgPSBOYU47XG4gICAgICAgIGlmICgtLWxvY2suY291bnQpIGRlbGV0ZSBsb2NrW2FjdGl2ZUlkXTsgZWxzZSBkZWxldGUgdGhpc1tuc107XG4gICAgICAgIGxvY2suYWN0aXZlICs9IC41O1xuICAgICAgICBhY3RpdmUuZXZlbnQgJiYgYWN0aXZlLmV2ZW50LmludGVycnVwdC5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGFjdGl2ZS5pbmRleCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uKGdyb3VwcywgbnMsIGlkKSB7XG4gICAgZDNfc3ViY2xhc3MoZ3JvdXBzLCBkM190cmFuc2l0aW9uUHJvdG90eXBlKTtcbiAgICBncm91cHMubmFtZXNwYWNlID0gbnM7XG4gICAgZ3JvdXBzLmlkID0gaWQ7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfdHJhbnNpdGlvblByb3RvdHlwZSA9IFtdLCBkM190cmFuc2l0aW9uSWQgPSAwLCBkM190cmFuc2l0aW9uSW5oZXJpdElkLCBkM190cmFuc2l0aW9uSW5oZXJpdDtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5jYWxsID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGw7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZW1wdHkgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHk7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUubm9kZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcbiAgZDMudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnRyYW5zaXRpb24gPyBkM190cmFuc2l0aW9uSW5oZXJpdElkID8gc2VsZWN0aW9uLnRyYW5zaXRpb24obmFtZSkgOiBzZWxlY3Rpb24gOiBkMy5zZWxlY3Rpb24oKS50cmFuc2l0aW9uKHNlbGVjdGlvbik7XG4gIH07XG4gIGQzLnRyYW5zaXRpb24ucHJvdG90eXBlID0gZDNfdHJhbnNpdGlvblByb3RvdHlwZTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKSB7XG4gICAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgICBkM190cmFuc2l0aW9uTm9kZShzdWJub2RlLCBpLCBucywgaWQsIG5vZGVbbnNdW2lkXSk7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZXMsIG5vZGUsIHN1Ym5vZGUsIHRyYW5zaXRpb247XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZF07XG4gICAgICAgICAgc3Vibm9kZXMgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAtMSwgbyA9IHN1Ym5vZGVzLmxlbmd0aDsgKytrIDwgbzsgKSB7XG4gICAgICAgICAgICBpZiAoc3Vibm9kZSA9IHN1Ym5vZGVzW2tdKSBkM190cmFuc2l0aW9uTm9kZShzdWJub2RlLCBrLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIGZpbHRlci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMubmFtZXNwYWNlLCB0aGlzLmlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50d2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHR3ZWVuKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLnR3ZWVuLmdldChuYW1lKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHdlZW4gPT0gbnVsbCA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5yZW1vdmUobmFtZSk7XG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdHdlZW4pO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uX3R3ZWVuKGdyb3VwcywgbmFtZSwgdmFsdWUsIHR3ZWVuKSB7XG4gICAgdmFyIGlkID0gZ3JvdXBzLmlkLCBucyA9IGdyb3Vwcy5uYW1lc3BhY2U7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKGdyb3VwcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHR3ZWVuKHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKTtcbiAgICB9IDogKHZhbHVlID0gdHdlZW4odmFsdWUpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9KSk7XG4gIH1cbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24obmFtZU5TLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lTlMpIHRoaXMuYXR0cih2YWx1ZSwgbmFtZU5TW3ZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGludGVycG9sYXRlID0gbmFtZU5TID09IFwidHJhbnNmb3JtXCIgPyBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGQzX2ludGVycG9sYXRlLCBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lTlMpO1xuICAgIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW4oYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IGF0dHJOdWxsIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuTlMoYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IGF0dHJOdWxsTlMgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJhdHRyLlwiICsgbmFtZU5TLCB2YWx1ZSwgbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5hdHRyVHdlZW4gPSBmdW5jdGlvbihuYW1lTlMsIHR3ZWVuKSB7XG4gICAgdmFyIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWVOUyk7XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGYodCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuTlMoZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIHRoaXMuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIGYodCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHdlZW4oXCJhdHRyLlwiICsgbmFtZU5TLCBuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHByaW9yaXR5IGluIG5hbWUpIHRoaXMuc3R5bGUocHJpb3JpdHksIG5hbWVbcHJpb3JpdHldLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZU51bGwoKSB7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZVN0cmluZyhiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gc3R5bGVOdWxsIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gZDNfd2luZG93KHRoaXMpLmdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBkM19pbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaSh0KSwgcHJpb3JpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUsIHN0eWxlU3RyaW5nKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zdHlsZVR3ZWVuID0gZnVuY3Rpb24obmFtZSwgdHdlZW4sIHByaW9yaXR5KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBwcmlvcml0eSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gc3R5bGVUd2VlbihkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgZDNfd2luZG93KHRoaXMpLmdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgZih0KSwgcHJpb3JpdHkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHdlZW4oXCJzdHlsZS5cIiArIG5hbWUsIHN0eWxlVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSwgZDNfdHJhbnNpdGlvbl90ZXh0KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbl90ZXh0KGIpIHtcbiAgICBpZiAoYiA9PSBudWxsKSBiID0gXCJcIjtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gYjtcbiAgICB9O1xuICB9XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChcImVuZC50cmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAodGhpc1tuc10uY291bnQgPCAyICYmIChwID0gdGhpcy5wYXJlbnROb2RlKSkgcC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZWFzZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gZDMuZWFzZS5hcHBseShkMywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmVhc2UgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmRlbGF5O1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kZWxheSA9ICt2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgIH0gOiAodmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kZWxheSA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmR1cmF0aW9uO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kdXJhdGlvbiA9IE1hdGgubWF4KDEsIHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgIH0gOiAodmFsdWUgPSBNYXRoLm1heCgxLCB2YWx1ZSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kdXJhdGlvbiA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIGluaGVyaXQgPSBkM190cmFuc2l0aW9uSW5oZXJpdCwgaW5oZXJpdElkID0gZDNfdHJhbnNpdGlvbkluaGVyaXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPSBpZDtcbiAgICAgICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0ID0gbm9kZVtuc11baWRdO1xuICAgICAgICAgIHR5cGUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdCA9IGluaGVyaXQ7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPSBpbmhlcml0SWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZF07XG4gICAgICAgICh0cmFuc2l0aW9uLmV2ZW50IHx8ICh0cmFuc2l0aW9uLmV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImludGVycnVwdFwiKSkpLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkMCA9IHRoaXMuaWQsIGlkMSA9ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlLCB0cmFuc2l0aW9uO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkMF07XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkMSwge1xuICAgICAgICAgICAgdGltZTogdHJhbnNpdGlvbi50aW1lLFxuICAgICAgICAgICAgZWFzZTogdHJhbnNpdGlvbi5lYXNlLFxuICAgICAgICAgICAgZGVsYXk6IHRyYW5zaXRpb24uZGVsYXkgKyB0cmFuc2l0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb246IHRyYW5zaXRpb24uZHVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZDEpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PSBudWxsID8gXCJfX3RyYW5zaXRpb25fX1wiIDogXCJfX3RyYW5zaXRpb25fXCIgKyBuYW1lICsgXCJfX1wiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZCwgaW5oZXJpdCkge1xuICAgIHZhciBsb2NrID0gbm9kZVtuc10gfHwgKG5vZGVbbnNdID0ge1xuICAgICAgYWN0aXZlOiAwLFxuICAgICAgY291bnQ6IDBcbiAgICB9KSwgdHJhbnNpdGlvbiA9IGxvY2tbaWRdLCB0aW1lLCB0aW1lciwgZHVyYXRpb24sIGVhc2UsIHR3ZWVucztcbiAgICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgICB2YXIgZGVsYXkgPSB0cmFuc2l0aW9uLmRlbGF5O1xuICAgICAgdGltZXIudCA9IGRlbGF5ICsgdGltZTtcbiAgICAgIGlmIChkZWxheSA8PSBlbGFwc2VkKSByZXR1cm4gc3RhcnQoZWxhcHNlZCAtIGRlbGF5KTtcbiAgICAgIHRpbWVyLmMgPSBzdGFydDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgICAgdmFyIGFjdGl2ZUlkID0gbG9jay5hY3RpdmUsIGFjdGl2ZSA9IGxvY2tbYWN0aXZlSWRdO1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUudGltZXIuYyA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS50aW1lci50ID0gTmFOO1xuICAgICAgICAtLWxvY2suY291bnQ7XG4gICAgICAgIGRlbGV0ZSBsb2NrW2FjdGl2ZUlkXTtcbiAgICAgICAgYWN0aXZlLmV2ZW50ICYmIGFjdGl2ZS5ldmVudC5pbnRlcnJ1cHQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBhY3RpdmUuaW5kZXgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY2FuY2VsSWQgaW4gbG9jaykge1xuICAgICAgICBpZiAoK2NhbmNlbElkIDwgaWQpIHtcbiAgICAgICAgICB2YXIgY2FuY2VsID0gbG9ja1tjYW5jZWxJZF07XG4gICAgICAgICAgY2FuY2VsLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICAgIGNhbmNlbC50aW1lci50ID0gTmFOO1xuICAgICAgICAgIC0tbG9jay5jb3VudDtcbiAgICAgICAgICBkZWxldGUgbG9ja1tjYW5jZWxJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVyLmMgPSB0aWNrO1xuICAgICAgZDNfdGltZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lci5jICYmIHRpY2soZWxhcHNlZCB8fCAxKSkge1xuICAgICAgICAgIHRpbWVyLmMgPSBudWxsO1xuICAgICAgICAgIHRpbWVyLnQgPSBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9LCAwLCB0aW1lKTtcbiAgICAgIGxvY2suYWN0aXZlID0gaWQ7XG4gICAgICB0cmFuc2l0aW9uLmV2ZW50ICYmIHRyYW5zaXRpb24uZXZlbnQuc3RhcnQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgIHR3ZWVucyA9IFtdO1xuICAgICAgdHJhbnNpdGlvbi50d2Vlbi5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID0gdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKSkge1xuICAgICAgICAgIHR3ZWVucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYXNlID0gdHJhbnNpdGlvbi5lYXNlO1xuICAgICAgZHVyYXRpb24gPSB0cmFuc2l0aW9uLmR1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICAgIHZhciB0ID0gZWxhcHNlZCAvIGR1cmF0aW9uLCBlID0gZWFzZSh0KSwgbiA9IHR3ZWVucy5sZW5ndGg7XG4gICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgdHdlZW5zWy0tbl0uY2FsbChub2RlLCBlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ldmVudCAmJiB0cmFuc2l0aW9uLmV2ZW50LmVuZC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpO1xuICAgICAgICBpZiAoLS1sb2NrLmNvdW50KSBkZWxldGUgbG9ja1tpZF07IGVsc2UgZGVsZXRlIG5vZGVbbnNdO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICB0aW1lID0gaW5oZXJpdC50aW1lO1xuICAgICAgdGltZXIgPSBkM190aW1lcihzY2hlZHVsZSwgMCwgdGltZSk7XG4gICAgICB0cmFuc2l0aW9uID0gbG9ja1tpZF0gPSB7XG4gICAgICAgIHR3ZWVuOiBuZXcgZDNfTWFwKCksXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHRpbWVyOiB0aW1lcixcbiAgICAgICAgZGVsYXk6IGluaGVyaXQuZGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2UsXG4gICAgICAgIGluZGV4OiBpXG4gICAgICB9O1xuICAgICAgaW5oZXJpdCA9IG51bGw7XG4gICAgICArK2xvY2suY291bnQ7XG4gICAgfVxuICB9XG4gIGQzLnN2Zy5heGlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKCksIG9yaWVudCA9IGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudCwgaW5uZXJUaWNrU2l6ZSA9IDYsIG91dGVyVGlja1NpemUgPSA2LCB0aWNrUGFkZGluZyA9IDMsIHRpY2tBcmd1bWVudHNfID0gWyAxMCBdLCB0aWNrVmFsdWVzID0gbnVsbCwgdGlja0Zvcm1hdF87XG4gICAgZnVuY3Rpb24gYXhpcyhnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGUsIHNjYWxlMSA9IHRoaXMuX19jaGFydF9fID0gc2NhbGUuY29weSgpO1xuICAgICAgICB2YXIgdGlja3MgPSB0aWNrVmFsdWVzID09IG51bGwgPyBzY2FsZTEudGlja3MgPyBzY2FsZTEudGlja3MuYXBwbHkoc2NhbGUxLCB0aWNrQXJndW1lbnRzXykgOiBzY2FsZTEuZG9tYWluKCkgOiB0aWNrVmFsdWVzLCB0aWNrRm9ybWF0ID0gdGlja0Zvcm1hdF8gPT0gbnVsbCA/IHNjYWxlMS50aWNrRm9ybWF0ID8gc2NhbGUxLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUxLCB0aWNrQXJndW1lbnRzXykgOiBkM19pZGVudGl0eSA6IHRpY2tGb3JtYXRfLCB0aWNrID0gZy5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHRpY2tzLCBzY2FsZTEpLCB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuaW5zZXJ0KFwiZ1wiLCBcIi5kb21haW5cIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKS5zdHlsZShcIm9wYWNpdHlcIiwgzrUpLCB0aWNrRXhpdCA9IGQzLnRyYW5zaXRpb24odGljay5leGl0KCkpLnN0eWxlKFwib3BhY2l0eVwiLCDOtSkucmVtb3ZlKCksIHRpY2tVcGRhdGUgPSBkMy50cmFuc2l0aW9uKHRpY2sub3JkZXIoKSkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpLCB0aWNrU3BhY2luZyA9IE1hdGgubWF4KGlubmVyVGlja1NpemUsIDApICsgdGlja1BhZGRpbmcsIHRpY2tUcmFuc2Zvcm07XG4gICAgICAgIHZhciByYW5nZSA9IGQzX3NjYWxlUmFuZ2Uoc2NhbGUxKSwgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFsgMCBdKSwgcGF0aFVwZGF0ZSA9IChwYXRoLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIiksIFxuICAgICAgICBkMy50cmFuc2l0aW9uKHBhdGgpKTtcbiAgICAgICAgdGlja0VudGVyLmFwcGVuZChcImxpbmVcIik7XG4gICAgICAgIHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuICAgICAgICB2YXIgbGluZUVudGVyID0gdGlja0VudGVyLnNlbGVjdChcImxpbmVcIiksIGxpbmVVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcImxpbmVcIiksIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIikudGV4dCh0aWNrRm9ybWF0KSwgdGV4dEVudGVyID0gdGlja0VudGVyLnNlbGVjdChcInRleHRcIiksIHRleHRVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcInRleHRcIiksIHNpZ24gPSBvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIiA/IC0xIDogMSwgeDEsIHgyLCB5MSwgeTI7XG4gICAgICAgIGlmIChvcmllbnQgPT09IFwiYm90dG9tXCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGQzX3N2Z19heGlzWCwgeDEgPSBcInhcIiwgeTEgPSBcInlcIiwgeDIgPSBcIngyXCIsIHkyID0gXCJ5MlwiO1xuICAgICAgICAgIHRleHQuYXR0cihcImR5XCIsIHNpZ24gPCAwID8gXCIwZW1cIiA6IFwiLjcxZW1cIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgICAgICAgICBwYXRoVXBkYXRlLmF0dHIoXCJkXCIsIFwiTVwiICsgcmFuZ2VbMF0gKyBcIixcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplICsgXCJWMEhcIiArIHJhbmdlWzFdICsgXCJWXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGQzX3N2Z19heGlzWSwgeDEgPSBcInlcIiwgeTEgPSBcInhcIiwgeDIgPSBcInkyXCIsIHkyID0gXCJ4MlwiO1xuICAgICAgICAgIHRleHQuYXR0cihcImR5XCIsIFwiLjMyZW1cIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBzaWduIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpO1xuICAgICAgICAgIHBhdGhVcGRhdGUuYXR0cihcImRcIiwgXCJNXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSArIFwiLFwiICsgcmFuZ2VbMF0gKyBcIkgwVlwiICsgcmFuZ2VbMV0gKyBcIkhcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lRW50ZXIuYXR0cih5Miwgc2lnbiAqIGlubmVyVGlja1NpemUpO1xuICAgICAgICB0ZXh0RW50ZXIuYXR0cih5MSwgc2lnbiAqIHRpY2tTcGFjaW5nKTtcbiAgICAgICAgbGluZVVwZGF0ZS5hdHRyKHgyLCAwKS5hdHRyKHkyLCBzaWduICogaW5uZXJUaWNrU2l6ZSk7XG4gICAgICAgIHRleHRVcGRhdGUuYXR0cih4MSwgMCkuYXR0cih5MSwgc2lnbiAqIHRpY2tTcGFjaW5nKTtcbiAgICAgICAgaWYgKHNjYWxlMS5yYW5nZUJhbmQpIHtcbiAgICAgICAgICB2YXIgeCA9IHNjYWxlMSwgZHggPSB4LnJhbmdlQmFuZCgpIC8gMjtcbiAgICAgICAgICBzY2FsZTAgPSBzY2FsZTEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4geChkKSArIGR4O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGUwLnJhbmdlQmFuZCkge1xuICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrRXhpdC5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMSwgc2NhbGUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aWNrRW50ZXIuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTAsIHNjYWxlMSk7XG4gICAgICAgIHRpY2tVcGRhdGUuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTEsIHNjYWxlMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXhpcy5zY2FsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgICAgc2NhbGUgPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLm9yaWVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICAgIG9yaWVudCA9IHggaW4gZDNfc3ZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQ7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tBcmd1bWVudHNfO1xuICAgICAgdGlja0FyZ3VtZW50c18gPSBkM19hcnJheShhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgICAgdGlja1ZhbHVlcyA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tGb3JtYXRfO1xuICAgICAgdGlja0Zvcm1hdF8gPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFuKSByZXR1cm4gaW5uZXJUaWNrU2l6ZTtcbiAgICAgIGlubmVyVGlja1NpemUgPSAreDtcbiAgICAgIG91dGVyVGlja1NpemUgPSArYXJndW1lbnRzW24gLSAxXTtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5pbm5lclRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW5uZXJUaWNrU2l6ZTtcbiAgICAgIGlubmVyVGlja1NpemUgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5vdXRlclRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0ZXJUaWNrU2l6ZTtcbiAgICAgIG91dGVyVGlja1NpemUgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tQYWRkaW5nO1xuICAgICAgdGlja1BhZGRpbmcgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAmJiBheGlzO1xuICAgIH07XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIHZhciBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQgPSBcImJvdHRvbVwiLCBkM19zdmdfYXhpc09yaWVudHMgPSB7XG4gICAgdG9wOiAxLFxuICAgIHJpZ2h0OiAxLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAxXG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19heGlzWChzZWxlY3Rpb24sIHgwLCB4MSkge1xuICAgIHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciB2MCA9IHgwKGQpO1xuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKGlzRmluaXRlKHYwKSA/IHYwIDogeDEoZCkpICsgXCIsMClcIjtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXhpc1koc2VsZWN0aW9uLCB5MCwgeTEpIHtcbiAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdjAgPSB5MChkKTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKGlzRmluaXRlKHYwKSA/IHYwIDogeTEoZCkpICsgXCIpXCI7XG4gICAgfSk7XG4gIH1cbiAgZDMuc3ZnLmJydXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaChicnVzaCwgXCJicnVzaHN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJicnVzaGVuZFwiKSwgeCA9IG51bGwsIHkgPSBudWxsLCB4RXh0ZW50ID0gWyAwLCAwIF0sIHlFeHRlbnQgPSBbIDAsIDAgXSwgeEV4dGVudERvbWFpbiwgeUV4dGVudERvbWFpbiwgeENsYW1wID0gdHJ1ZSwgeUNsYW1wID0gdHJ1ZSwgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbMF07XG4gICAgZnVuY3Rpb24gYnJ1c2goZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKS5vbihcIm1vdXNlZG93bi5icnVzaFwiLCBicnVzaHN0YXJ0KS5vbihcInRvdWNoc3RhcnQuYnJ1c2hcIiwgYnJ1c2hzdGFydCk7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kID0gZy5zZWxlY3RBbGwoXCIuYmFja2dyb3VuZFwiKS5kYXRhKFsgMCBdKTtcbiAgICAgICAgYmFja2dyb3VuZC5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikuc3R5bGUoXCJjdXJzb3JcIiwgXCJjcm9zc2hhaXJcIik7XG4gICAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudFwiKS5kYXRhKFsgMCBdKS5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiZXh0ZW50XCIpLnN0eWxlKFwiY3Vyc29yXCIsIFwibW92ZVwiKTtcbiAgICAgICAgdmFyIHJlc2l6ZSA9IGcuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5kYXRhKHJlc2l6ZXMsIGQzX2lkZW50aXR5KTtcbiAgICAgICAgcmVzaXplLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgcmVzaXplLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBcInJlc2l6ZSBcIiArIGQ7XG4gICAgICAgIH0pLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZDNfc3ZnX2JydXNoQ3Vyc29yW2RdO1xuICAgICAgICB9KS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gL1tld10kLy50ZXN0KGQpID8gLTMgOiBudWxsO1xuICAgICAgICB9KS5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIC9eW25zXS8udGVzdChkKSA/IC0zIDogbnVsbDtcbiAgICAgICAgfSkuYXR0cihcIndpZHRoXCIsIDYpLmF0dHIoXCJoZWlnaHRcIiwgNikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICByZXNpemUuc3R5bGUoXCJkaXNwbGF5XCIsIGJydXNoLmVtcHR5KCkgPyBcIm5vbmVcIiA6IG51bGwpO1xuICAgICAgICB2YXIgZ1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24oZyksIGJhY2tncm91bmRVcGRhdGUgPSBkMy50cmFuc2l0aW9uKGJhY2tncm91bmQpLCByYW5nZTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICByYW5nZSA9IGQzX3NjYWxlUmFuZ2UoeCk7XG4gICAgICAgICAgYmFja2dyb3VuZFVwZGF0ZS5hdHRyKFwieFwiLCByYW5nZVswXSkuYXR0cihcIndpZHRoXCIsIHJhbmdlWzFdIC0gcmFuZ2VbMF0pO1xuICAgICAgICAgIHJlZHJhd1goZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICByYW5nZSA9IGQzX3NjYWxlUmFuZ2UoeSk7XG4gICAgICAgICAgYmFja2dyb3VuZFVwZGF0ZS5hdHRyKFwieVwiLCByYW5nZVswXSkuYXR0cihcImhlaWdodFwiLCByYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICAgICAgICByZWRyYXdZKGdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlZHJhdyhnVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBicnVzaC5ldmVudCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV2ZW50XyA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyksIGV4dGVudDEgPSB7XG4gICAgICAgICAgeDogeEV4dGVudCxcbiAgICAgICAgICB5OiB5RXh0ZW50LFxuICAgICAgICAgIGk6IHhFeHRlbnREb21haW4sXG4gICAgICAgICAgajogeUV4dGVudERvbWFpblxuICAgICAgICB9LCBleHRlbnQwID0gdGhpcy5fX2NoYXJ0X18gfHwgZXh0ZW50MTtcbiAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSBleHRlbnQxO1xuICAgICAgICBpZiAoZDNfdHJhbnNpdGlvbkluaGVyaXRJZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZWFjaChcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IGV4dGVudDAuaTtcbiAgICAgICAgICAgIHlFeHRlbnREb21haW4gPSBleHRlbnQwLmo7XG4gICAgICAgICAgICB4RXh0ZW50ID0gZXh0ZW50MC54O1xuICAgICAgICAgICAgeUV4dGVudCA9IGV4dGVudDAueTtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS50d2VlbihcImJydXNoOmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHhpID0gZDNfaW50ZXJwb2xhdGVBcnJheSh4RXh0ZW50LCBleHRlbnQxLngpLCB5aSA9IGQzX2ludGVycG9sYXRlQXJyYXkoeUV4dGVudCwgZXh0ZW50MS55KTtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSB5RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHhFeHRlbnQgPSBleHRlbnQxLnggPSB4aSh0KTtcbiAgICAgICAgICAgICAgeUV4dGVudCA9IGV4dGVudDEueSA9IHlpKHQpO1xuICAgICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5lYWNoKFwiZW5kLmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IGV4dGVudDEuaTtcbiAgICAgICAgICAgIHlFeHRlbnREb21haW4gPSBleHRlbnQxLmo7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWRyYXcoZykge1xuICAgICAgZy5zZWxlY3RBbGwoXCIucmVzaXplXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4RXh0ZW50WysvZSQvLnRlc3QoZCldICsgXCIsXCIgKyB5RXh0ZW50WysvXnMvLnRlc3QoZCldICsgXCIpXCI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkcmF3WChnKSB7XG4gICAgICBnLnNlbGVjdChcIi5leHRlbnRcIikuYXR0cihcInhcIiwgeEV4dGVudFswXSk7XG4gICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnQsLm4+cmVjdCwucz5yZWN0XCIpLmF0dHIoXCJ3aWR0aFwiLCB4RXh0ZW50WzFdIC0geEV4dGVudFswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHJhd1koZykge1xuICAgICAgZy5zZWxlY3QoXCIuZXh0ZW50XCIpLmF0dHIoXCJ5XCIsIHlFeHRlbnRbMF0pO1xuICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50LC5lPnJlY3QsLnc+cmVjdFwiKS5hdHRyKFwiaGVpZ2h0XCIsIHlFeHRlbnRbMV0gLSB5RXh0ZW50WzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnJ1c2hzdGFydCgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBldmVudFRhcmdldCA9IGQzLnNlbGVjdChkMy5ldmVudC50YXJnZXQpLCBldmVudF8gPSBldmVudC5vZih0YXJnZXQsIGFyZ3VtZW50cyksIGcgPSBkMy5zZWxlY3QodGFyZ2V0KSwgcmVzaXppbmcgPSBldmVudFRhcmdldC5kYXR1bSgpLCByZXNpemluZ1ggPSAhL14obnxzKSQvLnRlc3QocmVzaXppbmcpICYmIHgsIHJlc2l6aW5nWSA9ICEvXihlfHcpJC8udGVzdChyZXNpemluZykgJiYgeSwgZHJhZ2dpbmcgPSBldmVudFRhcmdldC5jbGFzc2VkKFwiZXh0ZW50XCIpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0YXJnZXQpLCBjZW50ZXIsIG9yaWdpbiA9IGQzLm1vdXNlKHRhcmdldCksIG9mZnNldDtcbiAgICAgIHZhciB3ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyh0YXJnZXQpKS5vbihcImtleWRvd24uYnJ1c2hcIiwga2V5ZG93bikub24oXCJrZXl1cC5icnVzaFwiLCBrZXl1cCk7XG4gICAgICBpZiAoZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgdy5vbihcInRvdWNobW92ZS5icnVzaFwiLCBicnVzaG1vdmUpLm9uKFwidG91Y2hlbmQuYnJ1c2hcIiwgYnJ1c2hlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBicnVzaG1vdmUpLm9uKFwibW91c2V1cC5icnVzaFwiLCBicnVzaGVuZCk7XG4gICAgICB9XG4gICAgICBnLmludGVycnVwdCgpLnNlbGVjdEFsbChcIipcIikuaW50ZXJydXB0KCk7XG4gICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFswXSAtIG9yaWdpblswXTtcbiAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFswXSAtIG9yaWdpblsxXTtcbiAgICAgIH0gZWxzZSBpZiAocmVzaXppbmcpIHtcbiAgICAgICAgdmFyIGV4ID0gKy93JC8udGVzdChyZXNpemluZyksIGV5ID0gKy9ebi8udGVzdChyZXNpemluZyk7XG4gICAgICAgIG9mZnNldCA9IFsgeEV4dGVudFsxIC0gZXhdIC0gb3JpZ2luWzBdLCB5RXh0ZW50WzEgLSBleV0gLSBvcmlnaW5bMV0gXTtcbiAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFtleF07XG4gICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbZXldO1xuICAgICAgfSBlbHNlIGlmIChkMy5ldmVudC5hbHRLZXkpIGNlbnRlciA9IG9yaWdpbi5zbGljZSgpO1xuICAgICAgZy5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5zZWxlY3RBbGwoXCIucmVzaXplXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKTtcbiAgICAgIGQzLnNlbGVjdChcImJvZHlcIikuc3R5bGUoXCJjdXJzb3JcIiwgZXZlbnRUYXJnZXQuc3R5bGUoXCJjdXJzb3JcIikpO1xuICAgICAgZXZlbnRfKHtcbiAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgIH0pO1xuICAgICAgYnJ1c2htb3ZlKCk7XG4gICAgICBmdW5jdGlvbiBrZXlkb3duKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PSAzMikge1xuICAgICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICBvcmlnaW5bMF0gLT0geEV4dGVudFsxXTtcbiAgICAgICAgICAgIG9yaWdpblsxXSAtPSB5RXh0ZW50WzFdO1xuICAgICAgICAgICAgZHJhZ2dpbmcgPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGtleXVwKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PSAzMiAmJiBkcmFnZ2luZyA9PSAyKSB7XG4gICAgICAgICAgb3JpZ2luWzBdICs9IHhFeHRlbnRbMV07XG4gICAgICAgICAgb3JpZ2luWzFdICs9IHlFeHRlbnRbMV07XG4gICAgICAgICAgZHJhZ2dpbmcgPSAwO1xuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnJ1c2htb3ZlKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBkMy5tb3VzZSh0YXJnZXQpLCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgcG9pbnRbMF0gKz0gb2Zmc2V0WzBdO1xuICAgICAgICAgIHBvaW50WzFdICs9IG9mZnNldFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgaWYgKGQzLmV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgaWYgKCFjZW50ZXIpIGNlbnRlciA9IFsgKHhFeHRlbnRbMF0gKyB4RXh0ZW50WzFdKSAvIDIsICh5RXh0ZW50WzBdICsgeUV4dGVudFsxXSkgLyAyIF07XG4gICAgICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50WysocG9pbnRbMF0gPCBjZW50ZXJbMF0pXTtcbiAgICAgICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbKyhwb2ludFsxXSA8IGNlbnRlclsxXSldO1xuICAgICAgICAgIH0gZWxzZSBjZW50ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNpemluZ1ggJiYgbW92ZTEocG9pbnQsIHgsIDApKSB7XG4gICAgICAgICAgcmVkcmF3WChnKTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2l6aW5nWSAmJiBtb3ZlMShwb2ludCwgeSwgMSkpIHtcbiAgICAgICAgICByZWRyYXdZKGcpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICByZWRyYXcoZyk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgIG1vZGU6IGRyYWdnaW5nID8gXCJtb3ZlXCIgOiBcInJlc2l6ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmUxKHBvaW50LCBzY2FsZSwgaSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHNjYWxlKSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXSwgcG9zaXRpb24gPSBvcmlnaW5baV0sIGV4dGVudCA9IGkgPyB5RXh0ZW50IDogeEV4dGVudCwgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgbWluLCBtYXg7XG4gICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgIHIwIC09IHBvc2l0aW9uO1xuICAgICAgICAgIHIxIC09IHNpemUgKyBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBtaW4gPSAoaSA/IHlDbGFtcCA6IHhDbGFtcCkgPyBNYXRoLm1heChyMCwgTWF0aC5taW4ocjEsIHBvaW50W2ldKSkgOiBwb2ludFtpXTtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgbWF4ID0gKG1pbiArPSBwb3NpdGlvbikgKyBzaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjZW50ZXIpIHBvc2l0aW9uID0gTWF0aC5tYXgocjAsIE1hdGgubWluKHIxLCAyICogY2VudGVyW2ldIC0gbWluKSk7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgbWluKSB7XG4gICAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgICBtaW4gPSBwb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4ID0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbnRbMF0gIT0gbWluIHx8IGV4dGVudFsxXSAhPSBtYXgpIHtcbiAgICAgICAgICBpZiAoaSkgeUV4dGVudERvbWFpbiA9IG51bGw7IGVsc2UgeEV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICAgICAgZXh0ZW50WzBdID0gbWluO1xuICAgICAgICAgIGV4dGVudFsxXSA9IG1heDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnJ1c2hlbmQoKSB7XG4gICAgICAgIGJydXNobW92ZSgpO1xuICAgICAgICBnLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgYnJ1c2guZW1wdHkoKSA/IFwibm9uZVwiIDogbnVsbCk7XG4gICAgICAgIGQzLnNlbGVjdChcImJvZHlcIikuc3R5bGUoXCJjdXJzb3JcIiwgbnVsbCk7XG4gICAgICAgIHcub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbnVsbCkub24oXCJtb3VzZXVwLmJydXNoXCIsIG51bGwpLm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIG51bGwpLm9uKFwidG91Y2hlbmQuYnJ1c2hcIiwgbnVsbCkub24oXCJrZXlkb3duLmJydXNoXCIsIG51bGwpLm9uKFwia2V5dXAuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKCk7XG4gICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBicnVzaC54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSB6O1xuICAgICAgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbIXggPDwgMSB8ICF5XTtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IHo7XG4gICAgICByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1sheCA8PCAxIHwgIXldO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guY2xhbXAgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4ICYmIHkgPyBbIHhDbGFtcCwgeUNsYW1wIF0gOiB4ID8geENsYW1wIDogeSA/IHlDbGFtcCA6IG51bGw7XG4gICAgICBpZiAoeCAmJiB5KSB4Q2xhbXAgPSAhIXpbMF0sIHlDbGFtcCA9ICEhelsxXTsgZWxzZSBpZiAoeCkgeENsYW1wID0gISF6OyBlbHNlIGlmICh5KSB5Q2xhbXAgPSAhIXo7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5leHRlbnQgPSBmdW5jdGlvbih6KSB7XG4gICAgICB2YXIgeDAsIHgxLCB5MCwgeTEsIHQ7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeEV4dGVudERvbWFpbikge1xuICAgICAgICAgICAgeDAgPSB4RXh0ZW50RG9tYWluWzBdLCB4MSA9IHhFeHRlbnREb21haW5bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgwID0geEV4dGVudFswXSwgeDEgPSB4RXh0ZW50WzFdO1xuICAgICAgICAgICAgaWYgKHguaW52ZXJ0KSB4MCA9IHguaW52ZXJ0KHgwKSwgeDEgPSB4LmludmVydCh4MSk7XG4gICAgICAgICAgICBpZiAoeDEgPCB4MCkgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgaWYgKHlFeHRlbnREb21haW4pIHtcbiAgICAgICAgICAgIHkwID0geUV4dGVudERvbWFpblswXSwgeTEgPSB5RXh0ZW50RG9tYWluWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MCA9IHlFeHRlbnRbMF0sIHkxID0geUV4dGVudFsxXTtcbiAgICAgICAgICAgIGlmICh5LmludmVydCkgeTAgPSB5LmludmVydCh5MCksIHkxID0geS5pbnZlcnQoeTEpO1xuICAgICAgICAgICAgaWYgKHkxIDwgeTApIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCAmJiB5ID8gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF0gOiB4ID8gWyB4MCwgeDEgXSA6IHkgJiYgWyB5MCwgeTEgXTtcbiAgICAgIH1cbiAgICAgIGlmICh4KSB7XG4gICAgICAgIHgwID0gelswXSwgeDEgPSB6WzFdO1xuICAgICAgICBpZiAoeSkgeDAgPSB4MFswXSwgeDEgPSB4MVswXTtcbiAgICAgICAgeEV4dGVudERvbWFpbiA9IFsgeDAsIHgxIF07XG4gICAgICAgIGlmICh4LmludmVydCkgeDAgPSB4KHgwKSwgeDEgPSB4KHgxKTtcbiAgICAgICAgaWYgKHgxIDwgeDApIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICAgICAgICBpZiAoeDAgIT0geEV4dGVudFswXSB8fCB4MSAhPSB4RXh0ZW50WzFdKSB4RXh0ZW50ID0gWyB4MCwgeDEgXTtcbiAgICAgIH1cbiAgICAgIGlmICh5KSB7XG4gICAgICAgIHkwID0gelswXSwgeTEgPSB6WzFdO1xuICAgICAgICBpZiAoeCkgeTAgPSB5MFsxXSwgeTEgPSB5MVsxXTtcbiAgICAgICAgeUV4dGVudERvbWFpbiA9IFsgeTAsIHkxIF07XG4gICAgICAgIGlmICh5LmludmVydCkgeTAgPSB5KHkwKSwgeTEgPSB5KHkxKTtcbiAgICAgICAgaWYgKHkxIDwgeTApIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICBpZiAoeTAgIT0geUV4dGVudFswXSB8fCB5MSAhPSB5RXh0ZW50WzFdKSB5RXh0ZW50ID0gWyB5MCwgeTEgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgeEV4dGVudCA9IFsgMCwgMCBdLCB5RXh0ZW50ID0gWyAwLCAwIF07XG4gICAgICAgIHhFeHRlbnREb21haW4gPSB5RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF4ICYmIHhFeHRlbnRbMF0gPT0geEV4dGVudFsxXSB8fCAhIXkgJiYgeUV4dGVudFswXSA9PSB5RXh0ZW50WzFdO1xuICAgIH07XG4gICAgcmV0dXJuIGQzLnJlYmluZChicnVzaCwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIHZhciBkM19zdmdfYnJ1c2hDdXJzb3IgPSB7XG4gICAgbjogXCJucy1yZXNpemVcIixcbiAgICBlOiBcImV3LXJlc2l6ZVwiLFxuICAgIHM6IFwibnMtcmVzaXplXCIsXG4gICAgdzogXCJldy1yZXNpemVcIixcbiAgICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICAgIG5lOiBcIm5lc3ctcmVzaXplXCIsXG4gICAgc2U6IFwibndzZS1yZXNpemVcIixcbiAgICBzdzogXCJuZXN3LXJlc2l6ZVwiXG4gIH07XG4gIHZhciBkM19zdmdfYnJ1c2hSZXNpemVzID0gWyBbIFwiblwiLCBcImVcIiwgXCJzXCIsIFwid1wiLCBcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCIgXSwgWyBcImVcIiwgXCJ3XCIgXSwgWyBcIm5cIiwgXCJzXCIgXSwgW10gXTtcbiAgdmFyIGQzX3RpbWVfZm9ybWF0ID0gZDNfdGltZS5mb3JtYXQgPSBkM19sb2NhbGVfZW5VUy50aW1lRm9ybWF0O1xuICB2YXIgZDNfdGltZV9mb3JtYXRVdGMgPSBkM190aW1lX2Zvcm1hdC51dGM7XG4gIHZhciBkM190aW1lX2Zvcm1hdElzbyA9IGQzX3RpbWVfZm9ybWF0VXRjKFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCIpO1xuICBkM190aW1lX2Zvcm1hdC5pc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIikgPyBkM190aW1lX2Zvcm1hdElzb05hdGl2ZSA6IGQzX3RpbWVfZm9ybWF0SXNvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdElzb05hdGl2ZShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbiAgfVxuICBkM190aW1lX2Zvcm1hdElzb05hdGl2ZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBudWxsIDogZGF0ZTtcbiAgfTtcbiAgZDNfdGltZV9mb3JtYXRJc29OYXRpdmUudG9TdHJpbmcgPSBkM190aW1lX2Zvcm1hdElzby50b1N0cmluZztcbiAgZDNfdGltZS5zZWNvbmQgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoTWF0aC5mbG9vcihkYXRlIC8gMWUzKSAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gIH0pO1xuICBkM190aW1lLnNlY29uZHMgPSBkM190aW1lLnNlY29uZC5yYW5nZTtcbiAgZDNfdGltZS5zZWNvbmRzLnV0YyA9IGQzX3RpbWUuc2Vjb25kLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5taW51dGUgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoTWF0aC5mbG9vcihkYXRlIC8gNmU0KSAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIH0pO1xuICBkM190aW1lLm1pbnV0ZXMgPSBkM190aW1lLm1pbnV0ZS5yYW5nZTtcbiAgZDNfdGltZS5taW51dGVzLnV0YyA9IGQzX3RpbWUubWludXRlLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5ob3VyID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIHRpbWV6b25lID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC8gNjA7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKChNYXRoLmZsb29yKGRhdGUgLyAzNmU1IC0gdGltZXpvbmUpICsgdGltZXpvbmUpICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbiAgfSk7XG4gIGQzX3RpbWUuaG91cnMgPSBkM190aW1lLmhvdXIucmFuZ2U7XG4gIGQzX3RpbWUuaG91cnMudXRjID0gZDNfdGltZS5ob3VyLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5tb250aCA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUgPSBkM190aW1lLmRheShkYXRlKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG4gIH0pO1xuICBkM190aW1lLm1vbnRocyA9IGQzX3RpbWUubW9udGgucmFuZ2U7XG4gIGQzX3RpbWUubW9udGhzLnV0YyA9IGQzX3RpbWUubW9udGgudXRjLnJhbmdlO1xuICBmdW5jdGlvbiBkM190aW1lX3NjYWxlKGxpbmVhciwgbWV0aG9kcywgZm9ybWF0KSB7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcih4KTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfc2NhbGVEYXRlKGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGluZWFyLmRvbWFpbigpLm1hcChkM190aW1lX3NjYWxlRGF0ZSk7XG4gICAgICBsaW5lYXIuZG9tYWluKHgpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdGlja01ldGhvZChleHRlbnQsIGNvdW50KSB7XG4gICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgdGFyZ2V0ID0gc3BhbiAvIGNvdW50LCBpID0gZDMuYmlzZWN0KGQzX3RpbWVfc2NhbGVTdGVwcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiBpID09IGQzX3RpbWVfc2NhbGVTdGVwcy5sZW5ndGggPyBbIG1ldGhvZHMueWVhciwgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGV4dGVudC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIDMxNTM2ZTY7XG4gICAgICB9KSwgY291bnQpWzJdIF0gOiAhaSA/IFsgZDNfdGltZV9zY2FsZU1pbGxpc2Vjb25kcywgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGV4dGVudCwgY291bnQpWzJdIF0gOiBtZXRob2RzW3RhcmdldCAvIGQzX3RpbWVfc2NhbGVTdGVwc1tpIC0gMV0gPCBkM190aW1lX3NjYWxlU3RlcHNbaV0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgIH1cbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHNraXApIHtcbiAgICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW4oKSwgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgbWV0aG9kID0gaW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tNZXRob2QoZXh0ZW50LCAxMCkgOiB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgJiYgdGlja01ldGhvZChleHRlbnQsIGludGVydmFsKTtcbiAgICAgIGlmIChtZXRob2QpIGludGVydmFsID0gbWV0aG9kWzBdLCBza2lwID0gbWV0aG9kWzFdO1xuICAgICAgZnVuY3Rpb24gc2tpcHBlZChkYXRlKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZSkgJiYgIWludGVydmFsLnJhbmdlKGRhdGUsIGQzX3RpbWVfc2NhbGVEYXRlKCtkYXRlICsgMSksIHNraXApLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZS5kb21haW4oZDNfc2NhbGVfbmljZShkb21haW4sIHNraXAgPiAxID8ge1xuICAgICAgICBmbG9vcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHdoaWxlIChza2lwcGVkKGRhdGUgPSBpbnRlcnZhbC5mbG9vcihkYXRlKSkpIGRhdGUgPSBkM190aW1lX3NjYWxlRGF0ZShkYXRlIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNlaWw6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoc2tpcHBlZChkYXRlID0gaW50ZXJ2YWwuY2VpbChkYXRlKSkpIGRhdGUgPSBkM190aW1lX3NjYWxlRGF0ZSgrZGF0ZSArIDEpO1xuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IDogaW50ZXJ2YWwpKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHNraXApIHtcbiAgICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksIG1ldGhvZCA9IGludGVydmFsID09IG51bGwgPyB0aWNrTWV0aG9kKGV4dGVudCwgMTApIDogdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiID8gdGlja01ldGhvZChleHRlbnQsIGludGVydmFsKSA6ICFpbnRlcnZhbC5yYW5nZSAmJiBbIHtcbiAgICAgICAgcmFuZ2U6IGludGVydmFsXG4gICAgICB9LCBza2lwIF07XG4gICAgICBpZiAobWV0aG9kKSBpbnRlcnZhbCA9IG1ldGhvZFswXSwgc2tpcCA9IG1ldGhvZFsxXTtcbiAgICAgIHJldHVybiBpbnRlcnZhbC5yYW5nZShleHRlbnRbMF0sIGQzX3RpbWVfc2NhbGVEYXRlKCtleHRlbnRbMV0gKyAxKSwgc2tpcCA8IDEgPyAxIDogc2tpcCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUobGluZWFyLmNvcHkoKSwgbWV0aG9kcywgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9zY2FsZURhdGUodCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0KTtcbiAgfVxuICB2YXIgZDNfdGltZV9zY2FsZVN0ZXBzID0gWyAxZTMsIDVlMywgMTVlMywgM2U0LCA2ZTQsIDNlNSwgOWU1LCAxOGU1LCAzNmU1LCAxMDhlNSwgMjE2ZTUsIDQzMmU1LCA4NjRlNSwgMTcyOGU1LCA2MDQ4ZTUsIDI1OTJlNiwgNzc3NmU2LCAzMTUzNmU2IF07XG4gIHZhciBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzID0gWyBbIGQzX3RpbWUuc2Vjb25kLCAxIF0sIFsgZDNfdGltZS5zZWNvbmQsIDUgXSwgWyBkM190aW1lLnNlY29uZCwgMTUgXSwgWyBkM190aW1lLnNlY29uZCwgMzAgXSwgWyBkM190aW1lLm1pbnV0ZSwgMSBdLCBbIGQzX3RpbWUubWludXRlLCA1IF0sIFsgZDNfdGltZS5taW51dGUsIDE1IF0sIFsgZDNfdGltZS5taW51dGUsIDMwIF0sIFsgZDNfdGltZS5ob3VyLCAxIF0sIFsgZDNfdGltZS5ob3VyLCAzIF0sIFsgZDNfdGltZS5ob3VyLCA2IF0sIFsgZDNfdGltZS5ob3VyLCAxMiBdLCBbIGQzX3RpbWUuZGF5LCAxIF0sIFsgZDNfdGltZS5kYXksIDIgXSwgWyBkM190aW1lLndlZWssIDEgXSwgWyBkM190aW1lLm1vbnRoLCAxIF0sIFsgZDNfdGltZS5tb250aCwgMyBdLCBbIGQzX3RpbWUueWVhciwgMSBdIF07XG4gIHZhciBkM190aW1lX3NjYWxlTG9jYWxGb3JtYXQgPSBkM190aW1lX2Zvcm1hdC5tdWx0aShbIFsgXCIuJUxcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1pbGxpc2Vjb25kcygpO1xuICB9IF0sIFsgXCI6JVNcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFNlY29uZHMoKTtcbiAgfSBdLCBbIFwiJUk6JU1cIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1pbnV0ZXMoKTtcbiAgfSBdLCBbIFwiJUkgJXBcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldEhvdXJzKCk7XG4gIH0gXSwgWyBcIiVhICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXkoKSAmJiBkLmdldERhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlYiAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiVCXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNb250aCgpO1xuICB9IF0sIFsgXCIlWVwiLCBkM190cnVlIF0gXSk7XG4gIHZhciBkM190aW1lX3NjYWxlTWlsbGlzZWNvbmRzID0ge1xuICAgIHJhbmdlOiBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcCwgK3N0b3AsIHN0ZXApLm1hcChkM190aW1lX3NjYWxlRGF0ZSk7XG4gICAgfSxcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcy55ZWFyID0gZDNfdGltZS55ZWFyO1xuICBkM190aW1lLnNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUoZDMuc2NhbGUubGluZWFyKCksIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMsIGQzX3RpbWVfc2NhbGVMb2NhbEZvcm1hdCk7XG4gIH07XG4gIHZhciBkM190aW1lX3NjYWxlVXRjTWV0aG9kcyA9IGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gWyBtWzBdLnV0YywgbVsxXSBdO1xuICB9KTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVVdGNGb3JtYXQgPSBkM190aW1lX2Zvcm1hdFV0Yy5tdWx0aShbIFsgXCIuJUxcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB9IF0sIFsgXCI6JVNcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ1NlY29uZHMoKTtcbiAgfSBdLCBbIFwiJUk6JU1cIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01pbnV0ZXMoKTtcbiAgfSBdLCBbIFwiJUkgJXBcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0hvdXJzKCk7XG4gIH0gXSwgWyBcIiVhICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXkoKSAmJiBkLmdldFVUQ0RhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlYiAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiVCXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICB9IF0sIFsgXCIlWVwiLCBkM190cnVlIF0gXSk7XG4gIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzLnllYXIgPSBkM190aW1lLnllYXIudXRjO1xuICBkM190aW1lLnNjYWxlLnV0YyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM190aW1lX3NjYWxlKGQzLnNjYWxlLmxpbmVhcigpLCBkM190aW1lX3NjYWxlVXRjTWV0aG9kcywgZDNfdGltZV9zY2FsZVV0Y0Zvcm1hdCk7XG4gIH07XG4gIGQzLnRleHQgPSBkM194aHJUeXBlKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH0pO1xuICBkMy5qc29uID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkM194aHIodXJsLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgZDNfanNvbiwgY2FsbGJhY2spO1xuICB9O1xuICBmdW5jdGlvbiBkM19qc29uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cbiAgZDMuaHRtbCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfeGhyKHVybCwgXCJ0ZXh0L2h0bWxcIiwgZDNfaHRtbCwgY2FsbGJhY2spO1xuICB9O1xuICBmdW5jdGlvbiBkM19odG1sKHJlcXVlc3QpIHtcbiAgICB2YXIgcmFuZ2UgPSBkM19kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGUoZDNfZG9jdW1lbnQuYm9keSk7XG4gICAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cbiAgZDMueG1sID0gZDNfeGhyVHlwZShmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VYTUw7XG4gIH0pO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHRoaXMuZDMgPSBkMywgZGVmaW5lKGQzKTsgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkMzsgZWxzZSB0aGlzLmQzID0gZDM7XG59KCk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9EaXNwYXRjaGVyJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc3BhdGNoZXJcbiAqIFxuICogQHByZXZlbnRNdW5nZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIF9wcmVmaXggPSAnSURfJztcblxuLyoqXG4gKiBEaXNwYXRjaGVyIGlzIHVzZWQgdG8gYnJvYWRjYXN0IHBheWxvYWRzIHRvIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLiBUaGlzIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSBnZW5lcmljIHB1Yi1zdWIgc3lzdGVtcyBpbiB0d28gd2F5czpcbiAqXG4gKiAgIDEpIENhbGxiYWNrcyBhcmUgbm90IHN1YnNjcmliZWQgdG8gcGFydGljdWxhciBldmVudHMuIEV2ZXJ5IHBheWxvYWQgaXNcbiAqICAgICAgZGlzcGF0Y2hlZCB0byBldmVyeSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICogICAyKSBDYWxsYmFja3MgY2FuIGJlIGRlZmVycmVkIGluIHdob2xlIG9yIHBhcnQgdW50aWwgb3RoZXIgY2FsbGJhY2tzIGhhdmVcbiAqICAgICAgYmVlbiBleGVjdXRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhpcyBoeXBvdGhldGljYWwgZmxpZ2h0IGRlc3RpbmF0aW9uIGZvcm0sIHdoaWNoXG4gKiBzZWxlY3RzIGEgZGVmYXVsdCBjaXR5IHdoZW4gYSBjb3VudHJ5IGlzIHNlbGVjdGVkOlxuICpcbiAqICAgdmFyIGZsaWdodERpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcigpO1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY291bnRyeSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ291bnRyeVN0b3JlID0ge2NvdW50cnk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY2l0eSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ2l0eVN0b3JlID0ge2NpdHk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGJhc2UgZmxpZ2h0IHByaWNlIG9mIHRoZSBzZWxlY3RlZCBjaXR5XG4gKiAgIHZhciBGbGlnaHRQcmljZVN0b3JlID0ge3ByaWNlOiBudWxsfVxuICpcbiAqIFdoZW4gYSB1c2VyIGNoYW5nZXMgdGhlIHNlbGVjdGVkIGNpdHksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NpdHktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENpdHk6ICdwYXJpcydcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGBDaXR5U3RvcmVgOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NpdHktdXBkYXRlJykge1xuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBwYXlsb2FkLnNlbGVjdGVkQ2l0eTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvdW50cnksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NvdW50cnktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENvdW50cnk6ICdhdXN0cmFsaWEnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBib3RoIHN0b3JlczpcbiAqXG4gKiAgIENvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgQ291bnRyeVN0b3JlLmNvdW50cnkgPSBwYXlsb2FkLnNlbGVjdGVkQ291bnRyeTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIGNhbGxiYWNrIHRvIHVwZGF0ZSBgQ291bnRyeVN0b3JlYCBpcyByZWdpc3RlcmVkLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgcmV0dXJuZWQgdG9rZW4uIFVzaW5nIHRoaXMgdG9rZW4gd2l0aCBgd2FpdEZvcigpYCwgd2UgY2FuIGd1YXJhbnRlZVxuICogdGhhdCBgQ291bnRyeVN0b3JlYCBpcyB1cGRhdGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgdGhhdCB1cGRhdGVzIGBDaXR5U3RvcmVgXG4gKiBuZWVkcyB0byBxdWVyeSBpdHMgZGF0YS5cbiAqXG4gKiAgIENpdHlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gKiAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogICAgICAgLy8gU2VsZWN0IHRoZSBkZWZhdWx0IGNpdHkgZm9yIHRoZSBuZXcgY291bnRyeVxuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBnZXREZWZhdWx0Q2l0eUZvckNvdW50cnkoQ291bnRyeVN0b3JlLmNvdW50cnkpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIHVzYWdlIG9mIGB3YWl0Rm9yKClgIGNhbiBiZSBjaGFpbmVkLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgIEZsaWdodFByaWNlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9XG4gKiAgICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uVHlwZSkge1xuICogICAgICAgICBjYXNlICdjb3VudHJ5LXVwZGF0ZSc6XG4gKiAgICAgICAgIGNhc2UgJ2NpdHktdXBkYXRlJzpcbiAqICAgICAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NpdHlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZS5wcmljZSA9XG4gKiAgICAgICAgICAgICBnZXRGbGlnaHRQcmljZVN0b3JlKENvdW50cnlTdG9yZS5jb3VudHJ5LCBDaXR5U3RvcmUuY2l0eSk7XG4gKiAgICAgICAgICAgYnJlYWs7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgYGNvdW50cnktdXBkYXRlYCBwYXlsb2FkIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBpbnZva2UgdGhlIHN0b3JlcydcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIGluIG9yZGVyOiBgQ291bnRyeVN0b3JlYCwgYENpdHlTdG9yZWAsIHRoZW5cbiAqIGBGbGlnaHRQcmljZVN0b3JlYC5cbiAqL1xuXG52YXIgRGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpc3BhdGNoZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzSGFuZGxlZCA9IHt9O1xuICAgIHRoaXMuX2lzUGVuZGluZyA9IHt9O1xuICAgIHRoaXMuX2xhc3RJRCA9IDE7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aXRoIGV2ZXJ5IGRpc3BhdGNoZWQgcGF5bG9hZC4gUmV0dXJuc1xuICAgKiBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgd2FpdEZvcigpYC5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IF9wcmVmaXggKyB0aGlzLl9sYXN0SUQrKztcbiAgICB0aGlzLl9jYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgYmFzZWQgb24gaXRzIHRva2VuLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihpZCkge1xuICAgICF0aGlzLl9jYWxsYmFja3NbaWRdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIudW5yZWdpc3RlciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBjYWxsYmFja3Mgc3BlY2lmaWVkIHRvIGJlIGludm9rZWQgYmVmb3JlIGNvbnRpbnVpbmcgZXhlY3V0aW9uXG4gICAqIG9mIHRoZSBjdXJyZW50IGNhbGxiYWNrLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IGEgY2FsbGJhY2sgaW5cbiAgICogcmVzcG9uc2UgdG8gYSBkaXNwYXRjaGVkIHBheWxvYWQuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiB3YWl0Rm9yKGlkcykge1xuICAgICF0aGlzLl9pc0Rpc3BhdGNoaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBNdXN0IGJlIGludm9rZWQgd2hpbGUgZGlzcGF0Y2hpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpZHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaWldO1xuICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgIXRoaXMuX2lzSGFuZGxlZFtpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgJyArICd3YWl0aW5nIGZvciBgJXNgLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgIXRoaXMuX2NhbGxiYWNrc1tpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIHBheWxvYWQgdG8gYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKHBheWxvYWQpIHtcbiAgICAhIXRoaXMuX2lzRGlzcGF0Y2hpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2guZGlzcGF0Y2goLi4uKTogQ2Fubm90IGRpc3BhdGNoIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9zdG9wRGlzcGF0Y2hpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgRGlzcGF0Y2hlciBjdXJyZW50bHkgZGlzcGF0Y2hpbmcuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmlzRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBpc0Rpc3BhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Rpc3BhdGNoaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjYWxsYmFjayBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWQuIEFsc28gZG8gc29tZSBpbnRlcm5hbFxuICAgKiBib29ra2VlcGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9pbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uIF9pbnZva2VDYWxsYmFjayhpZCkge1xuICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0odGhpcy5fcGVuZGluZ1BheWxvYWQpO1xuICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgYm9va2tlZXBpbmcgbmVlZGVkIHdoZW4gZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5fc3RhcnREaXNwYXRjaGluZyA9IGZ1bmN0aW9uIF9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpIHtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ1BheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBib29ra2VlcGluZyB1c2VkIGZvciBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9zdG9wRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBfc3RvcERpc3BhdGNoaW5nKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUGF5bG9hZDtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIERpc3BhdGNoZXI7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignSW52YXJpYW50IFZpb2xhdGlvbjogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7IiwiLyoqXG4gKiBJbnRyby5qcyB2MS4xLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS91c2FibGljYS9pbnRyby5qc1xuICogTUlUIGxpY2Vuc2VkXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEzIHVzYWJsaS5jYSAtIEEgd2Vla2VuZCBwcm9qZWN0IGJ5IEFmc2hpbiBNZWhyYWJhbmkgKEBhZnNoaW5tZWgpXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBDb21tb25KU1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeShyb290KTtcbiAgfVxufSAodGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgLy9EZWZhdWx0IGNvbmZpZy92YXJpYWJsZXNcbiAgdmFyIFZFUlNJT04gPSAnMS4xLjEnO1xuXG4gIC8qKlxuICAgKiBJbnRyb0pzIG1haW4gY2xhc3NcbiAgICpcbiAgICogQGNsYXNzIEludHJvSnNcbiAgICovXG4gIGZ1bmN0aW9uIEludHJvSnMob2JqKSB7XG4gICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IG9iajtcblxuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAvKiBOZXh0IGJ1dHRvbiBsYWJlbCBpbiB0b29sdGlwIGJveCAqL1xuICAgICAgbmV4dExhYmVsOiAnTmV4dCAmcmFycjsnLFxuICAgICAgLyogUHJldmlvdXMgYnV0dG9uIGxhYmVsIGluIHRvb2x0aXAgYm94ICovXG4gICAgICBwcmV2TGFiZWw6ICcmbGFycjsgQmFjaycsXG4gICAgICAvKiBTa2lwIGJ1dHRvbiBsYWJlbCBpbiB0b29sdGlwIGJveCAqL1xuICAgICAgc2tpcExhYmVsOiAnU2tpcCcsXG4gICAgICAvKiBEb25lIGJ1dHRvbiBsYWJlbCBpbiB0b29sdGlwIGJveCAqL1xuICAgICAgZG9uZUxhYmVsOiAnRG9uZScsXG4gICAgICAvKiBEZWZhdWx0IHRvb2x0aXAgYm94IHBvc2l0aW9uICovXG4gICAgICB0b29sdGlwUG9zaXRpb246ICdib3R0b20nLFxuICAgICAgLyogTmV4dCBDU1MgY2xhc3MgZm9yIHRvb2x0aXAgYm94ZXMgKi9cbiAgICAgIHRvb2x0aXBDbGFzczogJycsXG4gICAgICAvKiBDU1MgY2xhc3MgdGhhdCBpcyBhZGRlZCB0byB0aGUgaGVscGVyTGF5ZXIgKi9cbiAgICAgIGhpZ2hsaWdodENsYXNzOiAnJyxcbiAgICAgIC8qIENsb3NlIGludHJvZHVjdGlvbiB3aGVuIHByZXNzaW5nIEVzY2FwZSBidXR0b24/ICovXG4gICAgICBleGl0T25Fc2M6IHRydWUsXG4gICAgICAvKiBDbG9zZSBpbnRyb2R1Y3Rpb24gd2hlbiBjbGlja2luZyBvbiBvdmVybGF5IGxheWVyPyAqL1xuICAgICAgZXhpdE9uT3ZlcmxheUNsaWNrOiB0cnVlLFxuICAgICAgLyogU2hvdyBzdGVwIG51bWJlcnMgaW4gaW50cm9kdWN0aW9uPyAqL1xuICAgICAgc2hvd1N0ZXBOdW1iZXJzOiB0cnVlLFxuICAgICAgLyogTGV0IHVzZXIgdXNlIGtleWJvYXJkIHRvIG5hdmlnYXRlIHRoZSB0b3VyPyAqL1xuICAgICAga2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuICAgICAgLyogU2hvdyB0b3VyIGNvbnRyb2wgYnV0dG9ucz8gKi9cbiAgICAgIHNob3dCdXR0b25zOiB0cnVlLFxuICAgICAgLyogU2hvdyB0b3VyIGJ1bGxldHM/ICovXG4gICAgICBzaG93QnVsbGV0czogdHJ1ZSxcbiAgICAgIC8qIFNob3cgdG91ciBwcm9ncmVzcz8gKi9cbiAgICAgIHNob3dQcm9ncmVzczogZmFsc2UsXG4gICAgICAvKiBTY3JvbGwgdG8gaGlnaGxpZ2h0ZWQgZWxlbWVudD8gKi9cbiAgICAgIHNjcm9sbFRvRWxlbWVudDogdHJ1ZSxcbiAgICAgIC8qIFNldCB0aGUgb3ZlcmxheSBvcGFjaXR5ICovXG4gICAgICBvdmVybGF5T3BhY2l0eTogMC44LFxuICAgICAgLyogUHJlY2VkZW5jZSBvZiBwb3NpdGlvbnMsIHdoZW4gYXV0byBpcyBlbmFibGVkICovXG4gICAgICBwb3NpdGlvblByZWNlZGVuY2U6IFtcImJvdHRvbVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwibGVmdFwiXSxcbiAgICAgIC8qIERpc2FibGUgYW4gaW50ZXJhY3Rpb24gd2l0aCBlbGVtZW50PyAqL1xuICAgICAgZGlzYWJsZUludGVyYWN0aW9uOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGUgYSBuZXcgaW50cm9kdWN0aW9uL2d1aWRlIGZyb20gYW4gZWxlbWVudCBpbiB0aGUgcGFnZVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfaW50cm9Gb3JFbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRFbG1cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFN1Y2Nlc3Mgb3Igbm90P1xuICAgKi9cbiAgZnVuY3Rpb24gX2ludHJvRm9yRWxlbWVudCh0YXJnZXRFbG0pIHtcbiAgICB2YXIgaW50cm9JdGVtcyA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnN0ZXBzKSB7XG4gICAgICAvL3VzZSBzdGVwcyBwYXNzZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHN0ZXBzTGVuZ3RoID0gdGhpcy5fb3B0aW9ucy5zdGVwcy5sZW5ndGg7IGkgPCBzdGVwc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50SXRlbSA9IF9jbG9uZU9iamVjdCh0aGlzLl9vcHRpb25zLnN0ZXBzW2ldKTtcbiAgICAgICAgLy9zZXQgdGhlIHN0ZXBcbiAgICAgICAgY3VycmVudEl0ZW0uc3RlcCA9IGludHJvSXRlbXMubGVuZ3RoICsgMTtcbiAgICAgICAgLy91c2UgcXVlcnlTZWxlY3RvciBmdW5jdGlvbiBvbmx5IHdoZW4gZGV2ZWxvcGVyIHVzZWQgQ1NTIHNlbGVjdG9yXG4gICAgICAgIGlmICh0eXBlb2YoY3VycmVudEl0ZW0uZWxlbWVudCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy9ncmFiIHRoZSBlbGVtZW50IHdpdGggZ2l2ZW4gc2VsZWN0b3IgZnJvbSB0aGUgcGFnZVxuICAgICAgICAgIGN1cnJlbnRJdGVtLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGN1cnJlbnRJdGVtLmVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbnRybyB3aXRob3V0IGVsZW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZihjdXJyZW50SXRlbS5lbGVtZW50KSA9PT0gJ3VuZGVmaW5lZCcgfHwgY3VycmVudEl0ZW0uZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZsb2F0aW5nRWxlbWVudFF1ZXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5pbnRyb2pzRmxvYXRpbmdFbGVtZW50XCIpO1xuXG4gICAgICAgICAgaWYgKGZsb2F0aW5nRWxlbWVudFF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZsb2F0aW5nRWxlbWVudFF1ZXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBmbG9hdGluZ0VsZW1lbnRRdWVyeS5jbGFzc05hbWUgPSAnaW50cm9qc0Zsb2F0aW5nRWxlbWVudCc7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZmxvYXRpbmdFbGVtZW50UXVlcnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRJdGVtLmVsZW1lbnQgID0gZmxvYXRpbmdFbGVtZW50UXVlcnk7XG4gICAgICAgICAgY3VycmVudEl0ZW0ucG9zaXRpb24gPSAnZmxvYXRpbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGludHJvSXRlbXMucHVzaChjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvL3VzZSBzdGVwcyBmcm9tIGRhdGEtKiBhbm5vdGF0aW9uc1xuICAgICAgdmFyIGFsbEludHJvU3RlcHMgPSB0YXJnZXRFbG0ucXVlcnlTZWxlY3RvckFsbCgnKltkYXRhLWludHJvXScpO1xuICAgICAgLy9pZiB0aGVyZSdzIG5vIGVsZW1lbnQgdG8gaW50cm9cbiAgICAgIGlmIChhbGxJbnRyb1N0ZXBzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2ZpcnN0IGFkZCBpbnRybyBpdGVtcyB3aXRoIGRhdGEtc3RlcFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGVsbXNMZW5ndGggPSBhbGxJbnRyb1N0ZXBzLmxlbmd0aDsgaSA8IGVsbXNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBhbGxJbnRyb1N0ZXBzW2ldO1xuICAgICAgICB2YXIgc3RlcCA9IHBhcnNlSW50KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGVwJyksIDEwKTtcblxuICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICBpbnRyb0l0ZW1zW3N0ZXAgLSAxXSA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGN1cnJlbnRFbGVtZW50LFxuICAgICAgICAgICAgaW50cm86IGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbnRybycpLFxuICAgICAgICAgICAgc3RlcDogcGFyc2VJbnQoY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0ZXAnKSwgMTApLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiBjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcENsYXNzJyksXG4gICAgICAgICAgICBoaWdobGlnaHRDbGFzczogY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWhpZ2hsaWdodENsYXNzJyksXG4gICAgICAgICAgICBwb3NpdGlvbjogY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBvc2l0aW9uJykgfHwgdGhpcy5fb3B0aW9ucy50b29sdGlwUG9zaXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vbmV4dCBhZGQgaW50cm8gaXRlbXMgd2l0aG91dCBkYXRhLXN0ZXBcbiAgICAgIC8vdG9kbzogd2UgbmVlZCBhIGNsZWFudXAgaGVyZSwgdHdvIGxvb3BzIGFyZSByZWR1bmRhbnRcbiAgICAgIHZhciBuZXh0U3RlcCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZWxtc0xlbmd0aCA9IGFsbEludHJvU3RlcHMubGVuZ3RoOyBpIDwgZWxtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IGFsbEludHJvU3RlcHNbaV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGVwJykgPT0gbnVsbCkge1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW50cm9JdGVtc1tuZXh0U3RlcF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0U3RlcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGludHJvSXRlbXNbbmV4dFN0ZXBdID0ge1xuICAgICAgICAgICAgZWxlbWVudDogY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgICBpbnRybzogY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWludHJvJyksXG4gICAgICAgICAgICBzdGVwOiBuZXh0U3RlcCArIDEsXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6IGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwQ2xhc3MnKSxcbiAgICAgICAgICAgIGhpZ2hsaWdodENsYXNzOiBjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGlnaGxpZ2h0Q2xhc3MnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zaXRpb24nKSB8fCB0aGlzLl9vcHRpb25zLnRvb2x0aXBQb3NpdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3JlbW92aW5nIHVuZGVmaW5lZC9udWxsIGVsZW1lbnRzXG4gICAgdmFyIHRlbXBJbnRyb0l0ZW1zID0gW107XG4gICAgZm9yICh2YXIgeiA9IDA7IHogPCBpbnRyb0l0ZW1zLmxlbmd0aDsgeisrKSB7XG4gICAgICBpbnRyb0l0ZW1zW3pdICYmIHRlbXBJbnRyb0l0ZW1zLnB1c2goaW50cm9JdGVtc1t6XSk7ICAvLyBjb3B5IG5vbi1lbXB0eSB2YWx1ZXMgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICB9XG5cbiAgICBpbnRyb0l0ZW1zID0gdGVtcEludHJvSXRlbXM7XG5cbiAgICAvL09rLCBzb3J0IGFsbCBpdGVtcyB3aXRoIGdpdmVuIHN0ZXBzXG4gICAgaW50cm9JdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zdGVwIC0gYi5zdGVwO1xuICAgIH0pO1xuXG4gICAgLy9zZXQgaXQgdG8gdGhlIGludHJvSnMgb2JqZWN0XG4gICAgc2VsZi5faW50cm9JdGVtcyA9IGludHJvSXRlbXM7XG5cbiAgICAvL2FkZCBvdmVybGF5IGxheWVyIHRvIHRoZSBwYWdlXG4gICAgaWYoX2FkZE92ZXJsYXlMYXllci5jYWxsKHNlbGYsIHRhcmdldEVsbSkpIHtcbiAgICAgIC8vdGhlbiwgc3RhcnQgdGhlIHNob3dcbiAgICAgIF9uZXh0U3RlcC5jYWxsKHNlbGYpO1xuXG4gICAgICB2YXIgc2tpcEJ1dHRvbiAgICAgPSB0YXJnZXRFbG0ucXVlcnlTZWxlY3RvcignLmludHJvanMtc2tpcGJ1dHRvbicpLFxuICAgICAgICAgIG5leHRTdGVwQnV0dG9uID0gdGFyZ2V0RWxtLnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLW5leHRidXR0b24nKTtcblxuICAgICAgc2VsZi5fb25LZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiBzZWxmLl9vcHRpb25zLmV4aXRPbkVzYyA9PSB0cnVlKSB7XG4gICAgICAgICAgLy9lc2NhcGUga2V5IHByZXNzZWQsIGV4aXQgdGhlIGludHJvXG4gICAgICAgICAgLy9jaGVjayBpZiBleGl0IGNhbGxiYWNrIGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoc2VsZi5faW50cm9FeGl0Q2FsbGJhY2sgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLl9pbnRyb0V4aXRDYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZXhpdEludHJvLmNhbGwoc2VsZiwgdGFyZ2V0RWxtKTtcbiAgICAgICAgfSBlbHNlIGlmKGUua2V5Q29kZSA9PT0gMzcpIHtcbiAgICAgICAgICAvL2xlZnQgYXJyb3dcbiAgICAgICAgICBfcHJldmlvdXNTdGVwLmNhbGwoc2VsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzOSkge1xuICAgICAgICAgIC8vcmlnaHQgYXJyb3dcbiAgICAgICAgICBfbmV4dFN0ZXAuY2FsbChzZWxmKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgLy9zcmNFbGVtZW50ID09PSBpZVxuICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ2ludHJvanMtcHJldmJ1dHRvbicpID4gMCkge1xuICAgICAgICAgICAgLy91c2VyIGhpdCBlbnRlciB3aGlsZSBmb2N1c2luZyBvbiBwcmV2aW91cyBidXR0b25cbiAgICAgICAgICAgIF9wcmV2aW91c1N0ZXAuY2FsbChzZWxmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ2ludHJvanMtc2tpcGJ1dHRvbicpID4gMCkge1xuICAgICAgICAgICAgLy91c2VyIGhpdCBlbnRlciB3aGlsZSBmb2N1c2luZyBvbiBza2lwIGJ1dHRvblxuICAgICAgICAgICAgaWYgKHNlbGYuX2ludHJvSXRlbXMubGVuZ3RoIC0gMSA9PSBzZWxmLl9jdXJyZW50U3RlcCAmJiB0eXBlb2YgKHNlbGYuX2ludHJvQ29tcGxldGVDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnRyb0NvbXBsZXRlQ2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgYW55IGNhbGxiYWNrIGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnRyb0V4aXRDYWxsYmFjayAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi5faW50cm9FeGl0Q2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9leGl0SW50cm8uY2FsbChzZWxmLCB0YXJnZXRFbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2RlZmF1bHQgYmVoYXZpb3IgZm9yIHJlc3BvbmRpbmcgdG8gZW50ZXJcbiAgICAgICAgICAgIF9uZXh0U3RlcC5jYWxsKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vcHJldmVudCBkZWZhdWx0IGJlaGF2aW91ciBvbiBoaXR0aW5nIEVudGVyLCB0byBwcmV2ZW50IHN0ZXBzIGJlaW5nIHNraXBwZWQgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICAgIGlmKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5fb25SZXNpemUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwoc2VsZiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtaGVscGVyTGF5ZXInKSk7XG4gICAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwoc2VsZiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJykpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2VsZi5fb25LZXlEb3duLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvciB3aW5kb3cgcmVzaXplXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZWxmLl9vblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7IC8vSUVcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5ZG93bicsIHNlbGYuX29uS2V5RG93bik7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3Igd2luZG93IHJlc2l6ZVxuICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZXNpemUnLCBzZWxmLl9vblJlc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gLypcbiAgICogbWFrZXMgYSBjb3B5IG9mIHRoZSBvYmplY3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX2Nsb25lT2JqZWN0XG4gICovXG4gIGZ1bmN0aW9uIF9jbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCB8fCB0eXBlb2YgKG9iamVjdCkgIT0gJ29iamVjdCcgfHwgdHlwZW9mIChvYmplY3Qubm9kZVR5cGUpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIChqUXVlcnkpICE9ICd1bmRlZmluZWQnICYmIG9iamVjdFtrZXldIGluc3RhbmNlb2YgalF1ZXJ5KSB7XG4gICAgICAgICAgdGVtcFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFtrZXldID0gX2Nsb25lT2JqZWN0KG9iamVjdFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXA7XG4gIH1cbiAgLyoqXG4gICAqIEdvIHRvIHNwZWNpZmljIHN0ZXAgb2YgaW50cm9kdWN0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nb1RvU3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gX2dvVG9TdGVwKHN0ZXApIHtcbiAgICAvL2JlY2F1c2Ugc3RlcHMgc3RhcnRzIHdpdGggemVyb1xuICAgIHRoaXMuX2N1cnJlbnRTdGVwID0gc3RlcCAtIDI7XG4gICAgaWYgKHR5cGVvZiAodGhpcy5faW50cm9JdGVtcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfbmV4dFN0ZXAuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gbmV4dCBzdGVwIG9uIGludHJvXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9uZXh0U3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gX25leHRTdGVwKCkge1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9ICdmb3J3YXJkJztcblxuICAgIGlmICh0eXBlb2YgKHRoaXMuX2N1cnJlbnRTdGVwKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGVwID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLl9jdXJyZW50U3RlcDtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMuX2ludHJvSXRlbXMubGVuZ3RoKSA8PSB0aGlzLl9jdXJyZW50U3RlcCkge1xuICAgICAgLy9lbmQgb2YgdGhlIGludHJvXG4gICAgICAvL2NoZWNrIGlmIGFueSBjYWxsYmFjayBpcyBkZWZpbmVkXG4gICAgICBpZiAodHlwZW9mICh0aGlzLl9pbnRyb0NvbXBsZXRlQ2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2ludHJvQ29tcGxldGVDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgX2V4aXRJbnRyby5jYWxsKHRoaXMsIHRoaXMuX3RhcmdldEVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RlcCA9IHRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdO1xuICAgIGlmICh0eXBlb2YgKHRoaXMuX2ludHJvQmVmb3JlQ2hhbmdlQ2FsbGJhY2spICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faW50cm9CZWZvcmVDaGFuZ2VDYWxsYmFjay5jYWxsKHRoaXMsIG5leHRTdGVwLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIF9zaG93RWxlbWVudC5jYWxsKHRoaXMsIG5leHRTdGVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byBwcmV2aW91cyBzdGVwIG9uIGludHJvXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9uZXh0U3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gX3ByZXZpb3VzU3RlcCgpIHtcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGVwID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGVwID0gdGhpcy5faW50cm9JdGVtc1stLXRoaXMuX2N1cnJlbnRTdGVwXTtcbiAgICBpZiAodHlwZW9mICh0aGlzLl9pbnRyb0JlZm9yZUNoYW5nZUNhbGxiYWNrKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2ludHJvQmVmb3JlQ2hhbmdlQ2FsbGJhY2suY2FsbCh0aGlzLCBuZXh0U3RlcC5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBfc2hvd0VsZW1lbnQuY2FsbCh0aGlzLCBuZXh0U3RlcCk7XG4gIH1cblxuICAvKipcbiAgICogRXhpdCBmcm9tIGludHJvXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9leGl0SW50cm9cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIF9leGl0SW50cm8odGFyZ2V0RWxlbWVudCkge1xuICAgIC8vcmVtb3ZlIG92ZXJsYXkgbGF5ZXIgZnJvbSB0aGUgcGFnZVxuICAgIHZhciBvdmVybGF5TGF5ZXIgPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLW92ZXJsYXknKTtcblxuICAgIC8vcmV0dXJuIGlmIGludHJvIGFscmVhZHkgY29tcGxldGVkIG9yIHNraXBwZWRcbiAgICBpZiAob3ZlcmxheUxheWVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL2ZvciBmYWRlLW91dCBhbmltYXRpb25cbiAgICBvdmVybGF5TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3ZlcmxheUxheWVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgb3ZlcmxheUxheWVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3ZlcmxheUxheWVyKTtcbiAgICAgIH1cbiAgICB9LCA1MDApO1xuXG4gICAgLy9yZW1vdmUgYWxsIGhlbHBlciBsYXllcnNcbiAgICB2YXIgaGVscGVyTGF5ZXIgPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLWhlbHBlckxheWVyJyk7XG4gICAgaWYgKGhlbHBlckxheWVyKSB7XG4gICAgICBoZWxwZXJMYXllci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhlbHBlckxheWVyKTtcbiAgICB9XG5cbiAgICB2YXIgcmVmZXJlbmNlTGF5ZXIgPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLXRvb2x0aXBSZWZlcmVuY2VMYXllcicpO1xuICAgIGlmIChyZWZlcmVuY2VMYXllcikge1xuICAgICAgcmVmZXJlbmNlTGF5ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZWZlcmVuY2VMYXllcik7XG4gICAgfVxuICAgIC8vcmVtb3ZlIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyXG4gICAgdmFyIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyID0gdGFyZ2V0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1kaXNhYmxlSW50ZXJhY3Rpb24nKTtcbiAgICBpZiAoZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIpIHtcbiAgICAgIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIpO1xuICAgIH1cblxuICAgIC8vcmVtb3ZlIGludHJvIGZsb2F0aW5nIGVsZW1lbnRcbiAgICB2YXIgZmxvYXRpbmdFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanNGbG9hdGluZ0VsZW1lbnQnKTtcbiAgICBpZiAoZmxvYXRpbmdFbGVtZW50KSB7XG4gICAgICBmbG9hdGluZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmbG9hdGluZ0VsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vcmVtb3ZlIGBpbnRyb2pzLXNob3dFbGVtZW50YCBjbGFzcyBmcm9tIHRoZSBlbGVtZW50XG4gICAgdmFyIHNob3dFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtc2hvd0VsZW1lbnQnKTtcbiAgICBpZiAoc2hvd0VsZW1lbnQpIHtcbiAgICAgIHNob3dFbGVtZW50LmNsYXNzTmFtZSA9IHNob3dFbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKC9pbnRyb2pzLVthLXpBLVpdKy9nLCAnJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBUaGlzIGlzIGEgbWFudWFsIHRyaW0uXG4gICAgfVxuXG4gICAgLy9yZW1vdmUgYGludHJvanMtZml4UGFyZW50YCBjbGFzcyBmcm9tIHRoZSBlbGVtZW50c1xuICAgIHZhciBmaXhQYXJlbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmludHJvanMtZml4UGFyZW50Jyk7XG4gICAgaWYgKGZpeFBhcmVudHMgJiYgZml4UGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gZml4UGFyZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmaXhQYXJlbnRzW2ldLmNsYXNzTmFtZSA9IGZpeFBhcmVudHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoL2ludHJvanMtZml4UGFyZW50L2csICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jbGVhbiBsaXN0ZW5lcnNcbiAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmRldGFjaEV2ZW50KSB7IC8vSUVcbiAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KCdvbmtleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xuICAgIH1cblxuICAgIC8vc2V0IHRoZSBzdGVwIHRvIHplcm9cbiAgICB0aGlzLl9jdXJyZW50U3RlcCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdG9vbHRpcCBib3ggaW4gdGhlIHBhZ2VcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX3BsYWNlVG9vbHRpcFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvb2x0aXBMYXllclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhcnJvd0xheWVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhlbHBlck51bWJlckxheWVyXG4gICAqL1xuICBmdW5jdGlvbiBfcGxhY2VUb29sdGlwKHRhcmdldEVsZW1lbnQsIHRvb2x0aXBMYXllciwgYXJyb3dMYXllciwgaGVscGVyTnVtYmVyTGF5ZXIpIHtcbiAgICB2YXIgdG9vbHRpcENzc0NsYXNzID0gJycsXG4gICAgICAgIGN1cnJlbnRTdGVwT2JqLFxuICAgICAgICB0b29sdGlwT2Zmc2V0LFxuICAgICAgICB0YXJnZXRPZmZzZXQsXG4gICAgICAgIHdpbmRvd1NpemUsXG4gICAgICAgIGN1cnJlbnRUb29sdGlwUG9zaXRpb247XG5cbiAgICAvL3Jlc2V0IHRoZSBvbGQgc3R5bGVcbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUudG9wICAgICAgICA9IG51bGw7XG4gICAgdG9vbHRpcExheWVyLnN0eWxlLnJpZ2h0ICAgICAgPSBudWxsO1xuICAgIHRvb2x0aXBMYXllci5zdHlsZS5ib3R0b20gICAgID0gbnVsbDtcbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUubGVmdCAgICAgICA9IG51bGw7XG4gICAgdG9vbHRpcExheWVyLnN0eWxlLm1hcmdpbkxlZnQgPSBudWxsO1xuICAgIHRvb2x0aXBMYXllci5zdHlsZS5tYXJnaW5Ub3AgID0gbnVsbDtcblxuICAgIGFycm93TGF5ZXIuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcblxuICAgIGlmICh0eXBlb2YoaGVscGVyTnVtYmVyTGF5ZXIpICE9ICd1bmRlZmluZWQnICYmIGhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgIGhlbHBlck51bWJlckxheWVyLnN0eWxlLnRvcCAgPSBudWxsO1xuICAgICAgaGVscGVyTnVtYmVyTGF5ZXIuc3R5bGUubGVmdCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy9wcmV2ZW50IGVycm9yIHdoZW4gYHRoaXMuX2N1cnJlbnRTdGVwYCBpcyB1bmRlZmluZWRcbiAgICBpZiAoIXRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdKSByZXR1cm47XG5cbiAgICAvL2lmIHdlIGhhdmUgYSBjdXN0b20gY3NzIGNsYXNzIGZvciBlYWNoIHN0ZXBcbiAgICBjdXJyZW50U3RlcE9iaiA9IHRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdO1xuICAgIGlmICh0eXBlb2YgKGN1cnJlbnRTdGVwT2JqLnRvb2x0aXBDbGFzcykgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0b29sdGlwQ3NzQ2xhc3MgPSBjdXJyZW50U3RlcE9iai50b29sdGlwQ2xhc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXBDc3NDbGFzcyA9IHRoaXMuX29wdGlvbnMudG9vbHRpcENsYXNzO1xuICAgIH1cblxuICAgIHRvb2x0aXBMYXllci5jbGFzc05hbWUgPSAoJ2ludHJvanMtdG9vbHRpcCAnICsgdG9vbHRpcENzc0NsYXNzKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cbiAgICBjdXJyZW50VG9vbHRpcFBvc2l0aW9uID0gdGhpcy5faW50cm9JdGVtc1t0aGlzLl9jdXJyZW50U3RlcF0ucG9zaXRpb247XG4gICAgaWYgKChjdXJyZW50VG9vbHRpcFBvc2l0aW9uID09IFwiYXV0b1wiIHx8IHRoaXMuX29wdGlvbnMudG9vbHRpcFBvc2l0aW9uID09IFwiYXV0b1wiKSkge1xuICAgICAgaWYgKGN1cnJlbnRUb29sdGlwUG9zaXRpb24gIT0gXCJmbG9hdGluZ1wiKSB7IC8vIEZsb2F0aW5nIGlzIGFsd2F5cyB2YWxpZCwgbm8gcG9pbnQgaW4gY2FsY3VsYXRpbmdcbiAgICAgICAgY3VycmVudFRvb2x0aXBQb3NpdGlvbiA9IF9kZXRlcm1pbmVBdXRvUG9zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXRFbGVtZW50LCB0b29sdGlwTGF5ZXIsIGN1cnJlbnRUb29sdGlwUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXRPZmZzZXQgID0gX2dldE9mZnNldCh0YXJnZXRFbGVtZW50KTtcbiAgICB0b29sdGlwT2Zmc2V0ID0gX2dldE9mZnNldCh0b29sdGlwTGF5ZXIpO1xuICAgIHdpbmRvd1NpemUgICAgPSBfZ2V0V2luU2l6ZSgpO1xuICAgIHN3aXRjaCAoY3VycmVudFRvb2x0aXBQb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1hcnJvdyBib3R0b20nO1xuXG4gICAgICAgIHZhciB0b29sdGlwTGF5ZXJTdHlsZUxlZnQgPSAxNTtcbiAgICAgICAgX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnQsIHRvb2x0aXBPZmZzZXQsIHdpbmRvd1NpemUsIHRvb2x0aXBMYXllcik7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5ib3R0b20gPSAodGFyZ2V0T2Zmc2V0LmhlaWdodCArICAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLmxlZnQgPSAodGFyZ2V0T2Zmc2V0LndpZHRoICsgMjApICsgJ3B4JztcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldC50b3AgKyB0b29sdGlwT2Zmc2V0LmhlaWdodCA+IHdpbmRvd1NpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCByaWdodCB3b3VsZCBoYXZlIGZhbGxlbiBiZWxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgICAgLy8gTW9kaWZ5IHNvIHRoYXQgdGhlIGJvdHRvbSBvZiB0aGUgdG9vbHRpcCBjb25uZWN0cyB3aXRoIHRoZSB0YXJnZXRcbiAgICAgICAgICBhcnJvd0xheWVyLmNsYXNzTmFtZSA9IFwiaW50cm9qcy1hcnJvdyBsZWZ0LWJvdHRvbVwiO1xuICAgICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgPSBcIi1cIiArICh0b29sdGlwT2Zmc2V0LmhlaWdodCAtIHRhcmdldE9mZnNldC5oZWlnaHQgLSAyMCkgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1hcnJvdyBsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zaG93U3RlcE51bWJlcnMgPT0gdHJ1ZSkge1xuICAgICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgPSAnMTVweCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0T2Zmc2V0LnRvcCArIHRvb2x0aXBPZmZzZXQuaGVpZ2h0ID4gd2luZG93U2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGxlZnQgd291bGQgaGF2ZSBmYWxsZW4gYmVsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuLlxuICAgICAgICAgIC8vIE1vZGlmeSBzbyB0aGF0IHRoZSBib3R0b20gb2YgdGhlIHRvb2x0aXAgY29ubmVjdHMgd2l0aCB0aGUgdGFyZ2V0XG4gICAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLnRvcCA9IFwiLVwiICsgKHRvb2x0aXBPZmZzZXQuaGVpZ2h0IC0gdGFyZ2V0T2Zmc2V0LmhlaWdodCAtIDIwKSArIFwicHhcIjtcbiAgICAgICAgICBhcnJvd0xheWVyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWFycm93IHJpZ2h0LWJvdHRvbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1hcnJvdyByaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLnJpZ2h0ID0gKHRhcmdldE9mZnNldC53aWR0aCArIDIwKSArICdweCc7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdGluZyc6XG4gICAgICAgIGFycm93TGF5ZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAvL3dlIGhhdmUgdG8gYWRqdXN0IHRoZSB0b3AgYW5kIGxlZnQgb2YgbGF5ZXIgbWFudWFsbHkgZm9yIGludHJvIGl0ZW1zIHdpdGhvdXQgZWxlbWVudFxuICAgICAgICB0b29sdGlwTGF5ZXIuc3R5bGUubGVmdCAgID0gJzUwJSc7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgICAgPSAnNTAlJztcbiAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLm1hcmdpbkxlZnQgPSAnLScgKyAodG9vbHRpcE9mZnNldC53aWR0aCAvIDIpICArICdweCc7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5tYXJnaW5Ub3AgID0gJy0nICsgKHRvb2x0aXBPZmZzZXQuaGVpZ2h0IC8gMikgKyAncHgnO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaGVscGVyTnVtYmVyTGF5ZXIpICE9ICd1bmRlZmluZWQnICYmIGhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICBoZWxwZXJOdW1iZXJMYXllci5zdHlsZS5sZWZ0ID0gJy0nICsgKCh0b29sdGlwT2Zmc2V0LndpZHRoIC8gMikgKyAxOCkgKyAncHgnO1xuICAgICAgICAgIGhlbHBlck51bWJlckxheWVyLnN0eWxlLnRvcCAgPSAnLScgKyAoKHRvb2x0aXBPZmZzZXQuaGVpZ2h0IC8gMikgKyAxOCkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQtYWxpZ25lZCc6XG4gICAgICAgIGFycm93TGF5ZXIuY2xhc3NOYW1lICAgICAgPSAnaW50cm9qcy1hcnJvdyB0b3AtcmlnaHQnO1xuXG4gICAgICAgIHZhciB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0ID0gMDtcbiAgICAgICAgX2NoZWNrTGVmdCh0YXJnZXRPZmZzZXQsIHRvb2x0aXBMYXllclN0eWxlUmlnaHQsIHRvb2x0aXBPZmZzZXQsIHRvb2x0aXBMYXllcik7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgICAgPSAodGFyZ2V0T2Zmc2V0LmhlaWdodCArICAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tLW1pZGRsZS1hbGlnbmVkJzpcbiAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgICAgICA9ICdpbnRyb2pzLWFycm93IHRvcC1taWRkbGUnO1xuXG4gICAgICAgIHZhciB0b29sdGlwTGF5ZXJTdHlsZUxlZnRSaWdodCA9IHRhcmdldE9mZnNldC53aWR0aCAvIDIgLSB0b29sdGlwT2Zmc2V0LndpZHRoIC8gMjtcbiAgICAgICAgaWYgKF9jaGVja0xlZnQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnRSaWdodCwgdG9vbHRpcE9mZnNldCwgdG9vbHRpcExheWVyKSkge1xuICAgICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5yaWdodCA9IG51bGw7XG4gICAgICAgICAgX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnRSaWdodCwgdG9vbHRpcE9mZnNldCwgd2luZG93U2l6ZSwgdG9vbHRpcExheWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwTGF5ZXIuc3R5bGUudG9wID0gKHRhcmdldE9mZnNldC5oZWlnaHQgKyAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tLWxlZnQtYWxpZ25lZCc6XG4gICAgICAvLyBCb3R0b20tbGVmdC1hbGlnbmVkIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0IGJvdHRvbVxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIC8vIEJvdHRvbSBnb2luZyB0byBmb2xsb3cgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFycm93TGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtYXJyb3cgdG9wJztcblxuICAgICAgICB2YXIgdG9vbHRpcExheWVyU3R5bGVMZWZ0ID0gMDtcbiAgICAgICAgX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnQsIHRvb2x0aXBPZmZzZXQsIHdpbmRvd1NpemUsIHRvb2x0aXBMYXllcik7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgICAgPSAodGFyZ2V0T2Zmc2V0LmhlaWdodCArICAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRvb2x0aXAgbGVmdCBzbyBpdCBkb2Vzbid0IGdvIG9mZiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgd2luZG93XG4gICAqXG4gICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlLCBpZiB0b29sdGlwTGF5ZXJTdHlsZUxlZnQgaXMgb2suICBmYWxzZSwgb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnQsIHRvb2x0aXBPZmZzZXQsIHdpbmRvd1NpemUsIHRvb2x0aXBMYXllcikge1xuICAgIGlmICh0YXJnZXRPZmZzZXQubGVmdCArIHRvb2x0aXBMYXllclN0eWxlTGVmdCArIHRvb2x0aXBPZmZzZXQud2lkdGggPiB3aW5kb3dTaXplLndpZHRoKSB7XG4gICAgICAvLyBvZmYgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHdpbmRvd1xuICAgICAgdG9vbHRpcExheWVyLnN0eWxlLmxlZnQgPSAod2luZG93U2l6ZS53aWR0aCAtIHRvb2x0aXBPZmZzZXQud2lkdGggLSB0YXJnZXRPZmZzZXQubGVmdCkgKyAncHgnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUubGVmdCA9IHRvb2x0aXBMYXllclN0eWxlTGVmdCArICdweCc7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRvb2x0aXAgcmlnaHQgc28gaXQgZG9lc24ndCBnbyBvZmYgdGhlIGxlZnQgc2lkZSBvZiB0aGUgd2luZG93XG4gICAqXG4gICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlLCBpZiB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0IGlzIG9rLiAgZmFsc2UsIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9jaGVja0xlZnQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0LCB0b29sdGlwT2Zmc2V0LCB0b29sdGlwTGF5ZXIpIHtcbiAgICBpZiAodGFyZ2V0T2Zmc2V0LmxlZnQgKyB0YXJnZXRPZmZzZXQud2lkdGggLSB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0IC0gdG9vbHRpcE9mZnNldC53aWR0aCA8IDApIHtcbiAgICAgIC8vIG9mZiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB3aW5kb3dcbiAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5sZWZ0ID0gKC10YXJnZXRPZmZzZXQubGVmdCkgKyAncHgnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUucmlnaHQgPSB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0ICsgJ3B4JztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCBiYXNlZCBvbiB0aGUgcG9zaXRpb24gcHJlY2VkZW5jZSBhbmQgYXZhaWxhYmlsaXR5XG4gICAqIG9mIHNjcmVlbiBzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2x0aXBMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzaXJlZFRvb2x0aXBQb3NpdGlvblxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gX2RldGVybWluZUF1dG9Qb3NpdGlvbih0YXJnZXRFbGVtZW50LCB0b29sdGlwTGF5ZXIsIGRlc2lyZWRUb29sdGlwUG9zaXRpb24pIHtcblxuICAgIC8vIFRha2UgYSBjbG9uZSBvZiBwb3NpdGlvbiBwcmVjZWRlbmNlLiBUaGVzZSB3aWxsIGJlIHRoZSBhdmFpbGFibGVcbiAgICB2YXIgcG9zc2libGVQb3NpdGlvbnMgPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUHJlY2VkZW5jZS5zbGljZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSBfZ2V0V2luU2l6ZSgpO1xuICAgIHZhciB0b29sdGlwSGVpZ2h0ID0gX2dldE9mZnNldCh0b29sdGlwTGF5ZXIpLmhlaWdodCArIDEwO1xuICAgIHZhciB0b29sdGlwV2lkdGggPSBfZ2V0T2Zmc2V0KHRvb2x0aXBMYXllcikud2lkdGggKyAyMDtcbiAgICB2YXIgdGFyZ2V0T2Zmc2V0ID0gX2dldE9mZnNldCh0YXJnZXRFbGVtZW50KTtcblxuICAgIC8vIElmIHdlIGNoZWNrIGFsbCB0aGUgcG9zc2libGUgYXJlYXMsIGFuZCB0aGVyZSBhcmUgbm8gdmFsaWQgcGxhY2VzIGZvciB0aGUgdG9vbHRpcCwgdGhlIGVsZW1lbnRcbiAgICAvLyBtdXN0IHRha2UgdXAgbW9zdCBvZiB0aGUgc2NyZWVuIHJlYWwgZXN0YXRlLiBTaG93IHRoZSB0b29sdGlwIGZsb2F0aW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cbiAgICB2YXIgY2FsY3VsYXRlZFBvc2l0aW9uID0gXCJmbG9hdGluZ1wiO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHdpZHRoIG9mIHRoZSB0b29sdGlwICsgdGhlIHN0YXJ0aW5nIHBvaW50IHdvdWxkIHNwaWxsIG9mZiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc2NyZWVuXG4gICAgLy8gSWYgbm8sIG5laXRoZXIgYm90dG9tIG9yIHRvcCBhcmUgdmFsaWRcbiAgICBpZiAodGFyZ2V0T2Zmc2V0LmxlZnQgKyB0b29sdGlwV2lkdGggPiB3aW5kb3dTaXplLndpZHRoIHx8ICgodGFyZ2V0T2Zmc2V0LmxlZnQgKyAodGFyZ2V0T2Zmc2V0LndpZHRoIC8gMikpIC0gdG9vbHRpcFdpZHRoKSA8IDApIHtcbiAgICAgIF9yZW1vdmVFbnRyeShwb3NzaWJsZVBvc2l0aW9ucywgXCJib3R0b21cIik7XG4gICAgICBfcmVtb3ZlRW50cnkocG9zc2libGVQb3NpdGlvbnMsIFwidG9wXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBmb3Igc3BhY2UgYmVsb3dcbiAgICAgIGlmICgodGFyZ2V0T2Zmc2V0LmhlaWdodCArIHRhcmdldE9mZnNldC50b3AgKyB0b29sdGlwSGVpZ2h0KSA+IHdpbmRvd1NpemUuaGVpZ2h0KSB7XG4gICAgICAgIF9yZW1vdmVFbnRyeShwb3NzaWJsZVBvc2l0aW9ucywgXCJib3R0b21cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzcGFjZSBhYm92ZVxuICAgICAgaWYgKHRhcmdldE9mZnNldC50b3AgLSB0b29sdGlwSGVpZ2h0IDwgMCkge1xuICAgICAgICBfcmVtb3ZlRW50cnkocG9zc2libGVQb3NpdGlvbnMsIFwidG9wXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzcGFjZSB0byB0aGUgcmlnaHRcbiAgICBpZiAodGFyZ2V0T2Zmc2V0LndpZHRoICsgdGFyZ2V0T2Zmc2V0LmxlZnQgKyB0b29sdGlwV2lkdGggPiB3aW5kb3dTaXplLndpZHRoKSB7XG4gICAgICBfcmVtb3ZlRW50cnkocG9zc2libGVQb3NpdGlvbnMsIFwicmlnaHRcIik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHNwYWNlIHRvIHRoZSBsZWZ0XG4gICAgaWYgKHRhcmdldE9mZnNldC5sZWZ0IC0gdG9vbHRpcFdpZHRoIDwgMCkge1xuICAgICAgX3JlbW92ZUVudHJ5KHBvc3NpYmxlUG9zaXRpb25zLCBcImxlZnRcIik7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgb3VyIGFycmF5IG9ubHkgaGFzIHBvc2l0aW9ucyB0aGF0IGFyZSB2YWxpZC4gUGljayB0aGUgZmlyc3Qgb25lLCBhcyBpdCByZW1haW5zIGluIG9yZGVyXG4gICAgaWYgKHBvc3NpYmxlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNhbGN1bGF0ZWRQb3NpdGlvbiA9IHBvc3NpYmxlUG9zaXRpb25zWzBdO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgaW4gdGhlIGxpc3QsIHJlcGxhY2Ugb3VyIGNhbGN1bGF0ZWQgY2hvaWNlIHdpdGggdGhhdFxuICAgIGlmIChkZXNpcmVkVG9vbHRpcFBvc2l0aW9uICYmIGRlc2lyZWRUb29sdGlwUG9zaXRpb24gIT0gXCJhdXRvXCIpIHtcbiAgICAgIGlmIChwb3NzaWJsZVBvc2l0aW9ucy5pbmRleE9mKGRlc2lyZWRUb29sdGlwUG9zaXRpb24pID4gLTEpIHtcbiAgICAgICAgY2FsY3VsYXRlZFBvc2l0aW9uID0gZGVzaXJlZFRvb2x0aXBQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2FsY3VsYXRlZFBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIGEgc3RyaW5nIGFycmF5IGlmIGl0J3MgdGhlcmUsIGRvZXMgbm90aGluZyBpZiBpdCBpc24ndCB0aGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyaW5nQXJyYXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmVtb3ZlXG4gICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRW50cnkoc3RyaW5nQXJyYXksIHN0cmluZ1RvUmVtb3ZlKSB7XG4gICAgaWYgKHN0cmluZ0FycmF5LmluZGV4T2Yoc3RyaW5nVG9SZW1vdmUpID4gLTEpIHtcbiAgICAgIHN0cmluZ0FycmF5LnNwbGljZShzdHJpbmdBcnJheS5pbmRleE9mKHN0cmluZ1RvUmVtb3ZlKSwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBsYXllciBvbiB0aGUgc2NyZWVuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWxwZXJMYXllclxuICAgKi9cbiAgZnVuY3Rpb24gX3NldEhlbHBlckxheWVyUG9zaXRpb24oaGVscGVyTGF5ZXIpIHtcbiAgICBpZiAoaGVscGVyTGF5ZXIpIHtcbiAgICAgIC8vcHJldmVudCBlcnJvciB3aGVuIGB0aGlzLl9jdXJyZW50U3RlcGAgaW4gdW5kZWZpbmVkXG4gICAgICBpZiAoIXRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdKSByZXR1cm47XG5cbiAgICAgIHZhciBjdXJyZW50RWxlbWVudCAgPSB0aGlzLl9pbnRyb0l0ZW1zW3RoaXMuX2N1cnJlbnRTdGVwXSxcbiAgICAgICAgICBlbGVtZW50UG9zaXRpb24gPSBfZ2V0T2Zmc2V0KGN1cnJlbnRFbGVtZW50LmVsZW1lbnQpLFxuICAgICAgICAgIHdpZHRoSGVpZ2h0UGFkZGluZyA9IDEwO1xuXG4gICAgICBpZiAoY3VycmVudEVsZW1lbnQucG9zaXRpb24gPT0gJ2Zsb2F0aW5nJykge1xuICAgICAgICB3aWR0aEhlaWdodFBhZGRpbmcgPSAwO1xuICAgICAgfVxuXG4gICAgICAvL3NldCBuZXcgcG9zaXRpb24gdG8gaGVscGVyIGxheWVyXG4gICAgICBoZWxwZXJMYXllci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAnICsgKGVsZW1lbnRQb3NpdGlvbi53aWR0aCAgKyB3aWR0aEhlaWdodFBhZGRpbmcpICArICdweDsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodDonICsgKGVsZW1lbnRQb3NpdGlvbi5oZWlnaHQgKyB3aWR0aEhlaWdodFBhZGRpbmcpICArICdweDsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcDonICAgICsgKGVsZW1lbnRQb3NpdGlvbi50b3AgICAgLSA1KSAgICsgJ3B4OycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0OiAnICArIChlbGVtZW50UG9zaXRpb24ubGVmdCAgIC0gNSkgICArICdweDsnKTtcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGlzYWJsZWludGVyYWN0aW9uIGxheWVyIGFuZCBhZGp1c3QgdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoZSBsYXllclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfZGlzYWJsZUludGVyYWN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBfZGlzYWJsZUludGVyYWN0aW9uICgpIHtcbiAgICB2YXIgZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1kaXNhYmxlSW50ZXJhY3Rpb24nKTtcbiAgICBpZiAoZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXNhYmxlSW50ZXJhY3Rpb25MYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1kaXNhYmxlSW50ZXJhY3Rpb24nO1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChkaXNhYmxlSW50ZXJhY3Rpb25MYXllcik7XG4gICAgfVxuXG4gICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbCh0aGlzLCBkaXNhYmxlSW50ZXJhY3Rpb25MYXllcik7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhbiBlbGVtZW50IG9uIHRoZSBwYWdlXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9zaG93RWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0RWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gX3Nob3dFbGVtZW50KHRhcmdldEVsZW1lbnQpIHtcblxuICAgIGlmICh0eXBlb2YgKHRoaXMuX2ludHJvQ2hhbmdlQ2FsbGJhY2spICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faW50cm9DaGFuZ2VDYWxsYmFjay5jYWxsKHRoaXMsIHRhcmdldEVsZW1lbnQuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBvbGRIZWxwZXJMYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLWhlbHBlckxheWVyJyksXG4gICAgICAgIG9sZFJlZmVyZW5jZUxheWVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJyksXG4gICAgICAgIGhpZ2hsaWdodENsYXNzID0gJ2ludHJvanMtaGVscGVyTGF5ZXInLFxuICAgICAgICBlbGVtZW50UG9zaXRpb24gPSBfZ2V0T2Zmc2V0KHRhcmdldEVsZW1lbnQuZWxlbWVudCk7XG5cbiAgICAvL2NoZWNrIGZvciBhIGN1cnJlbnQgc3RlcCBoaWdobGlnaHQgY2xhc3NcbiAgICBpZiAodHlwZW9mICh0YXJnZXRFbGVtZW50LmhpZ2hsaWdodENsYXNzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhpZ2hsaWdodENsYXNzICs9ICgnICcgKyB0YXJnZXRFbGVtZW50LmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG4gICAgLy9jaGVjayBmb3Igb3B0aW9ucyBoaWdobGlnaHQgY2xhc3NcbiAgICBpZiAodHlwZW9mICh0aGlzLl9vcHRpb25zLmhpZ2hsaWdodENsYXNzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhpZ2hsaWdodENsYXNzICs9ICgnICcgKyB0aGlzLl9vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAob2xkSGVscGVyTGF5ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEhlbHBlck51bWJlckxheWVyID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtaGVscGVyTnVtYmVyTGF5ZXInKSxcbiAgICAgICAgICBvbGR0b29sdGlwTGF5ZXIgICAgICA9IG9sZFJlZmVyZW5jZUxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLXRvb2x0aXB0ZXh0JyksXG4gICAgICAgICAgb2xkQXJyb3dMYXllciAgICAgICAgPSBvbGRSZWZlcmVuY2VMYXllci5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1hcnJvdycpLFxuICAgICAgICAgIG9sZHRvb2x0aXBDb250YWluZXIgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcCcpLFxuICAgICAgICAgIHNraXBUb29sdGlwQnV0dG9uICAgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtc2tpcGJ1dHRvbicpLFxuICAgICAgICAgIHByZXZUb29sdGlwQnV0dG9uICAgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtcHJldmJ1dHRvbicpLFxuICAgICAgICAgIG5leHRUb29sdGlwQnV0dG9uICAgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtbmV4dGJ1dHRvbicpO1xuXG4gICAgICAvL3VwZGF0ZSBvciByZXNldCB0aGUgaGVscGVyIGhpZ2hsaWdodCBjbGFzc1xuICAgICAgb2xkSGVscGVyTGF5ZXIuY2xhc3NOYW1lID0gaGlnaGxpZ2h0Q2xhc3M7XG4gICAgICAvL2hpZGUgdGhlIHRvb2x0aXBcbiAgICAgIG9sZHRvb2x0aXBDb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICBvbGR0b29sdGlwQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgICAgaWYgKG9sZEhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxhc3RJbnRyb0l0ZW0gPSB0aGlzLl9pbnRyb0l0ZW1zWyh0YXJnZXRFbGVtZW50LnN0ZXAgLSAyID49IDAgPyB0YXJnZXRFbGVtZW50LnN0ZXAgLSAyIDogMCldO1xuXG4gICAgICAgIGlmIChsYXN0SW50cm9JdGVtICE9IG51bGwgJiYgKHRoaXMuX2RpcmVjdGlvbiA9PSAnZm9yd2FyZCcgJiYgbGFzdEludHJvSXRlbS5wb3NpdGlvbiA9PSAnZmxvYXRpbmcnKSB8fCAodGhpcy5fZGlyZWN0aW9uID09ICdiYWNrd2FyZCcgJiYgdGFyZ2V0RWxlbWVudC5wb3NpdGlvbiA9PSAnZmxvYXRpbmcnKSkge1xuICAgICAgICAgIG9sZEhlbHBlck51bWJlckxheWVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vc2V0IG5ldyBwb3NpdGlvbiB0byBoZWxwZXIgbGF5ZXJcbiAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwoc2VsZiwgb2xkSGVscGVyTGF5ZXIpO1xuICAgICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbChzZWxmLCBvbGRSZWZlcmVuY2VMYXllcik7XG5cbiAgICAgIC8vcmVtb3ZlIGBpbnRyb2pzLWZpeFBhcmVudGAgY2xhc3MgZnJvbSB0aGUgZWxlbWVudHNcbiAgICAgIHZhciBmaXhQYXJlbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmludHJvanMtZml4UGFyZW50Jyk7XG4gICAgICBpZiAoZml4UGFyZW50cyAmJiBmaXhQYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpeFBhcmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBmaXhQYXJlbnRzW2ldLmNsYXNzTmFtZSA9IGZpeFBhcmVudHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoL2ludHJvanMtZml4UGFyZW50L2csICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vcmVtb3ZlIG9sZCBjbGFzc2VzXG4gICAgICB2YXIgb2xkU2hvd0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1zaG93RWxlbWVudCcpO1xuICAgICAgb2xkU2hvd0VsZW1lbnQuY2xhc3NOYW1lID0gb2xkU2hvd0VsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ludHJvanMtW2EtekEtWl0rL2csICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cbiAgICAgIC8vd2Ugc2hvdWxkIHdhaXQgdW50aWwgdGhlIENTUzMgdHJhbnNpdGlvbiBpcyBjb21wZXRlZCAoaXQncyAwLjMgc2VjKSB0byBwcmV2ZW50IGluY29ycmVjdCBgaGVpZ2h0YCBhbmQgYHdpZHRoYCBjYWxjdWxhdGlvblxuICAgICAgaWYgKHNlbGYuX2xhc3RTaG93RWxlbWVudFRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9sYXN0U2hvd0VsZW1lbnRUaW1lcik7XG4gICAgICB9XG4gICAgICBzZWxmLl9sYXN0U2hvd0VsZW1lbnRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vc2V0IGN1cnJlbnQgc3RlcCB0byB0aGUgbGFiZWxcbiAgICAgICAgaWYgKG9sZEhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICBvbGRIZWxwZXJOdW1iZXJMYXllci5pbm5lckhUTUwgPSB0YXJnZXRFbGVtZW50LnN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgLy9zZXQgY3VycmVudCB0b29sdGlwIHRleHRcbiAgICAgICAgb2xkdG9vbHRpcExheWVyLmlubmVySFRNTCA9IHRhcmdldEVsZW1lbnQuaW50cm87XG4gICAgICAgIC8vc2V0IHRoZSB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIG9sZHRvb2x0aXBDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgX3BsYWNlVG9vbHRpcC5jYWxsKHNlbGYsIHRhcmdldEVsZW1lbnQuZWxlbWVudCwgb2xkdG9vbHRpcENvbnRhaW5lciwgb2xkQXJyb3dMYXllciwgb2xkSGVscGVyTnVtYmVyTGF5ZXIpO1xuXG4gICAgICAgIC8vY2hhbmdlIGFjdGl2ZSBidWxsZXRcbiAgICAgICAgb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtYnVsbGV0cyBsaSA+IGEuYWN0aXZlJykuY2xhc3NOYW1lID0gJyc7XG4gICAgICAgIG9sZFJlZmVyZW5jZUxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLWJ1bGxldHMgbGkgPiBhW2RhdGEtc3RlcG51bWJlcj1cIicgKyB0YXJnZXRFbGVtZW50LnN0ZXAgKyAnXCJdJykuY2xhc3NOYW1lID0gJ2FjdGl2ZSc7XG5cbiAgICAgICAgb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtcHJvZ3Jlc3MgLmludHJvanMtcHJvZ3Jlc3NiYXInKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOicgKyBfZ2V0UHJvZ3Jlc3MuY2FsbChzZWxmKSArICclOycpO1xuXG4gICAgICAgIC8vc2hvdyB0aGUgdG9vbHRpcFxuICAgICAgICBvbGR0b29sdGlwQ29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBpZiAob2xkSGVscGVyTnVtYmVyTGF5ZXIpIG9sZEhlbHBlck51bWJlckxheWVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgICAgIC8vcmVzZXQgYnV0dG9uIGZvY3VzXG4gICAgICAgIGlmIChuZXh0VG9vbHRpcEJ1dHRvbi50YWJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAvL3RhYmluZGV4IG9mIC0xIG1lYW5zIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSB0b3VyIC0gZm9jdXMgb24gc2tpcCAvIGRvbmVcbiAgICAgICAgICBza2lwVG9vbHRpcEJ1dHRvbi5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vc3RpbGwgaW4gdGhlIHRvdXIsIGZvY3VzIG9uIG5leHRcbiAgICAgICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LCAzNTApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZWxwZXJMYXllciAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIHJlZmVyZW5jZUxheWVyICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgYXJyb3dMYXllciAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICB0b29sdGlwTGF5ZXIgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIHRvb2x0aXBUZXh0TGF5ZXIgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgYnVsbGV0c0xheWVyICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICBwcm9ncmVzc0xheWVyICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIGJ1dHRvbnNMYXllciAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGhlbHBlckxheWVyLmNsYXNzTmFtZSA9IGhpZ2hsaWdodENsYXNzO1xuICAgICAgcmVmZXJlbmNlTGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJztcblxuICAgICAgLy9zZXQgbmV3IHBvc2l0aW9uIHRvIGhlbHBlciBsYXllclxuICAgICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbChzZWxmLCBoZWxwZXJMYXllcik7XG4gICAgICBfc2V0SGVscGVyTGF5ZXJQb3NpdGlvbi5jYWxsKHNlbGYsIHJlZmVyZW5jZUxheWVyKTtcblxuICAgICAgLy9hZGQgaGVscGVyIGxheWVyIHRvIHRhcmdldCBlbGVtZW50XG4gICAgICB0aGlzLl90YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKGhlbHBlckxheWVyKTtcbiAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQocmVmZXJlbmNlTGF5ZXIpO1xuXG4gICAgICBhcnJvd0xheWVyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWFycm93JztcblxuICAgICAgdG9vbHRpcFRleHRMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy10b29sdGlwdGV4dCc7XG4gICAgICB0b29sdGlwVGV4dExheWVyLmlubmVySFRNTCA9IHRhcmdldEVsZW1lbnQuaW50cm87XG5cbiAgICAgIGJ1bGxldHNMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1idWxsZXRzJztcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd0J1bGxldHMgPT09IGZhbHNlKSB7XG4gICAgICAgIGJ1bGxldHNMYXllci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICB2YXIgdWxDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgc3RlcHNMZW5ndGggPSB0aGlzLl9pbnRyb0l0ZW1zLmxlbmd0aDsgaSA8IHN0ZXBzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlubmVyTGkgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICB2YXIgYW5jaG9yTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICBhbmNob3JMaW5rLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmdvVG9TdGVwKHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXN0ZXBudW1iZXInKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGkgPT09ICh0YXJnZXRFbGVtZW50LnN0ZXAtMSkpIGFuY2hvckxpbmsuY2xhc3NOYW1lID0gJ2FjdGl2ZSc7XG5cbiAgICAgICAgYW5jaG9yTGluay5ocmVmID0gJ2phdmFzY3JpcHQ6dm9pZCgwKTsnO1xuICAgICAgICBhbmNob3JMaW5rLmlubmVySFRNTCA9IFwiJm5ic3A7XCI7XG4gICAgICAgIGFuY2hvckxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLXN0ZXBudW1iZXInLCB0aGlzLl9pbnRyb0l0ZW1zW2ldLnN0ZXApO1xuXG4gICAgICAgIGlubmVyTGkuYXBwZW5kQ2hpbGQoYW5jaG9yTGluayk7XG4gICAgICAgIHVsQ29udGFpbmVyLmFwcGVuZENoaWxkKGlubmVyTGkpO1xuICAgICAgfVxuXG4gICAgICBidWxsZXRzTGF5ZXIuYXBwZW5kQ2hpbGQodWxDb250YWluZXIpO1xuXG4gICAgICBwcm9ncmVzc0xheWVyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLXByb2dyZXNzJztcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd1Byb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICBwcm9ncmVzc0xheWVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3Jlc3NCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHByb2dyZXNzQmFyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLXByb2dyZXNzYmFyJztcbiAgICAgIHByb2dyZXNzQmFyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6JyArIF9nZXRQcm9ncmVzcy5jYWxsKHRoaXMpICsgJyU7Jyk7XG5cbiAgICAgIHByb2dyZXNzTGF5ZXIuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NCYXIpO1xuXG4gICAgICBidXR0b25zTGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtdG9vbHRpcGJ1dHRvbnMnO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd0J1dHRvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGJ1dHRvbnNMYXllci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwTGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtdG9vbHRpcCc7XG4gICAgICB0b29sdGlwTGF5ZXIuYXBwZW5kQ2hpbGQodG9vbHRpcFRleHRMYXllcik7XG4gICAgICB0b29sdGlwTGF5ZXIuYXBwZW5kQ2hpbGQoYnVsbGV0c0xheWVyKTtcbiAgICAgIHRvb2x0aXBMYXllci5hcHBlbmRDaGlsZChwcm9ncmVzc0xheWVyKTtcblxuICAgICAgLy9hZGQgaGVscGVyIGxheWVyIG51bWJlclxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd1N0ZXBOdW1iZXJzID09IHRydWUpIHtcbiAgICAgICAgdmFyIGhlbHBlck51bWJlckxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBoZWxwZXJOdW1iZXJMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1oZWxwZXJOdW1iZXJMYXllcic7XG4gICAgICAgIGhlbHBlck51bWJlckxheWVyLmlubmVySFRNTCA9IHRhcmdldEVsZW1lbnQuc3RlcDtcbiAgICAgICAgcmVmZXJlbmNlTGF5ZXIuYXBwZW5kQ2hpbGQoaGVscGVyTnVtYmVyTGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwTGF5ZXIuYXBwZW5kQ2hpbGQoYXJyb3dMYXllcik7XG4gICAgICByZWZlcmVuY2VMYXllci5hcHBlbmRDaGlsZCh0b29sdGlwTGF5ZXIpO1xuXG4gICAgICAvL25leHQgYnV0dG9uXG4gICAgICB2YXIgbmV4dFRvb2x0aXBCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICAgIG5leHRUb29sdGlwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2ludHJvSXRlbXMubGVuZ3RoIC0gMSAhPSBzZWxmLl9jdXJyZW50U3RlcCkge1xuICAgICAgICAgIF9uZXh0U3RlcC5jYWxsKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5ocmVmID0gJ2phdmFzY3JpcHQ6dm9pZCgwKTsnO1xuICAgICAgbmV4dFRvb2x0aXBCdXR0b24uaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5uZXh0TGFiZWw7XG5cbiAgICAgIC8vcHJldmlvdXMgYnV0dG9uXG4gICAgICB2YXIgcHJldlRvb2x0aXBCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICAgIHByZXZUb29sdGlwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2N1cnJlbnRTdGVwICE9IDApIHtcbiAgICAgICAgICBfcHJldmlvdXNTdGVwLmNhbGwoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHByZXZUb29sdGlwQnV0dG9uLmhyZWYgPSAnamF2YXNjcmlwdDp2b2lkKDApOyc7XG4gICAgICBwcmV2VG9vbHRpcEJ1dHRvbi5pbm5lckhUTUwgPSB0aGlzLl9vcHRpb25zLnByZXZMYWJlbDtcblxuICAgICAgLy9za2lwIGJ1dHRvblxuICAgICAgdmFyIHNraXBUb29sdGlwQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgc2tpcFRvb2x0aXBCdXR0b24uY2xhc3NOYW1lID0gJ2ludHJvanMtYnV0dG9uIGludHJvanMtc2tpcGJ1dHRvbic7XG4gICAgICBza2lwVG9vbHRpcEJ1dHRvbi5ocmVmID0gJ2phdmFzY3JpcHQ6dm9pZCgwKTsnO1xuICAgICAgc2tpcFRvb2x0aXBCdXR0b24uaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5za2lwTGFiZWw7XG5cbiAgICAgIHNraXBUb29sdGlwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2ludHJvSXRlbXMubGVuZ3RoIC0gMSA9PSBzZWxmLl9jdXJyZW50U3RlcCAmJiB0eXBlb2YgKHNlbGYuX2ludHJvQ29tcGxldGVDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzZWxmLl9pbnRyb0NvbXBsZXRlQ2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9pbnRyb0l0ZW1zLmxlbmd0aCAtIDEgIT0gc2VsZi5fY3VycmVudFN0ZXAgJiYgdHlwZW9mIChzZWxmLl9pbnRyb0V4aXRDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzZWxmLl9pbnRyb0V4aXRDYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2V4aXRJbnRyby5jYWxsKHNlbGYsIHNlbGYuX3RhcmdldEVsZW1lbnQpO1xuICAgICAgfTtcblxuICAgICAgYnV0dG9uc0xheWVyLmFwcGVuZENoaWxkKHNraXBUb29sdGlwQnV0dG9uKTtcblxuICAgICAgLy9pbiBvcmRlciB0byBwcmV2ZW50IGRpc3BsYXlpbmcgbmV4dC9wcmV2aW91cyBidXR0b24gYWx3YXlzXG4gICAgICBpZiAodGhpcy5faW50cm9JdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGJ1dHRvbnNMYXllci5hcHBlbmRDaGlsZChwcmV2VG9vbHRpcEJ1dHRvbik7XG4gICAgICAgIGJ1dHRvbnNMYXllci5hcHBlbmRDaGlsZChuZXh0VG9vbHRpcEJ1dHRvbik7XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXBMYXllci5hcHBlbmRDaGlsZChidXR0b25zTGF5ZXIpO1xuXG4gICAgICAvL3NldCBwcm9wZXIgcG9zaXRpb25cbiAgICAgIF9wbGFjZVRvb2x0aXAuY2FsbChzZWxmLCB0YXJnZXRFbGVtZW50LmVsZW1lbnQsIHRvb2x0aXBMYXllciwgYXJyb3dMYXllciwgaGVscGVyTnVtYmVyTGF5ZXIpO1xuICAgIH1cblxuICAgIC8vZGlzYWJsZSBpbnRlcmFjdGlvblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVJbnRlcmFjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgX2Rpc2FibGVJbnRlcmFjdGlvbi5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIHByZXZUb29sdGlwQnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBuZXh0VG9vbHRpcEJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFN0ZXAgPT0gMCAmJiB0aGlzLl9pbnRyb0l0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHByZXZUb29sdGlwQnV0dG9uLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWJ1dHRvbiBpbnRyb2pzLXByZXZidXR0b24gaW50cm9qcy1kaXNhYmxlZCc7XG4gICAgICBwcmV2VG9vbHRpcEJ1dHRvbi50YWJJbmRleCA9ICctMSc7XG4gICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5jbGFzc05hbWUgPSAnaW50cm9qcy1idXR0b24gaW50cm9qcy1uZXh0YnV0dG9uJztcbiAgICAgIHNraXBUb29sdGlwQnV0dG9uLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuc2tpcExhYmVsO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faW50cm9JdGVtcy5sZW5ndGggLSAxID09IHRoaXMuX2N1cnJlbnRTdGVwIHx8IHRoaXMuX2ludHJvSXRlbXMubGVuZ3RoID09IDEpIHtcbiAgICAgIHNraXBUb29sdGlwQnV0dG9uLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuZG9uZUxhYmVsO1xuICAgICAgcHJldlRvb2x0aXBCdXR0b24uY2xhc3NOYW1lID0gJ2ludHJvanMtYnV0dG9uIGludHJvanMtcHJldmJ1dHRvbic7XG4gICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5jbGFzc05hbWUgPSAnaW50cm9qcy1idXR0b24gaW50cm9qcy1uZXh0YnV0dG9uIGludHJvanMtZGlzYWJsZWQnO1xuICAgICAgbmV4dFRvb2x0aXBCdXR0b24udGFiSW5kZXggPSAnLTEnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2VG9vbHRpcEJ1dHRvbi5jbGFzc05hbWUgPSAnaW50cm9qcy1idXR0b24gaW50cm9qcy1wcmV2YnV0dG9uJztcbiAgICAgIG5leHRUb29sdGlwQnV0dG9uLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWJ1dHRvbiBpbnRyb2pzLW5leHRidXR0b24nO1xuICAgICAgc2tpcFRvb2x0aXBCdXR0b24uaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5za2lwTGFiZWw7XG4gICAgfVxuXG4gICAgLy9TZXQgZm9jdXMgb24gXCJuZXh0XCIgYnV0dG9uLCBzbyB0aGF0IGhpdHRpbmcgRW50ZXIgYWx3YXlzIG1vdmVzIHlvdSBvbnRvIHRoZSBuZXh0IHN0ZXBcbiAgICBuZXh0VG9vbHRpcEJ1dHRvbi5mb2N1cygpO1xuXG4gICAgLy9hZGQgdGFyZ2V0IGVsZW1lbnQgcG9zaXRpb24gc3R5bGVcbiAgICB0YXJnZXRFbGVtZW50LmVsZW1lbnQuY2xhc3NOYW1lICs9ICcgaW50cm9qcy1zaG93RWxlbWVudCc7XG5cbiAgICB2YXIgY3VycmVudEVsZW1lbnRQb3NpdGlvbiA9IF9nZXRQcm9wVmFsdWUodGFyZ2V0RWxlbWVudC5lbGVtZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAoY3VycmVudEVsZW1lbnRQb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJlxuICAgICAgICBjdXJyZW50RWxlbWVudFBvc2l0aW9uICE9PSAncmVsYXRpdmUnKSB7XG4gICAgICAvL2NoYW5nZSB0byBuZXcgaW50cm8gaXRlbVxuICAgICAgdGFyZ2V0RWxlbWVudC5lbGVtZW50LmNsYXNzTmFtZSArPSAnIGludHJvanMtcmVsYXRpdmVQb3NpdGlvbic7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEVsbSA9IHRhcmdldEVsZW1lbnQuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChwYXJlbnRFbG0gIT0gbnVsbCkge1xuICAgICAgaWYgKHBhcmVudEVsbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdib2R5JykgYnJlYWs7XG5cbiAgICAgIC8vZml4IFRoZSBTdGFja2luZyBDb250ZW54dCBwcm9ibGVtLlxuICAgICAgLy9Nb3JlIGRldGFpbDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICAgICAgdmFyIHpJbmRleCA9IF9nZXRQcm9wVmFsdWUocGFyZW50RWxtLCAnei1pbmRleCcpO1xuICAgICAgdmFyIG9wYWNpdHkgPSBwYXJzZUZsb2F0KF9nZXRQcm9wVmFsdWUocGFyZW50RWxtLCAnb3BhY2l0eScpKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBfZ2V0UHJvcFZhbHVlKHBhcmVudEVsbSwgJ3RyYW5zZm9ybScpIHx8IF9nZXRQcm9wVmFsdWUocGFyZW50RWxtLCAnLXdlYmtpdC10cmFuc2Zvcm0nKSB8fCBfZ2V0UHJvcFZhbHVlKHBhcmVudEVsbSwgJy1tb3otdHJhbnNmb3JtJykgfHwgX2dldFByb3BWYWx1ZShwYXJlbnRFbG0sICctbXMtdHJhbnNmb3JtJykgfHwgX2dldFByb3BWYWx1ZShwYXJlbnRFbG0sICctby10cmFuc2Zvcm0nKTtcbiAgICAgIGlmICgvWzAtOV0rLy50ZXN0KHpJbmRleCkgfHwgb3BhY2l0eSA8IDEgfHwgKHRyYW5zZm9ybSAhPT0gJ25vbmUnICYmIHRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBwYXJlbnRFbG0uY2xhc3NOYW1lICs9ICcgaW50cm9qcy1maXhQYXJlbnQnO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRFbG0gPSBwYXJlbnRFbG0ucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoIV9lbGVtZW50SW5WaWV3cG9ydCh0YXJnZXRFbGVtZW50LmVsZW1lbnQpICYmIHRoaXMuX29wdGlvbnMuc2Nyb2xsVG9FbGVtZW50ID09PSB0cnVlKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldEVsZW1lbnQuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgd2luSGVpZ2h0ID0gX2dldFdpblNpemUoKS5oZWlnaHQsXG4gICAgICAgIHRvcCA9IHJlY3QuYm90dG9tIC0gKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSAtIHdpbkhlaWdodDtcblxuICAgICAgLy9TY3JvbGwgdXBcbiAgICAgIGlmICh0b3AgPCAwIHx8IHRhcmdldEVsZW1lbnQuZWxlbWVudC5jbGllbnRIZWlnaHQgPiB3aW5IZWlnaHQpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIHRvcCAtIDMwKTsgLy8gMzBweCBwYWRkaW5nIGZyb20gZWRnZSB0byBsb29rIG5pY2VcblxuICAgICAgLy9TY3JvbGwgZG93blxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIGJvdHRvbSArIDEwMCk7IC8vIDcwcHggKyAzMHB4IHBhZGRpbmcgZnJvbSBlZGdlIHRvIGxvb2sgbmljZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgKHRoaXMuX2ludHJvQWZ0ZXJDaGFuZ2VDYWxsYmFjaykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9pbnRyb0FmdGVyQ2hhbmdlQ2FsbGJhY2suY2FsbCh0aGlzLCB0YXJnZXRFbGVtZW50LmVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gZWxlbWVudCBDU1MgcHJvcGVydHkgb24gdGhlIHBhZ2VcbiAgICogVGhhbmtzIHRvIEphdmFTY3JpcHQgS2l0OiBodHRwOi8vd3d3LmphdmFzY3JpcHRraXQuY29tL2RodG1sdHV0b3JzL2RodG1sY2FzY2FkZTQuc2h0bWxcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX2dldFByb3BWYWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgICogQHJldHVybnMgRWxlbWVudCdzIHByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJvcFZhbHVlIChlbGVtZW50LCBwcm9wTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSAnJztcbiAgICBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUpIHsgLy9JRVxuICAgICAgcHJvcFZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbcHJvcE5hbWVdO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkgeyAvL090aGVyc1xuICAgICAgcHJvcFZhbHVlID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgICB9XG5cbiAgICAvL1ByZXZlbnQgZXhjZXB0aW9uIGluIElFXG4gICAgaWYgKHByb3BWYWx1ZSAmJiBwcm9wVmFsdWUudG9Mb3dlckNhc2UpIHtcbiAgICAgIHJldHVybiBwcm9wVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjcm9zcy1icm93c2VyIHdheSB0byBnZXQgdGhlIHNjcmVlbiBkaW1lbnNpb25zXG4gICAqIHZpYTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODY0NDY3L2ludGVybmV0LWV4cGxvcmVyLWlubmVyaGVpZ2h0XG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nZXRXaW5TaXplXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlc1xuICAgKi9cbiAgZnVuY3Rpb24gX2dldFdpblNpemUoKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgRCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHJldHVybiB7IHdpZHRoOiBELmNsaWVudFdpZHRoLCBoZWlnaHQ6IEQuY2xpZW50SGVpZ2h0IH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvdmVybGF5IGxheWVyIHRvIHRoZSBwYWdlXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIzOTk5L2hvdy10by10ZWxsLWlmLWEtZG9tLWVsZW1lbnQtaXMtdmlzaWJsZS1pbi10aGUtY3VycmVudC12aWV3cG9ydFxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfZWxlbWVudEluVmlld3BvcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsXG4gICAqL1xuICBmdW5jdGlvbiBfZWxlbWVudEluVmlld3BvcnQoZWwpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3QudG9wID49IDAgJiZcbiAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAocmVjdC5ib3R0b20rODApIDw9IHdpbmRvdy5pbm5lckhlaWdodCAmJiAvLyBhZGQgODAgdG8gZ2V0IHRoZSB0ZXh0IHJpZ2h0XG4gICAgICByZWN0LnJpZ2h0IDw9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb3ZlcmxheSBsYXllciB0byB0aGUgcGFnZVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfYWRkT3ZlcmxheUxheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRFbG1cbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRPdmVybGF5TGF5ZXIodGFyZ2V0RWxtKSB7XG4gICAgdmFyIG92ZXJsYXlMYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBzdHlsZVRleHQgPSAnJyxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvL3NldCBjc3MgY2xhc3MgbmFtZVxuICAgIG92ZXJsYXlMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1vdmVybGF5JztcblxuICAgIC8vY2hlY2sgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGJvZHksIHdlIHNob3VsZCBjYWxjdWxhdGUgdGhlIHNpemUgb2Ygb3ZlcmxheSBsYXllciBpbiBhIGJldHRlciB3YXlcbiAgICBpZiAodGFyZ2V0RWxtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2JvZHknKSB7XG4gICAgICBzdHlsZVRleHQgKz0gJ3RvcDogMDtib3R0b206IDA7IGxlZnQ6IDA7cmlnaHQ6IDA7cG9zaXRpb246IGZpeGVkOyc7XG4gICAgICBvdmVybGF5TGF5ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc2V0IG92ZXJsYXkgbGF5ZXIgcG9zaXRpb25cbiAgICAgIHZhciBlbGVtZW50UG9zaXRpb24gPSBfZ2V0T2Zmc2V0KHRhcmdldEVsbSk7XG4gICAgICBpZiAoZWxlbWVudFBvc2l0aW9uKSB7XG4gICAgICAgIHN0eWxlVGV4dCArPSAnd2lkdGg6ICcgKyBlbGVtZW50UG9zaXRpb24ud2lkdGggKyAncHg7IGhlaWdodDonICsgZWxlbWVudFBvc2l0aW9uLmhlaWdodCArICdweDsgdG9wOicgKyBlbGVtZW50UG9zaXRpb24udG9wICsgJ3B4O2xlZnQ6ICcgKyBlbGVtZW50UG9zaXRpb24ubGVmdCArICdweDsnO1xuICAgICAgICBvdmVybGF5TGF5ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlVGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFyZ2V0RWxtLmFwcGVuZENoaWxkKG92ZXJsYXlMYXllcik7XG5cbiAgICBvdmVybGF5TGF5ZXIub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuX29wdGlvbnMuZXhpdE9uT3ZlcmxheUNsaWNrID09IHRydWUpIHtcblxuICAgICAgICAvL2NoZWNrIGlmIGFueSBjYWxsYmFjayBpcyBkZWZpbmVkXG4gICAgICAgIGlmIChzZWxmLl9pbnRyb0V4aXRDYWxsYmFjayAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmLl9pbnRyb0V4aXRDYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIF9leGl0SW50cm8uY2FsbChzZWxmLCB0YXJnZXRFbG0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc3R5bGVUZXh0ICs9ICdvcGFjaXR5OiAnICsgc2VsZi5fb3B0aW9ucy5vdmVybGF5T3BhY2l0eS50b1N0cmluZygpICsgJzsnO1xuICAgICAgb3ZlcmxheUxheWVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZVRleHQpO1xuICAgIH0sIDEwKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBlbGVtZW50IHBvc2l0aW9uIG9uIHRoZSBwYWdlXG4gICAqIFRoYW5rcyB0byBgbWVvdXdgOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDI0NzQvMzc1OTY2XG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nZXRPZmZzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICogQHJldHVybnMgRWxlbWVudCdzIHBvc2l0aW9uIGluZm9cbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBlbGVtZW50UG9zaXRpb24gPSB7fTtcblxuICAgIC8vc2V0IHdpZHRoXG4gICAgZWxlbWVudFBvc2l0aW9uLndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgIC8vc2V0IGhlaWdodFxuICAgIGVsZW1lbnRQb3NpdGlvbi5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgIC8vY2FsY3VsYXRlIGVsZW1lbnQgdG9wIGFuZCBsZWZ0XG4gICAgdmFyIF94ID0gMDtcbiAgICB2YXIgX3kgPSAwO1xuICAgIHdoaWxlIChlbGVtZW50ICYmICFpc05hTihlbGVtZW50Lm9mZnNldExlZnQpICYmICFpc05hTihlbGVtZW50Lm9mZnNldFRvcCkpIHtcbiAgICAgIF94ICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgIF95ICs9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICAvL3NldCB0b3BcbiAgICBlbGVtZW50UG9zaXRpb24udG9wID0gX3k7XG4gICAgLy9zZXQgbGVmdFxuICAgIGVsZW1lbnRQb3NpdGlvbi5sZWZ0ID0gX3g7XG5cbiAgICByZXR1cm4gZWxlbWVudFBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfZ2V0UHJvZ3Jlc3NcbiAgICogQHJldHVybnMgY3VycmVudCBwcm9ncmVzcyBwZXJjZW50YWdlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgLy8gU3RlcHMgYXJlIDAgaW5kZXhlZFxuICAgIHZhciBjdXJyZW50U3RlcCA9IHBhcnNlSW50KCh0aGlzLl9jdXJyZW50U3RlcCArIDEpLCAxMCk7XG4gICAgcmV0dXJuICgoY3VycmVudFN0ZXAgLyB0aGlzLl9pbnRyb0l0ZW1zLmxlbmd0aCkgKiAxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJ3cml0ZXMgb2JqMSdzIHZhbHVlcyB3aXRoIG9iajIncyBhbmQgYWRkcyBvYmoyJ3MgaWYgbm9uIGV4aXN0ZW50IGluIG9iajFcbiAgICogdmlhOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3MTI1MS9ob3ctY2FuLWktbWVyZ2UtcHJvcGVydGllcy1vZi10d28tamF2YXNjcmlwdC1vYmplY3RzLWR5bmFtaWNhbGx5XG4gICAqXG4gICAqIEBwYXJhbSBvYmoxXG4gICAqIEBwYXJhbSBvYmoyXG4gICAqIEByZXR1cm5zIG9iajMgYSBuZXcgb2JqZWN0IGJhc2VkIG9uIG9iajEgYW5kIG9iajJcbiAgICovXG4gIGZ1bmN0aW9uIF9tZXJnZU9wdGlvbnMob2JqMSxvYmoyKSB7XG4gICAgdmFyIG9iajMgPSB7fTtcbiAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBvYmoxKSB7IG9iajNbYXR0cm5hbWVdID0gb2JqMVthdHRybmFtZV07IH1cbiAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBvYmoyKSB7IG9iajNbYXR0cm5hbWVdID0gb2JqMlthdHRybmFtZV07IH1cbiAgICByZXR1cm4gb2JqMztcbiAgfVxuXG4gIHZhciBpbnRyb0pzID0gZnVuY3Rpb24gKHRhcmdldEVsbSkge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldEVsbSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAvL09rLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2VcbiAgICAgIHJldHVybiBuZXcgSW50cm9Kcyh0YXJnZXRFbG0pO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKHRhcmdldEVsbSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvL3NlbGVjdCB0aGUgdGFyZ2V0IGVsZW1lbnQgd2l0aCBxdWVyeSBzZWxlY3RvclxuICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldEVsbSk7XG5cbiAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50cm9Kcyh0YXJnZXRFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZWxlbWVudCB3aXRoIGdpdmVuIHNlbGVjdG9yLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludHJvSnMoZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IEludHJvSnMgdmVyc2lvblxuICAgKlxuICAgKiBAcHJvcGVydHkgdmVyc2lvblxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICovXG4gIGludHJvSnMudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgLy9Qcm90b3R5cGVcbiAgaW50cm9Kcy5mbiA9IEludHJvSnMucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEludHJvSnModGhpcyk7XG4gICAgfSxcbiAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gX21lcmdlT3B0aW9ucyh0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9pbnRyb0ZvckVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLl90YXJnZXRFbGVtZW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ29Ub1N0ZXA6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgIF9nb1RvU3RlcC5jYWxsKHRoaXMsIHN0ZXApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0U3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICBfbmV4dFN0ZXAuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHJldmlvdXNTdGVwOiBmdW5jdGlvbigpIHtcbiAgICAgIF9wcmV2aW91c1N0ZXAuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXhpdDogZnVuY3Rpb24oKSB7XG4gICAgICBfZXhpdEludHJvLmNhbGwodGhpcywgdGhpcy5fdGFyZ2V0RWxlbWVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbCh0aGlzLCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1oZWxwZXJMYXllcicpKTtcbiAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwodGhpcywgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmJlZm9yZWNoYW5nZTogZnVuY3Rpb24ocHJvdmlkZWRDYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiAocHJvdmlkZWRDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5faW50cm9CZWZvcmVDaGFuZ2VDYWxsYmFjayA9IHByb3ZpZGVkQ2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGNhbGxiYWNrIGZvciBvbmJlZm9yZWNoYW5nZSB3YXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jaGFuZ2U6IGZ1bmN0aW9uKHByb3ZpZGVkQ2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVkQ2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2ludHJvQ2hhbmdlQ2FsbGJhY2sgPSBwcm92aWRlZENhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBjYWxsYmFjayBmb3Igb25jaGFuZ2Ugd2FzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmFmdGVyY2hhbmdlOiBmdW5jdGlvbihwcm92aWRlZENhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIChwcm92aWRlZENhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9pbnRyb0FmdGVyQ2hhbmdlQ2FsbGJhY2sgPSBwcm92aWRlZENhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBjYWxsYmFjayBmb3Igb25hZnRlcmNoYW5nZSB3YXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jb21wbGV0ZTogZnVuY3Rpb24ocHJvdmlkZWRDYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiAocHJvdmlkZWRDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5faW50cm9Db21wbGV0ZUNhbGxiYWNrID0gcHJvdmlkZWRDYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgY2FsbGJhY2sgZm9yIG9uY29tcGxldGUgd2FzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmV4aXQ6IGZ1bmN0aW9uKHByb3ZpZGVkQ2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVkQ2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2ludHJvRXhpdENhbGxiYWNrID0gcHJvdmlkZWRDYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgY2FsbGJhY2sgZm9yIG9uZXhpdCB3YXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5pbnRyb0pzID0gaW50cm9KcztcbiAgcmV0dXJuIGludHJvSnM7XG59KSk7XG4iLCIvKlxuIExlYWZsZXQsIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBtb2JpbGUtZnJpZW5kbHkgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cDovL2xlYWZsZXRqcy5jb21cbiAoYykgMjAxMC0yMDEzLCBWbGFkaW1pciBBZ2Fmb25raW5cbiAoYykgMjAxMC0yMDExLCBDbG91ZE1hZGVcbiovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG52YXIgb2xkTCA9IHdpbmRvdy5MLFxyXG4gICAgTCA9IHt9O1xyXG5cclxuTC52ZXJzaW9uID0gJzAuNy43JztcclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGZvciBOb2RlIG1vZHVsZSBwYXR0ZXJuIGxvYWRlcnMsIGluY2x1ZGluZyBCcm93c2VyaWZ5XHJcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBMO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYW4gQU1EIG1vZHVsZVxyXG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdGRlZmluZShMKTtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYSBnbG9iYWwgTCB2YXJpYWJsZSwgc2F2aW5nIHRoZSBvcmlnaW5hbCBMIHRvIHJlc3RvcmUgbGF0ZXIgaWYgbmVlZGVkXHJcblxyXG5MLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0d2luZG93LkwgPSBvbGRMO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxud2luZG93LkwgPSBMO1xyXG5cblxuLypcclxuICogTC5VdGlsIGNvbnRhaW5zIHZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCB0aHJvdWdob3V0IExlYWZsZXQgY29kZS5cclxuICovXHJcblxyXG5MLlV0aWwgPSB7XHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoZGVzdCkgeyAvLyAoT2JqZWN0WywgT2JqZWN0LCAuLi5dKSAtPlxyXG5cdFx0dmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRcdGZvciAoaiA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdFx0c3JjID0gc291cmNlc1tqXSB8fCB7fTtcclxuXHRcdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGVzdDtcclxuXHR9LFxyXG5cclxuXHRiaW5kOiBmdW5jdGlvbiAoZm4sIG9iaikgeyAvLyAoRnVuY3Rpb24sIE9iamVjdCkgLT4gRnVuY3Rpb25cclxuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogbnVsbDtcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MgfHwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0c3RhbXA6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGFzdElkID0gMCxcclxuXHRcdCAgICBrZXkgPSAnX2xlYWZsZXRfaWQnO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqW2tleV0gPSBvYmpba2V5XSB8fCArK2xhc3RJZDtcclxuXHRcdFx0cmV0dXJuIG9ialtrZXldO1xyXG5cdFx0fTtcclxuXHR9KCkpLFxyXG5cclxuXHRpbnZva2VFYWNoOiBmdW5jdGlvbiAob2JqLCBtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdHZhciBpLCBhcmdzO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcclxuXHJcblx0XHRcdGZvciAoaSBpbiBvYmopIHtcclxuXHRcdFx0XHRtZXRob2QuYXBwbHkoY29udGV4dCwgW2ksIG9ialtpXV0uY29uY2F0KGFyZ3MpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0bGltaXRFeGVjQnlJbnRlcnZhbDogZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbG9jaywgZXhlY09uVW5sb2NrO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB3cmFwcGVyRm4oKSB7XHJcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0XHRleGVjT25VbmxvY2sgPSB0cnVlO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblxyXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRsb2NrID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmIChleGVjT25VbmxvY2spIHtcclxuXHRcdFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0XHRcdGV4ZWNPblVubG9jayA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGltZSk7XHJcblxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0ZmFsc2VGbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGZvcm1hdE51bTogZnVuY3Rpb24gKG51bSwgZGlnaXRzKSB7XHJcblx0XHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIGRpZ2l0cyB8fCA1KTtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcblx0fSxcclxuXHJcblx0dHJpbTogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcblx0fSxcclxuXHJcblx0c3BsaXRXb3JkczogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIEwuVXRpbC50cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuXHR9LFxyXG5cclxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCBvYmoub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyYW1TdHJpbmc6IGZ1bmN0aW9uIChvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHRcdHZhciBwYXJhbXMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG5cdH0sXHJcblx0dGVtcGxhdGU6IGZ1bmN0aW9uIChzdHIsIGRhdGEpIHtcclxuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFx7ICooW1xcd19dKykgKlxcfS9nLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuXHR9LFxyXG5cclxuXHRlbXB0eUltYWdlVXJsOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSdcclxufTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5cdGZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRcdHZhciBpLCBmbixcclxuXHRcdCAgICBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdvJywgJ21zJ107XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aCAmJiAhZm47IGkrKykge1xyXG5cdFx0XHRmbiA9IHdpbmRvd1twcmVmaXhlc1tpXSArIG5hbWVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmbjtcclxuXHR9XHJcblxyXG5cdHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG5cdGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHRcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdFx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdCAgICAgICAgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuXHJcblx0dmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0ICAgICAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdCAgICAgICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG5cclxuXHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgaW1tZWRpYXRlLCBlbGVtZW50KSB7XHJcblx0XHRmbiA9IEwuYmluZChmbiwgY29udGV4dCk7XHJcblxyXG5cdFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0XHRmbigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgZm4sIGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG59KCkpO1xyXG5cclxuLy8gc2hvcnRjdXRzIGZvciBtb3N0IHVzZWQgdXRpbGl0eSBmdW5jdGlvbnNcclxuTC5leHRlbmQgPSBMLlV0aWwuZXh0ZW5kO1xyXG5MLmJpbmQgPSBMLlV0aWwuYmluZDtcclxuTC5zdGFtcCA9IEwuVXRpbC5zdGFtcDtcclxuTC5zZXRPcHRpb25zID0gTC5VdGlsLnNldE9wdGlvbnM7XHJcblxuXG4vKlxyXG4gKiBMLkNsYXNzIHBvd2VycyB0aGUgT09QIGZhY2lsaXRpZXMgb2YgdGhlIGxpYnJhcnkuXHJcbiAqIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG4gKi9cclxuXHJcbkwuQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbkwuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIGV4dGVuZGVkIGNsYXNzIHdpdGggdGhlIG5ldyBwcm90b3R5cGVcclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3MpIHtcclxuXHRcdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gaW5zdGFudGlhdGUgY2xhc3Mgd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yXHJcblx0dmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHRGLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBuZXcgRigpO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvL2luaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdEwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0TC5VdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm9wcy5vcHRpb25zICYmIHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgcHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRMLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdHZhciBwYXJlbnQgPSB0aGlzO1xyXG5cdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0TmV3Q2xhc3MuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudC5wcm90b3R5cGUuY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnQucHJvdG90eXBlLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gbWV0aG9kIGZvciBhZGRpbmcgcHJvcGVydGllcyB0byBwcm90b3R5cGVcclxuTC5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxufTtcclxuXHJcbi8vIG1lcmdlIG5ldyBkZWZhdWx0IG9wdGlvbnMgdG8gdGhlIENsYXNzXHJcbkwuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8vIGFkZCBhIGNvbnN0cnVjdG9yIGhvb2tcclxuTC5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5NaXhpbi5FdmVudHMgaXMgdXNlZCB0byBhZGQgY3VzdG9tIGV2ZW50cyBmdW5jdGlvbmFsaXR5IHRvIExlYWZsZXQgY2xhc3Nlcy5cclxuICovXHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG5MLk1peGluID0ge307XHJcblxyXG5MLk1peGluLkV2ZW50cyA9IHtcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkgeyAvLyAoU3RyaW5nLCBGdW5jdGlvblssIE9iamVjdF0pIG9yIChPYmplY3RbLCBPYmplY3RdKVxyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKEwuVXRpbC5pbnZva2VFYWNoKHR5cGVzLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIsIHRoaXMsIGZuLCBjb250ZXh0KSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudHMgPSB0aGlzW2V2ZW50c0tleV0gPSB0aGlzW2V2ZW50c0tleV0gfHwge30sXHJcblx0XHQgICAgY29udGV4dElkID0gY29udGV4dCAmJiBjb250ZXh0ICE9PSB0aGlzICYmIEwuc3RhbXAoY29udGV4dCksXHJcblx0XHQgICAgaSwgbGVuLCBldmVudCwgdHlwZSwgaW5kZXhLZXksIGluZGV4TGVuS2V5LCB0eXBlSW5kZXg7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZXZlbnQgPSB7XHJcblx0XHRcdFx0YWN0aW9uOiBmbixcclxuXHRcdFx0XHRjb250ZXh0OiBjb250ZXh0IHx8IHRoaXNcclxuXHRcdFx0fTtcclxuXHRcdFx0dHlwZSA9IHR5cGVzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGNvbnRleHRJZCkge1xyXG5cdFx0XHRcdC8vIHN0b3JlIGxpc3RlbmVycyBvZiBhIHBhcnRpY3VsYXIgY29udGV4dCBpbiBhIHNlcGFyYXRlIGhhc2ggKGlmIGl0IGhhcyBhbiBpZClcclxuXHRcdFx0XHQvLyBnaXZlcyBhIG1ham9yIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcmVtb3ZpbmcgdGhvdXNhbmRzIG9mIG1hcCBsYXllcnNcclxuXHJcblx0XHRcdFx0aW5kZXhLZXkgPSB0eXBlICsgJ19pZHgnO1xyXG5cdFx0XHRcdGluZGV4TGVuS2V5ID0gaW5kZXhLZXkgKyAnX2xlbic7XHJcblxyXG5cdFx0XHRcdHR5cGVJbmRleCA9IGV2ZW50c1tpbmRleEtleV0gPSBldmVudHNbaW5kZXhLZXldIHx8IHt9O1xyXG5cclxuXHRcdFx0XHRpZiAoIXR5cGVJbmRleFtjb250ZXh0SWRdKSB7XHJcblx0XHRcdFx0XHR0eXBlSW5kZXhbY29udGV4dElkXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBrZXlzIGluIHRoZSBpbmRleCB0byBxdWlja2x5IGNoZWNrIGlmIGl0J3MgZW1wdHlcclxuXHRcdFx0XHRcdGV2ZW50c1tpbmRleExlbktleV0gPSAoZXZlbnRzW2luZGV4TGVuS2V5XSB8fCAwKSArIDE7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0eXBlSW5kZXhbY29udGV4dElkXS5wdXNoKGV2ZW50KTtcclxuXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGV2ZW50c1t0eXBlXSA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcclxuXHRcdFx0XHRldmVudHNbdHlwZV0ucHVzaChldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRoYXNFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKHR5cGUpIHsgLy8gKFN0cmluZykgLT4gQm9vbGVhblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XTtcclxuXHRcdHJldHVybiAhIWV2ZW50cyAmJiAoKHR5cGUgaW4gZXZlbnRzICYmIGV2ZW50c1t0eXBlXS5sZW5ndGggPiAwKSB8fFxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICAodHlwZSArICdfaWR4JyBpbiBldmVudHMgJiYgZXZlbnRzW3R5cGUgKyAnX2lkeF9sZW4nXSA+IDApKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7IC8vIChbU3RyaW5nLCBGdW5jdGlvbiwgT2JqZWN0XSkgb3IgKE9iamVjdFssIE9iamVjdF0pXHJcblxyXG5cdFx0aWYgKCF0aGlzW2V2ZW50c0tleV0pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0eXBlcykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuVXRpbC5pbnZva2VFYWNoKHR5cGVzLCB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIsIHRoaXMsIGZuLCBjb250ZXh0KSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudHMgPSB0aGlzW2V2ZW50c0tleV0sXHJcblx0XHQgICAgY29udGV4dElkID0gY29udGV4dCAmJiBjb250ZXh0ICE9PSB0aGlzICYmIEwuc3RhbXAoY29udGV4dCksXHJcblx0XHQgICAgaSwgbGVuLCB0eXBlLCBsaXN0ZW5lcnMsIGosIGluZGV4S2V5LCBpbmRleExlbktleSwgdHlwZUluZGV4LCByZW1vdmVkO1xyXG5cclxuXHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHR5cGUgPSB0eXBlc1tpXTtcclxuXHRcdFx0aW5kZXhLZXkgPSB0eXBlICsgJ19pZHgnO1xyXG5cdFx0XHRpbmRleExlbktleSA9IGluZGV4S2V5ICsgJ19sZW4nO1xyXG5cclxuXHRcdFx0dHlwZUluZGV4ID0gZXZlbnRzW2luZGV4S2V5XTtcclxuXHJcblx0XHRcdGlmICghZm4pIHtcclxuXHRcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzW2luZGV4S2V5XTtcclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzW2luZGV4TGVuS2V5XTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzID0gY29udGV4dElkICYmIHR5cGVJbmRleCA/IHR5cGVJbmRleFtjb250ZXh0SWRdIDogZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0XHRmb3IgKGogPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0XHRcdFx0aWYgKChsaXN0ZW5lcnNbal0uYWN0aW9uID09PSBmbikgJiYgKCFjb250ZXh0IHx8IChsaXN0ZW5lcnNbal0uY29udGV4dCA9PT0gY29udGV4dCkpKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVtb3ZlZCA9IGxpc3RlbmVycy5zcGxpY2UoaiwgMSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gc2V0IHRoZSBvbGQgYWN0aW9uIHRvIGEgbm8tb3AsIGJlY2F1c2UgaXQgaXMgcG9zc2libGVcclxuXHRcdFx0XHRcdFx0XHQvLyB0aGF0IHRoZSBsaXN0ZW5lciBpcyBiZWluZyBpdGVyYXRlZCBvdmVyIGFzIHBhcnQgb2YgYSBkaXNwYXRjaFxyXG5cdFx0XHRcdFx0XHRcdHJlbW92ZWRbMF0uYWN0aW9uID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoY29udGV4dCAmJiB0eXBlSW5kZXggJiYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApKSB7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSB0eXBlSW5kZXhbY29udGV4dElkXTtcclxuXHRcdFx0XHRcdFx0ZXZlbnRzW2luZGV4TGVuS2V5XS0tO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGRlbGV0ZSB0aGlzW2V2ZW50c0tleV07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRmaXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7IC8vIChTdHJpbmdbLCBPYmplY3RdKVxyXG5cdFx0aWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXJzKHR5cGUpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBldmVudCA9IEwuVXRpbC5leHRlbmQoe30sIGRhdGEsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzIH0pO1xyXG5cclxuXHRcdHZhciBldmVudHMgPSB0aGlzW2V2ZW50c0tleV0sXHJcblx0XHQgICAgbGlzdGVuZXJzLCBpLCBsZW4sIHR5cGVJbmRleCwgY29udGV4dElkO1xyXG5cclxuXHRcdGlmIChldmVudHNbdHlwZV0pIHtcclxuXHRcdFx0Ly8gbWFrZSBzdXJlIGFkZGluZy9yZW1vdmluZyBsaXN0ZW5lcnMgaW5zaWRlIG90aGVyIGxpc3RlbmVycyB3b24ndCBjYXVzZSBpbmZpbml0ZSBsb29wXHJcblx0XHRcdGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXS5zbGljZSgpO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmFjdGlvbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaXJlIGV2ZW50IGZvciB0aGUgY29udGV4dC1pbmRleGVkIGxpc3RlbmVycyBhcyB3ZWxsXHJcblx0XHR0eXBlSW5kZXggPSBldmVudHNbdHlwZSArICdfaWR4J107XHJcblxyXG5cdFx0Zm9yIChjb250ZXh0SWQgaW4gdHlwZUluZGV4KSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHR5cGVJbmRleFtjb250ZXh0SWRdLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uYWN0aW9uLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmIChMLlV0aWwuaW52b2tlRWFjaCh0eXBlcywgdGhpcy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciwgdGhpcywgZm4sIGNvbnRleHQpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBMLmJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5hZGRFdmVudExpc3RlbmVyKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAuYWRkRXZlbnRMaXN0ZW5lcih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5NaXhpbi5FdmVudHMub24gPSBMLk1peGluLkV2ZW50cy5hZGRFdmVudExpc3RlbmVyO1xyXG5MLk1peGluLkV2ZW50cy5vZmYgPSBMLk1peGluLkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5MLk1peGluLkV2ZW50cy5vbmNlID0gTC5NaXhpbi5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXI7XHJcbkwuTWl4aW4uRXZlbnRzLmZpcmUgPSBMLk1peGluLkV2ZW50cy5maXJlRXZlbnQ7XHJcblxuXG4vKlxyXG4gKiBMLkJyb3dzZXIgaGFuZGxlcyBkaWZmZXJlbnQgYnJvd3NlciBhbmQgZmVhdHVyZSBkZXRlY3Rpb25zIGZvciBpbnRlcm5hbCBMZWFmbGV0IHVzZS5cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93LFxyXG5cdFx0aWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixcclxuXHJcblx0ICAgIC8vIHRlcnJpYmxlIGJyb3dzZXIgZGV0ZWN0aW9uIHRvIHdvcmsgYXJvdW5kIFNhZmFyaSAvIGlPUyAvIEFuZHJvaWQgYnJvd3NlciBidWdzXHJcblx0ICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxyXG5cdCAgICB3ZWJraXQgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEsXHJcblx0ICAgIGNocm9tZSA9IHVhLmluZGV4T2YoJ2Nocm9tZScpICE9PSAtMSxcclxuXHQgICAgcGhhbnRvbWpzID0gdWEuaW5kZXhPZigncGhhbnRvbScpICE9PSAtMSxcclxuXHQgICAgYW5kcm9pZCA9IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblx0ICAgIGFuZHJvaWQyMyA9IHVhLnNlYXJjaCgnYW5kcm9pZCBbMjNdJykgIT09IC0xLFxyXG5cdFx0Z2Vja28gPSB1YS5pbmRleE9mKCdnZWNrbycpICE9PSAtMSxcclxuXHJcblx0ICAgIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkICsgJycsXHJcblx0ICAgIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudCxcclxuXHRcdHBvaW50ZXIgPSAod2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB8fFxyXG5cdFx0XHRcdCAgbXNQb2ludGVyLFxyXG5cdCAgICByZXRpbmEgPSAoJ2RldmljZVBpeGVsUmF0aW8nIGluIHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpIHx8XHJcblx0ICAgICAgICAgICAgICgnbWF0Y2hNZWRpYScgaW4gd2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXJlc29sdXRpb246MTQ0ZHBpKScpICYmXHJcblx0ICAgICAgICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi1yZXNvbHV0aW9uOjE0NGRwaSknKS5tYXRjaGVzKSxcclxuXHJcblx0ICAgIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHQgICAgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlKSxcclxuXHQgICAgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMyxcclxuXHQgICAgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gZG9jLnN0eWxlLFxyXG5cdCAgICBvcGVyYTNkID0gJ09UcmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCB8fCBvcGVyYTNkKSAmJiAhcGhhbnRvbWpzO1xyXG5cclxuXHR2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgIXBoYW50b21qcyAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHRcdGllOiBpZSxcclxuXHRcdGllbHQ5OiBpZWx0OSxcclxuXHRcdHdlYmtpdDogd2Via2l0LFxyXG5cdFx0Z2Vja286IGdlY2tvICYmICF3ZWJraXQgJiYgIXdpbmRvdy5vcGVyYSAmJiAhaWUsXHJcblxyXG5cdFx0YW5kcm9pZDogYW5kcm9pZCxcclxuXHRcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cclxuXHRcdGllM2Q6IGllM2QsXHJcblx0XHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0XHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cdFx0b3BlcmEzZDogb3BlcmEzZCxcclxuXHRcdGFueTNkOiBhbnkzZCxcclxuXHJcblx0XHRtb2JpbGU6IG1vYmlsZSxcclxuXHRcdG1vYmlsZVdlYmtpdDogbW9iaWxlICYmIHdlYmtpdCxcclxuXHRcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGUgJiYgd2Via2l0M2QsXHJcblx0XHRtb2JpbGVPcGVyYTogbW9iaWxlICYmIHdpbmRvdy5vcGVyYSxcclxuXHJcblx0XHR0b3VjaDogdG91Y2gsXHJcblx0XHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuXHRcdHBvaW50ZXI6IHBvaW50ZXIsXHJcblxyXG5cdFx0cmV0aW5hOiByZXRpbmFcclxuXHR9O1xyXG5cclxufSgpKTtcclxuXG5cbi8qXHJcbiAqIEwuUG9pbnQgcmVwcmVzZW50cyBhIHBvaW50IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLlBvaW50ID0gZnVuY3Rpb24gKC8qTnVtYmVyKi8geCwgLypOdW1iZXIqLyB5LCAvKkJvb2xlYW4qLyByb3VuZCkge1xyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn07XHJcblxyXG5MLlBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbkwucG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQm91bmRzIHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5Cb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyhQb2ludCwgUG9pbnQpIG9yIFBvaW50W11cclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHsgLy8gKEJvb2xlYW4pIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKEJvdW5kcykgb3IgKFBvaW50KSAtPiBCb29sZWFuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gTC5wb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5ib3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuYm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHsgLy8gKEJvdW5kcykgb3IgKFBvaW50LCBQb2ludCkgb3IgKFBvaW50W10pXHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Cb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlRyYW5zZm9ybWF0aW9uIGlzIGFuIHV0aWxpdHkgY2xhc3MgdG8gcGVyZm9ybSBzaW1wbGUgcG9pbnQgdHJhbnNmb3JtYXRpb25zIHRocm91Z2ggYSAyZC1tYXRyaXguXHJcbiAqL1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn07XHJcblxyXG5MLlRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXG5cbi8qXHJcbiAqIEwuRG9tVXRpbCBjb250YWlucyB2YXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRE9NLlxyXG4gKi9cclxuXHJcbkwuRG9tVXRpbCA9IHtcclxuXHRnZXQ6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdO1xyXG5cclxuXHRcdGlmICghdmFsdWUgJiYgZWwuY3VycmVudFN0eWxlKSB7XHJcblx0XHRcdHZhbHVlID0gZWwuY3VycmVudFN0eWxlW3N0eWxlXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Z2V0Vmlld3BvcnRPZmZzZXQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcblxyXG5cdFx0dmFyIHRvcCA9IDAsXHJcblx0XHQgICAgbGVmdCA9IDAsXHJcblx0XHQgICAgZWwgPSBlbGVtZW50LFxyXG5cdFx0ICAgIGRvY0JvZHkgPSBkb2N1bWVudC5ib2R5LFxyXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG5cdFx0ICAgIHBvcztcclxuXHJcblx0XHRkbyB7XHJcblx0XHRcdHRvcCAgKz0gZWwub2Zmc2V0VG9wICB8fCAwO1xyXG5cdFx0XHRsZWZ0ICs9IGVsLm9mZnNldExlZnQgfHwgMDtcclxuXHJcblx0XHRcdC8vYWRkIGJvcmRlcnNcclxuXHRcdFx0dG9wICs9IHBhcnNlSW50KEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JvcmRlclRvcFdpZHRoJyksIDEwKSB8fCAwO1xyXG5cdFx0XHRsZWZ0ICs9IHBhcnNlSW50KEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JvcmRlckxlZnRXaWR0aCcpLCAxMCkgfHwgMDtcclxuXHJcblx0XHRcdHBvcyA9IEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0XHRpZiAoZWwub2Zmc2V0UGFyZW50ID09PSBkb2NCb2R5ICYmIHBvcyA9PT0gJ2Fic29sdXRlJykgeyBicmVhazsgfVxyXG5cclxuXHRcdFx0aWYgKHBvcyA9PT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRcdHRvcCAgKz0gZG9jQm9keS5zY3JvbGxUb3AgIHx8IGRvY0VsLnNjcm9sbFRvcCAgfHwgMDtcclxuXHRcdFx0XHRsZWZ0ICs9IGRvY0JvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0IHx8IDA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChwb3MgPT09ICdyZWxhdGl2ZScgJiYgIWVsLm9mZnNldExlZnQpIHtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICd3aWR0aCcpLFxyXG5cdFx0XHRcdCAgICBtYXhXaWR0aCA9IEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ21heC13aWR0aCcpLFxyXG5cdFx0XHRcdCAgICByID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0XHRcdGlmICh3aWR0aCAhPT0gJ25vbmUnIHx8IG1heFdpZHRoICE9PSAnbm9uZScpIHtcclxuXHRcdFx0XHRcdGxlZnQgKz0gci5sZWZ0ICsgZWwuY2xpZW50TGVmdDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vY2FsY3VsYXRlIGZ1bGwgeSBvZmZzZXQgc2luY2Ugd2UncmUgYnJlYWtpbmcgb3V0IG9mIHRoZSBsb29wXHJcblx0XHRcdFx0dG9wICs9IHIudG9wICsgKGRvY0JvZHkuc2Nyb2xsVG9wICB8fCBkb2NFbC5zY3JvbGxUb3AgIHx8IDApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XHJcblxyXG5cdFx0fSB3aGlsZSAoZWwpO1xyXG5cclxuXHRcdGVsID0gZWxlbWVudDtcclxuXHJcblx0XHRkbyB7XHJcblx0XHRcdGlmIChlbCA9PT0gZG9jQm9keSkgeyBicmVhazsgfVxyXG5cclxuXHRcdFx0dG9wICAtPSBlbC5zY3JvbGxUb3AgIHx8IDA7XHJcblx0XHRcdGxlZnQgLT0gZWwuc2Nyb2xsTGVmdCB8fCAwO1xyXG5cclxuXHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0fSB3aGlsZSAoZWwpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsZWZ0LCB0b3ApO1xyXG5cdH0sXHJcblxyXG5cdGRvY3VtZW50SXNMdHI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghTC5Eb21VdGlsLl9kb2NJc0x0ckNhY2hlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuX2RvY0lzTHRyQ2FjaGVkID0gdHJ1ZTtcclxuXHRcdFx0TC5Eb21VdGlsLl9kb2NJc0x0ciA9IEwuRG9tVXRpbC5nZXRTdHlsZShkb2N1bWVudC5ib2R5LCAnZGlyZWN0aW9uJykgPT09ICdsdHInO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIEwuRG9tVXRpbC5fZG9jSXNMdHI7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlOiBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHJcblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG5cclxuXHRcdGlmIChjb250YWluZXIpIHtcclxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0aGFzQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0XHR9XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLl9nZXRDbGFzcyhlbCk7XHJcblx0XHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG5cdH0sXHJcblxyXG5cdGFkZENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR2YXIgY2xhc3NlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoIUwuRG9tVXRpbC5oYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IEwuRG9tVXRpbC5fZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0XHRMLkRvbVV0aWwuX3NldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuX3NldENsYXNzKGVsLCBMLlV0aWwudHJpbSgoJyAnICsgTC5Eb21VdGlsLl9nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9zZXRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldENsYXNzOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcblx0fSxcclxuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cclxuXHRcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHJcblx0XHRcdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHRcdFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHRcdFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHRcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdFx0XHRpZiAoZmlsdGVyKSB7XHJcblx0XHRcdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dGVzdFByb3A6IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGdldFRyYW5zbGF0ZVN0cmluZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBvbiBXZWJLaXQgYnJvd3NlcnMgKENocm9tZS9TYWZhcmkvaU9TIFNhZmFyaS9BbmRyb2lkKSB1c2luZyB0cmFuc2xhdGUzZCBpbnN0ZWFkIG9mIHRyYW5zbGF0ZVxyXG5cdFx0Ly8gbWFrZXMgYW5pbWF0aW9uIHNtb290aGVyIGFzIGl0IGVuc3VyZXMgSFcgYWNjZWwgaXMgdXNlZC4gRmlyZWZveCAxMyBkb2Vzbid0IGNhcmVcclxuXHRcdC8vIChzYW1lIHNwZWVkIGVpdGhlciB3YXkpLCBPcGVyYSAxMiBkb2Vzbid0IHN1cHBvcnQgdHJhbnNsYXRlM2RcclxuXHJcblx0XHR2YXIgaXMzZCA9IEwuQnJvd3Nlci53ZWJraXQzZCxcclxuXHRcdCAgICBvcGVuID0gJ3RyYW5zbGF0ZScgKyAoaXMzZCA/ICczZCcgOiAnJykgKyAnKCcsXHJcblx0XHQgICAgY2xvc2UgPSAoaXMzZCA/ICcsMCcgOiAnJykgKyAnKSc7XHJcblxyXG5cdFx0cmV0dXJuIG9wZW4gKyBwb2ludC54ICsgJ3B4LCcgKyBwb2ludC55ICsgJ3B4JyArIGNsb3NlO1xyXG5cdH0sXHJcblxyXG5cdGdldFNjYWxlU3RyaW5nOiBmdW5jdGlvbiAoc2NhbGUsIG9yaWdpbikge1xyXG5cclxuXHRcdHZhciBwcmVUcmFuc2xhdGVTdHIgPSBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbi5hZGQob3JpZ2luLm11bHRpcGx5QnkoLTEgKiBzY2FsZSkpKSxcclxuXHRcdCAgICBzY2FsZVN0ciA9ICcgc2NhbGUoJyArIHNjYWxlICsgJykgJztcclxuXHJcblx0XHRyZXR1cm4gcHJlVHJhbnNsYXRlU3RyICsgc2NhbGVTdHI7XHJcblx0fSxcclxuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcG9pbnQsIGRpc2FibGUzRCkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgQm9vbGVhbl0pXHJcblxyXG5cdFx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2VcclxuXHRcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cclxuXHRcdGlmICghZGlzYWJsZTNEICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRlbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9ICBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKHBvaW50KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0XHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBwcmVmaXggc3R5bGUgcHJvcGVydHkgbmFtZXNcclxuXHJcbkwuRG9tVXRpbC5UUkFOU0ZPUk0gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcbiAgICAgICAgWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbkwuRG9tVXRpbC5UUkFOU0lUSU9OID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG4gICAgICAgIFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5EID1cclxuICAgICAgICBMLkRvbVV0aWwuVFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IEwuRG9tVXRpbC5UUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID9cclxuICAgICAgICBMLkRvbVV0aWwuVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICBMLmV4dGVuZChMLkRvbVV0aWwsIHtcclxuICAgICAgICAgICAgZGlzYWJsZVRleHRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGVuYWJsZVRleHRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuICAgICAgICAgICAgWyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG4gICAgICAgIEwuZXh0ZW5kKEwuRG9tVXRpbCwge1xyXG4gICAgICAgICAgICBkaXNhYmxlVGV4dFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZW5hYmxlVGV4dFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gdGhpcy5fdXNlclNlbGVjdDtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdXNlclNlbGVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHRMLmV4dGVuZChMLkRvbVV0aWwsIHtcclxuXHRcdGRpc2FibGVJbWFnZURyYWc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0ZW5hYmxlSW1hZ2VEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59KSgpO1xyXG5cblxuLypcclxuICogTC5MYXRMbmcgcmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5MYXRMbmcgPSBmdW5jdGlvbiAobGF0LCBsbmcsIGFsdCkgeyAvLyAoTnVtYmVyLCBOdW1iZXIsIE51bWJlcilcclxuXHRsYXQgPSBwYXJzZUZsb2F0KGxhdCk7XHJcblx0bG5nID0gcGFyc2VGbG9hdChsbmcpO1xyXG5cclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdHRoaXMubGF0ID0gbGF0O1xyXG5cdHRoaXMubG5nID0gbG5nO1xyXG5cclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gcGFyc2VGbG9hdChhbHQpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuZXh0ZW5kKEwuTGF0TG5nLCB7XHJcblx0REVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcclxuXHRSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cdE1BWF9NQVJHSU46IDEuMEUtOSAvLyBtYXggbWFyZ2luIG9mIGVycm9yIGZvciB0aGUgXCJlcXVhbHNcIiBjaGVja1xyXG59KTtcclxuXHJcbkwuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gTC5sYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gTC5MYXRMbmcuTUFYX01BUkdJTjtcclxuXHR9LFxyXG5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikgeyAvLyAoTnVtYmVyKSAtPiBTdHJpbmdcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gSGF2ZXJzaW5lIGRpc3RhbmNlIGZvcm11bGEsIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXHJcblx0Ly8gVE9ETyBtb3ZlIHRvIHByb2plY3Rpb24gY29kZSwgTGF0TG5nIHNob3VsZG4ndCBrbm93IGFib3V0IEVhcnRoXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7IC8vIChMYXRMbmcpIC0+IE51bWJlclxyXG5cdFx0b3RoZXIgPSBMLmxhdExuZyhvdGhlcik7XHJcblxyXG5cdFx0dmFyIFIgPSA2Mzc4MTM3LCAvLyBlYXJ0aCByYWRpdXMgaW4gbWV0ZXJzXHJcblx0XHQgICAgZDJyID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcclxuXHRcdCAgICBkTGF0ID0gKG90aGVyLmxhdCAtIHRoaXMubGF0KSAqIGQycixcclxuXHRcdCAgICBkTG9uID0gKG90aGVyLmxuZyAtIHRoaXMubG5nKSAqIGQycixcclxuXHRcdCAgICBsYXQxID0gdGhpcy5sYXQgKiBkMnIsXHJcblx0XHQgICAgbGF0MiA9IG90aGVyLmxhdCAqIGQycixcclxuXHRcdCAgICBzaW4xID0gTWF0aC5zaW4oZExhdCAvIDIpLFxyXG5cdFx0ICAgIHNpbjIgPSBNYXRoLnNpbihkTG9uIC8gMik7XHJcblxyXG5cdFx0dmFyIGEgPSBzaW4xICogc2luMSArIHNpbjIgKiBzaW4yICogTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcclxuXHJcblx0XHRyZXR1cm4gUiAqIDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XHJcblx0fSxcclxuXHJcblx0d3JhcDogZnVuY3Rpb24gKGEsIGIpIHsgLy8gKE51bWJlciwgTnVtYmVyKSAtPiBMYXRMbmdcclxuXHRcdHZhciBsbmcgPSB0aGlzLmxuZztcclxuXHJcblx0XHRhID0gYSB8fCAtMTgwO1xyXG5cdFx0YiA9IGIgfHwgIDE4MDtcclxuXHJcblx0XHRsbmcgPSAobG5nICsgYikgJSAoYiAtIGEpICsgKGxuZyA8IGEgfHwgbG5nID09PSBiID8gYiA6IGEpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5sYXQsIGxuZyk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5sYXRMbmcgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTGF0TG5nKSBvciAoW051bWJlciwgTnVtYmVyXSkgb3IgKE51bWJlciwgTnVtYmVyKVxyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoYSkpIHtcclxuXHRcdGlmICh0eXBlb2YgYVswXSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFbMF0gPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbik7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEsIGIpO1xyXG59O1xyXG5cclxuXG5cbi8qXHJcbiAqIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIG9uIHRoZSBtYXAgaW4gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuXHJcbkwuTGF0TG5nQm91bmRzID0gZnVuY3Rpb24gKHNvdXRoV2VzdCwgbm9ydGhFYXN0KSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghc291dGhXZXN0KSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IG5vcnRoRWFzdCA/IFtzb3V0aFdlc3QsIG5vcnRoRWFzdF0gOiBzb3V0aFdlc3Q7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmcpIG9yIChMYXRMbmdCb3VuZHMpXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXRMbmcgPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0aWYgKGxhdExuZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRvYmogPSBsYXRMbmc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3NvdXRoV2VzdCAmJiAhdGhpcy5fbm9ydGhFYXN0KSB7XHJcblx0XHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IEwuTGF0TG5nKG9iai5sYXQsIG9iai5sbmcpO1xyXG5cdFx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMLkxhdExuZyhvYmoubGF0LCBvYmoubG5nKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9zb3V0aFdlc3QubGF0ID0gTWF0aC5taW4ob2JqLmxhdCwgdGhpcy5fc291dGhXZXN0LmxhdCk7XHJcblx0XHRcdFx0dGhpcy5fc291dGhXZXN0LmxuZyA9IE1hdGgubWluKG9iai5sbmcsIHRoaXMuX3NvdXRoV2VzdC5sbmcpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9ub3J0aEVhc3QubGF0ID0gTWF0aC5tYXgob2JqLmxhdCwgdGhpcy5fbm9ydGhFYXN0LmxhdCk7XHJcblx0XHRcdFx0dGhpcy5fbm9ydGhFYXN0LmxuZyA9IE1hdGgubWF4KG9iai5sbmcsIHRoaXMuX25vcnRoRWFzdC5sbmcpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMuZXh0ZW5kKG9iai5fc291dGhXZXN0KTtcclxuXHRcdFx0dGhpcy5leHRlbmQob2JqLl9ub3J0aEVhc3QpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgYnkgYSBwZXJjZW50YWdlXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHsgLy8gKE51bWJlcikgLT4gTGF0TG5nQm91bmRzXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMLkxhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHsgLy8gLT4gTGF0TG5nXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoTGF0TG5nQm91bmRzKVxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKExhdExuZ0JvdW5kcylcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy9UT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuTC5sYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nLCBMYXRMbmcpXHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlByb2plY3Rpb24gY29udGFpbnMgdmFyaW91cyBnZW9ncmFwaGljYWwgcHJvamVjdGlvbnMgdXNlZCBieSBDUlMgY2xhc3Nlcy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24gPSB7fTtcclxuXG5cbi8qXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBpcyB0aGUgbW9zdCBwb3B1bGFyIG1hcCBwcm9qZWN0aW9uLCB1c2VkIGJ5IEVQU0c6Mzg1NyBDUlMgdXNlZCBieSBkZWZhdWx0LlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICB4ID0gbGF0bG5nLmxuZyAqIGQsXHJcblx0XHQgICAgeSA9IGxhdCAqIGQ7XHJcblxyXG5cdFx0eSA9IE1hdGgubG9nKE1hdGgudGFuKChNYXRoLlBJIC8gNCkgKyAoeSAvIDIpKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludCwgQm9vbGVhbikgLT4gTGF0TG5nXHJcblx0XHR2YXIgZCA9IEwuTGF0TG5nLlJBRF9UT19ERUcsXHJcblx0XHQgICAgbG5nID0gcG9pbnQueCAqIGQsXHJcblx0XHQgICAgbGF0ID0gKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSkpIC0gKE1hdGguUEkgLyAyKSkgKiBkO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcobGF0LCBsbmcpO1xyXG5cdH1cclxufTtcclxuXG5cbi8qXHJcbiAqIFNpbXBsZSBlcXVpcmVjdGFuZ3VsYXIgKFBsYXRlIENhcnJlZSkgcHJvamVjdGlvbiwgdXNlZCBieSBDUlMgbGlrZSBFUFNHOjQzMjYgYW5kIFNpbXBsZS5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkNSUyBpcyBhIGJhc2Ugb2JqZWN0IGZvciBhbGwgZGVmaW5lZCBDUlMgKENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbXMpIGluIExlYWZsZXQuXHJcbiAqL1xyXG5cclxuTC5DUlMgPSB7XHJcblx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkgeyAvLyAoTGF0TG5nLCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7IC8vIChQb2ludCwgTnVtYmVyWywgQm9vbGVhbl0pIC0+IExhdExuZ1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIHMgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cdFx0cmV0dXJuIEwucG9pbnQocywgcyk7XHJcblx0fVxyXG59O1xyXG5cblxuLypcbiAqIEEgc2ltcGxlIENSUyB0aGF0IGNhbiBiZSB1c2VkIGZvciBmbGF0IG5vbi1FYXJ0aCBtYXBzIGxpa2UgcGFub3JhbWFzIG9yIGdhbWUgbWFwcy5cbiAqL1xuXG5MLkNSUy5TaW1wbGUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH1cbn0pO1xuXG5cbi8qXHJcbiAqIEwuQ1JTLkVQU0czODU3IChTcGhlcmljYWwgTWVyY2F0b3IpIGlzIHRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIHdlYiBtYXBwaW5nXHJcbiAqIGFuZCBpcyB1c2VkIGJ5IExlYWZsZXQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzg1NyA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDAuNSAvIE1hdGguUEksIDAuNSwgLTAuNSAvIE1hdGguUEksIDAuNSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Lm11bHRpcGx5QnkoZWFydGhSYWRpdXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLkNSUy5FUFNHOTAwOTEzID0gTC5leHRlbmQoe30sIEwuQ1JTLkVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuXG5cbi8qXHJcbiAqIEwuQ1JTLkVQU0c0MzI2IGlzIGEgQ1JTIHBvcHVsYXIgYW1vbmcgYWR2YW5jZWQgR0lTIHNwZWNpYWxpc3RzLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0c0MzI2ID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5Mb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEgLyAzNjAsIDAuNSwgLTEgLyAzNjAsIDAuNSlcclxufSk7XHJcblxuXG4vKlxyXG4gKiBMLk1hcCBpcyB0aGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIC0gaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAuXHJcbiAqL1xyXG5cclxuTC5NYXAgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Y3JzOiBMLkNSUy5FUFNHMzg1NyxcclxuXHJcblx0XHQvKlxyXG5cdFx0Y2VudGVyOiBMYXRMbmcsXHJcblx0XHR6b29tOiBOdW1iZXIsXHJcblx0XHRsYXllcnM6IEFycmF5LFxyXG5cdFx0Ki9cclxuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlLFxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogTC5Eb21VdGlsLlRSQU5TSVRJT04gJiYgTC5Ccm93c2VyLmFueTNkXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gTC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KEwubGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl90aWxlTGF5ZXJzTnVtID0gMDtcclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnMob3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwdWJsaWMgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gcmVwbGFjZWQgYnkgYW5pbWF0aW9uLXBvd2VyZWQgaW1wbGVtZW50YXRpb24gaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb207XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoTC5sYXRMbmcoY2VudGVyKSwgdGhpcy5fbGltaXRab29tKHpvb20pKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgKGRlbHRhIHx8IDEpLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIChkZWx0YSB8fCAxKSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAob3B0aW9ucy5tYXhab29tKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCkgeyAvLyAoUG9pbnQpXHJcblx0XHQvLyByZXBsYWNlZCB3aXRoIGFuaW1hdGVkIHBhbkJ5IGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblxyXG5cdFx0dGhpcy5fcmF3UGFuQnkoTC5wb2ludChvZmZzZXQpKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAoIWJvdW5kcykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHQvLyBUT0RPIG1ldGhvZCBpcyB0b28gYmlnLCByZWZhY3RvclxyXG5cclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdC8vIFRPRE8gZ2V0TWF4Wm9vbSwgZ2V0TWluWm9vbSBpbiBJTGF5ZXIgKGluc3RlYWQgb2Ygb3B0aW9ucylcclxuXHRcdGlmIChsYXllci5vcHRpb25zICYmICghaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkpIHtcclxuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyBsb29rcyB1Z2x5LCByZWZhY3RvciEhIVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuVGlsZUxheWVyICYmIChsYXllciBpbnN0YW5jZW9mIEwuVGlsZUxheWVyKSkge1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzTnVtKys7XHJcblx0XHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQrKztcclxuXHRcdFx0bGF5ZXIub24oJ2xvYWQnLCB0aGlzLl9vblRpbGVMYXllckxvYWQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJBZGQobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyBsb29rcyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuVGlsZUxheWVyICYmIChsYXllciBpbnN0YW5jZW9mIEwuVGlsZUxheWVyKSkge1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzTnVtLS07XHJcblx0XHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQtLTtcclxuXHRcdFx0bGF5ZXIub2ZmKCdsb2FkJywgdGhpcy5fb25UaWxlTGF5ZXJMb2FkLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIWxheWVyKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHJldHVybiAoTC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9pbml0aWFsQ2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBoYW5kbGVyLmFkZFRvXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoJ29mZicpO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJQYW5lcygpO1xyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHB1YmxpYyBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHsgLy8gKEJvb2xlYW4pIC0+IExhdExuZ1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0aWFsQ2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9pbml0aWFsQ2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01pblpvb20gPT09IHVuZGVmaW5lZCA/IDAgOiB0aGlzLl9sYXllcnNNaW5ab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRNaW5ab29tKCkgLSAoaW5zaWRlID8gMSA6IDApLFxyXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICB6b29tTm90Rm91bmQgPSB0cnVlLFxyXG5cdFx0ICAgIGJvdW5kc1NpemU7XHJcblxyXG5cdFx0cGFkZGluZyA9IEwucG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdGRvIHtcclxuXHRcdFx0em9vbSsrO1xyXG5cdFx0XHRib3VuZHNTaXplID0gdGhpcy5wcm9qZWN0KHNlLCB6b29tKS5zdWJ0cmFjdCh0aGlzLnByb2plY3QobncsIHpvb20pKS5hZGQocGFkZGluZyk7XHJcblx0XHRcdHpvb21Ob3RGb3VuZCA9ICFpbnNpZGUgPyBzaXplLmNvbnRhaW5zKGJvdW5kc1NpemUpIDogYm91bmRzU2l6ZS54IDwgc2l6ZS54IHx8IGJvdW5kc1NpemUueSA8IHNpemUueTtcclxuXHJcblx0XHR9IHdoaWxlICh6b29tTm90Rm91bmQgJiYgem9vbSA8PSBtYXhab29tKTtcclxuXHJcblx0XHRpZiAoem9vbU5vdEZvdW5kICYmIGluc2lkZSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5zaWRlID8gem9vbSA6IHpvb20gLSAxO1xyXG5cdH0sXHJcblxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IEwuUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoKTtcclxuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9pbml0aWFsVG9wTGVmdFBvaW50O1xyXG5cdH0sXHJcblxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZSh0aGlzLl96b29tKTtcclxuXHR9LFxyXG5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb20gKyAoTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBjb252ZXJzaW9uIG1ldGhvZHNcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkgeyAvLyAoTGF0TG5nWywgTnVtYmVyXSkgLT4gUG9pbnRcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQoTC5sYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHsgLy8gKFBvaW50WywgTnVtYmVyXSkgLT4gTGF0TG5nXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKEwucG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7IC8vIChMYXRMbmcpXHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QoTC5sYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChMLnBvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoTC5sYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb250YWluZXIuX2xlYWZsZXQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBMLkRvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSBwYW5lcy5tYXBQYW5lID0gdGhpcy5fY3JlYXRlUGFuZSgnbGVhZmxldC1tYXAtcGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0dGhpcy5fdGlsZVBhbmUgPSBwYW5lcy50aWxlUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtdGlsZS1wYW5lJywgdGhpcy5fbWFwUGFuZSk7XHJcblx0XHRwYW5lcy5vYmplY3RzUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtb2JqZWN0cy1wYW5lJywgdGhpcy5fbWFwUGFuZSk7XHJcblx0XHRwYW5lcy5zaGFkb3dQYW5lID0gdGhpcy5fY3JlYXRlUGFuZSgnbGVhZmxldC1zaGFkb3ctcGFuZScpO1xyXG5cdFx0cGFuZXMub3ZlcmxheVBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LW92ZXJsYXktcGFuZScpO1xyXG5cdFx0cGFuZXMubWFya2VyUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtbWFya2VyLXBhbmUnKTtcclxuXHRcdHBhbmVzLnBvcHVwUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtcG9wdXAtcGFuZScpO1xyXG5cclxuXHRcdHZhciB6b29tSGlkZSA9ICcgbGVhZmxldC16b29tLWhpZGUnO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsIHpvb21IaWRlKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsIHpvb21IaWRlKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnBvcHVwUGFuZSwgem9vbUhpZGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVQYW5lOiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9wYW5lcy5vYmplY3RzUGFuZSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyUGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9tYXBQYW5lKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoTC5VdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHByZXNlcnZlTWFwT2Zmc2V0LCBhZnRlclpvb21BbmltKSB7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gKHRoaXMuX3pvb20gIT09IHpvb20pO1xyXG5cclxuXHRcdGlmICghYWZ0ZXJab29tQW5pbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5faW5pdGlhbENlbnRlciA9IGNlbnRlcjtcclxuXHJcblx0XHR0aGlzLl9pbml0aWFsVG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0TmV3VG9wTGVmdFBvaW50KGNlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFwcmVzZXJ2ZU1hcE9mZnNldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IEwuUG9pbnQoMCwgMCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5faW5pdGlhbFRvcExlZnRQb2ludC5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZUxheWVyc1RvTG9hZCA9IHRoaXMuX3RpbGVMYXllcnNOdW07XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcsIHtoYXJkOiAhcHJlc2VydmVNYXBPZmZzZXR9KTtcclxuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fbGF5ZXJBZGQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCBhZnRlclpvb21BbmltKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcsIHtoYXJkOiAhcHJlc2VydmVNYXBPZmZzZXR9KTtcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksXHJcblx0XHRcdG1pblpvb20gPSBJbmZpbml0eSxcclxuXHRcdFx0bWF4Wm9vbSA9IC1JbmZpbml0eSxcclxuXHRcdFx0b2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldO1xyXG5cdFx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcclxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5taW4obWluWm9vbSwgbGF5ZXIub3B0aW9ucy5taW5ab29tKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkpIHtcclxuXHRcdFx0XHRtYXhab29tID0gTWF0aC5tYXgobWF4Wm9vbSwgbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHsgLy8gd2UgaGF2ZSBubyB0aWxlbGF5ZXJzXHJcblx0XHRcdHRoaXMuX2xheWVyc01heFpvb20gPSB0aGlzLl9sYXllcnNNaW5ab29tID0gdW5kZWZpbmVkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb207XHJcblx0XHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBtYXAgZXZlbnRzXHJcblxyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAob25PZmYpIHtcclxuXHRcdGlmICghTC5Eb21FdmVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRvbk9mZiA9IG9uT2ZmIHx8ICdvbic7XHJcblxyXG5cdFx0TC5Eb21FdmVudFtvbk9mZl0odGhpcy5fY29udGFpbmVyLCAnY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBldmVudHMgPSBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlZW50ZXInLFxyXG5cdFx0ICAgICAgICAgICAgICAnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXSxcclxuXHRcdCAgICBpLCBsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lciwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50W29uT2ZmXSh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzLCBmYWxzZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgKCFlLl9zaW11bGF0ZWQgJiZcclxuXHRcdCAgICAgICAgKCh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcubW92ZWQoKSkgfHxcclxuXHRcdCAgICAgICAgICh0aGlzLmJveFpvb20gICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKSkpIHx8XHJcblx0XHQgICAgICAgICAgICBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuZmlyZSgncHJlY2xpY2snKTtcclxuXHRcdHRoaXMuX2ZpcmVNb3VzZUV2ZW50KGUpO1xyXG5cdH0sXHJcblxyXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IEwuRG9tRXZlbnQuX3NraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0dHlwZSA9ICh0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICh0eXBlID09PSAnbW91c2VsZWF2ZScgPyAnbW91c2VvdXQnIDogdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGhpcy5oYXNFdmVudExpc3RlbmVycyh0eXBlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250YWluZXJQb2ludCA9IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSksXHJcblx0XHQgICAgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpLFxyXG5cdFx0ICAgIGxhdGxuZyA9IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSh0eXBlLCB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxyXG5cdFx0XHRjb250YWluZXJQb2ludDogY29udGFpbmVyUG9pbnQsXHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVMYXllckxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQtLTtcclxuXHRcdGlmICh0aGlzLl90aWxlTGF5ZXJzTnVtICYmICF0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndGlsZWxheWVyc2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2xheWVyQWRkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9uQWRkKHRoaXMpO1xyXG5cdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdC8vIFRPRE8gcm91bmQgb24gZGlzcGxheSwgbm90IGNhbGN1bGF0aW9uIHRvIGluY3JlYXNlIHByZWNpc2lvbj9cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIG5ld1pvb20sIG5ld0NlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdUb3BMZWZ0UG9pbnQobmV3Q2VudGVyLCBuZXdab29tKS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCBuZXdab29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEwuQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBud09mZnNldCA9IHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgc2VPZmZzZXQgPSB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobndPZmZzZXQueCwgLXNlT2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChud09mZnNldC55LCAtc2VPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLm1hcCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXAoaWQsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTWVyY2F0b3IgcHJvamVjdGlvbiB0aGF0IHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBFYXJ0aCBpcyBub3QgYSBwZXJmZWN0IHNwaGVyZS5cclxuICogTGVzcyBwb3B1bGFyIHRoYW4gc3BoZXJpY2FsIG1lcmNhdG9yOyB1c2VkIGJ5IHByb2plY3Rpb25zIGxpa2UgRVBTRzozMzk1LlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5NZXJjYXRvciA9IHtcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA4NDA1OTE1NTYsXHJcblxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cdFJfTUFKT1I6IDYzNzgxMzcsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICByID0gdGhpcy5SX01BSk9SLFxyXG5cdFx0ICAgIHIyID0gdGhpcy5SX01JTk9SLFxyXG5cdFx0ICAgIHggPSBsYXRsbmcubG5nICogZCAqIHIsXHJcblx0XHQgICAgeSA9IGxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gcjIgLyByLFxyXG5cdFx0ICAgIGVjY2VudCA9IE1hdGguc3FydCgxLjAgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGVjY2VudCAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZWNjZW50ICogMC41KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbigwLjUgKiAoKE1hdGguUEkgKiAwLjUpIC0geSkpIC8gY29uO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2codHMpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQsIEJvb2xlYW4pIC0+IExhdExuZ1xyXG5cdFx0dmFyIGQgPSBMLkxhdExuZy5SQURfVE9fREVHLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlJfTUFKT1IsXHJcblx0XHQgICAgcjIgPSB0aGlzLlJfTUlOT1IsXHJcblx0XHQgICAgbG5nID0gcG9pbnQueCAqIGQgLyByLFxyXG5cdFx0ICAgIHRtcCA9IHIyIC8gcixcclxuXHRcdCAgICBlY2NlbnQgPSBNYXRoLnNxcnQoMSAtICh0bXAgKiB0bXApKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC0gcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IChNYXRoLlBJIC8gMikgLSAyICogTWF0aC5hdGFuKHRzKSxcclxuXHRcdCAgICBudW1JdGVyID0gMTUsXHJcblx0XHQgICAgdG9sID0gMWUtNyxcclxuXHRcdCAgICBpID0gbnVtSXRlcixcclxuXHRcdCAgICBkcGhpID0gMC4xLFxyXG5cdFx0ICAgIGNvbjtcclxuXHJcblx0XHR3aGlsZSAoKE1hdGguYWJzKGRwaGkpID4gdG9sKSAmJiAoLS1pID4gMCkpIHtcclxuXHRcdFx0Y29uID0gZWNjZW50ICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0ZHBoaSA9IChNYXRoLlBJIC8gMikgLSAyICogTWF0aC5hdGFuKHRzICpcclxuXHRcdFx0ICAgICAgICAgICAgTWF0aC5wb3coKDEuMCAtIGNvbikgLyAoMS4wICsgY29uKSwgMC41ICogZWNjZW50KSkgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcocGhpICogZCwgbG5nKTtcclxuXHR9XHJcbn07XHJcblxuXG5cclxuTC5DUlMuRVBTRzMzOTUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtID0gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cdFx0ICAgIHIgPSBtLlJfTUFKT1IsXHJcblx0XHQgICAgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIHIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIEwuVGlsZUxheWVyIGlzIHVzZWQgZm9yIHN0YW5kYXJkIHh5ei1udW1iZXJlZCB0aWxlIGxheWVycy5cclxuICovXHJcblxyXG5MLlRpbGVMYXllciA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1pblpvb206IDAsXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHRcdHRpbGVTaXplOiAyNTYsXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblx0XHRhdHRyaWJ1dGlvbjogJycsXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHRcdC8qXHJcblx0XHRtYXhOYXRpdmVab29tOiBudWxsLFxyXG5cdFx0ekluZGV4OiBudWxsLFxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHRcdGNvbnRpbnVvdXNXb3JsZDogZmFsc2UsXHJcblx0XHRub1dyYXA6IGZhbHNlLFxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHRcdHJldXNlVGlsZXM6IGZhbHNlLFxyXG5cdFx0Ym91bmRzOiBmYWxzZSxcclxuXHRcdCovXHJcblx0XHR1bmxvYWRJbnZpc2libGVUaWxlczogTC5Ccm93c2VyLm1vYmlsZSxcclxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBMLkJyb3dzZXIubW9iaWxlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMubWluWm9vbSA+IDApIHtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20tLTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmJvdW5kcykge1xyXG5cdFx0XHRvcHRpb25zLmJvdW5kcyA9IEwubGF0TG5nQm91bmRzKG9wdGlvbnMuYm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHN1YmRvbWFpbnMgPSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucztcclxuXHJcblx0XHRpZiAodHlwZW9mIHN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5zdWJkb21haW5zID0gc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHRoaXMuX2FuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0Ly8gY3JlYXRlIGEgY29udGFpbmVyIGRpdiBmb3IgdGlsZXNcclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcclxuXHJcblx0XHQvLyBzZXQgdXAgZXZlbnRzXHJcblx0XHRtYXAub24oe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5fcmVzZXQsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlXHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKHtcclxuXHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcclxuXHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFpvb21BbmltXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XHJcblx0XHRcdHRoaXMuX2xpbWl0ZWRVcGRhdGUgPSBMLlV0aWwubGltaXRFeGVjQnlJbnRlcnZhbCh0aGlzLl91cGRhdGUsIDE1MCwgdGhpcyk7XHJcblx0XHRcdG1hcC5vbignbW92ZScsIHRoaXMuX2xpbWl0ZWRVcGRhdGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0bWFwLm9mZih7XHJcblx0XHRcdCd2aWV3cmVzZXQnOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0J21vdmVlbmQnOiB0aGlzLl91cGRhdGVcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKHtcclxuXHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcclxuXHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFpvb21BbmltXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XHJcblx0XHRcdG1hcC5vZmYoJ21vdmUnLCB0aGlzLl9saW1pdGVkVXBkYXRlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lID0gdGhpcy5fbWFwLl9wYW5lcy50aWxlUGFuZTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChwYW5lLCBNYXRoLm1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lID0gdGhpcy5fbWFwLl9wYW5lcy50aWxlUGFuZTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHBhbmUuaW5zZXJ0QmVmb3JlKHRoaXMuX2NvbnRhaW5lciwgcGFuZS5maXJzdENoaWxkKTtcclxuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChwYW5lLCBNYXRoLm1pbik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoe2hhcmQ6IHRydWV9KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKHBhbmUsIGNvbXBhcmUpIHtcclxuXHJcblx0XHR2YXIgbGF5ZXJzID0gcGFuZS5jaGlsZHJlbixcclxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoSW5maW5pdHksIC1JbmZpbml0eSksIC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXHJcblx0XHQgICAgekluZGV4LCBpLCBsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0XHR6SW5kZXggPSBwYXJzZUludChsYXllcnNbaV0uc3R5bGUuekluZGV4LCAxMCk7XHJcblxyXG5cdFx0XHRcdGlmICghaXNOYU4oekluZGV4KSkge1xyXG5cdFx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgekluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9XHJcblx0XHQgICAgICAgIChpc0Zpbml0ZShlZGdlWkluZGV4KSA/IGVkZ2VaSW5kZXggOiAwKSArIGNvbXBhcmUoMSwgLTEpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSxcclxuXHRcdCAgICB0aWxlcyA9IHRoaXMuX3RpbGVzO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0Zm9yIChpIGluIHRpbGVzKSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZXNbaV0sIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB0aWxlUGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXInKTtcclxuXHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXRpbGUtY29udGFpbmVyJztcclxuXHJcblx0XHRcdFx0dGhpcy5fYmdCdWZmZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGlsZVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge3RpbGU6IHRoaXMuX3RpbGVzW2tleV19KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xyXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQgPSAwO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmV1c2VUaWxlcykge1xyXG5cdFx0XHR0aGlzLl91bnVzZWRUaWxlcyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RpbGVDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkICYmIGUgJiYgZS5oYXJkKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQmdCdWZmZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XHJcblx0fSxcclxuXHJcblx0X2dldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpICsgdGhpcy5vcHRpb25zLnpvb21PZmZzZXQsXHJcblx0XHQgICAgem9vbU4gPSB0aGlzLm9wdGlvbnMubWF4TmF0aXZlWm9vbSxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcclxuXHJcblx0XHRpZiAoem9vbU4gJiYgem9vbSA+IHpvb21OKSB7XHJcblx0XHRcdHRpbGVTaXplID0gTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbVNjYWxlKHpvb20pIC8gbWFwLmdldFpvb21TY2FsZSh6b29tTikgKiB0aWxlU2l6ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpbGVTaXplO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcclxuXHJcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSBMLmJvdW5kcyhcclxuXHRcdCAgICAgICAgYm91bmRzLm1pbi5kaXZpZGVCeSh0aWxlU2l6ZSkuX2Zsb29yKCksXHJcblx0XHQgICAgICAgIGJvdW5kcy5tYXguZGl2aWRlQnkodGlsZVNpemUpLl9mbG9vcigpKTtcclxuXHJcblx0XHR0aGlzLl9hZGRUaWxlc0Zyb21DZW50ZXJPdXQodGlsZUJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy51bmxvYWRJbnZpc2libGVUaWxlcyB8fCB0aGlzLm9wdGlvbnMucmV1c2VUaWxlcykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVPdGhlclRpbGVzKHRpbGVCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hZGRUaWxlc0Zyb21DZW50ZXJPdXQ6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBxdWV1ZSA9IFtdLFxyXG5cdFx0ICAgIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcclxuXHJcblx0XHR2YXIgaiwgaSwgcG9pbnQ7XHJcblxyXG5cdFx0Zm9yIChqID0gYm91bmRzLm1pbi55OyBqIDw9IGJvdW5kcy5tYXgueTsgaisrKSB7XHJcblx0XHRcdGZvciAoaSA9IGJvdW5kcy5taW4ueDsgaSA8PSBib3VuZHMubWF4Lng7IGkrKykge1xyXG5cdFx0XHRcdHBvaW50ID0gbmV3IEwuUG9pbnQoaSwgaik7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLl90aWxlU2hvdWxkQmVMb2FkZWQocG9pbnQpKSB7XHJcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBvaW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGlsZXNUb0xvYWQgPSBxdWV1ZS5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKHRpbGVzVG9Mb2FkID09PSAwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXHJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8oY2VudGVyKSAtIGIuZGlzdGFuY2VUbyhjZW50ZXIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG5cclxuXHRcdC8vIGlmIGl0cyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxyXG5cdFx0aWYgKCF0aGlzLl90aWxlc1RvTG9hZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90aWxlc1RvTG9hZCArPSB0aWxlc1RvTG9hZDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlsZXNUb0xvYWQ7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZUNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVTaG91bGRCZUxvYWRlZDogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0aWYgKCh0aWxlUG9pbnQueCArICc6JyArIHRpbGVQb2ludC55KSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGFscmVhZHkgbG9hZGVkXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKCFvcHRpb25zLmNvbnRpbnVvdXNXb3JsZCkge1xyXG5cdFx0XHR2YXIgbGltaXQgPSB0aGlzLl9nZXRXcmFwVGlsZU51bSgpO1xyXG5cclxuXHRcdFx0Ly8gZG9uJ3QgbG9hZCBpZiBleGNlZWRzIHdvcmxkIGJvdW5kc1xyXG5cdFx0XHRpZiAoKG9wdGlvbnMubm9XcmFwICYmICh0aWxlUG9pbnQueCA8IDAgfHwgdGlsZVBvaW50LnggPj0gbGltaXQueCkpIHx8XHJcblx0XHRcdFx0dGlsZVBvaW50LnkgPCAwIHx8IHRpbGVQb2ludC55ID49IGxpbWl0LnkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYm91bmRzKSB7XHJcblx0XHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuX2dldFRpbGVTaXplKCksXHJcblx0XHRcdCAgICBud1BvaW50ID0gdGlsZVBvaW50Lm11bHRpcGx5QnkodGlsZVNpemUpLFxyXG5cdFx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKFt0aWxlU2l6ZSwgdGlsZVNpemVdKSxcclxuXHRcdFx0ICAgIG53ID0gdGhpcy5fbWFwLnVucHJvamVjdChud1BvaW50KSxcclxuXHRcdFx0ICAgIHNlID0gdGhpcy5fbWFwLnVucHJvamVjdChzZVBvaW50KTtcclxuXHJcblx0XHRcdC8vIFRPRE8gdGVtcG9yYXJ5IGhhY2ssIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xNjE4XHJcblx0XHRcdGlmICghb3B0aW9ucy5jb250aW51b3VzV29ybGQgJiYgIW9wdGlvbnMubm9XcmFwKSB7XHJcblx0XHRcdFx0bncgPSBudy53cmFwKCk7XHJcblx0XHRcdFx0c2UgPSBzZS53cmFwKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy5ib3VuZHMuaW50ZXJzZWN0cyhbbncsIHNlXSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZU90aGVyVGlsZXM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBrQXJyLCB4LCB5LCBrZXk7XHJcblxyXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0a0FyciA9IGtleS5zcGxpdCgnOicpO1xyXG5cdFx0XHR4ID0gcGFyc2VJbnQoa0FyclswXSwgMTApO1xyXG5cdFx0XHR5ID0gcGFyc2VJbnQoa0FyclsxXSwgMTApO1xyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzXHJcblx0XHRcdGlmICh4IDwgYm91bmRzLm1pbi54IHx8IHggPiBib3VuZHMubWF4LnggfHwgeSA8IGJvdW5kcy5taW4ueSB8fCB5ID4gYm91bmRzLm1heC55KSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7dGlsZTogdGlsZSwgdXJsOiB0aWxlLnNyY30pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmV1c2VUaWxlcykge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcclxuXHRcdFx0dGhpcy5fdW51c2VkVGlsZXMucHVzaCh0aWxlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRpbGUucGFyZW50Tm9kZSA9PT0gdGhpcy5fdGlsZUNvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl90aWxlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRpbGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vQ2xvdWRNYWRlL0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHR0aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0XHRcdHRpbGUuc3JjID0gTC5VdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XHJcblx0fSxcclxuXHJcblx0X2FkZFRpbGU6IGZ1bmN0aW9uICh0aWxlUG9pbnQsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKHRpbGVQb2ludCk7XHJcblxyXG5cdFx0Ly8gZ2V0IHVudXNlZCB0aWxlIC0gb3IgY3JlYXRlIGEgbmV3IHRpbGVcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fZ2V0VGlsZSgpO1xyXG5cclxuXHRcdC8qXHJcblx0XHRDaHJvbWUgMjAgbGF5b3V0cyBtdWNoIGZhc3RlciB3aXRoIHRvcC9sZWZ0ICh2ZXJpZnkgd2l0aCB0aW1lbGluZSwgZnJhbWVzKVxyXG5cdFx0QW5kcm9pZCA0IGJyb3dzZXIgaGFzIGRpc3BsYXkgaXNzdWVzIHdpdGggdG9wL2xlZnQgYW5kIHJlcXVpcmVzIHRyYW5zZm9ybSBpbnN0ZWFkXHJcblx0XHQob3RoZXIgYnJvd3NlcnMgZG9uJ3QgY3VycmVudGx5IGNhcmUpIC0gc2VlIGRlYnVnL2hhY2tzL2ppdHRlci5odG1sIGZvciBhbiBleGFtcGxlXHJcblx0XHQqL1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MsIEwuQnJvd3Nlci5jaHJvbWUpO1xyXG5cclxuXHRcdHRoaXMuX3RpbGVzW3RpbGVQb2ludC54ICsgJzonICsgdGlsZVBvaW50LnldID0gdGlsZTtcclxuXHJcblx0XHR0aGlzLl9sb2FkVGlsZSh0aWxlLCB0aWxlUG9pbnQpO1xyXG5cclxuXHRcdGlmICh0aWxlLnBhcmVudE5vZGUgIT09IHRoaXMuX3RpbGVDb250YWluZXIpIHtcclxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG9wdGlvbnMubWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0em9vbSArPSBvcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4TmF0aXZlWm9vbSkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgb3JpZ2luID0gdGhpcy5fbWFwLmdldFBpeGVsT3JpZ2luKCksXHJcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl9nZXRUaWxlU2l6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlUG9pbnQubXVsdGlwbHlCeSh0aWxlU2l6ZSkuc3VidHJhY3Qob3JpZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBpbWFnZS1zcGVjaWZpYyBjb2RlIChvdmVycmlkZSB0byBpbXBsZW1lbnQgZS5nLiBDYW52YXMgb3IgU1ZHIHRpbGUgbGF5ZXIpXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHJldHVybiBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBMLmV4dGVuZCh7XHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbih0aWxlUG9pbnQpLFxyXG5cdFx0XHR6OiB0aWxlUG9pbnQueixcclxuXHRcdFx0eDogdGlsZVBvaW50LngsXHJcblx0XHRcdHk6IHRpbGVQb2ludC55XHJcblx0XHR9LCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0V3JhcFRpbGVOdW06IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnMsXHJcblx0XHQgICAgc2l6ZSA9IGNycy5nZXRTaXplKHRoaXMuX21hcC5nZXRab29tKCkpO1xyXG5cdFx0cmV0dXJuIHNpemUuZGl2aWRlQnkodGhpcy5fZ2V0VGlsZVNpemUoKSkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFRpbGVQb2ludDogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cclxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX2dldFdyYXBUaWxlTnVtKCk7XHJcblxyXG5cdFx0Ly8gd3JhcCB0aWxlIGNvb3JkaW5hdGVzXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jb250aW51b3VzV29ybGQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcclxuXHRcdFx0dGlsZVBvaW50LnggPSAoKHRpbGVQb2ludC54ICUgbGltaXQueCkgKyBsaW1pdC54KSAlIGxpbWl0Lng7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0dGlsZVBvaW50LnkgPSBsaW1pdC55IC0gdGlsZVBvaW50LnkgLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRpbGVQb2ludC56ID0gdGhpcy5fZ2V0Wm9vbUZvclVybCgpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VGlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXVzZVRpbGVzICYmIHRoaXMuX3VudXNlZFRpbGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl91bnVzZWRUaWxlcy5wb3AoKTtcclxuXHRcdFx0dGhpcy5fcmVzZXRUaWxlKHRpbGUpO1xyXG5cdFx0XHRyZXR1cm4gdGlsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVUaWxlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gT3ZlcnJpZGUgaWYgZGF0YSBzdG9yZWQgb24gYSB0aWxlIG5lZWRzIHRvIGJlIGNsZWFuZWQgdXAgYmVmb3JlIHJldXNlXHJcblx0X3Jlc2V0VGlsZTogZnVuY3Rpb24gKC8qdGlsZSovKSB7fSxcclxuXHJcblx0X2NyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW1nJywgJ2xlYWZsZXQtdGlsZScpO1xyXG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZ2V0VGlsZVNpemUoKSArICdweCc7XHJcblx0XHR0aWxlLmdhbGxlcnlpbWcgPSAnbm8nO1xyXG5cclxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxyXG5cdFx0aWYgKEwuQnJvd3Nlci5tb2JpbGVXZWJraXQzZCkge1xyXG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0X2xvYWRUaWxlOiBmdW5jdGlvbiAodGlsZSwgdGlsZVBvaW50KSB7XHJcblx0XHR0aWxlLl9sYXllciAgPSB0aGlzO1xyXG5cdFx0dGlsZS5vbmxvYWQgID0gdGhpcy5fdGlsZU9uTG9hZDtcclxuXHRcdHRpbGUub25lcnJvciA9IHRoaXMuX3RpbGVPbkVycm9yO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFRpbGVQb2ludCh0aWxlUG9pbnQpO1xyXG5cdFx0dGlsZS5zcmMgICAgID0gdGhpcy5nZXRUaWxlVXJsKHRpbGVQb2ludCk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xyXG5cdFx0XHR0aWxlOiB0aWxlLFxyXG5cdFx0XHR1cmw6IHRpbGUuc3JjXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZUxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQtLTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3RpbGVDb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3RpbGVzVG9Mb2FkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdFx0Ly8gY2xlYXIgc2NhbGVkIHRpbGVzIGFmdGVyIGFsbCBuZXcgdGlsZXMgYXJlIGxvYWRlZCAoZm9yIHBlcmZvcm1hbmNlKVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9jbGVhckJnQnVmZmVyVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX2NsZWFyQmdCdWZmZXJUaW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX2NsZWFyQmdCdWZmZXIsIHRoaXMpLCA1MDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyO1xyXG5cclxuXHRcdC8vT25seSBpZiB3ZSBhcmUgbG9hZGluZyBhbiBhY3R1YWwgaW1hZ2VcclxuXHRcdGlmICh0aGlzLnNyYyAhPT0gTC5VdGlsLmVtcHR5SW1hZ2VVcmwpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XHJcblxyXG5cdFx0XHRsYXllci5maXJlKCd0aWxlbG9hZCcsIHtcclxuXHRcdFx0XHR0aWxlOiB0aGlzLFxyXG5cdFx0XHRcdHVybDogdGhpcy5zcmNcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuX3RpbGVMb2FkZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyO1xyXG5cclxuXHRcdGxheWVyLmZpcmUoJ3RpbGVlcnJvcicsIHtcclxuXHRcdFx0dGlsZTogdGhpcyxcclxuXHRcdFx0dXJsOiB0aGlzLnNyY1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIG5ld1VybCA9IGxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKG5ld1VybCkge1xyXG5cdFx0XHR0aGlzLnNyYyA9IG5ld1VybDtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5fdGlsZUxvYWRlZCgpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnRpbGVMYXllciA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlRpbGVMYXllci5XTVMgaXMgdXNlZCBmb3IgcHV0dGluZyBXTVMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLlRpbGVMYXllci5XTVMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJyxcclxuXHRcdGxheWVyczogJycsXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIE9iamVjdClcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IEwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZSB8fCB0aGlzLm9wdGlvbnMudGlsZVNpemU7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEpIHtcclxuXHRcdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplICogMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdtc1BhcmFtcy53aWR0aCA9IHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ2NycycpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblxyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdEwuVGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKHRpbGVQb2ludCkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gU3RyaW5nXHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSxcclxuXHJcblx0XHQgICAgbndQb2ludCA9IHRpbGVQb2ludC5tdWx0aXBseUJ5KHRpbGVTaXplKSxcclxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQoW3RpbGVTaXplLCB0aWxlU2l6ZV0pLFxyXG5cclxuXHRcdCAgICBudyA9IHRoaXMuX2Nycy5wcm9qZWN0KG1hcC51bnByb2plY3QobndQb2ludCwgdGlsZVBvaW50LnopKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2Nycy5wcm9qZWN0KG1hcC51bnByb2plY3Qoc2VQb2ludCwgdGlsZVBvaW50LnopKSxcclxuXHRcdCAgICBiYm94ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBMLkNSUy5FUFNHNDMyNiA/XHJcblx0XHQgICAgICAgIFtzZS55LCBudy54LCBudy55LCBzZS54XS5qb2luKCcsJykgOlxyXG5cdFx0ICAgICAgICBbbncueCwgc2UueSwgc2UueCwgbncueV0uam9pbignLCcpLFxyXG5cclxuXHRcdCAgICB1cmwgPSBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCB7czogdGhpcy5fZ2V0U3ViZG9tYWluKHRpbGVQb2ludCl9KTtcclxuXHJcblx0XHRyZXR1cm4gdXJsICsgTC5VdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRydWUpICsgJyZCQk9YPScgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRMLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbkwudGlsZUxheWVyLndtcyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLldNUyh1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5UaWxlTGF5ZXIuQ2FudmFzIGlzIGEgY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSBhcyBhIGJhc2UgZm9yIGNyZWF0aW5nXHJcbiAqIGR5bmFtaWNhbGx5IGRyYXduIENhbnZhcy1iYXNlZCB0aWxlIGxheWVycy5cclxuICovXHJcblxyXG5MLlRpbGVMYXllci5DYW52YXMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGFzeW5jOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KHtoYXJkOiB0cnVlfSk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fcmVkcmF3VGlsZSh0aGlzLl90aWxlc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVkcmF3VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcclxuXHRcdHRoaXMuZHJhd1RpbGUodGlsZSwgdGlsZS5fdGlsZVBvaW50LCB0aGlzLl9tYXAuX3pvb20pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcclxuXHRcdHRpbGUud2lkdGggPSB0aWxlLmhlaWdodCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcclxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdF9sb2FkVGlsZTogZnVuY3Rpb24gKHRpbGUsIHRpbGVQb2ludCkge1xyXG5cdFx0dGlsZS5fbGF5ZXIgPSB0aGlzO1xyXG5cdFx0dGlsZS5fdGlsZVBvaW50ID0gdGlsZVBvaW50O1xyXG5cclxuXHRcdHRoaXMuX3JlZHJhd1RpbGUodGlsZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXN5bmMpIHtcclxuXHRcdFx0dGhpcy50aWxlRHJhd24odGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhd1RpbGU6IGZ1bmN0aW9uICgvKnRpbGUsIHRpbGVQb2ludCovKSB7XHJcblx0XHQvLyBvdmVycmlkZSB3aXRoIHJlbmRlcmluZyBjb2RlXHJcblx0fSxcclxuXHJcblx0dGlsZURyYXduOiBmdW5jdGlvbiAodGlsZSkge1xyXG5cdFx0dGhpcy5fdGlsZU9uTG9hZC5jYWxsKHRpbGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuTC50aWxlTGF5ZXIuY2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLkNhbnZhcyhvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuSW1hZ2VPdmVybGF5IGlzIHVzZWQgdG8gb3ZlcmxheSBpbWFnZXMgb3ZlciB0aGUgbWFwICh0byBzcGVjaWZpYyBnZW9ncmFwaGljYWwgYm91bmRzKS5cclxuICovXHJcblxyXG5MLkltYWdlT3ZlcmxheSA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG9wYWNpdHk6IDFcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWFwLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblxyXG5cdFx0bWFwLm9uKCd2aWV3cmVzZXQnLCB0aGlzLl9yZXNldCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG1hcC5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgTC5Ccm93c2VyLmFueTNkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmdldFBhbmVzKCkub3ZlcmxheVBhbmUucmVtb3ZlQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cclxuXHRcdG1hcC5vZmYoJ3ZpZXdyZXNldCcsIHRoaXMuX3Jlc2V0LCB0aGlzKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gcmVtb3ZlIGJyaW5nVG9Gcm9udC9icmluZ1RvQmFjayBkdXBsaWNhdGlvbiBmcm9tIFRpbGVMYXllci9QYXRoXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmUgPSB0aGlzLl9tYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHBhbmUuaW5zZXJ0QmVmb3JlKHRoaXMuX2ltYWdlLCBwYW5lLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9pbWFnZS5zcmMgPSB0aGlzLl91cmw7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5faW1hZ2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdpbWcnLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cclxuXHRcdC8vVE9ETyBjcmVhdGVJbWFnZSB1dGlsIG1ldGhvZCB0byByZW1vdmUgZHVwbGljYXRpb25cclxuXHRcdEwuZXh0ZW5kKHRoaXMuX2ltYWdlLCB7XHJcblx0XHRcdGdhbGxlcnlpbWc6ICdubycsXHJcblx0XHRcdG9uc2VsZWN0c3RhcnQ6IEwuVXRpbC5mYWxzZUZuLFxyXG5cdFx0XHRvbm1vdXNlbW92ZTogTC5VdGlsLmZhbHNlRm4sXHJcblx0XHRcdG9ubG9hZDogTC5iaW5kKHRoaXMuX29uSW1hZ2VMb2FkLCB0aGlzKSxcclxuXHRcdFx0c3JjOiB0aGlzLl91cmxcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBudyA9IHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgdG9wTGVmdCA9IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KG53LCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQoc2UsIGUuem9vbSwgZS5jZW50ZXIpLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdCAgICBvcmlnaW4gPSB0b3BMZWZ0Ll9hZGQoc2l6ZS5fbXVsdGlwbHlCeSgoMSAvIDIpICogKDEgLSAxIC8gc2NhbGUpKSk7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPVxyXG5cdFx0ICAgICAgICBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbikgKyAnIHNjYWxlKCcgKyBzY2FsZSArICcpICc7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgICA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIHRvcExlZnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCB0b3BMZWZ0KTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfb25JbWFnZUxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5JY29uIGlzIGFuIGltYWdlLWJhc2VkIGljb24gY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSB3aXRoIEwuTWFya2VyIGZvciBjdXN0b20gbWFya2Vycy5cclxuICovXHJcblxyXG5MLkljb24gPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0LypcclxuXHRcdGljb25Vcmw6IChTdHJpbmcpIChyZXF1aXJlZClcclxuXHRcdGljb25SZXRpbmFVcmw6IChTdHJpbmcpIChvcHRpb25hbCwgdXNlZCBmb3IgcmV0aW5hIGRldmljZXMgaWYgZGV0ZWN0ZWQpXHJcblx0XHRpY29uU2l6ZTogKFBvaW50KSAoY2FuIGJlIHNldCB0aHJvdWdoIENTUylcclxuXHRcdGljb25BbmNob3I6IChQb2ludCkgKGNlbnRlcmVkIGJ5IGRlZmF1bHQsIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucylcclxuXHRcdHBvcHVwQW5jaG9yOiAoUG9pbnQpIChpZiBub3Qgc3BlY2lmaWVkLCBwb3B1cCBvcGVucyBpbiB0aGUgYW5jaG9yIHBvaW50KVxyXG5cdFx0c2hhZG93VXJsOiAoU3RyaW5nKSAobm8gc2hhZG93IGJ5IGRlZmF1bHQpXHJcblx0XHRzaGFkb3dSZXRpbmFVcmw6IChTdHJpbmcpIChvcHRpb25hbCwgdXNlZCBmb3IgcmV0aW5hIGRldmljZXMgaWYgZGV0ZWN0ZWQpXHJcblx0XHRzaGFkb3dTaXplOiAoUG9pbnQpXHJcblx0XHRzaGFkb3dBbmNob3I6IChQb2ludClcclxuXHRcdCovXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWc7XHJcblx0XHRpZiAoIW9sZEljb24gfHwgb2xkSWNvbi50YWdOYW1lICE9PSAnSU1HJykge1xyXG5cdFx0XHRpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIHNpemUgPSBMLnBvaW50KG9wdGlvbnNbbmFtZSArICdTaXplJ10pLFxyXG5cdFx0ICAgIGFuY2hvcjtcclxuXHJcblx0XHRpZiAobmFtZSA9PT0gJ3NoYWRvdycpIHtcclxuXHRcdFx0YW5jaG9yID0gTC5wb2ludChvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YW5jaG9yID0gTC5wb2ludChvcHRpb25zLmljb25BbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghYW5jaG9yICYmIHNpemUpIHtcclxuXHRcdFx0YW5jaG9yID0gc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgb3B0aW9ucy5jbGFzc05hbWU7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0aWYgKEwuQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmljb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JY29uKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcbiAqIEwuSWNvbi5EZWZhdWx0IGlzIHRoZSBibHVlIG1hcmtlciBpY29uIHVzZWQgYnkgZGVmYXVsdCBpbiBMZWFmbGV0LlxuICovXG5cbkwuSWNvbi5EZWZhdWx0ID0gTC5JY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25TaXplOiBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cblx0XHRzaGFkb3dTaXplOiBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBrZXkgPSBuYW1lICsgJ1VybCc7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zW2tleV0pIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcblx0XHR9XG5cblx0XHRpZiAoTC5Ccm93c2VyLnJldGluYSAmJiBuYW1lID09PSAnaWNvbicpIHtcblx0XHRcdG5hbWUgKz0gJy0yeCc7XG5cdFx0fVxuXG5cdFx0dmFyIHBhdGggPSBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGg7XG5cblx0XHRpZiAoIXBhdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBhdXRvZGV0ZWN0IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCwgc2V0IGl0IG1hbnVhbGx5LicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoICsgJy9tYXJrZXItJyArIG5hbWUgKyAnLnBuZyc7XG5cdH1cbn0pO1xuXG5MLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcblx0ICAgIGxlYWZsZXRSZSA9IC9bXFwvXl1sZWFmbGV0W1xcLVxcLl9dPyhbXFx3XFwtXFwuX10qKVxcLmpzXFw/Py87XG5cblx0dmFyIGksIGxlbiwgc3JjLCBtYXRjaGVzLCBwYXRoO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHNjcmlwdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRzcmMgPSBzY3JpcHRzW2ldLnNyYztcblx0XHRtYXRjaGVzID0gc3JjLm1hdGNoKGxlYWZsZXRSZSk7XG5cblx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0cGF0aCA9IHNyYy5zcGxpdChsZWFmbGV0UmUpWzBdO1xuXHRcdFx0cmV0dXJuIChwYXRoID8gcGF0aCArICcvJyA6ICcnKSArICdpbWFnZXMnO1xuXHRcdH1cblx0fVxufSgpKTtcblxuXG4vKlxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGljb246IG5ldyBMLkljb24uRGVmYXVsdCgpLFxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cdFx0YWx0OiAnJyxcclxuXHRcdGNsaWNrYWJsZTogdHJ1ZSxcclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHRcdG9wYWNpdHk6IDEsXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTBcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0bWFwLm9uKCd2aWV3cmVzZXQnLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xyXG5cclxuXHRcdGlmIChtYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgncmVtb3ZlJyk7XHJcblxyXG5cdFx0bWFwLm9mZih7XHJcblx0XHRcdCd2aWV3cmVzZXQnOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0J3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb21cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7IGxhdGxuZzogdGhpcy5fbGF0bG5nIH0pO1xyXG5cdH0sXHJcblxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9zZXRQb3ModGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgYW5pbWF0aW9uID0gKG1hcC5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbiksXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9IGFuaW1hdGlvbiA/ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnIDogJ2xlYWZsZXQtem9vbS1oaWRlJztcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0XHRhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0Lm9uKGljb24sICdtb3VzZW92ZXInLCB0aGlzLl9icmluZ1RvRnJvbnQsIHRoaXMpXHJcblx0XHRcdFx0Lm9uKGljb24sICdtb3VzZW91dCcsIHRoaXMuX3Jlc2V0WkluZGV4LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0XHRhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9tYXAuX3BhbmVzO1xyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHBhbmVzLm1hcmtlclBhbmUuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0cGFuZXMuc2hhZG93UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0ICAgIC5vZmYodGhpcy5faWNvbiwgJ21vdXNlb3ZlcicsIHRoaXMuX2JyaW5nVG9Gcm9udClcclxuXHRcdFx0ICAgIC5vZmYodGhpcy5faWNvbiwgJ21vdXNlb3V0JywgdGhpcy5fcmVzZXRaSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5fcGFuZXMubWFya2VyUGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX21hcC5fcGFuZXMuc2hhZG93UGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFRPRE8gcmVmYWN0b3IgaW50byBzb21ldGhpbmcgc2hhcmVkIHdpdGggTWFwL1BhdGgvZXRjLiB0byBEUlkgaXQgdXBcclxuXHJcblx0XHR2YXIgaWNvbiA9IHRoaXMuX2ljb24sXHJcblx0XHQgICAgZXZlbnRzID0gWydkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cdFx0TC5Eb21FdmVudC5vbihpY29uLCAnY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2ssIHRoaXMpO1xyXG5cdFx0TC5Eb21FdmVudC5vbihpY29uLCAna2V5cHJlc3MnLCB0aGlzLl9vbktleVByZXNzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGljb24sIGV2ZW50c1tpXSwgdGhpcy5fZmlyZU1vdXNlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChMLkhhbmRsZXIuTWFya2VyRHJhZykge1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VDbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciB3YXNEcmFnZ2VkID0gdGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLm1vdmVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcnMoZS50eXBlKSB8fCB3YXNEcmFnZ2VkKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNEcmFnZ2VkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICgoIXRoaXMuZHJhZ2dpbmcgfHwgIXRoaXMuZHJhZ2dpbmcuX2VuYWJsZWQpICYmIHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92ZWQoKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGUsXHJcblx0XHRcdGxhdGxuZzogdGhpcy5fbGF0bG5nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnY2xpY2snLCB7XHJcblx0XHRcdFx0b3JpZ2luYWxFdmVudDogZSxcclxuXHRcdFx0XHRsYXRsbmc6IHRoaXMuX2xhdGxuZ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0dGhpcy5maXJlKGUudHlwZSwge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlLFxyXG5cdFx0XHRsYXRsbmc6IHRoaXMuX2xhdGxuZ1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVE9ETyBwcm9wZXIgY3VzdG9tIGV2ZW50IHByb3BhZ2F0aW9uXHJcblx0XHQvLyB0aGlzIGxpbmUgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGlmIG1hcmtlciBpcyBpbiBhIEZlYXR1cmVHcm91cFxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0aGlzLmhhc0V2ZW50TGlzdGVuZXJzKGUudHlwZSkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLnR5cGUgIT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fc2hhZG93LCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcbiAqIEwuRGl2SWNvbiBpcyBhIGxpZ2h0d2VpZ2h0IEhUTUwtYmFzZWQgaWNvbiBjbGFzcyAoYXMgb3Bwb3NlZCB0byB0aGUgaW1hZ2UtYmFzZWQgTC5JY29uKVxuICogdG8gdXNlIHdpdGggTC5NYXJrZXIuXG4gKi9cblxuTC5EaXZJY29uID0gTC5JY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXHRcdC8qXG5cdFx0aWNvbkFuY2hvcjogKFBvaW50KVxuXHRcdHBvcHVwQW5jaG9yOiAoUG9pbnQpXG5cdFx0aHRtbDogKFN0cmluZylcblx0XHRiZ1BvczogKFBvaW50KVxuXHRcdCovXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbicsXG5cdFx0aHRtbDogZmFsc2Vcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgIT09IGZhbHNlKSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPVxuXHRcdFx0ICAgICAgICAoLW9wdGlvbnMuYmdQb3MueCkgKyAncHggJyArICgtb3B0aW9ucy5iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5EaXZJY29uKG9wdGlvbnMpO1xufTtcblxuXG4vKlxyXG4gKiBMLlBvcHVwIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgcG9wdXBzIG9uIHRoZSBtYXAuXHJcbiAqL1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcbkwuUG9wdXAgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cdFx0Ly8gbWF4SGVpZ2h0OiBudWxsLFxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cdFx0Ly8gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cdFx0Ly8gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHRcdHpvb21BbmltYXRpb246IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0dGhpcy5fYW5pbWF0ZWQgPSBMLkJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblx0XHR0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYW5pbUZhZGUgPSBtYXAub3B0aW9ucy5mYWRlQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmIChhbmltRmFkZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cdFx0bWFwLl9wYW5lcy5wb3B1cFBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRtYXAub24odGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKGFuaW1GYWRlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5maXJlKCdvcGVuJyk7XHJcblxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLl9wYW5lcy5wb3B1cFBhbmUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRMLlV0aWwuZmFsc2VGbih0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgpOyAvLyBmb3JjZSByZWZsb3dcclxuXHJcblx0XHRtYXAub2ZmKHRoaXMuX2dldEV2ZW50cygpLCB0aGlzKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuZmFkZUFuaW1hdGlvbikge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdjbG9zZScpO1xyXG5cclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl96b29tQW5pbWF0aW9uO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCdjbG9zZU9uQ2xpY2snIGluIHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdFx0Y29udGFpbmVyQ2xhc3MgPSBwcmVmaXggKyAnICcgKyB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgJyBsZWFmbGV0LXpvb20tJyArXHJcblx0XHRcdCAgICAgICAgKHRoaXMuX2FuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyksXHJcblx0XHRcdGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNvbnRhaW5lckNsYXNzKSxcclxuXHRcdFx0Y2xvc2VCdXR0b247XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHRjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID1cclxuXHRcdFx0ICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cdFx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNsb3NlQnV0dG9uKTtcclxuXHJcblx0XHRcdEwuRG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID1cclxuXHRcdCAgICAgICAgTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcclxuXHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdEwuRG9tRXZlbnQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRlbnROb2RlLmlubmVySFRNTCA9IHRoaXMuX2NvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAodGhpcy5fY29udGVudE5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0dGhpcy5fY29udGVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGVudE5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fY29udGVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgYW5pbWF0ZWQgPSB0aGlzLl9hbmltYXRlZCxcclxuXHRcdCAgICBvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xyXG5cclxuXHRcdGlmIChhbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSAtIChhbmltYXRlZCA/IDAgOiBwb3MueSk7XHJcblx0XHR0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54ICsgKGFuaW1hdGVkID8gMCA6IHBvcy54KTtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF96b29tQW5pbWF0aW9uOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcik7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBMLlBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRsYXllclBvcy5fYWRkKEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgTC5Qb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHsgLy8gKFBvcHVwKSBvciAoU3RyaW5nIHx8IEhUTUxFbGVtZW50LCBMYXRMbmdbLCBPYmplY3RdKVxyXG5cdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblxyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBMLlBvcHVwKSkge1xyXG5cdFx0XHR2YXIgY29udGVudCA9IHBvcHVwO1xyXG5cclxuXHRcdFx0cG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zKVxyXG5cdFx0XHQgICAgLnNldExhdExuZyhsYXRsbmcpXHJcblx0XHRcdCAgICAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHBvcHVwLl9pc09wZW4gPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHRcdHBvcHVwLl9pc09wZW4gPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBQb3B1cCBleHRlbnNpb24gdG8gTC5NYXJrZXIsIGFkZGluZyBwb3B1cC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwICYmICF0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyh0aGlzLl9sYXRsbmcpO1xyXG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5faXNPcGVuKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIGFuY2hvciA9IEwucG9pbnQodGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvciB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdGFuY2hvciA9IGFuY2hvci5hZGQoTC5Qb3B1cC5wcm90b3R5cGUub3B0aW9ucy5vZmZzZXQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMub2Zmc2V0KSB7XHJcblx0XHRcdGFuY2hvciA9IGFuY2hvci5hZGQob3B0aW9ucy5vZmZzZXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7b2Zmc2V0OiBhbmNob3J9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub24oJ2NsaWNrJywgdGhpcy50b2dnbGVQb3B1cCwgdGhpcylcclxuXHRcdFx0ICAgIC5vbigncmVtb3ZlJywgdGhpcy5jbG9zZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9uKCdtb3ZlJywgdGhpcy5fbW92ZVBvcHVwLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIEwuUG9wdXApIHtcclxuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMsIHRoaXMpXHJcblx0XHRcdFx0LnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZignY2xpY2snLCB0aGlzLnRvZ2dsZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9mZigncmVtb3ZlJywgdGhpcy5jbG9zZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9mZignbW92ZScsIHRoaXMuX21vdmVQb3B1cCwgdGhpcyk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogTC5MYXllckdyb3VwIGlzIGEgY2xhc3MgdG8gY29tYmluZSBzZXZlcmFsIGxheWVycyBpbnRvIG9uZSBzbyB0aGF0XHJcbiAqIHlvdSBjYW4gbWFuaXB1bGF0ZSB0aGUgZ3JvdXAgKGUuZy4gYWRkL3JlbW92ZSBpdCkgYXMgb25lIGxheWVyLlxyXG4gKi9cclxuXHJcbkwuTGF5ZXJHcm91cCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghbGF5ZXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0cmV0dXJuIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2godGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gTC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcbkwubGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTGF5ZXJHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5GZWF0dXJlR3JvdXAgZXh0ZW5kcyBMLkxheWVyR3JvdXAgYnkgaW50cm9kdWNpbmcgbW91c2UgZXZlbnRzIGFuZCBhZGRpdGlvbmFsIG1ldGhvZHNcclxuICogc2hhcmVkIGJldHdlZW4gYSBncm91cCBvZiBpbnRlcmFjdGl2ZSBsYXllcnMgKGxpa2UgdmVjdG9ycyBvciBtYXJrZXJzKS5cclxuICovXHJcblxyXG5MLkZlYXR1cmVHcm91cCA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0RVZFTlRTOiAnY2xpY2sgZGJsY2xpY2sgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBwb3B1cG9wZW4gcG9wdXBjbG9zZSdcclxuXHR9LFxyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCdvbicgaW4gbGF5ZXIpIHtcclxuXHRcdFx0bGF5ZXIub24oTC5GZWF0dXJlR3JvdXAuRVZFTlRTLCB0aGlzLl9wcm9wYWdhdGVFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXBDb250ZW50ICYmIGxheWVyLmJpbmRQb3B1cCkge1xyXG5cdFx0XHRsYXllci5iaW5kUG9wdXAodGhpcy5fcG9wdXBDb250ZW50LCB0aGlzLl9wb3B1cE9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJ29mZicgaW4gbGF5ZXIpIHtcclxuXHRcdFx0bGF5ZXIub2ZmKEwuRmVhdHVyZUdyb3VwLkVWRU5UUywgdGhpcy5fcHJvcGFnYXRlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwQ29udGVudCkge1xyXG5cdFx0XHR0aGlzLmludm9rZSgndW5iaW5kUG9wdXAnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9wb3B1cENvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy5fcG9wdXBPcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYmluZFBvcHVwJywgY29udGVudCwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHQvLyBvcGVuIHBvcHVwIG9uIHRoZSBmaXJzdCBsYXllclxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0ub3BlblBvcHVwKGxhdGxuZyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyID8gbGF5ZXIuZ2V0TGF0TG5nKCkgOiBsYXllci5nZXRCb3VuZHMoKSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzXHJcblx0XHR9LCBlKTtcclxuXHRcdHRoaXMuZmlyZShlLnR5cGUsIGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlBhdGggaXMgYSBiYXNlIGNsYXNzIGZvciByZW5kZXJpbmcgdmVjdG9yIHBhdGhzIG9uIGEgbWFwLiBJbmhlcml0ZWQgYnkgUG9seWxpbmUsIENpcmNsZSwgZXRjLlxyXG4gKi9cclxuXHJcbkwuUGF0aCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogW0wuTWl4aW4uRXZlbnRzXSxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0Ly8gaG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlld1xyXG5cdFx0Ly8gKHJlbGF0aXZlIHRvIGl0cyBzaXplLCBlLmcuIDAuNSBpcyBoYWxmIHRoZSBzY3JlZW4gaW4gZWFjaCBkaXJlY3Rpb24pXHJcblx0XHQvLyBzZXQgaXQgc28gdGhhdCBTVkcgZWxlbWVudCBkb2Vzbid0IGV4Y2VlZCAxMjgwcHggKHZlY3RvcnMgZmxpY2tlciBvbiBkcmFnZW5kIGlmIGl0IGlzKVxyXG5cdFx0Q0xJUF9QQURESU5HOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgbWF4ID0gTC5Ccm93c2VyLm1vYmlsZSA/IDEyODAgOiAyMDAwLFxyXG5cdFx0XHQgICAgdGFyZ2V0ID0gKG1heCAvIE1hdGgubWF4KHdpbmRvdy5vdXRlcldpZHRoLCB3aW5kb3cub3V0ZXJIZWlnaHQpIC0gMSkgLyAyO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMC41LCB0YXJnZXQpKTtcclxuXHRcdH0pKClcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRzdHJva2U6IHRydWUsXHJcblx0XHRjb2xvcjogJyMwMDMzZmYnLFxyXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxyXG5cdFx0bGluZUNhcDogbnVsbCxcclxuXHRcdGxpbmVKb2luOiBudWxsLFxyXG5cdFx0d2VpZ2h0OiA1LFxyXG5cdFx0b3BhY2l0eTogMC41LFxyXG5cclxuXHRcdGZpbGw6IGZhbHNlLFxyXG5cdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxyXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcclxuXHJcblx0XHRjbGlja2FibGU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdEVsZW1lbnRzKCk7XHJcblx0XHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnByb2plY3RMYXRsbmdzKCk7XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9tYXAuX3BhdGhSb290LmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcclxuXHJcblx0XHRtYXAub24oe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5wcm9qZWN0TGF0bG5ncyxcclxuXHRcdFx0J21vdmVlbmQnOiB0aGlzLl91cGRhdGVQYXRoXHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5fcGF0aFJvb3QucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBOZWVkIHRvIGZpcmUgcmVtb3ZlIGV2ZW50IGJlZm9yZSB3ZSBzZXQgX21hcCB0byBudWxsIGFzIHRoZSBldmVudCBob29rcyBtaWdodCBuZWVkIHRoZSBvYmplY3RcclxuXHRcdHRoaXMuZmlyZSgncmVtb3ZlJyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIudm1sKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XHJcblx0XHRcdHRoaXMuX3N0cm9rZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuX2ZpbGwgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hcC5vZmYoe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5wcm9qZWN0TGF0bG5ncyxcclxuXHRcdFx0J21vdmVlbmQnOiB0aGlzLl91cGRhdGVQYXRoXHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZG8gYWxsIHByb2plY3Rpb24gc3R1ZmYgaGVyZVxyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLnByb2plY3RMYXRsbmdzKCk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfdXBkYXRlUGF0aFZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcCA9IEwuUGF0aC5DTElQX1BBRERJTkcsXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHBhbmVQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSksXHJcblx0XHQgICAgbWluID0gcGFuZVBvcy5tdWx0aXBseUJ5KC0xKS5fc3VidHJhY3Qoc2l6ZS5tdWx0aXBseUJ5KHApLl9yb3VuZCgpKSxcclxuXHRcdCAgICBtYXggPSBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpLl9yb3VuZCgpKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoVmlld3BvcnQgPSBuZXcgTC5Cb3VuZHMobWluLCBtYXgpO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBFeHRlbmRzIEwuUGF0aCB3aXRoIFNWRy1zcGVjaWZpYyByZW5kZXJpbmcgY29kZS5cclxuICovXHJcblxyXG5MLlBhdGguU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuXHJcbkwuQnJvd3Nlci5zdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKEwuUGF0aC5TVkdfTlMsICdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbkwuUGF0aCA9IEwuUGF0aC5leHRlbmQoe1xyXG5cdHN0YXRpY3M6IHtcclxuXHRcdFNWRzogTC5Ccm93c2VyLnN2Z1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9tYXAuX3BhdGhSb290LFxyXG5cdFx0ICAgIHBhdGggPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0aWYgKHBhdGggJiYgcm9vdC5sYXN0Q2hpbGQgIT09IHBhdGgpIHtcclxuXHRcdFx0cm9vdC5hcHBlbmRDaGlsZChwYXRoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX21hcC5fcGF0aFJvb3QsXHJcblx0XHQgICAgcGF0aCA9IHRoaXMuX2NvbnRhaW5lcixcclxuXHRcdCAgICBmaXJzdCA9IHJvb3QuZmlyc3RDaGlsZDtcclxuXHJcblx0XHRpZiAocGF0aCAmJiBmaXJzdCAhPT0gcGF0aCkge1xyXG5cdFx0XHRyb290Lmluc2VydEJlZm9yZShwYXRoLCBmaXJzdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBmb3JtIHBhdGggc3RyaW5nIGhlcmVcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoTC5QYXRoLlNWR19OUywgbmFtZSk7XHJcblx0fSxcclxuXHJcblx0X2luaXRFbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLl9pbml0UGF0aFJvb3QoKTtcclxuXHRcdHRoaXMuX2luaXRQYXRoKCk7XHJcblx0XHR0aGlzLl9pbml0U3R5bGUoKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ2cnKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoID0gdGhpcy5fY3JlYXRlRWxlbWVudCgncGF0aCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9wYXRoLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcGF0aCk7XHJcblx0fSxcclxuXHJcblx0X2luaXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsICdyb3VuZCcpO1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZmlsbCkge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCB0aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUgJiYgIXRoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHRoaXMub3B0aW9ucy5jb2xvcik7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMub3B0aW9ucy53ZWlnaHQpO1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRhc2hBcnJheSkge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgdGhpcy5vcHRpb25zLmRhc2hBcnJheSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fcGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmxpbmVDYXApIHtcclxuXHRcdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCB0aGlzLm9wdGlvbnMubGluZUNhcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5saW5lSm9pbikge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCB0aGlzLm9wdGlvbnMubGluZUpvaW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZmlsbCkge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMub3B0aW9ucy5maWxsQ29sb3IgfHwgdGhpcy5vcHRpb25zLmNvbG9yKTtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIHRoaXMub3B0aW9ucy5maWxsT3BhY2l0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzdHIgPSB0aGlzLmdldFBhdGhTdHJpbmcoKTtcclxuXHRcdGlmICghc3RyKSB7XHJcblx0XHRcdC8vIGZpeCB3ZWJraXQgZW1wdHkgc3RyaW5nIHBhcnNpbmcgYnVnXHJcblx0XHRcdHN0ciA9ICdNMCAwJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgc3RyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIHJlbW92ZSBkdXBsaWNhdGlvbiB3aXRoIEwuTWFwXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdGlmIChMLkJyb3dzZXIuc3ZnIHx8ICFMLkJyb3dzZXIudm1sKSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGgsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fb25Nb3VzZUNsaWNrLCB0aGlzKTtcclxuXHJcblx0XHRcdHZhciBldmVudHMgPSBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZW92ZXInLFxyXG5cdFx0XHQgICAgICAgICAgICAgICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92ZWQoKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9maXJlTW91c2VFdmVudChlKTtcclxuXHR9LFxyXG5cclxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAhdGhpcy5oYXNFdmVudExpc3RlbmVycyhlLnR5cGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSksXHJcblx0XHQgICAgbGF5ZXJQb2ludCA9IG1hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCksXHJcblx0XHQgICAgbGF0bG5nID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxyXG5cdFx0XHRjb250YWluZXJQb2ludDogY29udGFpbmVyUG9pbnQsXHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLnR5cGUgIT09ICdtb3VzZW1vdmUnKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3BhdGhSb290KSB7XHJcblx0XHRcdHRoaXMuX3BhdGhSb290ID0gTC5QYXRoLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCgnc3ZnJyk7XHJcblx0XHRcdHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lLmFwcGVuZENoaWxkKHRoaXMuX3BhdGhSb290KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aFJvb3QsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlUGF0aFpvb20sXHJcblx0XHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFBhdGhab29tXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGhSb290LCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVN2Z1ZpZXdwb3J0KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3ZnVmlld3BvcnQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVBhdGhab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoZS5jZW50ZXIpLl9tdWx0aXBseUJ5KC1zY2FsZSkuX2FkZCh0aGlzLl9wYXRoVmlld3BvcnQubWluKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoUm9vdC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9XHJcblx0XHQgICAgICAgIEwuRG9tVXRpbC5nZXRUcmFuc2xhdGVTdHJpbmcob2Zmc2V0KSArICcgc2NhbGUoJyArIHNjYWxlICsgJykgJztcclxuXHJcblx0XHR0aGlzLl9wYXRoWm9vbWluZyA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X2VuZFBhdGhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9wYXRoWm9vbWluZyA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdmdWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9wYXRoWm9vbWluZykge1xyXG5cdFx0XHQvLyBEbyBub3QgdXBkYXRlIFNWR3Mgd2hpbGUgYSB6b29tIGFuaW1hdGlvbiBpcyBnb2luZyBvbiBvdGhlcndpc2UgdGhlIGFuaW1hdGlvbiB3aWxsIGJyZWFrLlxyXG5cdFx0XHQvLyBXaGVuIHRoZSB6b29tIGFuaW1hdGlvbiBlbmRzIHdlIHdpbGwgYmUgdXBkYXRlZCBhZ2FpbiBhbnl3YXlcclxuXHRcdFx0Ly8gVGhpcyBmaXhlcyB0aGUgY2FzZSB3aGVyZSB5b3UgZG8gYSBtb21lbnR1bSBtb3ZlIGFuZCB6b29tIHdoaWxlIHRoZSBtb3ZlIGlzIHN0aWxsIG9uZ29pbmcuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHJcblx0XHR2YXIgdnAgPSB0aGlzLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbWluID0gdnAubWluLFxyXG5cdFx0ICAgIG1heCA9IHZwLm1heCxcclxuXHRcdCAgICB3aWR0aCA9IG1heC54IC0gbWluLngsXHJcblx0XHQgICAgaGVpZ2h0ID0gbWF4LnkgLSBtaW4ueSxcclxuXHRcdCAgICByb290ID0gdGhpcy5fcGF0aFJvb3QsXHJcblx0XHQgICAgcGFuZSA9IHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lO1xyXG5cclxuXHRcdC8vIEhhY2sgdG8gbWFrZSBmbGlja2VyIG9uIGRyYWcgZW5kIG9uIG1vYmlsZSB3ZWJraXQgbGVzcyBpcnJpdGF0aW5nXHJcblx0XHRpZiAoTC5Ccm93c2VyLm1vYmlsZVdlYmtpdCkge1xyXG5cdFx0XHRwYW5lLnJlbW92ZUNoaWxkKHJvb3QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihyb290LCBtaW4pO1xyXG5cdFx0cm9vdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xyXG5cdFx0cm9vdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XHJcblx0XHRyb290LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFttaW4ueCwgbWluLnksIHdpZHRoLCBoZWlnaHRdLmpvaW4oJyAnKSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5tb2JpbGVXZWJraXQpIHtcclxuXHRcdFx0cGFuZS5hcHBlbmRDaGlsZChyb290KTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogUG9wdXAgZXh0ZW5zaW9uIHRvIEwuUGF0aCAocG9seWxpbmVzLCBwb2x5Z29ucywgY2lyY2xlcyksIGFkZGluZyBwb3B1cC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5QYXRoLmluY2x1ZGUoe1xyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBMLlBvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghdGhpcy5fcG9wdXAgfHwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub24oJ2NsaWNrJywgdGhpcy5fb3BlblBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9uKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXAsIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZignY2xpY2snLCB0aGlzLl9vcGVuUG9wdXApXHJcblx0XHRcdCAgICAub2ZmKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXApO1xyXG5cclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgZnJvbSBvbmUgb2YgdGhlIHBhdGgncyBwb2ludHMgaWYgbm90IHNwZWNpZmllZFxyXG5cdFx0XHRsYXRsbmcgPSBsYXRsbmcgfHwgdGhpcy5fbGF0bG5nIHx8XHJcblx0XHRcdCAgICAgICAgIHRoaXMuX2xhdGxuZ3NbTWF0aC5mbG9vcih0aGlzLl9sYXRsbmdzLmxlbmd0aCAvIDIpXTtcclxuXHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cCh7bGF0bG5nOiBsYXRsbmd9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXApO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBWZWN0b3IgcmVuZGVyaW5nIGZvciBJRTYtOCB0aHJvdWdoIFZNTC5cclxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcclxuICovXHJcblxyXG5MLkJyb3dzZXIudm1sID0gIUwuQnJvd3Nlci5zdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0oKSk7XHJcblxyXG5MLlBhdGggPSBMLkJyb3dzZXIuc3ZnIHx8ICFMLkJyb3dzZXIudm1sID8gTC5QYXRoIDogTC5QYXRoLmV4dGVuZCh7XHJcblx0c3RhdGljczoge1xyXG5cdFx0Vk1MOiB0cnVlLFxyXG5cdFx0Q0xJUF9QQURESU5HOiAwLjAyXHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUVsZW1lbnQ6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcclxuXHRcdFx0XHQgICAgICAgICc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KCkpLFxyXG5cclxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdzaGFwZScpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZScgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgOiAnJykpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcclxuXHJcblx0XHR0aGlzLl9wYXRoID0gdGhpcy5fY3JlYXRlRWxlbWVudCgncGF0aCcpO1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3BhdGgpO1xyXG5cclxuXHRcdHRoaXMuX21hcC5fcGF0aFJvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdFN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN0cm9rZSA9IHRoaXMuX3N0cm9rZSxcclxuXHRcdCAgICBmaWxsID0gdGhpcy5fZmlsbCxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHRjb250YWluZXIuc3Ryb2tlZCA9IG9wdGlvbnMuc3Ryb2tlO1xyXG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9IG9wdGlvbnMuZmlsbDtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0aWYgKCFzdHJva2UpIHtcclxuXHRcdFx0XHRzdHJva2UgPSB0aGlzLl9zdHJva2UgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdzdHJva2UnKTtcclxuXHRcdFx0XHRzdHJva2UuZW5kY2FwID0gJ3JvdW5kJztcclxuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xyXG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBMLlV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xyXG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxyXG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmxpbmVDYXApIHtcclxuXHRcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmxpbmVKb2luKSB7XHJcblx0XHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xyXG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcclxuXHRcdFx0dGhpcy5fc3Ryb2tlID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdGlmICghZmlsbCkge1xyXG5cdFx0XHRcdGZpbGwgPSB0aGlzLl9maWxsID0gdGhpcy5fY3JlYXRlRWxlbWVudCgnZmlsbCcpO1xyXG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcclxuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcclxuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xyXG5cdFx0XHR0aGlzLl9maWxsID0gbnVsbDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblx0XHR0aGlzLl9wYXRoLnYgPSB0aGlzLmdldFBhdGhTdHJpbmcoKSArICcgJzsgLy8gdGhlIHNwYWNlIGZpeGVzIElFIGVtcHR5IHBhdGggc3RyaW5nIGJ1Z1xyXG5cdFx0c3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKEwuQnJvd3Nlci5zdmcgfHwgIUwuQnJvd3Nlci52bWwgPyB7fSA6IHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcGF0aFJvb3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9wYXRoUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cm9vdC5jbGFzc05hbWUgPSAnbGVhZmxldC12bWwtY29udGFpbmVyJztcclxuXHRcdHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lLmFwcGVuZENoaWxkKHJvb3QpO1xyXG5cclxuXHRcdHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUGF0aFZpZXdwb3J0KCk7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIFZlY3RvciByZW5kZXJpbmcgZm9yIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgY2FudmFzLlxyXG4gKi9cclxuXHJcbkwuQnJvd3Nlci5jYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG5MLlBhdGggPSAoTC5QYXRoLlNWRyAmJiAhd2luZG93LkxfUFJFRkVSX0NBTlZBUykgfHwgIUwuQnJvd3Nlci5jYW52YXMgPyBMLlBhdGggOiBMLlBhdGguZXh0ZW5kKHtcclxuXHRzdGF0aWNzOiB7XHJcblx0XHQvL0NMSVBfUEFERElORzogMC4wMiwgLy8gbm90IHN1cmUgaWYgdGhlcmUncyBhIG5lZWQgdG8gc2V0IGl0IHRvIGEgc21hbGwgdmFsdWVcclxuXHRcdENBTlZBUzogdHJ1ZSxcclxuXHRcdFNWRzogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHRcdFx0dGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5vZmYoJ3ZpZXdyZXNldCcsIHRoaXMucHJvamVjdExhdGxuZ3MsIHRoaXMpXHJcblx0XHQgICAgLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVBhdGgsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblx0XHRcclxuXHRcdHRoaXMuZmlyZSgncmVtb3ZlJyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZXF1ZXN0VXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICFMLlBhdGguX3VwZGF0ZVJlcXVlc3QpIHtcclxuXHRcdFx0TC5QYXRoLl91cGRhdGVSZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fZmlyZU1hcE1vdmVFbmQsIHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpcmVNYXBNb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlBhdGguX3VwZGF0ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRFbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLl9pbml0UGF0aFJvb3QoKTtcclxuXHRcdHRoaXMuX2N0eCA9IHRoaXMuX21hcC5fY2FudmFzQ3R4O1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcclxuXHRcdFx0dGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubGluZUNhcCkge1xyXG5cdFx0XHR0aGlzLl9jdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLmxpbmVKb2luKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYXdQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgaiwgbGVuLCBsZW4yLCBwb2ludCwgZHJhd01ldGhvZDtcclxuXHJcblx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHRoaXMuX3BhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xyXG5cdFx0XHRcdHBvaW50ID0gdGhpcy5fcGFydHNbaV1bal07XHJcblx0XHRcdFx0ZHJhd01ldGhvZCA9IChqID09PSAwID8gJ21vdmUnIDogJ2xpbmUnKSArICdUbyc7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N0eFtkcmF3TWV0aG9kXShwb2ludC54LCBwb2ludC55KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBUT0RPIHJlZmFjdG9yIHVnbHkgaGFja1xyXG5cdFx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIEwuUG9seWdvbikge1xyXG5cdFx0XHRcdHRoaXMuX2N0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fcGFydHMubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fY2hlY2tJZkVtcHR5KCkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGN0eCA9IHRoaXMuX2N0eCxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX2RyYXdQYXRoKCk7XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XHJcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xyXG5cdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2sgZGJsY2xpY2sgY29udGV4dG1lbnUnLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpcmVNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zUG9pbnQoZS5sYXllclBvaW50KSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoZS50eXBlLCBlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gVE9ETyBkb24ndCBkbyBvbiBlYWNoIG1vdmVcclxuXHRcdGlmICh0aGlzLl9jb250YWluc1BvaW50KGUubGF5ZXJQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcblx0XHRcdHRoaXMuX21vdXNlSW5zaWRlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3VzZW92ZXInLCBlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuX21vdXNlSW5zaWRlKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJyc7XHJcblx0XHRcdHRoaXMuX21vdXNlSW5zaWRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW91c2VvdXQnLCBlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuaW5jbHVkZSgoTC5QYXRoLlNWRyAmJiAhd2luZG93LkxfUFJFRkVSX0NBTlZBUykgfHwgIUwuQnJvd3Nlci5jYW52YXMgPyB7fSA6IHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX3BhdGhSb290LFxyXG5cdFx0ICAgIGN0eDtcclxuXHJcblx0XHRpZiAoIXJvb3QpIHtcclxuXHRcdFx0cm9vdCA9IHRoaXMuX3BhdGhSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdHJvb3Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRjdHggPSB0aGlzLl9jYW52YXNDdHggPSByb290LmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0XHRjdHgubGluZUNhcCA9ICdyb3VuZCc7XHJcblx0XHRcdGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZChyb290KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGhSb290LmNsYXNzTmFtZSA9ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnO1xyXG5cdFx0XHRcdHRoaXMub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVBhdGhab29tKTtcclxuXHRcdFx0XHR0aGlzLm9uKCd6b29tZW5kJywgdGhpcy5fZW5kUGF0aFpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVDYW52YXNWaWV3cG9ydCk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZUNhbnZhc1ZpZXdwb3J0KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNhbnZhc1ZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBkb24ndCByZWRyYXcgd2hpbGUgem9vbWluZy4gU2VlIF91cGRhdGVTdmdWaWV3cG9ydCBmb3IgbW9yZSBkZXRhaWxzXHJcblx0XHRpZiAodGhpcy5fcGF0aFpvb21pbmcpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHJcblx0XHR2YXIgdnAgPSB0aGlzLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbWluID0gdnAubWluLFxyXG5cdFx0ICAgIHNpemUgPSB2cC5tYXguc3VidHJhY3QobWluKSxcclxuXHRcdCAgICByb290ID0gdGhpcy5fcGF0aFJvb3Q7XHJcblxyXG5cdFx0Ly9UT0RPIGNoZWNrIGlmIHRoaXMgd29ya3MgcHJvcGVybHkgb24gbW9iaWxlIHdlYmtpdFxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHJvb3QsIG1pbik7XHJcblx0XHRyb290LndpZHRoID0gc2l6ZS54O1xyXG5cdFx0cm9vdC5oZWlnaHQgPSBzaXplLnk7XHJcblx0XHRyb290LmdldENvbnRleHQoJzJkJykudHJhbnNsYXRlKC1taW4ueCwgLW1pbi55KTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogTC5MaW5lVXRpbCBjb250YWlucyBkaWZmZXJlbnQgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxpbmUgc2VnbWVudHNcclxuICogYW5kIHBvbHlsaW5lcyAoY2xpcHBpbmcsIHNpbXBsaWZpY2F0aW9uLCBkaXN0YW5jZXMsIGV0Yy4pXHJcbiAqL1xyXG5cclxuLypqc2hpbnQgYml0d2lzZTpmYWxzZSAqLyAvLyBhbGxvdyBiaXR3aXNlIG9wZXJhdGlvbnMgZm9yIHRoaXMgZmlsZVxyXG5cclxuTC5MaW5lVXRpbCA9IHtcclxuXHJcblx0Ly8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcblx0Ly8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcblx0c2ltcGxpZnk6IGZ1bmN0aW9uICgvKlBvaW50W10qLyBwb2ludHMsIC8qTnVtYmVyKi8gdG9sZXJhbmNlKSB7XHJcblx0XHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHRcdC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50IGJldHdlZW4gdHdvIHBvaW50c1xyXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6ICBmdW5jdGlvbiAoLypQb2ludCovIHAsIC8qUG9pbnQqLyBwMSwgLypQb2ludCovIHAyKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcblx0fSxcclxuXHJcblx0Ly8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcblx0X3NpbXBsaWZ5RFA6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0XHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHRcdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0XHRtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdFx0dmFyIGksXHJcblx0XHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdQb2ludHM7XHJcblx0fSxcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwOiBmdW5jdGlvbiAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0XHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRcdCAgICBpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRcdHNxRGlzdCA9IHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcblx0X3JlZHVjZVBvaW50czogZnVuY3Rpb24gKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHRcdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRcdHByZXYgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBDb2hlbi1TdXRoZXJsYW5kIGxpbmUgY2xpcHBpbmcgYWxnb3JpdGhtLlxyXG5cdC8vIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWxpbmUgdGhhdCBhcmUgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG5cclxuXHRjbGlwU2VnbWVudDogZnVuY3Rpb24gKGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUpIHtcclxuXHRcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gdGhpcy5fbGFzdENvZGUgOiB0aGlzLl9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0XHQgICAgY29kZUIgPSB0aGlzLl9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdFx0Ly8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0XHR0aGlzLl9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0XHRcdHAgPSB0aGlzLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcyk7XHJcblx0XHRcdFx0bmV3Q29kZSA9IHRoaXMuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdFx0XHRhID0gcDtcclxuXHRcdFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YiA9IHA7XHJcblx0XHRcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEVkZ2VJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChhLCBiLCBjb2RlLCBib3VuZHMpIHtcclxuXHRcdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHRcdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXg7XHJcblxyXG5cdFx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHksIG1heC55KTtcclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2ludChhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeSwgbWluLnkpO1xyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobWF4LngsIGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4KTtcclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobWluLngsIGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0Qml0Q29kZTogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCBib3VuZHMpIHtcclxuXHRcdHZhciBjb2RlID0gMDtcclxuXHJcblx0XHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdFx0Y29kZSB8PSAxO1xyXG5cdFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdFx0Y29kZSB8PSAyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdFx0Y29kZSB8PSA0O1xyXG5cdFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRcdGNvZGUgfD0gODtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29kZTtcclxuXHR9LFxyXG5cclxuXHQvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocDEsIHAyKSB7XHJcblx0XHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5cdF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0XHR2YXIgeCA9IHAxLngsXHJcblx0XHQgICAgeSA9IHAxLnksXHJcblx0XHQgICAgZHggPSBwMi54IC0geCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdFx0ICAgIHQ7XHJcblxyXG5cdFx0aWYgKGRvdCA+IDApIHtcclxuXHRcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHRcdHkgPSBwMi55O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRkeCA9IHAueCAtIHg7XHJcblx0XHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fVxyXG59O1xyXG5cblxuLypcclxuICogTC5Qb2x5bGluZSBpcyB1c2VkIHRvIGRpc3BsYXkgcG9seWxpbmVzIG9uIGEgbWFwLlxyXG4gKi9cclxuXHJcbkwuUG9seWxpbmUgPSBMLlBhdGguZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIGhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWxcclxuXHRcdC8vIG1vcmUgPSBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGxlc3MgPSBtb3JlIGFjY3VyYXRlXHJcblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcclxuXHRcdG5vQ2xpcDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fb3JpZ2luYWxQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9vcmlnaW5hbFBvaW50c1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UGF0aFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aCwgc3RyID0gJyc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRzdHIgKz0gdGhpcy5fZ2V0UGF0aFBhcnRTdHIodGhpcy5fcGFydHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmdzLnB1c2goTC5sYXRMbmcobGF0bG5nKSk7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcclxuXHR9LFxyXG5cclxuXHRzcGxpY2VMYXRMbmdzOiBmdW5jdGlvbiAoKSB7IC8vIChOdW1iZXIgaW5kZXgsIE51bWJlciBob3dNYW55KVxyXG5cdFx0dmFyIHJlbW92ZWQgPSBbXS5zcGxpY2UuYXBwbHkodGhpcy5fbGF0bG5ncywgYXJndW1lbnRzKTtcclxuXHRcdHRoaXMuX2NvbnZlcnRMYXRMbmdzKHRoaXMuX2xhdGxuZ3MsIHRydWUpO1xyXG5cdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdHJldHVybiByZW1vdmVkO1xyXG5cdH0sXHJcblxyXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xyXG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksIHBhcnRzID0gdGhpcy5fcGFydHMsIHAxLCBwMiwgbWluUG9pbnQgPSBudWxsO1xyXG5cclxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XHJcblx0XHRcdHZhciBwb2ludHMgPSBwYXJ0c1tqXTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcclxuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcclxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKTtcclxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcclxuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xyXG5cdFx0XHRcdFx0bWluUG9pbnQgPSBMLkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG1pblBvaW50KSB7XHJcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtaW5Qb2ludDtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHModGhpcy5nZXRMYXRMbmdzKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIG92ZXJ3cml0ZSkge1xyXG5cdFx0dmFyIGksIGxlbiwgdGFyZ2V0ID0gb3ZlcndyaXRlID8gbGF0bG5ncyA6IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKEwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbaV0pICYmIHR5cGVvZiBsYXRsbmdzW2ldWzBdICE9PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0YXJnZXRbaV0gPSBMLmxhdExuZyhsYXRsbmdzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuUGF0aC5wcm90b3R5cGUuX2luaXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UGF0aFBhcnRTdHI6IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuXHRcdHZhciByb3VuZCA9IEwuUGF0aC5WTUw7XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoLCBzdHIgPSAnJywgcDsgaiA8IGxlbjI7IGorKykge1xyXG5cdFx0XHRwID0gcG9pbnRzW2pdO1xyXG5cdFx0XHRpZiAocm91bmQpIHtcclxuXHRcdFx0XHRwLl9yb3VuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH0sXHJcblxyXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXHJcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHRcdCAgICBpLCBrLCBzZWdtZW50O1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XHJcblx0XHRcdHRoaXMuX3BhcnRzID0gW3BvaW50c107XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xyXG5cclxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxyXG5cdFx0ICAgIHZwID0gdGhpcy5fbWFwLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbHUgPSBMLkxpbmVVdGlsO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGsgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcblx0XHRcdHNlZ21lbnQgPSBsdS5jbGlwU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIHZwLCBpKTtcclxuXHRcdFx0aWYgKCFzZWdtZW50KSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XHJcblx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XHJcblxyXG5cdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XHJcblx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2kgKyAxXSkgfHwgKGkgPT09IGxlbiAtIDIpKSB7XHJcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcclxuXHRcdFx0XHRrKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmVcclxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxyXG5cdFx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cGFydHNbaV0gPSBsdS5zaW1wbGlmeShwYXJ0c1tpXSwgdGhpcy5vcHRpb25zLnNtb290aEZhY3Rvcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcclxuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XHJcblxyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5fdXBkYXRlUGF0aC5jYWxsKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlBvbHlVdGlsIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29ucyAoY2xpcHBpbmcsIGV0Yy4pLlxyXG4gKi9cclxuXHJcbi8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi8gLy8gYWxsb3cgYml0d2lzZSBvcGVyYXRpb25zIGhlcmVcclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qXHJcbiAqIFN1dGhlcmxhbmQtSG9kZ2VtYW4gcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG0uXHJcbiAqIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWdvbiB0aGF0IGFyZSBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAqL1xyXG5MLlBvbHlVdGlsLmNsaXBQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgYm91bmRzKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHAsXHJcblx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlBvbHlnb24gaXMgdXNlZCB0byBkaXNwbGF5IHBvbHlnb25zIG9uIGEgbWFwLlxyXG4gKi9cclxuXHJcbkwuUG9seWdvbiA9IEwuUG9seWxpbmUuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRmaWxsOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdEwuUG9seWxpbmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBsYXRsbmdzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2luaXRXaXRoSG9sZXMobGF0bG5ncyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRXaXRoSG9sZXM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XHJcblx0XHR2YXIgaSwgbGVuLCBob2xlO1xyXG5cdFx0aWYgKGxhdGxuZ3MgJiYgTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgJiYgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnbnVtYmVyJykpIHtcclxuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbMF0pO1xyXG5cdFx0XHR0aGlzLl9ob2xlcyA9IGxhdGxuZ3Muc2xpY2UoMSk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9ob2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGhvbGUgPSB0aGlzLl9ob2xlc1tpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKHRoaXMuX2hvbGVzW2ldKTtcclxuXHRcdFx0XHRpZiAoaG9sZVswXS5lcXVhbHMoaG9sZVtob2xlLmxlbmd0aCAtIDFdKSkge1xyXG5cdFx0XHRcdFx0aG9sZS5wb3AoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgb3V0IGxhc3QgcG9pbnQgaWYgaXRzIGVxdWFsIHRvIHRoZSBmaXJzdCBvbmVcclxuXHRcdGxhdGxuZ3MgPSB0aGlzLl9sYXRsbmdzO1xyXG5cclxuXHRcdGlmIChsYXRsbmdzLmxlbmd0aCA+PSAyICYmIGxhdGxuZ3NbMF0uZXF1YWxzKGxhdGxuZ3NbbGF0bG5ncy5sZW5ndGggLSAxXSkpIHtcclxuXHRcdFx0bGF0bG5ncy5wb3AoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Qb2x5bGluZS5wcm90b3R5cGUucHJvamVjdExhdGxuZ3MuY2FsbCh0aGlzKTtcclxuXHJcblx0XHQvLyBwcm9qZWN0IHBvbHlnb24gaG9sZXMgcG9pbnRzXHJcblx0XHQvLyBUT0RPIG1vdmUgdGhpcyBsb2dpYyB0byBQb2x5bGluZSB0byBnZXQgcmlkIG9mIGR1cGxpY2F0aW9uXHJcblx0XHR0aGlzLl9ob2xlUG9pbnRzID0gW107XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ob2xlcykgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgaSwgaiwgbGVuLCBsZW4yO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hvbGVQb2ludHNbaV0gPSBbXTtcclxuXHJcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSB0aGlzLl9ob2xlc1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcclxuXHRcdFx0XHR0aGlzLl9ob2xlUG9pbnRzW2ldW2pdID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ob2xlc1tpXVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0aWYgKGxhdGxuZ3MgJiYgTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgJiYgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnbnVtYmVyJykpIHtcclxuXHRcdFx0dGhpcy5faW5pdFdpdGhIb2xlcyhsYXRsbmdzKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gTC5Qb2x5bGluZS5wcm90b3R5cGUuc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXHJcblx0XHQgICAgbmV3UGFydHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9wYXJ0cyA9IFtwb2ludHNdLmNvbmNhdCh0aGlzLl9ob2xlUG9pbnRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGNsaXBwZWQgPSBMLlBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3BhcnRzW2ldLCB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCk7XHJcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xyXG5cdFx0XHRcdG5ld1BhcnRzLnB1c2goY2xpcHBlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wYXJ0cyA9IG5ld1BhcnRzO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQYXRoUGFydFN0cjogZnVuY3Rpb24gKHBvaW50cykge1xyXG5cdFx0dmFyIHN0ciA9IEwuUG9seWxpbmUucHJvdG90eXBlLl9nZXRQYXRoUGFydFN0ci5jYWxsKHRoaXMsIHBvaW50cyk7XHJcblx0XHRyZXR1cm4gc3RyICsgKEwuQnJvd3Nlci5zdmcgPyAneicgOiAneCcpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnBvbHlnb24gPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogQ29udGFpbnMgTC5NdWx0aVBvbHlsaW5lIGFuZCBMLk11bHRpUG9seWdvbiBsYXllcnMuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBjcmVhdGVNdWx0aShLbGFzcykge1xyXG5cclxuXHRcdHJldHVybiBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdFx0XHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdFx0XHR0aGlzLnNldExhdExuZ3MobGF0bG5ncyk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0XHRcdHZhciBpID0gMCxcclxuXHRcdFx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKGkgPCBsZW4pIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXIuc2V0TGF0TG5ncyhsYXRsbmdzW2krK10pO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHdoaWxlIChpIDwgbGVuKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZExheWVyKG5ldyBLbGFzcyhsYXRsbmdzW2krK10sIHRoaXMuX29wdGlvbnMpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdFx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRcdFx0bGF0bG5ncy5wdXNoKGxheWVyLmdldExhdExuZ3MoKSk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBsYXRsbmdzO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdEwuTXVsdGlQb2x5bGluZSA9IGNyZWF0ZU11bHRpKEwuUG9seWxpbmUpO1xyXG5cdEwuTXVsdGlQb2x5Z29uID0gY3JlYXRlTXVsdGkoTC5Qb2x5Z29uKTtcclxuXHJcblx0TC5tdWx0aVBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5NdWx0aVBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cdEwubXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5NdWx0aVBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblx0fTtcclxufSgpKTtcclxuXG5cbi8qXHJcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXHJcbiAqL1xyXG5cclxuTC5SZWN0YW5nbGUgPSBMLlBvbHlnb24uZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XHJcblx0XHR0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcclxuXHRcdGxhdExuZ0JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcclxuXHRcdF07XHJcblx0fVxyXG59KTtcclxuXHJcbkwucmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5SZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQ2lyY2xlIGlzIGEgY2lyY2xlIG92ZXJsYXkgKHdpdGggYSBjZXJ0YWluIHJhZGl1cyBpbiBtZXRlcnMpLlxyXG4gKi9cclxuXHJcbkwuQ2lyY2xlID0gTC5QYXRoLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBhdGgucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRmaWxsOiB0cnVlXHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XHJcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsbmdSYWRpdXMgPSB0aGlzLl9nZXRMbmdSYWRpdXMoKSxcclxuXHRcdCAgICBsYXRsbmcgPSB0aGlzLl9sYXRsbmcsXHJcblx0XHQgICAgcG9pbnRMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZyAtIGxuZ1JhZGl1c10pO1xyXG5cclxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpO1xyXG5cdFx0dGhpcy5fcmFkaXVzID0gTWF0aC5tYXgodGhpcy5fcG9pbnQueCAtIHBvaW50TGVmdC54LCAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsbmdSYWRpdXMgPSB0aGlzLl9nZXRMbmdSYWRpdXMoKSxcclxuXHRcdCAgICBsYXRSYWRpdXMgPSAodGhpcy5fbVJhZGl1cyAvIDQwMDc1MDE3KSAqIDM2MCxcclxuXHRcdCAgICBsYXRsbmcgPSB0aGlzLl9sYXRsbmc7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW2xhdGxuZy5sYXQgLSBsYXRSYWRpdXMsIGxhdGxuZy5sbmcgLSBsbmdSYWRpdXNdLFxyXG5cdFx0ICAgICAgICBbbGF0bG5nLmxhdCArIGxhdFJhZGl1cywgbGF0bG5nLmxuZyArIGxuZ1JhZGl1c10pO1xyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcCA9IHRoaXMuX3BvaW50LFxyXG5cdFx0ICAgIHIgPSB0aGlzLl9yYWRpdXM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NoZWNrSWZFbXB0eSgpKSB7XHJcblx0XHRcdHJldHVybiAnJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnN2Zykge1xyXG5cdFx0XHRyZXR1cm4gJ00nICsgcC54ICsgJywnICsgKHAueSAtIHIpICtcclxuXHRcdFx0ICAgICAgICdBJyArIHIgKyAnLCcgKyByICsgJywwLDEsMSwnICtcclxuXHRcdFx0ICAgICAgIChwLnggLSAwLjEpICsgJywnICsgKHAueSAtIHIpICsgJyB6JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHAuX3JvdW5kKCk7XHJcblx0XHRcdHIgPSBNYXRoLnJvdW5kKHIpO1xyXG5cdFx0XHRyZXR1cm4gJ0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgciArICcgMCwnICsgKDY1NTM1ICogMzYwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gRWFydGggaGFyZGNvZGVkLCBtb3ZlIGludG8gcHJvamVjdGlvbiBjb2RlIVxyXG5cclxuXHRfZ2V0TGF0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21SYWRpdXMgLyA0MDA3NTAxNykgKiAzNjA7XHJcblx0fSxcclxuXHJcblx0X2dldExuZ1JhZGl1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldExhdFJhZGl1cygpIC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIHRoaXMuX2xhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHZhciB2cCA9IHRoaXMuX21hcC5fcGF0aFZpZXdwb3J0LFxyXG5cdFx0ICAgIHIgPSB0aGlzLl9yYWRpdXMsXHJcblx0XHQgICAgcCA9IHRoaXMuX3BvaW50O1xyXG5cclxuXHRcdHJldHVybiBwLnggLSByID4gdnAubWF4LnggfHwgcC55IC0gciA+IHZwLm1heC55IHx8XHJcblx0XHQgICAgICAgcC54ICsgciA8IHZwLm1pbi54IHx8IHAueSArIHIgPCB2cC5taW4ueTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jaXJjbGUgPSBmdW5jdGlvbiAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQ2lyY2xlTWFya2VyIGlzIGEgY2lyY2xlIG92ZXJsYXkgd2l0aCBhIHBlcm1hbmVudCBwaXhlbCByYWRpdXMuXHJcbiAqL1xyXG5cclxuTC5DaXJjbGVNYXJrZXIgPSBMLkNpcmNsZS5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHJhZGl1czogMTAsXHJcblx0XHR3ZWlnaHQ6IDJcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLkNpcmNsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGxhdGxuZywgbnVsbCwgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlU3R5bGUgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkNpcmNsZS5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLnNldFJhZGl1cyh0aGlzLm9wdGlvbnMucmFkaXVzKTtcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdEwuQ2lyY2xlLnByb3RvdHlwZS5zZXRMYXRMbmcuY2FsbCh0aGlzLCBsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLl9pc09wZW4pIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY2lyY2xlTWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5DaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEV4dGVuZHMgTC5Qb2x5bGluZSB0byBiZSBhYmxlIHRvIG1hbnVhbGx5IGRldGVjdCBjbGlja3Mgb24gQ2FudmFzLXJlbmRlcmVkIHBvbHlsaW5lcy5cclxuICovXHJcblxyXG5MLlBvbHlsaW5lLmluY2x1ZGUoIUwuUGF0aC5DQU5WQVMgPyB7fSA6IHtcclxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xyXG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgZGlzdCwgcGFydCxcclxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCAvIDI7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHR3ICs9IDEwOyAvLyBwb2x5bGluZSBjbGljayB0b2xlcmFuY2Ugb24gdG91Y2ggZGV2aWNlc1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcclxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XHJcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRpc3QgPSBMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSk7XHJcblxyXG5cdFx0XHRcdGlmIChkaXN0IDw9IHcpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBFeHRlbmRzIEwuUG9seWdvbiB0byBiZSBhYmxlIHRvIG1hbnVhbGx5IGRldGVjdCBjbGlja3Mgb24gQ2FudmFzLXJlbmRlcmVkIHBvbHlnb25zLlxyXG4gKi9cclxuXHJcbkwuUG9seWdvbi5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XHJcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XHJcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXHJcblx0XHQgICAgcGFydCwgcDEsIHAyLFxyXG5cdFx0ICAgIGksIGosIGssXHJcblx0XHQgICAgbGVuLCBsZW4yO1xyXG5cclxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiBjaGVjayBpZiB3aXRoaW4gYm91bmRzIGZpcnN0XHJcblxyXG5cdFx0aWYgKEwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSkpIHtcclxuXHRcdFx0Ly8gY2xpY2sgb24gcG9seWdvbiBib3JkZXJcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcclxuXHJcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xyXG5cdFx0XHRcdHAxID0gcGFydFtqXTtcclxuXHRcdFx0XHRwMiA9IHBhcnRba107XHJcblxyXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmXHJcblx0XHRcdFx0XHRcdChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XHJcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnNpZGU7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIEV4dGVuZHMgTC5DaXJjbGUgd2l0aCBDYW52YXMtc3BlY2lmaWMgY29kZS5cclxuICovXHJcblxyXG5MLkNpcmNsZS5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XHJcblx0X2RyYXdQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcCA9IHRoaXMuX3BvaW50O1xyXG5cdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0dGhpcy5fY3R4LmFyYyhwLngsIHAueSwgdGhpcy5fcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuX3BvaW50LFxyXG5cdFx0ICAgIHcyID0gdGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMDtcclxuXHJcblx0XHRyZXR1cm4gKHAuZGlzdGFuY2VUbyhjZW50ZXIpIDw9IHRoaXMuX3JhZGl1cyArIHcyKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcbiAqIENpcmNsZU1hcmtlciBjYW52YXMgc3BlY2lmaWMgZHJhd2luZyBwYXJ0cy5cbiAqL1xuXG5MLkNpcmNsZU1hcmtlci5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuUGF0aC5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlLmNhbGwodGhpcyk7XG5cdH1cbn0pO1xuXG5cbi8qXHJcbiAqIEwuR2VvSlNPTiB0dXJucyBhbnkgR2VvSlNPTiBkYXRhIGludG8gYSBMZWFmbGV0IGxheWVyLlxyXG4gKi9cclxuXHJcbkwuR2VvSlNPTiA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBMLlV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBPbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmVzW2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMucG9pbnRUb0xheWVyLCBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nLCBvcHRpb25zKTtcclxuXHRcdGxheWVyLmZlYXR1cmUgPSBMLkdlb0pTT04uYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBzdHlsZSA9IHRoaXMub3B0aW9ucy5zdHlsZTtcclxuXHRcdGlmIChzdHlsZSkge1xyXG5cdFx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0XHRMLlV0aWwuZXh0ZW5kKGxheWVyLm9wdGlvbnMsIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdH1cclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuZXh0ZW5kKEwuR2VvSlNPTiwge1xyXG5cdGdlb21ldHJ5VG9MYXllcjogZnVuY3Rpb24gKGdlb2pzb24sIHBvaW50VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIHZlY3Rvck9wdGlvbnMpIHtcclxuXHRcdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0XHQgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXHJcblx0XHQgICAgbGF5ZXJzID0gW10sXHJcblx0XHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdFx0Y29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nO1xyXG5cclxuXHRcdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdFx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKTtcclxuXHJcblx0XHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0XHRsYXllcnMucHVzaChwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIDAsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ1BvbHlnb24nOlxyXG5cdFx0XHRpZiAoY29vcmRzLmxlbmd0aCA9PT0gMiAmJiAhY29vcmRzWzFdLmxlbmd0aCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIDEsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWxpbmUobGF0bG5ncywgdmVjdG9yT3B0aW9ucyk7XHJcblxyXG5cdFx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdFx0bGF0bG5ncyA9IHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgMiwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuTXVsdGlQb2x5Z29uKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcblx0XHRcdFx0bGF5ZXJzLnB1c2godGhpcy5nZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0XHR9LCBwb2ludFRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCB2ZWN0b3JPcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjb29yZHNUb0xhdExuZzogZnVuY3Rpb24gKGNvb3JkcykgeyAvLyAoQXJyYXlbLCBCb29sZWFuXSkgLT4gTGF0TG5nXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG5cdH0sXHJcblxyXG5cdGNvb3Jkc1RvTGF0TG5nczogZnVuY3Rpb24gKGNvb3JkcywgbGV2ZWxzRGVlcCwgY29vcmRzVG9MYXRMbmcpIHsgLy8gKEFycmF5WywgTnVtYmVyLCBGdW5jdGlvbl0pIC0+IEFycmF5XHJcblx0XHR2YXIgbGF0bG5nLCBpLCBsZW4sXHJcblx0XHQgICAgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0ICAgICAgICB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBjb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQgICAgICAgIChjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9Db29yZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF07XHJcblxyXG5cdFx0aWYgKGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXRsbmcuYWx0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nc1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0TG5ncykge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRMbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKEwuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyhsYXRMbmdzW2ldKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9LFxyXG5cclxuXHRnZXRGZWF0dXJlOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/IEwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOiBMLkdlb0pTT04uYXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxuXHR9LFxyXG5cclxuXHRhc0ZlYXR1cmU6IGZ1bmN0aW9uIChnZW9KU09OKSB7XHJcblx0XHRpZiAoZ2VvSlNPTi50eXBlID09PSAnRmVhdHVyZScpIHtcclxuXHRcdFx0cmV0dXJuIGdlb0pTT047XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdFx0Z2VvbWV0cnk6IGdlb0pTT05cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBMLkdlb0pTT04ubGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5MLkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuTC5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5MLlBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLmdldExhdExuZ3MoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLlBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW0wuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5nZXRMYXRMbmdzKCkpXSxcclxuXHRcdCAgICBpLCBsZW4sIGhvbGU7XHJcblxyXG5cdFx0Y29vcmRzWzBdLnB1c2goY29vcmRzWzBdWzBdKTtcclxuXHJcblx0XHRpZiAodGhpcy5faG9sZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5faG9sZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRob2xlID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9ob2xlc1tpXSk7XHJcblx0XHRcdFx0aG9sZS5wdXNoKGhvbGVbMF0pO1xyXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKGhvbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBtdWx0aVRvR2VvSlNPTih0eXBlKSB7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04oKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0TC5NdWx0aVBvbHlsaW5lLmluY2x1ZGUoe3RvR2VvSlNPTjogbXVsdGlUb0dlb0pTT04oJ011bHRpTGluZVN0cmluZycpfSk7XHJcblx0TC5NdWx0aVBvbHlnb24uaW5jbHVkZSh7dG9HZW9KU09OOiBtdWx0aVRvR2VvSlNPTignTXVsdGlQb2x5Z29uJyl9KTtcclxuXHJcblx0TC5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdFx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LFxyXG5cdFx0XHRcdGpzb25zID0gW10sXHJcblx0XHRcdFx0anNvbjtcclxuXHJcblx0XHRcdGlmIChnZW9tZXRyeSAmJiBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0XHRyZXR1cm4gbXVsdGlUb0dlb0pTT04oJ011bHRpUG9pbnQnKS5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeSAmJiBnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJztcclxuXHJcblx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHRcdGpzb24gPSBsYXllci50b0dlb0pTT04oKTtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBqc29uLmdlb21ldHJ5IDogTC5HZW9KU09OLmFzRmVhdHVyZShqc29uKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KTtcclxufSgpKTtcclxuXHJcbkwuZ2VvSnNvbiA9IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkRvbUV2ZW50IGNvbnRhaW5zIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIERPTSBldmVudHMuXHJcbiAqL1xyXG5cclxuTC5Eb21FdmVudCA9IHtcclxuXHQvKiBpbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMgKi9cclxuXHRhZGRMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHsgLy8gKEhUTUxFbGVtZW50LCBTdHJpbmcsIEZ1bmN0aW9uWywgT2JqZWN0XSlcclxuXHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGZuKSxcclxuXHRcdCAgICBrZXkgPSAnX2xlYWZsZXRfJyArIHR5cGUgKyBpZCxcclxuXHRcdCAgICBoYW5kbGVyLCBvcmlnaW5hbEhhbmRsZXIsIG5ld1R5cGU7XHJcblxyXG5cdFx0aWYgKG9ialtrZXldKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IEwuRG9tRXZlbnQuX2dldEV2ZW50KCkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHRcdH1cclxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblxyXG5cdFx0XHRcdG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblx0XHRcdFx0bmV3VHlwZSA9ICh0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcpO1xyXG5cclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGlmICghTC5Eb21FdmVudC5fY2hlY2tNb3VzZShvYmosIGUpKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihuZXdUeXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjbGljaycgJiYgTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIEwuRG9tRXZlbnQuX2ZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpba2V5XSA9IGhhbmRsZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuKSB7ICAvLyAoSFRNTEVsZW1lbnQsIFN0cmluZywgRnVuY3Rpb24pXHJcblxyXG5cdFx0dmFyIGlkID0gTC5zdGFtcChmbiksXHJcblx0XHQgICAga2V5ID0gJ19sZWFmbGV0XycgKyB0eXBlICsgaWQsXHJcblx0XHQgICAgaGFuZGxlciA9IG9ialtrZXldO1xyXG5cclxuXHRcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JyksIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpba2V5XSA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcHBlZChlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQub24oZWwsICdtb3VzZXdoZWVsJywgc3RvcClcclxuXHRcdFx0Lm9uKGVsLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHN0b3ApO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IEwuRHJhZ2dhYmxlLlNUQVJULmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24oZWwsIEwuRHJhZ2dhYmxlLlNUQVJUW2ldLCBzdG9wKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQub24oZWwsICdjbGljaycsIEwuRG9tRXZlbnQuX2Zha2VTdG9wKVxyXG5cdFx0XHQub24oZWwsICdkYmxjbGljaycsIHN0b3ApO1xyXG5cdH0sXHJcblxyXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQucHJldmVudERlZmF1bHQoZSlcclxuXHRcdFx0LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRNb3VzZVBvc2l0aW9uOiBmdW5jdGlvbiAoZSwgY29udGFpbmVyKSB7XHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdFx0ZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHRcdGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0V2hlZWxEZWx0YTogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHR2YXIgZGVsdGEgPSAwO1xyXG5cclxuXHRcdGlmIChlLndoZWVsRGVsdGEpIHtcclxuXHRcdFx0ZGVsdGEgPSBlLndoZWVsRGVsdGEgLyAxMjA7XHJcblx0XHR9XHJcblx0XHRpZiAoZS5kZXRhaWwpIHtcclxuXHRcdFx0ZGVsdGEgPSAtZS5kZXRhaWwgLyAzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRlbHRhO1xyXG5cdH0sXHJcblxyXG5cdF9za2lwRXZlbnRzOiB7fSxcclxuXHJcblx0X2Zha2VTdG9wOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpXHJcblx0XHRMLkRvbUV2ZW50Ll9za2lwRXZlbnRzW2UudHlwZV0gPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9za2lwcGVkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNraXBwZWQgPSB0aGlzLl9za2lwRXZlbnRzW2UudHlwZV07XHJcblx0XHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG5cdFx0dGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gc2tpcHBlZDtcclxuXHR9LFxyXG5cclxuXHQvLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuXHRfY2hlY2tNb3VzZTogZnVuY3Rpb24gKGVsLCBlKSB7XHJcblxyXG5cdFx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdFx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0RXZlbnQ6IGZ1bmN0aW9uICgpIHsgLy8gZXZpbCBtYWdpYyBmb3IgSUVcclxuXHRcdC8qanNoaW50IG5vYXJnOmZhbHNlICovXHJcblx0XHR2YXIgZSA9IHdpbmRvdy5ldmVudDtcclxuXHRcdGlmICghZSkge1xyXG5cdFx0XHR2YXIgY2FsbGVyID0gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7XHJcblx0XHRcdHdoaWxlIChjYWxsZXIpIHtcclxuXHRcdFx0XHRlID0gY2FsbGVyWydhcmd1bWVudHMnXVswXTtcclxuXHRcdFx0XHRpZiAoZSAmJiB3aW5kb3cuRXZlbnQgPT09IGUuY29uc3RydWN0b3IpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsZXIgPSBjYWxsZXIuY2FsbGVyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZTtcclxuXHR9LFxyXG5cclxuXHQvLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcblx0X2ZpbHRlckNsaWNrOiBmdW5jdGlvbiAoZSwgaGFuZGxlcikge1xyXG5cdFx0dmFyIHRpbWVTdGFtcCA9IChlLnRpbWVTdGFtcCB8fCBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSxcclxuXHRcdFx0ZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcclxuXHJcblx0XHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRcdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdFx0cmV0dXJuIGhhbmRsZXIoZSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5Eb21FdmVudC5vbiA9IEwuRG9tRXZlbnQuYWRkTGlzdGVuZXI7XHJcbkwuRG9tRXZlbnQub2ZmID0gTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcjtcclxuXG5cbi8qXHJcbiAqIEwuRHJhZ2dhYmxlIGFsbG93cyB5b3UgdG8gYWRkIGRyYWdnaW5nIGNhcGFiaWxpdGllcyB0byBhbnkgZWxlbWVudC4gU3VwcG9ydHMgbW9iaWxlIGRldmljZXMgdG9vLlxyXG4gKi9cclxuXHJcbkwuRHJhZ2dhYmxlID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0U1RBUlQ6IEwuQnJvd3Nlci50b3VjaCA/IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSA6IFsnbW91c2Vkb3duJ10sXHJcblx0XHRFTkQ6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcblx0XHR9LFxyXG5cdFx0TU9WRToge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQpIHtcclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gTC5EcmFnZ2FibGUuU1RBUlQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJUW2ldLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gTC5EcmFnZ2FibGUuU1RBUlQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVFtpXSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHJcblx0XHRpZiAoTC5EcmFnZ2FibGUuX2Rpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2ggJiYgTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgMykgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlLCB0aGlzLl9kcmFnU3RhcnRUYXJnZXQpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJyk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHRcdHRoaXMuZmlyZSgnZHJhZycpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBMLkRyYWdnYWJsZS5NT1ZFKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSlcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtpXSwgdGhpcy5fb25VcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuTC5IYW5kbGVyID0gTC5DbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHR9LFxuXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG59KTtcblxuXG4vKlxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHRpbmVydGlhOiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3Ncblx0aW5lcnRpYVRocmVzaG9sZDogTC5Ccm93c2VyLnRvdWNoID8gMzIgOiAxOCwgLy8gbXNcblx0ZWFzZUxpbmVhcml0eTogMC4yNSxcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHR3b3JsZENvcHlKdW1wOiBmYWxzZVxufSk7XG5cbkwuTWFwLkRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdCdkcmFnJzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHQnZHJhZ2VuZCc6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZywgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbigndmlld3Jlc2V0JywgdGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwLl9wYW5BbmltKSB7XG5cdFx0XHRtYXAuX3BhbkFuaW0uc3RvcCgpO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDIwMCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnKVxuXHRcdCAgICAuZmlyZSgnZHJhZycpO1xuXHR9LFxuXG5cdF9vblZpZXdSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gZml4IGhhcmRjb2RlZCBFYXJ0aCB2YWx1ZXNcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5wcm9qZWN0KFswLCAxODBdKS54O1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXHRcdCAgICBkZWxheSA9ICtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRpbWUsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBkZWxheSA+IG9wdGlvbnMuaW5lcnRpYVRocmVzaG9sZCB8fCAhdGhpcy5fcG9zaXRpb25zWzBdO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lICsgZGVsYXkgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCB8fCAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIEwuTWFwLkRyYWcpO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Eb3VibGVDbGlja1pvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpICsgKGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IC0xIDogMSk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIEwuTWFwLkRvdWJsZUNsaWNrWm9vbSk7XG5cblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRzY3JvbGxXaGVlbFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5TY3JvbGxXaGVlbFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoNDAgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBkZWx0YSA9IHRoaXMuX2RlbHRhLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdGRlbHRhID0gZGVsdGEgPiAwID8gTWF0aC5jZWlsKGRlbHRhKSA6IE1hdGguZmxvb3IoZGVsdGEpO1xuXHRcdGRlbHRhID0gTWF0aC5tYXgoTWF0aC5taW4oZGVsdGEsIDQpLCAtNCk7XG5cdFx0ZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgZGVsdGEpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgTC5NYXAuU2Nyb2xsV2hlZWxab29tKTtcblxuXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xyXG5cclxuXHRfdG91Y2hzdGFydDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JyxcclxuXHRfdG91Y2hlbmQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogTC5Ccm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCcsXHJcblxyXG5cdC8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcblx0YWRkRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0XHR2YXIgbGFzdCxcclxuXHRcdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHRcdCAgICBkZWxheSA9IDI1MCxcclxuXHRcdCAgICB0b3VjaCxcclxuXHRcdCAgICBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gdGhpcy5fdG91Y2hzdGFydCxcclxuXHRcdCAgICB0b3VjaGVuZCA9IHRoaXMuX3RvdWNoZW5kLFxyXG5cdFx0ICAgIHRyYWNrZWRUb3VjaGVzID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0dHJhY2tlZFRvdWNoZXMucHVzaChlLnBvaW50ZXJJZCk7XHJcblx0XHRcdFx0Y291bnQgPSB0cmFja2VkVG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjb3VudCA+IDEpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBub3cgPSBEYXRlLm5vdygpLFxyXG5cdFx0XHRcdGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRcdGxhc3QgPSBub3c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdHZhciBpZHggPSB0cmFja2VkVG91Y2hlcy5pbmRleE9mKGUucG9pbnRlcklkKTtcclxuXHRcdFx0XHRpZiAoaWR4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0cmFja2VkVG91Y2hlcy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRvdWJsZVRhcCkge1xyXG5cdFx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdFx0dmFyIG5ld1RvdWNoID0geyB9LFxyXG5cdFx0XHRcdFx0XHRwcm9wO1xyXG5cclxuXHRcdFx0XHRcdC8vIGpzaGludCBmb3JpbjpmYWxzZVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcC5iaW5kKHRvdWNoKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3A7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRvYmpbcHJlICsgdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRcdG9ialtwcmUgKyB0b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblxyXG5cdFx0Ly8gb24gcG9pbnRlciB3ZSBuZWVkIHRvIGxpc3RlbiBvbiB0aGUgZG9jdW1lbnQsIG90aGVyd2lzZSBhIGRyYWcgc3RhcnRpbmcgb24gdGhlIG1hcCBhbmQgbW92aW5nIG9mZiBzY3JlZW5cclxuXHRcdC8vIHdpbGwgbm90IGNvbWUgdGhyb3VnaCB0byB1cywgc28gd2Ugd2lsbCBsb3NlIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgYXJlIG9uZ29pbmdcclxuXHRcdHZhciBlbmRFbGVtZW50ID0gTC5Ccm93c2VyLnBvaW50ZXIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBvYmo7XHJcblxyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XHJcblx0XHRlbmRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0ZW5kRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEwuRG9tRXZlbnQuUE9JTlRFUl9DQU5DRUwsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaHN0YXJ0LCBvYmpbcHJlICsgdGhpcy5fdG91Y2hzdGFydCArIGlkXSwgZmFsc2UpO1xyXG5cdFx0KEwuQnJvd3Nlci5wb2ludGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogb2JqKS5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0ICAgICAgICB0aGlzLl90b3VjaGVuZCwgb2JqW3ByZSArIHRoaXMuX3RvdWNoZW5kICsgaWRdLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEwuRG9tRXZlbnQuUE9JTlRFUl9DQU5DRUwsIG9ialtwcmUgKyB0aGlzLl90b3VjaGVuZCArIGlkXSxcclxuXHRcdFx0XHRmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcblxuXHQvL3N0YXRpY1xuXHRQT0lOVEVSX0RPV046IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiAncG9pbnRlcmRvd24nLFxuXHRQT0lOVEVSX01PVkU6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgOiAncG9pbnRlcm1vdmUnLFxuXHRQT0lOVEVSX1VQOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6ICdwb2ludGVydXAnLFxuXHRQT0lOVEVSX0NBTkNFTDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnLFxuXG5cdF9wb2ludGVyczogW10sXG5cdF9wb2ludGVyRG9jdW1lbnRMaXN0ZW5lcjogZmFsc2UsXG5cblx0Ly8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuXHQvLyBCYXNlZCBvbiBjaGFuZ2VzIGJ5IHZlcHJvemEgaHR0cHM6Ly9naXRodWIuY29tL0Nsb3VkTWFkZS9MZWFmbGV0L3B1bGwvMTAxOVxuXHQvL3JlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAndG91Y2hzdGFydCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJTdGFydChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcblx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJFbmQob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XG5cdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdHJldHVybiB0aGlzLmFkZFBvaW50ZXJMaXN0ZW5lck1vdmUob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93ICdVbmtub3duIHRvdWNoIGV2ZW50IHR5cGUnO1xuXHRcdH1cblx0fSxcblxuXHRhZGRQb2ludGVyTGlzdGVuZXJTdGFydDogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXG5cdFx0ICAgIHBvaW50ZXJzID0gdGhpcy5fcG9pbnRlcnM7XG5cblx0XHR2YXIgY2IgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYWxyZWFkeUluQXJyYXkgPSBmYWxzZTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHRhbHJlYWR5SW5BcnJheSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghYWxyZWFkeUluQXJyYXkpIHtcblx0XHRcdFx0cG9pbnRlcnMucHVzaChlKTtcblx0XHRcdH1cblxuXHRcdFx0ZS50b3VjaGVzID0gcG9pbnRlcnMuc2xpY2UoKTtcblx0XHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRcdGhhbmRsZXIoZSk7XG5cdFx0fTtcblxuXHRcdG9ialtwcmUgKyAndG91Y2hzdGFydCcgKyBpZF0gPSBjYjtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgY2IsIGZhbHNlKTtcblxuXHRcdC8vIG5lZWQgdG8gYWxzbyBsaXN0ZW4gZm9yIGVuZCBldmVudHMgdG8ga2VlcCB0aGUgX3BvaW50ZXJzIGxpc3QgYWNjdXJhdGVcblx0XHQvLyB0aGlzIG5lZWRzIHRvIGJlIG9uIHRoZSBib2R5IGFuZCBuZXZlciBnbyBhd2F5XG5cdFx0aWYgKCF0aGlzLl9wb2ludGVyRG9jdW1lbnRMaXN0ZW5lcikge1xuXHRcdFx0dmFyIGludGVybmFsQ2IgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHRcdHBvaW50ZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdC8vV2UgbGlzdGVuIG9uIHRoZSBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGludGVybmFsQ2IsIGZhbHNlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIGludGVybmFsQ2IsIGZhbHNlKTtcblxuXHRcdFx0dGhpcy5fcG9pbnRlckRvY3VtZW50TGlzdGVuZXIgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFkZFBvaW50ZXJMaXN0ZW5lck1vdmU6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxuXHRcdCAgICB0b3VjaGVzID0gdGhpcy5fcG9pbnRlcnM7XG5cblx0XHRmdW5jdGlvbiBjYihlKSB7XG5cblx0XHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRvdWNoZXNbaV0ucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuXHRcdFx0XHRcdHRvdWNoZXNbaV0gPSBlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGUudG91Y2hlcyA9IHRvdWNoZXMuc2xpY2UoKTtcblx0XHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRcdGhhbmRsZXIoZSk7XG5cdFx0fVxuXG5cdFx0b2JqW3ByZSArICd0b3VjaG1vdmUnICsgaWRdID0gY2I7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGNiLCBmYWxzZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhZGRQb2ludGVyTGlzdGVuZXJFbmQ6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxuXHRcdCAgICB0b3VjaGVzID0gdGhpcy5fcG9pbnRlcnM7XG5cblx0XHR2YXIgY2IgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0b3VjaGVzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHR0b3VjaGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlLnRvdWNoZXMgPSB0b3VjaGVzLnNsaWNlKCk7XG5cdFx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdFx0XHRoYW5kbGVyKGUpO1xuXHRcdH07XG5cblx0XHRvYmpbcHJlICsgJ3RvdWNoZW5kJyArIGlkXSA9IGNiO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgY2IsIGZhbHNlKTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBjYiwgZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBpZCkge1xuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcblx0XHQgICAgY2IgPSBvYmpbcHJlICsgdHlwZSArIGlkXTtcblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIGNiLCBmYWxzZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGNiLCBmYWxzZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGNiLCBmYWxzZSk7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBjYiwgZmFsc2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHR0b3VjaFpvb206IEwuQnJvd3Nlci50b3VjaCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuTC5NYXAuVG91Y2hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICB2aWV3Q2VudGVyID0gbWFwLl9nZXRDZW50ZXJMYXllclBvaW50KCk7XG5cblx0XHR0aGlzLl9zdGFydENlbnRlciA9IHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2NlbnRlck9mZnNldCA9IHZpZXdDZW50ZXIuc3VidHJhY3QodGhpcy5fc3RhcnRDZW50ZXIpO1xuXG5cdFx0aWYgKG1hcC5fcGFuQW5pbSkge1xuXHRcdFx0bWFwLl9wYW5BbmltLnN0b3AoKTtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9zY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXHRcdHRoaXMuX2RlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydENlbnRlcik7XG5cblx0XHRpZiAodGhpcy5fc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cykge1xuXHRcdFx0aWYgKChtYXAuZ2V0Wm9vbSgpID09PSBtYXAuZ2V0TWluWm9vbSgpICYmIHRoaXMuX3NjYWxlIDwgMSkgfHxcblx0XHRcdCAgICAobWFwLmdldFpvb20oKSA9PT0gbWFwLmdldE1heFpvb20oKSAmJiB0aGlzLl9zY2FsZSA+IDEpKSB7IHJldHVybjsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhtYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJyk7XG5cblx0XHRcdG1hcFxuXHRcdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdFx0ICAgIC5maXJlKCd6b29tc3RhcnQnKTtcblxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoXG5cdFx0ICAgICAgICB0aGlzLl91cGRhdGVPbk1vdmUsIHRoaXMsIHRydWUsIHRoaXMuX21hcC5fY29udGFpbmVyKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X3VwZGF0ZU9uTW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9yaWdpbiA9IHRoaXMuX2dldFNjYWxlT3JpZ2luKCksXG5cdFx0ICAgIGNlbnRlciA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcob3JpZ2luKSxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRTY2FsZVpvb20odGhpcy5fc2NhbGUpO1xuXG5cdFx0bWFwLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRoaXMuX3N0YXJ0Q2VudGVyLCB0aGlzLl9zY2FsZSwgdGhpcy5fZGVsdGEsIGZhbHNlLCB0cnVlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhtYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJyk7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSlcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHR2YXIgb3JpZ2luID0gdGhpcy5fZ2V0U2NhbGVPcmlnaW4oKSxcblx0XHQgICAgY2VudGVyID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhvcmlnaW4pLFxuXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBmbG9hdFpvb21EZWx0YSA9IG1hcC5nZXRTY2FsZVpvb20odGhpcy5fc2NhbGUpIC0gb2xkWm9vbSxcblx0XHQgICAgcm91bmRab29tRGVsdGEgPSAoZmxvYXRab29tRGVsdGEgPiAwID9cblx0XHQgICAgICAgICAgICBNYXRoLmNlaWwoZmxvYXRab29tRGVsdGEpIDogTWF0aC5mbG9vcihmbG9hdFpvb21EZWx0YSkpLFxuXG5cdFx0ICAgIHpvb20gPSBtYXAuX2xpbWl0Wm9vbShvbGRab29tICsgcm91bmRab29tRGVsdGEpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUoem9vbSkgLyB0aGlzLl9zY2FsZTtcblxuXHRcdG1hcC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCBvcmlnaW4sIHNjYWxlKTtcblx0fSxcblxuXHRfZ2V0U2NhbGVPcmlnaW46IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2VudGVyT2Zmc2V0ID0gdGhpcy5fY2VudGVyT2Zmc2V0LnN1YnRyYWN0KHRoaXMuX2RlbHRhKS5kaXZpZGVCeSh0aGlzLl9zY2FsZSk7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXJ0Q2VudGVyLmFkZChjZW50ZXJPZmZzZXQpO1xuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgTC5NYXAuVG91Y2hab29tKTtcblxuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHR0YXA6IHRydWUsXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5MLk1hcC5UYXAgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcylcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25VcCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpXG5cdFx0XHQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblVwLCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XG5cdEwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIEwuTWFwLlRhcCk7XG59XG5cblxuLypcbiAqIEwuSGFuZGxlci5TaGlmdERyYWdab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbkwuTWFwLkJveFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblxuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0TGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX2JveCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fcGFuZSk7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCB0aGlzLl9zdGFydExheWVyUG9pbnQpO1xuXG5cdFx0XHQvL1RPRE8gcmVmYWN0b3I6IG1vdmUgY3Vyc29yIHRvIHN0eWxlc1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHZhciBzdGFydFBvaW50ID0gdGhpcy5fc3RhcnRMYXllclBvaW50LFxuXHRcdCAgICBib3ggPSB0aGlzLl9ib3gsXG5cblx0XHQgICAgbGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLFxuXHRcdCAgICBvZmZzZXQgPSBsYXllclBvaW50LnN1YnRyYWN0KHN0YXJ0UG9pbnQpLFxuXG5cdFx0ICAgIG5ld1BvcyA9IG5ldyBMLlBvaW50KFxuXHRcdCAgICAgICAgTWF0aC5taW4obGF5ZXJQb2ludC54LCBzdGFydFBvaW50LngpLFxuXHRcdCAgICAgICAgTWF0aC5taW4obGF5ZXJQb2ludC55LCBzdGFydFBvaW50LnkpKTtcblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihib3gsIG5ld1Bvcyk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHQvLyBUT0RPIHJlZmFjdG9yOiByZW1vdmUgaGFyZGNvZGVkIDQgcGl4ZWxzXG5cdFx0Ym94LnN0eWxlLndpZHRoICA9IChNYXRoLm1heCgwLCBNYXRoLmFicyhvZmZzZXQueCkgLSA0KSkgKyAncHgnO1xuXHRcdGJveC5zdHlsZS5oZWlnaHQgPSAoTWF0aC5tYXgoMCwgTWF0aC5hYnMob2Zmc2V0LnkpIC0gNCkpICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9wYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2JveCk7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJyc7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBsYXllclBvaW50ID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cblx0XHRpZiAodGhpcy5fc3RhcnRMYXllclBvaW50LmVxdWFscyhsYXllclBvaW50KSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0TGF5ZXJQb2ludCksXG5cdFx0ICAgICAgICBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpKTtcblxuXHRcdG1hcC5maXRCb3VuZHMoYm91bmRzKTtcblxuXHRcdG1hcC5maXJlKCdib3h6b29tZW5kJywge1xuXHRcdFx0Ym94Wm9vbUJvdW5kczogYm91bmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEwuTWFwLkJveFpvb20pO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRrZXlib2FyZDogdHJ1ZSxcblx0a2V5Ym9hcmRQYW5PZmZzZXQ6IDgwLFxuXHRrZXlib2FyZFpvb21PZmZzZXQ6IDFcbn0pO1xuXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5PZmZzZXQpO1xuXHRcdHRoaXMuX3NldFpvb21PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRab29tT2Zmc2V0KTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPT09IC0xKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oY29udGFpbmVyLCAnZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB0aGlzKVxuXHRcdCAgICAub24oY29udGFpbmVyLCAnYmx1cicsIHRoaXMuX29uQmx1ciwgdGhpcylcblx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAub24oJ2ZvY3VzJywgdGhpcy5fYWRkSG9va3MsIHRoaXMpXG5cdFx0ICAgIC5vbignYmx1cicsIHRoaXMuX3JlbW92ZUhvb2tzLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoY29udGFpbmVyLCAnZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB0aGlzKVxuXHRcdCAgICAub2ZmKGNvbnRhaW5lciwgJ2JsdXInLCB0aGlzLl9vbkJsdXIsIHRoaXMpXG5cdFx0ICAgIC5vZmYoY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5vZmYoJ2ZvY3VzJywgdGhpcy5fYWRkSG9va3MsIHRoaXMpXG5cdFx0ICAgIC5vZmYoJ2JsdXInLCB0aGlzLl9yZW1vdmVIb29rcywgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuT2Zmc2V0OiBmdW5jdGlvbiAocGFuKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbiwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW4sIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbl07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbl07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tT2Zmc2V0OiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb207XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHRcdG1hcC5wYW5CeSh0aGlzLl9wYW5LZXlzW2tleV0pO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgTC5NYXAuS2V5Ym9hcmQpO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuTC5IYW5kbGVyLk1hcmtlckRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoaWNvbiwgaWNvbik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlXG5cdFx0XHQub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9uKCdkcmFnJywgdGhpcy5fb25EcmFnLCB0aGlzKVxuXHRcdFx0Lm9uKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCB0aGlzKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlXG5cdFx0XHQub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWcnLCB0aGlzLl9vbkRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIHtsYXRsbmc6IGxhdGxuZ30pXG5cdFx0ICAgIC5maXJlKCdkcmFnJyk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcblxuXG4vKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5MLkNvbnRyb2wgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdGNvcm5lci5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKG1hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vLyBhZGRzIGNvbnRyb2wtcmVsYXRlZCBtZXRob2RzIHRvIEwuTWFwXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZUZyb20odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBMLkNvbnRyb2wuWm9vbSBpcyB1c2VkIGZvciB0aGUgZGVmYXVsdCB6b29tIGJ1dHRvbnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuWm9vbSA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cdFx0em9vbU91dFRleHQ6ICctJyxcclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKFxyXG5cdFx0ICAgICAgICB0aGlzLm9wdGlvbnMuem9vbUluVGV4dCwgdGhpcy5vcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4sICB0aGlzKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXHJcblx0XHQgICAgICAgIHRoaXMub3B0aW9ucy56b29tT3V0VGV4dCwgdGhpcy5vcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fbWFwLnpvb21JbihlLnNoaWZ0S2V5ID8gMyA6IDEpO1xyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fbWFwLnpvb21PdXQoZS5zaGlmdEtleSA/IDMgOiAxKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBzdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnbW91c2Vkb3duJywgc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ2RibGNsaWNrJywgc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgY29udGV4dCk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0XHRjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdGlmIChtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wuem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuWm9vbShvcHRpb25zKTtcclxufTtcclxuXHJcblxuXG4vKlxyXG4gKiBMLkNvbnRyb2wuQXR0cmlidXRpb24gaXMgdXNlZCBmb3IgZGlzcGxheWluZyBhdHRyaWJ1dGlvbiBvbiB0aGUgbWFwIChhZGRlZCBieSBkZWZhdWx0KS5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRtYXBcclxuXHRcdCAgICAub24oJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckFkZCwgdGhpcylcclxuXHRcdCAgICAub24oJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllclJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQWRkKVxyXG5cdFx0ICAgIC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllclJlbW92ZSk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihlLmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGlvbihlLmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wgPSAobmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbigpKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sLmF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXG4gKiBMLkNvbnRyb2wuU2NhbGUgaXMgdXNlZCBmb3IgZGlzcGxheWluZyBtZXRyaWMvaW1wZXJpYWwgc2NhbGUgb24gdGhlIG1hcC5cbiAqL1xuXG5MLkNvbnRyb2wuU2NhbGUgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cdFx0bWF4V2lkdGg6IDEwMCxcblx0XHRtZXRyaWM6IHRydWUsXG5cdFx0aW1wZXJpYWw6IHRydWUsXG5cdFx0dXBkYXRlV2hlbklkbGU6IGZhbHNlXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldEJvdW5kcygpLFxuXHRcdCAgICBjZW50ZXJMYXQgPSBib3VuZHMuZ2V0Q2VudGVyKCkubGF0LFxuXHRcdCAgICBoYWxmV29ybGRNZXRlcnMgPSA2Mzc4MTM3ICogTWF0aC5QSSAqIE1hdGguY29zKGNlbnRlckxhdCAqIE1hdGguUEkgLyAxODApLFxuXHRcdCAgICBkaXN0ID0gaGFsZldvcmxkTWV0ZXJzICogKGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sbmcgLSBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKSAvIDE4MCxcblxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHQgICAgbWF4TWV0ZXJzID0gMDtcblxuXHRcdGlmIChzaXplLnggPiAwKSB7XG5cdFx0XHRtYXhNZXRlcnMgPSBkaXN0ICogKG9wdGlvbnMubWF4V2lkdGggLyBzaXplLngpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhvcHRpb25zLCBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBtYXhNZXRlcnMpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKTtcblxuXHRcdHRoaXMuX21TY2FsZS5zdHlsZS53aWR0aCA9IHRoaXMuX2dldFNjYWxlV2lkdGgobWV0ZXJzIC8gbWF4TWV0ZXJzKSArICdweCc7XG5cdFx0dGhpcy5fbVNjYWxlLmlubmVySFRNTCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5faVNjYWxlLFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblxuXHRcdFx0c2NhbGUuc3R5bGUud2lkdGggPSB0aGlzLl9nZXRTY2FsZVdpZHRoKG1pbGVzIC8gbWF4TWlsZXMpICsgJ3B4Jztcblx0XHRcdHNjYWxlLmlubmVySFRNTCA9IG1pbGVzICsgJyBtaSc7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXG5cdFx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IHRoaXMuX2dldFNjYWxlV2lkdGgoZmVldCAvIG1heEZlZXQpICsgJ3B4Jztcblx0XHRcdHNjYWxlLmlubmVySFRNTCA9IGZlZXQgKyAnIGZ0Jztcblx0XHR9XG5cdH0sXG5cblx0X2dldFNjYWxlV2lkdGg6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSAtIDEwO1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDogZCA+PSA1ID8gNSA6IGQgPj0gMyA/IDMgOiBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5MLmNvbnRyb2wuc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5TY2FsZShvcHRpb25zKTtcbn07XG5cblxuLypcclxuICogTC5Db250cm9sLkxheWVycyBpcyBhIGNvbnRyb2wgdG8gYWxsb3cgdXNlcnMgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGxheWVycyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5MYXllcnMgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHRcdGF1dG9aSW5kZXg6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRtYXBcclxuXHRcdCAgICAub24oJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcylcclxuXHRcdCAgICAub24oJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKVxyXG5cdFx0ICAgIC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0Ly9NYWtlcyB0aGlzIHdvcmsgb24gSUUxMCBUb3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcilcclxuXHRcdFx0XHQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdCAgICAub24oY29udGFpbmVyLCAnbW91c2VvdmVyJywgdGhpcy5fZXhwYW5kLCB0aGlzKVxyXG5cdFx0XHRcdCAgICAub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxyXG5cdFx0XHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuX2V4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9Xb3JrIGFyb3VuZCBmb3IgRmlyZWZveCBhbmRyb2lkIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwMzNcclxuXHRcdFx0TC5Eb21FdmVudC5vbihmb3JtLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKSwgMCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX2NvbGxhcHNlLCB0aGlzKTtcclxuXHRcdFx0Ly8gVE9ETyBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBmb3JtKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSB7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcblx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5pbm5lckhUTUwgPSAnJztcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdC5pbm5lckhUTUwgPSAnJztcclxuXHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQgPSBmYWxzZSxcclxuXHRcdCAgICBvdmVybGF5c1ByZXNlbnQgPSBmYWxzZSxcclxuXHRcdCAgICBpLCBvYmo7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2xheWVyc1tMLnN0YW1wKGUubGF5ZXIpXTtcclxuXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcblx0XHRcdChlLnR5cGUgPT09ICdsYXllcmFkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2xheWVyYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgKyBuYW1lICsgJ1wiJztcclxuXHRcdGlmIChjaGVja2VkKSB7XHJcblx0XHRcdHJhZGlvSHRtbCArPSAnIGNoZWNrZWQ9XCJjaGVja2VkXCInO1xyXG5cdFx0fVxyXG5cdFx0cmFkaW9IdG1sICs9ICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzJywgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IEwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCBpbnB1dCwgb2JqLFxyXG5cdFx0ICAgIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXRzTGVuID0gaW5wdXRzLmxlbmd0aDtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgaW5wdXRzTGVuOyBpKyspIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpbnB1dC5sYXllcklkXTtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkICYmICF0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihvYmoubGF5ZXIpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihvYmoubGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5fY29udGFpbmVyLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcsICcnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sLmxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxuICogTC5Qb3NBbmltYXRpb24gaXMgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgZm9yIHBhbiBhbmltYXRpb25zLlxuICovXG5cbkwuUG9zQW5pbWF0aW9uID0gTC5DbGFzcy5leHRlbmQoe1xuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIE51bWJlciwgTnVtYmVyXSlcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3UG9zO1xuXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TSVRJT05dID0gJ2FsbCAnICsgKGR1cmF0aW9uIHx8IDAuMjUpICtcblx0XHQgICAgICAgICdzIGN1YmljLWJlemllcigwLDAsJyArIChlYXNlTGluZWFyaXR5IHx8IDAuNSkgKyAnLDEpJztcblxuXHRcdEwuRG9tRXZlbnQub24oZWwsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oZWwsIG5ld1Bvcyk7XG5cblx0XHQvLyB0b2dnbGUgcmVmbG93LCBDaHJvbWUgZmxpY2tlcnMgZm9yIHNvbWUgcmVhc29uIGlmIHlvdSBkb24ndCBkbyB0aGlzXG5cdFx0TC5VdGlsLmZhbHNlRm4oZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0Ly8gdGhlcmUncyBubyBuYXRpdmUgd2F5IHRvIHRyYWNrIHZhbHVlIHVwZGF0ZXMgb2YgdHJhbnNpdGlvbmVkIHByb3BlcnRpZXMsIHNvIHdlIGltaXRhdGUgdGhpc1xuXHRcdHRoaXMuX3N0ZXBUaW1lciA9IHNldEludGVydmFsKEwuYmluZCh0aGlzLl9vblN0ZXAsIHRoaXMpLCA1MCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdC8vIGlmIHdlIGp1c3QgcmVtb3ZlZCB0aGUgdHJhbnNpdGlvbiBwcm9wZXJ0eSwgdGhlIGVsZW1lbnQgd291bGQganVtcCB0byBpdHMgZmluYWwgcG9zaXRpb24sXG5cdFx0Ly8gc28gd2UgbmVlZCB0byBtYWtlIGl0IHN0YXkgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fZ2V0UG9zKCkpO1xuXHRcdHRoaXMuX29uVHJhbnNpdGlvbkVuZCgpO1xuXHRcdEwuVXRpbC5mYWxzZUZuKHRoaXMuX2VsLm9mZnNldFdpZHRoKTsgLy8gZm9yY2UgcmVmbG93IGluIGNhc2Ugd2UgYXJlIGFib3V0IHRvIHN0YXJ0IGEgbmV3IGFuaW1hdGlvblxuXHR9LFxuXG5cdF9vblN0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc3RlcFBvcyA9IHRoaXMuX2dldFBvcygpO1xuXHRcdGlmICghc3RlcFBvcykge1xuXHRcdFx0dGhpcy5fb25UcmFuc2l0aW9uRW5kKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXG5cdFx0Ly8gbWFrZSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24gcmV0dXJuIGludGVybWVkaWF0ZSBwb3NpdGlvbiB2YWx1ZSBkdXJpbmcgYW5pbWF0aW9uXG5cdFx0dGhpcy5fZWwuX2xlYWZsZXRfcG9zID0gc3RlcFBvcztcblxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdC8vIHlvdSBjYW4ndCBlYXNpbHkgZ2V0IGludGVybWVkaWF0ZSB2YWx1ZXMgb2YgcHJvcGVydGllcyBhbmltYXRlZCB3aXRoIENTUzMgVHJhbnNpdGlvbnMsXG5cdC8vIHdlIG5lZWQgdG8gcGFyc2UgY29tcHV0ZWQgc3R5bGUgKGluIGNhc2Ugb2YgdHJhbnNmb3JtIGl0IHJldHVybnMgbWF0cml4IHN0cmluZylcblxuXHRfdHJhbnNmb3JtUmU6IC8oWy0rXT8oPzpcXGQqXFwuKT9cXGQrKVxcRCosIChbLStdPyg/OlxcZCpcXC4pP1xcZCspXFxEKlxcKS8sXG5cblx0X2dldFBvczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsZWZ0LCB0b3AsIG1hdGNoZXMsXG5cdFx0ICAgIGVsID0gdGhpcy5fZWwsXG5cdFx0ICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0bWF0Y2hlcyA9IHN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dLm1hdGNoKHRoaXMuX3RyYW5zZm9ybVJlKTtcblx0XHRcdGlmICghbWF0Y2hlcykgeyByZXR1cm47IH1cblx0XHRcdGxlZnQgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuXHRcdFx0dG9wICA9IHBhcnNlRmxvYXQobWF0Y2hlc1syXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmxlZnQpO1xuXHRcdFx0dG9wICA9IHBhcnNlRmxvYXQoc3R5bGUudG9wKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGVmdCwgdG9wLCB0cnVlKTtcblx0fSxcblxuXHRfb25UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZWwsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCB0aGlzKTtcblxuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cblx0XHR0aGlzLl9lbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNJVElPTl0gPSAnJztcblxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXG5cdFx0Ly8gbWFrZSBzdXJlIEwuRG9tVXRpbC5nZXRQb3NpdGlvbiByZXR1cm5zIHRoZSBmaW5hbCBwb3NpdGlvbiB2YWx1ZSBhZnRlciBhbmltYXRpb25cblx0XHR0aGlzLl9lbC5fbGVhZmxldF9wb3MgPSB0aGlzLl9uZXdQb3M7XG5cblx0XHRjbGVhckludGVydmFsKHRoaXMuX3N0ZXBUaW1lcik7XG5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKS5maXJlKCdlbmQnKTtcblx0fVxuXG59KTtcblxuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgcGFubmluZyBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLmluY2x1ZGUoe1xuXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKEwubGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b3B0aW9ucy56b29tID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XG5cdFx0XHRcdG9wdGlvbnMucGFuID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMucGFuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuXHRcdFx0dmFyIGFuaW1hdGVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcblxuXHRcdFx0aWYgKGFuaW1hdGVkKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xuXHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xuXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCk7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZmxvb3IoKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5cbi8qXG4gKiBMLlBvc0FuaW1hdGlvbiBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiB0aGF0IHBvd2VycyBMZWFmbGV0IHBhbiBhbmltYXRpb25zXG4gKiBpbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucy5cbiAqL1xuXG5MLlBvc0FuaW1hdGlvbiA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OID8gTC5Qb3NBbmltYXRpb24gOiBMLlBvc0FuaW1hdGlvbi5leHRlbmQoe1xuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBOdW1iZXIsIE51bWJlcl0pXG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCgpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuXG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSB6b29tIGFuaW1hdGlvbnMuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcblx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNFxufSk7XG5cbmlmIChMLkRvbVV0aWwuVFJBTlNJVElPTikge1xuXG5cdEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJlxuXHRcdFx0XHRMLkJyb3dzZXIuYW55M2QgJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMgJiYgIUwuQnJvd3Nlci5tb2JpbGVPcGVyYTtcblxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwUGFuZSwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59XG5cbkwuTWFwLmluY2x1ZGUoIUwuRG9tVXRpbC5UUkFOU0lUSU9OID8ge30gOiB7XG5cblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xuXHR9LFxuXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpLFxuXHRcdFx0b3JpZ2luID0gdGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpLl9hZGQob2Zmc2V0KTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXNcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCd6b29tc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgb3JpZ2luLCBzY2FsZSwgbnVsbCwgdHJ1ZSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9yaWdpbiwgc2NhbGUsIGRlbHRhLCBiYWNrd2FyZHMsIGZvclRvdWNoWm9vbSkge1xuXG5cdFx0aWYgKCFmb3JUb3VjaFpvb20pIHtcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIHB1dCB0cmFuc2Zvcm0gdHJhbnNpdGlvbiBvbiBhbGwgbGF5ZXJzIHdpdGggbGVhZmxldC16b29tLWFuaW1hdGVkIGNsYXNzXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXG5cdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xuXHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xuXG5cdFx0Ly8gZGlzYWJsZSBhbnkgZHJhZ2dpbmcgZHVyaW5nIGFuaW1hdGlvblxuXHRcdGlmIChMLkRyYWdnYWJsZSkge1xuXHRcdFx0TC5EcmFnZ2FibGUuX2Rpc2FibGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xuXHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0em9vbTogem9vbSxcblx0XHRcdFx0b3JpZ2luOiBvcmlnaW4sXG5cdFx0XHRcdHNjYWxlOiBzY2FsZSxcblx0XHRcdFx0ZGVsdGE6IGRlbHRhLFxuXHRcdFx0XHRiYWNrd2FyZHM6IGJhY2t3YXJkc1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBob3JyaWJsZSBoYWNrIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5XG5cdFx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblxuXHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHRydWUsIHRydWUpO1xuXG5cdFx0XHRpZiAoTC5EcmFnZ2FibGUpIHtcblx0XHRcdFx0TC5EcmFnZ2FibGUuX2Rpc2FibGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cdH1cbn0pO1xuXG5cbi8qXG5cdFpvb20gYW5pbWF0aW9uIGxvZ2ljIGZvciBMLlRpbGVMYXllci5cbiovXG5cbkwuVGlsZUxheWVyLmluY2x1ZGUoe1xuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcblx0XHRcdHRoaXMuX2FuaW1hdGluZyA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcmVwYXJlQmdCdWZmZXIoKTtcblx0XHR9XG5cblx0XHR2YXIgYmcgPSB0aGlzLl9iZ0J1ZmZlcixcblx0XHQgICAgdHJhbnNmb3JtID0gTC5Eb21VdGlsLlRSQU5TRk9STSxcblx0XHQgICAgaW5pdGlhbFRyYW5zZm9ybSA9IGUuZGVsdGEgPyBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKGUuZGVsdGEpIDogYmcuc3R5bGVbdHJhbnNmb3JtXSxcblx0XHQgICAgc2NhbGVTdHIgPSBMLkRvbVV0aWwuZ2V0U2NhbGVTdHJpbmcoZS5zY2FsZSwgZS5vcmlnaW4pO1xuXG5cdFx0Ymcuc3R5bGVbdHJhbnNmb3JtXSA9IGUuYmFja3dhcmRzID9cblx0XHRcdFx0c2NhbGVTdHIgKyAnICcgKyBpbml0aWFsVHJhbnNmb3JtIDpcblx0XHRcdFx0aW5pdGlhbFRyYW5zZm9ybSArICcgJyArIHNjYWxlU3RyO1xuXHR9LFxuXG5cdF9lbmRab29tQW5pbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBmcm9udCA9IHRoaXMuX3RpbGVDb250YWluZXIsXG5cdFx0ICAgIGJnID0gdGhpcy5fYmdCdWZmZXI7XG5cblx0XHRmcm9udC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cdFx0ZnJvbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChmcm9udCk7IC8vIEJyaW5nIHRvIGZvcmVcblxuXHRcdC8vIGZvcmNlIHJlZmxvd1xuXHRcdEwuVXRpbC5mYWxzZUZuKGJnLm9mZnNldFdpZHRoKTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fY2xlYXJCZ0J1ZmZlcigpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FuaW1hdGluZyA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckJnQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmIChtYXAgJiYgIW1hcC5fYW5pbWF0aW5nWm9vbSAmJiAhbWFwLnRvdWNoWm9vbS5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fYmdCdWZmZXIuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHR0aGlzLl9iZ0J1ZmZlci5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9ICcnO1xuXHRcdH1cblx0fSxcblxuXHRfcHJlcGFyZUJnQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZnJvbnQgPSB0aGlzLl90aWxlQ29udGFpbmVyLFxuXHRcdCAgICBiZyA9IHRoaXMuX2JnQnVmZmVyO1xuXG5cdFx0Ly8gaWYgZm9yZWdyb3VuZCBsYXllciBkb2Vzbid0IGhhdmUgbWFueSB0aWxlcyBidXQgYmcgbGF5ZXIgZG9lcyxcblx0XHQvLyBrZWVwIHRoZSBleGlzdGluZyBiZyBsYXllciBhbmQganVzdCB6b29tIGl0IHNvbWUgbW9yZVxuXG5cdFx0dmFyIGJnTG9hZGVkID0gdGhpcy5fZ2V0TG9hZGVkVGlsZXNQZXJjZW50YWdlKGJnKSxcblx0XHQgICAgZnJvbnRMb2FkZWQgPSB0aGlzLl9nZXRMb2FkZWRUaWxlc1BlcmNlbnRhZ2UoZnJvbnQpO1xuXG5cdFx0aWYgKGJnICYmIGJnTG9hZGVkID4gMC41ICYmIGZyb250TG9hZGVkIDwgMC41KSB7XG5cblx0XHRcdGZyb250LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHRcdHRoaXMuX3N0b3BMb2FkaW5nSW1hZ2VzKGZyb250KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBwcmVwYXJlIHRoZSBidWZmZXIgdG8gYmVjb21lIHRoZSBmcm9udCB0aWxlIHBhbmVcblx0XHRiZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0Ymcuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPSAnJztcblxuXHRcdC8vIHN3aXRjaCBvdXQgdGhlIGN1cnJlbnQgbGF5ZXIgdG8gYmUgdGhlIG5ldyBiZyBsYXllciAoYW5kIHZpY2UtdmVyc2EpXG5cdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IGJnO1xuXHRcdGJnID0gdGhpcy5fYmdCdWZmZXIgPSBmcm9udDtcblxuXHRcdHRoaXMuX3N0b3BMb2FkaW5nSW1hZ2VzKGJnKTtcblxuXHRcdC8vcHJldmVudCBiZyBidWZmZXIgZnJvbSBjbGVhcmluZyByaWdodCBhZnRlciB6b29tXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2NsZWFyQmdCdWZmZXJUaW1lcik7XG5cdH0sXG5cblx0X2dldExvYWRlZFRpbGVzUGVyY2VudGFnZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlcyA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJyksXG5cdFx0ICAgIGksIGxlbiwgY291bnQgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICh0aWxlc1tpXS5jb21wbGV0ZSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY291bnQgLyBsZW47XG5cdH0sXG5cblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcblx0X3N0b3BMb2FkaW5nSW1hZ2VzOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSksXG5cdFx0ICAgIGksIGxlbiwgdGlsZTtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aWxlID0gdGlsZXNbaV07XG5cblx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IEwuVXRpbC5mYWxzZUZuO1xuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBMLlV0aWwuZmFsc2VGbjtcblx0XHRcdFx0dGlsZS5zcmMgPSBMLlV0aWwuZW1wdHlJbWFnZVVybDtcblxuXHRcdFx0XHR0aWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuXG4vKlxyXG4gKiBQcm92aWRlcyBMLk1hcCB3aXRoIGNvbnZlbmllbnQgc2hvcnRjdXRzIGZvciB1c2luZyBicm93c2VyIGdlb2xvY2F0aW9uIGZlYXR1cmVzLlxyXG4gKi9cclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdF9kZWZhdWx0TG9jYXRlT3B0aW9uczoge1xyXG5cdFx0d2F0Y2g6IGZhbHNlLFxyXG5cdFx0c2V0VmlldzogZmFsc2UsXHJcblx0XHRtYXhab29tOiBJbmZpbml0eSxcclxuXHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0bWF4aW11bUFnZTogMCxcclxuXHRcdGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uICgvKk9iamVjdCovIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHRoaXMuX2RlZmF1bHRMb2NhdGVPcHRpb25zLCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0XHRvbkVycm9yID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblxyXG5cdFx0ICAgIGxhdEFjY3VyYWN5ID0gMTgwICogcG9zLmNvb3Jkcy5hY2N1cmFjeSAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcyhMLkxhdExuZy5ERUdfVE9fUkFEICogbGF0KSxcclxuXHJcblx0XHQgICAgYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgICAgICBbbGF0IC0gbGF0QWNjdXJhY3ksIGxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgICAgIFtsYXQgKyBsYXRBY2N1cmFjeSwgbG5nICsgbG5nQWNjdXJhY3ldKSxcclxuXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IE1hdGgubWluKHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpLCBvcHRpb25zLm1heFpvb20pO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcblxuXG59KHdpbmRvdywgZG9jdW1lbnQpKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgncXVldWUnLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwucXVldWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICB2YXIgbm9hYm9ydCA9IHt9O1xuICB2YXIgc3VjY2VzcyA9IFtudWxsXTtcbiAgZnVuY3Rpb24gbmV3UXVldWUoY29uY3VycmVuY3kpIHtcbiAgICBpZiAoIShjb25jdXJyZW5jeSA+PSAxKSkgdGhyb3cgbmV3IEVycm9yO1xuXG4gICAgdmFyIHEsXG4gICAgICAgIHRhc2tzID0gW10sXG4gICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgd2FpdGluZyA9IDAsXG4gICAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICAgIGVuZGVkID0gMCxcbiAgICAgICAgc3RhcnRpbmcsIC8vIGluc2lkZSBhIHN5bmNocm9ub3VzIHRhc2sgY2FsbGJhY2s/XG4gICAgICAgIGVycm9yLFxuICAgICAgICBjYWxsYmFjayA9IG5vb3AsXG4gICAgICAgIGNhbGxiYWNrQWxsID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgaWYgKHN0YXJ0aW5nKSByZXR1cm47IC8vIGxldCB0aGUgY3VycmVudCB0YXNrIGNvbXBsZXRlXG4gICAgICB3aGlsZSAoc3RhcnRpbmcgPSB3YWl0aW5nICYmIGFjdGl2ZSA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIHZhciBpID0gZW5kZWQgKyBhY3RpdmUsXG4gICAgICAgICAgICB0ID0gdGFza3NbaV0sXG4gICAgICAgICAgICBqID0gdC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgYyA9IHRbal07XG4gICAgICAgIHRbal0gPSBlbmQoaSk7XG4gICAgICAgIC0td2FpdGluZywgKythY3RpdmUsIHRhc2tzW2ldID0gYy5hcHBseShudWxsLCB0KSB8fCBub2Fib3J0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZChpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSwgcikge1xuICAgICAgICBpZiAoIXRhc2tzW2ldKSB0aHJvdyBuZXcgRXJyb3I7IC8vIGRldGVjdCBtdWx0aXBsZSBjYWxsYmFja3NcbiAgICAgICAgLS1hY3RpdmUsICsrZW5kZWQsIHRhc2tzW2ldID0gbnVsbDtcbiAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHJldHVybjsgLy8gb25seSByZXBvcnQgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICBhYm9ydChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzW2ldID0gcjtcbiAgICAgICAgICBpZiAod2FpdGluZykgc3RhcnQoKTtcbiAgICAgICAgICBlbHNlIGlmICghYWN0aXZlKSBub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYm9ydChlKSB7XG4gICAgICBlcnJvciA9IGU7IC8vIGlnbm9yZSBuZXcgdGFza3MgYW5kIHNxdWVsY2ggYWN0aXZlIGNhbGxiYWNrc1xuICAgICAgd2FpdGluZyA9IE5hTjsgLy8gc3RvcCBxdWV1ZWQgdGFza3MgZnJvbSBzdGFydGluZ1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrQWxsKSBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgIGVsc2UgY2FsbGJhY2suYXBwbHkobnVsbCwgc3VjY2Vzcy5jb25jYXQocmVzdWx0cykpO1xuICAgIH1cblxuICAgIHJldHVybiBxID0ge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBub29wKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgICAgIHZhciB0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB0LnB1c2goZik7XG4gICAgICAgICsrd2FpdGluZywgdGFza3MucHVzaCh0KTtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpID0gZW5kZWQgKyBhY3RpdmUsIHQ7XG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSAodCA9IHRhc2tzW2ldKSAmJiB0LmFib3J0ICYmIHQuYWJvcnQoKTtcbiAgICAgICAgICBhYm9ydChuZXcgRXJyb3IoXCJhYm9ydFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBub29wKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgICAgIGNhbGxiYWNrID0gZiwgY2FsbGJhY2tBbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF3YWl0aW5nICYmICFhY3RpdmUpIG5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sXG4gICAgICBhd2FpdEFsbDogZnVuY3Rpb24oZikge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG5vb3ApIHRocm93IG5ldyBFcnJvcjtcbiAgICAgICAgY2FsbGJhY2sgPSBmLCBjYWxsYmFja0FsbCA9IHRydWU7XG4gICAgICAgIGlmICghd2FpdGluZyAmJiAhYWN0aXZlKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1ZXVlKGNvbmN1cnJlbmN5KSB7XG4gICAgcmV0dXJuIG5ld1F1ZXVlKGFyZ3VtZW50cy5sZW5ndGggPyArY29uY3VycmVuY3kgOiBJbmZpbml0eSk7XG4gIH1cblxuICBxdWV1ZS52ZXJzaW9uID0gXCIxLjIuMVwiO1xuXG4gIHJldHVybiBxdWV1ZTtcblxufSkpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVG9vbHRpcCA9IHJlcXVpcmUoJ3JjLXRvb2x0aXAnKTtcblxudmFyIF9yY1Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUb29sdGlwKTtcblxudmFyIEhhbmRsZSA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSGFuZGxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYW5kbGUocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFuZGxlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEhhbmRsZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Rvb2x0aXBWaXNpYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGFuZGxlLCBbe1xuICAgIGtleTogJ3Nob3dUb29sdGlwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd1Rvb2x0aXAoKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNUb29sdGlwVmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZVRvb2x0aXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1Rvb2x0aXBWaXNpYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgICB2YXIgdGlwVHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50aXBUcmFuc2l0aW9uTmFtZTtcbiAgICAgIHZhciB0aXBGb3JtYXR0ZXIgPSBwcm9wcy50aXBGb3JtYXR0ZXI7XG4gICAgICB2YXIgdmVydGljYWwgPSBwcm9wcy52ZXJ0aWNhbDtcbiAgICAgIHZhciBvZmZzZXQgPSBwcm9wcy5vZmZzZXQ7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgIHZhciBkcmFnZ2luZyA9IHByb3BzLmRyYWdnaW5nO1xuICAgICAgdmFyIG5vVGlwID0gcHJvcHMubm9UaXA7XG5cbiAgICAgIHZhciBzdHlsZSA9IHZlcnRpY2FsID8geyBib3R0b206IG9mZnNldCArICclJyB9IDogeyBsZWZ0OiBvZmZzZXQgKyAnJScgfTtcbiAgICAgIHZhciBoYW5kbGUgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvbk1vdXNlVXA6IHRoaXMuc2hvd1Rvb2x0aXAuYmluZCh0aGlzKSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLnNob3dUb29sdGlwLmJpbmQodGhpcyksXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oaWRlVG9vbHRpcC5iaW5kKHRoaXMpIH0pO1xuXG4gICAgICBpZiAobm9UaXApIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzVG9vbHRpcFZpc2libGUgPSBkcmFnZ2luZyB8fCB0aGlzLnN0YXRlLmlzVG9vbHRpcFZpc2libGU7XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9yY1Rvb2x0aXAyWydkZWZhdWx0J10sXG4gICAgICAgIHtcbiAgICAgICAgICBwcmVmaXhDbHM6IGNsYXNzTmFtZS5yZXBsYWNlKCdzbGlkZXItaGFuZGxlJywgJ3Rvb2x0aXAnKSxcbiAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAgIHZpc2libGU6IGlzVG9vbHRpcFZpc2libGUsXG4gICAgICAgICAgb3ZlcmxheTogX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGlwRm9ybWF0dGVyKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRpcFRyYW5zaXRpb25OYW1lIH0sXG4gICAgICAgIGhhbmRsZVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGFuZGxlO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEhhbmRsZTtcblxuSGFuZGxlLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgdmVydGljYWw6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgb2Zmc2V0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgdGlwVHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICB0aXBGb3JtYXR0ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgdmFsdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLFxuICBkcmFnZ2luZzogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBub1RpcDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgTWFya3MgPSBmdW5jdGlvbiBNYXJrcyhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcbiAgdmFyIHZlcnRpY2FsID0gX3JlZi52ZXJ0aWNhbDtcbiAgdmFyIG1hcmtzID0gX3JlZi5tYXJrcztcbiAgdmFyIGluY2x1ZGVkID0gX3JlZi5pbmNsdWRlZDtcbiAgdmFyIHVwcGVyQm91bmQgPSBfcmVmLnVwcGVyQm91bmQ7XG4gIHZhciBsb3dlckJvdW5kID0gX3JlZi5sb3dlckJvdW5kO1xuICB2YXIgbWF4ID0gX3JlZi5tYXg7XG4gIHZhciBtaW4gPSBfcmVmLm1pbjtcblxuICB2YXIgbWFya3NLZXlzID0gT2JqZWN0LmtleXMobWFya3MpO1xuICB2YXIgbWFya3NDb3VudCA9IG1hcmtzS2V5cy5sZW5ndGg7XG4gIHZhciB1bml0ID0gMTAwIC8gKG1hcmtzQ291bnQgLSAxKTtcbiAgdmFyIG1hcmtXaWR0aCA9IHVuaXQgKiAwLjk7XG5cbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICB2YXIgZWxlbWVudHMgPSBtYXJrc0tleXMubWFwKHBhcnNlRmxvYXQpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgX2NsYXNzTmFtZXM7XG5cbiAgICB2YXIgaXNBY3RpdmVkID0gIWluY2x1ZGVkICYmIHBvaW50ID09PSB1cHBlckJvdW5kIHx8IGluY2x1ZGVkICYmIHBvaW50IDw9IHVwcGVyQm91bmQgJiYgcG9pbnQgPj0gbG93ZXJCb3VuZDtcbiAgICB2YXIgbWFya0NsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgY2xhc3NOYW1lICsgJy10ZXh0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgY2xhc3NOYW1lICsgJy10ZXh0LWFjdGl2ZScsIGlzQWN0aXZlZCksIF9jbGFzc05hbWVzKSk7XG5cbiAgICB2YXIgYm90dG9tU3R5bGUgPSB7XG4gICAgICAvLyBoZWlnaHQ6IG1hcmtXaWR0aCArICclJyxcbiAgICAgIG1hcmdpbkJvdHRvbTogJy0yMDAnICsgJyUnLFxuICAgICAgYm90dG9tOiAocG9pbnQgLSBtaW4pIC8gcmFuZ2UgKiAxMDAgKyAnJSdcbiAgICB9O1xuXG4gICAgdmFyIGxlZnRTdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBtYXJrV2lkdGggKyAnJScsXG4gICAgICBtYXJnaW5MZWZ0OiAtbWFya1dpZHRoIC8gMiArICclJyxcbiAgICAgIGxlZnQ6IChwb2ludCAtIG1pbikgLyByYW5nZSAqIDEwMCArICclJ1xuICAgIH07XG5cbiAgICB2YXIgc3R5bGUgPSB2ZXJ0aWNhbCA/IGJvdHRvbVN0eWxlIDogbGVmdFN0eWxlO1xuXG4gICAgdmFyIG1hcmtQb2ludCA9IG1hcmtzW3BvaW50XTtcbiAgICB2YXIgbWFya1BvaW50SXNPYmplY3QgPSB0eXBlb2YgbWFya1BvaW50ID09PSAnb2JqZWN0JyAmJiAhX3JlYWN0MlsnZGVmYXVsdCddLmlzVmFsaWRFbGVtZW50KG1hcmtQb2ludCk7XG4gICAgdmFyIG1hcmtMYWJlbCA9IG1hcmtQb2ludElzT2JqZWN0ID8gbWFya1BvaW50LmxhYmVsIDogbWFya1BvaW50O1xuICAgIHZhciBtYXJrU3R5bGUgPSBtYXJrUG9pbnRJc09iamVjdCA/IF9leHRlbmRzKHt9LCBzdHlsZSwgbWFya1BvaW50LnN0eWxlKSA6IHN0eWxlO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdzcGFuJyxcbiAgICAgIHsgY2xhc3NOYW1lOiBtYXJrQ2xhc3NOYW1lLCBzdHlsZTogbWFya1N0eWxlLCBrZXk6IHBvaW50IH0sXG4gICAgICBtYXJrTGFiZWxcbiAgICApO1xuICB9KTtcblxuICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2RpdicsXG4gICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgIGVsZW1lbnRzXG4gICk7XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNYXJrcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVXRpbExpYkRvbUFkZEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdyYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgX3JjVXRpbExpYkRvbUFkZEV2ZW50TGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsTGliRG9tQWRkRXZlbnRMaXN0ZW5lcik7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX1RyYWNrID0gcmVxdWlyZSgnLi9UcmFjaycpO1xuXG52YXIgX1RyYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RyYWNrKTtcblxudmFyIF9IYW5kbGUgPSByZXF1aXJlKCcuL0hhbmRsZScpO1xuXG52YXIgX0hhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IYW5kbGUpO1xuXG52YXIgX1N0ZXBzID0gcmVxdWlyZSgnLi9TdGVwcycpO1xuXG52YXIgX1N0ZXBzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0ZXBzKTtcblxudmFyIF9NYXJrcyA9IHJlcXVpcmUoJy4vTWFya3MnKTtcblxudmFyIF9NYXJrczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXJrcyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc05vdFRvdWNoRXZlbnQoZSkge1xuICByZXR1cm4gZS50b3VjaGVzLmxlbmd0aCA+IDEgfHwgZS50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICd0b3VjaGVuZCcgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoUG9zaXRpb24odmVydGljYWwsIGUpIHtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLnRvdWNoZXNbMF0ucGFnZVg7XG59XG5cbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24odmVydGljYWwsIGUpIHtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZS5jbGllbnRZIDogZS5wYWdlWDtcbn1cblxuZnVuY3Rpb24gcGF1c2VFdmVudChlKSB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxudmFyIFNsaWRlciA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU2xpZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTbGlkZXIocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFNsaWRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIHZhciByYW5nZSA9IHByb3BzLnJhbmdlO1xuICAgIHZhciBtaW4gPSBwcm9wcy5taW47XG4gICAgdmFyIG1heCA9IHByb3BzLm1heDtcblxuICAgIHZhciBpbml0aWFsVmFsdWUgPSByYW5nZSA/IFttaW4sIG1pbl0gOiBtaW47XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9ICdkZWZhdWx0VmFsdWUnIGluIHByb3BzID8gcHJvcHMuZGVmYXVsdFZhbHVlIDogaW5pdGlhbFZhbHVlO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcblxuICAgIHZhciB1cHBlckJvdW5kID0gdW5kZWZpbmVkO1xuICAgIHZhciBsb3dlckJvdW5kID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wcy5yYW5nZSkge1xuICAgICAgbG93ZXJCb3VuZCA9IHRoaXMudHJpbUFsaWduVmFsdWUodmFsdWVbMF0pO1xuICAgICAgdXBwZXJCb3VuZCA9IHRoaXMudHJpbUFsaWduVmFsdWUodmFsdWVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cHBlckJvdW5kID0gdGhpcy50cmltQWxpZ25WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlY2VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcHMucmFuZ2UgJiYgdXBwZXJCb3VuZCA9PT0gbG93ZXJCb3VuZCkge1xuICAgICAgcmVjZW50ID0gbG93ZXJCb3VuZCA9PT0gbWF4ID8gJ2xvd2VyQm91bmQnIDogJ3VwcGVyQm91bmQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnQgPSAndXBwZXJCb3VuZCc7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhbmRsZTogbnVsbCxcbiAgICAgIHJlY2VudDogcmVjZW50LFxuICAgICAgdXBwZXJCb3VuZDogdXBwZXJCb3VuZCxcbiAgICAgIC8vIElmIFNsaWRlciBpcyBub3QgcmFuZ2UsIHNldCBgbG93ZXJCb3VuZGAgZXF1YWwgdG8gYG1pbmAuXG4gICAgICBsb3dlckJvdW5kOiBsb3dlckJvdW5kIHx8IG1pblxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMgfHwgJ21pbicgaW4gbmV4dFByb3BzIHx8ICdtYXgnIGluIG5leHRQcm9wcykpIHJldHVybjtcblxuICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgbG93ZXJCb3VuZCA9IF9zdGF0ZS5sb3dlckJvdW5kO1xuICAgICAgdmFyIHVwcGVyQm91bmQgPSBfc3RhdGUudXBwZXJCb3VuZDtcblxuICAgICAgaWYgKG5leHRQcm9wcy5yYW5nZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWUgfHwgW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdO1xuICAgICAgICB2YXIgbmV4dFVwcGVyQm91bmQgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHZhbHVlWzFdLCBuZXh0UHJvcHMpO1xuICAgICAgICB2YXIgbmV4dExvd2VyQm91bmQgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHZhbHVlWzBdLCBuZXh0UHJvcHMpO1xuICAgICAgICBpZiAobmV4dExvd2VyQm91bmQgPT09IGxvd2VyQm91bmQgJiYgbmV4dFVwcGVyQm91bmQgPT09IHVwcGVyQm91bmQpIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB1cHBlckJvdW5kOiBuZXh0VXBwZXJCb3VuZCxcbiAgICAgICAgICBsb3dlckJvdW5kOiBuZXh0TG93ZXJCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWx1ZU91dE9mQm91bmRzKHVwcGVyQm91bmQsIG5leHRQcm9wcykgfHwgdGhpcy5pc1ZhbHVlT3V0T2ZCb3VuZHMobG93ZXJCb3VuZCwgbmV4dFByb3BzKSkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoW25leHRMb3dlckJvdW5kLCBuZXh0VXBwZXJCb3VuZF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCA/IG5leHRQcm9wcy52YWx1ZSA6IHVwcGVyQm91bmQ7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHZhbHVlLCBuZXh0UHJvcHMpO1xuICAgICAgICBpZiAobmV4dFZhbHVlID09PSB1cHBlckJvdW5kICYmIGxvd2VyQm91bmQgPT09IG5leHRQcm9wcy5taW4pIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB1cHBlckJvdW5kOiBuZXh0VmFsdWUsXG4gICAgICAgICAgbG93ZXJCb3VuZDogbmV4dFByb3BzLm1pblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWx1ZU91dE9mQm91bmRzKHVwcGVyQm91bmQsIG5leHRQcm9wcykpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKHN0YXRlKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGlzTm90Q29udHJvbGxlZCA9ICEoJ3ZhbHVlJyBpbiBwcm9wcyk7XG4gICAgICBpZiAoaXNOb3RDb250cm9sbGVkKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oYW5kbGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhhbmRsZTogc3RhdGUuaGFuZGxlIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCB0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gICAgICB2YXIgY2hhbmdlZFZhbHVlID0gcHJvcHMucmFuZ2UgPyBbZGF0YS5sb3dlckJvdW5kLCBkYXRhLnVwcGVyQm91bmRdIDogZGF0YS51cHBlckJvdW5kO1xuICAgICAgcHJvcHMub25DaGFuZ2UoY2hhbmdlZFZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1vdXNlTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldE1vdXNlUG9zaXRpb24odGhpcy5wcm9wcy52ZXJ0aWNhbCwgZSk7XG4gICAgICB0aGlzLm9uTW92ZShlLCBwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Ub3VjaE1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgICBpZiAoaXNOb3RUb3VjaEV2ZW50KGUpKSB7XG4gICAgICAgIHRoaXMuZW5kKCd0b3VjaCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldFRvdWNoUG9zaXRpb24odGhpcy5wcm9wcy52ZXJ0aWNhbCwgZSk7XG4gICAgICB0aGlzLm9uTW92ZShlLCBwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3ZlKGUsIHBvc2l0aW9uKSB7XG4gICAgICBwYXVzZUV2ZW50KGUpO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIHZhciBkaWZmUG9zaXRpb24gPSBwb3NpdGlvbiAtIHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIGRpZmZQb3NpdGlvbiA9IHRoaXMucHJvcHMudmVydGljYWwgPyAtZGlmZlBvc2l0aW9uIDogZGlmZlBvc2l0aW9uO1xuICAgICAgdmFyIGRpZmZWYWx1ZSA9IGRpZmZQb3NpdGlvbiAvIHRoaXMuZ2V0U2xpZGVyTGVuZ3RoKCkgKiAocHJvcHMubWF4IC0gcHJvcHMubWluKTtcblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy50cmltQWxpZ25WYWx1ZSh0aGlzLnN0YXJ0VmFsdWUgKyBkaWZmVmFsdWUpO1xuICAgICAgdmFyIG9sZFZhbHVlID0gc3RhdGVbc3RhdGUuaGFuZGxlXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcblxuICAgICAgaWYgKHByb3BzLmFsbG93Q3Jvc3MgJiYgdmFsdWUgPCBzdGF0ZS5sb3dlckJvdW5kICYmIHN0YXRlLmhhbmRsZSA9PT0gJ3VwcGVyQm91bmQnKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2Uoe1xuICAgICAgICAgIGhhbmRsZTogJ2xvd2VyQm91bmQnLFxuICAgICAgICAgIGxvd2VyQm91bmQ6IHZhbHVlLFxuICAgICAgICAgIHVwcGVyQm91bmQ6IHRoaXMuc3RhdGUubG93ZXJCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmFsbG93Q3Jvc3MgJiYgdmFsdWUgPiBzdGF0ZS51cHBlckJvdW5kICYmIHN0YXRlLmhhbmRsZSA9PT0gJ2xvd2VyQm91bmQnKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2Uoe1xuICAgICAgICAgIGhhbmRsZTogJ3VwcGVyQm91bmQnLFxuICAgICAgICAgIHVwcGVyQm91bmQ6IHZhbHVlLFxuICAgICAgICAgIGxvd2VyQm91bmQ6IHRoaXMuc3RhdGUudXBwZXJCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uQ2hhbmdlKF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3RhdGUuaGFuZGxlLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uVG91Y2hTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoaXNOb3RUb3VjaEV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldFRvdWNoUG9zaXRpb24odGhpcy5wcm9wcy52ZXJ0aWNhbCwgZSk7XG4gICAgICB0aGlzLm9uU3RhcnQocG9zaXRpb24pO1xuICAgICAgdGhpcy5hZGREb2N1bWVudEV2ZW50cygndG91Y2gnKTtcbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBpZiAoZS5idXR0b24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0TW91c2VQb3NpdGlvbih0aGlzLnByb3BzLnZlcnRpY2FsLCBlKTtcbiAgICAgIHRoaXMub25TdGFydChwb3NpdGlvbik7XG4gICAgICB0aGlzLmFkZERvY3VtZW50RXZlbnRzKCdtb3VzZScpO1xuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblN0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdGFydChwb3NpdGlvbikge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHByb3BzLm9uQmVmb3JlQ2hhbmdlKHRoaXMuZ2V0VmFsdWUoKSk7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsY1ZhbHVlQnlQb3MocG9zaXRpb24pO1xuICAgICAgdGhpcy5zdGFydFZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciB1cHBlckJvdW5kID0gc3RhdGUudXBwZXJCb3VuZDtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gc3RhdGUubG93ZXJCb3VuZDtcblxuICAgICAgdmFyIHZhbHVlTmVlZENoYW5naW5nID0gJ3VwcGVyQm91bmQnO1xuICAgICAgaWYgKHRoaXMucHJvcHMucmFuZ2UpIHtcbiAgICAgICAgdmFyIGlzTG93ZXJCb3VuZENsb3NlciA9IE1hdGguYWJzKHVwcGVyQm91bmQgLSB2YWx1ZSkgPiBNYXRoLmFicyhsb3dlckJvdW5kIC0gdmFsdWUpO1xuICAgICAgICBpZiAoaXNMb3dlckJvdW5kQ2xvc2VyKSB7XG4gICAgICAgICAgdmFsdWVOZWVkQ2hhbmdpbmcgPSAnbG93ZXJCb3VuZCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNBdFRoZVNhbWVQb2ludCA9IHVwcGVyQm91bmQgPT09IGxvd2VyQm91bmQ7XG4gICAgICAgIGlmIChpc0F0VGhlU2FtZVBvaW50KSB7XG4gICAgICAgICAgdmFsdWVOZWVkQ2hhbmdpbmcgPSBzdGF0ZS5yZWNlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBdFRoZVNhbWVQb2ludCAmJiB2YWx1ZSAhPT0gdXBwZXJCb3VuZCkge1xuICAgICAgICAgIHZhbHVlTmVlZENoYW5naW5nID0gdmFsdWUgPCB1cHBlckJvdW5kID8gJ2xvd2VyQm91bmQnIDogJ3VwcGVyQm91bmQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBoYW5kbGU6IHZhbHVlTmVlZENoYW5naW5nLFxuICAgICAgICByZWNlbnQ6IHZhbHVlTmVlZENoYW5naW5nXG4gICAgICB9KTtcblxuICAgICAgdmFyIG9sZFZhbHVlID0gc3RhdGVbdmFsdWVOZWVkQ2hhbmdpbmddO1xuICAgICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLm9uQ2hhbmdlKF9kZWZpbmVQcm9wZXJ0eSh7fSwgdmFsdWVOZWVkQ2hhbmdpbmcsIHZhbHVlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHZhciBfc3RhdGUyID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gX3N0YXRlMi5sb3dlckJvdW5kO1xuICAgICAgdmFyIHVwcGVyQm91bmQgPSBfc3RhdGUyLnVwcGVyQm91bmQ7XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnJhbmdlID8gW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdIDogdXBwZXJCb3VuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTbGlkZXJMZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTbGlkZXJMZW5ndGgoKSB7XG4gICAgICB2YXIgc2xpZGVyID0gdGhpcy5yZWZzLnNsaWRlcjtcbiAgICAgIGlmICghc2xpZGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy52ZXJ0aWNhbCA/IHNsaWRlci5jbGllbnRIZWlnaHQgOiBzbGlkZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2xpZGVyU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTbGlkZXJTdGFydCgpIHtcbiAgICAgIHZhciBzbGlkZXIgPSB0aGlzLnJlZnMuc2xpZGVyO1xuICAgICAgdmFyIHJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnZlcnRpY2FsID8gcmVjdC50b3AgOiByZWN0LmxlZnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJlY2lzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKHN0ZXApIHtcbiAgICAgIHZhciBzdGVwU3RyaW5nID0gc3RlcC50b1N0cmluZygpO1xuICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICBpZiAoc3RlcFN0cmluZy5pbmRleE9mKCcuJykgPj0gMCkge1xuICAgICAgICBwcmVjaXNpb24gPSBzdGVwU3RyaW5nLmxlbmd0aCAtIHN0ZXBTdHJpbmcuaW5kZXhPZignLicpIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVjaXNpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNWYWx1ZU91dE9mQm91bmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWx1ZU91dE9mQm91bmRzKHZhbHVlLCBwcm9wcykge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgcHJvcHMubWluIHx8IHZhbHVlID4gcHJvcHMubWF4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyaW1BbGlnblZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJpbUFsaWduVmFsdWUodiwgbmV4dFByb3BzKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgICAgdmFyIGhhbmRsZSA9IHN0YXRlLmhhbmRsZTtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gc3RhdGUubG93ZXJCb3VuZDtcbiAgICAgIHZhciB1cHBlckJvdW5kID0gc3RhdGUudXBwZXJCb3VuZDtcblxuICAgICAgdmFyIF9leHRlbmRzMiA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCBuZXh0UHJvcHMgfHwge30pO1xuXG4gICAgICB2YXIgbWFya3MgPSBfZXh0ZW5kczIubWFya3M7XG4gICAgICB2YXIgc3RlcCA9IF9leHRlbmRzMi5zdGVwO1xuICAgICAgdmFyIG1pbiA9IF9leHRlbmRzMi5taW47XG4gICAgICB2YXIgbWF4ID0gX2V4dGVuZHMyLm1heDtcbiAgICAgIHZhciBhbGxvd0Nyb3NzID0gX2V4dGVuZHMyLmFsbG93Q3Jvc3M7XG5cbiAgICAgIHZhciB2YWwgPSB2O1xuICAgICAgaWYgKHZhbCA8PSBtaW4pIHtcbiAgICAgICAgdmFsID0gbWluO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA+PSBtYXgpIHtcbiAgICAgICAgdmFsID0gbWF4O1xuICAgICAgfVxuICAgICAgaWYgKCFhbGxvd0Nyb3NzICYmIGhhbmRsZSA9PT0gJ3VwcGVyQm91bmQnICYmIHZhbCA8PSBsb3dlckJvdW5kKSB7XG4gICAgICAgIHZhbCA9IGxvd2VyQm91bmQ7XG4gICAgICB9XG4gICAgICBpZiAoIWFsbG93Q3Jvc3MgJiYgaGFuZGxlID09PSAnbG93ZXJCb3VuZCcgJiYgdmFsID49IHVwcGVyQm91bmQpIHtcbiAgICAgICAgdmFsID0gdXBwZXJCb3VuZDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50cyA9IE9iamVjdC5rZXlzKG1hcmtzKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgICBpZiAoc3RlcCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2xvc2VzdFN0ZXAgPSBNYXRoLnJvdW5kKCh2YWwgLSBtaW4pIC8gc3RlcCkgKiBzdGVwICsgbWluO1xuICAgICAgICBwb2ludHMucHVzaChjbG9zZXN0U3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWZmcyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2YWwgLSBwb2ludCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSBwb2ludHNbZGlmZnMuaW5kZXhPZihNYXRoLm1pbi5hcHBseShNYXRoLCBkaWZmcykpXTtcblxuICAgICAgcmV0dXJuIHN0ZXAgIT09IG51bGwgPyBwYXJzZUZsb2F0KGNsb3Nlc3RQb2ludC50b0ZpeGVkKHRoaXMuZ2V0UHJlY2lzaW9uKHN0ZXApKSkgOiBjbG9zZXN0UG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY09mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNPZmZzZXQodmFsdWUpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIG1pbiA9IF9wcm9wcy5taW47XG4gICAgICB2YXIgbWF4ID0gX3Byb3BzLm1heDtcblxuICAgICAgdmFyIHJhdGlvID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgICAgcmV0dXJuIHJhdGlvICogMTAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGNWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNWYWx1ZShvZmZzZXQpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciB2ZXJ0aWNhbCA9IF9wcm9wczIudmVydGljYWw7XG4gICAgICB2YXIgbWluID0gX3Byb3BzMi5taW47XG4gICAgICB2YXIgbWF4ID0gX3Byb3BzMi5tYXg7XG5cbiAgICAgIHZhciByYXRpbyA9IE1hdGguYWJzKG9mZnNldCAvIHRoaXMuZ2V0U2xpZGVyTGVuZ3RoKCkpO1xuICAgICAgdmFyIHZhbHVlID0gdmVydGljYWwgPyAoMSAtIHJhdGlvKSAqIChtYXggLSBtaW4pICsgbWluIDogcmF0aW8gKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjVmFsdWVCeVBvcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNWYWx1ZUJ5UG9zKHBvc2l0aW9uKSB7XG4gICAgICB2YXIgcGl4ZWxPZmZzZXQgPSBwb3NpdGlvbiAtIHRoaXMuZ2V0U2xpZGVyU3RhcnQoKTtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHRoaXMuY2FsY1ZhbHVlKHBpeGVsT2Zmc2V0KSk7XG4gICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZERvY3VtZW50RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRG9jdW1lbnRFdmVudHModHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgLy8ganVzdCB3b3JrIGZvciBjaHJvbWUgaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBCcm93c2VyXG4gICAgICAgIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lciA9ICgwLCBfcmNVdGlsTGliRG9tQWRkRXZlbnRMaXN0ZW5lcjJbJ2RlZmF1bHQnXSkoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uVG91Y2hVcExpc3RlbmVyID0gKDAsIF9yY1V0aWxMaWJEb21BZGRFdmVudExpc3RlbmVyMlsnZGVmYXVsdCddKShkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5lbmQuYmluZCh0aGlzLCAndG91Y2gnKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyID0gKDAsIF9yY1V0aWxMaWJEb21BZGRFdmVudExpc3RlbmVyMlsnZGVmYXVsdCddKShkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIgPSAoMCwgX3JjVXRpbExpYkRvbUFkZEV2ZW50TGlzdGVuZXIyWydkZWZhdWx0J10pKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuZW5kLmJpbmQodGhpcywgJ21vdXNlJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50cyh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub25Ub3VjaFVwTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCh0eXBlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50cyh0eXBlKTtcbiAgICAgIHRoaXMucHJvcHMub25BZnRlckNoYW5nZSh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhhbmRsZTogbnVsbCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX2NsYXNzTmFtZXM7XG5cbiAgICAgIHZhciBfc3RhdGUzID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBoYW5kbGUgPSBfc3RhdGUzLmhhbmRsZTtcbiAgICAgIHZhciB1cHBlckJvdW5kID0gX3N0YXRlMy51cHBlckJvdW5kO1xuICAgICAgdmFyIGxvd2VyQm91bmQgPSBfc3RhdGUzLmxvd2VyQm91bmQ7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gX3Byb3BzMy5jbGFzc05hbWU7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMy5wcmVmaXhDbHM7XG4gICAgICB2YXIgZGlzYWJsZWQgPSBfcHJvcHMzLmRpc2FibGVkO1xuICAgICAgdmFyIHZlcnRpY2FsID0gX3Byb3BzMy52ZXJ0aWNhbDtcbiAgICAgIHZhciBkb3RzID0gX3Byb3BzMy5kb3RzO1xuICAgICAgdmFyIGluY2x1ZGVkID0gX3Byb3BzMy5pbmNsdWRlZDtcbiAgICAgIHZhciByYW5nZSA9IF9wcm9wczMucmFuZ2U7XG4gICAgICB2YXIgc3RlcCA9IF9wcm9wczMuc3RlcDtcbiAgICAgIHZhciBtYXJrcyA9IF9wcm9wczMubWFya3M7XG4gICAgICB2YXIgbWF4ID0gX3Byb3BzMy5tYXg7XG4gICAgICB2YXIgbWluID0gX3Byb3BzMy5taW47XG4gICAgICB2YXIgdGlwVHJhbnNpdGlvbk5hbWUgPSBfcHJvcHMzLnRpcFRyYW5zaXRpb25OYW1lO1xuICAgICAgdmFyIHRpcEZvcm1hdHRlciA9IF9wcm9wczMudGlwRm9ybWF0dGVyO1xuICAgICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzMy5jaGlsZHJlbjtcblxuICAgICAgdmFyIGN1c3RvbUhhbmRsZSA9IHRoaXMucHJvcHMuaGFuZGxlO1xuXG4gICAgICB2YXIgdXBwZXJPZmZzZXQgPSB0aGlzLmNhbGNPZmZzZXQodXBwZXJCb3VuZCk7XG4gICAgICB2YXIgbG93ZXJPZmZzZXQgPSB0aGlzLmNhbGNPZmZzZXQobG93ZXJCb3VuZCk7XG5cbiAgICAgIHZhciBoYW5kbGVDbGFzc05hbWUgPSBwcmVmaXhDbHMgKyAnLWhhbmRsZSc7XG4gICAgICB2YXIgaXNOb1RpcCA9IHN0ZXAgPT09IG51bGwgfHwgdGlwRm9ybWF0dGVyID09PSBudWxsO1xuXG4gICAgICB2YXIgdXBwZXIgPSAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY3VzdG9tSGFuZGxlLCB7IGNsYXNzTmFtZTogaGFuZGxlQ2xhc3NOYW1lLFxuICAgICAgICBub1RpcDogaXNOb1RpcCwgdGlwVHJhbnNpdGlvbk5hbWU6IHRpcFRyYW5zaXRpb25OYW1lLCB0aXBGb3JtYXR0ZXI6IHRpcEZvcm1hdHRlcixcbiAgICAgICAgdmVydGljYWw6IHZlcnRpY2FsLCBvZmZzZXQ6IHVwcGVyT2Zmc2V0LCB2YWx1ZTogdXBwZXJCb3VuZCwgZHJhZ2dpbmc6IGhhbmRsZSA9PT0gJ3VwcGVyQm91bmQnIH0pO1xuXG4gICAgICB2YXIgbG93ZXIgPSBudWxsO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGxvd2VyID0gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGN1c3RvbUhhbmRsZSwgeyBjbGFzc05hbWU6IGhhbmRsZUNsYXNzTmFtZSxcbiAgICAgICAgICBub1RpcDogaXNOb1RpcCwgdGlwVHJhbnNpdGlvbk5hbWU6IHRpcFRyYW5zaXRpb25OYW1lLCB0aXBGb3JtYXR0ZXI6IHRpcEZvcm1hdHRlcixcbiAgICAgICAgICB2ZXJ0aWNhbDogdmVydGljYWwsIG9mZnNldDogbG93ZXJPZmZzZXQsIHZhbHVlOiBsb3dlckJvdW5kLCBkcmFnZ2luZzogaGFuZGxlID09PSAnbG93ZXJCb3VuZCcgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbGlkZXJDbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIHByZWZpeENscywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgcHJlZml4Q2xzICsgJy1kaXNhYmxlZCcsIGRpc2FibGVkKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBjbGFzc05hbWUsICEhY2xhc3NOYW1lKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBwcmVmaXhDbHMgKyAnLXZlcnRpY2FsJywgdGhpcy5wcm9wcy52ZXJ0aWNhbCksIF9jbGFzc05hbWVzKSk7XG4gICAgICB2YXIgaXNJbmNsdWRlZCA9IGluY2x1ZGVkIHx8IHJhbmdlO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyByZWY6ICdzbGlkZXInLCBjbGFzc05hbWU6IHNsaWRlckNsYXNzTmFtZSxcbiAgICAgICAgICBvblRvdWNoU3RhcnQ6IGRpc2FibGVkID8gbm9vcCA6IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyksXG4gICAgICAgICAgb25Nb3VzZURvd246IGRpc2FibGVkID8gbm9vcCA6IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSB9LFxuICAgICAgICB1cHBlcixcbiAgICAgICAgbG93ZXIsXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9UcmFjazJbJ2RlZmF1bHQnXSwgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdHJhY2snLCB2ZXJ0aWNhbDogdmVydGljYWwsIGluY2x1ZGVkOiBpc0luY2x1ZGVkLFxuICAgICAgICAgIG9mZnNldDogbG93ZXJPZmZzZXQsIGxlbmd0aDogdXBwZXJPZmZzZXQgLSBsb3dlck9mZnNldCB9KSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX1N0ZXBzMlsnZGVmYXVsdCddLCB7IHByZWZpeENsczogcHJlZml4Q2xzLCB2ZXJ0aWNhbDogdmVydGljYWwsIG1hcmtzOiBtYXJrcywgZG90czogZG90cywgc3RlcDogc3RlcCxcbiAgICAgICAgICBpbmNsdWRlZDogaXNJbmNsdWRlZCwgbG93ZXJCb3VuZDogbG93ZXJCb3VuZCxcbiAgICAgICAgICB1cHBlckJvdW5kOiB1cHBlckJvdW5kLCBtYXg6IG1heCwgbWluOiBtaW4gfSksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9NYXJrczJbJ2RlZmF1bHQnXSwgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctbWFyaycsIHZlcnRpY2FsOiB2ZXJ0aWNhbCwgbWFya3M6IG1hcmtzLFxuICAgICAgICAgIGluY2x1ZGVkOiBpc0luY2x1ZGVkLCBsb3dlckJvdW5kOiBsb3dlckJvdW5kLFxuICAgICAgICAgIHVwcGVyQm91bmQ6IHVwcGVyQm91bmQsIG1heDogbWF4LCBtaW46IG1pbiB9KSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5TbGlkZXIucHJvcFR5cGVzID0ge1xuICBtaW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLFxuICBtYXg6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLFxuICBzdGVwOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgZGVmYXVsdFZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsIF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcildKSxcbiAgdmFsdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlciwgX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyKV0pLFxuICBtYXJrczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gIGluY2x1ZGVkOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gIGNsYXNzTmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIHByZWZpeENsczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIGRpc2FibGVkOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gIGNoaWxkcmVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueSxcbiAgb25CZWZvcmVDaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgb25DaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgb25BZnRlckNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICBoYW5kbGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZWxlbWVudCxcbiAgdGlwVHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICB0aXBGb3JtYXR0ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgZG90czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICByYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICB2ZXJ0aWNhbDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBhbGxvd0Nyb3NzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2xcbn07XG5cblNsaWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIHByZWZpeENsczogJ3JjLXNsaWRlcicsXG4gIGNsYXNzTmFtZTogJycsXG4gIHRpcFRyYW5zaXRpb25OYW1lOiAnJyxcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbiAgc3RlcDogMSxcbiAgbWFya3M6IHt9LFxuICBoYW5kbGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9IYW5kbGUyWydkZWZhdWx0J10sIG51bGwpLFxuICBvbkJlZm9yZUNoYW5nZTogbm9vcCxcbiAgb25DaGFuZ2U6IG5vb3AsXG4gIG9uQWZ0ZXJDaGFuZ2U6IG5vb3AsXG4gIHRpcEZvcm1hdHRlcjogZnVuY3Rpb24gdGlwRm9ybWF0dGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBpbmNsdWRlZDogdHJ1ZSxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBkb3RzOiBmYWxzZSxcbiAgcmFuZ2U6IGZhbHNlLFxuICB2ZXJ0aWNhbDogZmFsc2UsXG4gIGFsbG93Q3Jvc3M6IHRydWVcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNsaWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGNhbGNQb2ludHModmVydGljYWwsIG1hcmtzLCBkb3RzLCBzdGVwLCBtaW4sIG1heCkge1xuICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGRvdHMgPyBzdGVwID4gMCA6IHRydWUsICdgU2xpZGVyW3N0ZXBdYCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIgaW4gb3JkZXIgdG8gbWFrZSBTbGlkZXJbZG90c10gd29yay4nKTtcbiAgdmFyIHBvaW50cyA9IE9iamVjdC5rZXlzKG1hcmtzKS5tYXAocGFyc2VGbG9hdCk7XG4gIGlmIChkb3RzKSB7XG4gICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkgPSBpICsgc3RlcCkge1xuICAgICAgaWYgKHBvaW50cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgICAgcG9pbnRzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludHM7XG59XG5cbnZhciBTdGVwcyA9IGZ1bmN0aW9uIFN0ZXBzKF9yZWYpIHtcbiAgdmFyIHByZWZpeENscyA9IF9yZWYucHJlZml4Q2xzO1xuICB2YXIgdmVydGljYWwgPSBfcmVmLnZlcnRpY2FsO1xuICB2YXIgbWFya3MgPSBfcmVmLm1hcmtzO1xuICB2YXIgZG90cyA9IF9yZWYuZG90cztcbiAgdmFyIHN0ZXAgPSBfcmVmLnN0ZXA7XG4gIHZhciBpbmNsdWRlZCA9IF9yZWYuaW5jbHVkZWQ7XG4gIHZhciBsb3dlckJvdW5kID0gX3JlZi5sb3dlckJvdW5kO1xuICB2YXIgdXBwZXJCb3VuZCA9IF9yZWYudXBwZXJCb3VuZDtcbiAgdmFyIG1heCA9IF9yZWYubWF4O1xuICB2YXIgbWluID0gX3JlZi5taW47XG5cbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICB2YXIgZWxlbWVudHMgPSBjYWxjUG9pbnRzKHZlcnRpY2FsLCBtYXJrcywgZG90cywgc3RlcCwgbWluLCBtYXgpLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgX2NsYXNzTmFtZXM7XG5cbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5hYnMocG9pbnQgLSBtaW4pIC8gcmFuZ2UgKiAxMDAgKyAnJSc7XG4gICAgdmFyIHN0eWxlID0gdmVydGljYWwgPyB7IGJvdHRvbTogb2Zmc2V0IH0gOiB7IGxlZnQ6IG9mZnNldCB9O1xuXG4gICAgdmFyIGlzQWN0aXZlZCA9ICFpbmNsdWRlZCAmJiBwb2ludCA9PT0gdXBwZXJCb3VuZCB8fCBpbmNsdWRlZCAmJiBwb2ludCA8PSB1cHBlckJvdW5kICYmIHBvaW50ID49IGxvd2VyQm91bmQ7XG4gICAgdmFyIHBvaW50Q2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKSgoX2NsYXNzTmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBwcmVmaXhDbHMgKyAnLWRvdCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIHByZWZpeENscyArICctZG90LWFjdGl2ZScsIGlzQWN0aXZlZCksIF9jbGFzc05hbWVzKSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogcG9pbnRDbGFzc05hbWUsIHN0eWxlOiBzdHlsZSwga2V5OiBwb2ludCB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICdkaXYnLFxuICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXN0ZXAnIH0sXG4gICAgZWxlbWVudHNcbiAgKTtcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN0ZXBzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBUcmFjayA9IGZ1bmN0aW9uIFRyYWNrKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuICB2YXIgaW5jbHVkZWQgPSBfcmVmLmluY2x1ZGVkO1xuICB2YXIgdmVydGljYWwgPSBfcmVmLnZlcnRpY2FsO1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBsZW5ndGggPSBfcmVmLmxlbmd0aDtcblxuICB2YXIgc3R5bGUgPSB7XG4gICAgdmlzaWJpbGl0eTogaW5jbHVkZWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xuICB9O1xuICBpZiAodmVydGljYWwpIHtcbiAgICBzdHlsZS5ib3R0b20gPSBvZmZzZXQgKyAnJSc7XG4gICAgc3R5bGUuaGVpZ2h0ID0gbGVuZ3RoICsgJyUnO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmxlZnQgPSBvZmZzZXQgKyAnJSc7XG4gICAgc3R5bGUud2lkdGggPSBsZW5ndGggKyAnJSc7XG4gIH1cbiAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUcmFjaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1NsaWRlcicpOyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcGxhY2VtZW50cyA9IHJlcXVpcmUoJy4vcGxhY2VtZW50cycpO1xuXG52YXIgX3JjVHJpZ2dlciA9IHJlcXVpcmUoJ3JjLXRyaWdnZXInKTtcblxudmFyIF9yY1RyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUcmlnZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRvb2x0aXAgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVG9vbHRpcCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdHJpZ2dlcjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGRlZmF1bHRWaXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb25WaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgYWZ0ZXJWaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3ZlcmxheTogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ub2RlLCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuY10pLmlzUmVxdWlyZWQsXG4gICAgb3ZlcmxheVN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvdmVybGF5Q2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1vdXNlRW50ZXJEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgbW91c2VMZWF2ZURlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBnZXRUb29sdGlwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGVzdHJveVRvb2x0aXBPbkhpZGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgYXJyb3dDb250ZW50OiBfcmVhY3QuUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy10b29sdGlwJyxcbiAgICAgIG1vdXNlRW50ZXJEZWxheTogMCxcbiAgICAgIGRlc3Ryb3lUb29sdGlwT25IaWRlOiBmYWxzZSxcbiAgICAgIG1vdXNlTGVhdmVEZWxheTogMC4xLFxuICAgICAgYWxpZ246IHt9LFxuICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgdHJpZ2dlcjogWydob3ZlciddLFxuICAgICAgYXJyb3dDb250ZW50OiBudWxsXG4gICAgfTtcbiAgfSxcbiAgZ2V0UG9wdXBFbGVtZW50OiBmdW5jdGlvbiBnZXRQb3B1cEVsZW1lbnQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFycm93Q29udGVudCA9IF9wcm9wcy5hcnJvd0NvbnRlbnQ7XG4gICAgdmFyIG92ZXJsYXkgPSBfcHJvcHMub3ZlcmxheTtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzLnByZWZpeENscztcblxuICAgIHJldHVybiBbX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctYXJyb3cnLCBrZXk6ICdhcnJvdycgfSxcbiAgICAgIGFycm93Q29udGVudFxuICAgICksIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlubmVyJywga2V5OiAnY29udGVudCcgfSxcbiAgICAgIHR5cGVvZiBvdmVybGF5ID09PSAnZnVuY3Rpb24nID8gb3ZlcmxheSgpIDogb3ZlcmxheVxuICAgICldO1xuICB9LFxuICBnZXRQb3B1cERvbU5vZGU6IGZ1bmN0aW9uIGdldFBvcHVwRG9tTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZzLnRyaWdnZXIuZ2V0UG9wdXBEb21Ob2RlKCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgb3ZlcmxheUNsYXNzTmFtZSA9IF9wcm9wczIub3ZlcmxheUNsYXNzTmFtZTtcbiAgICB2YXIgdHJpZ2dlciA9IF9wcm9wczIudHJpZ2dlcjtcbiAgICB2YXIgbW91c2VFbnRlckRlbGF5ID0gX3Byb3BzMi5tb3VzZUVudGVyRGVsYXk7XG4gICAgdmFyIG1vdXNlTGVhdmVEZWxheSA9IF9wcm9wczIubW91c2VMZWF2ZURlbGF5O1xuICAgIHZhciBvdmVybGF5U3R5bGUgPSBfcHJvcHMyLm92ZXJsYXlTdHlsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMi5wcmVmaXhDbHM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzMi5jaGlsZHJlbjtcbiAgICB2YXIgb25WaXNpYmxlQ2hhbmdlID0gX3Byb3BzMi5vblZpc2libGVDaGFuZ2U7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gX3Byb3BzMi50cmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uID0gX3Byb3BzMi5hbmltYXRpb247XG4gICAgdmFyIHBsYWNlbWVudCA9IF9wcm9wczIucGxhY2VtZW50O1xuICAgIHZhciBhbGlnbiA9IF9wcm9wczIuYWxpZ247XG4gICAgdmFyIGRlc3Ryb3lUb29sdGlwT25IaWRlID0gX3Byb3BzMi5kZXN0cm95VG9vbHRpcE9uSGlkZTtcbiAgICB2YXIgZGVmYXVsdFZpc2libGUgPSBfcHJvcHMyLmRlZmF1bHRWaXNpYmxlO1xuICAgIHZhciBnZXRUb29sdGlwQ29udGFpbmVyID0gX3Byb3BzMi5nZXRUb29sdGlwQ29udGFpbmVyO1xuXG4gICAgdmFyIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMyLCBbJ292ZXJsYXlDbGFzc05hbWUnLCAndHJpZ2dlcicsICdtb3VzZUVudGVyRGVsYXknLCAnbW91c2VMZWF2ZURlbGF5JywgJ292ZXJsYXlTdHlsZScsICdwcmVmaXhDbHMnLCAnY2hpbGRyZW4nLCAnb25WaXNpYmxlQ2hhbmdlJywgJ3RyYW5zaXRpb25OYW1lJywgJ2FuaW1hdGlvbicsICdwbGFjZW1lbnQnLCAnYWxpZ24nLCAnZGVzdHJveVRvb2x0aXBPbkhpZGUnLCAnZGVmYXVsdFZpc2libGUnLCAnZ2V0VG9vbHRpcENvbnRhaW5lciddKTtcblxuICAgIHZhciBleHRyYVByb3BzID0gX2V4dGVuZHMoe30sIHJlc3RQcm9wcyk7XG4gICAgaWYgKCd2aXNpYmxlJyBpbiB0aGlzLnByb3BzKSB7XG4gICAgICBleHRyYVByb3BzLnBvcHVwVmlzaWJsZSA9IHRoaXMucHJvcHMudmlzaWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNUcmlnZ2VyMltcImRlZmF1bHRcIl0sXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIHBvcHVwQ2xhc3NOYW1lOiBvdmVybGF5Q2xhc3NOYW1lLFxuICAgICAgICByZWY6ICd0cmlnZ2VyJyxcbiAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICAgIHBvcHVwOiB0aGlzLmdldFBvcHVwRWxlbWVudCxcbiAgICAgICAgYWN0aW9uOiB0cmlnZ2VyLFxuICAgICAgICBidWlsdGluUGxhY2VtZW50czogX3BsYWNlbWVudHMucGxhY2VtZW50cyxcbiAgICAgICAgcG9wdXBQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgcG9wdXBBbGlnbjogYWxpZ24sXG4gICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiBnZXRUb29sdGlwQ29udGFpbmVyLFxuICAgICAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogb25WaXNpYmxlQ2hhbmdlLFxuICAgICAgICBwb3B1cFRyYW5zaXRpb25OYW1lOiB0cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgcG9wdXBBbmltYXRpb246IGFuaW1hdGlvbixcbiAgICAgICAgZGVmYXVsdFBvcHVwVmlzaWJsZTogZGVmYXVsdFZpc2libGUsXG4gICAgICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogZGVzdHJveVRvb2x0aXBPbkhpZGUsXG4gICAgICAgIG1vdXNlTGVhdmVEZWxheTogbW91c2VMZWF2ZURlbGF5LFxuICAgICAgICBwb3B1cFN0eWxlOiBvdmVybGF5U3R5bGUsXG4gICAgICAgIG1vdXNlRW50ZXJEZWxheTogbW91c2VFbnRlckRlbGF5XG4gICAgICB9LCBleHRyYVByb3BzKSxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVG9vbHRpcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1Rvb2x0aXAnKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXV0b0FkanVzdE92ZXJmbG93ID0ge1xuICBhZGp1c3RYOiAxLFxuICBhZGp1c3RZOiAxXG59O1xuXG52YXIgdGFyZ2V0T2Zmc2V0ID0gWzAsIDBdO1xuXG52YXIgcGxhY2VtZW50cyA9IGV4cG9ydHMucGxhY2VtZW50cyA9IHtcbiAgbGVmdDoge1xuICAgIHBvaW50czogWydjcicsICdjbCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbLTQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ2NsJywgJ2NyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFs0LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICB0b3A6IHtcbiAgICBwb2ludHM6IFsnYmMnLCAndGMnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIC00XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICBib3R0b206IHtcbiAgICBwb2ludHM6IFsndGMnLCAnYmMnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHRvcExlZnQ6IHtcbiAgICBwb2ludHM6IFsnYmwnLCAndGwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIC00XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICBsZWZ0VG9wOiB7XG4gICAgcG9pbnRzOiBbJ3RyJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFstNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsnYnInLCAndHInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIC00XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICByaWdodFRvcDoge1xuICAgIHBvaW50czogWyd0bCcsICd0ciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsndHInLCAnYnInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHJpZ2h0Qm90dG9tOiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ2JyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFs0LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICBib3R0b21MZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ3RsJywgJ2JsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCA0XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICBsZWZ0Qm90dG9tOiB7XG4gICAgcG9pbnRzOiBbJ2JyJywgJ2JsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFstNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwbGFjZW1lbnRzOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgTGF6eVJlbmRlckJveCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdMYXp5UmVuZGVyQm94JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaGlkZGVuQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gbmV4dFByb3BzLmhpZGRlbkNsYXNzTmFtZSB8fCBuZXh0UHJvcHMudmlzaWJsZTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGhpZGRlbkNsYXNzTmFtZSA9IF9wcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgdmFyIHZpc2libGUgPSBfcHJvcHMudmlzaWJsZTtcblxuICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnaGlkZGVuQ2xhc3NOYW1lJywgJ3Zpc2libGUnXSk7XG5cbiAgICBpZiAoaGlkZGVuQ2xhc3NOYW1lIHx8IF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDEpIHtcbiAgICAgIGlmICghdmlzaWJsZSAmJiBoaWRkZW5DbGFzc05hbWUpIHtcbiAgICAgICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIGhpZGRlbkNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdkaXYnLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLm9ubHkocHJvcHMuY2hpbGRyZW4pO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBMYXp5UmVuZGVyQm94O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcmNBbGlnbiA9IHJlcXVpcmUoJ3JjLWFsaWduJyk7XG5cbnZhciBfcmNBbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FsaWduKTtcblxudmFyIF9yY0FuaW1hdGUgPSByZXF1aXJlKCdyYy1hbmltYXRlJyk7XG5cbnZhciBfcmNBbmltYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQW5pbWF0ZSk7XG5cbnZhciBfUG9wdXBJbm5lciA9IHJlcXVpcmUoJy4vUG9wdXBJbm5lcicpO1xuXG52YXIgX1BvcHVwSW5uZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9wdXBJbm5lcik7XG5cbnZhciBfTGF6eVJlbmRlckJveCA9IHJlcXVpcmUoJy4vTGF6eVJlbmRlckJveCcpO1xuXG52YXIgX0xhenlSZW5kZXJCb3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGF6eVJlbmRlckJveCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgUG9wdXAgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUG9wdXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgZ2V0Q2xhc3NOYW1lRnJvbUFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25BbGlnbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGdldFJvb3REb21Ob2RlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgYWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbk1vdXNlTGVhdmU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnJvb3ROb2RlID0gdGhpcy5nZXRQb3B1cERvbU5vZGUoKTtcbiAgfSxcbiAgb25BbGlnbjogZnVuY3Rpb24gb25BbGlnbihwb3B1cERvbU5vZGUsIGFsaWduKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWxpZ25DbGFzc05hbWUgPSBwcm9wcy5nZXRDbGFzc05hbWVGcm9tQWxpZ24ocHJvcHMuYWxpZ24pO1xuICAgIHZhciBjdXJyZW50QWxpZ25DbGFzc05hbWUgPSBwcm9wcy5nZXRDbGFzc05hbWVGcm9tQWxpZ24oYWxpZ24pO1xuICAgIGlmIChhbGlnbkNsYXNzTmFtZSAhPT0gY3VycmVudEFsaWduQ2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRBbGlnbkNsYXNzTmFtZSA9IGN1cnJlbnRBbGlnbkNsYXNzTmFtZTtcbiAgICAgIHBvcHVwRG9tTm9kZS5jbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZShjdXJyZW50QWxpZ25DbGFzc05hbWUpO1xuICAgIH1cbiAgICBwcm9wcy5vbkFsaWduKHBvcHVwRG9tTm9kZSwgYWxpZ24pO1xuICB9LFxuICBnZXRQb3B1cERvbU5vZGU6IGZ1bmN0aW9uIGdldFBvcHVwRG9tTm9kZSgpIHtcbiAgICByZXR1cm4gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcy5yZWZzLnBvcHVwKTtcbiAgfSxcbiAgZ2V0VGFyZ2V0OiBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuZ2V0Um9vdERvbU5vZGUoKTtcbiAgfSxcbiAgZ2V0TWFza1RyYW5zaXRpb25OYW1lOiBmdW5jdGlvbiBnZXRNYXNrVHJhbnNpdGlvbk5hbWUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5tYXNrVHJhbnNpdGlvbk5hbWU7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHByb3BzLm1hc2tBbmltYXRpb247XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBhbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy0nICsgYW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIGdldFRyYW5zaXRpb25OYW1lOiBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIGlmICghdHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnByZWZpeENscyArICctJyArIHByb3BzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25OYW1lO1xuICB9LFxuICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uIGdldENsYXNzTmFtZShjdXJyZW50QWxpZ25DbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnICcgKyB0aGlzLnByb3BzLmNsYXNzTmFtZSArICcgJyArIGN1cnJlbnRBbGlnbkNsYXNzTmFtZTtcbiAgfSxcbiAgZ2V0UG9wdXBFbGVtZW50OiBmdW5jdGlvbiBnZXRQb3B1cEVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICB2YXIgc3R5bGUgPSBwcm9wcy5zdHlsZTtcbiAgICB2YXIgdmlzaWJsZSA9IHByb3BzLnZpc2libGU7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgZGVzdHJveVBvcHVwT25IaWRlID0gcHJvcHMuZGVzdHJveVBvcHVwT25IaWRlO1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lIHx8IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihhbGlnbikpO1xuICAgIHZhciBoaWRkZW5DbGFzc05hbWUgPSBwcmVmaXhDbHMgKyAnLWhpZGRlbic7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRBbGlnbkNsYXNzTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBuZXdTdHlsZSA9IF9leHRlbmRzKHt9LCBzdHlsZSwgdGhpcy5nZXRaSW5kZXhTdHlsZSgpKTtcbiAgICB2YXIgcG9wdXBJbm5lclByb3BzID0ge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgIHJlZjogJ3BvcHVwJyxcbiAgICAgIG9uTW91c2VFbnRlcjogcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICBzdHlsZTogbmV3U3R5bGVcbiAgICB9O1xuICAgIGlmIChkZXN0cm95UG9wdXBPbkhpZGUpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbmltYXRlMltcImRlZmF1bHRcIl0sXG4gICAgICAgIHtcbiAgICAgICAgICBjb21wb25lbnQ6ICcnLFxuICAgICAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cnVlLFxuICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiB0aGlzLmdldFRyYW5zaXRpb25OYW1lKClcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZSA/IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX3JjQWxpZ24yW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0LFxuICAgICAgICAgICAga2V5OiAncG9wdXAnLFxuICAgICAgICAgICAgcmVmOiB0aGlzLnNhdmVBbGlnbixcbiAgICAgICAgICAgIG1vbml0b3JXaW5kb3dSZXNpemU6IHRydWUsXG4gICAgICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgICAgICBvbkFsaWduOiB0aGlzLm9uQWxpZ25cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBfUG9wdXBJbm5lcjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgICAgICB9LCBwb3B1cElubmVyUHJvcHMpLFxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICApXG4gICAgICAgICkgOiBudWxsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgIF9yY0FuaW1hdGUyW1wiZGVmYXVsdFwiXSxcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50OiAnJyxcbiAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uTmFtZTogdGhpcy5nZXRUcmFuc2l0aW9uTmFtZSgpLFxuICAgICAgICBzaG93UHJvcDogJ3hWaXNpYmxlJ1xuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9yY0FsaWduMltcImRlZmF1bHRcIl0sXG4gICAgICAgIHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0LFxuICAgICAgICAgIGtleTogJ3BvcHVwJyxcbiAgICAgICAgICByZWY6IHRoaXMuc2F2ZUFsaWduLFxuICAgICAgICAgIG1vbml0b3JXaW5kb3dSZXNpemU6IHRydWUsXG4gICAgICAgICAgeFZpc2libGU6IHZpc2libGUsXG4gICAgICAgICAgY2hpbGRyZW5Qcm9wczogeyB2aXNpYmxlOiAneFZpc2libGUnIH0sXG4gICAgICAgICAgZGlzYWJsZWQ6ICF2aXNpYmxlLFxuICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICBvbkFsaWduOiB0aGlzLm9uQWxpZ25cbiAgICAgICAgfSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfUG9wdXBJbm5lcjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGhpZGRlbkNsYXNzTmFtZTogaGlkZGVuQ2xhc3NOYW1lXG4gICAgICAgICAgfSwgcG9wdXBJbm5lclByb3BzKSxcbiAgICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgZ2V0WkluZGV4U3R5bGU6IGZ1bmN0aW9uIGdldFpJbmRleFN0eWxlKCkge1xuICAgIHZhciBzdHlsZSA9IHt9O1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHByb3BzLnpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHlsZS56SW5kZXggPSBwcm9wcy56SW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgZ2V0TWFza0VsZW1lbnQ6IGZ1bmN0aW9uIGdldE1hc2tFbGVtZW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG1hc2tFbGVtZW50ID0gdm9pZCAwO1xuICAgIGlmIChwcm9wcy5tYXNrKSB7XG4gICAgICB2YXIgbWFza1RyYW5zaXRpb24gPSB0aGlzLmdldE1hc2tUcmFuc2l0aW9uTmFtZSgpO1xuICAgICAgbWFza0VsZW1lbnQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXp5UmVuZGVyQm94MltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgc3R5bGU6IHRoaXMuZ2V0WkluZGV4U3R5bGUoKSxcbiAgICAgICAga2V5OiAnbWFzaycsXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1tYXNrJyxcbiAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLW1hc2staGlkZGVuJyxcbiAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZVxuICAgICAgfSk7XG4gICAgICBpZiAobWFza1RyYW5zaXRpb24pIHtcbiAgICAgICAgbWFza0VsZW1lbnQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9yY0FuaW1hdGUyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdtYXNrJyxcbiAgICAgICAgICAgIHNob3dQcm9wOiAndmlzaWJsZScsXG4gICAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cnVlLFxuICAgICAgICAgICAgY29tcG9uZW50OiAnJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiBtYXNrVHJhbnNpdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFza0VsZW1lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tFbGVtZW50O1xuICB9LFxuICBzYXZlQWxpZ246IGZ1bmN0aW9uIHNhdmVBbGlnbihhbGlnbikge1xuICAgIHRoaXMuYWxpZ25JbnN0YW5jZSA9IGFsaWduO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuZ2V0TWFza0VsZW1lbnQoKSxcbiAgICAgIHRoaXMuZ2V0UG9wdXBFbGVtZW50KClcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQb3B1cDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xhenlSZW5kZXJCb3ggPSByZXF1aXJlKCcuL0xhenlSZW5kZXJCb3gnKTtcblxudmFyIF9MYXp5UmVuZGVyQm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhenlSZW5kZXJCb3gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFBvcHVwSW5uZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUG9wdXBJbm5lcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlkZGVuQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICBpZiAoIXByb3BzLnZpc2libGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBwcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9MYXp5UmVuZGVyQm94MltcImRlZmF1bHRcIl0sXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWNvbnRlbnQnLCB2aXNpYmxlOiBwcm9wcy52aXNpYmxlIH0sXG4gICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXBJbm5lcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24gPSByZXF1aXJlKCdyYy11dGlsL2xpYi9jcmVhdGVDaGFpbmVkRnVuY3Rpb24nKTtcblxudmFyIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKTtcblxudmFyIF9jb250YWlucyA9IHJlcXVpcmUoJ3JjLXV0aWwvbGliL0RvbS9jb250YWlucycpO1xuXG52YXIgX2NvbnRhaW5zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRhaW5zKTtcblxudmFyIF9hZGRFdmVudExpc3RlbmVyID0gcmVxdWlyZSgncmMtdXRpbC9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXInKTtcblxudmFyIF9hZGRFdmVudExpc3RlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZEV2ZW50TGlzdGVuZXIpO1xuXG52YXIgX1BvcHVwID0gcmVxdWlyZSgnLi9Qb3B1cCcpO1xuXG52YXIgX1BvcHVwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiByZXR1cm5FbXB0eVN0cmluZygpIHtcbiAgcmV0dXJuICcnO1xufVxuXG52YXIgQUxMX0hBTkRMRVJTID0gWydvbkNsaWNrJywgJ29uTW91c2VEb3duJywgJ29uVG91Y2hTdGFydCcsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJywgJ29uRm9jdXMnLCAnb25CbHVyJ107XG5cbnZhciBUcmlnZ2VyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1RyaWdnZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGFjdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgc2hvd0FjdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgaGlkZUFjdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIG9uUG9wdXBWaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgYWZ0ZXJQb3B1cFZpc2libGVDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwb3B1cDogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMubm9kZSwgX3JlYWN0LlByb3BUeXBlcy5mdW5jXSkuaXNSZXF1aXJlZCxcbiAgICBwb3B1cFN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwb3B1cFBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYnVpbHRpblBsYWNlbWVudHM6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBvcHVwVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwQW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBtb3VzZUVudGVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1vdXNlTGVhdmVEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgekluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBmb2N1c0RlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBibHVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGVzdHJveVBvcHVwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbWFzazogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uUG9wdXBBbGlnbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHBvcHVwQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBvcHVwVmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG1hc2tUcmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbWFza0FuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtdHJpZ2dlci1wb3B1cCcsXG4gICAgICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogcmV0dXJuRW1wdHlTdHJpbmcsXG4gICAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICAgIGFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgb25Qb3B1cEFsaWduOiBub29wLFxuICAgICAgcG9wdXBDbGFzc05hbWU6ICcnLFxuICAgICAgbW91c2VFbnRlckRlbGF5OiAwLFxuICAgICAgbW91c2VMZWF2ZURlbGF5OiAwLjEsXG4gICAgICBmb2N1c0RlbGF5OiAwLFxuICAgICAgYmx1ckRlbGF5OiAwLjE1LFxuICAgICAgcG9wdXBTdHlsZToge30sXG4gICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IGZhbHNlLFxuICAgICAgcG9wdXBBbGlnbjoge30sXG4gICAgICBkZWZhdWx0UG9wdXBWaXNpYmxlOiBmYWxzZSxcbiAgICAgIG1hc2s6IGZhbHNlLFxuICAgICAgYWN0aW9uOiBbXSxcbiAgICAgIHNob3dBY3Rpb246IFtdLFxuICAgICAgaGlkZUFjdGlvbjogW11cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwb3B1cFZpc2libGUgPSB2b2lkIDA7XG4gICAgaWYgKCdwb3B1cFZpc2libGUnIGluIHByb3BzKSB7XG4gICAgICBwb3B1cFZpc2libGUgPSAhIXByb3BzLnBvcHVwVmlzaWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wdXBWaXNpYmxlID0gISFwcm9wcy5kZWZhdWx0UG9wdXBWaXNpYmxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9wdXBWaXNpYmxlOiBwb3B1cFZpc2libGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoe30sIHtcbiAgICAgIHBvcHVwVmlzaWJsZTogdGhpcy5zdGF0ZS5wb3B1cFZpc2libGVcbiAgICB9KTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoJ3BvcHVwVmlzaWJsZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcG9wdXBWaXNpYmxlOiAhIW5leHRQcm9wcy5wb3B1cFZpc2libGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0aGlzLnBvcHVwUmVuZGVyZWQpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihfdGhpcywgX3RoaXMuZ2V0UG9wdXBFbGVtZW50KCksIF90aGlzLmdldFBvcHVwQ29udGFpbmVyKCksIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgICAgc2VsZi5wb3B1cEluc3RhbmNlID0gdGhpcztcbiAgICAgICAgICBpZiAocHJldlN0YXRlLnBvcHVwVmlzaWJsZSAhPT0gc3RhdGUucG9wdXBWaXNpYmxlKSB7XG4gICAgICAgICAgICBwcm9wcy5hZnRlclBvcHVwVmlzaWJsZUNoYW5nZShzdGF0ZS5wb3B1cFZpc2libGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfdGhpcy5pc0NsaWNrVG9IaWRlKCkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUucG9wdXBWaXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9ICgwLCBfYWRkRXZlbnRMaXN0ZW5lcjJbXCJkZWZhdWx0XCJdKShkb2N1bWVudCwgJ21vdXNlZG93bicsIF90aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSAoMCwgX2FkZEV2ZW50TGlzdGVuZXIyW1wiZGVmYXVsdFwiXSkoZG9jdW1lbnQsICd0b3VjaHN0YXJ0JywgX3RoaXMub25Eb2N1bWVudENsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIpIHtcbiAgICAgICAgICBfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIucmVtb3ZlKCk7XG4gICAgICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgX3RoaXMudG91Y2hPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCh0eXBlb2YgX3JldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldCkpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBwb3B1cENvbnRhaW5lciA9IHRoaXMucG9wdXBDb250YWluZXI7XG4gICAgaWYgKHBvcHVwQ29udGFpbmVyKSB7XG4gICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS51bm1vdW50Q29tcG9uZW50QXROb2RlKHBvcHVwQ29udGFpbmVyKTtcbiAgICAgIHBvcHVwQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wdXBDb250YWluZXIpO1xuICAgICAgdGhpcy5wb3B1cENvbnRhaW5lciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlcikge1xuICAgICAgdGhpcy5jbGlja091dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5jbGlja091dHNpZGVIYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMudG91Y2hPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICB0aGlzLmRlbGF5U2V0UG9wdXBWaXNpYmxlKHRydWUsIHRoaXMucHJvcHMubW91c2VFbnRlckRlbGF5KTtcbiAgfSxcbiAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvdHJpZ2dlci9wdWxsLzEzXG4gICAgLy8gcmVhY3QgYnVnP1xuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgJiYgIWUucmVsYXRlZFRhcmdldC5zZXRUaW1lb3V0ICYmICgwLCBfY29udGFpbnMyW1wiZGVmYXVsdFwiXSkodGhpcy5wb3B1cENvbnRhaW5lciwgZS5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlbGF5U2V0UG9wdXBWaXNpYmxlKGZhbHNlLCB0aGlzLnByb3BzLm1vdXNlTGVhdmVEZWxheSk7XG4gIH0sXG4gIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7XG4gICAgLy8gaW5jYXNlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZXIoKTtcbiAgICBpZiAodGhpcy5pc0ZvY3VzVG9TaG93KCkpIHtcbiAgICAgIHRoaXMuZm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUodHJ1ZSwgdGhpcy5wcm9wcy5mb2N1c0RlbGF5KTtcbiAgICB9XG4gIH0sXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbiBvbk1vdXNlRG93bigpIHtcbiAgICB0aGlzLnByZUNsaWNrVGltZSA9IERhdGUubm93KCk7XG4gIH0sXG4gIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCkge1xuICAgIHRoaXMucHJlVG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgfSxcbiAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZXIoKTtcbiAgICBpZiAodGhpcy5pc0JsdXJUb0hpZGUoKSkge1xuICAgICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZShmYWxzZSwgdGhpcy5wcm9wcy5ibHVyRGVsYXkpO1xuICAgIH1cbiAgfSxcbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIC8vIGZvY3VzIHdpbGwgdHJpZ2dlciBjbGlja1xuICAgIGlmICh0aGlzLmZvY3VzVGltZSkge1xuICAgICAgdmFyIHByZVRpbWUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wcmVDbGlja1RpbWUgJiYgdGhpcy5wcmVUb3VjaFRpbWUpIHtcbiAgICAgICAgcHJlVGltZSA9IE1hdGgubWluKHRoaXMucHJlQ2xpY2tUaW1lLCB0aGlzLnByZVRvdWNoVGltZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJlQ2xpY2tUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSB0aGlzLnByZUNsaWNrVGltZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVUb3VjaFRpbWUpIHtcbiAgICAgICAgcHJlVGltZSA9IHRoaXMucHJlVG91Y2hUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHByZVRpbWUgLSB0aGlzLmZvY3VzVGltZSkgPCAyMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzVGltZSA9IDA7XG4gICAgfVxuICAgIHRoaXMucHJlQ2xpY2tUaW1lID0gMDtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IDA7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgbmV4dFZpc2libGUgPSAhdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgaWYgKHRoaXMuaXNDbGlja1RvSGlkZSgpICYmICFuZXh0VmlzaWJsZSB8fCBuZXh0VmlzaWJsZSAmJiB0aGlzLmlzQ2xpY2tUb1Nob3coKSkge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUoIXRoaXMuc3RhdGUucG9wdXBWaXNpYmxlKTtcbiAgICB9XG4gIH0sXG4gIG9uRG9jdW1lbnRDbGljazogZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgcm9vdCA9ICgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpO1xuICAgIHZhciBwb3B1cE5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICAgIGlmICghKDAsIF9jb250YWluczJbXCJkZWZhdWx0XCJdKShyb290LCB0YXJnZXQpICYmICEoMCwgX2NvbnRhaW5zMltcImRlZmF1bHRcIl0pKHBvcHVwTm9kZSwgdGFyZ2V0KSkge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUoZmFsc2UpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UG9wdXBEb21Ob2RlOiBmdW5jdGlvbiBnZXRQb3B1cERvbU5vZGUoKSB7XG4gICAgLy8gZm9yIHRlc3RcbiAgICBpZiAodGhpcy5wb3B1cEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3B1cEluc3RhbmNlLmlzTW91bnRlZCgpID8gdGhpcy5wb3B1cEluc3RhbmNlLmdldFBvcHVwRG9tTm9kZSgpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGdldFJvb3REb21Ob2RlOiBmdW5jdGlvbiBnZXRSb290RG9tTm9kZSgpIHtcbiAgICByZXR1cm4gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyk7XG4gIH0sXG4gIGdldFBvcHVwQ29udGFpbmVyOiBmdW5jdGlvbiBnZXRQb3B1cENvbnRhaW5lcigpIHtcbiAgICBpZiAoIXRoaXMucG9wdXBDb250YWluZXIpIHtcbiAgICAgIHRoaXMucG9wdXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHZhciBtb3VudE5vZGUgPSB0aGlzLnByb3BzLmdldFBvcHVwQ29udGFpbmVyID8gdGhpcy5wcm9wcy5nZXRQb3B1cENvbnRhaW5lcigoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzKSkgOiBkb2N1bWVudC5ib2R5O1xuICAgICAgbW91bnROb2RlLmFwcGVuZENoaWxkKHRoaXMucG9wdXBDb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb3B1cENvbnRhaW5lcjtcbiAgfSxcbiAgZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ246IGZ1bmN0aW9uIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IFtdO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBvcHVwUGxhY2VtZW50ID0gcHJvcHMucG9wdXBQbGFjZW1lbnQ7XG4gICAgdmFyIGJ1aWx0aW5QbGFjZW1lbnRzID0gcHJvcHMuYnVpbHRpblBsYWNlbWVudHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuICAgIGlmIChwb3B1cFBsYWNlbWVudCAmJiBidWlsdGluUGxhY2VtZW50cykge1xuICAgICAgY2xhc3NOYW1lLnB1c2goKDAsIF91dGlscy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbikoYnVpbHRpblBsYWNlbWVudHMsIHByZWZpeENscywgYWxpZ24pKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKSB7XG4gICAgICBjbGFzc05hbWUucHVzaChwcm9wcy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbihhbGlnbikpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lLmpvaW4oJyAnKTtcbiAgfSxcbiAgZ2V0UG9wdXBBbGlnbjogZnVuY3Rpb24gZ2V0UG9wdXBBbGlnbigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwb3B1cFBsYWNlbWVudCA9IHByb3BzLnBvcHVwUGxhY2VtZW50O1xuICAgIHZhciBwb3B1cEFsaWduID0gcHJvcHMucG9wdXBBbGlnbjtcbiAgICB2YXIgYnVpbHRpblBsYWNlbWVudHMgPSBwcm9wcy5idWlsdGluUGxhY2VtZW50cztcblxuICAgIGlmIChwb3B1cFBsYWNlbWVudCAmJiBidWlsdGluUGxhY2VtZW50cykge1xuICAgICAgcmV0dXJuICgwLCBfdXRpbHMuZ2V0QWxpZ25Gcm9tUGxhY2VtZW50KShidWlsdGluUGxhY2VtZW50cywgcG9wdXBQbGFjZW1lbnQsIHBvcHVwQWxpZ24pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBBbGlnbjtcbiAgfSxcbiAgZ2V0UG9wdXBFbGVtZW50OiBmdW5jdGlvbiBnZXRQb3B1cEVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgdmFyIG1vdXNlUHJvcHMgPSB7fTtcbiAgICBpZiAodGhpcy5pc01vdXNlRW50ZXJUb1Nob3coKSkge1xuICAgICAgbW91c2VQcm9wcy5vbk1vdXNlRW50ZXIgPSB0aGlzLm9uTW91c2VFbnRlcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUxlYXZlVG9IaWRlKCkpIHtcbiAgICAgIG1vdXNlUHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX1BvcHVwMltcImRlZmF1bHRcIl0sXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIHByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IHByb3BzLmRlc3Ryb3lQb3B1cE9uSGlkZSxcbiAgICAgICAgdmlzaWJsZTogc3RhdGUucG9wdXBWaXNpYmxlLFxuICAgICAgICBjbGFzc05hbWU6IHByb3BzLnBvcHVwQ2xhc3NOYW1lLFxuICAgICAgICBhY3Rpb246IHByb3BzLmFjdGlvbixcbiAgICAgICAgYWxpZ246IHRoaXMuZ2V0UG9wdXBBbGlnbigpLFxuICAgICAgICBvbkFsaWduOiBwcm9wcy5vblBvcHVwQWxpZ24sXG4gICAgICAgIGFuaW1hdGlvbjogcHJvcHMucG9wdXBBbmltYXRpb24sXG4gICAgICAgIGdldENsYXNzTmFtZUZyb21BbGlnbjogdGhpcy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnblxuICAgICAgfSwgbW91c2VQcm9wcywge1xuICAgICAgICBnZXRSb290RG9tTm9kZTogdGhpcy5nZXRSb290RG9tTm9kZSxcbiAgICAgICAgc3R5bGU6IHByb3BzLnBvcHVwU3R5bGUsXG4gICAgICAgIG1hc2s6IHByb3BzLm1hc2ssXG4gICAgICAgIHpJbmRleDogcHJvcHMuekluZGV4LFxuICAgICAgICB0cmFuc2l0aW9uTmFtZTogcHJvcHMucG9wdXBUcmFuc2l0aW9uTmFtZSxcbiAgICAgICAgbWFza0FuaW1hdGlvbjogcHJvcHMubWFza0FuaW1hdGlvbixcbiAgICAgICAgbWFza1RyYW5zaXRpb25OYW1lOiBwcm9wcy5tYXNrVHJhbnNpdGlvbk5hbWVcbiAgICAgIH0pLFxuICAgICAgdHlwZW9mIHByb3BzLnBvcHVwID09PSAnZnVuY3Rpb24nID8gcHJvcHMucG9wdXAoKSA6IHByb3BzLnBvcHVwXG4gICAgKTtcbiAgfSxcbiAgc2V0UG9wdXBWaXNpYmxlOiBmdW5jdGlvbiBzZXRQb3B1cFZpc2libGUocG9wdXBWaXNpYmxlKSB7XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZXIoKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3B1cFZpc2libGUgIT09IHBvcHVwVmlzaWJsZSkge1xuICAgICAgaWYgKCEoJ3BvcHVwVmlzaWJsZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcG9wdXBWaXNpYmxlOiBwb3B1cFZpc2libGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uUG9wdXBWaXNpYmxlQ2hhbmdlKHBvcHVwVmlzaWJsZSk7XG4gICAgfVxuICB9LFxuICBkZWxheVNldFBvcHVwVmlzaWJsZTogZnVuY3Rpb24gZGVsYXlTZXRQb3B1cFZpc2libGUodmlzaWJsZSwgZGVsYXlTKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZGVsYXkgPSBkZWxheVMgKiAxMDAwO1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICB0aGlzLmRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNldFBvcHVwVmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgX3RoaXMyLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFBvcHVwVmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9XG4gIH0sXG4gIGNsZWFyRGVsYXlUaW1lcjogZnVuY3Rpb24gY2xlYXJEZWxheVRpbWVyKCkge1xuICAgIGlmICh0aGlzLmRlbGF5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZXIpO1xuICAgICAgdGhpcy5kZWxheVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGlzQ2xpY2tUb1Nob3c6IGZ1bmN0aW9uIGlzQ2xpY2tUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wcy5hY3Rpb247XG4gICAgdmFyIHNob3dBY3Rpb24gPSBfcHJvcHMuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMTtcbiAgfSxcbiAgaXNDbGlja1RvSGlkZTogZnVuY3Rpb24gaXNDbGlja1RvSGlkZSgpIHtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczIuYWN0aW9uO1xuICAgIHZhciBoaWRlQWN0aW9uID0gX3Byb3BzMi5oaWRlQWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xO1xuICB9LFxuICBpc01vdXNlRW50ZXJUb1Nob3c6IGZ1bmN0aW9uIGlzTW91c2VFbnRlclRvU2hvdygpIHtcbiAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczMuYWN0aW9uO1xuICAgIHZhciBzaG93QWN0aW9uID0gX3Byb3BzMy5zaG93QWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdob3ZlcicpICE9PSAtMSB8fCBzaG93QWN0aW9uLmluZGV4T2YoJ21vdXNlRW50ZXInKSAhPT0gLTE7XG4gIH0sXG4gIGlzTW91c2VMZWF2ZVRvSGlkZTogZnVuY3Rpb24gaXNNb3VzZUxlYXZlVG9IaWRlKCkge1xuICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aW9uID0gX3Byb3BzNC5hY3Rpb247XG4gICAgdmFyIGhpZGVBY3Rpb24gPSBfcHJvcHM0LmhpZGVBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2hvdmVyJykgIT09IC0xIHx8IGhpZGVBY3Rpb24uaW5kZXhPZignbW91c2VMZWF2ZScpICE9PSAtMTtcbiAgfSxcbiAgaXNGb2N1c1RvU2hvdzogZnVuY3Rpb24gaXNGb2N1c1RvU2hvdygpIHtcbiAgICB2YXIgX3Byb3BzNSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczUuYWN0aW9uO1xuICAgIHZhciBzaG93QWN0aW9uID0gX3Byb3BzNS5zaG93QWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdmb2N1cycpICE9PSAtMSB8fCBzaG93QWN0aW9uLmluZGV4T2YoJ2ZvY3VzJykgIT09IC0xO1xuICB9LFxuICBpc0JsdXJUb0hpZGU6IGZ1bmN0aW9uIGlzQmx1clRvSGlkZSgpIHtcbiAgICB2YXIgX3Byb3BzNiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczYuYWN0aW9uO1xuICAgIHZhciBoaWRlQWN0aW9uID0gX3Byb3BzNi5oaWRlQWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdmb2N1cycpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoJ2JsdXInKSAhPT0gLTE7XG4gIH0sXG4gIGZvcmNlUG9wdXBBbGlnbjogZnVuY3Rpb24gZm9yY2VQb3B1cEFsaWduKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSAmJiB0aGlzLnBvcHVwSW5zdGFuY2UgJiYgdGhpcy5wb3B1cEluc3RhbmNlLmFsaWduSW5zdGFuY2UpIHtcbiAgICAgIHRoaXMucG9wdXBJbnN0YW5jZS5hbGlnbkluc3RhbmNlLmZvcmNlQWxpZ24oKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRoaXMucG9wdXBSZW5kZXJlZCA9IHRoaXMucG9wdXBSZW5kZXJlZCB8fCB0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBjaGlsZCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgIHZhciBjaGlsZFByb3BzID0gY2hpbGQucHJvcHMgfHwge307XG4gICAgdmFyIG5ld0NoaWxkUHJvcHMgPSB7fTtcblxuICAgIGlmICh0aGlzLmlzQ2xpY2tUb0hpZGUoKSB8fCB0aGlzLmlzQ2xpY2tUb1Nob3coKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbkNsaWNrID0gKDAsIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yW1wiZGVmYXVsdFwiXSkodGhpcy5vbkNsaWNrLCBjaGlsZFByb3BzLm9uQ2xpY2spO1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRG93biA9ICgwLCBfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uMltcImRlZmF1bHRcIl0pKHRoaXMub25Nb3VzZURvd24sIGNoaWxkUHJvcHMub25Nb3VzZURvd24pO1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vblRvdWNoU3RhcnQgPSAoMCwgX2NyZWF0ZUNoYWluZWRGdW5jdGlvbjJbXCJkZWZhdWx0XCJdKSh0aGlzLm9uVG91Y2hTdGFydCwgY2hpbGRQcm9wcy5vblRvdWNoU3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc01vdXNlRW50ZXJUb1Nob3coKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSAoMCwgX2NyZWF0ZUNoYWluZWRGdW5jdGlvbjJbXCJkZWZhdWx0XCJdKSh0aGlzLm9uTW91c2VFbnRlciwgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc01vdXNlTGVhdmVUb0hpZGUoKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlTGVhdmUgPSAoMCwgX2NyZWF0ZUNoYWluZWRGdW5jdGlvbjJbXCJkZWZhdWx0XCJdKSh0aGlzLm9uTW91c2VMZWF2ZSwgY2hpbGRQcm9wcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvY3VzVG9TaG93KCkgfHwgdGhpcy5pc0JsdXJUb0hpZGUoKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbkZvY3VzID0gKDAsIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yW1wiZGVmYXVsdFwiXSkodGhpcy5vbkZvY3VzLCBjaGlsZFByb3BzLm9uRm9jdXMpO1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbkJsdXIgPSAoMCwgX2NyZWF0ZUNoYWluZWRGdW5jdGlvbjJbXCJkZWZhdWx0XCJdKSh0aGlzLm9uQmx1ciwgY2hpbGRQcm9wcy5vbkJsdXIpO1xuICAgIH1cblxuICAgIEFMTF9IQU5ETEVSUy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgbmV3Rm4gPSB2b2lkIDA7XG4gICAgICBpZiAocHJvcHNbaGFuZGxlcl0gJiYgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXSkge1xuICAgICAgICBuZXdGbiA9ICgwLCBfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uMltcImRlZmF1bHRcIl0pKHByb3BzW2hhbmRsZXJdLCBuZXdDaGlsZFByb3BzW2hhbmRsZXJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0ZuID0gcHJvcHNbaGFuZGxlcl0gfHwgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdGbikge1xuICAgICAgICBuZXdDaGlsZFByb3BzW2hhbmRsZXJdID0gbmV3Rm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJpZ2dlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1RyaWdnZXInKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZ2V0QWxpZ25Gcm9tUGxhY2VtZW50ID0gZ2V0QWxpZ25Gcm9tUGxhY2VtZW50O1xuZXhwb3J0cy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbiA9IGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduO1xuZnVuY3Rpb24gaXNQb2ludHNFcShhMSwgYTIpIHtcbiAgcmV0dXJuIGExWzBdID09PSBhMlswXSAmJiBhMVsxXSA9PT0gYTJbMV07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduRnJvbVBsYWNlbWVudChidWlsdGluUGxhY2VtZW50cywgcGxhY2VtZW50U3RyLCBhbGlnbikge1xuICB2YXIgYmFzZUFsaWduID0gYnVpbHRpblBsYWNlbWVudHNbcGxhY2VtZW50U3RyXSB8fCB7fTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBiYXNlQWxpZ24sIGFsaWduKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24oYnVpbHRpblBsYWNlbWVudHMsIHByZWZpeENscywgYWxpZ24pIHtcbiAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgZm9yICh2YXIgcGxhY2VtZW50IGluIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgaWYgKGJ1aWx0aW5QbGFjZW1lbnRzLmhhc093blByb3BlcnR5KHBsYWNlbWVudCkpIHtcbiAgICAgIGlmIChpc1BvaW50c0VxKGJ1aWx0aW5QbGFjZW1lbnRzW3BsYWNlbWVudF0ucG9pbnRzLCBwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhDbHMgKyAnLXBsYWNlbWVudC0nICsgcGxhY2VtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfZG9tQWxpZ24gPSByZXF1aXJlKCdkb20tYWxpZ24nKTtcblxudmFyIF9kb21BbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb21BbGlnbik7XG5cbnZhciBfYWRkRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ3JjLXV0aWwvbGliL0RvbS9hZGRFdmVudExpc3RlbmVyJyk7XG5cbnZhciBfYWRkRXZlbnRMaXN0ZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRFdmVudExpc3RlbmVyKTtcblxudmFyIF9pc1dpbmRvdyA9IHJlcXVpcmUoJy4vaXNXaW5kb3cnKTtcblxudmFyIF9pc1dpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1dpbmRvdyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBidWZmZXIoZm4sIG1zKSB7XG4gIHZhciB0aW1lciA9IHZvaWQgMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlckZuKCkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gIH07XG59XG5cbnZhciBBbGlnbiA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdBbGlnbicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY2hpbGRyZW5Qcm9wczogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgYWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgdGFyZ2V0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25BbGlnbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG1vbml0b3JCdWZmZXJUaW1lOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBtb25pdG9yV2luZG93UmVzaXplOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0OiBmdW5jdGlvbiB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICB9LFxuICAgICAgb25BbGlnbjogZnVuY3Rpb24gb25BbGlnbigpIHt9LFxuXG4gICAgICBtb25pdG9yQnVmZmVyVGltZTogNTAsXG4gICAgICBtb25pdG9yV2luZG93UmVzaXplOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIC8vIGlmIHBhcmVudCByZWYgbm90IGF0dGFjaGVkIC4uLi4gdXNlIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkXG4gICAgdGhpcy5mb3JjZUFsaWduKCk7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCAmJiBwcm9wcy5tb25pdG9yV2luZG93UmVzaXplKSB7XG4gICAgICB0aGlzLnN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHJlQWxpZ24gPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgaWYgKHByZXZQcm9wcy5kaXNhYmxlZCB8fCBwcmV2UHJvcHMuYWxpZ24gIT09IHByb3BzLmFsaWduKSB7XG4gICAgICAgIHJlQWxpZ24gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxhc3RUYXJnZXQgPSBwcmV2UHJvcHMudGFyZ2V0KCk7XG4gICAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gcHJvcHMudGFyZ2V0KCk7XG4gICAgICAgIGlmICgoMCwgX2lzV2luZG93MltcImRlZmF1bHRcIl0pKGxhc3RUYXJnZXQpICYmICgwLCBfaXNXaW5kb3cyW1wiZGVmYXVsdFwiXSkoY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgICByZUFsaWduID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFRhcmdldCAhPT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIHJlQWxpZ24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlQWxpZ24pIHtcbiAgICAgIHRoaXMuZm9yY2VBbGlnbigpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5tb25pdG9yV2luZG93UmVzaXplICYmICFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zdGFydE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgfSxcbiAgc3RhcnRNb25pdG9yV2luZG93UmVzaXplOiBmdW5jdGlvbiBzdGFydE1vbml0b3JXaW5kb3dSZXNpemUoKSB7XG4gICAgaWYgKCF0aGlzLnJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9ICgwLCBfYWRkRXZlbnRMaXN0ZW5lcjJbXCJkZWZhdWx0XCJdKSh3aW5kb3csICdyZXNpemUnLCBidWZmZXIodGhpcy5mb3JjZUFsaWduLCB0aGlzLnByb3BzLm1vbml0b3JCdWZmZXJUaW1lKSk7XG4gICAgfVxuICB9LFxuICBzdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24gc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGZvcmNlQWxpZ246IGZ1bmN0aW9uIGZvcmNlQWxpZ24oKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICB2YXIgc291cmNlID0gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICBwcm9wcy5vbkFsaWduKHNvdXJjZSwgKDAsIF9kb21BbGlnbjJbXCJkZWZhdWx0XCJdKShzb3VyY2UsIHByb3BzLnRhcmdldCgpLCBwcm9wcy5hbGlnbikpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuUHJvcHMgPSBfcHJvcHMuY2hpbGRyZW5Qcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGRyZW5Qcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGNoaWxkcmVuUHJvcHMpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBuZXdQcm9wc1twcm9wXSA9IHRoaXMucHJvcHNbY2hpbGRyZW5Qcm9wc1twcm9wXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hpbGQsIG5ld1Byb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBbGlnbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9BbGlnbiA9IHJlcXVpcmUoJy4vQWxpZ24nKTtcblxudmFyIF9BbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BbGlnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9BbGlnbjJbXCJkZWZhdWx0XCJdOyAvLyBleHBvcnQgdGhpcyBwYWNrYWdlJ3MgYXBpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpc1dpbmRvdztcbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAvKiBlc2xpbnQgbm8tZXEtbnVsbDogMCAqL1xuICAvKiBlc2xpbnQgZXFlcWVxOiAwICovXG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbmZ1bmN0aW9uIGFkanVzdEZvclZpZXdwb3J0KGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QsIG92ZXJmbG93KSB7XG4gIHZhciBwb3MgPSBfdXRpbHMyWydkZWZhdWx0J10uY2xvbmUoZWxGdXR1cmVQb3MpO1xuICB2YXIgc2l6ZSA9IHtcbiAgICB3aWR0aDogZWxSZWdpb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBlbFJlZ2lvbi5oZWlnaHRcbiAgfTtcblxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WCAmJiBwb3MubGVmdCA8IHZpc2libGVSZWN0LmxlZnQpIHtcbiAgICBwb3MubGVmdCA9IHZpc2libGVSZWN0LmxlZnQ7XG4gIH1cblxuICAvLyBMZWZ0IGVkZ2UgaW5zaWRlIGFuZCByaWdodCBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byByZXNpemUgaXQuXG4gIGlmIChvdmVyZmxvdy5yZXNpemVXaWR0aCAmJiBwb3MubGVmdCA+PSB2aXNpYmxlUmVjdC5sZWZ0ICYmIHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0KSB7XG4gICAgc2l6ZS53aWR0aCAtPSBwb3MubGVmdCArIHNpemUud2lkdGggLSB2aXNpYmxlUmVjdC5yaWdodDtcbiAgfVxuXG4gIC8vIFJpZ2h0IGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RYICYmIHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0KSB7XG4gICAgLy8g5L+d6K+B5bem6L6555WM5ZKM5Y+v6KeG5Yy65Z+f5bem6L6555WM5a+56b2QXG4gICAgcG9zLmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5yaWdodCAtIHNpemUud2lkdGgsIHZpc2libGVSZWN0LmxlZnQpO1xuICB9XG5cbiAgLy8gVG9wIGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RZICYmIHBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3ApIHtcbiAgICBwb3MudG9wID0gdmlzaWJsZVJlY3QudG9wO1xuICB9XG5cbiAgLy8gVG9wIGVkZ2UgaW5zaWRlIGFuZCBib3R0b20gZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gcmVzaXplIGl0LlxuICBpZiAob3ZlcmZsb3cucmVzaXplSGVpZ2h0ICYmIHBvcy50b3AgPj0gdmlzaWJsZVJlY3QudG9wICYmIHBvcy50b3AgKyBzaXplLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbSkge1xuICAgIHNpemUuaGVpZ2h0IC09IHBvcy50b3AgKyBzaXplLmhlaWdodCAtIHZpc2libGVSZWN0LmJvdHRvbTtcbiAgfVxuXG4gIC8vIEJvdHRvbSBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byBtb3ZlIGl0LlxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WSAmJiBwb3MudG9wICsgc2l6ZS5oZWlnaHQgPiB2aXNpYmxlUmVjdC5ib3R0b20pIHtcbiAgICAvLyDkv53or4HkuIrovrnnlYzlkozlj6/op4bljLrln5/kuIrovrnnlYzlr7npvZBcbiAgICBwb3MudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QuYm90dG9tIC0gc2l6ZS5oZWlnaHQsIHZpc2libGVSZWN0LnRvcCk7XG4gIH1cblxuICByZXR1cm4gX3V0aWxzMlsnZGVmYXVsdCddLm1peChwb3MsIHNpemUpO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBhZGp1c3RGb3JWaWV3cG9ydDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICog6I635Y+WIG5vZGUg5LiK55qEIGFsaWduIOWvuem9kOeCuSDnm7jlr7nkuo7pobXpnaLnmoTlnZDmoIdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZnVuY3Rpb24gZ2V0QWxpZ25PZmZzZXQocmVnaW9uLCBhbGlnbikge1xuICB2YXIgViA9IGFsaWduLmNoYXJBdCgwKTtcbiAgdmFyIEggPSBhbGlnbi5jaGFyQXQoMSk7XG4gIHZhciB3ID0gcmVnaW9uLndpZHRoO1xuICB2YXIgaCA9IHJlZ2lvbi5oZWlnaHQ7XG4gIHZhciB4ID0gdW5kZWZpbmVkO1xuICB2YXIgeSA9IHVuZGVmaW5lZDtcblxuICB4ID0gcmVnaW9uLmxlZnQ7XG4gIHkgPSByZWdpb24udG9wO1xuXG4gIGlmIChWID09PSAnYycpIHtcbiAgICB5ICs9IGggLyAyO1xuICB9IGVsc2UgaWYgKFYgPT09ICdiJykge1xuICAgIHkgKz0gaDtcbiAgfVxuXG4gIGlmIChIID09PSAnYycpIHtcbiAgICB4ICs9IHcgLyAyO1xuICB9IGVsc2UgaWYgKEggPT09ICdyJykge1xuICAgIHggKz0gdztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVmdDogeCxcbiAgICB0b3A6IHlcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0QWxpZ25PZmZzZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZ2V0QWxpZ25PZmZzZXQgPSByZXF1aXJlKCcuL2dldEFsaWduT2Zmc2V0Jyk7XG5cbnZhciBfZ2V0QWxpZ25PZmZzZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0QWxpZ25PZmZzZXQpO1xuXG5mdW5jdGlvbiBnZXRFbEZ1dHVyZVBvcyhlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgcG9pbnRzLCBvZmZzZXQsIHRhcmdldE9mZnNldCkge1xuICB2YXIgeHkgPSB1bmRlZmluZWQ7XG4gIHZhciBkaWZmID0gdW5kZWZpbmVkO1xuICB2YXIgcDEgPSB1bmRlZmluZWQ7XG4gIHZhciBwMiA9IHVuZGVmaW5lZDtcblxuICB4eSA9IHtcbiAgICBsZWZ0OiBlbFJlZ2lvbi5sZWZ0LFxuICAgIHRvcDogZWxSZWdpb24udG9wXG4gIH07XG5cbiAgcDEgPSAoMCwgX2dldEFsaWduT2Zmc2V0MlsnZGVmYXVsdCddKShyZWZOb2RlUmVnaW9uLCBwb2ludHNbMV0pO1xuICBwMiA9ICgwLCBfZ2V0QWxpZ25PZmZzZXQyWydkZWZhdWx0J10pKGVsUmVnaW9uLCBwb2ludHNbMF0pO1xuXG4gIGRpZmYgPSBbcDIubGVmdCAtIHAxLmxlZnQsIHAyLnRvcCAtIHAxLnRvcF07XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiB4eS5sZWZ0IC0gZGlmZlswXSArIG9mZnNldFswXSAtIHRhcmdldE9mZnNldFswXSxcbiAgICB0b3A6IHh5LnRvcCAtIGRpZmZbMV0gKyBvZmZzZXRbMV0gLSB0YXJnZXRPZmZzZXRbMV1cbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0RWxGdXR1cmVQb3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG4vKipcbiAqIOW+l+WIsOS8muWvvOiHtOWFg+e0oOaYvuekuuS4jeWFqOeahOelluWFiOWFg+e0oFxuICovXG5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIGllIOi/meS4quS5n+S4jeaYr+WujOWFqOWPr+ihjFxuICAvKlxuICAgPGRpdiBzdHlsZT1cIndpZHRoOiA1MHB4O2hlaWdodDogMTAwcHg7b3ZlcmZsb3c6IGhpZGRlblwiPlxuICAgPGRpdiBzdHlsZT1cIndpZHRoOiA1MHB4O2hlaWdodDogMTAwcHg7cG9zaXRpb246IHJlbGF0aXZlO1wiIGlkPVwiZDZcIj5cbiAgIOWFg+e0oCA2IOmrmCAxMDBweCDlrr0gNTBweDxici8+XG4gICA8L2Rpdj5cbiAgIDwvZGl2PlxuICAgKi9cbiAgLy8gZWxlbWVudC5vZmZzZXRQYXJlbnQgZG9lcyB0aGUgcmlnaHQgdGhpbmcgaW4gaWU3IGFuZCBiZWxvdy4gUmV0dXJuIHBhcmVudCB3aXRoIGxheW91dCFcbiAgLy8gIEluIG90aGVyIGJyb3dzZXJzIGl0IG9ubHkgaW5jbHVkZXMgZWxlbWVudHMgd2l0aCBwb3NpdGlvbiBhYnNvbHV0ZSwgcmVsYXRpdmUgb3JcbiAgLy8gZml4ZWQsIG5vdCBlbGVtZW50cyB3aXRoIG92ZXJmbG93IHNldCB0byBhdXRvIG9yIHNjcm9sbC5cbiAgLy8gICAgICAgIGlmIChVQS5pZSAmJiBpZU1vZGUgPCA4KSB7XG4gIC8vICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAvLyAgICAgICAgfVxuICAvLyDnu5/kuIDnmoQgb2Zmc2V0UGFyZW50IOaWueazlVxuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICB2YXIgcGFyZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgcG9zaXRpb25TdHlsZSA9IF91dGlsczJbJ2RlZmF1bHQnXS5jc3MoZWxlbWVudCwgJ3Bvc2l0aW9uJyk7XG4gIHZhciBza2lwU3RhdGljID0gcG9zaXRpb25TdHlsZSA9PT0gJ2ZpeGVkJyB8fCBwb3NpdGlvblN0eWxlID09PSAnYWJzb2x1dGUnO1xuXG4gIGlmICghc2tpcFN0YXRpYykge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdodG1sJyA/IG51bGwgOiBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICBmb3IgKHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPT0gYm9keTsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICBwb3NpdGlvblN0eWxlID0gX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhwYXJlbnQsICdwb3NpdGlvbicpO1xuICAgIGlmIChwb3NpdGlvblN0eWxlICE9PSAnc3RhdGljJykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldE9mZnNldFBhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbmZ1bmN0aW9uIGdldFJlZ2lvbihub2RlKSB7XG4gIHZhciBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gIHZhciB3ID0gdW5kZWZpbmVkO1xuICB2YXIgaCA9IHVuZGVmaW5lZDtcbiAgaWYgKCFfdXRpbHMyWydkZWZhdWx0J10uaXNXaW5kb3cobm9kZSkgJiYgbm9kZS5ub2RlVHlwZSAhPT0gOSkge1xuICAgIG9mZnNldCA9IF91dGlsczJbJ2RlZmF1bHQnXS5vZmZzZXQobm9kZSk7XG4gICAgdyA9IF91dGlsczJbJ2RlZmF1bHQnXS5vdXRlcldpZHRoKG5vZGUpO1xuICAgIGggPSBfdXRpbHMyWydkZWZhdWx0J10ub3V0ZXJIZWlnaHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3cobm9kZSk7XG4gICAgb2Zmc2V0ID0ge1xuICAgICAgbGVmdDogX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbExlZnQod2luKSxcbiAgICAgIHRvcDogX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbFRvcCh3aW4pXG4gICAgfTtcbiAgICB3ID0gX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKTtcbiAgICBoID0gX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIH1cbiAgb2Zmc2V0LndpZHRoID0gdztcbiAgb2Zmc2V0LmhlaWdodCA9IGg7XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFJlZ2lvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50ID0gcmVxdWlyZSgnLi9nZXRPZmZzZXRQYXJlbnQnKTtcblxudmFyIF9nZXRPZmZzZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T2Zmc2V0UGFyZW50KTtcblxuLyoqXG4gKiDojrflvpflhYPntKDnmoTmmL7npLrpg6jliIbnmoTljLrln59cbiAqL1xuZnVuY3Rpb24gZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIHZpc2libGVSZWN0ID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IEluZmluaXR5LFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IEluZmluaXR5XG4gIH07XG4gIHZhciBlbCA9ICgwLCBfZ2V0T2Zmc2V0UGFyZW50MlsnZGVmYXVsdCddKShlbGVtZW50KTtcbiAgdmFyIHNjcm9sbFggPSB1bmRlZmluZWQ7XG4gIHZhciBzY3JvbGxZID0gdW5kZWZpbmVkO1xuICB2YXIgd2luU2l6ZSA9IHVuZGVmaW5lZDtcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIHZpc2libGUgcmVjdCBieSBjbGltYmluZyB0aGUgZG9tIGFjY291bnRpbmcgZm9yXG4gIC8vIGFsbCBzY3JvbGxhYmxlIGNvbnRhaW5lcnMuXG4gIHdoaWxlIChlbCkge1xuICAgIC8vIGNsaWVudFdpZHRoIGlzIHplcm8gZm9yIGlubGluZSBibG9jayBlbGVtZW50cyBpbiBpZS5cbiAgICBpZiAoKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpID09PSAtMSB8fCBlbC5jbGllbnRXaWR0aCAhPT0gMCkgJiZcbiAgICAvLyBib2R5IG1heSBoYXZlIG92ZXJmbG93IHNldCBvbiBpdCwgeWV0IHdlIHN0aWxsIGdldCB0aGUgZW50aXJlXG4gICAgLy8gdmlld3BvcnQuIEluIHNvbWUgYnJvd3NlcnMsIGVsLm9mZnNldFBhcmVudCBtYXkgYmVcbiAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHNvIGNoZWNrIGZvciB0aGF0IHRvby5cbiAgICBlbCAhPT0gYm9keSAmJiBlbCAhPT0gZG9jdW1lbnRFbGVtZW50ICYmIF91dGlsczJbJ2RlZmF1bHQnXS5jc3MoZWwsICdvdmVyZmxvdycpICE9PSAndmlzaWJsZScpIHtcbiAgICAgIHZhciBwb3MgPSBfdXRpbHMyWydkZWZhdWx0J10ub2Zmc2V0KGVsKTtcbiAgICAgIC8vIGFkZCBib3JkZXJcbiAgICAgIHBvcy5sZWZ0ICs9IGVsLmNsaWVudExlZnQ7XG4gICAgICBwb3MudG9wICs9IGVsLmNsaWVudFRvcDtcbiAgICAgIHZpc2libGVSZWN0LnRvcCA9IE1hdGgubWF4KHZpc2libGVSZWN0LnRvcCwgcG9zLnRvcCk7XG4gICAgICB2aXNpYmxlUmVjdC5yaWdodCA9IE1hdGgubWluKHZpc2libGVSZWN0LnJpZ2h0LFxuICAgICAgLy8gY29uc2lkZXIgYXJlYSB3aXRob3V0IHNjcm9sbEJhclxuICAgICAgcG9zLmxlZnQgKyBlbC5jbGllbnRXaWR0aCk7XG4gICAgICB2aXNpYmxlUmVjdC5ib3R0b20gPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5ib3R0b20sIHBvcy50b3AgKyBlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgdmlzaWJsZVJlY3QubGVmdCA9IE1hdGgubWF4KHZpc2libGVSZWN0LmxlZnQsIHBvcy5sZWZ0KTtcbiAgICB9IGVsc2UgaWYgKGVsID09PSBib2R5IHx8IGVsID09PSBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbCA9ICgwLCBfZ2V0T2Zmc2V0UGFyZW50MlsnZGVmYXVsdCddKShlbCk7XG4gIH1cblxuICAvLyBDbGlwIGJ5IHdpbmRvdydzIHZpZXdwb3J0LlxuICBzY3JvbGxYID0gX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbExlZnQod2luKTtcbiAgc2Nyb2xsWSA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKTtcbiAgdmlzaWJsZVJlY3QubGVmdCA9IE1hdGgubWF4KHZpc2libGVSZWN0LmxlZnQsIHNjcm9sbFgpO1xuICB2aXNpYmxlUmVjdC50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIHNjcm9sbFkpO1xuICB3aW5TaXplID0ge1xuICAgIHdpZHRoOiBfdXRpbHMyWydkZWZhdWx0J10udmlld3BvcnRXaWR0aCh3aW4pLFxuICAgIGhlaWdodDogX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0SGVpZ2h0KHdpbilcbiAgfTtcbiAgdmlzaWJsZVJlY3QucmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCwgc2Nyb2xsWCArIHdpblNpemUud2lkdGgpO1xuICB2aXNpYmxlUmVjdC5ib3R0b20gPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5ib3R0b20sIHNjcm9sbFkgKyB3aW5TaXplLmhlaWdodCk7XG4gIHJldHVybiB2aXNpYmxlUmVjdC50b3AgPj0gMCAmJiB2aXNpYmxlUmVjdC5sZWZ0ID49IDAgJiYgdmlzaWJsZVJlY3QuYm90dG9tID4gdmlzaWJsZVJlY3QudG9wICYmIHZpc2libGVSZWN0LnJpZ2h0ID4gdmlzaWJsZVJlY3QubGVmdCA/IHZpc2libGVSZWN0IDogbnVsbDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLyoqXG4gKiBhbGlnbiBkb20gbm9kZSBmbGV4aWJseVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG52YXIgX2dldE9mZnNldFBhcmVudCA9IHJlcXVpcmUoJy4vZ2V0T2Zmc2V0UGFyZW50Jyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE9mZnNldFBhcmVudCk7XG5cbnZhciBfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50ID0gcmVxdWlyZSgnLi9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQnKTtcblxudmFyIF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50KTtcblxudmFyIF9hZGp1c3RGb3JWaWV3cG9ydCA9IHJlcXVpcmUoJy4vYWRqdXN0Rm9yVmlld3BvcnQnKTtcblxudmFyIF9hZGp1c3RGb3JWaWV3cG9ydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGp1c3RGb3JWaWV3cG9ydCk7XG5cbnZhciBfZ2V0UmVnaW9uID0gcmVxdWlyZSgnLi9nZXRSZWdpb24nKTtcblxudmFyIF9nZXRSZWdpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UmVnaW9uKTtcblxudmFyIF9nZXRFbEZ1dHVyZVBvcyA9IHJlcXVpcmUoJy4vZ2V0RWxGdXR1cmVQb3MnKTtcblxudmFyIF9nZXRFbEZ1dHVyZVBvczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRFbEZ1dHVyZVBvcyk7XG5cbi8vIGh0dHA6Ly95aW1pbmdoZS5pdGV5ZS5jb20vYmxvZy8xMTI0NzIwXG5cbmZ1bmN0aW9uIGlzRmFpbFgoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MubGVmdCA8IHZpc2libGVSZWN0LmxlZnQgfHwgZWxGdXR1cmVQb3MubGVmdCArIGVsUmVnaW9uLndpZHRoID4gdmlzaWJsZVJlY3QucmlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MudG9wIDwgdmlzaWJsZVJlY3QudG9wIHx8IGVsRnV0dXJlUG9zLnRvcCArIGVsUmVnaW9uLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbTtcbn1cblxuZnVuY3Rpb24gaXNDb21wbGV0ZUZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLmxlZnQgPiB2aXNpYmxlUmVjdC5yaWdodCB8fCBlbEZ1dHVyZVBvcy5sZWZ0ICsgZWxSZWdpb24ud2lkdGggPCB2aXNpYmxlUmVjdC5sZWZ0O1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRlRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MudG9wID4gdmlzaWJsZVJlY3QuYm90dG9tIHx8IGVsRnV0dXJlUG9zLnRvcCArIGVsUmVnaW9uLmhlaWdodCA8IHZpc2libGVSZWN0LnRvcDtcbn1cblxuZnVuY3Rpb24gZmxpcChwb2ludHMsIHJlZywgbWFwKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgX3V0aWxzMlsnZGVmYXVsdCddLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocCkge1xuICAgIHJldC5wdXNoKHAucmVwbGFjZShyZWcsIGZ1bmN0aW9uIChtKSB7XG4gICAgICByZXR1cm4gbWFwW21dO1xuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZsaXBPZmZzZXQob2Zmc2V0LCBpbmRleCkge1xuICBvZmZzZXRbaW5kZXhdID0gLW9mZnNldFtpbmRleF07XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXQoc3RyLCBvZmZzZXRMZW4pIHtcbiAgdmFyIG4gPSB1bmRlZmluZWQ7XG4gIGlmICgvJSQvLnRlc3Qoc3RyKSkge1xuICAgIG4gPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSwgMTApIC8gMTAwICogb2Zmc2V0TGVuO1xuICB9IGVsc2Uge1xuICAgIG4gPSBwYXJzZUludChzdHIsIDEwKTtcbiAgfVxuICByZXR1cm4gbiB8fCAwO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQob2Zmc2V0LCBlbCkge1xuICBvZmZzZXRbMF0gPSBjb252ZXJ0T2Zmc2V0KG9mZnNldFswXSwgZWwud2lkdGgpO1xuICBvZmZzZXRbMV0gPSBjb252ZXJ0T2Zmc2V0KG9mZnNldFsxXSwgZWwuaGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gZG9tQWxpZ24oZWwsIHJlZk5vZGUsIGFsaWduKSB7XG4gIHZhciBwb2ludHMgPSBhbGlnbi5wb2ludHM7XG4gIHZhciBvZmZzZXQgPSBhbGlnbi5vZmZzZXQgfHwgWzAsIDBdO1xuICB2YXIgdGFyZ2V0T2Zmc2V0ID0gYWxpZ24udGFyZ2V0T2Zmc2V0IHx8IFswLCAwXTtcbiAgdmFyIG92ZXJmbG93ID0gYWxpZ24ub3ZlcmZsb3c7XG4gIHZhciB0YXJnZXQgPSBhbGlnbi50YXJnZXQgfHwgcmVmTm9kZTtcbiAgdmFyIHNvdXJjZSA9IGFsaWduLnNvdXJjZSB8fCBlbDtcbiAgb2Zmc2V0ID0gW10uY29uY2F0KG9mZnNldCk7XG4gIHRhcmdldE9mZnNldCA9IFtdLmNvbmNhdCh0YXJnZXRPZmZzZXQpO1xuICBvdmVyZmxvdyA9IG92ZXJmbG93IHx8IHt9O1xuICB2YXIgbmV3T3ZlcmZsb3dDZmcgPSB7fTtcblxuICB2YXIgZmFpbCA9IDA7XG4gIC8vIOW9k+WJjeiKgueCueWPr+S7peiiq+aUvue9rueahOaYvuekuuWMuuWfn1xuICB2YXIgdmlzaWJsZVJlY3QgPSAoMCwgX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudDJbJ2RlZmF1bHQnXSkoc291cmNlKTtcbiAgLy8g5b2T5YmN6IqC54K55omA5Y2g55qE5Yy65Z+fLCBsZWZ0L3RvcC93aWR0aC9oZWlnaHRcbiAgdmFyIGVsUmVnaW9uID0gKDAsIF9nZXRSZWdpb24yWydkZWZhdWx0J10pKHNvdXJjZSk7XG4gIC8vIOWPgueFp+iKgueCueaJgOWNoOeahOWMuuWfnywgbGVmdC90b3Avd2lkdGgvaGVpZ2h0XG4gIHZhciByZWZOb2RlUmVnaW9uID0gKDAsIF9nZXRSZWdpb24yWydkZWZhdWx0J10pKHRhcmdldCk7XG4gIC8vIOWwhiBvZmZzZXQg6L2s5o2i5oiQ5pWw5YC877yM5pSv5oyB55m+5YiG5q+UXG4gIG5vcm1hbGl6ZU9mZnNldChvZmZzZXQsIGVsUmVnaW9uKTtcbiAgbm9ybWFsaXplT2Zmc2V0KHRhcmdldE9mZnNldCwgcmVmTm9kZVJlZ2lvbik7XG4gIC8vIOW9k+WJjeiKgueCueWwhuimgeiiq+aUvue9rueahOS9jee9rlxuICB2YXIgZWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgcG9pbnRzLCBvZmZzZXQsIHRhcmdldE9mZnNldCk7XG4gIC8vIOW9k+WJjeiKgueCueWwhuimgeaJgOWkhOeahOWMuuWfn1xuICB2YXIgbmV3RWxSZWdpb24gPSBfdXRpbHMyWydkZWZhdWx0J10ubWVyZ2UoZWxSZWdpb24sIGVsRnV0dXJlUG9zKTtcblxuICAvLyDlpoLmnpzlj6/op4bljLrln5/kuI3og73lrozlhajmlL7nva7lvZPliY3oioLngrnml7blhYHorrjosIPmlbRcbiAgaWYgKHZpc2libGVSZWN0ICYmIChvdmVyZmxvdy5hZGp1c3RYIHx8IG92ZXJmbG93LmFkanVzdFkpKSB7XG4gICAgaWYgKG92ZXJmbG93LmFkanVzdFgpIHtcbiAgICAgIC8vIOWmguaenOaoquWQkeS4jeiDveaUvuS4i1xuICAgICAgaWYgKGlzRmFpbFgoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkpIHtcbiAgICAgICAgLy8g5a+56b2Q5L2N572u5Y+N5LiLXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBmbGlwKHBvaW50cywgL1tscl0vaWcsIHtcbiAgICAgICAgICBsOiAncicsXG4gICAgICAgICAgcjogJ2wnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyDlgY/np7vph4/kuZ/lj43kuItcbiAgICAgICAgdmFyIG5ld09mZnNldCA9IGZsaXBPZmZzZXQob2Zmc2V0LCAwKTtcbiAgICAgICAgdmFyIG5ld1RhcmdldE9mZnNldCA9IGZsaXBPZmZzZXQodGFyZ2V0T2Zmc2V0LCAwKTtcbiAgICAgICAgdmFyIG5ld0VsRnV0dXJlUG9zID0gKDAsIF9nZXRFbEZ1dHVyZVBvczJbJ2RlZmF1bHQnXSkoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIG5ld1BvaW50cywgbmV3T2Zmc2V0LCBuZXdUYXJnZXRPZmZzZXQpO1xuICAgICAgICBpZiAoIWlzQ29tcGxldGVGYWlsWChuZXdFbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAgIGZhaWwgPSAxO1xuICAgICAgICAgIHBvaW50cyA9IG5ld1BvaW50cztcbiAgICAgICAgICBvZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gbmV3VGFyZ2V0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJmbG93LmFkanVzdFkpIHtcbiAgICAgIC8vIOWmguaenOe6teWQkeS4jeiDveaUvuS4i1xuICAgICAgaWYgKGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkpIHtcbiAgICAgICAgLy8g5a+56b2Q5L2N572u5Y+N5LiLXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBmbGlwKHBvaW50cywgL1t0Yl0vaWcsIHtcbiAgICAgICAgICB0OiAnYicsXG4gICAgICAgICAgYjogJ3QnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyDlgY/np7vph4/kuZ/lj43kuItcbiAgICAgICAgdmFyIG5ld09mZnNldCA9IGZsaXBPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgdmFyIG5ld1RhcmdldE9mZnNldCA9IGZsaXBPZmZzZXQodGFyZ2V0T2Zmc2V0LCAxKTtcbiAgICAgICAgdmFyIG5ld0VsRnV0dXJlUG9zID0gKDAsIF9nZXRFbEZ1dHVyZVBvczJbJ2RlZmF1bHQnXSkoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIG5ld1BvaW50cywgbmV3T2Zmc2V0LCBuZXdUYXJnZXRPZmZzZXQpO1xuICAgICAgICBpZiAoIWlzQ29tcGxldGVGYWlsWShuZXdFbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAgIGZhaWwgPSAxO1xuICAgICAgICAgIHBvaW50cyA9IG5ld1BvaW50cztcbiAgICAgICAgICBvZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gbmV3VGFyZ2V0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g5aaC5p6c5aSx6LSl77yM6YeN5paw6K6h566X5b2T5YmN6IqC54K55bCG6KaB6KKr5pS+572u55qE5L2N572uXG4gICAgaWYgKGZhaWwpIHtcbiAgICAgIGVsRnV0dXJlUG9zID0gKDAsIF9nZXRFbEZ1dHVyZVBvczJbJ2RlZmF1bHQnXSkoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpO1xuICAgICAgX3V0aWxzMlsnZGVmYXVsdCddLm1peChuZXdFbFJlZ2lvbiwgZWxGdXR1cmVQb3MpO1xuICAgIH1cblxuICAgIC8vIOajgOafpeWPjeS4i+WQjueahOS9jee9ruaYr+WQpuWPr+S7peaUvuS4i+S6hlxuICAgIC8vIOWmguaenOS7jeeEtuaUvuS4jeS4i+WPquacieaMh+WumuS6huWPr+S7peiwg+aVtOW9k+WJjeaWueWQkeaJjeiwg+aVtFxuICAgIG5ld092ZXJmbG93Q2ZnLmFkanVzdFggPSBvdmVyZmxvdy5hZGp1c3RYICYmIGlzRmFpbFgoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCk7XG5cbiAgICBuZXdPdmVyZmxvd0NmZy5hZGp1c3RZID0gb3ZlcmZsb3cuYWRqdXN0WSAmJiBpc0ZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpO1xuXG4gICAgLy8g56Gu5a6e6KaB6LCD5pW077yM55Sa6Iez5Y+v6IO95Lya6LCD5pW06auY5bqm5a695bqmXG4gICAgaWYgKG5ld092ZXJmbG93Q2ZnLmFkanVzdFggfHwgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WSkge1xuICAgICAgbmV3RWxSZWdpb24gPSAoMCwgX2FkanVzdEZvclZpZXdwb3J0MlsnZGVmYXVsdCddKShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0LCBuZXdPdmVyZmxvd0NmZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gbmVlZCBqdWRnZSB0byBpbiBjYXNlIHNldCBmaXhlZCB3aXRoIGluIGNzcyBvbiBoZWlnaHQgYXV0byBlbGVtZW50XG4gIGlmIChuZXdFbFJlZ2lvbi53aWR0aCAhPT0gZWxSZWdpb24ud2lkdGgpIHtcbiAgICBfdXRpbHMyWydkZWZhdWx0J10uY3NzKHNvdXJjZSwgJ3dpZHRoJywgc291cmNlLndpZHRoKCkgKyBuZXdFbFJlZ2lvbi53aWR0aCAtIGVsUmVnaW9uLndpZHRoKTtcbiAgfVxuXG4gIGlmIChuZXdFbFJlZ2lvbi5oZWlnaHQgIT09IGVsUmVnaW9uLmhlaWdodCkge1xuICAgIF91dGlsczJbJ2RlZmF1bHQnXS5jc3Moc291cmNlLCAnaGVpZ2h0Jywgc291cmNlLmhlaWdodCgpICsgbmV3RWxSZWdpb24uaGVpZ2h0IC0gZWxSZWdpb24uaGVpZ2h0KTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzE5MFxuICAvLyBodHRwOi8vbG9jYWxob3N0Ojg4ODgva2lzc3kvc3JjL292ZXJsYXkvZGVtby9vdGhlci9yZWxhdGl2ZV9hbGlnbi9hbGlnbi5odG1sXG4gIC8vIOebuOWvueS6juWxj+W5leS9jee9ruayoeWPmO+8jOiAjCBsZWZ0L3RvcCDlj5jkuoZcbiAgLy8g5L6L5aaCIDxkaXYgJ3JlbGF0aXZlJz48ZWwgYWJzb2x1dGU+PC9kaXY+XG4gIF91dGlsczJbJ2RlZmF1bHQnXS5vZmZzZXQoc291cmNlLCB7XG4gICAgbGVmdDogbmV3RWxSZWdpb24ubGVmdCxcbiAgICB0b3A6IG5ld0VsUmVnaW9uLnRvcFxuICB9LCB7XG4gICAgdXNlQ3NzUmlnaHQ6IGFsaWduLnVzZUNzc1JpZ2h0LFxuICAgIHVzZUNzc0JvdHRvbTogYWxpZ24udXNlQ3NzQm90dG9tXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXQsXG4gICAgb3ZlcmZsb3c6IG5ld092ZXJmbG93Q2ZnXG4gIH07XG59XG5cbmRvbUFsaWduLl9fZ2V0T2Zmc2V0UGFyZW50ID0gX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXTtcblxuZG9tQWxpZ24uX19nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQgPSBfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50MlsnZGVmYXVsdCddO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBkb21BbGlnbjtcblxuLyoqXG4gKiAgMjAxMi0wNC0yNiB5aW1pbmdoZUBnbWFpbC5jb21cbiAqICAgLSDkvJjljJbmmbrog73lr7npvZDnrpfms5VcbiAqICAgLSDmhY7nlKggcmVzaXplWFhcbiAqXG4gKiAgMjAxMS0wNy0xMyB5aW1pbmdoZUBnbWFpbC5jb20gbm90ZTpcbiAqICAgLSDlop7liqDmmbrog73lr7npvZDvvIzku6Xlj4rlpKflsI/osIPmlbTpgInpoblcbiAqKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgUkVfTlVNID0gL1tcXC0rXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVtcXC0rXT9cXGQrfCkvLnNvdXJjZTtcblxudmFyIGdldENvbXB1dGVkU3R5bGVYID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBjc3MoZWwsIG5hbWUsIHYpIHtcbiAgdmFyIHZhbHVlID0gdjtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGkgaW4gbmFtZSkge1xuICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY3NzKGVsLCBpLCBuYW1lW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICsgJ3B4JztcbiAgICB9XG4gICAgZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbCwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFBvc2l0aW9uKGVsZW0pIHtcbiAgdmFyIGJveCA9IHVuZGVmaW5lZDtcbiAgdmFyIHggPSB1bmRlZmluZWQ7XG4gIHZhciB5ID0gdW5kZWZpbmVkO1xuICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICB2YXIgZG9jRWxlbSA9IGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyDmoLnmja4gR0JTIOacgOaWsOaVsOaNru+8jEEtR3JhZGUgQnJvd3NlcnMg6YO95bey5pSv5oyBIGdldEJvdW5kaW5nQ2xpZW50UmVjdCDmlrnms5XvvIzkuI3nlKjlho3ogIPomZHkvKDnu5/nmoTlrp7njrDmlrnlvI9cbiAgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAvLyDms6jvvJpqUXVlcnkg6L+Y6ICD6JmR5YeP5Y67IGRvY0VsZW0uY2xpZW50TGVmdC9jbGllbnRUb3BcbiAgLy8g5L2G5rWL6K+V5Y+R546w77yM6L+Z5qC35Y+N6ICM5Lya5a+86Ie05b2TIGh0bWwg5ZKMIGJvZHkg5pyJ6L656LedL+i+ueahhuagt+W8j+aXtu+8jOiOt+WPlueahOWAvOS4jeato+ehrlxuICAvLyDmraTlpJbvvIxpZTYg5Lya5b+955WlIGh0bWwg55qEIG1hcmdpbiDlgLzvvIzlubjov5DlnLDmmK/msqHmnInosIHkvJrljrvorr7nva4gaHRtbCDnmoQgbWFyZ2luXG5cbiAgeCA9IGJveC5sZWZ0O1xuICB5ID0gYm94LnRvcDtcblxuICAvLyBJbiBJRSwgbW9zdCBvZiB0aGUgdGltZSwgMiBleHRyYSBwaXhlbHMgYXJlIGFkZGVkIHRvIHRoZSB0b3AgYW5kIGxlZnRcbiAgLy8gZHVlIHRvIHRoZSBpbXBsaWNpdCAyLXBpeGVsIGluc2V0IGJvcmRlci4gIEluIElFNi83IHF1aXJrcyBtb2RlIGFuZFxuICAvLyBJRTYgc3RhbmRhcmRzIG1vZGUsIHRoaXMgYm9yZGVyIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhlXG4gIC8vIGRvY3VtZW50IGVsZW1lbnQncyBib3JkZXIgdG8gemVybyAtLSB0aHVzLCB3ZSBjYW5ub3QgcmVseSBvbiB0aGVcbiAgLy8gb2Zmc2V0IGFsd2F5cyBiZWluZyAyIHBpeGVscy5cblxuICAvLyBJbiBxdWlya3MgbW9kZSwgdGhlIG9mZnNldCBjYW4gYmUgZGV0ZXJtaW5lZCBieSBxdWVyeWluZyB0aGUgYm9keSdzXG4gIC8vIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgaW4gc3RhbmRhcmRzIG1vZGUsIGl0IGlzIGZvdW5kIGJ5IHF1ZXJ5aW5nXG4gIC8vIHRoZSBkb2N1bWVudCBlbGVtZW50J3MgY2xpZW50TGVmdC9jbGllbnRUb3AuICBTaW5jZSB3ZSBhbHJlYWR5IGNhbGxlZFxuICAvLyBnZXRDbGllbnRCb3VuZGluZ1JlY3Qgd2UgaGF2ZSBhbHJlYWR5IGZvcmNlZCBhIHJlZmxvdywgc28gaXQgaXMgbm90XG4gIC8vIHRvbyBleHBlbnNpdmUganVzdCB0byBxdWVyeSB0aGVtIGFsbC5cblxuICAvLyBpZSDkuIvlupTor6Xlh4/ljrvnqpflj6PnmoTovrnmoYblkKfvvIzmr5Xnq5/pu5jorqQgYWJzb2x1dGUg6YO95piv55u45a+556qX5Y+j5a6a5L2N55qEXG4gIC8vIOeql+WPo+i+ueahhuagh+WHhuaYr+iuviBkb2N1bWVudEVsZW1lbnQgLHF1aXJrcyDml7borr7nva4gYm9keVxuICAvLyDmnIDlpb3npoHmraLlnKggYm9keSDlkowgaHRtbCDkuIrovrnmoYYg77yM5L2GIGllIDwgOSBodG1sIOm7mOiupOaciSAycHgg77yM5YeP5Y67XG4gIC8vIOS9huaYr+mdniBpZSDkuI3lj6/og73orr7nva7nqpflj6PovrnmoYbvvIxib2R5IGh0bWwg5Lmf5LiN5piv56qX5Y+jICxpZSDlj6/ku6XpgJrov4cgaHRtbCxib2R5IOiuvue9rlxuICAvLyDmoIflh4YgaWUg5LiLIGRvY0VsZW0uY2xpZW50VG9wIOWwseaYryBib3JkZXItdG9wXG4gIC8vIGllNyBodG1sIOWNs+eql+WPo+i+ueahhuaUueWPmOS4jeS6huOAguawuOi/nOS4uiAyXG4gIC8vIOS9huagh+WHhiBmaXJlZm94L2Nocm9tZS9pZTkg5LiLIGRvY0VsZW0uY2xpZW50VG9wIOaYr+eql+WPo+i+ueahhu+8jOWNs+S9v+iuvuS6hiBib3JkZXItdG9wIOS5n+S4uiAwXG5cbiAgeCAtPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG4gIHkgLT0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcblxuICByZXR1cm4geyBsZWZ0OiB4LCB0b3A6IHkgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsKHcsIHRvcCkge1xuICB2YXIgcmV0ID0gd1sncGFnZScgKyAodG9wID8gJ1knIDogJ1gnKSArICdPZmZzZXQnXTtcbiAgdmFyIG1ldGhvZCA9ICdzY3JvbGwnICsgKHRvcCA/ICdUb3AnIDogJ0xlZnQnKTtcbiAgaWYgKHR5cGVvZiByZXQgIT09ICdudW1iZXInKSB7XG4gICAgdmFyIGQgPSB3LmRvY3VtZW50O1xuICAgIC8vIGllNiw3LDggc3RhbmRhcmQgbW9kZVxuICAgIHJldCA9IGQuZG9jdW1lbnRFbGVtZW50W21ldGhvZF07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdudW1iZXInKSB7XG4gICAgICAvLyBxdWlya3MgbW9kZVxuICAgICAgcmV0ID0gZC5ib2R5W21ldGhvZF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbExlZnQodykge1xuICByZXR1cm4gZ2V0U2Nyb2xsKHcpO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxUb3Aodykge1xuICByZXR1cm4gZ2V0U2Nyb2xsKHcsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgdmFyIHBvcyA9IGdldENsaWVudFBvc2l0aW9uKGVsKTtcbiAgdmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gIHBvcy5sZWZ0ICs9IGdldFNjcm9sbExlZnQodyk7XG4gIHBvcy50b3AgKz0gZ2V0U2Nyb2xsVG9wKHcpO1xuICByZXR1cm4gcG9zO1xufVxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbSwgbmFtZSwgY3MpIHtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBjcztcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgZCA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGUgfHwgZC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzYxXG4gIGlmIChjb21wdXRlZFN0eWxlKSB7XG4gICAgdmFsID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkU3R5bGVbbmFtZV07XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG52YXIgX1JFX05VTV9OT19QWCA9IG5ldyBSZWdFeHAoJ14oJyArIFJFX05VTSArICcpKD8hcHgpW2EteiVdKyQnLCAnaScpO1xudmFyIFJFX1BPUyA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLztcbnZhciBDVVJSRU5UX1NUWUxFID0gJ2N1cnJlbnRTdHlsZSc7XG52YXIgUlVOVElNRV9TVFlMRSA9ICdydW50aW1lU3R5bGUnO1xudmFyIExFRlQgPSAnbGVmdCc7XG52YXIgUFggPSAncHgnO1xuXG5mdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZUlFKGVsZW0sIG5hbWUpIHtcbiAgLy8gY3VycmVudFN0eWxlIG1heWJlIG51bGxcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM1MjMxLmFzcHhcbiAgdmFyIHJldCA9IGVsZW1bQ1VSUkVOVF9TVFlMRV0gJiYgZWxlbVtDVVJSRU5UX1NUWUxFXVtuYW1lXTtcblxuICAvLyDlvZMgd2lkdGgvaGVpZ2h0IOiuvue9ruS4uueZvuWIhuavlOaXtu+8jOmAmui/hyBwaXhlbExlZnQg5pa55byP6L2s5o2i55qEIHdpZHRoL2hlaWdodCDlgLxcbiAgLy8g5LiA5byA5aeL5bCx5aSE55CG5LqGISBDVVNUT01fU1RZTEUuaGVpZ2h0LENVU1RPTV9TVFlMRS53aWR0aCAsY3NzSG9vayDop6PlhrNAMjAxMS0wOC0xOVxuICAvLyDlnKggaWUg5LiL5LiN5a+577yM6ZyA6KaB55u05o6l55SoIG9mZnNldCDmlrnlvI9cbiAgLy8gYm9yZGVyV2lkdGgg562J5YC85Lmf5pyJ6Zeu6aKY77yM5L2G6ICD6JmR5YiwIGJvcmRlcldpZHRoIOiuvuS4uueZvuWIhuavlOeahOamgueOh+W+iOWwj++8jOi/memHjOWwseS4jeiAg+iZkeS6hlxuXG4gIC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcbiAgLy8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuICAvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcbiAgLy8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXG4gIC8vIGV4Y2x1ZGUgbGVmdCByaWdodCBmb3IgcmVsYXRpdml0eVxuICBpZiAoX1JFX05VTV9OT19QWC50ZXN0KHJldCkgJiYgIVJFX1BPUy50ZXN0KG5hbWUpKSB7XG4gICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgIHZhciBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gICAgdmFyIGxlZnQgPSBzdHlsZVtMRUZUXTtcbiAgICB2YXIgcnNMZWZ0ID0gZWxlbVtSVU5USU1FX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIHByZXZlbnQgZmxhc2hpbmcgb2YgY29udGVudFxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSBlbGVtW0NVUlJFTlRfU1RZTEVdW0xFRlRdO1xuXG4gICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgIHN0eWxlW0xFRlRdID0gbmFtZSA9PT0gJ2ZvbnRTaXplJyA/ICcxZW0nIDogcmV0IHx8IDA7XG4gICAgcmV0ID0gc3R5bGUucGl4ZWxMZWZ0ICsgUFg7XG5cbiAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgc3R5bGVbTEVGVF0gPSBsZWZ0O1xuXG4gICAgZWxlbVtSVU5USU1FX1NUWUxFXVtMRUZUXSA9IHJzTGVmdDtcbiAgfVxuICByZXR1cm4gcmV0ID09PSAnJyA/ICdhdXRvJyA6IHJldDtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdldENvbXB1dGVkU3R5bGVYID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBfZ2V0Q29tcHV0ZWRTdHlsZSA6IF9nZXRDb21wdXRlZFN0eWxlSUU7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldERpcmVjdGlvbihkaXIsIG9wdGlvbikge1xuICBpZiAoZGlyID09PSAnbGVmdCcpIHtcbiAgICByZXR1cm4gb3B0aW9uLnVzZUNzc1JpZ2h0ID8gJ3JpZ2h0JyA6IGRpcjtcbiAgfVxuICByZXR1cm4gb3B0aW9uLnVzZUNzc0JvdHRvbSA/ICdib3R0b20nIDogZGlyO1xufVxuXG5mdW5jdGlvbiBvcHBvc2l0ZU9mZnNldERpcmVjdGlvbihkaXIpIHtcbiAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgcmV0dXJuICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoZGlyID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfSBlbHNlIGlmIChkaXIgPT09ICd0b3AnKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9IGVsc2UgaWYgKGRpciA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH1cbn1cblxuLy8g6K6+572uIGVsZW0g55u45a+5IGVsZW0ub3duZXJEb2N1bWVudCDnmoTlnZDmoIdcbmZ1bmN0aW9uIHNldE9mZnNldChlbGVtLCBvZmZzZXQsIG9wdGlvbikge1xuICAvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG4gIGlmIChjc3MoZWxlbSwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIH1cbiAgdmFyIHByZXNldEggPSAtOTk5O1xuICB2YXIgcHJlc2V0ViA9IC05OTk7XG4gIHZhciBob3Jpem9udGFsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oJ2xlZnQnLCBvcHRpb24pO1xuICB2YXIgdmVydGljYWxQcm9wZXJ0eSA9IGdldE9mZnNldERpcmVjdGlvbigndG9wJywgb3B0aW9uKTtcbiAgdmFyIG9wcG9zaXRlSG9yaXpvbnRhbFByb3BlcnR5ID0gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oaG9yaXpvbnRhbFByb3BlcnR5KTtcbiAgdmFyIG9wcG9zaXRlVmVydGljYWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKHZlcnRpY2FsUHJvcGVydHkpO1xuXG4gIGlmIChob3Jpem9udGFsUHJvcGVydHkgIT09ICdsZWZ0Jykge1xuICAgIHByZXNldEggPSA5OTk7XG4gIH1cblxuICBpZiAodmVydGljYWxQcm9wZXJ0eSAhPT0gJ3RvcCcpIHtcbiAgICBwcmVzZXRWID0gOTk5O1xuICB9XG5cbiAgaWYgKCdsZWZ0JyBpbiBvZmZzZXQpIHtcbiAgICBlbGVtLnN0eWxlW29wcG9zaXRlSG9yaXpvbnRhbFByb3BlcnR5XSA9ICcnO1xuICAgIGVsZW0uc3R5bGVbaG9yaXpvbnRhbFByb3BlcnR5XSA9IHByZXNldEggKyAncHgnO1xuICB9XG4gIGlmICgndG9wJyBpbiBvZmZzZXQpIHtcbiAgICBlbGVtLnN0eWxlW29wcG9zaXRlVmVydGljYWxQcm9wZXJ0eV0gPSAnJztcbiAgICBlbGVtLnN0eWxlW3ZlcnRpY2FsUHJvcGVydHldID0gcHJlc2V0ViArICdweCc7XG4gIH1cbiAgdmFyIG9sZCA9IGdldE9mZnNldChlbGVtKTtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICBmb3IgKGtleSBpbiBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciBkaXIgPSBnZXRPZmZzZXREaXJlY3Rpb24oa2V5LCBvcHRpb24pO1xuICAgICAgdmFyIHByZXNldCA9IGtleSA9PT0gJ2xlZnQnID8gcHJlc2V0SCA6IHByZXNldFY7XG4gICAgICBpZiAoZGlyID09PSBrZXkpIHtcbiAgICAgICAgcmV0W2Rpcl0gPSBwcmVzZXQgKyBvZmZzZXRba2V5XSAtIG9sZFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0W2Rpcl0gPSBwcmVzZXQgKyBvbGRba2V5XSAtIG9mZnNldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjc3MoZWxlbSwgcmV0KTtcbn1cblxuZnVuY3Rpb24gZWFjaChhcnIsIGZuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4oYXJyW2ldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0JvcmRlckJveEZuKGVsZW0pIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGVYKGVsZW0sICdib3hTaXppbmcnKSA9PT0gJ2JvcmRlci1ib3gnO1xufVxuXG52YXIgQk9YX01PREVMUyA9IFsnbWFyZ2luJywgJ2JvcmRlcicsICdwYWRkaW5nJ107XG52YXIgQ09OVEVOVF9JTkRFWCA9IC0xO1xudmFyIFBBRERJTkdfSU5ERVggPSAyO1xudmFyIEJPUkRFUl9JTkRFWCA9IDE7XG52YXIgTUFSR0lOX0lOREVYID0gMDtcblxuZnVuY3Rpb24gc3dhcChlbGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgb2xkID0ge307XG4gIHZhciBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gIHZhciBuYW1lID0gdW5kZWZpbmVkO1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBvbGRbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICAgIHN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjay5jYWxsKGVsZW0pO1xuXG4gIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UEJNV2lkdGgoZWxlbSwgcHJvcHMsIHdoaWNoKSB7XG4gIHZhciB2YWx1ZSA9IDA7XG4gIHZhciBwcm9wID0gdW5kZWZpbmVkO1xuICB2YXIgaiA9IHVuZGVmaW5lZDtcbiAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gIGZvciAoaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgIHByb3AgPSBwcm9wc1tqXTtcbiAgICBpZiAocHJvcCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHdoaWNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjc3NQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocHJvcCA9PT0gJ2JvcmRlcicpIHtcbiAgICAgICAgICBjc3NQcm9wID0gcHJvcCArIHdoaWNoW2ldICsgJ1dpZHRoJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjc3NQcm9wID0gcHJvcCArIHdoaWNoW2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgY3NzUHJvcCkpIHx8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBBIGNydWRlIHdheSBvZiBkZXRlcm1pbmluZyBpZiBhbiBvYmplY3QgaXMgYSB3aW5kb3dcbiAqIEBtZW1iZXIgdXRpbFxuICovXG5mdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgLy8gbXVzdCB1c2UgPT0gZm9yIGllOFxuICAvKiBlc2xpbnQgZXFlcWVxOjAgKi9cbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogPT0gb2JqLndpbmRvdztcbn1cblxudmFyIGRvbVV0aWxzID0ge307XG5cbmVhY2goWydXaWR0aCcsICdIZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZG9tVXRpbHNbJ2RvYycgKyBuYW1lXSA9IGZ1bmN0aW9uIChyZWZXaW4pIHtcbiAgICB2YXIgZCA9IHJlZldpbi5kb2N1bWVudDtcbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgLy8gZmlyZWZveCBjaHJvbWUgZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDwgYm9keS5zY3JvbGxIZWlnaHRcbiAgICAvLyBpZSBzdGFuZGFyZCBtb2RlIDogZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodD4gYm9keS5zY3JvbGxIZWlnaHRcbiAgICBkLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIG5hbWVdLFxuICAgIC8vIHF1aXJrcyA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQg5pyA5aSn562J5LqO5Y+v6KeG56qX5Y+j5aSa5LiA54K577yfXG4gICAgZC5ib2R5WydzY3JvbGwnICsgbmFtZV0sIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXShkKSk7XG4gIH07XG5cbiAgZG9tVXRpbHNbJ3ZpZXdwb3J0JyArIG5hbWVdID0gZnVuY3Rpb24gKHdpbikge1xuICAgIC8vIHBjIGJyb3dzZXIgaW5jbHVkZXMgc2Nyb2xsYmFyIGluIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgdmFyIHByb3AgPSAnY2xpZW50JyArIG5hbWU7XG4gICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnRQcm9wID0gZG9jdW1lbnRFbGVtZW50W3Byb3BdO1xuICAgIC8vIOagh+WHhuaooeW8j+WPliBkb2N1bWVudEVsZW1lbnRcbiAgICAvLyBiYWNrY29tcGF0IOWPliBib2R5XG4gICAgcmV0dXJuIGRvYy5jb21wYXRNb2RlID09PSAnQ1NTMUNvbXBhdCcgJiYgZG9jdW1lbnRFbGVtZW50UHJvcCB8fCBib2R5ICYmIGJvZHlbcHJvcF0gfHwgZG9jdW1lbnRFbGVtZW50UHJvcDtcbiAgfTtcbn0pO1xuXG4vKlxuIOW+l+WIsOWFg+e0oOeahOWkp+Wwj+S/oeaBr1xuIEBwYXJhbSBlbGVtXG4gQHBhcmFtIG5hbWVcbiBAcGFyYW0ge1N0cmluZ30gW2V4dHJhXSAgJ3BhZGRpbmcnIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nXG4gJ2JvcmRlcicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXJcbiAnbWFyZ2luJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZyArIGJvcmRlciArIG1hcmdpblxuICovXG5mdW5jdGlvbiBnZXRXSChlbGVtLCBuYW1lLCBleCkge1xuICB2YXIgZXh0cmEgPSBleDtcbiAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICd3aWR0aCcgPyBkb21VdGlscy52aWV3cG9ydFdpZHRoKGVsZW0pIDogZG9tVXRpbHMudmlld3BvcnRIZWlnaHQoZWxlbSk7XG4gIH0gZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMuZG9jV2lkdGgoZWxlbSkgOiBkb21VdGlscy5kb2NIZWlnaHQoZWxlbSk7XG4gIH1cbiAgdmFyIHdoaWNoID0gbmFtZSA9PT0gJ3dpZHRoJyA/IFsnTGVmdCcsICdSaWdodCddIDogWydUb3AnLCAnQm90dG9tJ107XG4gIHZhciBib3JkZXJCb3hWYWx1ZSA9IG5hbWUgPT09ICd3aWR0aCcgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSk7XG4gIHZhciBpc0JvcmRlckJveCA9IGlzQm9yZGVyQm94Rm4oZWxlbSwgY29tcHV0ZWRTdHlsZSk7XG4gIHZhciBjc3NCb3hWYWx1ZSA9IDA7XG4gIGlmIChib3JkZXJCb3hWYWx1ZSA9PT0gbnVsbCB8fCBib3JkZXJCb3hWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGJvcmRlckJveFZhbHVlIDw9IDApIHtcbiAgICBib3JkZXJCb3hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1biBjb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG4gICAgY3NzQm94VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCBuYW1lKTtcbiAgICBpZiAoY3NzQm94VmFsdWUgPT09IG51bGwgfHwgY3NzQm94VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBOdW1iZXIoY3NzQm94VmFsdWUpIDwgMCkge1xuICAgICAgY3NzQm94VmFsdWUgPSBlbGVtLnN0eWxlW25hbWVdIHx8IDA7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSAnJywgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG4gICAgY3NzQm94VmFsdWUgPSBwYXJzZUZsb2F0KGNzc0JveFZhbHVlKSB8fCAwO1xuICB9XG4gIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmEgPSBpc0JvcmRlckJveCA/IEJPUkRFUl9JTkRFWCA6IENPTlRFTlRfSU5ERVg7XG4gIH1cbiAgdmFyIGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCA9IGJvcmRlckJveFZhbHVlICE9PSB1bmRlZmluZWQgfHwgaXNCb3JkZXJCb3g7XG4gIHZhciB2YWwgPSBib3JkZXJCb3hWYWx1ZSB8fCBjc3NCb3hWYWx1ZTtcbiAgaWYgKGV4dHJhID09PSBDT05URU5UX0lOREVYKSB7XG4gICAgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgICAgcmV0dXJuIHZhbCAtIGdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJywgJ3BhZGRpbmcnXSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3NzQm94VmFsdWU7XG4gIH0gZWxzZSBpZiAoYm9yZGVyQm94VmFsdWVPcklzQm9yZGVyQm94KSB7XG4gICAgaWYgKGV4dHJhID09PSBCT1JERVJfSU5ERVgpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWwgKyAoZXh0cmEgPT09IFBBRERJTkdfSU5ERVggPyAtZ2V0UEJNV2lkdGgoZWxlbSwgWydib3JkZXInXSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpIDogZ2V0UEJNV2lkdGgoZWxlbSwgWydtYXJnaW4nXSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpKTtcbiAgfVxuICByZXR1cm4gY3NzQm94VmFsdWUgKyBnZXRQQk1XaWR0aChlbGVtLCBCT1hfTU9ERUxTLnNsaWNlKGV4dHJhKSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpO1xufVxuXG52YXIgY3NzU2hvdyA9IHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHZpc2liaWxpdHk6ICdoaWRkZW4nLCBkaXNwbGF5OiAnYmxvY2snIH07XG5cbi8vIGZpeCAjMTE5IDogaHR0cHM6Ly9naXRodWIuY29tL2tpc3N5dGVhbS9raXNzeS9pc3N1ZXMvMTE5XG5mdW5jdGlvbiBnZXRXSElnbm9yZURpc3BsYXkoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciB2YWwgPSB1bmRlZmluZWQ7XG4gIHZhciBlbGVtID0gYXJnc1swXTtcbiAgLy8gaW4gY2FzZSBlbGVtIGlzIHdpbmRvd1xuICAvLyBlbGVtLm9mZnNldFdpZHRoID09PSB1bmRlZmluZWRcbiAgaWYgKGVsZW0ub2Zmc2V0V2lkdGggIT09IDApIHtcbiAgICB2YWwgPSBnZXRXSC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG5lYWNoKFsnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBmaXJzdCA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICBkb21VdGlsc1snb3V0ZXInICsgZmlyc3RdID0gZnVuY3Rpb24gKGVsLCBpbmNsdWRlTWFyZ2luKSB7XG4gICAgcmV0dXJuIGVsICYmIGdldFdISWdub3JlRGlzcGxheShlbCwgbmFtZSwgaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9JTkRFWCA6IEJPUkRFUl9JTkRFWCk7XG4gIH07XG4gIHZhciB3aGljaCA9IG5hbWUgPT09ICd3aWR0aCcgPyBbJ0xlZnQnLCAnUmlnaHQnXSA6IFsnVG9wJywgJ0JvdHRvbSddO1xuXG4gIGRvbVV0aWxzW25hbWVdID0gZnVuY3Rpb24gKGVsZW0sIHYpIHtcbiAgICB2YXIgdmFsID0gdjtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSk7XG4gICAgICAgIHZhciBpc0JvcmRlckJveCA9IGlzQm9yZGVyQm94Rm4oZWxlbSk7XG4gICAgICAgIGlmIChpc0JvcmRlckJveCkge1xuICAgICAgICAgIHZhbCArPSBnZXRQQk1XaWR0aChlbGVtLCBbJ3BhZGRpbmcnLCAnYm9yZGVyJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NzKGVsZW0sIG5hbWUsIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbSAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWxlbSwgbmFtZSwgQ09OVEVOVF9JTkRFWCk7XG4gIH07XG59KTtcblxuZnVuY3Rpb24gbWl4KHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGkgaW4gZnJvbSkge1xuICAgIGlmIChmcm9tLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICB0b1tpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxudmFyIHV0aWxzID0ge1xuICBnZXRXaW5kb3c6IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5kb2N1bWVudCAmJiBub2RlLnNldFRpbWVvdXQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGU7XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICB9LFxuICBvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldChlbCwgdmFsdWUsIG9wdGlvbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZXRPZmZzZXQoZWwsIHZhbHVlLCBvcHRpb24gfHwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0T2Zmc2V0KGVsKTtcbiAgICB9XG4gIH0sXG4gIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgZWFjaDogZWFjaCxcbiAgY3NzOiBjc3MsXG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICByZXRbaV0gPSBvYmpbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBvdmVyZmxvdyA9IG9iai5vdmVyZmxvdztcbiAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHJldC5vdmVyZmxvd1tpXSA9IG9iai5vdmVyZmxvd1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBtaXg6IG1peCxcbiAgZ2V0V2luZG93U2Nyb2xsTGVmdDogZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsTGVmdCh3KSB7XG4gICAgcmV0dXJuIGdldFNjcm9sbExlZnQodyk7XG4gIH0sXG4gIGdldFdpbmRvd1Njcm9sbFRvcDogZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsVG9wKHcpIHtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsVG9wKHcpO1xuICB9LFxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHV0aWxzLm1peChyZXQsIGFyZ3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICB2aWV3cG9ydFdpZHRoOiAwLFxuICB2aWV3cG9ydEhlaWdodDogMFxufTtcblxubWl4KHV0aWxzLCBkb21VdGlscyk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHV0aWxzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfQ2hpbGRyZW5VdGlscyA9IHJlcXVpcmUoJy4vQ2hpbGRyZW5VdGlscycpO1xuXG52YXIgX0FuaW1hdGVDaGlsZCA9IHJlcXVpcmUoJy4vQW5pbWF0ZUNoaWxkJyk7XG5cbnZhciBfQW5pbWF0ZUNoaWxkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FuaW1hdGVDaGlsZCk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZGVmYXVsdEtleSA9ICdyY19hbmltYXRlXycgKyBEYXRlLm5vdygpO1xuXG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICBpZiAoX3JlYWN0MltcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgaWYgKCFjaGlsZHJlbi5rZXkpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAga2V5OiBkZWZhdWx0S2V5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIEFuaW1hdGUgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQW5pbWF0ZScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY29tcG9uZW50OiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYW55LFxuICAgIGFuaW1hdGlvbjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9iamVjdCxcbiAgICB0cmFuc2l0aW9uTmFtZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHRyYW5zaXRpb25FbnRlcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkFwcGVhcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmJvb2wsXG4gICAgZXhjbHVzaXZlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uTGVhdmU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIG9uRW5kOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVudGVyOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxlYXZlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkFwcGVhcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2hvd1Byb3A6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5pbWF0aW9uOiB7fSxcbiAgICAgIGNvbXBvbmVudDogJ3NwYW4nLFxuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkFwcGVhcjogZmFsc2UsXG4gICAgICBvbkVuZDogbm9vcCxcbiAgICAgIG9uRW50ZXI6IG5vb3AsXG4gICAgICBvbkxlYXZlOiBub29wLFxuICAgICAgb25BcHBlYXI6IG5vb3BcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXMgPSB7fTtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHModGhpcy5wcm9wcykpXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2hvd1Byb3AgPSB0aGlzLnByb3BzLnNob3dQcm9wO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG4gICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuICEhY2hpbGQucHJvcHNbc2hvd1Byb3BdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgX3RoaXMucGVyZm9ybUFwcGVhcihjaGlsZC5rZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5uZXh0UHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKG5leHRQcm9wcykpO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgLy8gZXhjbHVzaXZlIG5lZWRzIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIGlmIChwcm9wcy5leGNsdXNpdmUpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF90aGlzMi5zdG9wKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNob3dQcm9wID0gcHJvcHMuc2hvd1Byb3A7XG4gICAgdmFyIGN1cnJlbnRseUFuaW1hdGluZ0tleXMgPSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXM7XG4gICAgLy8gbGFzdCBwcm9wcyBjaGlsZHJlbiBpZiBleGNsdXNpdmVcbiAgICB2YXIgY3VycmVudENoaWxkcmVuID0gcHJvcHMuZXhjbHVzaXZlID8gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpKSA6IHRoaXMuc3RhdGUuY2hpbGRyZW47XG4gICAgLy8gaW4gY2FzZSBkZXN0cm95IGluIHNob3dQcm9wIG1vZGVcbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgIGN1cnJlbnRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IGN1cnJlbnRDaGlsZCAmJiAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShuZXh0Q2hpbGRyZW4sIGN1cnJlbnRDaGlsZC5rZXkpO1xuICAgICAgICB2YXIgbmV3Q2hpbGQgPSB2b2lkIDA7XG4gICAgICAgIGlmICgoIW5leHRDaGlsZCB8fCAhbmV4dENoaWxkLnByb3BzW3Nob3dQcm9wXSkgJiYgY3VycmVudENoaWxkLnByb3BzW3Nob3dQcm9wXSkge1xuICAgICAgICAgIG5ld0NoaWxkID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG5leHRDaGlsZCB8fCBjdXJyZW50Q2hpbGQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc2hvd1Byb3AsIHRydWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDaGlsZCA9IG5leHRDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXh0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobmV4dENoaWxkKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkIHx8ICEoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXh0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMubWVyZ2VDaGlsZHJlbikoY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIG5lZWQgcmVuZGVyIHRvIGF2b2lkIHVwZGF0ZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuXG4gICAgfSk7XG5cbiAgICBuZXh0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBjaGlsZCAmJiBjaGlsZC5rZXk7XG4gICAgICBpZiAoY2hpbGQgJiYgY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNQcmV2ID0gY2hpbGQgJiYgKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXkpO1xuICAgICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICAgIHZhciBzaG93SW5OZXh0ID0gY2hpbGQucHJvcHNbc2hvd1Byb3BdO1xuICAgICAgICBpZiAoaGFzUHJldikge1xuICAgICAgICAgIHZhciBzaG93SW5Ob3cgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgICAgICAgaWYgKCFzaG93SW5Ob3cgJiYgc2hvd0luTmV4dCkge1xuICAgICAgICAgICAgX3RoaXMyLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvd0luTmV4dCkge1xuICAgICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWhhc1ByZXYpIHtcbiAgICAgICAgX3RoaXMyLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGN1cnJlbnRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGtleSA9IGNoaWxkICYmIGNoaWxkLmtleTtcbiAgICAgIGlmIChjaGlsZCAmJiBjdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc05leHQgPSBjaGlsZCAmJiAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShuZXh0Q2hpbGRyZW4sIGtleSk7XG4gICAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgICAgdmFyIHNob3dJbk5vdyA9IGNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgICAgaWYgKGhhc05leHQpIHtcbiAgICAgICAgICB2YXIgc2hvd0luTmV4dCA9ICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICAgICAgICBpZiAoIXNob3dJbk5leHQgJiYgc2hvd0luTm93KSB7XG4gICAgICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaG93SW5Ob3cpIHtcbiAgICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgIF90aGlzMi5rZXlzVG9MZWF2ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIGtleXNUb0VudGVyLmZvckVhY2godGhpcy5wZXJmb3JtRW50ZXIpO1xuICAgIHZhciBrZXlzVG9MZWF2ZSA9IHRoaXMua2V5c1RvTGVhdmU7XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgIGtleXNUb0xlYXZlLmZvckVhY2godGhpcy5wZXJmb3JtTGVhdmUpO1xuICB9LFxuICBwZXJmb3JtRW50ZXI6IGZ1bmN0aW9uIHBlcmZvcm1FbnRlcihrZXkpIHtcbiAgICAvLyBtYXkgYWxyZWFkeSByZW1vdmUgYnkgZXhjbHVzaXZlXG4gICAgaWYgKHRoaXMucmVmc1trZXldKSB7XG4gICAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSA9IHRydWU7XG4gICAgICB0aGlzLnJlZnNba2V5XS5jb21wb25lbnRXaWxsRW50ZXIodGhpcy5oYW5kbGVEb25lQWRkaW5nLmJpbmQodGhpcywga2V5LCAnZW50ZXInKSk7XG4gICAgfVxuICB9LFxuICBwZXJmb3JtQXBwZWFyOiBmdW5jdGlvbiBwZXJmb3JtQXBwZWFyKGtleSkge1xuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEFwcGVhcih0aGlzLmhhbmRsZURvbmVBZGRpbmcuYmluZCh0aGlzLCBrZXksICdhcHBlYXInKSk7XG4gICAgfVxuICB9LFxuICBoYW5kbGVEb25lQWRkaW5nOiBmdW5jdGlvbiBoYW5kbGVEb25lQWRkaW5nKGtleSwgdHlwZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldO1xuICAgIC8vIGlmIHVwZGF0ZSBvbiBleGNsdXNpdmUgbW9kZSwgc2tpcCBjaGVja1xuICAgIGlmIChwcm9wcy5leGNsdXNpdmUgJiYgcHJvcHMgIT09IHRoaXMubmV4dFByb3BzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykpO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQ2hpbGRCeUtleShjdXJyZW50Q2hpbGRyZW4sIGtleSkpIHtcbiAgICAgIC8vIGV4Y2x1c2l2ZSB3aWxsIG5vdCBuZWVkIHRoaXNcbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnYXBwZWFyJykge1xuICAgICAgICBpZiAoX3V0aWwyW1wiZGVmYXVsdFwiXS5hbGxvd0FwcGVhckNhbGxiYWNrKHByb3BzKSkge1xuICAgICAgICAgIHByb3BzLm9uQXBwZWFyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF91dGlsMltcImRlZmF1bHRcIl0uYWxsb3dFbnRlckNhbGxiYWNrKHByb3BzKSkge1xuICAgICAgICAgIHByb3BzLm9uRW50ZXIoa2V5KTtcbiAgICAgICAgICBwcm9wcy5vbkVuZChrZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwZXJmb3JtTGVhdmU6IGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZShrZXkpIHtcbiAgICAvLyBtYXkgYWxyZWFkeSByZW1vdmUgYnkgZXhjbHVzaXZlXG4gICAgaWYgKHRoaXMucmVmc1trZXldKSB7XG4gICAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSA9IHRydWU7XG4gICAgICB0aGlzLnJlZnNba2V5XS5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH1cbiAgfSxcbiAgaGFuZGxlRG9uZUxlYXZpbmc6IGZ1bmN0aW9uIGhhbmRsZURvbmVMZWF2aW5nKGtleSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldO1xuICAgIC8vIGlmIHVwZGF0ZSBvbiBleGNsdXNpdmUgbW9kZSwgc2tpcCBjaGVja1xuICAgIGlmIChwcm9wcy5leGNsdXNpdmUgJiYgcHJvcHMgIT09IHRoaXMubmV4dFByb3BzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykpO1xuICAgIC8vIGluIGNhc2Ugc3RhdGUgY2hhbmdlIGlzIHRvbyBmYXN0XG4gICAgaWYgKHRoaXMuaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpKSB7XG4gICAgICB0aGlzLnBlcmZvcm1FbnRlcihrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kID0gZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICBpZiAoX3V0aWwyW1wiZGVmYXVsdFwiXS5hbGxvd0xlYXZlQ2FsbGJhY2socHJvcHMpKSB7XG4gICAgICAgICAgcHJvcHMub25MZWF2ZShrZXkpO1xuICAgICAgICAgIHByb3BzLm9uRW5kKGtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyogZXNsaW50IHJlYWN0L25vLWlzLW1vdW50ZWQ6MCAqL1xuICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgISgwLCBfQ2hpbGRyZW5VdGlscy5pc1NhbWVDaGlsZHJlbikodGhpcy5zdGF0ZS5jaGlsZHJlbiwgY3VycmVudENoaWxkcmVuLCBwcm9wcy5zaG93UHJvcCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgY2hpbGRyZW46IGN1cnJlbnRDaGlsZHJlblxuICAgICAgICB9LCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1ZhbGlkQ2hpbGRCeUtleTogZnVuY3Rpb24gaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpIHtcbiAgICB2YXIgc2hvd1Byb3AgPSB0aGlzLnByb3BzLnNob3dQcm9wO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5KTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcChrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC5zdG9wKCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHRoaXMubmV4dFByb3BzID0gcHJvcHM7XG4gICAgdmFyIHN0YXRlQ2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gICAgaWYgKHN0YXRlQ2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuID0gc3RhdGVDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGQua2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNldCBrZXkgZm9yIDxyYy1hbmltYXRlPiBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9BbmltYXRlQ2hpbGQyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGNoaWxkLmtleSxcbiAgICAgICAgICAgIHJlZjogY2hpbGQua2V5LFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBwcm9wcy5hbmltYXRpb24sXG4gICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogcHJvcHMudHJhbnNpdGlvbk5hbWUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRW50ZXI6IHByb3BzLnRyYW5zaXRpb25FbnRlcixcbiAgICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHByb3BzLnRyYW5zaXRpb25BcHBlYXIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uTGVhdmU6IHByb3BzLnRyYW5zaXRpb25MZWF2ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgQ29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50O1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIHZhciBwYXNzZWRQcm9wcyA9IHByb3BzO1xuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhc3NlZFByb3BzID0ge1xuICAgICAgICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcGFzc2VkUHJvcHMsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQW5pbWF0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9jc3NBbmltYXRpb24gPSByZXF1aXJlKCdjc3MtYW5pbWF0aW9uJyk7XG5cbnZhciBfY3NzQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc0FuaW1hdGlvbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgdHJhbnNpdGlvbk1hcCA9IHtcbiAgZW50ZXI6ICd0cmFuc2l0aW9uRW50ZXInLFxuICBhcHBlYXI6ICd0cmFuc2l0aW9uQXBwZWFyJyxcbiAgbGVhdmU6ICd0cmFuc2l0aW9uTGVhdmUnXG59O1xuXG52YXIgQW5pbWF0ZUNoaWxkID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0FuaW1hdGVDaGlsZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY2hpbGRyZW46IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxFbnRlcjogZnVuY3Rpb24gY29tcG9uZW50V2lsbEVudGVyKGRvbmUpIHtcbiAgICBpZiAoX3V0aWwyW1wiZGVmYXVsdFwiXS5pc0VudGVyU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2VudGVyJywgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxBcHBlYXI6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxBcHBlYXIoZG9uZSkge1xuICAgIGlmIChfdXRpbDJbXCJkZWZhdWx0XCJdLmlzQXBwZWFyU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2FwcGVhcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsTGVhdmU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxMZWF2ZShkb25lKSB7XG4gICAgaWYgKF91dGlsMltcImRlZmF1bHRcIl0uaXNMZWF2ZVN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbHdheXMgc3luYywgZG8gbm90IGludGVydXB0IHdpdGggcmVhY3QgY29tcG9uZW50IGxpZmUgY3ljbGVcbiAgICAgIC8vIHVwZGF0ZSBoaWRkZW4gLT4gYW5pbWF0ZSBoaWRkZW4gLT5cbiAgICAgIC8vIGRpZFVwZGF0ZSAtPiBhbmltYXRlIGxlYXZlIC0+IHVubW91bnQgKGlmIGFuaW1hdGUgaXMgbm9uZSlcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24oYW5pbWF0aW9uVHlwZSwgZmluaXNoQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG5vZGUgPSBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBuYW1lSXNPYmogPSAodHlwZW9mIHRyYW5zaXRpb25OYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0cmFuc2l0aW9uTmFtZSkpID09PSAnb2JqZWN0JztcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gZW5kKCkge1xuICAgICAgX3RoaXMuc3RvcHBlciA9IG51bGw7XG4gICAgICBmaW5pc2hDYWxsYmFjaygpO1xuICAgIH07XG4gICAgaWYgKChfY3NzQW5pbWF0aW9uLmlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkIHx8ICFwcm9wcy5hbmltYXRpb25bYW5pbWF0aW9uVHlwZV0pICYmIHRyYW5zaXRpb25OYW1lICYmIHByb3BzW3RyYW5zaXRpb25NYXBbYW5pbWF0aW9uVHlwZV1dKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVJc09iaiA/IHRyYW5zaXRpb25OYW1lW2FuaW1hdGlvblR5cGVdIDogdHJhbnNpdGlvbk5hbWUgKyAnLScgKyBhbmltYXRpb25UeXBlO1xuICAgICAgdGhpcy5zdG9wcGVyID0gKDAsIF9jc3NBbmltYXRpb24yW1wiZGVmYXVsdFwiXSkobm9kZSwgbmFtZSwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wcGVyID0gcHJvcHMuYW5pbWF0aW9uW2FuaW1hdGlvblR5cGVdKG5vZGUsIGVuZCk7XG4gICAgfVxuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBzdG9wcGVyID0gdGhpcy5zdG9wcGVyO1xuICAgIGlmIChzdG9wcGVyKSB7XG4gICAgICB0aGlzLnN0b3BwZXIgPSBudWxsO1xuICAgICAgc3RvcHBlci5zdG9wKCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQW5pbWF0ZUNoaWxkO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50b0FycmF5Q2hpbGRyZW4gPSB0b0FycmF5Q2hpbGRyZW47XG5leHBvcnRzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSA9IGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkgPSBmaW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5ID0gZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5O1xuZXhwb3J0cy5pc1NhbWVDaGlsZHJlbiA9IGlzU2FtZUNoaWxkcmVuO1xuZXhwb3J0cy5tZXJnZUNoaWxkcmVuID0gbWVyZ2VDaGlsZHJlbjtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9BcnJheUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0LnB1c2goY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXkpIHtcbiAgdmFyIHJldCA9IG51bGw7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICByZXQgPSBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5LCBzaG93UHJvcCkge1xuICB2YXIgcmV0ID0gbnVsbDtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSAmJiBjaGlsZC5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHdvIGNoaWxkIHdpdGggc2FtZSBrZXkgZm9yIDxyYy1hbmltYXRlPiBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5LCBzaG93UHJvcCkge1xuICB2YXIgZm91bmQgPSAwO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvdW5kID0gY2hpbGQgJiYgY2hpbGQua2V5ID09PSBrZXkgJiYgIWNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkcmVuKGMxLCBjMiwgc2hvd1Byb3ApIHtcbiAgdmFyIHNhbWUgPSBjMS5sZW5ndGggPT09IGMyLmxlbmd0aDtcbiAgaWYgKHNhbWUpIHtcbiAgICBjMS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZDIgPSBjMltpbmRleF07XG4gICAgICBpZiAoY2hpbGQgJiYgY2hpbGQyKSB7XG4gICAgICAgIGlmIChjaGlsZCAmJiAhY2hpbGQyIHx8ICFjaGlsZCAmJiBjaGlsZDIpIHtcbiAgICAgICAgICBzYW1lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQua2V5ICE9PSBjaGlsZDIua2V5KSB7XG4gICAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNob3dQcm9wICYmIGNoaWxkLnByb3BzW3Nob3dQcm9wXSAhPT0gY2hpbGQyLnByb3BzW3Nob3dQcm9wXSkge1xuICAgICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzYW1lO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuKHByZXYsIG5leHQpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuICB2YXIgbmV4dENoaWxkcmVuUGVuZGluZyA9IHt9O1xuICB2YXIgcGVuZGluZ0NoaWxkcmVuID0gW107XG4gIHByZXYuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KG5leHQsIGNoaWxkLmtleSkpIHtcbiAgICAgIGlmIChwZW5kaW5nQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG5leHRDaGlsZHJlblBlbmRpbmdbY2hpbGQua2V5XSA9IHBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH0pO1xuXG4gIG5leHQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgbmV4dENoaWxkcmVuUGVuZGluZy5oYXNPd25Qcm9wZXJ0eShjaGlsZC5rZXkpKSB7XG4gICAgICByZXQgPSByZXQuY29uY2F0KG5leHRDaGlsZHJlblBlbmRpbmdbY2hpbGQua2V5XSk7XG4gICAgfVxuICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgfSk7XG5cbiAgcmV0ID0gcmV0LmNvbmNhdChwZW5kaW5nQ2hpbGRyZW4pO1xuXG4gIHJldHVybiByZXQ7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBleHBvcnQgdGhpcyBwYWNrYWdlJ3MgYXBpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vQW5pbWF0ZScpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHV0aWwgPSB7XG4gIGlzQXBwZWFyU3VwcG9ydGVkOiBmdW5jdGlvbiBpc0FwcGVhclN1cHBvcnRlZChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy50cmFuc2l0aW9uQXBwZWFyIHx8IHByb3BzLmFuaW1hdGlvbi5hcHBlYXI7XG4gIH0sXG4gIGlzRW50ZXJTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzRW50ZXJTdXBwb3J0ZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMudHJhbnNpdGlvbkVudGVyIHx8IHByb3BzLmFuaW1hdGlvbi5lbnRlcjtcbiAgfSxcbiAgaXNMZWF2ZVN1cHBvcnRlZDogZnVuY3Rpb24gaXNMZWF2ZVN1cHBvcnRlZChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy50cmFuc2l0aW9uTGVhdmUgfHwgcHJvcHMuYW5pbWF0aW9uLmxlYXZlO1xuICB9LFxuICBhbGxvd0FwcGVhckNhbGxiYWNrOiBmdW5jdGlvbiBhbGxvd0FwcGVhckNhbGxiYWNrKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zaXRpb25BcHBlYXIgfHwgcHJvcHMuYW5pbWF0aW9uLmFwcGVhcjtcbiAgfSxcbiAgYWxsb3dFbnRlckNhbGxiYWNrOiBmdW5jdGlvbiBhbGxvd0VudGVyQ2FsbGJhY2socHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbkVudGVyIHx8IHByb3BzLmFuaW1hdGlvbi5lbnRlcjtcbiAgfSxcbiAgYWxsb3dMZWF2ZUNhbGxiYWNrOiBmdW5jdGlvbiBhbGxvd0xlYXZlQ2FsbGJhY2socHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbkxlYXZlIHx8IHByb3BzLmFuaW1hdGlvbi5sZWF2ZTtcbiAgfVxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdXRpbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBFVkVOVF9OQU1FX01BUCA9IHtcbiAgdHJhbnNpdGlvbmVuZDoge1xuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbjogJ21velRyYW5zaXRpb25FbmQnLFxuICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgIG1zVHJhbnNpdGlvbjogJ01TVHJhbnNpdGlvbkVuZCdcbiAgfSxcblxuICBhbmltYXRpb25lbmQ6IHtcbiAgICBhbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxuICAgIFdlYmtpdEFuaW1hdGlvbjogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgTW96QW5pbWF0aW9uOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICBPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgbXNBbmltYXRpb246ICdNU0FuaW1hdGlvbkVuZCdcbiAgfVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICB9XG5cbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cblxuICBmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG4gICAgaWYgKEVWRU5UX05BTUVfTUFQLmhhc093blByb3BlcnR5KGJhc2VFdmVudE5hbWUpKSB7XG4gICAgICB2YXIgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIGJhc2VFdmVudHMpIHtcbiAgICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZGV0ZWN0RXZlbnRzKCk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG52YXIgVHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgYWRkRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGV2ZW50TGlzdGVuZXIsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgZW5kRXZlbnRzOiBlbmRFdmVudHMsXG5cbiAgcmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUcmFuc2l0aW9uRXZlbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0V2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xuXG52YXIgX0V2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50KTtcblxudmFyIF9jb21wb25lbnRDbGFzc2VzID0gcmVxdWlyZSgnY29tcG9uZW50LWNsYXNzZXMnKTtcblxudmFyIF9jb21wb25lbnRDbGFzc2VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudENsYXNzZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIGlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkID0gX0V2ZW50MltcImRlZmF1bHRcIl0uZW5kRXZlbnRzLmxlbmd0aCAhPT0gMDtcblxuXG52YXIgY2FwaXRhbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLFxuLy8gbXMgaXMgc3BlY2lhbCAuLi4uICFcbidtcyddO1xudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctby0nLCAnbXMtJywgJyddO1xuXG5mdW5jdGlvbiBnZXREdXJhdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gIHZhciByZXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHJldCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJlZml4ZXNbaV0gKyBuYW1lKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZml4QnJvd3NlckJ5VGltZW91dChub2RlKSB7XG4gIGlmIChpc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCkge1xuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldER1cmF0aW9uKG5vZGUsICd0cmFuc2l0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdChnZXREdXJhdGlvbihub2RlLCAnYW5pbWF0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgdmFyIHRpbWUgPSBNYXRoLm1heCh0cmFuc2l0aW9uRHVyYXRpb24sIGFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAvLyBzb21ldGltZXMsIGJyb3dzZXIgYnVnXG4gICAgbm9kZS5yY0VuZEFuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLnJjRW5kQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9LCB0aW1lICogMTAwMCArIDIwMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKSB7XG4gIGlmIChub2RlLnJjRW5kQW5pbVRpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQobm9kZS5yY0VuZEFuaW1UaW1lb3V0KTtcbiAgICBub2RlLnJjRW5kQW5pbVRpbWVvdXQgPSBudWxsO1xuICB9XG59XG5cbnZhciBjc3NBbmltYXRpb24gPSBmdW5jdGlvbiBjc3NBbmltYXRpb24obm9kZSwgdHJhbnNpdGlvbk5hbWUsIGVuZENhbGxiYWNrKSB7XG4gIHZhciBjbGFzc05hbWUgPSB0cmFuc2l0aW9uTmFtZTtcbiAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctYWN0aXZlJztcbiAgdmFyIGVuZCA9IGVuZENhbGxiYWNrO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBhY3RpdmUgPSB2b2lkIDA7XG4gIHZhciBub2RlQ2xhc3NlcyA9ICgwLCBfY29tcG9uZW50Q2xhc3NlczJbXCJkZWZhdWx0XCJdKShub2RlKTtcblxuICBpZiAoZW5kQ2FsbGJhY2sgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVuZENhbGxiYWNrKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBlbmQgPSBlbmRDYWxsYmFjay5lbmQ7XG4gICAgc3RhcnQgPSBlbmRDYWxsYmFjay5zdGFydDtcbiAgICBhY3RpdmUgPSBlbmRDYWxsYmFjay5hY3RpdmU7XG4gIH1cblxuICBpZiAobm9kZS5yY0VuZExpc3RlbmVyKSB7XG4gICAgbm9kZS5yY0VuZExpc3RlbmVyKCk7XG4gIH1cblxuICBub2RlLnJjRW5kTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucmNBbmltVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KG5vZGUucmNBbmltVGltZW91dCk7XG4gICAgICBub2RlLnJjQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGNsZWFyQnJvd3NlckJ1Z1RpbWVvdXQobm9kZSk7XG5cbiAgICBub2RlQ2xhc3Nlcy5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICBub2RlQ2xhc3Nlcy5yZW1vdmUoYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgIF9FdmVudDJbXCJkZWZhdWx0XCJdLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgLy8gVXN1YWxseSB0aGlzIG9wdGlvbmFsIGVuZCBpcyB1c2VkIGZvciBpbmZvcm1pbmcgYW4gb3duZXIgb2ZcbiAgICAvLyBhIGxlYXZlIGFuaW1hdGlvbiBhbmQgdGVsbGluZyBpdCB0byByZW1vdmUgdGhlIGNoaWxkLlxuICAgIGlmIChlbmQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfRXZlbnQyW1wiZGVmYXVsdFwiXS5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIG5vZGUucmNFbmRMaXN0ZW5lcik7XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgc3RhcnQoKTtcbiAgfVxuICBub2RlQ2xhc3Nlcy5hZGQoY2xhc3NOYW1lKTtcblxuICBub2RlLnJjQW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLnJjQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgIG5vZGVDbGFzc2VzLmFkZChhY3RpdmVDbGFzc05hbWUpO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIHNldFRpbWVvdXQoYWN0aXZlLCAwKTtcbiAgICB9XG4gICAgZml4QnJvd3NlckJ5VGltZW91dChub2RlKTtcbiAgICAvLyAzMG1zIGZvciBmaXJlZm94XG4gIH0sIDMwKTtcblxuICByZXR1cm4ge1xuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAobm9kZS5yY0VuZExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmNzc0FuaW1hdGlvbi5zdHlsZSA9IGZ1bmN0aW9uIChub2RlLCBzdHlsZSwgY2FsbGJhY2spIHtcbiAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICB9XG5cbiAgbm9kZS5yY0VuZExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJjQW5pbVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChub2RlLnJjQW5pbVRpbWVvdXQpO1xuICAgICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGVhckJyb3dzZXJCdWdUaW1lb3V0KG5vZGUpO1xuXG4gICAgX0V2ZW50MltcImRlZmF1bHRcIl0ucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBub2RlLnJjRW5kTGlzdGVuZXIpO1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lciA9IG51bGw7XG5cbiAgICAvLyBVc3VhbGx5IHRoaXMgb3B0aW9uYWwgY2FsbGJhY2sgaXMgdXNlZCBmb3IgaW5mb3JtaW5nIGFuIG93bmVyIG9mXG4gICAgLy8gYSBsZWF2ZSBhbmltYXRpb24gYW5kIHRlbGxpbmcgaXQgdG8gcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIF9FdmVudDJbXCJkZWZhdWx0XCJdLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcblxuICBub2RlLnJjQW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzIGluIHN0eWxlKSB7XG4gICAgICBpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgbm9kZS5zdHlsZVtzXSA9IHN0eWxlW3NdO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnJjQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgIGZpeEJyb3dzZXJCeVRpbWVvdXQobm9kZSk7XG4gIH0sIDApO1xufTtcblxuY3NzQW5pbWF0aW9uLnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcCwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5ID0gcDtcbiAgdmFyIHYgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2ID0gcHJvcGVydHk7XG4gICAgcHJvcGVydHkgPSAnJztcbiAgfVxuICBwcm9wZXJ0eSA9IHByb3BlcnR5IHx8ICcnO1xuICBjYXBpdGFsUHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgbm9kZS5zdHlsZVtwcmVmaXggKyAnVHJhbnNpdGlvbicgKyBwcm9wZXJ0eV0gPSB2O1xuICB9KTtcbn07XG5cbmNzc0FuaW1hdGlvbi5pc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCA9IGlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNzc0FuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG50cnkge1xuICB2YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG59IGNhdGNoIChlcnIpIHtcbiAgdmFyIGluZGV4ID0gcmVxdWlyZSgnY29tcG9uZW50LWluZGV4b2YnKTtcbn1cblxuLyoqXG4gKiBXaGl0ZXNwYWNlIHJlZ2V4cC5cbiAqL1xuXG52YXIgcmUgPSAvXFxzKy87XG5cbi8qKlxuICogdG9TdHJpbmcgcmVmZXJlbmNlLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVsKXtcbiAgcmV0dXJuIG5ldyBDbGFzc0xpc3QoZWwpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IENsYXNzTGlzdCBmb3IgYGVsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWwpIHtcbiAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIGBuYW1lYCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSl7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcbiAgaWYgKCF+aSkgYXJyLnB1c2gobmFtZSk7XG4gIHRoaXMuZWwuY2xhc3NOYW1lID0gYXJyLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyBgbmFtZWAgd2hlbiBwcmVzZW50LCBvclxuICogcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmVcbiAqIGFueSB3aGljaCBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKXtcbiAgaWYgKCdbb2JqZWN0IFJlZ0V4cF0nID09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZyhuYW1lKTtcbiAgfVxuXG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcbiAgaWYgKH5pKSBhcnIuc3BsaWNlKGksIDEpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGNsYXNzZXMgbWF0Y2hpbmcgYHJlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbihyZSl7XG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlLnRlc3QoYXJyW2ldKSkge1xuICAgICAgdGhpcy5yZW1vdmUoYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBjbGFzcyBgbmFtZWAsIGNhbiBmb3JjZSBzdGF0ZSB2aWEgYGZvcmNlYC5cbiAqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxuICogdGhlIG1pc3Rha2Ugd2lsbCBiZSBkZXRlY3RlZCBhbmQgY29ycmVjdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24obmFtZSwgZm9yY2Upe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcbiAgICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTsgLy8gdG9nZ2xlIGFnYWluIHRvIGNvcnJlY3RcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpe1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gIHZhciBzdHIgPSBjbGFzc05hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICB2YXIgYXJyID0gc3RyLnNwbGl0KHJlKTtcbiAgaWYgKCcnID09PSBhcnJbMF0pIGFyci5zaGlmdCgpO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmhhcyA9XG5DbGFzc0xpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiB0aGlzLmxpc3RcbiAgICA/IHRoaXMubGlzdC5jb250YWlucyhuYW1lKVxuICAgIDogISEgfmluZGV4KHRoaXMuYXJyYXkoKSwgbmFtZSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChhcnIuaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBhZGRFdmVudExpc3RlbmVyV3JhcDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2FkZERvbUV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdhZGQtZG9tLWV2ZW50LWxpc3RlbmVyJyk7XG5cbnZhciBfYWRkRG9tRXZlbnRMaXN0ZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGREb21FdmVudExpc3RlbmVyKTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcldyYXAodGFyZ2V0LCBldmVudFR5cGUsIGNiKSB7XG4gIC8qIGVzbGludCBjYW1lbGNhc2U6IDIgKi9cbiAgdmFyIGNhbGxiYWNrID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID8gZnVuY3Rpb24gcnVuKGUpIHtcbiAgICBfcmVhY3REb20yWydkZWZhdWx0J10udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoY2IsIGUpO1xuICB9IDogY2I7XG4gIHJldHVybiAoMCwgX2FkZERvbUV2ZW50TGlzdGVuZXIyWydkZWZhdWx0J10pKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnRhaW5zKHJvb3QsIG4pIHtcbiAgdmFyIG5vZGUgPSBuO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07IiwiLyoqXG4gKiBTYWZlIGNoYWluZWQgZnVuY3Rpb25cbiAqXG4gKiBXaWxsIG9ubHkgY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIGlmIG5lZWRlZCxcbiAqIG90aGVyd2lzZSB3aWxsIHBhc3MgYmFjayBleGlzdGluZyBmdW5jdGlvbnMgb3IgbnVsbC5cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb258bnVsbH1cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbigpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnc1tpXSAmJiBhcmdzW2ldLmFwcGx5KSB7XG4gICAgICAgIGFyZ3NbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uOyIsIi8qKlxuICogQGlnbm9yZVxuICogYmFzZSBldmVudCBvYmplY3QgZm9yIGN1c3RvbSBhbmQgZG9tIGV2ZW50LlxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEJhc2VPYmplY3QoKSB7XG4gIHRoaXMudGltZVN0YW1wID0gRGF0ZS5ub3coKTtcbiAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuRXZlbnRCYXNlT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgaXNFdmVudE9iamVjdDogMSxcblxuICBjb25zdHJ1Y3RvcjogRXZlbnRCYXNlT2JqZWN0LFxuXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cbiAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICB9LFxuXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIC8vIGZpeGVkIDEuMlxuICAgIC8vIGNhbGwgc3RvcFByb3BhZ2F0aW9uIGltcGxpY2l0bHlcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIGhhbHQ6IGZ1bmN0aW9uIGhhbHQoaW1tZWRpYXRlKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgdGhpcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEV2ZW50QmFzZU9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiLyoqXG4gKiBAaWdub3JlXG4gKiBldmVudCBvYmplY3QgZm9yIGRvbVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfRXZlbnRCYXNlT2JqZWN0ID0gcmVxdWlyZSgnLi9FdmVudEJhc2VPYmplY3QnKTtcblxudmFyIF9FdmVudEJhc2VPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnRCYXNlT2JqZWN0KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBUUlVFID0gdHJ1ZTtcbnZhciBGQUxTRSA9IGZhbHNlO1xudmFyIGNvbW1vblByb3BzID0gWydhbHRLZXknLCAnYnViYmxlcycsICdjYW5jZWxhYmxlJywgJ2N0cmxLZXknLCAnY3VycmVudFRhcmdldCcsICdldmVudFBoYXNlJywgJ21ldGFLZXknLCAnc2hpZnRLZXknLCAndGFyZ2V0JywgJ3RpbWVTdGFtcCcsICd2aWV3JywgJ3R5cGUnXTtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodykge1xuICByZXR1cm4gdyA9PT0gbnVsbCB8fCB3ID09PSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudE5vcm1hbGl6ZXJzID0gW3tcbiAgcmVnOiAvXmtleS8sXG4gIHByb3BzOiBbJ2NoYXInLCAnY2hhckNvZGUnLCAna2V5JywgJ2tleUNvZGUnLCAnd2hpY2gnXSxcbiAgZml4OiBmdW5jdGlvbiBmaXgoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGV2ZW50LndoaWNoKSkge1xuICAgICAgZXZlbnQud2hpY2ggPSAhaXNOdWxsT3JVbmRlZmluZWQobmF0aXZlRXZlbnQuY2hhckNvZGUpID8gbmF0aXZlRXZlbnQuY2hhckNvZGUgOiBuYXRpdmVFdmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIC8vIGFkZCBtZXRhS2V5IHRvIG5vbi1NYWMgYnJvd3NlcnMgKHVzZSBjdHJsIGZvciBQQyAncyBhbmQgTWV0YSBmb3IgTWFjcylcbiAgICBpZiAoZXZlbnQubWV0YUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBldmVudC5tZXRhS2V5ID0gZXZlbnQuY3RybEtleTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgcmVnOiAvXnRvdWNoLyxcbiAgcHJvcHM6IFsndG91Y2hlcycsICdjaGFuZ2VkVG91Y2hlcycsICd0YXJnZXRUb3VjaGVzJ11cbn0sIHtcbiAgcmVnOiAvXmhhc2hjaGFuZ2UkLyxcbiAgcHJvcHM6IFsnbmV3VVJMJywgJ29sZFVSTCddXG59LCB7XG4gIHJlZzogL15nZXN0dXJlY2hhbmdlJC9pLFxuICBwcm9wczogWydyb3RhdGlvbicsICdzY2FsZSddXG59LCB7XG4gIHJlZzogL14obW91c2V3aGVlbHxET01Nb3VzZVNjcm9sbCkkLyxcbiAgcHJvcHM6IFtdLFxuICBmaXg6IGZ1bmN0aW9uIGZpeChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZGVsdGFYID0gdW5kZWZpbmVkO1xuICAgIHZhciBkZWx0YVkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRlbHRhID0gdW5kZWZpbmVkO1xuICAgIHZhciB3aGVlbERlbHRhID0gbmF0aXZlRXZlbnQud2hlZWxEZWx0YTtcbiAgICB2YXIgYXhpcyA9IG5hdGl2ZUV2ZW50LmF4aXM7XG4gICAgdmFyIHdoZWVsRGVsdGFZID0gbmF0aXZlRXZlbnQud2hlZWxEZWx0YVk7XG4gICAgdmFyIHdoZWVsRGVsdGFYID0gbmF0aXZlRXZlbnQud2hlZWxEZWx0YVg7XG4gICAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcblxuICAgIC8vIGllL3dlYmtpdFxuICAgIGlmICh3aGVlbERlbHRhKSB7XG4gICAgICBkZWx0YSA9IHdoZWVsRGVsdGEgLyAxMjA7XG4gICAgfVxuXG4gICAgLy8gZ2Vja29cbiAgICBpZiAoZGV0YWlsKSB7XG4gICAgICAvLyBwcmVzcyBjb250cm9sIGUuZGV0YWlsID09IDEgZWxzZSBlLmRldGFpbCA9PSAzXG4gICAgICBkZWx0YSA9IDAgLSAoZGV0YWlsICUgMyA9PT0gMCA/IGRldGFpbCAvIDMgOiBkZXRhaWwpO1xuICAgIH1cblxuICAgIC8vIEdlY2tvXG4gICAgaWYgKGF4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGF4aXMgPT09IGV2ZW50LkhPUklaT05UQUxfQVhJUykge1xuICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBkZWx0YVggPSAwIC0gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGF4aXMgPT09IGV2ZW50LlZFUlRJQ0FMX0FYSVMpIHtcbiAgICAgICAgZGVsdGFYID0gMDtcbiAgICAgICAgZGVsdGFZID0gZGVsdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2Via2l0XG4gICAgaWYgKHdoZWVsRGVsdGFZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbHRhWSA9IHdoZWVsRGVsdGFZIC8gMTIwO1xuICAgIH1cbiAgICBpZiAod2hlZWxEZWx0YVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsdGFYID0gLTEgKiB3aGVlbERlbHRhWCAvIDEyMDtcbiAgICB9XG5cbiAgICAvLyDpu5jorqQgZGVsdGFZIChpZSlcbiAgICBpZiAoIWRlbHRhWCAmJiAhZGVsdGFZKSB7XG4gICAgICBkZWx0YVkgPSBkZWx0YTtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGFYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogZGVsdGFYIG9mIG1vdXNld2hlZWwgZXZlbnRcbiAgICAgICAqIEBwcm9wZXJ0eSBkZWx0YVhcbiAgICAgICAqIEBtZW1iZXIgRXZlbnQuRG9tRXZlbnQuT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIGV2ZW50LmRlbHRhWCA9IGRlbHRhWDtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGFZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogZGVsdGFZIG9mIG1vdXNld2hlZWwgZXZlbnRcbiAgICAgICAqIEBwcm9wZXJ0eSBkZWx0YVlcbiAgICAgICAqIEBtZW1iZXIgRXZlbnQuRG9tRXZlbnQuT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIGV2ZW50LmRlbHRhWSA9IGRlbHRhWTtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBkZWx0YSBvZiBtb3VzZXdoZWVsIGV2ZW50XG4gICAgICAgKiBAcHJvcGVydHkgZGVsdGFcbiAgICAgICAqIEBtZW1iZXIgRXZlbnQuRG9tRXZlbnQuT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIGV2ZW50LmRlbHRhID0gZGVsdGE7XG4gICAgfVxuICB9XG59LCB7XG4gIHJlZzogL15tb3VzZXxjb250ZXh0bWVudXxjbGlja3xtc3BvaW50ZXJ8KF5ET01Nb3VzZVNjcm9sbCQpL2ksXG4gIHByb3BzOiBbJ2J1dHRvbnMnLCAnY2xpZW50WCcsICdjbGllbnRZJywgJ2J1dHRvbicsICdvZmZzZXRYJywgJ3JlbGF0ZWRUYXJnZXQnLCAnd2hpY2gnLCAnZnJvbUVsZW1lbnQnLCAndG9FbGVtZW50JywgJ29mZnNldFknLCAncGFnZVgnLCAncGFnZVknLCAnc2NyZWVuWCcsICdzY3JlZW5ZJ10sXG4gIGZpeDogZnVuY3Rpb24gZml4KGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIHZhciBldmVudERvYyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZG9jID0gdW5kZWZpbmVkO1xuICAgIHZhciBib2R5ID0gdW5kZWZpbmVkO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGJ1dHRvbiA9IG5hdGl2ZUV2ZW50LmJ1dHRvbjtcblxuICAgIC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcbiAgICBpZiAodGFyZ2V0ICYmIGlzTnVsbE9yVW5kZWZpbmVkKGV2ZW50LnBhZ2VYKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQobmF0aXZlRXZlbnQuY2xpZW50WCkpIHtcbiAgICAgIGV2ZW50RG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICBkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBib2R5ID0gZXZlbnREb2MuYm9keTtcbiAgICAgIGV2ZW50LnBhZ2VYID0gbmF0aXZlRXZlbnQuY2xpZW50WCArIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgZXZlbnQucGFnZVkgPSBuYXRpdmVFdmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICB9XG5cbiAgICAvLyB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcbiAgICAvLyBkbyBub3QgdXNlIGJ1dHRvblxuICAgIGlmICghZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChidXR0b24gJiAxKSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uICYgMikge1xuICAgICAgICBldmVudC53aGljaCA9IDM7XG4gICAgICB9IGVsc2UgaWYgKGJ1dHRvbiAmIDQpIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZWxhdGVkVGFyZ2V0LCBpZiBuZWNlc3NhcnlcbiAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZXZlbnQuZnJvbUVsZW1lbnQpIHtcbiAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBldmVudC5mcm9tRWxlbWVudCA9PT0gdGFyZ2V0ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59XTtcblxuZnVuY3Rpb24gcmV0VHJ1ZSgpIHtcbiAgcmV0dXJuIFRSVUU7XG59XG5cbmZ1bmN0aW9uIHJldEZhbHNlKCkge1xuICByZXR1cm4gRkFMU0U7XG59XG5cbmZ1bmN0aW9uIERvbUV2ZW50T2JqZWN0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcblxuICB2YXIgaXNOYXRpdmUgPSB0eXBlb2YgbmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBuYXRpdmVFdmVudC5jYW5jZWxCdWJibGUgPT09ICdib29sZWFuJztcblxuICBfRXZlbnRCYXNlT2JqZWN0MlsnZGVmYXVsdCddLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIC8vIGluIGNhc2UgZG9tIGV2ZW50IGhhcyBiZWVuIG1hcmsgYXMgZGVmYXVsdCBwcmV2ZW50ZWQgYnkgbG93ZXIgZG9tIG5vZGVcbiAgdmFyIGlzRGVmYXVsdFByZXZlbnRlZCA9IHJldEZhbHNlO1xuICBpZiAoJ2RlZmF1bHRQcmV2ZW50ZWQnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgaXNEZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA/IHJldFRydWUgOiByZXRGYWxzZTtcbiAgfSBlbHNlIGlmICgnZ2V0UHJldmVudERlZmF1bHQnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjkxMTUxXG4gICAgaXNEZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZ2V0UHJldmVudERlZmF1bHQoKSA/IHJldFRydWUgOiByZXRGYWxzZTtcbiAgfSBlbHNlIGlmICgncmV0dXJuVmFsdWUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgaXNEZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IEZBTFNFID8gcmV0VHJ1ZSA6IHJldEZhbHNlO1xuICB9XG5cbiAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cbiAgdmFyIGZpeEZucyA9IFtdO1xuICB2YXIgZml4Rm4gPSB1bmRlZmluZWQ7XG4gIHZhciBsID0gdW5kZWZpbmVkO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIHByb3BzID0gY29tbW9uUHJvcHMuY29uY2F0KCk7XG5cbiAgZXZlbnROb3JtYWxpemVycy5mb3JFYWNoKGZ1bmN0aW9uIChub3JtYWxpemVyKSB7XG4gICAgaWYgKHR5cGUubWF0Y2gobm9ybWFsaXplci5yZWcpKSB7XG4gICAgICBwcm9wcyA9IHByb3BzLmNvbmNhdChub3JtYWxpemVyLnByb3BzKTtcbiAgICAgIGlmIChub3JtYWxpemVyLmZpeCkge1xuICAgICAgICBmaXhGbnMucHVzaChub3JtYWxpemVyLmZpeCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBsID0gcHJvcHMubGVuZ3RoO1xuXG4gIC8vIGNsb25lIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdFxuICB3aGlsZSAobCkge1xuICAgIHByb3AgPSBwcm9wc1stLWxdO1xuICAgIHRoaXNbcHJvcF0gPSBuYXRpdmVFdmVudFtwcm9wXTtcbiAgfVxuXG4gIC8vIGZpeCB0YXJnZXQgcHJvcGVydHksIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXRoaXMudGFyZ2V0ICYmIGlzTmF0aXZlKSB7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50OyAvLyBzcmNFbGVtZW50IG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGVpdGhlclxuICB9XG5cbiAgLy8gY2hlY2sgaWYgdGFyZ2V0IGlzIGEgdGV4dCBub2RlIChzYWZhcmkpXG4gIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLnRhcmdldC5ub2RlVHlwZSA9PT0gMykge1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGwgPSBmaXhGbnMubGVuZ3RoO1xuXG4gIHdoaWxlIChsKSB7XG4gICAgZml4Rm4gPSBmaXhGbnNbLS1sXTtcbiAgICBmaXhGbih0aGlzLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICB0aGlzLnRpbWVTdGFtcCA9IG5hdGl2ZUV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xufVxuXG52YXIgRXZlbnRCYXNlT2JqZWN0UHJvdG8gPSBfRXZlbnRCYXNlT2JqZWN0MlsnZGVmYXVsdCddLnByb3RvdHlwZTtcblxuKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKERvbUV2ZW50T2JqZWN0LnByb3RvdHlwZSwgRXZlbnRCYXNlT2JqZWN0UHJvdG8sIHtcbiAgY29uc3RydWN0b3I6IERvbUV2ZW50T2JqZWN0LFxuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB2YXIgZSA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBGQUxTRSAoSUUpXG4gICAgICBlLnJldHVyblZhbHVlID0gRkFMU0U7XG4gICAgfVxuXG4gICAgRXZlbnRCYXNlT2JqZWN0UHJvdG8ucHJldmVudERlZmF1bHQuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gVFJVRSAoSUUpXG4gICAgICBlLmNhbmNlbEJ1YmJsZSA9IFRSVUU7XG4gICAgfVxuXG4gICAgRXZlbnRCYXNlT2JqZWN0UHJvdG8uc3RvcFByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBEb21FdmVudE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBhZGRFdmVudExpc3RlbmVyO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfRXZlbnRPYmplY3QgPSByZXF1aXJlKCcuL0V2ZW50T2JqZWN0Jyk7XG5cbnZhciBfRXZlbnRPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnRPYmplY3QpO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiB3cmFwQ2FsbGJhY2soZSkge1xuICAgIHZhciBuZSA9IG5ldyBfRXZlbnRPYmplY3QyWydkZWZhdWx0J10oZSk7XG4gICAgY2FsbGJhY2suY2FsbCh0YXJnZXQsIG5lKTtcbiAgfVxuXG4gIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcENhbGxiYWNrLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHdyYXBDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIHdyYXBDYWxsYmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgd3JhcENhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX01hcENvbnRyb2wyID0gcmVxdWlyZSgnLi9NYXBDb250cm9sJyk7XG5cbnZhciBfTWFwQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb250cm9sMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEF0dHJpYnV0aW9uQ29udHJvbCA9IGZ1bmN0aW9uIChfTWFwQ29udHJvbCkge1xuICBfaW5oZXJpdHMoQXR0cmlidXRpb25Db250cm9sLCBfTWFwQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRpb25Db250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdHRyaWJ1dGlvbkNvbnRyb2wpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihBdHRyaWJ1dGlvbkNvbnRyb2wpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0aW9uQ29udHJvbCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQuY29udHJvbC5hdHRyaWJ1dGlvbih0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXR0cmlidXRpb25Db250cm9sO1xufShfTWFwQ29udHJvbDMuZGVmYXVsdCk7XG5cbkF0dHJpYnV0aW9uQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIHByZWZpeDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBBdHRyaWJ1dGlvbkNvbnRyb2w7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9NYXBMYXllcjIgPSByZXF1aXJlKCcuL01hcExheWVyJyk7XG5cbnZhciBfTWFwTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWFwTGF5ZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQmFzZVRpbGVMYXllciA9IGZ1bmN0aW9uIChfTWFwTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEJhc2VUaWxlTGF5ZXIsIF9NYXBMYXllcik7XG5cbiAgZnVuY3Rpb24gQmFzZVRpbGVMYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVRpbGVMYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VUaWxlTGF5ZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VUaWxlTGF5ZXIsIFt7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgb3BhY2l0eSA9IF9wcm9wcy5vcGFjaXR5O1xuICAgICAgdmFyIHpJbmRleCA9IF9wcm9wcy56SW5kZXg7XG5cbiAgICAgIGlmIChvcGFjaXR5ICE9PSBwcmV2UHJvcHMub3BhY2l0eSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgICB9XG4gICAgICBpZiAoekluZGV4ICE9PSBwcmV2UHJvcHMuekluZGV4KSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VUaWxlTGF5ZXI7XG59KF9NYXBMYXllcjMuZGVmYXVsdCk7XG5cbkJhc2VUaWxlTGF5ZXIucHJvcFR5cGVzID0ge1xuICBvcGFjaXR5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgekluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VUaWxlTGF5ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vQmFzZVRpbGVMYXllcicpO1xuXG52YXIgX0Jhc2VUaWxlTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRpbGVMYXllcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENhbnZhc1RpbGVMYXllciA9IGZ1bmN0aW9uIChfQmFzZVRpbGVMYXllcikge1xuICBfaW5oZXJpdHMoQ2FudmFzVGlsZUxheWVyLCBfQmFzZVRpbGVMYXllcik7XG5cbiAgZnVuY3Rpb24gQ2FudmFzVGlsZUxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNUaWxlTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW52YXNUaWxlTGF5ZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhc1RpbGVMYXllciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW52YXNUaWxlTGF5ZXIucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBfbWFwID0gX3Byb3BzLm1hcDtcbiAgICAgIHZhciBfbGMgPSBfcHJvcHMubGF5ZXJDb250YWluZXI7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ2xheWVyQ29udGFpbmVyJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQudGlsZUxheWVyLmNhbnZhcyhwcm9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZhc1RpbGVMYXllcjtcbn0oX0Jhc2VUaWxlTGF5ZXIzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNUaWxlTGF5ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfbGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF9sYXRsbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF0bG5nKTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENpcmNsZSA9IGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoQ2lyY2xlLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGUucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjZW50ZXIgPSBfcHJvcHMuY2VudGVyO1xuICAgICAgdmFyIF9tYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIF9sYyA9IF9wcm9wcy5sYXllckNvbnRhaW5lcjtcbiAgICAgIHZhciByYWRpdXMgPSBfcHJvcHMucmFkaXVzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2NlbnRlcicsICdtYXAnLCAnbGF5ZXJDb250YWluZXInLCAncmFkaXVzJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LmNpcmNsZSkoY2VudGVyLCByYWRpdXMsIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5jZW50ZXIgIT09IHByZXZQcm9wcy5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmcodGhpcy5wcm9wcy5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMucmFkaXVzICE9PSBwcmV2UHJvcHMucmFkaXVzKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0UmFkaXVzKHRoaXMucHJvcHMucmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY2xlO1xufShfUGF0aDMuZGVmYXVsdCk7XG5cbkNpcmNsZS5wcm9wVHlwZXMgPSB7XG4gIGNlbnRlcjogX2xhdGxuZzIuZGVmYXVsdC5pc1JlcXVpcmVkLFxuICByYWRpdXM6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfbGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF9sYXRsbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF0bG5nKTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENpcmNsZU1hcmtlciA9IGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoQ2lyY2xlTWFya2VyLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gQ2lyY2xlTWFya2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGVNYXJrZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGVNYXJrZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZU1hcmtlciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGVNYXJrZXIucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjZW50ZXIgPSBfcHJvcHMuY2VudGVyO1xuICAgICAgdmFyIF9tYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIF9sYyA9IF9wcm9wcy5sYXllckNvbnRhaW5lcjtcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydjZW50ZXInLCAnbWFwJywgJ2xheWVyQ29udGFpbmVyJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LmNpcmNsZU1hcmtlcikoY2VudGVyLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMuY2VudGVyICE9PSBwcmV2UHJvcHMuY2VudGVyKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0TGF0TG5nKHRoaXMucHJvcHMuY2VudGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb3BzLnJhZGl1cyAhPT0gcHJldlByb3BzLnJhZGl1cykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldFJhZGl1cyh0aGlzLnByb3BzLnJhZGl1cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmNsZU1hcmtlcjtcbn0oX1BhdGgzLmRlZmF1bHQpO1xuXG5DaXJjbGVNYXJrZXIucHJvcFR5cGVzID0ge1xuICBjZW50ZXI6IF9sYXRsbmcyLmRlZmF1bHQuaXNSZXF1aXJlZCxcbiAgcmFkaXVzOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IENpcmNsZU1hcmtlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoRmVhdHVyZUdyb3VwLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gRmVhdHVyZUdyb3VwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGZWF0dXJlR3JvdXApO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihGZWF0dXJlR3JvdXApLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZlYXR1cmVHcm91cCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LmZlYXR1cmVHcm91cCkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmVhdHVyZUdyb3VwLnByb3RvdHlwZSksICdjb21wb25lbnREaWRNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNldFN0eWxlKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJDaGlsZHJlbldpdGhQcm9wcyh7XG4gICAgICAgIGxheWVyQ29udGFpbmVyOiB0aGlzLmxlYWZsZXRFbGVtZW50LFxuICAgICAgICBwb3B1cENvbnRhaW5lcjogdGhpcy5sZWFmbGV0RWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZlYXR1cmVHcm91cDtcbn0oX1BhdGgzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGZWF0dXJlR3JvdXA7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lzRnVuY3Rpb24yID0gcmVxdWlyZSgnbG9kYXNoL2lzRnVuY3Rpb24nKTtcblxudmFyIF9pc0Z1bmN0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRnVuY3Rpb24yKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgR2VvSnNvbiA9IGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoR2VvSnNvbiwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIEdlb0pzb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdlb0pzb24pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihHZW9Kc29uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHZW9Kc29uLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlb0pzb24ucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBkYXRhID0gX3Byb3BzLmRhdGE7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2RhdGEnLCAnbWFwJywgJ2xheWVyQ29udGFpbmVyJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0Lmdlb0pzb24pKGRhdGEsIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uMy5kZWZhdWx0KSh0aGlzLnByb3BzLnN0eWxlKSkge1xuICAgICAgICB0aGlzLnNldFN0eWxlKHRoaXMucHJvcHMuc3R5bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHZW9Kc29uO1xufShfUGF0aDMuZGVmYXVsdCk7XG5cbkdlb0pzb24ucHJvcFR5cGVzID0ge1xuICBkYXRhOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gR2VvSnNvbjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9ib3VuZHMgPSByZXF1aXJlKCcuL3R5cGVzL2JvdW5kcycpO1xuXG52YXIgX2JvdW5kczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib3VuZHMpO1xuXG52YXIgX01hcExheWVyMiA9IHJlcXVpcmUoJy4vTWFwTGF5ZXInKTtcblxudmFyIF9NYXBMYXllcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBMYXllcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uIChfTWFwTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEltYWdlT3ZlcmxheSwgX01hcExheWVyKTtcblxuICBmdW5jdGlvbiBJbWFnZU92ZXJsYXkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlT3ZlcmxheSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlT3ZlcmxheSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2VPdmVybGF5LCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlT3ZlcmxheS5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGJvdW5kcyA9IF9wcm9wcy5ib3VuZHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuICAgICAgdmFyIHVybCA9IF9wcm9wcy51cmw7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYm91bmRzJywgJ21hcCcsICdsYXllckNvbnRhaW5lcicsICd1cmwnXSk7XG5cbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQgPSAoMCwgX2xlYWZsZXQuaW1hZ2VPdmVybGF5KSh1cmwsIGJvdW5kcywgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnVybCAhPT0gcHJldlByb3BzLnVybCkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldFVybCh0aGlzLnByb3BzLnVybCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy5vcGFjaXR5ICE9PSBwcmV2UHJvcHMub3BhY2l0eSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldE9wYWNpdHkodGhpcy5wcm9wcy5vcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2VPdmVybGF5O1xufShfTWFwTGF5ZXIzLmRlZmF1bHQpO1xuXG5JbWFnZU92ZXJsYXkucHJvcFR5cGVzID0ge1xuICBhdHRyaWJ1dGlvbjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIGJvdW5kczogX2JvdW5kczIuZGVmYXVsdC5pc1JlcXVpcmVkLFxuICBvcGFjaXR5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgdXJsOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gSW1hZ2VPdmVybGF5OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfTWFwTGF5ZXIyID0gcmVxdWlyZSgnLi9NYXBMYXllcicpO1xuXG52YXIgX01hcExheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcExheWVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIExheWVyR3JvdXAgPSBmdW5jdGlvbiAoX01hcExheWVyKSB7XG4gIF9pbmhlcml0cyhMYXllckdyb3VwLCBfTWFwTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIExheWVyR3JvdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyR3JvdXApO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihMYXllckdyb3VwKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMYXllckdyb3VwLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKExheWVyR3JvdXAucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LmxheWVyR3JvdXApKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ2hpbGRyZW5XaXRoUHJvcHMoe1xuICAgICAgICBsYXllckNvbnRhaW5lcjogdGhpcy5sZWFmbGV0RWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheWVyR3JvdXA7XG59KF9NYXBMYXllcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExheWVyR3JvdXA7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Fzc2lnbjIgPSByZXF1aXJlKCdsb2Rhc2gvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbjIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfY2hpbGRyZW4yID0gcmVxdWlyZSgnLi90eXBlcy9jaGlsZHJlbicpO1xuXG52YXIgX2NoaWxkcmVuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NoaWxkcmVuMik7XG5cbnZhciBfbGF5ZXJDb250YWluZXIgPSByZXF1aXJlKCcuL3R5cGVzL2xheWVyQ29udGFpbmVyJyk7XG5cbnZhciBfbGF5ZXJDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF5ZXJDb250YWluZXIpO1xuXG52YXIgX01hcENvbnRyb2wyID0gcmVxdWlyZSgnLi9NYXBDb250cm9sJyk7XG5cbnZhciBfTWFwQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb250cm9sMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29udHJvbGxlZExheWVyUHJvcFR5cGVzID0ge1xuICBhZGRCYXNlTGF5ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgYWRkT3ZlcmxheTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBjaGVja2VkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgbWFwOiBfcmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoX2xlYWZsZXQuTWFwKSxcbiAgbmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgcmVtb3ZlTGF5ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgcmVtb3ZlTGF5ZXJDb250cm9sOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5cbi8vIEFidHJhY3QgY2xhc3MgZm9yIGxheWVyIGNvbnRhaW5lciwgZXh0ZW5kZWQgYnkgQmFzZUxheWVyIGFuZCBPdmVybGF5XG5cbnZhciBDb250cm9sbGVkTGF5ZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ29udHJvbGxlZExheWVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sbGVkTGF5ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xsZWRMYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbnRyb2xsZWRMYXllcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29udHJvbGxlZExheWVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKF9yZWYpIHtcbiAgICAgIHZhciBjaGVja2VkID0gX3JlZi5jaGVja2VkO1xuICAgICAgdmFyIG1hcCA9IF9yZWYubWFwO1xuXG4gICAgICAvLyBIYW5kbGUgZHluYW1pY2FsbHkgKHVuKWNoZWNraW5nIHRoZSBsYXllciA9PiBhZGRpbmcvcmVtb3ZpbmcgZnJvbSB0aGUgbWFwXG4gICAgICBpZiAoY2hlY2tlZCAmJiAhdGhpcy5wcm9wcy5jaGVja2VkKSB7XG4gICAgICAgIG1hcC5hZGRMYXllcih0aGlzLmxheWVyKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5jaGVja2VkICYmICFjaGVja2VkKSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcih0aGlzLmxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5wcm9wcy5yZW1vdmVMYXllckNvbnRyb2wodGhpcy5sYXllcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlTGF5ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMYXllcihsYXllcikge1xuICAgICAgdGhpcy5wcm9wcy5yZW1vdmVMYXllcihsYXllcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShfcmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSwge1xuICAgICAgICAvLyBQcm94eSBsYXllciBjb250YWluZXIgbWV0aG9kIGNhbGxzIHRvIGxvY2FsIG1ldGhvZHNcbiAgICAgICAgbGF5ZXJDb250YWluZXI6IHtcbiAgICAgICAgICBhZGRMYXllcjogdGhpcy5hZGRMYXllci5iaW5kKHRoaXMpLFxuICAgICAgICAgIHJlbW92ZUxheWVyOiB0aGlzLnJlbW92ZUxheWVyLmJpbmQodGhpcylcbiAgICAgICAgfSxcbiAgICAgICAgbWFwOiB0aGlzLnByb3BzLm1hcFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbnRyb2xsZWRMYXllcjtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbkNvbnRyb2xsZWRMYXllci5wcm9wVHlwZXMgPSBjb250cm9sbGVkTGF5ZXJQcm9wVHlwZXM7XG5cbnZhciBCYXNlTGF5ZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZWRMYXllcikge1xuICBfaW5oZXJpdHMoQmFzZUxheWVyLCBfQ29udHJvbGxlZExheWVyKTtcblxuICBmdW5jdGlvbiBCYXNlTGF5ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VMYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VMYXllcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUxheWVyLCBbe1xuICAgIGtleTogJ2FkZExheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjsgLy8gS2VlcCBsYXllciByZWZlcmVuY2UgdG8gaGFuZGxlIGR5bmFtaWMgY2hhbmdlcyBvZiBwcm9wc1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgYWRkQmFzZUxheWVyID0gX3Byb3BzLmFkZEJhc2VMYXllcjtcbiAgICAgIHZhciBjaGVja2VkID0gX3Byb3BzLmNoZWNrZWQ7XG4gICAgICB2YXIgbmFtZSA9IF9wcm9wcy5uYW1lO1xuXG4gICAgICBhZGRCYXNlTGF5ZXIobGF5ZXIsIG5hbWUsIGNoZWNrZWQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlTGF5ZXI7XG59KENvbnRyb2xsZWRMYXllcik7XG5cbkJhc2VMYXllci5wcm9wVHlwZXMgPSBjb250cm9sbGVkTGF5ZXJQcm9wVHlwZXM7XG5cbnZhciBPdmVybGF5ID0gZnVuY3Rpb24gKF9Db250cm9sbGVkTGF5ZXIyKSB7XG4gIF9pbmhlcml0cyhPdmVybGF5LCBfQ29udHJvbGxlZExheWVyMik7XG5cbiAgZnVuY3Rpb24gT3ZlcmxheSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3ZlcmxheSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKE92ZXJsYXkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE92ZXJsYXksIFt7XG4gICAga2V5OiAnYWRkTGF5ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMYXllcihsYXllcikge1xuICAgICAgdGhpcy5sYXllciA9IGxheWVyOyAvLyBLZWVwIGxheWVyIHJlZmVyZW5jZSB0byBoYW5kbGUgZHluYW1pYyBjaGFuZ2VzIG9mIHByb3BzXG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgYWRkT3ZlcmxheSA9IF9wcm9wczIuYWRkT3ZlcmxheTtcbiAgICAgIHZhciBjaGVja2VkID0gX3Byb3BzMi5jaGVja2VkO1xuICAgICAgdmFyIG5hbWUgPSBfcHJvcHMyLm5hbWU7XG5cbiAgICAgIGFkZE92ZXJsYXkobGF5ZXIsIG5hbWUsIGNoZWNrZWQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPdmVybGF5O1xufShDb250cm9sbGVkTGF5ZXIpO1xuXG5PdmVybGF5LnByb3BUeXBlcyA9IGNvbnRyb2xsZWRMYXllclByb3BUeXBlcztcblxudmFyIExheWVyc0NvbnRyb2wgPSBmdW5jdGlvbiAoX01hcENvbnRyb2wpIHtcbiAgX2luaGVyaXRzKExheWVyc0NvbnRyb2wsIF9NYXBDb250cm9sKTtcblxuICBmdW5jdGlvbiBMYXllcnNDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXllcnNDb250cm9sKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGF5ZXJzQ29udHJvbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5ZXJzQ29udHJvbCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgYmFzZUxheWVycyA9IF9wcm9wczMuYmFzZUxheWVycztcbiAgICAgIHZhciBfY2hpbGRyZW4gPSBfcHJvcHMzLmNoaWxkcmVuO1xuICAgICAgdmFyIF9sYyA9IF9wcm9wczMubGF5ZXJDb250YWluZXI7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wczMubWFwO1xuICAgICAgdmFyIG92ZXJsYXlzID0gX3Byb3BzMy5vdmVybGF5cztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMywgWydiYXNlTGF5ZXJzJywgJ2NoaWxkcmVuJywgJ2xheWVyQ29udGFpbmVyJywgJ21hcCcsICdvdmVybGF5cyddKTtcblxuICAgICAgLy8gUHJlLXYwLjExIGJlaGF2aW9yLCB3YXJuIGluIHYwLjExLCByZW1vdmUgaW4gdjAuMTJcblxuXG4gICAgICB0aGlzLmxlZ2FjeSA9ICEhKGJhc2VMYXllcnMgfHwgb3ZlcmxheXMpO1xuXG4gICAgICBpZiAodGhpcy5sZWdhY3kpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdUaGUgXCJiYXNlTGF5ZXJzXCIgYW5kIFwib3ZlcmxheXNcIiBwcm9wZXJ0aWVzIGZvciBcIkxheWVyc0NvbnRyb2xcIiBhcmUgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24uIFlvdSBzaG91bGQgdXNlIHRoZSBcIkxheWVyc0NvbnRyb2wuQmFzZUxheWVyXCIgYW5kIFwiTGF5ZXJzQ29udHJvbC5PdmVybGF5XCIgaW5zdGVhZCwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9IF9sZWFmbGV0LmNvbnRyb2wubGF5ZXJzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb250cm9sUHJvcHMgPSB7XG4gICAgICAgICAgYWRkQmFzZUxheWVyOiB0aGlzLmFkZEJhc2VMYXllci5iaW5kKHRoaXMpLFxuICAgICAgICAgIGFkZE92ZXJsYXk6IHRoaXMuYWRkT3ZlcmxheS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHJlbW92ZUxheWVyOiB0aGlzLnJlbW92ZUxheWVyLmJpbmQodGhpcyksXG4gICAgICAgICAgcmVtb3ZlTGF5ZXJDb250cm9sOiB0aGlzLnJlbW92ZUxheWVyQ29udHJvbC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkQmFzZUxheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQmFzZUxheWVyKGxheWVyLCBuYW1lKSB7XG4gICAgICB2YXIgY2hlY2tlZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICB0aGlzLnByb3BzLm1hcC5hZGRMYXllcihsYXllcik7XG4gICAgICB9XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LmFkZEJhc2VMYXllcihsYXllciwgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkT3ZlcmxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE92ZXJsYXkobGF5ZXIsIG5hbWUpIHtcbiAgICAgIHZhciBjaGVja2VkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgIHRoaXMucHJvcHMubWFwLmFkZExheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuYWRkT3ZlcmxheShsYXllciwgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlTGF5ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMYXllcihsYXllcikge1xuICAgICAgdGhpcy5wcm9wcy5tYXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUxheWVyQ29udHJvbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxheWVyQ29udHJvbChsYXllcikge1xuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5yZW1vdmVMYXllcihsYXllcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2xvbmVkQ2hpbGRyZW5XaXRoUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbG9uZWRDaGlsZHJlbldpdGhQcm9wcyhleHRyYSkge1xuICAgICAgdmFyIF9wcm9wczQgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzNC5jaGlsZHJlbjtcbiAgICAgIHZhciBsYXllckNvbnRhaW5lciA9IF9wcm9wczQubGF5ZXJDb250YWluZXI7XG4gICAgICB2YXIgbWFwID0gX3Byb3BzNC5tYXA7XG5cbiAgICAgIHZhciBwcm9wcyA9ICgwLCBfYXNzaWduMy5kZWZhdWx0KSh7IGxheWVyQ29udGFpbmVyOiBsYXllckNvbnRhaW5lciwgbWFwOiBtYXAgfSwgZXh0cmEpO1xuXG4gICAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZCA/ICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwgcHJvcHMpIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmxlZ2FjeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDbG9uZWRDaGlsZHJlbldpdGhQcm9wcyh0aGlzLmNvbnRyb2xQcm9wcyk7XG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9IH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXllcnNDb250cm9sO1xufShfTWFwQ29udHJvbDMuZGVmYXVsdCk7XG5cbkxheWVyc0NvbnRyb2wucHJvcFR5cGVzID0ge1xuICBiYXNlTGF5ZXJzOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgY2hpbGRyZW46IF9jaGlsZHJlbjMuZGVmYXVsdCxcbiAgbGF5ZXJDb250YWluZXI6IF9sYXllckNvbnRhaW5lcjIuZGVmYXVsdCxcbiAgbWFwOiBfcmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoX2xlYWZsZXQuTWFwKSxcbiAgb3ZlcmxheXM6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTGF5ZXJzQ29udHJvbDtcblxuXG5MYXllcnNDb250cm9sLkJhc2VMYXllciA9IEJhc2VMYXllcjtcbkxheWVyc0NvbnRyb2wuT3ZlcmxheSA9IE92ZXJsYXk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3VuaXF1ZUlkMiA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxdWVJZCcpO1xuXG52YXIgX3VuaXF1ZUlkMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VuaXF1ZUlkMik7XG5cbnZhciBfb21pdDIgPSByZXF1aXJlKCdsb2Rhc2gvb21pdCcpO1xuXG52YXIgX29taXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb21pdDIpO1xuXG52YXIgX2lzVW5kZWZpbmVkMiA9IHJlcXVpcmUoJ2xvZGFzaC9pc1VuZGVmaW5lZCcpO1xuXG52YXIgX2lzVW5kZWZpbmVkMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzVW5kZWZpbmVkMik7XG5cbnZhciBfaXNBcnJheTIgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheScpO1xuXG52YXIgX2lzQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheTIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX2xlYWZsZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGVhZmxldCk7XG5cbnZhciBfYm91bmRzID0gcmVxdWlyZSgnLi90eXBlcy9ib3VuZHMnKTtcblxudmFyIF9ib3VuZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm91bmRzKTtcblxudmFyIF9jaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHlwZXMvY2hpbGRyZW4nKTtcblxudmFyIF9jaGlsZHJlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jaGlsZHJlbik7XG5cbnZhciBfbGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF9sYXRsbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF0bG5nKTtcblxudmFyIF9NYXBDb21wb25lbnQyID0gcmVxdWlyZSgnLi9NYXBDb21wb25lbnQnKTtcblxudmFyIF9NYXBDb21wb25lbnQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWFwQ29tcG9uZW50Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tZGlkLW1vdW50LXNldC1zdGF0ZSAqL1xuXG52YXIgbm9ybWFsaXplQ2VudGVyID0gZnVuY3Rpb24gbm9ybWFsaXplQ2VudGVyKHBvcykge1xuICByZXR1cm4gKDAsIF9pc0FycmF5My5kZWZhdWx0KShwb3MpID8gcG9zIDogW3Bvcy5sYXQsIHBvcy5sbmcgfHwgcG9zLmxvbl07XG59O1xuXG52YXIgTWFwID0gZnVuY3Rpb24gKF9NYXBDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1hcCwgX01hcENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWFwKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlkOiBwcm9wcy5pZCB8fCAoMCwgX3VuaXF1ZUlkMy5kZWZhdWx0KSgnbWFwJylcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXAsIFt7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBwcm9wcyA9ICgwLCBfb21pdDMuZGVmYXVsdCkodGhpcy5wcm9wcywgWydjaGlsZHJlbicsICdjbGFzc05hbWUnLCAnaWQnLCAnc3R5bGUnXSk7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQyLmRlZmF1bHQubWFwKHRoaXMuc3RhdGUuaWQsIHByb3BzKTtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hcC5wcm90b3R5cGUpLCAnY29tcG9uZW50RGlkTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1hcDogdGhpcy5sZWFmbGV0RWxlbWVudCB9KTtcbiAgICAgIGlmICghKDAsIF9pc1VuZGVmaW5lZDMuZGVmYXVsdCkocHJvcHMuYm91bmRzKSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LmZpdEJvdW5kcyhwcm9wcy5ib3VuZHMsIHByb3BzLmJvdW5kc09wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGJvdW5kcyA9IF9wcm9wcy5ib3VuZHM7XG4gICAgICB2YXIgYm91bmRzT3B0aW9ucyA9IF9wcm9wcy5ib3VuZHNPcHRpb25zO1xuICAgICAgdmFyIGNlbnRlciA9IF9wcm9wcy5jZW50ZXI7XG4gICAgICB2YXIgbWF4Qm91bmRzID0gX3Byb3BzLm1heEJvdW5kcztcbiAgICAgIHZhciB6b29tID0gX3Byb3BzLnpvb207XG4gICAgICB2YXIgYW5pbWF0ZSA9IF9wcm9wcy5hbmltYXRlO1xuXG4gICAgICBpZiAoY2VudGVyICYmIHRoaXMuc2hvdWxkVXBkYXRlQ2VudGVyKGNlbnRlciwgcHJldlByb3BzLmNlbnRlcikpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRWaWV3KGNlbnRlciwgem9vbSwgeyBhbmltYXRlOiBhbmltYXRlIH0pO1xuICAgICAgfSBlbHNlIGlmICh6b29tICYmIHpvb20gIT09IHByZXZQcm9wcy56b29tKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0Wm9vbSh6b29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhCb3VuZHMgJiYgdGhpcy5zaG91bGRVcGRhdGVCb3VuZHMobWF4Qm91bmRzLCBwcmV2UHJvcHMubWF4Qm91bmRzKSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldE1heEJvdW5kcyhtYXhCb3VuZHMpO1xuICAgICAgfVxuICAgICAgaWYgKGJvdW5kcyAmJiAodGhpcy5zaG91bGRVcGRhdGVCb3VuZHMoYm91bmRzLCBwcmV2UHJvcHMuYm91bmRzKSB8fCBib3VuZHNPcHRpb25zICE9PSBwcmV2UHJvcHMuYm91bmRzT3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5maXRCb3VuZHMoYm91bmRzLCBib3VuZHNPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsVW5tb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnJlbW92ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZFVwZGF0ZUNlbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNlbnRlcihuZXh0LCBwcmV2KSB7XG4gICAgICBpZiAoIXByZXYpIHJldHVybiB0cnVlO1xuICAgICAgbmV4dCA9IG5vcm1hbGl6ZUNlbnRlcihuZXh0KTtcbiAgICAgIHByZXYgPSBub3JtYWxpemVDZW50ZXIocHJldik7XG4gICAgICByZXR1cm4gbmV4dFswXSAhPT0gcHJldlswXSB8fCBuZXh0WzFdICE9PSBwcmV2WzFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZFVwZGF0ZUJvdW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZUJvdW5kcyhuZXh0LCBwcmV2KSB7XG4gICAgICBpZiAoIXByZXYpIHJldHVybiB0cnVlO1xuICAgICAgbmV4dCA9IF9sZWFmbGV0Mi5kZWZhdWx0LmxhdExuZ0JvdW5kcyhuZXh0KTtcbiAgICAgIHByZXYgPSBfbGVhZmxldDIuZGVmYXVsdC5sYXRMbmdCb3VuZHMocHJldik7XG4gICAgICByZXR1cm4gIW5leHQuZXF1YWxzKHByZXYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLmxlYWZsZXRFbGVtZW50O1xuICAgICAgdmFyIGNoaWxkcmVuID0gbWFwID8gX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkID8gX3JlYWN0Mi5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwgeyBtYXA6IG1hcCwgbGF5ZXJDb250YWluZXI6IG1hcCB9KSA6IG51bGw7XG4gICAgICB9KSA6IG51bGw7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgIGlkOiB0aGlzLnN0YXRlLmlkLFxuICAgICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlIH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXA7XG59KF9NYXBDb21wb25lbnQzLmRlZmF1bHQpO1xuXG5NYXAucHJvcFR5cGVzID0ge1xuICBhbmltYXRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGJvdW5kczogX2JvdW5kczIuZGVmYXVsdCxcbiAgYm91bmRzT3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIGNlbnRlcjogX2xhdGxuZzIuZGVmYXVsdCxcbiAgY2hpbGRyZW46IF9jaGlsZHJlbjIuZGVmYXVsdCxcbiAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgaWQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBtYXhCb3VuZHM6IF9ib3VuZHMyLmRlZmF1bHQsXG4gIG1heFpvb206IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICBtaW5ab29tOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICB6b29tOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxufTtcbk1hcC5kZWZhdWx0UHJvcHMgPSB7XG4gIGFuaW1hdGU6IGZhbHNlXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTWFwOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWR1Y2UyID0gcmVxdWlyZSgnbG9kYXNoL3JlZHVjZScpO1xuXG52YXIgX3JlZHVjZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWR1Y2UyKTtcblxudmFyIF9rZXlzMiA9IHJlcXVpcmUoJ2xvZGFzaC9rZXlzJyk7XG5cbnZhciBfa2V5czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzMik7XG5cbnZhciBfZm9yRWFjaDIgPSByZXF1aXJlKCdsb2Rhc2gvZm9yRWFjaCcpO1xuXG52YXIgX2ZvckVhY2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9yRWFjaDIpO1xuXG52YXIgX2Nsb25lMiA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZScpO1xuXG52YXIgX2Nsb25lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRVZFTlRTX1JFX0xFR0FDWSA9IC9eb25MZWFmbGV0KC4rKSQvaTtcbnZhciBFVkVOVFNfUkUgPSAvXm9uKC4rKSQvaTtcblxudmFyIE1hcENvbXBvbmVudCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNYXBDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1hcENvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwQ29tcG9uZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBDb21wb25lbnQsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgdGhpcy5fbGVhZmxldEV2ZW50cyA9IHRoaXMuZXh0cmFjdExlYWZsZXRFdmVudHModGhpcy5wcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMuYmluZExlYWZsZXRFdmVudHModGhpcy5fbGVhZmxldEV2ZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuZXh0cmFjdExlYWZsZXRFdmVudHMobmV4dFByb3BzKTtcbiAgICAgIHRoaXMuX2xlYWZsZXRFdmVudHMgPSB0aGlzLmJpbmRMZWFmbGV0RXZlbnRzKG5leHQsIHRoaXMuX2xlYWZsZXRFdmVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmxlYWZsZXRFbGVtZW50O1xuICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gICAgICAoMCwgX2ZvckVhY2gzLmRlZmF1bHQpKHRoaXMuX2xlYWZsZXRFdmVudHMsIGZ1bmN0aW9uIChjYiwgZXYpIHtcbiAgICAgICAgZWwub2ZmKGV2LCBjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMZWFmbGV0RWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlYWZsZXRFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVhZmxldEVsZW1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXh0cmFjdExlYWZsZXRFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0TGVhZmxldEV2ZW50cyhwcm9wcykge1xuICAgICAgcmV0dXJuICgwLCBfcmVkdWNlMy5kZWZhdWx0KSgoMCwgX2tleXMzLmRlZmF1bHQpKHByb3BzKSwgZnVuY3Rpb24gKHJlcywgcHJvcCkge1xuICAgICAgICB2YXIgbWF5YmVFdmVudCA9IHByb3AucmVwbGFjZShFVkVOVFNfUkVfTEVHQUNZLCBmdW5jdGlvbiAobWF0Y2gsIHApIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1wib25MZWFmbGV0JyArIHAgKyAnXCIgYW5kIG90aGVyIFwib25MZWFmbGV0Li4uXCIgcHJvcGVydGllcyBhcmUgZGVwcmVjYXRlZCBhbmQgc3VwcG9ydCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgdmVyc2lvbiwgdXNlIFwib24nICsgcCArICdcIiBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiAnb24nICsgcDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChFVkVOVFNfUkUudGVzdChtYXliZUV2ZW50KSkge1xuICAgICAgICAgIHZhciBrZXkgPSBtYXliZUV2ZW50LnJlcGxhY2UoRVZFTlRTX1JFLCBmdW5jdGlvbiAobWF0Y2gsIHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzW2tleV0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JpbmRMZWFmbGV0RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZExlYWZsZXRFdmVudHMoKSB7XG4gICAgICB2YXIgbmV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHByZXYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgdmFyIGVsID0gdGhpcy5sZWFmbGV0RWxlbWVudDtcbiAgICAgIGlmICghZWwgfHwgIWVsLm9uKSByZXR1cm47XG5cbiAgICAgIHZhciBkaWZmID0gKDAsIF9jbG9uZTMuZGVmYXVsdCkocHJldik7XG4gICAgICAoMCwgX2ZvckVhY2gzLmRlZmF1bHQpKHByZXYsIGZ1bmN0aW9uIChjYiwgZXYpIHtcbiAgICAgICAgaWYgKCFuZXh0W2V2XSB8fCBjYiAhPT0gbmV4dFtldl0pIHtcbiAgICAgICAgICBkZWxldGUgZGlmZltldl07XG4gICAgICAgICAgZWwub2ZmKGV2LCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX2ZvckVhY2gzLmRlZmF1bHQpKG5leHQsIGZ1bmN0aW9uIChjYiwgZXYpIHtcbiAgICAgICAgaWYgKCFwcmV2W2V2XSB8fCBjYiAhPT0gcHJldltldl0pIHtcbiAgICAgICAgICBkaWZmW2V2XSA9IGNiO1xuICAgICAgICAgIGVsLm9uKGV2LCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaXJlTGVhZmxldEV2ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZUxlYWZsZXRFdmVudCh0eXBlLCBkYXRhKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmxlYWZsZXRFbGVtZW50O1xuICAgICAgaWYgKGVsKSBlbC5maXJlKHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBDb21wb25lbnQ7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNYXBDb21wb25lbnQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9jb250cm9sUG9zaXRpb24gPSByZXF1aXJlKCcuL3R5cGVzL2NvbnRyb2xQb3NpdGlvbicpO1xuXG52YXIgX2NvbnRyb2xQb3NpdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250cm9sUG9zaXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBNYXBDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1hcENvbnRyb2wsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1hcENvbnRyb2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcENvbnRyb2wpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXBDb250cm9sKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBDb250cm9sLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LmFkZFRvKHRoaXMucHJvcHMubWFwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wb3NpdGlvbiAhPT0gcHJldlByb3BzLnBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0UG9zaXRpb24odGhpcy5wcm9wcy5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQucmVtb3ZlRnJvbSh0aGlzLnByb3BzLm1hcCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGVhZmxldEVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWFmbGV0RWxlbWVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlYWZsZXRFbGVtZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBDb250cm9sO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuTWFwQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG1hcDogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIHBvc2l0aW9uOiBfY29udHJvbFBvc2l0aW9uMi5kZWZhdWx0XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTWFwQ29udHJvbDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYXNzaWduMiA9IHJlcXVpcmUoJ2xvZGFzaC9hc3NpZ24nKTtcblxudmFyIF9hc3NpZ24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfY2hpbGRyZW4gPSByZXF1aXJlKCcuL3R5cGVzL2NoaWxkcmVuJyk7XG5cbnZhciBfY2hpbGRyZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hpbGRyZW4pO1xuXG52YXIgX2xheWVyQ29udGFpbmVyID0gcmVxdWlyZSgnLi90eXBlcy9sYXllckNvbnRhaW5lcicpO1xuXG52YXIgX2xheWVyQ29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xheWVyQ29udGFpbmVyKTtcblxudmFyIF9NYXBDb21wb25lbnQyID0gcmVxdWlyZSgnLi9NYXBDb21wb25lbnQnKTtcblxudmFyIF9NYXBDb21wb25lbnQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWFwQ29tcG9uZW50Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIE1hcExheWVyID0gZnVuY3Rpb24gKF9NYXBDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1hcExheWVyLCBfTWFwQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNYXBMYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXBMYXllcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwTGF5ZXIsIFt7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hcExheWVyLnByb3RvdHlwZSksICdjb21wb25lbnREaWRNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnByb3BzLmxheWVyQ29udGFpbmVyLmFkZExheWVyKHRoaXMubGVhZmxldEVsZW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXBMYXllci5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbFVubW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5wcm9wcy5sYXllckNvbnRhaW5lci5yZW1vdmVMYXllcih0aGlzLmxlYWZsZXRFbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDbG9uZWRDaGlsZHJlbldpdGhQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsb25lZENoaWxkcmVuV2l0aFByb3BzKGV4dHJhKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIGxheWVyQ29udGFpbmVyID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuXG4gICAgICB2YXIgcHJvcHMgPSAoMCwgX2Fzc2lnbjMuZGVmYXVsdCkoeyBtYXA6IG1hcCwgbGF5ZXJDb250YWluZXI6IGxheWVyQ29udGFpbmVyIH0sIGV4dHJhKTtcblxuICAgICAgcmV0dXJuIF9yZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQgPyAoMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoY2hpbGQsIHByb3BzKSA6IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJDaGlsZHJlbldpdGhQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuV2l0aFByb3BzKHByb3BzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENsb25lZENoaWxkcmVuV2l0aFByb3BzKHByb3BzKTtcbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gfSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcExheWVyO1xufShfTWFwQ29tcG9uZW50My5kZWZhdWx0KTtcblxuTWFwTGF5ZXIucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogX2NoaWxkcmVuMi5kZWZhdWx0LFxuICBsYXllckNvbnRhaW5lcjogX2xheWVyQ29udGFpbmVyMi5kZWZhdWx0LFxuICBtYXA6IF9yZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihfbGVhZmxldC5NYXApXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTWFwTGF5ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfbGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF9sYXRsbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF0bG5nKTtcblxudmFyIF9NYXBMYXllcjIgPSByZXF1aXJlKCcuL01hcExheWVyJyk7XG5cbnZhciBfTWFwTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWFwTGF5ZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBNYXJrZXIgPSBmdW5jdGlvbiAoX01hcExheWVyKSB7XG4gIF9pbmhlcml0cyhNYXJrZXIsIF9NYXBMYXllcik7XG5cbiAgZnVuY3Rpb24gTWFya2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXJrZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcmtlciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXJrZXIucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBfbWFwID0gX3Byb3BzLm1hcDtcbiAgICAgIHZhciBfbGMgPSBfcHJvcHMubGF5ZXJDb250YWluZXI7XG4gICAgICB2YXIgcG9zaXRpb24gPSBfcHJvcHMucG9zaXRpb247XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ2xheWVyQ29udGFpbmVyJywgJ3Bvc2l0aW9uJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0Lm1hcmtlcikocG9zaXRpb24sIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wb3NpdGlvbiAhPT0gcHJldlByb3BzLnBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0TGF0TG5nKHRoaXMucHJvcHMucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMuaWNvbiAhPT0gcHJldlByb3BzLmljb24pIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRJY29uKHRoaXMucHJvcHMuaWNvbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy56SW5kZXhPZmZzZXQgIT09IHByZXZQcm9wcy56SW5kZXhPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRaSW5kZXhPZmZzZXQodGhpcy5wcm9wcy56SW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMub3BhY2l0eSAhPT0gcHJldlByb3BzLm9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRPcGFjaXR5KHRoaXMucHJvcHMub3BhY2l0eSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy5kcmFnZ2FibGUgIT09IHByZXZQcm9wcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckNoaWxkcmVuV2l0aFByb3BzKHtcbiAgICAgICAgcG9wdXBDb250YWluZXI6IHRoaXMubGVhZmxldEVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrZXI7XG59KF9NYXBMYXllcjMuZGVmYXVsdCk7XG5cbk1hcmtlci5wcm9wVHlwZXMgPSB7XG4gIGljb246IF9yZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihfbGVhZmxldC5JY29uKSxcbiAgb3BhY2l0eTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIHBvc2l0aW9uOiBfbGF0bG5nMi5kZWZhdWx0LmlzUmVxdWlyZWQsXG4gIHpJbmRleE9mZnNldDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBNYXJrZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfbGF0bG5nTGlzdCA9IHJlcXVpcmUoJy4vdHlwZXMvbGF0bG5nTGlzdCcpO1xuXG52YXIgX2xhdGxuZ0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF0bG5nTGlzdCk7XG5cbnZhciBfUGF0aDIgPSByZXF1aXJlKCcuL1BhdGgnKTtcblxudmFyIF9QYXRoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhdGgyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKE11bHRpUG9seWdvbiwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIE11bHRpUG9seWdvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlQb2x5Z29uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTXVsdGlQb2x5Z29uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNdWx0aVBvbHlnb24sIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTXVsdGlQb2x5Z29uLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuICAgICAgdmFyIHBvbHlnb25zID0gX3Byb3BzLnBvbHlnb25zO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ21hcCcsICdsYXllckNvbnRhaW5lcicsICdwb2x5Z29ucyddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5tdWx0aVBvbHlnb24pKHBvbHlnb25zLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMucG9seWdvbnMgIT09IHByZXZQcm9wcy5wb2x5Z29ucykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZ3ModGhpcy5wcm9wcy5wb2x5Z29ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE11bHRpUG9seWdvbjtcbn0oX1BhdGgzLmRlZmF1bHQpO1xuXG5NdWx0aVBvbHlnb24ucHJvcFR5cGVzID0ge1xuICBwb2x5Z29uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9sYXRsbmdMaXN0Mi5kZWZhdWx0KS5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlQb2x5Z29uOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX2xhdGxuZ0xpc3QgPSByZXF1aXJlKCcuL3R5cGVzL2xhdGxuZ0xpc3QnKTtcblxudmFyIF9sYXRsbmdMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZ0xpc3QpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTXVsdGlQb2x5bGluZSA9IGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoTXVsdGlQb2x5bGluZSwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIE11bHRpUG9seWxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpUG9seWxpbmUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNdWx0aVBvbHlsaW5lKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNdWx0aVBvbHlsaW5lLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE11bHRpUG9seWxpbmUucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBfbWFwID0gX3Byb3BzLm1hcDtcbiAgICAgIHZhciBfbGMgPSBfcHJvcHMubGF5ZXJDb250YWluZXI7XG4gICAgICB2YXIgcG9seWxpbmVzID0gX3Byb3BzLnBvbHlsaW5lcztcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydtYXAnLCAnbGF5ZXJDb250YWluZXInLCAncG9seWxpbmVzJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0Lm11bHRpUG9seWxpbmUpKHBvbHlsaW5lcywgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBvbHlsaW5lcyAhPT0gcHJldlByb3BzLnBvbHlsaW5lcykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZ3ModGhpcy5wcm9wcy5wb2x5bGluZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNdWx0aVBvbHlsaW5lO1xufShfUGF0aDMuZGVmYXVsdCk7XG5cbk11bHRpUG9seWxpbmUucHJvcFR5cGVzID0ge1xuICBwb2x5bGluZXM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfbGF0bG5nTGlzdDIuZGVmYXVsdCkuaXNSZXF1aXJlZFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpUG9seWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BpY2syID0gcmVxdWlyZSgnbG9kYXNoL3BpY2snKTtcblxudmFyIF9waWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2syKTtcblxudmFyIF9pc0VxdWFsMiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0VxdWFsJyk7XG5cbnZhciBfaXNFcXVhbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0VxdWFsMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfTWFwTGF5ZXIyID0gcmVxdWlyZSgnLi9NYXBMYXllcicpO1xuXG52YXIgX01hcExheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcExheWVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIE9QVElPTlMgPSBbJ3N0cm9rZScsICdjb2xvcicsICd3ZWlnaHQnLCAnb3BhY2l0eScsICdmaWxsJywgJ2ZpbGxDb2xvcicsICdmaWxsT3BhY2l0eScsICdmaWxsUnVsZScsICdkYXNoQXJyYXknLCAnbGluZUNhcCcsICdsaW5lSm9pbicsICdjbGlja2FibGUnLCAncG9pbnRlckV2ZW50cycsICdjbGFzc05hbWUnXTtcblxudmFyIFBhdGggPSBmdW5jdGlvbiAoX01hcExheWVyKSB7XG4gIF9pbmhlcml0cyhQYXRoLCBfTWFwTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGgpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihQYXRoKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXRoLCBbe1xuICAgIGtleTogJ2dldFBhdGhPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aE9wdGlvbnMocHJvcHMpIHtcbiAgICAgIHJldHVybiAoMCwgX3BpY2szLmRlZmF1bHQpKHByb3BzLCBPUFRJT05TKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0eWxlKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRTdHlsZShvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdHlsZUlmQ2hhbmdlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0eWxlSWZDaGFuZ2VkKGZyb21Qcm9wcywgdG9Qcm9wcykge1xuICAgICAgdmFyIG5leHRTdHlsZSA9IHRoaXMuZ2V0UGF0aE9wdGlvbnModG9Qcm9wcyk7XG4gICAgICBpZiAoISgwLCBfaXNFcXVhbDMuZGVmYXVsdCkobmV4dFN0eWxlLCB0aGlzLmdldFBhdGhPcHRpb25zKGZyb21Qcm9wcykpKSB7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUobmV4dFN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJDaGlsZHJlbldpdGhQcm9wcyh7XG4gICAgICAgIHBvcHVwQ29udGFpbmVyOiB0aGlzLmxlYWZsZXRFbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0aDtcbn0oX01hcExheWVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGF0aDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9sYXRsbmdMaXN0ID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmdMaXN0Jyk7XG5cbnZhciBfbGF0bG5nTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXRsbmdMaXN0KTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFBvbHlnb24gPSBmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKFBvbHlnb24sIF9QYXRoKTtcblxuICBmdW5jdGlvbiBQb2x5Z29uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5Z29uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9seWdvbikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9seWdvbiwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihQb2x5Z29uLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IF9wcm9wcy5wb3NpdGlvbnM7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ2xheWVyQ29udGFpbmVyJywgJ3Bvc2l0aW9ucyddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5wb2x5Z29uKShwb3NpdGlvbnMsIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wb3NpdGlvbnMgIT09IHByZXZQcm9wcy5wb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmdzKHRoaXMucHJvcHMucG9zaXRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9seWdvbjtcbn0oX1BhdGgzLmRlZmF1bHQpO1xuXG5Qb2x5Z29uLnByb3BUeXBlcyA9IHtcbiAgcG9zaXRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX2xhdGxuZ0xpc3QyLmRlZmF1bHQsIF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfbGF0bG5nTGlzdDIuZGVmYXVsdCldKS5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gUG9seWdvbjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX2xhdGxuZ0xpc3QgPSByZXF1aXJlKCcuL3R5cGVzL2xhdGxuZ0xpc3QnKTtcblxudmFyIF9sYXRsbmdMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZ0xpc3QpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUG9seWxpbmUgPSBmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKFBvbHlsaW5lLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gUG9seWxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbHlsaW5lKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9seWxpbmUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbHlsaW5lLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvbHlsaW5lLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IF9wcm9wcy5wb3NpdGlvbnM7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ2xheWVyQ29udGFpbmVyJywgJ3Bvc2l0aW9ucyddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5wb2x5bGluZSkocG9zaXRpb25zLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMucG9zaXRpb25zICE9PSBwcmV2UHJvcHMucG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0TGF0TG5ncyh0aGlzLnByb3BzLnBvc2l0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHlsaW5lO1xufShfUGF0aDMuZGVmYXVsdCk7XG5cblBvbHlsaW5lLnByb3BUeXBlcyA9IHtcbiAgcG9zaXRpb25zOiBfbGF0bG5nTGlzdDIuZGVmYXVsdC5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gUG9seWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9sYXRsbmcgPSByZXF1aXJlKCcuL3R5cGVzL2xhdGxuZycpO1xuXG52YXIgX2xhdGxuZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXRsbmcpO1xuXG52YXIgX01hcENvbXBvbmVudDIgPSByZXF1aXJlKCcuL01hcENvbXBvbmVudCcpO1xuXG52YXIgX01hcENvbXBvbmVudDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb21wb25lbnQyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQb3B1cCA9IGZ1bmN0aW9uIChfTWFwQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQb3B1cCwgX01hcENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9wdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHVwKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9wdXApLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvcHVwLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvcHVwLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX2NoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIF9tYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIHBvcHVwQ29udGFpbmVyID0gX3Byb3BzLnBvcHVwQ29udGFpbmVyO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2NoaWxkcmVuJywgJ21hcCcsICdwb3B1cENvbnRhaW5lciddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5wb3B1cCkocHJvcHMsIHBvcHVwQ29udGFpbmVyKTtcbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQub24oJ29wZW4nLCB0aGlzLnJlbmRlclBvcHVwQ29udGVudC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQub24oJ2Nsb3NlJywgdGhpcy5yZW1vdmVQb3B1cENvbnRlbnQuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMyLm1hcDtcbiAgICAgIHZhciBwb3B1cENvbnRhaW5lciA9IF9wcm9wczIucG9wdXBDb250YWluZXI7XG4gICAgICB2YXIgcG9zaXRpb24gPSBfcHJvcHMyLnBvc2l0aW9uO1xuXG4gICAgICB2YXIgZWwgPSB0aGlzLmxlYWZsZXRFbGVtZW50O1xuXG4gICAgICBpZiAocG9wdXBDb250YWluZXIpIHtcbiAgICAgICAgLy8gQXR0YWNoIHRvIGNvbnRhaW5lciBjb21wb25lbnRcbiAgICAgICAgcG9wdXBDb250YWluZXIuYmluZFBvcHVwKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0dGFjaCB0byBhIE1hcFxuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICBlbC5zZXRMYXRMbmcocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsLm9wZW5PbihtYXApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucHJvcHMucG9zaXRpb247XG5cblxuICAgICAgaWYgKHBvc2l0aW9uICE9PSBwcmV2UHJvcHMucG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmcocG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sZWFmbGV0RWxlbWVudC5faXNPcGVuKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUG9wdXBDb250ZW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvcHVwLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsVW5tb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJlbW92ZVBvcHVwQ29udGVudCgpO1xuICAgICAgdGhpcy5wcm9wcy5tYXAucmVtb3ZlTGF5ZXIodGhpcy5sZWFmbGV0RWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyUG9wdXBDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUG9wdXBDb250ZW50KCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgKDAsIF9yZWFjdERvbS5yZW5kZXIpKF9yZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB0aGlzLmxlYWZsZXRFbGVtZW50Ll9jb250ZW50Tm9kZSk7XG5cbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5fdXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuX2FkanVzdFBhbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQb3B1cENvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVQb3B1cENvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQb3B1cENvbnRlbnQoKSB7XG4gICAgICBpZiAodGhpcy5sZWFmbGV0RWxlbWVudC5fY29udGVudE5vZGUpIHtcbiAgICAgICAgKDAsIF9yZWFjdERvbS51bm1vdW50Q29tcG9uZW50QXROb2RlKSh0aGlzLmxlYWZsZXRFbGVtZW50Ll9jb250ZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvcHVwO1xufShfTWFwQ29tcG9uZW50My5kZWZhdWx0KTtcblxuUG9wdXAucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5ub2RlLFxuICBtYXA6IF9yZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihfbGVhZmxldC5NYXApLFxuICBwb3B1cENvbnRhaW5lcjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIHBvc2l0aW9uOiBfbGF0bG5nMi5kZWZhdWx0XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gUG9wdXA7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9ib3VuZHMgPSByZXF1aXJlKCcuL3R5cGVzL2JvdW5kcycpO1xuXG52YXIgX2JvdW5kczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib3VuZHMpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVjdGFuZ2xlID0gZnVuY3Rpb24gKF9QYXRoKSB7XG4gIF9pbmhlcml0cyhSZWN0YW5nbGUsIF9QYXRoKTtcblxuICBmdW5jdGlvbiBSZWN0YW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3RhbmdsZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlY3RhbmdsZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVjdGFuZ2xlLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlY3RhbmdsZS5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGJvdW5kcyA9IF9wcm9wcy5ib3VuZHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2JvdW5kcycsICdtYXAnLCAnbGF5ZXJDb250YWluZXInXSk7XG5cbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQgPSAoMCwgX2xlYWZsZXQucmVjdGFuZ2xlKShib3VuZHMsIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMgIT09IHByZXZQcm9wcy5ib3VuZHMpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRCb3VuZHModGhpcy5wcm9wcy5ib3VuZHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWN0YW5nbGU7XG59KF9QYXRoMy5kZWZhdWx0KTtcblxuUmVjdGFuZ2xlLnByb3BUeXBlcyA9IHtcbiAgYm91bmRzOiBfYm91bmRzMi5kZWZhdWx0LmlzUmVxdWlyZWRcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBSZWN0YW5nbGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX01hcENvbnRyb2wyID0gcmVxdWlyZSgnLi9NYXBDb250cm9sJyk7XG5cbnZhciBfTWFwQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb250cm9sMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFpvb21Db250cm9sID0gZnVuY3Rpb24gKF9NYXBDb250cm9sKSB7XG4gIF9pbmhlcml0cyhab29tQ29udHJvbCwgX01hcENvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIFpvb21Db250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBab29tQ29udHJvbCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFpvb21Db250cm9sKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhab29tQ29udHJvbCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQuY29udHJvbC5zY2FsZSh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWm9vbUNvbnRyb2w7XG59KF9NYXBDb250cm9sMy5kZWZhdWx0KTtcblxuWm9vbUNvbnRyb2wucHJvcFR5cGVzID0ge1xuICBpbXBlcmlhbDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICBtYXhXaWR0aDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIG1ldHJpYzogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICB1cGRhdGVXaGVuSWRsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gWm9vbUNvbnRyb2w7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfQmFzZVRpbGVMYXllcjIgPSByZXF1aXJlKCcuL0Jhc2VUaWxlTGF5ZXInKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUaWxlTGF5ZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUaWxlTGF5ZXIgPSBmdW5jdGlvbiAoX0Jhc2VUaWxlTGF5ZXIpIHtcbiAgX2luaGVyaXRzKFRpbGVMYXllciwgX0Jhc2VUaWxlTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFRpbGVMYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGlsZUxheWVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGlsZUxheWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaWxlTGF5ZXIsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGlsZUxheWVyLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuICAgICAgdmFyIHVybCA9IF9wcm9wcy51cmw7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ2xheWVyQ29udGFpbmVyJywgJ3VybCddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC50aWxlTGF5ZXIpKHVybCwgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbGVMYXllci5wcm90b3R5cGUpLCAnY29tcG9uZW50RGlkVXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBwcmV2UHJvcHMpO1xuICAgICAgdmFyIHVybCA9IHRoaXMucHJvcHMudXJsO1xuXG4gICAgICBpZiAodXJsICE9PSBwcmV2UHJvcHMudXJsKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0VXJsKHVybCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRpbGVMYXllcjtcbn0oX0Jhc2VUaWxlTGF5ZXIzLmRlZmF1bHQpO1xuXG5UaWxlTGF5ZXIucHJvcFR5cGVzID0ge1xuICB1cmw6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBUaWxlTGF5ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfQmFzZVRpbGVMYXllcjIgPSByZXF1aXJlKCcuL0Jhc2VUaWxlTGF5ZXInKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUaWxlTGF5ZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBXTVNUaWxlTGF5ZXIgPSBmdW5jdGlvbiAoX0Jhc2VUaWxlTGF5ZXIpIHtcbiAgX2luaGVyaXRzKFdNU1RpbGVMYXllciwgX0Jhc2VUaWxlTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFdNU1RpbGVMYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV01TVGlsZUxheWVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV01TVGlsZUxheWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXTVNUaWxlTGF5ZXIsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoV01TVGlsZUxheWVyLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX21hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgX2xjID0gX3Byb3BzLmxheWVyQ29udGFpbmVyO1xuICAgICAgdmFyIHVybCA9IF9wcm9wcy51cmw7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ2xheWVyQ29udGFpbmVyJywgJ3VybCddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9IF9sZWFmbGV0LnRpbGVMYXllci53bXModXJsLCBwcm9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdNU1RpbGVMYXllcjtcbn0oX0Jhc2VUaWxlTGF5ZXIzLmRlZmF1bHQpO1xuXG5XTVNUaWxlTGF5ZXIucHJvcFR5cGVzID0ge1xuICB1cmw6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBXTVNUaWxlTGF5ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX01hcENvbnRyb2wyID0gcmVxdWlyZSgnLi9NYXBDb250cm9sJyk7XG5cbnZhciBfTWFwQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb250cm9sMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFpvb21Db250cm9sID0gZnVuY3Rpb24gKF9NYXBDb250cm9sKSB7XG4gIF9pbmhlcml0cyhab29tQ29udHJvbCwgX01hcENvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIFpvb21Db250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBab29tQ29udHJvbCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFpvb21Db250cm9sKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhab29tQ29udHJvbCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQuY29udHJvbC56b29tKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBab29tQ29udHJvbDtcbn0oX01hcENvbnRyb2wzLmRlZmF1bHQpO1xuXG5ab29tQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIHpvb21JblRleHQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICB6b29tSW5UaXRsZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIHpvb21PdXRUZXh0OiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgem9vbU91dFRpdGxlOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFpvb21Db250cm9sOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0SWNvbkRlZmF1bHRJbWFnZVBhdGggPSBleHBvcnRzLlpvb21Db250cm9sID0gZXhwb3J0cy5XTVNUaWxlTGF5ZXIgPSBleHBvcnRzLlRpbGVMYXllciA9IGV4cG9ydHMuU2NhbGVDb250cm9sID0gZXhwb3J0cy5SZWN0YW5nbGUgPSBleHBvcnRzLlBvcHVwID0gZXhwb3J0cy5Qb2x5bGluZSA9IGV4cG9ydHMuUG9seWdvbiA9IGV4cG9ydHMuUGF0aCA9IGV4cG9ydHMuTXVsdGlQb2x5bGluZSA9IGV4cG9ydHMuTXVsdGlQb2x5Z29uID0gZXhwb3J0cy5NYXJrZXIgPSBleHBvcnRzLk1hcExheWVyID0gZXhwb3J0cy5NYXBDb250cm9sID0gZXhwb3J0cy5NYXBDb21wb25lbnQgPSBleHBvcnRzLk1hcCA9IGV4cG9ydHMuTGF5ZXJzQ29udHJvbCA9IGV4cG9ydHMuTGF5ZXJHcm91cCA9IGV4cG9ydHMuSW1hZ2VPdmVybGF5ID0gZXhwb3J0cy5HZW9Kc29uID0gZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBleHBvcnRzLkNpcmNsZU1hcmtlciA9IGV4cG9ydHMuQ2lyY2xlID0gZXhwb3J0cy5DYW52YXNUaWxlTGF5ZXIgPSBleHBvcnRzLkJhc2VUaWxlTGF5ZXIgPSBleHBvcnRzLkF0dHJpYnV0aW9uQ29udHJvbCA9IGV4cG9ydHMuUHJvcFR5cGVzID0gdW5kZWZpbmVkO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfbGVhZmxldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sZWFmbGV0KTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxudmFyIF9Qcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdHlwZXMpO1xuXG52YXIgX0F0dHJpYnV0aW9uQ29udHJvbDIgPSByZXF1aXJlKCcuL0F0dHJpYnV0aW9uQ29udHJvbCcpO1xuXG52YXIgX0F0dHJpYnV0aW9uQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdHRyaWJ1dGlvbkNvbnRyb2wyKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vQmFzZVRpbGVMYXllcicpO1xuXG52YXIgX0Jhc2VUaWxlTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRpbGVMYXllcjIpO1xuXG52YXIgX0NhbnZhc1RpbGVMYXllcjIgPSByZXF1aXJlKCcuL0NhbnZhc1RpbGVMYXllcicpO1xuXG52YXIgX0NhbnZhc1RpbGVMYXllcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNUaWxlTGF5ZXIyKTtcblxudmFyIF9DaXJjbGUyID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxudmFyIF9DaXJjbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlMik7XG5cbnZhciBfQ2lyY2xlTWFya2VyMiA9IHJlcXVpcmUoJy4vQ2lyY2xlTWFya2VyJyk7XG5cbnZhciBfQ2lyY2xlTWFya2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZU1hcmtlcjIpO1xuXG52YXIgX0ZlYXR1cmVHcm91cDIgPSByZXF1aXJlKCcuL0ZlYXR1cmVHcm91cCcpO1xuXG52YXIgX0ZlYXR1cmVHcm91cDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GZWF0dXJlR3JvdXAyKTtcblxudmFyIF9HZW9Kc29uMiA9IHJlcXVpcmUoJy4vR2VvSnNvbicpO1xuXG52YXIgX0dlb0pzb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR2VvSnNvbjIpO1xuXG52YXIgX0ltYWdlT3ZlcmxheTIgPSByZXF1aXJlKCcuL0ltYWdlT3ZlcmxheScpO1xuXG52YXIgX0ltYWdlT3ZlcmxheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbWFnZU92ZXJsYXkyKTtcblxudmFyIF9MYXllckdyb3VwMiA9IHJlcXVpcmUoJy4vTGF5ZXJHcm91cCcpO1xuXG52YXIgX0xheWVyR3JvdXAzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGF5ZXJHcm91cDIpO1xuXG52YXIgX0xheWVyc0NvbnRyb2wyID0gcmVxdWlyZSgnLi9MYXllcnNDb250cm9sJyk7XG5cbnZhciBfTGF5ZXJzQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYXllcnNDb250cm9sMik7XG5cbnZhciBfTWFwMiA9IHJlcXVpcmUoJy4vTWFwJyk7XG5cbnZhciBfTWFwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcDIpO1xuXG52YXIgX01hcENvbXBvbmVudDIgPSByZXF1aXJlKCcuL01hcENvbXBvbmVudCcpO1xuXG52YXIgX01hcENvbXBvbmVudDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb21wb25lbnQyKTtcblxudmFyIF9NYXBDb250cm9sMiA9IHJlcXVpcmUoJy4vTWFwQ29udHJvbCcpO1xuXG52YXIgX01hcENvbnRyb2wzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWFwQ29udHJvbDIpO1xuXG52YXIgX01hcExheWVyMiA9IHJlcXVpcmUoJy4vTWFwTGF5ZXInKTtcblxudmFyIF9NYXBMYXllcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBMYXllcjIpO1xuXG52YXIgX01hcmtlcjIgPSByZXF1aXJlKCcuL01hcmtlcicpO1xuXG52YXIgX01hcmtlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXJrZXIyKTtcblxudmFyIF9NdWx0aVBvbHlnb24yID0gcmVxdWlyZSgnLi9NdWx0aVBvbHlnb24nKTtcblxudmFyIF9NdWx0aVBvbHlnb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTXVsdGlQb2x5Z29uMik7XG5cbnZhciBfTXVsdGlQb2x5bGluZTIgPSByZXF1aXJlKCcuL011bHRpUG9seWxpbmUnKTtcblxudmFyIF9NdWx0aVBvbHlsaW5lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX011bHRpUG9seWxpbmUyKTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG52YXIgX1BvbHlnb24yID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XG5cbnZhciBfUG9seWdvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb2x5Z29uMik7XG5cbnZhciBfUG9seWxpbmUyID0gcmVxdWlyZSgnLi9Qb2x5bGluZScpO1xuXG52YXIgX1BvbHlsaW5lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvbHlsaW5lMik7XG5cbnZhciBfUG9wdXAyID0gcmVxdWlyZSgnLi9Qb3B1cCcpO1xuXG52YXIgX1BvcHVwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwMik7XG5cbnZhciBfUmVjdGFuZ2xlMiA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XG5cbnZhciBfUmVjdGFuZ2xlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY3RhbmdsZTIpO1xuXG52YXIgX1NjYWxlQ29udHJvbDIgPSByZXF1aXJlKCcuL1NjYWxlQ29udHJvbCcpO1xuXG52YXIgX1NjYWxlQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TY2FsZUNvbnRyb2wyKTtcblxudmFyIF9UaWxlTGF5ZXIyID0gcmVxdWlyZSgnLi9UaWxlTGF5ZXInKTtcblxudmFyIF9UaWxlTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGlsZUxheWVyMik7XG5cbnZhciBfV01TVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vV01TVGlsZUxheWVyJyk7XG5cbnZhciBfV01TVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dNU1RpbGVMYXllcjIpO1xuXG52YXIgX1pvb21Db250cm9sMiA9IHJlcXVpcmUoJy4vWm9vbUNvbnRyb2wnKTtcblxudmFyIF9ab29tQ29udHJvbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ab29tQ29udHJvbDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlByb3BUeXBlcyA9IF9Qcm9wVHlwZXM7XG5leHBvcnRzLkF0dHJpYnV0aW9uQ29udHJvbCA9IF9BdHRyaWJ1dGlvbkNvbnRyb2wzLmRlZmF1bHQ7XG5leHBvcnRzLkJhc2VUaWxlTGF5ZXIgPSBfQmFzZVRpbGVMYXllcjMuZGVmYXVsdDtcbmV4cG9ydHMuQ2FudmFzVGlsZUxheWVyID0gX0NhbnZhc1RpbGVMYXllcjMuZGVmYXVsdDtcbmV4cG9ydHMuQ2lyY2xlID0gX0NpcmNsZTMuZGVmYXVsdDtcbmV4cG9ydHMuQ2lyY2xlTWFya2VyID0gX0NpcmNsZU1hcmtlcjMuZGVmYXVsdDtcbmV4cG9ydHMuRmVhdHVyZUdyb3VwID0gX0ZlYXR1cmVHcm91cDMuZGVmYXVsdDtcbmV4cG9ydHMuR2VvSnNvbiA9IF9HZW9Kc29uMy5kZWZhdWx0O1xuZXhwb3J0cy5JbWFnZU92ZXJsYXkgPSBfSW1hZ2VPdmVybGF5My5kZWZhdWx0O1xuZXhwb3J0cy5MYXllckdyb3VwID0gX0xheWVyR3JvdXAzLmRlZmF1bHQ7XG5leHBvcnRzLkxheWVyc0NvbnRyb2wgPSBfTGF5ZXJzQ29udHJvbDMuZGVmYXVsdDtcbmV4cG9ydHMuTWFwID0gX01hcDMuZGVmYXVsdDtcbmV4cG9ydHMuTWFwQ29tcG9uZW50ID0gX01hcENvbXBvbmVudDMuZGVmYXVsdDtcbmV4cG9ydHMuTWFwQ29udHJvbCA9IF9NYXBDb250cm9sMy5kZWZhdWx0O1xuZXhwb3J0cy5NYXBMYXllciA9IF9NYXBMYXllcjMuZGVmYXVsdDtcbmV4cG9ydHMuTWFya2VyID0gX01hcmtlcjMuZGVmYXVsdDtcbmV4cG9ydHMuTXVsdGlQb2x5Z29uID0gX011bHRpUG9seWdvbjMuZGVmYXVsdDtcbmV4cG9ydHMuTXVsdGlQb2x5bGluZSA9IF9NdWx0aVBvbHlsaW5lMy5kZWZhdWx0O1xuZXhwb3J0cy5QYXRoID0gX1BhdGgzLmRlZmF1bHQ7XG5leHBvcnRzLlBvbHlnb24gPSBfUG9seWdvbjMuZGVmYXVsdDtcbmV4cG9ydHMuUG9seWxpbmUgPSBfUG9seWxpbmUzLmRlZmF1bHQ7XG5leHBvcnRzLlBvcHVwID0gX1BvcHVwMy5kZWZhdWx0O1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBfUmVjdGFuZ2xlMy5kZWZhdWx0O1xuZXhwb3J0cy5TY2FsZUNvbnRyb2wgPSBfU2NhbGVDb250cm9sMy5kZWZhdWx0O1xuZXhwb3J0cy5UaWxlTGF5ZXIgPSBfVGlsZUxheWVyMy5kZWZhdWx0O1xuZXhwb3J0cy5XTVNUaWxlTGF5ZXIgPSBfV01TVGlsZUxheWVyMy5kZWZhdWx0O1xuZXhwb3J0cy5ab29tQ29udHJvbCA9IF9ab29tQ29udHJvbDMuZGVmYXVsdDtcbnZhciBzZXRJY29uRGVmYXVsdEltYWdlUGF0aCA9IGV4cG9ydHMuc2V0SWNvbkRlZmF1bHRJbWFnZVBhdGggPSBmdW5jdGlvbiBzZXRJY29uRGVmYXVsdEltYWdlUGF0aChwYXRoKSB7XG4gIF9sZWFmbGV0Mi5kZWZhdWx0Lkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSBwYXRoO1xufTtcblxuc2V0SWNvbkRlZmF1bHRJbWFnZVBhdGgoJy8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2xlYWZsZXQvMC43LjcvaW1hZ2VzJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX2xhdGxuZ0xpc3QgPSByZXF1aXJlKCcuL2xhdGxuZ0xpc3QnKTtcblxudmFyIF9sYXRsbmdMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZ0xpc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5pbnN0YW5jZU9mKF9sZWFmbGV0LkxhdExuZ0JvdW5kcyksIF9sYXRsbmdMaXN0Mi5kZWZhdWx0XSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLm5vZGUpLCBfcmVhY3QuUHJvcFR5cGVzLm5vZGVdKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsndG9wbGVmdCcsICd0b3ByaWdodCcsICdib3R0b21sZWZ0JywgJ2JvdHRvbXJpZ2h0J10pOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubGF5ZXJDb250YWluZXIgPSBleHBvcnRzLmxhdGxuZ0xpc3QgPSBleHBvcnRzLmxhdGxuZyA9IGV4cG9ydHMuY29udHJvbFBvc2l0aW9uID0gZXhwb3J0cy5jaGlsZHJlbiA9IGV4cG9ydHMuYm91bmRzID0gdW5kZWZpbmVkO1xuXG52YXIgX2JvdW5kczIgPSByZXF1aXJlKCcuL2JvdW5kcycpO1xuXG52YXIgX2JvdW5kczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib3VuZHMyKTtcblxudmFyIF9jaGlsZHJlbjIgPSByZXF1aXJlKCcuL2NoaWxkcmVuJyk7XG5cbnZhciBfY2hpbGRyZW4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hpbGRyZW4yKTtcblxudmFyIF9jb250cm9sUG9zaXRpb24yID0gcmVxdWlyZSgnLi9jb250cm9sUG9zaXRpb24nKTtcblxudmFyIF9jb250cm9sUG9zaXRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udHJvbFBvc2l0aW9uMik7XG5cbnZhciBfbGF0bG5nMiA9IHJlcXVpcmUoJy4vbGF0bG5nJyk7XG5cbnZhciBfbGF0bG5nMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZzIpO1xuXG52YXIgX2xhdGxuZ0xpc3QyID0gcmVxdWlyZSgnLi9sYXRsbmdMaXN0Jyk7XG5cbnZhciBfbGF0bG5nTGlzdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXRsbmdMaXN0Mik7XG5cbnZhciBfbGF5ZXJDb250YWluZXIyID0gcmVxdWlyZSgnLi9sYXllckNvbnRhaW5lcicpO1xuXG52YXIgX2xheWVyQ29udGFpbmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xheWVyQ29udGFpbmVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuYm91bmRzID0gX2JvdW5kczMuZGVmYXVsdDtcbmV4cG9ydHMuY2hpbGRyZW4gPSBfY2hpbGRyZW4zLmRlZmF1bHQ7XG5leHBvcnRzLmNvbnRyb2xQb3NpdGlvbiA9IF9jb250cm9sUG9zaXRpb24zLmRlZmF1bHQ7XG5leHBvcnRzLmxhdGxuZyA9IF9sYXRsbmczLmRlZmF1bHQ7XG5leHBvcnRzLmxhdGxuZ0xpc3QgPSBfbGF0bG5nTGlzdDMuZGVmYXVsdDtcbmV4cG9ydHMubGF5ZXJDb250YWluZXIgPSBfbGF5ZXJDb250YWluZXIzLmRlZmF1bHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1xuLy8gW051bWJlciwgTnVtYmVyXVxuX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyKSxcbi8vIHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9XG5fcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgbGF0OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgbG5nOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxufSksXG4vLyB7bGF0OiBOdW1iZXIsIGxvbjogTnVtYmVyfVxuX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4gIGxhdDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIGxvbjogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcbn0pXSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sYXRsbmcgPSByZXF1aXJlKCcuL2xhdGxuZycpO1xuXG52YXIgX2xhdGxuZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXRsbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX2xhdGxuZzIuZGVmYXVsdCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4gIGFkZExheWVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVtb3ZlTGF5ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTsiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFJlZmxlY3QgPSByb290LlJlZmxlY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgTWFwI3NldGAgYmVjYXVzZSBpdCBkb2Vzbid0IHJldHVybiB0aGUgbWFwIGluc3RhbmNlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1hcEVudHJ5O1xuIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSG9zdE9iamVjdCA9IHJlcXVpcmUoJy4vX2lzSG9zdE9iamVjdCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNGdWxsXSBTcGVjaWZ5IGEgY2xvbmUgaW5jbHVkaW5nIHN5bWJvbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgaWYgKGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoIWlzQXJyKSB7XG4gICAgdmFyIHByb3BzID0gaXNGdWxsID8gZ2V0QWxsS2V5cyh2YWx1ZSkgOiBrZXlzKHZhbHVlKTtcbiAgfVxuICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90bykge1xuICByZXR1cm4gaXNPYmplY3QocHJvdG8pID8gb2JqZWN0Q3JlYXRlKHByb3RvKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfVxuICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRGlmZmVyZW5jZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgLy8gQXZvaWQgYSBidWcgaW4gSUUgMTAtMTEgd2hlcmUgb2JqZWN0cyB3aXRoIGEgW1tQcm90b3R5cGVdXSBvZiBgbnVsbGAsXG4gIC8vIHRoYXQgYXJlIGNvbXBvc2VkIGVudGlyZWx5IG9mIGluZGV4IHByb3BlcnRpZXMsIHJldHVybiBgZmFsc2VgIGZvclxuICAvLyBgaGFzT3duUHJvcGVydHlgIGNoZWNrcyBvZiB0aGVtLlxuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiZcbiAgICAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmIGtleSBpbiBvYmplY3QgJiYgZ2V0UHJvdG90eXBlKG9iamVjdCkgPT09IG51bGwpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGluZGV4T2ZOYU4gPSByZXF1aXJlKCcuL19pbmRleE9mTmFOJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgpO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy5cbiAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAqICAgICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAgICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBnZXRUYWcob3RoZXIpO1xuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRywgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXM7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCBza2lwIHRoZSBjb25zdHJ1Y3RvclxuICogcHJvcGVydHkgb2YgcHJvdG90eXBlcyBvciB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIG5hdGl2ZUtleXMoT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL19SZWZsZWN0JyksXG4gICAgaXRlcmF0b3JUb0FycmF5ID0gcmVxdWlyZSgnLi9faXRlcmF0b3JUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGVudW1lcmF0ZSA9IFJlZmxlY3QgPyBSZWZsZWN0LmVudW1lcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCBza2lwIHRoZSBjb25zdHJ1Y3RvclxuICogcHJvcGVydHkgb2YgcHJvdG90eXBlcyBvciB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBvYmplY3QgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IE9iamVjdChvYmplY3QpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIElFIDwgOSB3aXRoIGVzNi1zaGltLlxuaWYgKGVudW1lcmF0ZSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7ICd2YWx1ZU9mJzogMSB9LCAndmFsdWVPZicpKSB7XG4gIGJhc2VLZXlzSW4gPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KGVudW1lcmF0ZShvYmplY3QpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHVuZGVmaW5lZCwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHByb3BzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UocHJvcHMsIGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlZHVjZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3Jpbmcgd3JhcHBlciBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgYHZhbHVlYCBpZiBpdCdzIGEgZ2xvYmFsIG9iamVjdCwgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrR2xvYmFsO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCJ2YXIgYWRkTWFwRW50cnkgPSByZXF1aXJlKCcuL19hZGRNYXBFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCB0cnVlKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVNYXA7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIGFkZFNldEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkU2V0RW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgdHJ1ZSkgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiBzb3VyY2Vba2V5XTtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIHJlc3QgPSByZXF1aXJlKCcuL3Jlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gcmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xudmFyIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgPSAxLFxuICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4uYWRkKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZFxuICAgICAgLy8gYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXNcbiAgICAgIC8vIG5vdCBlcXVhbC5cbiAgICAgIHJldHVybiArb2JqZWN0ID09ICtvdGhlcjtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBUcmVhdCBgTmFOYCB2cy4gYE5hTmAgYXMgZXF1YWwuXG4gICAgICByZXR1cm4gKG9iamVjdCAhPSArb2JqZWN0KSA/IG90aGVyICE9ICtvdGhlciA6IG9iamVjdCA9PSArb3RoZXI7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IFVOT1JERVJFRF9DT01QQVJFX0ZMQUc7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgcmV0dXJuIGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBiYXNlSGFzID0gcmVxdWlyZSgnLi9fYmFzZUhhcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGJhc2VIYXMob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYVxuICogW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpIHRoYXQgYWZmZWN0c1xuICogU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TGVuZ3RoO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBHZXRzIHRoZSBgW1tQcm90b3R5cGVdXWAgb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGBbW1Byb3RvdHlwZV1dYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG90eXBlKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGUoT2JqZWN0KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9sIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3ltYm9scyhvYmplY3QpIHtcbiAgLy8gQ29lcmNlIGBvYmplY3RgIHRvIGFuIG9iamVjdCB0byBhdm9pZCBub24tb2JqZWN0IGVycm9ycyBpbiBWOC5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDMgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyhPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBJRSA8IDExLlxuaWYgKCFnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgZ2V0U3ltYm9scyA9IHN0dWJBcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllc1xuICogb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBnZXRTeW1ib2xzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNTdHJpbmcob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGluZGV4IGtleXMgZm9yIGBvYmplY3RgIHZhbHVlcyBvZiBhcnJheXMsXG4gKiBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgc3RyaW5ncywgb3RoZXJ3aXNlIGBudWxsYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fG51bGx9IFJldHVybnMgaW5kZXgga2V5cywgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4S2V5cyhvYmplY3QpIHtcbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiB1bmRlZmluZWQ7XG4gIGlmIChpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzU3RyaW5nKG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleEtleXM7XG4iLCIvKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBOYU5gIGlzIGZvdW5kIGluIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk5hTjtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVNYXAgPSByZXF1aXJlKCcuL19jbG9uZU1hcCcpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVNldCA9IHJlcXVpcmUoJy4vX2Nsb25lU2V0JyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNIb3N0T2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgdmFyIGRhdGEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpdGVyYXRvclRvQXJyYXk7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBjaGVja0dsb2JhbCA9IHJlcXVpcmUoJy4vX2NoZWNrR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpO1xuXG4vKiogRGV0ZWN0IGB0aGlzYCBhcyB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwodHlwZW9mIHRoaXMgPT0gJ29iamVjdCcgJiYgdGhpcyk7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSAmJiBjYWNoZS5fX2RhdGFfXy5sZW5ndGggPT0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIGNhY2hlID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShjYWNoZS5fX2RhdGFfXyk7XG4gIH1cbiAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KFxcLnxcXFtcXF0pKD86XFw0fCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuICovXG52YXIgbm9uRW51bVNoYWRvd3MgPSAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7ICd2YWx1ZU9mJzogMSB9LCAndmFsdWVPZicpO1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25JblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmUgPSA1O1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuZCA9IDQ7XG4gKiBCYXIucHJvdG90eXBlLmYgPSA2O1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMywgJ2UnOiA1IH1cbiAqL1xudmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGlmIChub25FbnVtU2hhZG93cyB8fCBpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgZmFsc2UsIHRydWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyB1c2VkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBpbmNvcnJlY3RseSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBnZXRMZW5ndGggPSByZXF1aXJlKCcuL19nZXRMZW5ndGgnKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9ICFCdWZmZXIgPyBzdHViRmFsc2UgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCdWZmZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSAqKm5vdCoqIHN1cHBvcnRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgd2VhayBtYXAgY29uc3RydWN0b3JzLFxuICAvLyBhbmQgUGhhbnRvbUpTIDEuOSB3aGljaCByZXR1cm5zICdmdW5jdGlvbicgZm9yIGBOb2RlTGlzdGAgaW5zdGFuY2VzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG4iLCJ2YXIgYmFzZUhhcyA9IHJlcXVpcmUoJy4vX2Jhc2VIYXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaW5kZXhLZXlzID0gcmVxdWlyZSgnLi9faW5kZXhLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpO1xuICBpZiAoIShpc1Byb3RvIHx8IGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XG4gICAgcmV0dXJuIGJhc2VLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIGluZGV4ZXMgPSBpbmRleEtleXMob2JqZWN0KSxcbiAgICAgIHNraXBJbmRleGVzID0gISFpbmRleGVzLFxuICAgICAgcmVzdWx0ID0gaW5kZXhlcyB8fCBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChiYXNlSGFzKG9iamVjdCwga2V5KSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSAmJlxuICAgICAgICAhKGlzUHJvdG8gJiYga2V5ID09ICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpbmRleEtleXMgPSByZXF1aXJlKCcuL19pbmRleEtleXMnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHByb3BzID0gYmFzZUtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBpbmRleGVzID0gaW5kZXhLZXlzKG9iamVjdCksXG4gICAgICBza2lwSW5kZXhlcyA9ICEhaW5kZXhlcyxcbiAgICAgIHJlc3VsdCA9IGluZGV4ZXMgfHwgW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlRGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vX2Jhc2VEaWZmZXJlbmNlJyksXG4gICAgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICByZXN0ID0gcmVxdWlyZSgnLi9yZXN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXQgYXJlXG4gKiBub3Qgb21pdHRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gb21pdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYic6ICcyJyB9XG4gKi9cbnZhciBvbWl0ID0gcmVzdChmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm9wcyA9IGFycmF5TWFwKGJhc2VGbGF0dGVuKHByb3BzLCAxKSwgdG9LZXkpO1xuICByZXR1cm4gYmFzZVBpY2sob2JqZWN0LCBiYXNlRGlmZmVyZW5jZShnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcHJvcHMpKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9taXQ7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUGljayA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrJyksXG4gICAgcmVzdCA9IHJlcXVpcmUoJy4vcmVzdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IHJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMsIDEpLCB0b0tleSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VSZWR1Y2UgPSByZXF1aXJlKCcuL19iYXNlUmVkdWNlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gKiBhbmQgYHNvcnRCeWBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAqICAgcmV0dXJuIHN1bSArIG47XG4gKiB9LCAwKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICogYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogdG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFycmF5KTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcnJheSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJyYXkpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3Q7XG4iLCIvKipcbiAqIEEgbWV0aG9kIHRoYXQgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBBIG1ldGhvZCB0aGF0IHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gaXNGdW5jdGlvbih2YWx1ZS52YWx1ZU9mKSA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xudmFyIGlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAqXG4gKiBfLnVuaXF1ZUlkKCk7XG4gKiAvLyA9PiAnMTA1J1xuICovXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2V4ZW52Jyk7XG52YXIgTW9kYWxQb3J0YWwgPSBSZWFjdC5jcmVhdGVGYWN0b3J5KHJlcXVpcmUoJy4vTW9kYWxQb3J0YWwnKSk7XG52YXIgYXJpYUFwcEhpZGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9hcmlhQXBwSGlkZXInKTtcbnZhciBlbGVtZW50Q2xhc3MgPSByZXF1aXJlKCdlbGVtZW50LWNsYXNzJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG52YXIgU2FmZUhUTUxFbGVtZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93LkhUTUxFbGVtZW50IDoge307XG5cbnZhciBNb2RhbCA9IG1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGRpc3BsYXlOYW1lOiAnTW9kYWwnLFxuICBzdGF0aWNzOiB7XG4gICAgc2V0QXBwRWxlbWVudDogYXJpYUFwcEhpZGVyLnNldEVsZW1lbnQsXG4gICAgaW5qZWN0Q1NTOiBmdW5jdGlvbigpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVlxuICAgICAgICAmJiBjb25zb2xlLndhcm4oJ1JlYWN0LU1vZGFsOiBpbmplY3RDU1MgaGFzIGJlZW4gZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbmQgbm8gbG9uZ2VyIGhhcyBhbnkgZWZmZWN0LiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uJyk7XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIGlzT3BlbjogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBzdHlsZTogUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGNvbnRlbnQ6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgICBvdmVybGF5OiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gICAgfSksXG4gICAgYXBwRWxlbWVudDogUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoU2FmZUhUTUxFbGVtZW50KSxcbiAgICBvblJlcXVlc3RDbG9zZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2xvc2VUaW1lb3V0TVM6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgYXJpYUhpZGVBcHA6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICBhcmlhSGlkZUFwcDogdHJ1ZSxcbiAgICAgIGNsb3NlVGltZW91dE1TOiAwXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5ub2RlLmNsYXNzTmFtZSA9ICdSZWFjdE1vZGFsUG9ydGFsJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgdGhpcy5yZW5kZXJQb3J0YWwodGhpcy5wcm9wcyk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV3UHJvcHMpIHtcbiAgICB0aGlzLnJlbmRlclBvcnRhbChuZXdQcm9wcyk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5ub2RlKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gIH0sXG5cbiAgcmVuZGVyUG9ydGFsOiBmdW5jdGlvbihwcm9wcykge1xuICAgIGlmIChwcm9wcy5pc09wZW4pIHtcbiAgICAgIGVsZW1lbnRDbGFzcyhkb2N1bWVudC5ib2R5KS5hZGQoJ1JlYWN0TW9kYWxfX0JvZHktLW9wZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudENsYXNzKGRvY3VtZW50LmJvZHkpLnJlbW92ZSgnUmVhY3RNb2RhbF9fQm9keS0tb3BlbicpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5hcmlhSGlkZUFwcCkge1xuICAgICAgYXJpYUFwcEhpZGVyLnRvZ2dsZShwcm9wcy5pc09wZW4sIHByb3BzLmFwcEVsZW1lbnQpO1xuICAgIH1cbiAgICBzYW5pdGl6ZVByb3BzKHByb3BzKTtcbiAgICB0aGlzLnBvcnRhbCA9IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHRoaXMsIE1vZGFsUG9ydGFsKHByb3BzKSwgdGhpcy5ub2RlKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3QuRE9NLm5vc2NyaXB0KCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVByb3BzKHByb3BzKSB7XG4gIGRlbGV0ZSBwcm9wcy5yZWY7XG59XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGRpdiA9IFJlYWN0LkRPTS5kaXY7XG52YXIgZm9jdXNNYW5hZ2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9mb2N1c01hbmFnZXInKTtcbnZhciBzY29wZVRhYiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc2NvcGVUYWInKTtcbnZhciBBc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guYXNzaWduJyk7XG5cblxuLy8gc28gdGhhdCBvdXIgQ1NTIGlzIHN0YXRpY2FsbHkgYW5hbHl6YWJsZVxudmFyIENMQVNTX05BTUVTID0ge1xuICBvdmVybGF5OiB7XG4gICAgYmFzZTogJ1JlYWN0TW9kYWxfX092ZXJsYXknLFxuICAgIGFmdGVyT3BlbjogJ1JlYWN0TW9kYWxfX092ZXJsYXktLWFmdGVyLW9wZW4nLFxuICAgIGJlZm9yZUNsb3NlOiAnUmVhY3RNb2RhbF9fT3ZlcmxheS0tYmVmb3JlLWNsb3NlJ1xuICB9LFxuICBjb250ZW50OiB7XG4gICAgYmFzZTogJ1JlYWN0TW9kYWxfX0NvbnRlbnQnLFxuICAgIGFmdGVyT3BlbjogJ1JlYWN0TW9kYWxfX0NvbnRlbnQtLWFmdGVyLW9wZW4nLFxuICAgIGJlZm9yZUNsb3NlOiAnUmVhY3RNb2RhbF9fQ29udGVudC0tYmVmb3JlLWNsb3NlJ1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFN0eWxlcyA9IHtcbiAgb3ZlcmxheToge1xuICAgIHBvc2l0aW9uICAgICAgICA6ICdmaXhlZCcsXG4gICAgdG9wICAgICAgICAgICAgIDogMCxcbiAgICBsZWZ0ICAgICAgICAgICAgOiAwLFxuICAgIHJpZ2h0ICAgICAgICAgICA6IDAsXG4gICAgYm90dG9tICAgICAgICAgIDogMCxcbiAgICBiYWNrZ3JvdW5kQ29sb3IgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KSdcbiAgfSxcbiAgY29udGVudDoge1xuICAgIHBvc2l0aW9uICAgICAgICAgICAgICAgIDogJ2Fic29sdXRlJyxcbiAgICB0b3AgICAgICAgICAgICAgICAgICAgICA6ICc0MHB4JyxcbiAgICBsZWZ0ICAgICAgICAgICAgICAgICAgICA6ICc0MHB4JyxcbiAgICByaWdodCAgICAgICAgICAgICAgICAgICA6ICc0MHB4JyxcbiAgICBib3R0b20gICAgICAgICAgICAgICAgICA6ICc0MHB4JyxcbiAgICBib3JkZXIgICAgICAgICAgICAgICAgICA6ICcxcHggc29saWQgI2NjYycsXG4gICAgYmFja2dyb3VuZCAgICAgICAgICAgICAgOiAnI2ZmZicsXG4gICAgb3ZlcmZsb3cgICAgICAgICAgICAgICAgOiAnYXV0bycsXG4gICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmcgOiAndG91Y2gnLFxuICAgIGJvcmRlclJhZGl1cyAgICAgICAgICAgIDogJzRweCcsXG4gICAgb3V0bGluZSAgICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgcGFkZGluZyAgICAgICAgICAgICAgICAgOiAnMjBweCdcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG52YXIgTW9kYWxQb3J0YWwgPSBtb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ01vZGFsUG9ydGFsJyxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBvdmVybGF5OiB7fSxcbiAgICAgICAgY29udGVudDoge31cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFmdGVyT3BlbjogZmFsc2UsXG4gICAgICBiZWZvcmVDbG9zZTogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAvLyBGb2N1cyBuZWVkcyB0byBiZSBzZXQgd2hlbiBtb3VudGluZyBhbmQgYWxyZWFkeSBvcGVuXG4gICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICB0aGlzLnNldEZvY3VzQWZ0ZXJSZW5kZXIodHJ1ZSk7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgLy8gRm9jdXMgb25seSBuZWVkcyB0byBiZSBzZXQgb25jZSB3aGVuIHRoZSBtb2RhbCBpcyBiZWluZyBvcGVuZWRcbiAgICBpZiAoIXRoaXMucHJvcHMuaXNPcGVuICYmIG5ld1Byb3BzLmlzT3Blbikge1xuICAgICAgdGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKHRydWUpO1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiAhbmV3UHJvcHMuaXNPcGVuKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZvY3VzQWZ0ZXJSZW5kZXIpIHtcbiAgICAgIHRoaXMuZm9jdXNDb250ZW50KCk7XG4gICAgICB0aGlzLnNldEZvY3VzQWZ0ZXJSZW5kZXIoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICBzZXRGb2N1c0FmdGVyUmVuZGVyOiBmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICB0aGlzLmZvY3VzQWZ0ZXJSZW5kZXIgPSBmb2N1cztcbiAgfSxcblxuICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICBmb2N1c01hbmFnZXIuc2V0dXBTY29wZWRGb2N1cyh0aGlzLm5vZGUpO1xuICAgIGZvY3VzTWFuYWdlci5tYXJrRm9yRm9jdXNMYXRlcigpO1xuICAgIHRoaXMuc2V0U3RhdGUoe2lzT3BlbjogdHJ1ZX0sIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7YWZ0ZXJPcGVuOiB0cnVlfSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm93bmVySGFuZGxlc0Nsb3NlKCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMgPiAwKVxuICAgICAgdGhpcy5jbG9zZVdpdGhUaW1lb3V0KCk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5jbG9zZVdpdGhvdXRUaW1lb3V0KCk7XG4gIH0sXG5cbiAgZm9jdXNDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZnMuY29udGVudC5mb2N1cygpO1xuICB9LFxuXG4gIGNsb3NlV2l0aFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe2JlZm9yZUNsb3NlOiB0cnVlfSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNsb3NlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2VXaXRob3V0VGltZW91dCwgdGhpcy5wcm9wcy5jbG9zZVRpbWVvdXRNUyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBjbG9zZVdpdGhvdXRUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFmdGVyT3BlbjogZmFsc2UsXG4gICAgICBiZWZvcmVDbG9zZTogZmFsc2VcbiAgICB9LCB0aGlzLmFmdGVyQ2xvc2UpO1xuICB9LFxuXG4gIGFmdGVyQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGZvY3VzTWFuYWdlci5yZXR1cm5Gb2N1cygpO1xuICAgIGZvY3VzTWFuYWdlci50ZWFyZG93blNjb3BlZEZvY3VzKCk7XG4gIH0sXG5cbiAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5IC8qdGFiKi8pIHNjb3BlVGFiKHRoaXMucmVmcy5jb250ZW50LCBldmVudCk7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcgLyplc2MqLykgdGhpcy5yZXF1ZXN0Q2xvc2UoKTtcbiAgfSxcblxuICBoYW5kbGVPdmVybGF5Q2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm93bmVySGFuZGxlc0Nsb3NlKCkpXG4gICAgICB0aGlzLnJlcXVlc3RDbG9zZSgpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuZm9jdXNDb250ZW50KCk7XG4gIH0sXG5cbiAgcmVxdWVzdENsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vd25lckhhbmRsZXNDbG9zZSgpKVxuICAgICAgdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZSgpO1xuICB9LFxuXG4gIG93bmVySGFuZGxlc0Nsb3NlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vblJlcXVlc3RDbG9zZTtcbiAgfSxcblxuICBzaG91bGRCZUNsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLnByb3BzLmlzT3BlbiAmJiAhdGhpcy5zdGF0ZS5iZWZvcmVDbG9zZTtcbiAgfSxcblxuICBidWlsZENsYXNzTmFtZTogZnVuY3Rpb24od2hpY2gsIGFkZGl0aW9uYWwpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gQ0xBU1NfTkFNRVNbd2hpY2hdLmJhc2U7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWZ0ZXJPcGVuKVxuICAgICAgY2xhc3NOYW1lICs9ICcgJytDTEFTU19OQU1FU1t3aGljaF0uYWZ0ZXJPcGVuO1xuICAgIGlmICh0aGlzLnN0YXRlLmJlZm9yZUNsb3NlKVxuICAgICAgY2xhc3NOYW1lICs9ICcgJytDTEFTU19OQU1FU1t3aGljaF0uYmVmb3JlQ2xvc2U7XG4gICAgcmV0dXJuIGFkZGl0aW9uYWwgPyBjbGFzc05hbWUgKyAnICcgKyBhZGRpdGlvbmFsIDogY2xhc3NOYW1lO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkQmVDbG9zZWQoKSA/IGRpdigpIDogKFxuICAgICAgZGl2KHtcbiAgICAgICAgcmVmOiBcIm92ZXJsYXlcIixcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ2xhc3NOYW1lKCdvdmVybGF5JywgdGhpcy5wcm9wcy5vdmVybGF5Q2xhc3NOYW1lKSxcbiAgICAgICAgc3R5bGU6IEFzc2lnbih7fSwgZGVmYXVsdFN0eWxlcy5vdmVybGF5LCB0aGlzLnByb3BzLnN0eWxlLm92ZXJsYXkgfHwge30pLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU92ZXJsYXlDbGlja1xuICAgICAgfSxcbiAgICAgICAgZGl2KHtcbiAgICAgICAgICByZWY6IFwiY29udGVudFwiLFxuICAgICAgICAgIHN0eWxlOiBBc3NpZ24oe30sIGRlZmF1bHRTdHlsZXMuY29udGVudCwgdGhpcy5wcm9wcy5zdHlsZS5jb250ZW50IHx8IHt9KSxcbiAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDbGFzc05hbWUoJ2NvbnRlbnQnLCB0aGlzLnByb3BzLmNsYXNzTmFtZSksXG4gICAgICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgICAgICBvbkNsaWNrOiBzdG9wUHJvcGFnYXRpb24sXG4gICAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd25cbiAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcbiIsInZhciBfZWxlbWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuZnVuY3Rpb24gc2V0RWxlbWVudChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQgPSAnbGVuZ3RoJyBpbiBlbCA/IGVsWzBdIDogZWw7XG4gIH1cbiAgX2VsZW1lbnQgPSBlbGVtZW50IHx8IF9lbGVtZW50O1xufVxuXG5mdW5jdGlvbiBoaWRlKGFwcEVsZW1lbnQpIHtcbiAgdmFsaWRhdGVFbGVtZW50KGFwcEVsZW1lbnQpO1xuICAoYXBwRWxlbWVudCB8fCBfZWxlbWVudCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG59XG5cbmZ1bmN0aW9uIHNob3coYXBwRWxlbWVudCkge1xuICB2YWxpZGF0ZUVsZW1lbnQoYXBwRWxlbWVudCk7XG4gIChhcHBFbGVtZW50IHx8IF9lbGVtZW50KS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZShzaG91bGRIaWRlLCBhcHBFbGVtZW50KSB7XG4gIGlmIChzaG91bGRIaWRlKVxuICAgIGhpZGUoYXBwRWxlbWVudCk7XG4gIGVsc2VcbiAgICBzaG93KGFwcEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVsZW1lbnQoYXBwRWxlbWVudCkge1xuICBpZiAoIWFwcEVsZW1lbnQgJiYgIV9lbGVtZW50KVxuICAgIHRocm93IG5ldyBFcnJvcigncmVhY3QtbW9kYWw6IFlvdSBtdXN0IHNldCBhbiBlbGVtZW50IHdpdGggYE1vZGFsLnNldEFwcEVsZW1lbnQoZWwpYCB0byBtYWtlIHRoaXMgYWNjZXNzaWJsZScpO1xufVxuXG5mdW5jdGlvbiByZXNldEZvclRlc3RpbmcoKSB7XG4gIF9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbn1cblxuZXhwb3J0cy50b2dnbGUgPSB0b2dnbGU7XG5leHBvcnRzLnNldEVsZW1lbnQgPSBzZXRFbGVtZW50O1xuZXhwb3J0cy5zaG93ID0gc2hvdztcbmV4cG9ydHMuaGlkZSA9IGhpZGU7XG5leHBvcnRzLnJlc2V0Rm9yVGVzdGluZyA9IHJlc2V0Rm9yVGVzdGluZztcbiIsInZhciBmaW5kVGFiYmFibGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RhYmJhYmxlJyk7XG52YXIgbW9kYWxFbGVtZW50ID0gbnVsbDtcbnZhciBmb2N1c0xhdGVyRWxlbWVudCA9IG51bGw7XG52YXIgbmVlZFRvRm9jdXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlQmx1cihldmVudCkge1xuICBuZWVkVG9Gb2N1cyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gIGlmIChuZWVkVG9Gb2N1cykge1xuICAgIG5lZWRUb0ZvY3VzID0gZmFsc2U7XG4gICAgaWYgKCFtb2RhbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbmVlZCB0byBzZWUgaG93IGpRdWVyeSBzaGltcyBkb2N1bWVudC5vbignZm9jdXNpbicpIHNvIHdlIGRvbid0IG5lZWQgdGhlXG4gICAgLy8gc2V0VGltZW91dCwgZmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgZm9jdXNpbiwgaWYgaXQgZGlkLCB3ZSBjb3VsZCBmb2N1c1xuICAgIC8vIHRoZSBlbGVtZW50IG91dHNpZGUgb2YgYSBzZXRUaW1lb3V0LiBTaWRlLWVmZmVjdCBvZiB0aGlzIGltcGxlbWVudGF0aW9uIFxuICAgIC8vIGlzIHRoYXQgdGhlIGRvY3VtZW50LmJvZHkgZ2V0cyBmb2N1cywgYW5kIHRoZW4gd2UgZm9jdXMgb3VyIGVsZW1lbnQgcmlnaHQgXG4gICAgLy8gYWZ0ZXIsIHNlZW1zIGZpbmUuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChtb2RhbEVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBlbCA9IChmaW5kVGFiYmFibGUobW9kYWxFbGVtZW50KVswXSB8fCBtb2RhbEVsZW1lbnQpO1xuICAgICAgZWwuZm9jdXMoKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5leHBvcnRzLm1hcmtGb3JGb2N1c0xhdGVyID0gZnVuY3Rpb24oKSB7XG4gIGZvY3VzTGF0ZXJFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbn07XG5cbmV4cG9ydHMucmV0dXJuRm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBmb2N1c0xhdGVyRWxlbWVudC5mb2N1cygpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKCdZb3UgdHJpZWQgdG8gcmV0dXJuIGZvY3VzIHRvICcrZm9jdXNMYXRlckVsZW1lbnQrJyBidXQgaXQgaXMgbm90IGluIHRoZSBET00gYW55bW9yZScpO1xuICB9XG4gIGZvY3VzTGF0ZXJFbGVtZW50ID0gbnVsbDtcbn07XG5cbmV4cG9ydHMuc2V0dXBTY29wZWRGb2N1cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgbW9kYWxFbGVtZW50ID0gZWxlbWVudDtcblxuICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uQmx1cicsIGhhbmRsZUJsdXIpO1xuICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbkZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICB9XG59O1xuXG5leHBvcnRzLnRlYXJkb3duU2NvcGVkRm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgbW9kYWxFbGVtZW50ID0gbnVsbDtcblxuICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXRhY2hFdmVudCgnb25CbHVyJywgaGFuZGxlQmx1cik7XG4gICAgZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uRm9jdXMnLCBoYW5kbGVGb2N1cyk7XG4gIH1cbn07XG5cblxuIiwidmFyIGZpbmRUYWJiYWJsZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGFiYmFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihub2RlLCBldmVudCkge1xuICB2YXIgdGFiYmFibGUgPSBmaW5kVGFiYmFibGUobm9kZSk7XG4gIHZhciBmaW5hbFRhYmJhYmxlID0gdGFiYmFibGVbZXZlbnQuc2hpZnRLZXkgPyAwIDogdGFiYmFibGUubGVuZ3RoIC0gMV07XG4gIHZhciBsZWF2aW5nRmluYWxUYWJiYWJsZSA9IChcbiAgICBmaW5hbFRhYmJhYmxlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8XG4gICAgLy8gaGFuZGxlIGltbWVkaWF0ZSBzaGlmdCt0YWIgYWZ0ZXIgb3BlbmluZyB3aXRoIG1vdXNlXG4gICAgbm9kZSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICApO1xuICBpZiAoIWxlYXZpbmdGaW5hbFRhYmJhYmxlKSByZXR1cm47XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHZhciB0YXJnZXQgPSB0YWJiYWJsZVtldmVudC5zaGlmdEtleSA/IHRhYmJhYmxlLmxlbmd0aCAtIDEgOiAwXTtcbiAgdGFyZ2V0LmZvY3VzKCk7XG59O1xuIiwiLyohXG4gKiBBZGFwdGVkIGZyb20galF1ZXJ5IFVJIGNvcmVcbiAqXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cblxuZnVuY3Rpb24gZm9jdXNhYmxlKGVsZW1lbnQsIGlzVGFiSW5kZXhOb3ROYU4pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdChub2RlTmFtZSkgP1xuICAgICFlbGVtZW50LmRpc2FibGVkIDpcbiAgICBcImFcIiA9PT0gbm9kZU5hbWUgP1xuICAgICAgZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOlxuICAgICAgaXNUYWJJbmRleE5vdE5hTikgJiYgdmlzaWJsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaGlkZGVuKGVsKSB7XG4gIHJldHVybiAoZWwub2Zmc2V0V2lkdGggPD0gMCAmJiBlbC5vZmZzZXRIZWlnaHQgPD0gMCkgfHxcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZSc7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoZWxlbWVudCkge1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSBicmVhaztcbiAgICBpZiAoaGlkZGVuKGVsZW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdGFiYmFibGUoZWxlbWVudCkge1xuICB2YXIgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgaWYgKHRhYkluZGV4ID09PSBudWxsKSB0YWJJbmRleCA9IHVuZGVmaW5lZDtcbiAgdmFyIGlzVGFiSW5kZXhOYU4gPSBpc05hTih0YWJJbmRleCk7XG4gIHJldHVybiAoaXNUYWJJbmRleE5hTiB8fCB0YWJJbmRleCA+PSAwKSAmJiBmb2N1c2FibGUoZWxlbWVudCwgIWlzVGFiSW5kZXhOYU4pO1xufVxuXG5mdW5jdGlvbiBmaW5kVGFiYmFibGVEZXNjZW5kYW50cyhlbGVtZW50KSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpLCAwKS5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gdGFiYmFibGUoZWwpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kVGFiYmFibGVEZXNjZW5kYW50cztcblxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvTW9kYWwnKTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHJldHVybiBuZXcgRWxlbWVudENsYXNzKG9wdHMpXG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyLCBwcm9wKSB7XG4gIGlmIChhcnIuaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKHByb3ApXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgaWYgKGFycltpXSA9PT0gcHJvcCkgcmV0dXJuIGlcbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIEVsZW1lbnRDbGFzcyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFbGVtZW50Q2xhc3MpKSByZXR1cm4gbmV3IEVsZW1lbnRDbGFzcyhvcHRzKVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICAvLyBzaW1pbGFyIGRvaW5nIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgYnV0IHdvcmtzIGluIElFOFxuICBpZiAob3B0cy5ub2RlVHlwZSkgb3B0cyA9IHtlbDogb3B0c31cblxuICB0aGlzLm9wdHMgPSBvcHRzXG4gIHRoaXMuZWwgPSBvcHRzLmVsIHx8IGRvY3VtZW50LmJvZHlcbiAgaWYgKHR5cGVvZiB0aGlzLmVsICE9PSAnb2JqZWN0JykgdGhpcy5lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5lbClcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgaWYgKGVsLmNsYXNzTmFtZSA9PT0gXCJcIikgcmV0dXJuIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgnICcpXG4gIGlmIChpbmRleE9mKGNsYXNzZXMsIGNsYXNzTmFtZSkgPiAtMSkgcmV0dXJuIGNsYXNzZXNcbiAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSlcbiAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJylcbiAgcmV0dXJuIGNsYXNzZXNcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgaWYgKGVsLmNsYXNzTmFtZSA9PT0gXCJcIikgcmV0dXJuXG4gIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KCcgJylcbiAgdmFyIGlkeCA9IGluZGV4T2YoY2xhc3NlcywgY2xhc3NOYW1lKVxuICBpZiAoaWR4ID4gLTEpIGNsYXNzZXMuc3BsaWNlKGlkeCwgMSlcbiAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJylcbiAgcmV0dXJuIGNsYXNzZXNcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVxuICByZXR1cm4gaW5kZXhPZihjbGFzc2VzLCBjbGFzc05hbWUpID4gLTFcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgaWYgKHRoaXMuaGFzKGNsYXNzTmFtZSkpIHRoaXMucmVtb3ZlKGNsYXNzTmFtZSlcbiAgZWxzZSB0aGlzLmFkZChjbGFzc05hbWUpXG59XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE1IEplZCBXYXRzb24uXG4gIEJhc2VkIG9uIGNvZGUgdGhhdCBpcyBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjYW5Vc2VET00gPSAhIShcblx0XHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdHdpbmRvdy5kb2N1bWVudCAmJlxuXHRcdHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG5cdCk7XG5cblx0dmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG5cdFx0Y2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cblx0XHRjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuXHRcdGNhblVzZUV2ZW50TGlzdGVuZXJzOlxuXHRcdFx0Y2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cblx0XHRjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlblxuXG5cdH07XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRXhlY3V0aW9uRW52aXJvbm1lbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0fVxuXG59KCkpO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlQXNzaWduID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlYXNzaWduJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCdsb2Rhc2guX2NyZWF0ZWFzc2lnbmVyJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmFzc2lnbmAgZm9yIGN1c3RvbWl6aW5nIGFzc2lnbmVkIHZhbHVlcyB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZywgbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYFxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIodmFsdWUsIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKTtcblxuICAgIGlmICgocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkgfHxcbiAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOlxuICogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBhbGlhcyBleHRlbmRcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uYXNzaWduKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiA0MCB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodmFsdWUpID8gb3RoZXIgOiB2YWx1ZTtcbiAqIH0pO1xuICpcbiAqIGRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgcmV0dXJuIGN1c3RvbWl6ZXJcbiAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG4gICAgOiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsIi8qKlxuICogbG9kYXNoIDMuMi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUNvcHkgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vjb3B5JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgPT0gbnVsbFxuICAgID8gb2JqZWN0XG4gICAgOiBiYXNlQ29weShzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnbG9kYXNoLl9iaW5kY2FsbGJhY2snKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJ2xvZGFzaC5faXNpdGVyYXRlZWNhbGwnKSxcbiAgICByZXN0UGFyYW0gPSByZXF1aXJlKCdsb2Rhc2gucmVzdHBhcmFtJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYXNzaWducyBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gYSBnaXZlblxuICogZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgYW5kIGBfLm1lcmdlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAyID8gc291cmNlc1tsZW5ndGggLSAyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG4gICAgICBsZW5ndGggLT0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicgPyB0aGlzQXJnIDogdW5kZWZpbmVkO1xuICAgICAgbGVuZ3RoIC09IChjdXN0b21pemVyID8gMSA6IDApO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmRDYWxsYmFjaztcbiIsIi8qKlxuICogbG9kYXNoIDMuMC45IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjYuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gKiB9KTtcbiAqXG4gKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgcmVzdCk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgfVxuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIGluZGV4ID0gLTE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3RQYXJhbTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjkuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIEFjY2Vzc29yID0ge1xuICBJREVOVElUWV9GTjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9LFxuXG4gIGdlbmVyYXRlQWNjZXNzb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2ZpZWxkXTtcbiAgICB9O1xuICB9LFxuXG4gIGdlbmVyYXRlT3B0aW9uVG9TdHJpbmdGb3I6IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVBY2Nlc3Nvcihwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuSURFTlRJVFlfRk47XG4gICAgfVxuICB9LFxuXG4gIHZhbHVlRm9yT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvYmplY3Rbb3B0aW9uXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcHRpb24ob2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjZXNzb3I7IiwiLyoqXG4gKiBQb2x5RmlsbHMgbWFrZSBtZSBzYWRcbiAqL1xudmFyIEtleUV2ZW50ID0gS2V5RXZlbnQgfHwge307XG5LZXlFdmVudC5ET01fVktfVVAgPSBLZXlFdmVudC5ET01fVktfVVAgfHwgMzg7XG5LZXlFdmVudC5ET01fVktfRE9XTiA9IEtleUV2ZW50LkRPTV9WS19ET1dOIHx8IDQwO1xuS2V5RXZlbnQuRE9NX1ZLX0JBQ0tfU1BBQ0UgPSBLZXlFdmVudC5ET01fVktfQkFDS19TUEFDRSB8fCA4O1xuS2V5RXZlbnQuRE9NX1ZLX1JFVFVSTiA9IEtleUV2ZW50LkRPTV9WS19SRVRVUk4gfHwgMTM7XG5LZXlFdmVudC5ET01fVktfRU5URVIgPSBLZXlFdmVudC5ET01fVktfRU5URVIgfHwgMTQ7XG5LZXlFdmVudC5ET01fVktfRVNDQVBFID0gS2V5RXZlbnQuRE9NX1ZLX0VTQ0FQRSB8fCAyNztcbktleUV2ZW50LkRPTV9WS19UQUIgPSBLZXlFdmVudC5ET01fVktfVEFCIHx8IDk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXZlbnQ7IiwidmFyIFR5cGVhaGVhZCA9IHJlcXVpcmUoJy4vdHlwZWFoZWFkJyk7XG52YXIgVG9rZW5pemVyID0gcmVxdWlyZSgnLi90b2tlbml6ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFR5cGVhaGVhZDogVHlwZWFoZWFkLFxuICBUb2tlbml6ZXI6IFRva2VuaXplclxufTsiLCJ2YXIgQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9hY2Nlc3NvcicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vdG9rZW4nKTtcbnZhciBLZXlFdmVudCA9IHJlcXVpcmUoJy4uL2tleWV2ZW50Jyk7XG52YXIgVHlwZWFoZWFkID0gcmVxdWlyZSgnLi4vdHlwZWFoZWFkJyk7XG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuZnVuY3Rpb24gX2FycmF5c0FyZURpZmZlcmVudChhcnJheTEsIGFycmF5Mikge1xuICBpZiAoYXJyYXkxLmxlbmd0aCAhPSBhcnJheTIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IGFycmF5Mi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChhcnJheTJbaV0gIT09IGFycmF5MVtpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSB0eXBlYWhlYWQgdGhhdCwgd2hlbiBhbiBvcHRpb24gaXMgc2VsZWN0ZWQsIGluc3RlYWQgb2Ygc2ltcGx5IGZpbGxpbmdcbiAqIHRoZSB0ZXh0IGVudHJ5IHdpZGdldCwgcHJlcGVuZHMgYSByZW5kZXJhYmxlIFwidG9rZW5cIiwgdGhhdCBtYXkgYmUgZGVsZXRlZFxuICogYnkgcHJlc3NpbmcgYmFja3NwYWNlIG9uIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgd2l0aCB0aGUga2V5Ym9hcmQuXG4gKi9cbnZhciBUeXBlYWhlYWRUb2tlbml6ZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVHlwZWFoZWFkVG9rZW5pemVyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBjdXN0b21DbGFzc2VzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGFsbG93Q3VzdG9tVmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGRlZmF1bHRTZWxlY3RlZDogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIGRlZmF1bHRWYWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkaXNhYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaW5wdXRQcm9wczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvblRva2VuUmVtb3ZlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5UHJlc3M6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5VXA6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG9rZW5BZGQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZmlsdGVyT3B0aW9uOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBSZWFjdC5Qcm9wVHlwZXMuZnVuY10pLFxuICAgIGRpc3BsYXlPcHRpb246IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIFJlYWN0LlByb3BUeXBlcy5mdW5jXSksXG4gICAgZm9ybUlucHV0T3B0aW9uOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBSZWFjdC5Qcm9wVHlwZXMuZnVuY10pLFxuICAgIG1heFZpc2libGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZGVmYXVsdENsYXNzTmFtZXM6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29weSB0aGlzIHRvIGF2b2lkIGluY29ycmVjdCBzaGFyaW5nXG4gICAgICAvLyBvZiBzdGF0ZSBhY3Jvc3MgaW5zdGFuY2VzIChlLmcuLCB2aWEgZ2V0RGVmYXVsdFByb3BzKCkpXG4gICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5kZWZhdWx0U2VsZWN0ZWQuc2xpY2UoMClcbiAgICB9O1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiBbXSxcbiAgICAgIGRlZmF1bHRTZWxlY3RlZDogW10sXG4gICAgICBjdXN0b21DbGFzc2VzOiB7fSxcbiAgICAgIGFsbG93Q3VzdG9tVmFsdWVzOiAwLFxuICAgICAgZGVmYXVsdFZhbHVlOiBcIlwiLFxuICAgICAgcGxhY2Vob2xkZXI6IFwiXCIsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBpbnB1dFByb3BzOiB7fSxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVzOiB0cnVlLFxuICAgICAgZmlsdGVyT3B0aW9uOiBudWxsLFxuICAgICAgZGlzcGxheU9wdGlvbjogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0sXG4gICAgICBmb3JtSW5wdXRPcHRpb246IG51bGwsXG4gICAgICBvbktleURvd246IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvbktleVByZXNzOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25LZXlVcDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgIG9uRm9jdXM6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvbkJsdXI6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvblRva2VuQWRkOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIG9uVG9rZW5SZW1vdmU6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgLy8gaWYgd2UgZ2V0IG5ldyBkZWZhdWx0UHJvcHMsIHVwZGF0ZSBzZWxlY3RlZFxuICAgIGlmIChfYXJyYXlzQXJlRGlmZmVyZW50KHRoaXMucHJvcHMuZGVmYXVsdFNlbGVjdGVkLCBuZXh0UHJvcHMuZGVmYXVsdFNlbGVjdGVkKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGVkOiBuZXh0UHJvcHMuZGVmYXVsdFNlbGVjdGVkLnNsaWNlKDApIH0pO1xuICAgIH1cbiAgfSxcblxuICBmb2N1czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVmcy50eXBlYWhlYWQuZm9jdXMoKTtcbiAgfSxcblxuICBnZXRTZWxlY3RlZFRva2VuczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkO1xuICB9LFxuXG4gIC8vIFRPRE86IFN1cHBvcnQgaW5pdGlhbGl6ZWQgdG9rZW5zXG4gIC8vXG4gIF9yZW5kZXJUb2tlbnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9rZW5DbGFzc2VzID0ge307XG4gICAgdG9rZW5DbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy50b2tlbl0gPSAhIXRoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy50b2tlbjtcbiAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lcyh0b2tlbkNsYXNzZXMpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnN0YXRlLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBkaXNwbGF5U3RyaW5nID0gQWNjZXNzb3IudmFsdWVGb3JPcHRpb24odGhpcy5wcm9wcy5kaXNwbGF5T3B0aW9uLCBzZWxlY3RlZCk7XG4gICAgICB2YXIgdmFsdWUgPSBBY2Nlc3Nvci52YWx1ZUZvck9wdGlvbih0aGlzLnByb3BzLmZvcm1JbnB1dE9wdGlvbiB8fCB0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24sIHNlbGVjdGVkKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBUb2tlbixcbiAgICAgICAgeyBrZXk6IGRpc3BsYXlTdHJpbmcsIGNsYXNzTmFtZTogY2xhc3NMaXN0LFxuICAgICAgICAgIG9uUmVtb3ZlOiB0aGlzLl9yZW1vdmVUb2tlbkZvclZhbHVlLFxuICAgICAgICAgIG9iamVjdDogc2VsZWN0ZWQsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5hbWU6IHRoaXMucHJvcHMubmFtZSB9LFxuICAgICAgICBkaXNwbGF5U3RyaW5nXG4gICAgICApO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgX2dldE9wdGlvbnNGb3JUeXBlYWhlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZXR1cm4gdGhpcy5wcm9wcy5vcHRpb25zIHdpdGhvdXQgdGhpcy5zZWxlY3RlZFxuICAgIHJldHVybiB0aGlzLnByb3BzLm9wdGlvbnM7XG4gIH0sXG5cbiAgX29uS2V5RG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IGludGVyY2VwdGluZyBiYWNrc3BhY2VzXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleUV2ZW50LkRPTV9WS19CQUNLX1NQQUNFKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmFja3NwYWNlKGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbktleURvd24oZXZlbnQpO1xuICB9LFxuXG4gIF9oYW5kbGVCYWNrc3BhY2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIE5vIHRva2Vuc1xuICAgIGlmICghdGhpcy5zdGF0ZS5zZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdG9rZW4gT05MWSB3aGVuIGJrc3AgcHJlc3NlZCBhdCBiZWdpbm5pbmcgb2YgbGluZVxuICAgIC8vIHdpdGhvdXQgYSBzZWxlY3Rpb25cbiAgICB2YXIgZW50cnkgPSB0aGlzLnJlZnMudHlwZWFoZWFkLnJlZnMuZW50cnk7XG4gICAgaWYgKGVudHJ5LnNlbGVjdGlvblN0YXJ0ID09IGVudHJ5LnNlbGVjdGlvbkVuZCAmJiBlbnRyeS5zZWxlY3Rpb25TdGFydCA9PSAwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVUb2tlbkZvclZhbHVlKHRoaXMuc3RhdGUuc2VsZWN0ZWRbdGhpcy5zdGF0ZS5zZWxlY3RlZC5sZW5ndGggLSAxXSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICBfcmVtb3ZlVG9rZW5Gb3JWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zdGF0ZS5zZWxlY3RlZC5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGVkOiB0aGlzLnN0YXRlLnNlbGVjdGVkIH0pO1xuICAgIHRoaXMucHJvcHMub25Ub2tlblJlbW92ZSh2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIF9hZGRUb2tlbkZvclZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZC5pbmRleE9mKHZhbHVlKSAhPSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNlbGVjdGVkLnB1c2godmFsdWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZDogdGhpcy5zdGF0ZS5zZWxlY3RlZCB9KTtcbiAgICB0aGlzLnJlZnMudHlwZWFoZWFkLnNldEVudHJ5VGV4dChcIlwiKTtcbiAgICB0aGlzLnByb3BzLm9uVG9rZW5BZGQodmFsdWUpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgY2xhc3Nlc1t0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMudHlwZWFoZWFkXSA9ICEhdGhpcy5wcm9wcy5jdXN0b21DbGFzc2VzLnR5cGVhaGVhZDtcbiAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lcyhjbGFzc2VzKTtcbiAgICB2YXIgdG9rZW5pemVyQ2xhc3NlcyA9IFt0aGlzLnByb3BzLmRlZmF1bHRDbGFzc05hbWVzICYmIFwidHlwZWFoZWFkLXRva2VuaXplclwiXTtcbiAgICB0b2tlbml6ZXJDbGFzc2VzW3RoaXMucHJvcHMuY2xhc3NOYW1lXSA9ICEhdGhpcy5wcm9wcy5jbGFzc05hbWU7XG4gICAgdmFyIHRva2VuaXplckNsYXNzTGlzdCA9IGNsYXNzTmFtZXModG9rZW5pemVyQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHRva2VuaXplckNsYXNzTGlzdCB9LFxuICAgICAgdGhpcy5fcmVuZGVyVG9rZW5zKCksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVhaGVhZCwgeyByZWY6ICd0eXBlYWhlYWQnLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTGlzdCxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLnByb3BzLmRpc2FibGVkLFxuICAgICAgICBpbnB1dFByb3BzOiB0aGlzLnByb3BzLmlucHV0UHJvcHMsXG4gICAgICAgIGFsbG93Q3VzdG9tVmFsdWVzOiB0aGlzLnByb3BzLmFsbG93Q3VzdG9tVmFsdWVzLFxuICAgICAgICBjdXN0b21DbGFzc2VzOiB0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMuX2dldE9wdGlvbnNGb3JUeXBlYWhlYWQoKSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgbWF4VmlzaWJsZTogdGhpcy5wcm9wcy5tYXhWaXNpYmxlLFxuICAgICAgICBvbk9wdGlvblNlbGVjdGVkOiB0aGlzLl9hZGRUb2tlbkZvclZhbHVlLFxuICAgICAgICBvbktleURvd246IHRoaXMuX29uS2V5RG93bixcbiAgICAgICAgb25LZXlQcmVzczogdGhpcy5wcm9wcy5vbktleVByZXNzLFxuICAgICAgICBvbktleVVwOiB0aGlzLnByb3BzLm9uS2V5VXAsXG4gICAgICAgIG9uRm9jdXM6IHRoaXMucHJvcHMub25Gb2N1cyxcbiAgICAgICAgb25CbHVyOiB0aGlzLnByb3BzLm9uQmx1cixcbiAgICAgICAgZGlzcGxheU9wdGlvbjogdGhpcy5wcm9wcy5kaXNwbGF5T3B0aW9uLFxuICAgICAgICBkZWZhdWx0Q2xhc3NOYW1lczogdGhpcy5wcm9wcy5kZWZhdWx0Q2xhc3NOYW1lcyxcbiAgICAgICAgZmlsdGVyT3B0aW9uOiB0aGlzLnByb3BzLmZpbHRlck9wdGlvbiB9KVxuICAgICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVhaGVhZFRva2VuaXplcjsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSByZW5kZXJpbmcgb2YgYW4gb3B0aW9uIHRoYXQgaGFzIGJlZW4gXCJzZWxlY3RlZFwiIGluIGFcbiAqIFR5cGVhaGVhZFRva2VuaXplclxuICovXG52YXIgVG9rZW4gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVG9rZW4nLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9iamVjdDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIG9uUmVtb3ZlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzKFtcInR5cGVhaGVhZC10b2tlblwiLCB0aGlzLnByb3BzLmNsYXNzTmFtZV0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgIHRoaXMuX3JlbmRlckhpZGRlbklucHV0KCksXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgdGhpcy5fcmVuZGVyQ2xvc2VCdXR0b24oKVxuICAgICk7XG4gIH0sXG5cbiAgX3JlbmRlckhpZGRlbklucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSWYgbm8gbmFtZSB3YXMgc2V0LCBkb24ndCBjcmVhdGUgYSBoaWRkZW4gaW5wdXRcbiAgICBpZiAoIXRoaXMucHJvcHMubmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICBuYW1lOiB0aGlzLnByb3BzLm5hbWUgKyAnW10nLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy5vYmplY3RcbiAgICB9KTtcbiAgfSxcblxuICBfcmVuZGVyQ2xvc2VCdXR0b246IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMub25SZW1vdmUpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdhJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndHlwZWFoZWFkLXRva2VuLWNsb3NlJywgaHJlZjogJyMnLCBvbkNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uUmVtb3ZlKHRoaXMucHJvcHMub2JqZWN0KTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LmJpbmQodGhpcykgfSxcbiAgICAgICfDlydcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjsiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9hY2Nlc3NvcicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBUeXBlYWhlYWRTZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnZhciBLZXlFdmVudCA9IHJlcXVpcmUoJy4uL2tleWV2ZW50Jyk7XG52YXIgZnV6enkgPSByZXF1aXJlKCdmdXp6eScpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbi8qKlxuICogQSBcInR5cGVhaGVhZFwiLCBhbiBhdXRvLWNvbXBsZXRpbmcgdGV4dCBpbnB1dFxuICpcbiAqIFJlbmRlcnMgYW4gdGV4dCBpbnB1dCB0aGF0IHNob3dzIG9wdGlvbnMgbmVhcmJ5IHRoYXQgeW91IGNhbiB1c2UgdGhlXG4gKiBrZXlib2FyZCBvciBtb3VzZSB0byBzZWxlY3QuICBSZXF1aXJlcyBDU1MgZm9yIE1BU1NJVkUgREFNQUdFLlxuICovXG52YXIgVHlwZWFoZWFkID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1R5cGVhaGVhZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjdXN0b21DbGFzc2VzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG1heFZpc2libGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIGFsbG93Q3VzdG9tVmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGRlZmF1bHRWYWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkaXNhYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdGV4dGFyZWE6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGlucHV0UHJvcHM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb25PcHRpb25TZWxlY3RlZDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25LZXlQcmVzczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25LZXlVcDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25CbHVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBmaWx0ZXJPcHRpb246IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIFJlYWN0LlByb3BUeXBlcy5mdW5jXSksXG4gICAgZGlzcGxheU9wdGlvbjogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBmb3JtSW5wdXRPcHRpb246IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIFJlYWN0LlByb3BUeXBlcy5mdW5jXSksXG4gICAgZGVmYXVsdENsYXNzTmFtZXM6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGN1c3RvbUxpc3RDb21wb25lbnQ6IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5lbGVtZW50LCBSZWFjdC5Qcm9wVHlwZXMuZnVuY10pLFxuICAgIHNob3dPcHRpb25zV2hlbkVtcHR5OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiBbXSxcbiAgICAgIGN1c3RvbUNsYXNzZXM6IHt9LFxuICAgICAgYWxsb3dDdXN0b21WYWx1ZXM6IDAsXG4gICAgICBkZWZhdWx0VmFsdWU6IFwiXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHBsYWNlaG9sZGVyOiBcIlwiLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdGV4dGFyZWE6IGZhbHNlLFxuICAgICAgaW5wdXRQcm9wczoge30sXG4gICAgICBvbk9wdGlvblNlbGVjdGVkOiBmdW5jdGlvbiAob3B0aW9uKSB7fSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25LZXlQcmVzczogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgIG9uS2V5VXA6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvbkZvY3VzOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25CbHVyOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgZmlsdGVyT3B0aW9uOiBudWxsLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZXM6IHRydWUsXG4gICAgICBjdXN0b21MaXN0Q29tcG9uZW50OiBUeXBlYWhlYWRTZWxlY3RvcixcbiAgICAgIHNob3dPcHRpb25zV2hlbkVtcHR5OiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50bHkgdmlzaWJsZSBzZXQgb2Ygb3B0aW9uc1xuICAgICAgdmlzaWJsZTogdGhpcy5nZXRPcHRpb25zRm9yVmFsdWUodGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUsIHRoaXMucHJvcHMub3B0aW9ucyksXG5cbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBzb21ldGhpbmcgZWxzZSwgXCJlbnRyeVZhbHVlXCJcbiAgICAgIGVudHJ5VmFsdWU6IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUsXG5cbiAgICAgIC8vIEEgdmFsaWQgdHlwZWFoZWFkIHZhbHVlXG4gICAgICBzZWxlY3Rpb246IHRoaXMucHJvcHMudmFsdWUsXG5cbiAgICAgIC8vIEluZGV4IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgIHNlbGVjdGlvbkluZGV4OiBudWxsXG4gICAgfTtcbiAgfSxcblxuICBfc2hvdWxkU2tpcFNlYXJjaDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGVtcHR5VmFsdWUgPSAhaW5wdXQgfHwgaW5wdXQudHJpbSgpLmxlbmd0aCA9PSAwO1xuICAgIHJldHVybiAhdGhpcy5wcm9wcy5zaG93T3B0aW9uc1doZW5FbXB0eSAmJiBlbXB0eVZhbHVlO1xuICB9LFxuXG4gIGdldE9wdGlvbnNGb3JWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFNraXBTZWFyY2godmFsdWUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlck9wdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZUZpbHRlckZ1bmN0aW9uKCk7XG4gICAgdmFyIHJlc3VsdCA9IGZpbHRlck9wdGlvbnModmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnByb3BzLm1heFZpc2libGUpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCB0aGlzLnByb3BzLm1heFZpc2libGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIHNldEVudHJ5VGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5yZWZzLmVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fb25UZXh0RW50cnlVcGRhdGVkKCk7XG4gIH0sXG5cbiAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlZnMuZW50cnkuZm9jdXMoKTtcbiAgfSxcblxuICBfaGFzQ3VzdG9tVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5hbGxvd0N1c3RvbVZhbHVlcyA+IDAgJiYgdGhpcy5zdGF0ZS5lbnRyeVZhbHVlLmxlbmd0aCA+PSB0aGlzLnByb3BzLmFsbG93Q3VzdG9tVmFsdWVzICYmIHRoaXMuc3RhdGUudmlzaWJsZS5pbmRleE9mKHRoaXMuc3RhdGUuZW50cnlWYWx1ZSkgPCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIF9nZXRDdXN0b21WYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9oYXNDdXN0b21WYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5lbnRyeVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBfcmVuZGVySW5jcmVtZW50YWxTZWFyY2hSZXN1bHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90aGluZyBoYXMgYmVlbiBlbnRlcmVkIGludG8gdGhlIHRleHRib3hcbiAgICBpZiAodGhpcy5fc2hvdWxkU2tpcFNlYXJjaCh0aGlzLnN0YXRlLmVudHJ5VmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICAvLyBTb21ldGhpbmcgd2FzIGp1c3Qgc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY3VzdG9tTGlzdENvbXBvbmVudCwge1xuICAgICAgcmVmOiAnc2VsJywgb3B0aW9uczogdGhpcy5zdGF0ZS52aXNpYmxlLFxuICAgICAgb25PcHRpb25TZWxlY3RlZDogdGhpcy5fb25PcHRpb25TZWxlY3RlZCxcbiAgICAgIGFsbG93Q3VzdG9tVmFsdWVzOiB0aGlzLnByb3BzLmFsbG93Q3VzdG9tVmFsdWVzLFxuICAgICAgY3VzdG9tVmFsdWU6IHRoaXMuX2dldEN1c3RvbVZhbHVlKCksXG4gICAgICBjdXN0b21DbGFzc2VzOiB0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMsXG4gICAgICBzZWxlY3Rpb25JbmRleDogdGhpcy5zdGF0ZS5zZWxlY3Rpb25JbmRleCxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVzOiB0aGlzLnByb3BzLmRlZmF1bHRDbGFzc05hbWVzLFxuICAgICAgZGlzcGxheU9wdGlvbjogQWNjZXNzb3IuZ2VuZXJhdGVPcHRpb25Ub1N0cmluZ0Zvcih0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24pIH0pO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uSW5kZXg7XG4gICAgaWYgKHRoaXMuX2hhc0N1c3RvbVZhbHVlKCkpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5lbnRyeVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudmlzaWJsZVtpbmRleF07XG4gIH0sXG5cbiAgX29uT3B0aW9uU2VsZWN0ZWQ6IGZ1bmN0aW9uIChvcHRpb24sIGV2ZW50KSB7XG4gICAgdmFyIG5FbnRyeSA9IHRoaXMucmVmcy5lbnRyeTtcbiAgICBuRW50cnkuZm9jdXMoKTtcblxuICAgIHZhciBkaXNwbGF5T3B0aW9uID0gQWNjZXNzb3IuZ2VuZXJhdGVPcHRpb25Ub1N0cmluZ0Zvcih0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24pO1xuICAgIHZhciBvcHRpb25TdHJpbmcgPSBkaXNwbGF5T3B0aW9uKG9wdGlvbiwgMCk7XG5cbiAgICB2YXIgZm9ybUlucHV0T3B0aW9uID0gQWNjZXNzb3IuZ2VuZXJhdGVPcHRpb25Ub1N0cmluZ0Zvcih0aGlzLnByb3BzLmZvcm1JbnB1dE9wdGlvbiB8fCBkaXNwbGF5T3B0aW9uKTtcbiAgICB2YXIgZm9ybUlucHV0T3B0aW9uU3RyaW5nID0gZm9ybUlucHV0T3B0aW9uKG9wdGlvbik7XG5cbiAgICBuRW50cnkudmFsdWUgPSBvcHRpb25TdHJpbmc7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZpc2libGU6IHRoaXMuZ2V0T3B0aW9uc0ZvclZhbHVlKG9wdGlvblN0cmluZywgdGhpcy5wcm9wcy5vcHRpb25zKSxcbiAgICAgIHNlbGVjdGlvbjogZm9ybUlucHV0T3B0aW9uU3RyaW5nLFxuICAgICAgZW50cnlWYWx1ZTogb3B0aW9uU3RyaW5nIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9uT3B0aW9uU2VsZWN0ZWQob3B0aW9uLCBldmVudCk7XG4gIH0sXG5cbiAgX29uVGV4dEVudHJ5VXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMucmVmcy5lbnRyeS52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmlzaWJsZTogdGhpcy5nZXRPcHRpb25zRm9yVmFsdWUodmFsdWUsIHRoaXMucHJvcHMub3B0aW9ucyksXG4gICAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgICBlbnRyeVZhbHVlOiB2YWx1ZSB9KTtcbiAgfSxcblxuICBfb25FbnRlcjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uS2V5RG93bihldmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vbk9wdGlvblNlbGVjdGVkKHNlbGVjdGlvbiwgZXZlbnQpO1xuICB9LFxuXG4gIF9vbkVzY2FwZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VsZWN0aW9uSW5kZXg6IG51bGxcbiAgICB9KTtcbiAgfSxcblxuICBfb25UYWI6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIHZhciBvcHRpb24gPSBzZWxlY3Rpb24gPyBzZWxlY3Rpb24gOiB0aGlzLnN0YXRlLnZpc2libGUubGVuZ3RoID4gMCA/IHRoaXMuc3RhdGUudmlzaWJsZVswXSA6IG51bGw7XG5cbiAgICBpZiAob3B0aW9uID09PSBudWxsICYmIHRoaXMuX2hhc0N1c3RvbVZhbHVlKCkpIHtcbiAgICAgIG9wdGlvbiA9IHRoaXMuX2dldEN1c3RvbVZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uT3B0aW9uU2VsZWN0ZWQob3B0aW9uLCBldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGV2ZW50TWFwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzID0ge307XG5cbiAgICBldmVudHNbS2V5RXZlbnQuRE9NX1ZLX1VQXSA9IHRoaXMubmF2VXA7XG4gICAgZXZlbnRzW0tleUV2ZW50LkRPTV9WS19ET1dOXSA9IHRoaXMubmF2RG93bjtcbiAgICBldmVudHNbS2V5RXZlbnQuRE9NX1ZLX1JFVFVSTl0gPSBldmVudHNbS2V5RXZlbnQuRE9NX1ZLX0VOVEVSXSA9IHRoaXMuX29uRW50ZXI7XG4gICAgZXZlbnRzW0tleUV2ZW50LkRPTV9WS19FU0NBUEVdID0gdGhpcy5fb25Fc2NhcGU7XG4gICAgZXZlbnRzW0tleUV2ZW50LkRPTV9WS19UQUJdID0gdGhpcy5fb25UYWI7XG5cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIF9uYXY6IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgIGlmICghdGhpcy5faGFzSGludCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdJbmRleCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uSW5kZXggPT09IG51bGwgPyBkZWx0YSA9PSAxID8gMCA6IGRlbHRhIDogdGhpcy5zdGF0ZS5zZWxlY3Rpb25JbmRleCArIGRlbHRhO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnN0YXRlLnZpc2libGUubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9oYXNDdXN0b21WYWx1ZSgpKSB7XG4gICAgICBsZW5ndGggKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmV3SW5kZXggPCAwKSB7XG4gICAgICBuZXdJbmRleCArPSBsZW5ndGg7XG4gICAgfSBlbHNlIGlmIChuZXdJbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgIG5ld0luZGV4IC09IGxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgc2VsZWN0aW9uSW5kZXg6IG5ld0luZGV4IH0pO1xuICB9LFxuXG4gIG5hdkRvd246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uYXYoMSk7XG4gIH0sXG5cbiAgbmF2VXA6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uYXYoLTEpO1xuICB9LFxuXG4gIF9vbkNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX29uVGV4dEVudHJ5VXBkYXRlZCgpO1xuICB9LFxuXG4gIF9vbktleURvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyB2aXNpYmxlIGVsZW1lbnRzLCBkb24ndCBwZXJmb3JtIHNlbGVjdG9yIG5hdmlnYXRpb24uXG4gICAgLy8gSnVzdCBwYXNzIHRoaXMgdXAgdG8gdGhlIHVwc3RyZWFtIG9uS2V5ZG93biBoYW5kbGVyLlxuICAgIC8vIEFsc28gc2tpcCBpZiB0aGUgdXNlciBpcyBwcmVzc2luZyB0aGUgc2hpZnQga2V5LCBzaW5jZSBub25lIG9mIG91ciBoYW5kbGVycyBhcmUgbG9va2luZyBmb3Igc2hpZnRcbiAgICBpZiAoIXRoaXMuX2hhc0hpbnQoKSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25LZXlEb3duKGV2ZW50KTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRNYXAoKVtldmVudC5rZXlDb2RlXTtcblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25LZXlEb3duKGV2ZW50KTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgcHJvcGFnYXRlIHRoZSBrZXlzdHJva2UgYmFjayB0byB0aGUgRE9NL2Jyb3dzZXJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZpc2libGU6IHRoaXMuZ2V0T3B0aW9uc0ZvclZhbHVlKHRoaXMuc3RhdGUuZW50cnlWYWx1ZSwgbmV4dFByb3BzLm9wdGlvbnMpXG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0Q2xhc3NlcyA9IHt9O1xuICAgIGlucHV0Q2xhc3Nlc1t0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuaW5wdXRdID0gISF0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuaW5wdXQ7XG4gICAgdmFyIGlucHV0Q2xhc3NMaXN0ID0gY2xhc3NOYW1lcyhpbnB1dENsYXNzZXMpO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICB0eXBlYWhlYWQ6IHRoaXMucHJvcHMuZGVmYXVsdENsYXNzTmFtZXNcbiAgICB9O1xuICAgIGNsYXNzZXNbdGhpcy5wcm9wcy5jbGFzc05hbWVdID0gISF0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lcyhjbGFzc2VzKTtcblxuICAgIHZhciBJbnB1dEVsZW1lbnQgPSB0aGlzLnByb3BzLnRleHRhcmVhID8gJ3RleHRhcmVhJyA6ICdpbnB1dCc7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTGlzdCB9LFxuICAgICAgdGhpcy5fcmVuZGVySGlkZGVuSW5wdXQoKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRFbGVtZW50LCBfZXh0ZW5kcyh7IHJlZjogJ2VudHJ5JywgdHlwZTogJ3RleHQnLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy5wcm9wcy5kaXNhYmxlZFxuICAgICAgfSwgdGhpcy5wcm9wcy5pbnB1dFByb3BzLCB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnByb3BzLnBsYWNlaG9sZGVyLFxuICAgICAgICBjbGFzc05hbWU6IGlucHV0Q2xhc3NMaXN0LFxuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lbnRyeVZhbHVlLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5fb25DaGFuZ2UsXG4gICAgICAgIG9uS2V5RG93bjogdGhpcy5fb25LZXlEb3duLFxuICAgICAgICBvbktleVByZXNzOiB0aGlzLnByb3BzLm9uS2V5UHJlc3MsXG4gICAgICAgIG9uS2V5VXA6IHRoaXMucHJvcHMub25LZXlVcCxcbiAgICAgICAgb25Gb2N1czogdGhpcy5wcm9wcy5vbkZvY3VzLFxuICAgICAgICBvbkJsdXI6IHRoaXMucHJvcHMub25CbHVyXG4gICAgICB9KSksXG4gICAgICB0aGlzLl9yZW5kZXJJbmNyZW1lbnRhbFNlYXJjaFJlc3VsdHMoKVxuICAgICk7XG4gIH0sXG5cbiAgX3JlbmRlckhpZGRlbklucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLm5hbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgIHR5cGU6ICdoaWRkZW4nLFxuICAgICAgbmFtZTogdGhpcy5wcm9wcy5uYW1lLFxuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgfSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlRmlsdGVyRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsdGVyT3B0aW9uUHJvcCA9IHRoaXMucHJvcHMuZmlsdGVyT3B0aW9uO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyT3B0aW9uUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyT3B0aW9uUHJvcCh2YWx1ZSwgbyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcHBlcjtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyT3B0aW9uUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFwcGVyID0gQWNjZXNzb3IuZ2VuZXJhdGVBY2Nlc3NvcihmaWx0ZXJPcHRpb25Qcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlciA9IEFjY2Vzc29yLklERU5USVRZX0ZOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZnV6enkuZmlsdGVyKHZhbHVlLCBvcHRpb25zLCB7IGV4dHJhY3Q6IG1hcHBlciB9KS5tYXAoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zW3Jlcy5pbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhc0hpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS52aXNpYmxlLmxlbmd0aCA+IDAgfHwgdGhpcy5faGFzQ3VzdG9tVmFsdWUoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkOyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuLyoqXG4gKiBBIHNpbmdsZSBvcHRpb24gd2l0aGluIHRoZSBUeXBlYWhlYWRTZWxlY3RvclxuICovXG52YXIgVHlwZWFoZWFkT3B0aW9uID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1R5cGVhaGVhZE9wdGlvbicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY3VzdG9tQ2xhc3NlczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjdXN0b21WYWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNsaWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjaGlsZHJlbjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBob3ZlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VzdG9tQ2xhc3Nlczoge30sXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgY2xhc3Nlc1t0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuaG92ZXIgfHwgXCJob3ZlclwiXSA9ICEhdGhpcy5wcm9wcy5ob3ZlcjtcbiAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5saXN0SXRlbV0gPSAhIXRoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5saXN0SXRlbTtcblxuICAgIGlmICh0aGlzLnByb3BzLmN1c3RvbVZhbHVlKSB7XG4gICAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5jdXN0b21BZGRdID0gISF0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuY3VzdG9tQWRkO1xuICAgIH1cblxuICAgIHZhciBjbGFzc0xpc3QgPSBjbGFzc05hbWVzKGNsYXNzZXMpO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTGlzdCwgb25DbGljazogdGhpcy5fb25DbGljayB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2EnLFxuICAgICAgICB7IGhyZWY6ICdqYXZhc2NyaXB0OiB2b2lkIDA7JywgY2xhc3NOYW1lOiB0aGlzLl9nZXRDbGFzc2VzKCksIHJlZjogJ2FuY2hvcicgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgKVxuICAgICk7XG4gIH0sXG5cbiAgX2dldENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHtcbiAgICAgIFwidHlwZWFoZWFkLW9wdGlvblwiOiB0cnVlXG4gICAgfTtcbiAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5saXN0QW5jaG9yXSA9ICEhdGhpcy5wcm9wcy5jdXN0b21DbGFzc2VzLmxpc3RBbmNob3I7XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lcyhjbGFzc2VzKTtcbiAgfSxcblxuICBfb25DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkT3B0aW9uOyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgVHlwZWFoZWFkT3B0aW9uID0gcmVxdWlyZSgnLi9vcHRpb24nKTtcbnZhciBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgYXV0b2NvbXBsZXRpb24gcHJvY2Vzc1xuICogb2YgdGhlIHR5cGVhaGVhZFxuICovXG52YXIgVHlwZWFoZWFkU2VsZWN0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVHlwZWFoZWFkU2VsZWN0b3InLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBhbGxvd0N1c3RvbVZhbHVlczogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBjdXN0b21DbGFzc2VzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGN1c3RvbVZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNlbGVjdGlvbkluZGV4OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG9uT3B0aW9uU2VsZWN0ZWQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRpc3BsYXlPcHRpb246IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZGVmYXVsdENsYXNzTmFtZXM6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdGlvbkluZGV4OiBudWxsLFxuICAgICAgY3VzdG9tQ2xhc3Nlczoge30sXG4gICAgICBhbGxvd0N1c3RvbVZhbHVlczogMCxcbiAgICAgIGN1c3RvbVZhbHVlOiBudWxsLFxuICAgICAgb25PcHRpb25TZWxlY3RlZDogZnVuY3Rpb24gKG9wdGlvbikge30sXG4gICAgICBkZWZhdWx0Q2xhc3NOYW1lczogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG9uJ3QgcmVuZGVyIGlmIHRoZXJlIGFyZSBubyBvcHRpb25zIHRvIGRpc3BsYXlcbiAgICBpZiAoIXRoaXMucHJvcHMub3B0aW9ucy5sZW5ndGggJiYgdGhpcy5wcm9wcy5hbGxvd0N1c3RvbVZhbHVlcyA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICBcInR5cGVhaGVhZC1zZWxlY3RvclwiOiB0aGlzLnByb3BzLmRlZmF1bHRDbGFzc05hbWVzXG4gICAgfTtcbiAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5yZXN1bHRzXSA9IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5yZXN1bHRzO1xuICAgIHZhciBjbGFzc0xpc3QgPSBjbGFzc05hbWVzKGNsYXNzZXMpO1xuXG4gICAgLy8gQ3VzdG9tVmFsdWUgc2hvdWxkIGJlIGFkZGVkIHRvIHRvcCBvZiByZXN1bHRzIGxpc3Qgd2l0aCBkaWZmZXJlbnQgY2xhc3MgbmFtZVxuICAgIHZhciBjdXN0b21WYWx1ZSA9IG51bGw7XG4gICAgdmFyIGN1c3RvbVZhbHVlT2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy5wcm9wcy5jdXN0b21WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY3VzdG9tVmFsdWVPZmZzZXQrKztcbiAgICAgIGN1c3RvbVZhbHVlID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgVHlwZWFoZWFkT3B0aW9uLFxuICAgICAgICB7IHJlZjogdGhpcy5wcm9wcy5jdXN0b21WYWx1ZSwga2V5OiB0aGlzLnByb3BzLmN1c3RvbVZhbHVlLFxuICAgICAgICAgIGhvdmVyOiB0aGlzLnByb3BzLnNlbGVjdGlvbkluZGV4ID09PSAwLFxuICAgICAgICAgIGN1c3RvbUNsYXNzZXM6IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3NlcyxcbiAgICAgICAgICBjdXN0b21WYWx1ZTogdGhpcy5wcm9wcy5jdXN0b21WYWx1ZSxcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcywgdGhpcy5wcm9wcy5jdXN0b21WYWx1ZSkgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jdXN0b21WYWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IHRoaXMucHJvcHMub3B0aW9ucy5tYXAoZnVuY3Rpb24gKHJlc3VsdCwgaSkge1xuICAgICAgdmFyIGRpc3BsYXlTdHJpbmcgPSB0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24ocmVzdWx0LCBpKTtcbiAgICAgIHZhciB1bmlxdWVLZXkgPSBkaXNwbGF5U3RyaW5nICsgJ18nICsgaTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBUeXBlYWhlYWRPcHRpb24sXG4gICAgICAgIHsgcmVmOiB1bmlxdWVLZXksIGtleTogdW5pcXVlS2V5LFxuICAgICAgICAgIGhvdmVyOiB0aGlzLnByb3BzLnNlbGVjdGlvbkluZGV4ID09PSBpICsgY3VzdG9tVmFsdWVPZmZzZXQsXG4gICAgICAgICAgY3VzdG9tQ2xhc3NlczogdGhpcy5wcm9wcy5jdXN0b21DbGFzc2VzLFxuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzLCByZXN1bHQpIH0sXG4gICAgICAgIGRpc3BsYXlTdHJpbmdcbiAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICd1bCcsXG4gICAgICB7IGNsYXNzTmFtZTogY2xhc3NMaXN0IH0sXG4gICAgICBjdXN0b21WYWx1ZSxcbiAgICAgIHJlc3VsdHNcbiAgICApO1xuICB9LFxuXG4gIF9vbkNsaWNrOiBmdW5jdGlvbiAocmVzdWx0LCBldmVudCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9uT3B0aW9uU2VsZWN0ZWQocmVzdWx0LCBldmVudCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkU2VsZWN0b3I7IiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNSBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuXG5mdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuXHR2YXIgY2xhc3NlcyA9ICcnO1xuXHR2YXIgYXJnO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdGlmICghYXJnKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBhcmcgfHwgJ251bWJlcicgPT09IHR5cGVvZiBhcmcpIHtcblx0XHRcdGNsYXNzZXMgKz0gJyAnICsgYXJnO1xuXHRcdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0XHRcdGNsYXNzZXMgKz0gJyAnICsgY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBhcmcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0aWYgKCFhcmcuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAhYXJnW2tleV0pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGFzc2VzICs9ICcgJyArIGtleTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGNsYXNzZXMuc3Vic3RyKDEpO1xufVxuXG4vLyBzYWZlbHkgZXhwb3J0IGNsYXNzTmFtZXMgZm9yIG5vZGUgLyBicm93c2VyaWZ5XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xufVxuXG4vLyBzYWZlbHkgZXhwb3J0IGNsYXNzTmFtZXMgZm9yIFJlcXVpcmVKU1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHR9KTtcbn1cbiIsIi8qXG4gKiBGdXp6eVxuICogaHR0cHM6Ly9naXRodWIuY29tL215b3JrL2Z1enp5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE1hdHQgWW9ya1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbihmdW5jdGlvbigpIHtcblxudmFyIHJvb3QgPSB0aGlzO1xuXG52YXIgZnV6enkgPSB7fTtcblxuLy8gVXNlIGluIG5vZGUgb3IgaW4gYnJvd3NlclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1enp5O1xufSBlbHNlIHtcbiAgcm9vdC5mdXp6eSA9IGZ1enp5O1xufVxuXG4vLyBSZXR1cm4gYWxsIGVsZW1lbnRzIG9mIGBhcnJheWAgdGhhdCBoYXZlIGEgZnV6enlcbi8vIG1hdGNoIGFnYWluc3QgYHBhdHRlcm5gLlxuZnV6enkuc2ltcGxlRmlsdGVyID0gZnVuY3Rpb24ocGF0dGVybiwgYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gZnV6enkudGVzdChwYXR0ZXJuLCBzdHJpbmcpO1xuICB9KTtcbn07XG5cbi8vIERvZXMgYHBhdHRlcm5gIGZ1enp5IG1hdGNoIGBzdHJpbmdgP1xuZnV6enkudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0cmluZykge1xuICByZXR1cm4gZnV6enkubWF0Y2gocGF0dGVybiwgc3RyaW5nKSAhPT0gbnVsbDtcbn07XG5cbi8vIElmIGBwYXR0ZXJuYCBtYXRjaGVzIGBzdHJpbmdgLCB3cmFwIGVhY2ggbWF0Y2hpbmcgY2hhcmFjdGVyXG4vLyBpbiBgb3B0cy5wcmVgIGFuZCBgb3B0cy5wb3N0YC4gSWYgbm8gbWF0Y2gsIHJldHVybiBudWxsXG5mdXp6eS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0cmluZywgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHBhdHRlcm5JZHggPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgbGVuID0gc3RyaW5nLmxlbmd0aFxuICAgICwgdG90YWxTY29yZSA9IDBcbiAgICAsIGN1cnJTY29yZSA9IDBcbiAgICAvLyBwcmVmaXhcbiAgICAsIHByZSA9IG9wdHMucHJlIHx8ICcnXG4gICAgLy8gc3VmZml4XG4gICAgLCBwb3N0ID0gb3B0cy5wb3N0IHx8ICcnXG4gICAgLy8gU3RyaW5nIHRvIGNvbXBhcmUgYWdhaW5zdC4gVGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSB2ZXJzaW9uIG9mIHRoZVxuICAgIC8vIHJhdyBzdHJpbmdcbiAgICAsIGNvbXBhcmVTdHJpbmcgPSAgb3B0cy5jYXNlU2Vuc2l0aXZlICYmIHN0cmluZyB8fCBzdHJpbmcudG9Mb3dlckNhc2UoKVxuICAgICwgY2gsIGNvbXBhcmVDaGFyO1xuXG4gIHBhdHRlcm4gPSBvcHRzLmNhc2VTZW5zaXRpdmUgJiYgcGF0dGVybiB8fCBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gRm9yIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcsIGVpdGhlciBhZGQgaXQgdG8gdGhlIHJlc3VsdFxuICAvLyBvciB3cmFwIGluIHRlbXBsYXRlIGlmIGl0J3MgdGhlIG5leHQgc3RyaW5nIGluIHRoZSBwYXR0ZXJuXG4gIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIGNoID0gc3RyaW5nW2lkeF07XG4gICAgaWYoY29tcGFyZVN0cmluZ1tpZHhdID09PSBwYXR0ZXJuW3BhdHRlcm5JZHhdKSB7XG4gICAgICBjaCA9IHByZSArIGNoICsgcG9zdDtcbiAgICAgIHBhdHRlcm5JZHggKz0gMTtcblxuICAgICAgLy8gY29uc2VjdXRpdmUgY2hhcmFjdGVycyBzaG91bGQgaW5jcmVhc2UgdGhlIHNjb3JlIG1vcmUgdGhhbiBsaW5lYXJseVxuICAgICAgY3VyclNjb3JlICs9IDEgKyBjdXJyU2NvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJTY29yZSA9IDA7XG4gICAgfVxuICAgIHRvdGFsU2NvcmUgKz0gY3VyclNjb3JlO1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGNoO1xuICB9XG5cbiAgLy8gcmV0dXJuIHJlbmRlcmVkIHN0cmluZyBpZiB3ZSBoYXZlIGEgbWF0Y2ggZm9yIGV2ZXJ5IGNoYXJcbiAgaWYocGF0dGVybklkeCA9PT0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge3JlbmRlcmVkOiByZXN1bHQuam9pbignJyksIHNjb3JlOiB0b3RhbFNjb3JlfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gVGhlIG5vcm1hbCBlbnRyeSBwb2ludC4gRmlsdGVycyBgYXJyYCBmb3IgbWF0Y2hlcyBhZ2FpbnN0IGBwYXR0ZXJuYC5cbi8vIEl0IHJldHVybnMgYW4gYXJyYXkgd2l0aCBtYXRjaGluZyB2YWx1ZXMgb2YgdGhlIHR5cGU6XG4vL1xuLy8gICAgIFt7XG4vLyAgICAgICAgIHN0cmluZzogICAnPGI+bGFoJyAvLyBUaGUgcmVuZGVyZWQgc3RyaW5nXG4vLyAgICAgICAsIGluZGV4OiAgICAyICAgICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gYGFycmBcbi8vICAgICAgICwgb3JpZ2luYWw6ICdibGFoJyAgIC8vIFRoZSBvcmlnaW5hbCBlbGVtZW50IGluIGBhcnJgXG4vLyAgICAgfV1cbi8vXG4vLyBgb3B0c2AgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgYmFnLiBEZXRhaWxzOlxuLy9cbi8vICAgIG9wdHMgPSB7XG4vLyAgICAgICAgLy8gc3RyaW5nIHRvIHB1dCBiZWZvcmUgYSBtYXRjaGluZyBjaGFyYWN0ZXJcbi8vICAgICAgICBwcmU6ICAgICAnPGI+J1xuLy9cbi8vICAgICAgICAvLyBzdHJpbmcgdG8gcHV0IGFmdGVyIG1hdGNoaW5nIGNoYXJhY3RlclxuLy8gICAgICAsIHBvc3Q6ICAgICc8L2I+J1xuLy9cbi8vICAgICAgICAvLyBPcHRpb25hbCBmdW5jdGlvbi4gSW5wdXQgaXMgYW4gZW50cnkgaW4gdGhlIGdpdmVuIGFycmAsXG4vLyAgICAgICAgLy8gb3V0cHV0IHNob3VsZCBiZSB0aGUgc3RyaW5nIHRvIHRlc3QgYHBhdHRlcm5gIGFnYWluc3QuXG4vLyAgICAgICAgLy8gSW4gdGhpcyBleGFtcGxlLCBpZiBgYXJyID0gW3tjcnlpbmc6ICdrb2FsYSd9XWAgd2Ugd291bGQgcmV0dXJuXG4vLyAgICAgICAgLy8gJ2tvYWxhJy5cbi8vICAgICAgLCBleHRyYWN0OiBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZy5jcnlpbmc7IH1cbi8vICAgIH1cbmZ1enp5LmZpbHRlciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGFyciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgcmV0dXJuIGFyclxuICAgIC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgZWxlbWVudCwgaWR4LCBhcnIpIHtcbiAgICAgIHZhciBzdHIgPSBlbGVtZW50O1xuICAgICAgaWYob3B0cy5leHRyYWN0KSB7XG4gICAgICAgIHN0ciA9IG9wdHMuZXh0cmFjdChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciByZW5kZXJlZCA9IGZ1enp5Lm1hdGNoKHBhdHRlcm4sIHN0ciwgb3B0cyk7XG4gICAgICBpZihyZW5kZXJlZCAhPSBudWxsKSB7XG4gICAgICAgIHByZXZbcHJldi5sZW5ndGhdID0ge1xuICAgICAgICAgICAgc3RyaW5nOiByZW5kZXJlZC5yZW5kZXJlZFxuICAgICAgICAgICwgc2NvcmU6IHJlbmRlcmVkLnNjb3JlXG4gICAgICAgICAgLCBpbmRleDogaWR4XG4gICAgICAgICAgLCBvcmlnaW5hbDogZWxlbWVudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgW10pXG5cbiAgICAvLyBTb3J0IGJ5IHNjb3JlLiBCcm93c2VycyBhcmUgaW5jb25zaXN0ZW50IHdydCBzdGFibGUvdW5zdGFibGVcbiAgICAvLyBzb3J0aW5nLCBzbyBmb3JjZSBzdGFibGUgYnkgdXNpbmcgdGhlIGluZGV4IGluIHRoZSBjYXNlIG9mIHRpZS5cbiAgICAvLyBTZWUgaHR0cDovL29mYi5uZXQvfnNldGhtbC9pcy1zb3J0LXN0YWJsZS5odG1sXG4gICAgLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgICB2YXIgY29tcGFyZSA9IGIuc2NvcmUgLSBhLnNjb3JlO1xuICAgICAgaWYoY29tcGFyZSkgcmV0dXJuIGNvbXBhcmU7XG4gICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgfSk7XG59O1xuXG5cbn0oKSk7XG5cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8vaW1wb3J0IFwiYmFiZWwtcG9seWZpbGxcIjtcblxuLy8gc3RvcmVzXG5pbXBvcnQgQXJlYURlc2NyaXB0aW9uc1N0b3JlIGZyb20gJy4vc3RvcmVzL0FyZWFEZXNjcmlwdGlvbnNTdG9yZSc7XG5pbXBvcnQgQ2l0eVN0b3JlIGZyb20gJy4vc3RvcmVzL0NpdHlTdG9yZSc7XG5pbXBvcnQgRGltZW5zaW9uc1N0b3JlIGZyb20gJy4vc3RvcmVzL0RpbWVuc2lvbnNTdG9yZSc7XG5pbXBvcnQgTWFwU3RhdGVTdG9yZSBmcm9tICcuL3N0b3Jlcy9NYXBTdGF0ZVN0b3JlJztcbmltcG9ydCBSYXN0ZXJTdG9yZSBmcm9tICcuL3N0b3Jlcy9SYXN0ZXJTdG9yZSc7XG5pbXBvcnQgVXNlckxvY2F0aW9uU3RvcmUgZnJvbSAnLi9zdG9yZXMvVXNlckxvY2F0aW9uU3RvcmUnO1xuaW1wb3J0IFRleHRzU3RvcmUgZnJvbSAnLi9zdG9yZXMvVGV4dHNTdG9yZSc7XG5cbi8vIGNvbXBvbmVudHMgKHZpZXdzKVxuaW1wb3J0IEFEQ2F0IGZyb20gJy4vY29tcG9uZW50cy9BRENhdC5qc3gnO1xuaW1wb3J0IEFyZWFEZXNjcmlwdGlvbiBmcm9tICcuL2NvbXBvbmVudHMvQXJlYURlc2NyaXB0aW9uLmpzeCc7XG5pbXBvcnQgeyBDYXJ0b0RCVGlsZUxheWVyLCBIYXNoTWFuYWdlciwgTGVnZW5kLCBOYXZpZ2F0aW9uIH0gZnJvbSAnQHBhbm9yYW1hL3Rvb2xraXQnO1xuaW1wb3J0IENpdHlTbmlwcGV0IGZyb20gJy4vY29tcG9uZW50cy9DaXR5U25pcHBldC5qc3gnO1xuaW1wb3J0IENpdHlTdGF0cyBmcm9tICcuL2NvbXBvbmVudHMvQ2l0eVN0YXRzLmpzeCc7XG5pbXBvcnQgRG93bmxvYWRlciBmcm9tICcuL2NvbXBvbmVudHMvRG93bmxvYWRlci5qc3gnO1xuaW1wb3J0IHsgaWNvbiB9IGZyb20gJ2xlYWZsZXQnO1xuaW1wb3J0IHsgTWFwLCBUaWxlTGF5ZXIsIExheWVyR3JvdXAsIHNldEljb25EZWZhdWx0SW1hZ2VQYXRoIH0gZnJvbSAncmVhY3QtbGVhZmxldCc7XG5pbXBvcnQgTW9kYWwgZnJvbSAncmVhY3QtbW9kYWwnO1xuaW1wb3J0IFNsaWRlciBmcm9tICdyYy1zbGlkZXInO1xuaW1wb3J0IFN0YXRlU3RhdHMgZnJvbSAnLi9jb21wb25lbnRzL1N0YXRlU3RhdHMuanN4JztcbmltcG9ydCB7IFR5cGVhaGVhZCB9IGZyb20gJ3JlYWN0LXR5cGVhaGVhZCc7XG5pbXBvcnQgVHlwZUFoZWFkQ2l0eVNuaXBwZXQgZnJvbSAnLi9jb21wb25lbnRzL1R5cGVBaGVhZENpdHlTbmlwcGV0LmpzeCc7XG5pbXBvcnQgSE9MQ01hcCBmcm9tICcuL2NvbXBvbmVudHMvSE9MQ01hcC5qc3gnO1xuaW1wb3J0IFNpZGViYXJNYXAgZnJvbSAnLi9jb21wb25lbnRzL1NpZGViYXJNYXAuanN4JztcblxuLy8gdXRpbHNcbmltcG9ydCB7IEFwcEFjdGlvbnMsIEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcblxuLy8gZGF0YVxuaW1wb3J0IHBhbm9yYW1hTmF2RGF0YSBmcm9tICcuLi9kYXRhL3Bhbm9yYW1hX25hdi5qc29uJztcbmltcG9ydCBzdGF0ZUFiYnJzIGZyb20gJy4uL2RhdGEvc3RhdGVfYWJici5qc29uJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0c29tZXRoaW5nUmVxdWVzdGVkOiBPYmplY3Qua2V5cyhIYXNoTWFuYWdlci5nZXRTdGF0ZSgpKS5yZWR1Y2UoKGEsYikgPT4gKHR5cGVvZiBhICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgSGFzaE1hbmFnZXIuZ2V0U3RhdGUoKVthXSAhPT0gJ3VuZGVmaW5lZCcpIHx8ICh0eXBlb2YgYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEhhc2hNYW5hZ2VyLmdldFN0YXRlKClbYl0gIT09ICd1bmRlZmluZWQnKSwgJycpXG5cdH07XG5cblx0Y29uc3RydWN0b3IgKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLmdldERlZmF1bHRTdGF0ZSgpO1xuXG5cdFx0Ly8gYmluZCBoYW5kbGVyc1xuXHRcdGNvbnN0IGhhbmRsZXJzID0gWydvbldpbmRvd1Jlc2l6ZScsJ29uTW9kYWxDbGljaycsJ3RvZ2dsZUJ1cmdlc3NEaWFncmFtJywnc3RvcmVDaGFuZ2VkJywnb25CdXJnZXNzQ2hhcnRPZmYnLCdvbkJ1cmdlc3NDaGFydEhvdmVyJywnb25TdGF0ZVNlbGVjdGVkJywnb25DaXR5U2VsZWN0ZWQnLCdvbk1hcE1vdmVkJywnb25QYW5vcmFtYU1lbnVDbGljaycsJ29uRG93bmxvYWRDbGlja2VkJywnb25DYXRlZ29yeUNsaWNrJywnbmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQnLCduZWlnaGJvcmhvb2RzVW5oaWdobGlnaHRlZCcsJ29uU2xpZGVyQ2hhbmdlJywnb25Vc2VyQ2l0eVJlc3BvbnNlJywnb25OZWlnaGJvcmhvb2RQb2x5Z29uQ2xpY2snLCdvbkFyZWFDaGFydEhvdmVyJywnb25BcmVhQ2hhcnRPZmYnLCdvbkNpdHlNYXJrZXJTZWxlY3RlZCcsJ29uR3JhZGVIb3ZlcicsJ29uR3JhZGVVbmhvdmVyJywnb25IT0xDSURDbGljaycsJ29uTmVpZ2hib3Job29kQ2xvc2UnLCdvbkNhdGVnb3J5Q2xvc2UnLCdvbkFkSW1hZ2VDbGlja2VkJ107XG5cdFx0aGFuZGxlcnMubWFwKGhhbmRsZXIgPT4geyB0aGlzW2hhbmRsZXJdID0gdGhpc1toYW5kbGVyXS5iaW5kKHRoaXMpOyB9KTtcblx0fVxuXG5cdC8qIExpZmVjeWNsZSBtZXRob2RzICovXG5cblx0Y29tcG9uZW50V2lsbE1vdW50ICgpIHtcblx0XHRBcHBBY3Rpb25zLmxvYWRJbml0aWFsRGF0YSh0aGlzLnN0YXRlLCBIYXNoTWFuYWdlci5nZXRTdGF0ZSgpKTtcblxuXHRcdC8vdHJ5IHRvIHJldHJpZXZlIHRoZSB1c2VycyBsb2NhdGlvblxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oKHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdEFwcEFjdGlvbnMudXNlckxvY2F0ZWQoW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV0pO1xuXHRcdFx0fSwgKGVycm9yKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignR2VvbG9jYXRpb24gZXJyb3Igb2NjdXJyZWQuIEVycm9yIGNvZGU6ICcgKyBlcnJvci5jb2RlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50ICgpIHtcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcblx0XHRBcmVhRGVzY3JpcHRpb25zU3RvcmUuYWRkTGlzdGVuZXIoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkLCB0aGlzLnN0b3JlQ2hhbmdlZCk7XG5cdFx0Q2l0eVN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdERpbWVuc2lvbnNTdG9yZS5hZGRMaXN0ZW5lcihBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQsIHRoaXMuc3RvcmVDaGFuZ2VkKTtcblx0XHRNYXBTdGF0ZVN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFJhc3RlclN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFVzZXJMb2NhdGlvblN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFRleHRzU3RvcmUuYWRkTGlzdGVuZXIoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkLCB0aGlzLnN0b3JlQ2hhbmdlZCk7XG5cblx0XHQvLyB5b3UgaGF2ZSB0byB3YWl0IHVudGlsIHRoZXJlJ3MgYSBtYXAgdG8gcXVlcnkgdG8gZ2V0IHRoZSB2aXNpYmxlIG1hcHNcblx0XHRjb25zdCB3YWl0aW5nSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRpZiAoUmFzdGVyU3RvcmUuaGFzTG9hZGVkKCkgJiYgQXJlYURlc2NyaXB0aW9uc1N0b3JlLmhhc0xvYWRlZCgpKSB7XG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwod2FpdGluZ0lkKTtcblxuXHRcdFx0XHQvLyBlbWl0IG1hcHBlZCBtb3ZlZCBldmVudCB0byBpbml0aWFsaXplIG1hcCBzdGF0ZVxuXHRcdFx0XHRBcHBBY3Rpb25zLm1hcEluaXRpYWxpemVkKHRoaXMuZ2V0TGVhZmxldEVsZW1lbnRGb3JNYXAoKSk7XG5cdFx0XHR9XG5cdFx0fSwgMTAwKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHsgfVxuXG5cdGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7fVxuXG5cdC8qIHNldFN0YXRlIG1ldGhvZHMgKi9cblxuXHRnZXREZWZhdWx0U3RhdGUgKCkge1xuXHRcdGNvbnN0IGhhc2hTdGF0ZSA9IEhhc2hNYW5hZ2VyLmdldFN0YXRlKCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VsZWN0ZWRDaXR5OiAoaGFzaFN0YXRlLmNpdHkpID8gcGFyc2VJbnQoaGFzaFN0YXRlLmNpdHkpIDogbnVsbCwgXG5cdFx0XHRzZWxlY3RlZE5laWdoYm9yaG9vZDogKGhhc2hTdGF0ZS5hcmVhKSA/IGhhc2hTdGF0ZS5hcmVhIDogbnVsbCxcblx0XHRcdHNlbGVjdGVkQ2F0ZWdvcnk6IChoYXNoU3RhdGUuY2F0ZWdvcnkpID8gaGFzaFN0YXRlLmNhdGVnb3J5IDogbnVsbCxcblx0XHRcdHNlbGVjdGVkUmluZ0dyYWRlOiB7IFxuXHRcdFx0XHRyaW5nSWQ6IG51bGwsIFxuXHRcdFx0XHRncmFkZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHNlbGVjdGVkR3JhZGU6IG51bGwsXG5cdFx0XHRyYXN0ZXI6IHtcblx0XHRcdFx0b3BhY2l0eTogKGhhc2hTdGF0ZS5vcGFjaXR5KSA/IHBhcnNlRmxvYXQoaGFzaFN0YXRlLm9wYWNpdHkpIDogMC44XG5cdFx0XHR9LFxuXHRcdFx0aGlnaGxpZ2h0ZWROZWlnaGJvcmhvb2Q6IG51bGwsXG5cdFx0XHRidXJnZXNzRGlhZ3JhbVZpc2libGU6IGZhbHNlLFxuXHRcdFx0ZG93bmxvYWRPcGVuOiBmYWxzZSxcblx0XHRcdGFkSW1hZ2VPcGVuOiBmYWxzZSxcblx0XHRcdG1hcDoge1xuXHRcdFx0XHR6b29tOiAoaGFzaFN0YXRlLmxvYyAmJiBoYXNoU3RhdGUubG9jLnpvb20pID8gaGFzaFN0YXRlLmxvYy56b29tIDogNSxcblx0XHRcdFx0Y2VudGVyOiAoaGFzaFN0YXRlLmxvYyAmJiBoYXNoU3RhdGUubG9jLmNlbnRlcikgPyBbaGFzaFN0YXRlLmxvYy5jZW50ZXJbMF0sIGhhc2hTdGF0ZS5sb2MuY2VudGVyWzFdXSA6IFszOS44MzMzMzMzLC05OC41ODU1MjJdXG5cdFx0XHR9LFxuXHRcdFx0ZGltZW5zaW9uczoge1xuXHRcdFx0XHRsZWZ0OiB7XG5cdFx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwcGVyUmlnaHQ6IHtcblx0XHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRzdG9yZUNoYW5nZWQgKG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0c2VsZWN0ZWRDaXR5OiBDaXR5U3RvcmUuZ2V0SWQoKSxcblx0XHRcdHNlbGVjdGVkR3JhZGU6IENpdHlTdG9yZS5nZXRTZWxlY3RlZEdyYWRlKCksXG5cdFx0XHRzZWxlY3RlZE5laWdoYm9yaG9vZDogQ2l0eVN0b3JlLmdldFNlbGVjdGVkSG9sY0lkKCksXG5cdFx0XHRzZWxlY3RlZENhdGVnb3J5OiBDaXR5U3RvcmUuZ2V0U2VsZWN0ZWRDYXRlZ29yeSgpLFxuXHRcdFx0c2VsZWN0ZWRSaW5nR3JhZGU6IENpdHlTdG9yZS5nZXRTZWxlY3RlZFJpbmdHcmFkZSgpLFxuXHRcdFx0aGlnaGxpZ2h0ZWROZWlnaGJvcmhvb2Q6IENpdHlTdG9yZS5nZXRIaWdobGlnaHRlZEhvbGNJZCgpLFxuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGNlbnRlcjogTWFwU3RhdGVTdG9yZS5nZXRDZW50ZXIoKSxcblx0XHRcdFx0em9vbTogTWFwU3RhdGVTdG9yZS5nZXRab29tKClcblx0XHRcdH1cblx0XHR9LCB0aGlzLmNoYW5nZUhhc2gpOyBcblx0fVxuXG5cdG9uTWFwTW92ZWQgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5tYXBNb3ZlZCh0aGlzLmdldExlYWZsZXRFbGVtZW50Rm9yTWFwKCkpO1xuXHR9XG5cblx0b25DaXR5U2VsZWN0ZWQgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5jaXR5U2VsZWN0ZWQoZXZlbnQudGFyZ2V0LmlkLCB0cnVlKTtcblx0fVxuXG5cdG9uQ2l0eU1hcmtlclNlbGVjdGVkIChldmVudCkge1xuXHRcdEFwcEFjdGlvbnMuY2l0eVNlbGVjdGVkKGV2ZW50LnRhcmdldC5vcHRpb25zLmlkLCB0cnVlKTtcblx0fVxuXG5cdG9uTmVpZ2hib3Job29kUG9seWdvbkNsaWNrIChldmVudCkge1xuXHRcdGxldCBuZWlnaGJvcmhvb2RJZCA9IGV2ZW50LnRhcmdldC5vcHRpb25zLm5laWdoYm9yaG9vZElkLFxuXHRcdFx0YWRJZCA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5vcHRpb25zLmFkSWQpO1xuXG5cdFx0Ly8gY2xpY2tpbmcgb24gYSBzZWxlY3RlZCBuZWlnaGJvcmhvb2QgZGVzZWxlY3RzIGl0XG5cdFx0bmVpZ2hib3Job29kSWQgPSAobmVpZ2hib3Job29kSWQgPT0gdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCAmJiBhZElkID09IHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KSA/IG51bGwgOiBuZWlnaGJvcmhvb2RJZFxuXG5cdFx0QXBwQWN0aW9ucy5uZWlnaGJvcmhvb2RTZWxlY3RlZChuZWlnaGJvcmhvb2RJZCwgYWRJZCk7XG5cdH1cblxuXHRvbk5laWdoYm9yaG9vZENsb3NlKCkge1xuXHRcdEFwcEFjdGlvbnMubmVpZ2hib3Job29kU2VsZWN0ZWQobnVsbCwgdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpO1xuXHR9XG5cblx0b25IT0xDSURDbGljayAoZXZlbnQpIHtcblx0XHRBcHBBY3Rpb25zLm5laWdoYm9yaG9vZFNlbGVjdGVkKGV2ZW50LnRhcmdldC5pZCwgdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpO1xuXHR9XG5cblx0bmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5uZWlnaGJvcmhvb2RIaWdobGlnaHRlZChldmVudC50YXJnZXQuaWQpO1xuXHR9XG5cblx0bmVpZ2hib3Job29kc1VuaGlnaGxpZ2h0ZWQgKCkge1xuXHRcdEFwcEFjdGlvbnMubmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQobnVsbCk7XG5cdH1cblxuXHRvbkNhdGVnb3J5Q2xpY2sgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5BRENhdGVnb3J5U2VsZWN0ZWQoZXZlbnQudGFyZ2V0LmlkKTtcblx0fVxuXG5cdG9uQ2F0ZWdvcnlDbG9zZSAoZXZlbnQpIHtcblx0XHRBcHBBY3Rpb25zLkFEQ2F0ZWdvcnlTZWxlY3RlZChudWxsKTtcblx0fVxuXG5cdG9uQnVyZ2Vzc0NoYXJ0SG92ZXIgKHJpbmdJZCwgZ3JhZGUpIHtcblx0XHRBcHBBY3Rpb25zLnJpbmdHcmFkZVNlbGVjdGVkKHtyaW5nSWQ6IHJpbmdJZCwgZ3JhZGU6IGdyYWRlfSk7XG5cdH1cblxuXHRvbkJ1cmdlc3NDaGFydE9mZiAoKSB7XG5cdFx0QXBwQWN0aW9ucy5yaW5nR3JhZGVTZWxlY3RlZCh7cmluZ0lkOiAtMSwgZ3JhZGU6IG51bGx9KTtcblx0fVxuXG5cdG9uQXJlYUNoYXJ0SG92ZXIgKGdyYWRlKSB7XG5cdFx0QXBwQWN0aW9ucy5ncmFkZVNlbGVjdGVkKGdyYWRlKTtcblx0fVxuXG5cdG9uQXJlYUNoYXJ0T2ZmICgpIHtcblx0XHRBcHBBY3Rpb25zLmdyYWRlU2VsZWN0ZWQobnVsbCk7XG5cdH1cblxuXHRvbkxlZ2VuZFNlbGVjdCAobGVnZW5kVGV4dCkge1xuXG5cdH1cblxuXHRvbkdyYWRlSG92ZXIgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5ncmFkZVNlbGVjdGVkKGV2ZW50LnRhcmdldC5ncmFkZSk7XG5cdH1cblxuXHRvbkdyYWRlVW5ob3ZlciAoKSB7XG5cdFx0QXBwQWN0aW9ucy5ncmFkZVNlbGVjdGVkKG51bGwpO1xuXHR9XG5cblx0Y2F0ZWdvcnlTZWxlY3RlZCAoaWQpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdHNlbGVjdGVkTmVpZ2hib3Job29kOiBudWxsLFxuXHRcdFx0c2VsZWN0ZWRDYXRlZ29yeTogaWRcblx0XHR9LCB0aGlzLmNoYW5nZUhhc2gpO1xuXHR9XG5cblx0b25XaW5kb3dSZXNpemUgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy53aW5kb3dSZXNpemVkKCk7XG5cdH1cblxuXHRvblN0YXRlU2VsZWN0ZWQgKHZhbHVlLCBpbmRleCkge1xuXHRcdC8vIGZvciBjbGljayBvbiBzdGF0ZSBuYW1lIGluIHNpZGViYXJcblx0XHR2YWx1ZSA9ICh2YWx1ZS50YXJnZXQpID8gdmFsdWUudGFyZ2V0IDogdmFsdWU7XG5cdFx0XHRcdFxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0c2VsZWN0ZWRDaXR5OiBudWxsLFxuXHRcdFx0c2VsZWN0ZWROZWlnaGJvcmhvb2Q6IG51bGwsXG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0em9vbTogdGhpcy5nZXRMZWFmbGV0RWxlbWVudEZvck1hcCgpLmdldEJvdW5kc1pvb20oUmFzdGVyU3RvcmUuZ2V0TWFwQm91bmRzRm9yU3RhdGUodmFsdWUuaWQpKSxcblx0XHRcdFx0Y2VudGVyOiBSYXN0ZXJTdG9yZS5nZXRDZW50ZXJGb3JTdGF0ZSh2YWx1ZS5pZClcblx0XHRcdH1cblx0XHR9LCB0aGlzLmNoYW5nZUhhc2goKSk7XG5cdH1cblxuXHRvblNsaWRlckNoYW5nZSAodmFsdWUpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdHJhc3Rlcjoge1xuXHRcdFx0XHRvcGFjaXR5OiB2YWx1ZSAvIDEwMFxuXHRcdFx0fVxuXHRcdH0sIHRoaXMuY2hhbmdlSGFzaCk7XG5cdH1cblxuXHRvbkRvd25sb2FkQ2xpY2tlZCAoKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRkb3dubG9hZE9wZW46ICF0aGlzLnN0YXRlLmRvd25sb2FkT3BlblxuXHRcdH0pO1xuXHR9XG5cblx0b25BZEltYWdlQ2xpY2tlZCAoKSB7XG5cdFx0QXBwQWN0aW9ucy5BREltYWdlT3BlbmVkKHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QsIHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KTtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGFkSW1hZ2VPcGVuOiAhdGhpcy5zdGF0ZS5hZEltYWdlT3BlblxuXHRcdH0pO1xuXHR9XG5cblx0b25QYW5vcmFtYU1lbnVDbGljayAoKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRzaG93X3Bhbm9yYW1hX21lbnU6ICF0aGlzLnN0YXRlLnNob3dfcGFub3JhbWFfbWVudVxuXHRcdH0pO1xuXHR9XG5cblx0b25Vc2VyQ2l0eVJlc3BvbnNlKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnRhcmdldC52YWx1ZSA9PSAneWVzJykge1xuXHRcdFx0QXBwQWN0aW9ucy5jaXR5U2VsZWN0ZWQoVXNlckxvY2F0aW9uU3RvcmUuZ2V0QWRJZCgpLCB0cnVlKTtcblx0XHR9XG5cdFx0QXBwQWN0aW9ucy51c2VyUmVzcG9uZGVkVG9ab29tT2ZmZXIoKTtcblx0fVxuXG5cdHRvZ2dsZUJ1cmdlc3NEaWFncmFtICgpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGJ1cmdlc3NEaWFncmFtVmlzaWJsZTogIXRoaXMuc3RhdGUuYnVyZ2Vzc0RpYWdyYW1WaXNpYmxlXG5cdFx0fSk7XG5cdH1cblxuXHRvbk1vZGFsQ2xpY2sgKGV2ZW50KSB7XG5cdFx0Y29uc3Qgc3ViamVjdCA9IChldmVudC50YXJnZXQuaWQpID8gKGV2ZW50LnRhcmdldC5pZCkgOiBudWxsO1xuXHRcdEFwcEFjdGlvbnMub25Nb2RhbENsaWNrKHN1YmplY3QpO1xuXHR9XG5cblx0Z2V0TGVhZmxldEVsZW1lbnRGb3JNYXAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLnJlZnMuaG9sY19tYXApID8gdGhpcy5yZWZzLmhvbGNfbWFwLnJlZnMudGhlX21hcC5sZWFmbGV0RWxlbWVudCA6IHRoaXMucmVmcy5zaWRlYmFyX21hcC5yZWZzLmhvbGNfbWFwLnJlZnMudGhlX21hcC5sZWFmbGV0RWxlbWVudDtcblx0fVxuXG5cdC8qIG1hbmFnZSBoYXNoICovXG5cblx0Y2hhbmdlSGFzaCAoKSB7XG5cdFx0SGFzaE1hbmFnZXIudXBkYXRlSGFzaCh7IFxuXHRcdFx0Y2l0eTogdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksXG5cdFx0XHRhcmVhOiB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kLFxuXHRcdFx0Y2F0ZWdvcnk6IHRoaXMuc3RhdGUuc2VsZWN0ZWRDYXRlZ29yeSxcblx0XHRcdG9wYWNpdHk6IHRoaXMuc3RhdGUucmFzdGVyLm9wYWNpdHksXG5cdFx0XHRsb2M6IHtcblx0XHRcdFx0em9vbTogdGhpcy5zdGF0ZS5tYXAuem9vbSxcblx0XHRcdFx0Y2VudGVyOiB0aGlzLnN0YXRlLm1hcC5jZW50ZXJcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHNlYXJjaERpc3BsYXkgKCkge1xuXHRcdGxldCBjaXRpZXNPcHRpb25zID0gUmFzdGVyU3RvcmUuZ2V0Q2l0eUlkc0FuZE5hbWVzKCksXG5cdFx0XHRjaXRpZXNEYXRhID0gUmFzdGVyU3RvcmUuZ2V0QWxsUmFzdGVycygpO1xuXHRcdHJldHVybiBjaXRpZXNPcHRpb25zLm1hcCgoY2l0eU9wdGlvbikgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQ6IGNpdHlPcHRpb24uaWQsXG5cdFx0XHRcdGNpdHlOYW1lOiBjaXR5T3B0aW9uLmNpdHlOYW1lLFxuXHRcdFx0XHRkaXNwbGF5OiA8Q2l0eVNuaXBwZXQgXG5cdFx0XHRcdFx0Y2l0eURhdGE9eyBjaXRpZXNEYXRhW2NpdHlPcHRpb24uaWRdIH0gXG5cdFx0XHRcdFx0b25DaXR5Q2xpY2s9eyB0aGlzLnByb3BzLm9uQ2l0eUNsaWNrIH0gXG5cdFx0XHRcdFx0a2V5PXsgJ2NpdHlTZWFyY2gnICsgY2l0eU9wdGlvbi5pZCB9IFxuXHRcdFx0XHQvPlxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmVuZGVyICgpIHtcblxuXHRcdGxldCBtb2RhbFN0eWxlID0ge1xuXHRcdFx0XHRvdmVybGF5IDoge1xuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogbnVsbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb250ZW50IDoge1xuXHRcdFx0XHRcdHRvcDogbnVsbCxcblx0XHRcdFx0XHRsZWZ0OiBudWxsLFxuXHRcdFx0XHRcdHJpZ2h0OiBudWxsLFxuXHRcdFx0XHRcdGJvdHRvbTogbnVsbCxcblx0XHRcdFx0XHRib3JkZXI6IG51bGwsXG5cdFx0XHRcdFx0YmFja2dyb3VuZDogbnVsbCxcblx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IG51bGwsXG5cdFx0XHRcdFx0cGFkZGluZzogbnVsbCxcblx0XHRcdFx0XHRwb3NpdGlvbjogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0QURzID0gQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldFZpc2libGUoKSxcblx0XHRcdGFib3ZlVGhyZXNob2xkID0gTWFwU3RhdGVTdG9yZS5pc0Fib3ZlWm9vbVRocmVzaG9sZCgpLFxuXHRcdFx0b3V0ZXJSYWRpdXMgPSBDaXR5U3RvcmUuZ2V0T3V0ZXJSaW5nUmFkaXVzKCk7XG5cblx0XHRjb25zdCBzZWxlY3RlZEFEcyA9IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRBRHNGb3JOZWlnaGJvcmhvb2QodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QpLFxuXHRcdFx0bmVpZ2hib3Job29kTmFtZXMgPSBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0TmVpZ2hib3Job29kTmFtZXModGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpLFxuXHRcdFx0QURzQnlDYXQgPSBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0QURzRm9yQ2F0ZWdvcnkodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIHRoaXMuc3RhdGUuc2VsZWN0ZWRDYXRlZ29yeSksXG5cdFx0XHRjYXROdW0gPSAodGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5KSA/IHRoaXMuc3RhdGUuc2VsZWN0ZWRDYXRlZ29yeS5zcGxpdCgnLScpWzBdIDogbnVsbCxcblx0XHRcdGNhdExldHRlciA9ICh0aGlzLnN0YXRlLnNlbGVjdGVkQ2F0ZWdvcnkpID8gdGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5LnNwbGl0KCctJylbMV0gOiBudWxsLFxuXHRcdFx0dmlzaWJsZU1hcHMgPSBNYXBTdGF0ZVN0b3JlLmdldFZpc2libGVIT0xDTWFwcygpLFxuXHRcdFx0dmlzaWJsZVN0YXRlcyA9IE1hcFN0YXRlU3RvcmUuZ2V0VmlzaWJsZUhPTENNYXBzQnlTdGF0ZSgpO1xuXG5cdFx0Ly9zZXRJY29uRGVmYXVsdEltYWdlUGF0aCgnLi9zdGF0aWMnKTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyIGZ1bGwtaGVpZ2h0Jz5cblx0XHRcdFx0PE5hdmlnYXRpb24gXG5cdFx0XHRcdFx0c2hvd19tZW51PXsgdGhpcy5zdGF0ZS5zaG93X3Bhbm9yYW1hX21lbnUgfSBcblx0XHRcdFx0XHRvbl9oYW1idXJnZXJfY2xpY2s9eyB0aGlzLm9uUGFub3JhbWFNZW51Q2xpY2sgfSBcblx0XHRcdFx0XHRuYXZfZGF0YT17IHBhbm9yYW1hTmF2RGF0YS5maWx0ZXIoKGl0ZW0sIGkpID0+IGl0ZW0udXJsLmluZGV4T2YoJ2hvbGMnKSA9PT0gLTEpIH0gXG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdyb3cgZnVsbC1oZWlnaHQnPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdjb2x1bW5zIGVpZ2h0IGZ1bGwtaGVpZ2h0Jz5cblx0XHRcdFx0XHRcdDxoZWFkZXIgY2xhc3NOYW1lPSdyb3cgdS1mdWxsLXdpZHRoJz5cblx0XHRcdFx0XHRcdFx0PGgxPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0naGVhZGVyLW1haW4nPk1hcHBpbmcgSW5lcXVhbGl0eTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2hlYWRlci1zdWInPlJlZGxpbmluZyBpbiBOZXcgRGVhbCBBbWVyaWNhPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8L2gxPlxuXHRcdFx0XHRcdFx0XHQ8aDQgb25DbGljaz17IHRoaXMub25Nb2RhbENsaWNrIH0gaWQ9eyAnYWJvdXQnIH0+SW50cm9kdWN0aW9uPC9oND5cblx0XHRcdFx0XHRcdFx0PGg0IG9uQ2xpY2s9eyB0aGlzLm9uTW9kYWxDbGljayB9IGlkPXsgJ2JpYmxpb2dyYXBoJyB9PkJpYmxpb2dyYXBoaWMgTm90ZXMgJiBCaWJsaW9ncmFwaHk8L2g0PlxuXHRcdFx0XHRcdFx0XHQ8aDQgb25DbGljaz17IHRoaXMub25Nb2RhbENsaWNrIH0gaWQ9eyAnY3JlZGl0cycgfT5DcmVkaXRzPC9oND5cblx0XHRcdFx0XHRcdFx0PGhyIGNsYXNzTmFtZT0nc3R5bGUtZWlnaHQnIC8+XG5cdFx0XHRcdFx0XHQ8L2hlYWRlcj5cblx0XHRcdFx0XHRcdDxkaXYgXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT0ncm93IHRlbXBsYXRlLXRpbGUgbGVhZmxldC1jb250YWluZXIgbWFpbi1wYW5lJyBcblx0XHRcdFx0XHRcdFx0c3R5bGU9eyBEaW1lbnNpb25zU3RvcmUuZ2V0TWFpblBhbmVTdHlsZSgpIH1cblx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHR7ICghdGhpcy5zdGF0ZS5hZEltYWdlT3BlbikgP1xuXHRcdFx0XHRcdFx0XHRcdDxIT0xDTWFwXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWY9J2hvbGNfbWFwJ1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGU9eyB0aGlzLnN0YXRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uTWFwTW92ZWQ9eyB0aGlzLm9uTWFwTW92ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0b25OZWlnaGJvcmhvb2RQb2x5Z29uQ2xpY2s9eyB0aGlzLm9uTmVpZ2hib3Job29kUG9seWdvbkNsaWNrIH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2l0eU1hcmtlclNlbGVjdGVkPSB7IHRoaXMub25DaXR5TWFya2VyU2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHRcdFx0XHQ8TWFwIFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVmPSd0aGVfYWRfdGlsZXMnIFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2VudGVyPXsgWzc1LC0xMjVdIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHR6b29tPXsgMyB9ICBcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT0ndGhlX2FkJ1xuXHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9eyBEaW1lbnNpb25zU3RvcmUuZ2V0QURWaWV3ZXJTdHlsZSgpIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDxUaWxlTGF5ZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PSdBRCdcblx0XHRcdFx0XHRcdFx0XHRcdFx0dXJsPXsgQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldEFkVGlsZVVybCh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR6SW5kZXg9eyAxMDAwIH1cblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDxMZWdlbmQgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGl0ZW1zPXsgWyAnQ2xvc2UnIF0gfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9J2FkQ2xvc2UnIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkl0ZW1TZWxlY3RlZD17IHRoaXMub25BZEltYWdlQ2xpY2tlZCB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0PC9NYXA+IFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0XHR7IFRleHRzU3RvcmUubWFpbk1vZGFsSXNPcGVuKCkgP1xuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdsb25naXNoZm9ybSc+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT0nY2xvc2UnIG9uQ2xpY2s9eyB0aGlzLm9uTW9kYWxDbGljayB9PjxzcGFuPsOXPC9zcGFuPjwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbnRlbnQnIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXsgVGV4dHNTdG9yZS5nZXRNb2RhbENvbnRlbnQoKSB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+IDpcblx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7IChmYWxzZSkgP1xuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdsb25naXNoZm9ybSc+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT0nY2xvc2UnIG9uQ2xpY2s9eyB0aGlzLm9uQWRJbWFnZUNsaWNrZWR9PjxzcGFuPsOXPC9zcGFuPjwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGltZyBzcmM9eyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0QWRVcmwodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QpIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj4gOlxuXHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHR7IChhYm92ZVRocmVzaG9sZCkgP1xuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J29wYWNpdHlTbGlkZXInPlxuXHRcdFx0XHRcdFx0XHQ8U2xpZGVyIFxuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2FsPXsgdHJ1ZSB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgdGhpcy5zdGF0ZS5yYXN0ZXIub3BhY2l0eSAqIDEwMCB9XG5cdFx0XHRcdFx0XHRcdFx0b25BZnRlckNoYW5nZT17IHRoaXMub25TbGlkZXJDaGFuZ2UgfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+IDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbHVtbnMgZm91ciBmdWxsLWhlaWdodCc+XG5cblx0XHRcdFx0XHRcdDxkaXYgXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT0ncm93IHRlbXBsYXRlLXRpbGUgY2l0eS1zZWxlY3RvcicgXG5cdFx0XHRcdFx0XHRcdHN0eWxlPXsgRGltZW5zaW9uc1N0b3JlLmdldFNlYXJjaFN0eWxlKCkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8VHlwZWFoZWFkXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucz17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRBRHNMaXN0KCkgfVxuXHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgJ1NlYXJjaCBieSBjaXR5IG9yIHN0YXRlJyB9XG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyT3B0aW9uPXsgJ3NlYXJjaE5hbWUnIH1cblx0XHRcdFx0XHRcdFx0XHRkaXNwbGF5T3B0aW9uPXsoY2l0eSwgaSkgPT4gY2l0eS5hZF9pZCB9XG5cdFx0XHRcdFx0XHRcdFx0b25PcHRpb25TZWxlY3RlZD17IHRoaXMub25DaXR5U2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUxpc3RDb21wb25lbnQ9eyBUeXBlQWhlYWRDaXR5U25pcHBldCB9XG5cdFx0XHRcdFx0XHRcdFx0bWF4VmlzaWJsZT17IDggfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdDxkaXYgXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT0ncm93IGZ1bGwtaGVpZ2h0IHRlbXBsYXRlLXRpbGUgZGF0YVZpZXdlcicgXG5cdFx0XHRcdFx0XHRcdHN0eWxlPXsgRGltZW5zaW9uc1N0b3JlLmdldFNpZGViYXJIZWlnaHRTdHlsZSgpIH1cblx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHR7ICghdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCAmJiAhdGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5ICYmICF0aGlzLnN0YXRlLmRvd25sb2FkT3BlbiAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSkgP1xuXHRcdFx0XHRcdFx0XHRcdDxDaXR5U3RhdHMgXG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lPXsgQ2l0eVN0b3JlLmdldE5hbWUoKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZT17IENpdHlTdG9yZS5nZXRTdGF0ZSgpIH1cblx0XHRcdFx0XHRcdFx0XHRcdGNpdHlEYXRhPXsgQ2l0eVN0b3JlLmdldENpdHlEYXRhKCkgfSBcblx0XHRcdFx0XHRcdFx0XHRcdGFyZWE9eyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0QXJlYSh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSkgfSBcblx0XHRcdFx0XHRcdFx0XHRcdGdyYWRlU3RhdHM9eyBDaXR5U3RvcmUuZ2V0R3JhZGVTdGF0cygpIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRyaW5nU3RhdHM9eyBDaXR5U3RvcmUuZ2V0UmluZ1N0YXRzKCkgfSBcblx0XHRcdFx0XHRcdFx0XHRcdGFyZWFTZWxlY3RlZD17IHRoaXMub25CdXJnZXNzQ2hhcnRIb3ZlciB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0YXJlYVVuc2VsZWN0ZWQ9eyB0aGlzLm9uQnVyZ2Vzc0NoYXJ0T2ZmIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRncmFkZVNlbGVjdGVkPXsgdGhpcy5vbkFyZWFDaGFydEhvdmVyIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRncmFkZVVuc2VsZWN0ZWQ9eyB0aGlzLm9uQXJlYUNoYXJ0T2ZmIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVuQnVyZ2Vzcz17IHRoaXMub25Nb2RhbENsaWNrIH1cblx0XHRcdFx0XHRcdFx0XHRcdGJ1cmdlc3NEaWFncmFtVmlzaWJsZT17IHRoaXMuc3RhdGUuYnVyZ2Vzc0RpYWdyYW1WaXNpYmxlIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHR0b2dnbGVCdXJnZXNzRGlhZ3JhbT17IHRoaXMudG9nZ2xlQnVyZ2Vzc0RpYWdyYW0gfSBcblx0XHRcdFx0XHRcdFx0XHRcdGhhc0FEcz17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5oYXNBRERhdGEodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpIH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uRG93bmxvYWRDbGlja2VkPXsgdGhpcy5vbkRvd25sb2FkQ2xpY2tlZCB9XG5cdFx0XHRcdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7ICghdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCAmJiAhdGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5ICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5ICYmIE9iamVjdC5rZXlzKEFEcykubGVuZ3RoID49IDIpID9cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0XHRcdFx0PGg0Pk90aGVyIFZpc2libGUgTWFwczwvaDQ+XG5cdFx0XHRcdFx0XHRcdFx0XHR7IE9iamVjdC5rZXlzKHZpc2libGVNYXBzKS5tYXAobWFwSWQgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKCh2aXNpYmxlTWFwc1ttYXBJZF0uY2l0eUlkICE9PSB0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxDaXR5U25pcHBldCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNpdHlEYXRhPXsgdmlzaWJsZU1hcHNbbWFwSWRdIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNpdHlDbGljaz17IHRoaXMub25DaXR5U2VsZWN0ZWQgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdjaXR5JyArIG1hcElkIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWNlbnRlcj17IGZhbHNlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPiA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0fSl9IFxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PiA6XG5cdFx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0XHR7ICh0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kICYmICF0aGlzLnN0YXRlLmFkSW1hZ2VPcGVuKSA/IFxuXHRcdFx0XHRcdFx0XHRcdDxBcmVhRGVzY3JpcHRpb24gXG5cdFx0XHRcdFx0XHRcdFx0XHRhcmVhSWQ9eyB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRwcmV2aW91c0FyZWFJZD17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRQcmV2aW91c0hPTENJZCh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bmV4dEFyZWFJZD17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXROZXh0SE9MQ0lkKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5LCB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRuZWlnaGJvcmhvb2ROYW1lcz17IG5laWdoYm9yaG9vZE5hbWVzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGFyZWFEZXNjcmlwdGlvbnM9eyBzZWxlY3RlZEFEcyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0dGh1bWJuYWlsVXJsPXsgQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldFRodW1ibmFpbFVybCh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9ybUlkPXsgQ2l0eVN0b3JlLmdldEZvcm1JZCgpIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRjaXR5SWQ9eyB0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNhdGVnb3J5Q2xpY2s9eyB0aGlzLm9uQ2F0ZWdvcnlDbGljayB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0b25IT0xDSURDbGljaz17IHRoaXMub25IT0xDSURDbGljayB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0b25BZEltYWdlQ2xpY2tlZD17IHRoaXMub25BZEltYWdlQ2xpY2tlZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNsb3NlPXsgdGhpcy5vbk5laWdoYm9yaG9vZENsb3NlIH1cblx0XHRcdFx0XHRcdFx0XHRcdHJlZj17J2FyZWFkZXNjcmlwdGlvbicgKyB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRwcmV2aW91c1N0eWxlPXsgRGltZW5zaW9uc1N0b3JlLmdldEFETmF2UHJldmlvdXNTdHlsZSgpIH1cblx0XHRcdFx0XHRcdFx0XHRcdG5leHRTdHlsZT17IERpbWVuc2lvbnNTdG9yZS5nZXRBRE5hdk5leHRTdHlsZSgpIH1cblx0XHRcdFx0XHRcdFx0XHQvPiA6IFxuXHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7ICh0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kICYmIHRoaXMuc3RhdGUuYWRJbWFnZU9wZW4pID8gXG5cdFx0XHRcdFx0XHRcdFx0PFNpZGViYXJNYXBcblx0XHRcdFx0XHRcdFx0XHRcdHJlZj0nc2lkZWJhcl9tYXAnXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZT17IHRoaXMuc3RhdGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0b25NYXBNb3ZlZD17IHRoaXMub25NYXBNb3ZlZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbk5laWdoYm9yaG9vZFBvbHlnb25DbGljaz17IHRoaXMub25OZWlnaGJvcmhvb2RQb2x5Z29uQ2xpY2sgfVxuXHRcdFx0XHRcdFx0XHRcdFx0b25DaXR5TWFya2VyU2VsZWN0ZWQ9IHsgdGhpcy5vbkNpdHlNYXJrZXJTZWxlY3RlZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRhcmVhSWQ9eyB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRwcmV2aW91c0FyZWFJZD17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRQcmV2aW91c0hPTENJZCh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bmV4dEFyZWFJZD17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXROZXh0SE9MQ0lkKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5LCB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRuZWlnaGJvcmhvb2ROYW1lcz17IG5laWdoYm9yaG9vZE5hbWVzIH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uSE9MQ0lEQ2xpY2s9eyB0aGlzLm9uSE9MQ0lEQ2xpY2sgfSBcblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xvc2U9eyB0aGlzLm9uTmVpZ2hib3Job29kQ2xvc2UgfVxuXHRcdFx0XHRcdFx0XHRcdFx0cHJldmlvdXNTdHlsZT17IERpbWVuc2lvbnNTdG9yZS5nZXRBRE5hdlByZXZpb3VzU3R5bGUoKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0U3R5bGU9eyBEaW1lbnNpb25zU3RvcmUuZ2V0QUROYXZOZXh0U3R5bGUoKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRtYXBTdHlsZT17IERpbWVuc2lvbnNTdG9yZS5nZXRTaWRlYmFyTWFwU3R5bGUoKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHQvPiA6IFxuXHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7ICh0aGlzLnN0YXRlLnNlbGVjdGVkQ2F0ZWdvcnkpID9cblx0XHRcdFx0XHRcdFx0XHQ8QURDYXQgXG5cdFx0XHRcdFx0XHRcdFx0XHRBRHNCeUNhdD17IEFEc0J5Q2F0IH1cblx0XHRcdFx0XHRcdFx0XHRcdG5laWdoYm9yaG9vZE5hbWVzPXsgbmVpZ2hib3Job29kTmFtZXMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9ybUlkID0geyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0Rm9ybUlkKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KSB9XG5cdFx0XHRcdFx0XHRcdFx0XHR0aXRsZT17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRDYXRUaXRsZSh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgY2F0TnVtLCBjYXRMZXR0ZXIpIH1cblx0XHRcdFx0XHRcdFx0XHRcdGNhdE51bT17IGNhdE51bSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2F0TGV0dGVyID0geyBjYXRMZXR0ZXIgfSBcblx0XHRcdFx0XHRcdFx0XHRcdHByZXZpb3VzQ2F0SWRzID0geyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0UHJldmlvdXNDYXRJZHModGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIGNhdE51bSwgY2F0TGV0dGVyKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0Q2F0SWRzID0geyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0TmV4dENhdElkcyh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgY2F0TnVtLCBjYXRMZXR0ZXIpIH1cblx0XHRcdFx0XHRcdFx0XHRcdGNpdHlJZD17IHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5IH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uTmVpZ2hib3Job29kQ2xpY2s9eyB0aGlzLm9uSE9MQ0lEQ2xpY2sgfSBcblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2F0ZWdvcnlDbGljaz17IHRoaXMub25DYXRlZ29yeUNsaWNrIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRvbk5laWdoYm9yaG9vZEhvdmVyPXsgdGhpcy5uZWlnaGJvcmhvb2RIaWdobGlnaHRlZCB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0b25OZWlnaGJvcmhvb2RPdXQ9eyB0aGlzLm5laWdoYm9yaG9vZHNVbmhpZ2hsaWdodGVkIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRwcmV2aW91c1N0eWxlPXsgRGltZW5zaW9uc1N0b3JlLmdldEFETmF2UHJldmlvdXNTdHlsZSgpIH1cblx0XHRcdFx0XHRcdFx0XHRcdG5leHRTdHlsZT17IERpbWVuc2lvbnNTdG9yZS5nZXRBRE5hdk5leHRTdHlsZSgpIH1cblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xvc2U9eyB0aGlzLm9uQ2F0ZWdvcnlDbG9zZSB9XG5cdFx0XHRcdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7ICghdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkgJiYgIXRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QgJiYgIXRoaXMuc3RhdGUuc2VsZWN0ZWRDYXRlZ29yeSAmJiB2aXNpYmxlU3RhdGVzKSA/XG5cdFx0XHRcdFx0XHRcdFx0T2JqZWN0LmtleXModmlzaWJsZVN0YXRlcykubWFwKCh0aGVTdGF0ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIDxTdGF0ZVN0YXRzIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZU5hbWU9eyBzdGF0ZUFiYnJzW3RoZVN0YXRlXSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjaXRpZXM9eyB2aXNpYmxlU3RhdGVzW3RoZVN0YXRlXSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNpdHlDbGljaz17IHRoaXMub25DaXR5U2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9eyB0aGVTdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQvPjtcblx0XHRcdFx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHsgKHRoaXMuc3RhdGUuZG93bmxvYWRPcGVuKSA/XG5cdFx0XHRcdFx0XHRcdFx0PERvd25sb2FkZXIgXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXB1cmw9eyBSYXN0ZXJTdG9yZS5nZXRNYXBVcmwoKSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0dGh1bWJuYWlsPXsgUmFzdGVyU3RvcmUuZ2V0TWFwVGh1bWJuYWlsKCkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZT17IFJhc3RlclN0b3JlLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCkubmFtZSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGU9eyBDaXR5U3RvcmUuZ2V0U3RhdGUoKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRhZEdlb2pzb249eyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0QURzQXNHZW9qc29uKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkRvd25sb2FkQ2xpY2tlZD17IHRoaXMub25Eb3dubG9hZENsaWNrZWQgfVxuXHRcdFx0XHRcdFx0XHRcdC8+IDogXG5cdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PE1vZGFsIFxuXHRcdFx0XHRcdFx0aXNPcGVuPXsgVXNlckxvY2F0aW9uU3RvcmUuZ2V0T2ZmZXJab29tVG8oKSB9IFxuXHRcdFx0XHRcdFx0c3R5bGU9eyBtb2RhbFN0eWxlIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8cD5Xb3VsZCB5b3UgbGlrZSB0byB6b29tIHRvIHsgVXNlckxvY2F0aW9uU3RvcmUuZ2V0Q2l0eSgpIH0/PC9wPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXsgdGhpcy5vblVzZXJDaXR5UmVzcG9uc2UgfSB2YWx1ZT17ICd5ZXMnIH0+U3VyZTwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXsgdGhpcy5vblVzZXJDaXR5UmVzcG9uc2UgfSB2YWx1ZT17ICdubycgfT5ObyB0aGFua3M8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L01vZGFsPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PiBcblx0XHQpO1xuXG5cdH1cbn0iLCJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBTaWRlYmFyTmVpZ2hib3Job29kTmF2IGZyb20gJy4vU2lkZWJhck5laWdoYm9yaG9vZE5hdi5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBRENhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cblx0Ly8gcHJvcGVydHkgdmFsaWRhdGlvblxuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdFxuXHR9O1xuXG5cdC8vIChpbnN0ZWFkIG9mIEVTNS1zdHlsZSBnZXREZWZhdWx0UHJvcHMpXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2F0TnVtOiB1bmRlZmluZWQsXG5cdFx0Y2F0TGV0dGVyOiB1bmRlZmluZWRcblx0fTtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8vIGJpbmQgaGFuZGxlcnNcblx0XHRsZXQgaGFuZGxlcnMgPSBbJ3JlbmRlcjE5MzcwODI2XzVjJywgJ3JlbmRlcjE5MzcwODI2XzVjJywgJ3JlbmRlcjE5MzcwMjAzXzVkJywgJ3JlbmRlcjE5MzcwODI2XzVkJywgJ3JlbmRlcjE5MzcwODI2XzVnJywgJ3JlbmRlcjE5MzcwMjAzXzVnJywncmVuZGVyMTkzNzAyMDNfOGEnLCdyZW5kZXIxOTM3MDgyNl84YScsJ3JlbmRlcjE5MzcwMjAzXzhiJywncmVuZGVyMTkzNzA4MjZfOGInLCdyZW5kZXIxOTM3MDIwM184YycsJ3JlbmRlcjE5MzcwODI2XzhjJ107XG5cdFx0aGFuZGxlcnMubWFwKGhhbmRsZXIgPT4geyB0aGlzW2hhbmRsZXJdID0gdGhpc1toYW5kbGVyXS5iaW5kKHRoaXMpOyB9KTtcblx0fVxuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdFx0Ly9yZXR1cm4gKG5leHRQcm9wcy5jYXROdW0gIT09IHRoaXMucHJvcHMuY2F0TnVtIHx8IG5leHRQcm9wcy5jYXRMZXR0ZXIgIT09IHRoaXMucHJvcHMuY2F0TGV0dGVyIHx8IG5leHRQcm9wcy5jaXR5SWQgIT09IHRoaXMucHJvcHMuY2l0eUlkKVxuXHR9XG5cblx0LyogYWxwaGFudW0uanMgKEMpIEJyaWFuIEh1aXNtYW5cblx0KiBCYXNlZCBvbiB0aGUgQWxwaGFudW0gQWxnb3JpdGhtIGJ5IERhdmlkIEtvZWxsZVxuXHQqIFRoZSBBbHBoYW51bSBBbGdvcml0aG0gaXMgZGlzY3Vzc2VkIGF0IGh0dHA6Ly93d3cuRGF2ZUtvZWxsZS5jb21cblx0KlxuXHQqIERpc3RyaWJ1dGVkIHVuZGVyIHNhbWUgbGljZW5zZSBhcyBvcmlnaW5hbFxuXHQqIFxuXHQqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3Jcblx0KiBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG5cdCogTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyXG5cdCogdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIGFueSBsYXRlciB2ZXJzaW9uLlxuXHQqIFxuXHQqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuXHQqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5cdCogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcblx0KiBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXHQqIFxuXHQqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcblx0KiBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG5cdCogRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAgMDIxMTAtMTMwMSAgVVNBXG5cdCovXG5cdGFscGhhbnVtQ2FzZSAoYSwgYikge1xuXHRcdGZ1bmN0aW9uIGNodW5raWZ5KHQpIHtcblx0XHRcdHZhciB0eiA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dmFyIHggPSAwLCB5ID0gLTEsIG4gPSAwLCBpLCBqO1xuXHRcdFx0d2hpbGUgKGkgPSAoaiA9IHQuY2hhckF0KHgrKykpLmNoYXJDb2RlQXQoMCkpIHtcblx0XHRcdFx0dmFyIG0gPSAoaSA9PSA0NiB8fCAoaSA+PTQ4ICYmIGkgPD0gNTcpKTtcblx0XHRcdFx0aWYgKG0gIT09IG4pIHtcblx0XHRcdFx0XHR0elsrK3ldID0gJyc7XG5cdFx0XHRcdFx0biA9IG07XG5cdFx0XHRcdH1cblx0XHRcdFx0dHpbeV0gKz0gajtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ejtcblx0XHR9XG5cblx0XHR2YXIgYWEgPSBjaHVua2lmeShhLnRvTG93ZXJDYXNlKCkpO1xuXHRcdHZhciBiYiA9IGNodW5raWZ5KGIudG9Mb3dlckNhc2UoKSk7XHRcdFxuXHRcdGZvciAobGV0IHggPSAwOyBhYVt4XSAmJiBiYlt4XTsgeCsrKSB7XG5cdFx0XHRpZiAoYWFbeF0gIT09IGJiW3hdKSB7XG5cdFx0XHRcdHZhciBjID0gTnVtYmVyKGFhW3hdKSwgZCA9IE51bWJlcihiYlt4XSk7XG5cdFx0XHRcdGlmIChjID09IGFhW3hdICYmIGQgPT0gYmJbeF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gYyAtIGQ7XG5cdFx0XHRcdH0gZWxzZSByZXR1cm4gKGFhW3hdID4gYmJbeF0pID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYWEubGVuZ3RoIC0gYmIubGVuZ3RoO1xuXHR9XG5cblx0Z2V0Q2F0ZWdvcnlTdHJpbmcgKGNhdE51bSwgY2F0TGV0dGVyKSB7XG5cdFx0cmV0dXJuIGNhdE51bSArICgoY2F0TGV0dGVyKSA/ICctJyArIGNhdExldHRlciA6ICcnKTtcblx0fVxuXG5cdHJlbmRlckdyYWRlKGdyYWRlKSB7XG5cdFx0bGV0IGlkaW9zeW5jcmF0aWNEaXNwbGF5ID0gdGhpc1sncmVuZGVyJyArIHRoaXMucHJvcHMuZm9ybUlkICsgJ18nICsgdGhpcy5wcm9wcy5jYXROdW0gKyAoKHRoaXMucHJvcHMuY2F0TGV0dGVyKSA/IHRoaXMucHJvcHMuY2F0TGV0dGVyIDogJycpXSxcblx0XHRcdGNhdGVnb3J5RGF0YSA9IHRoaXMucHJvcHMuQURzQnlDYXQ7XG5cblx0XHRpZiAoIWNhdGVnb3J5RGF0YSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXsnZ3JhZGUtaGVhZGVyJyArIGdyYWRlfT48aDI+eyBncmFkZSB9PC9oMj48L2Rpdj5cblx0XHRcdFx0PHVsIGNsYXNzTmFtZT0nYXJlYV9kZXNjcmlwdGlvbicgcmVmPXsgJ2NhdCcgKyBncmFkZSB9PlxuXHRcdFx0XHRcdHsgT2JqZWN0LmtleXMoY2F0ZWdvcnlEYXRhKS5zb3J0KHRoaXMuYWxwaGFudW1DYXNlKS5tYXAobmVpZ2hib3Job29kSWQgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGdyYWRlID09IG5laWdoYm9yaG9vZElkLmNoYXJBdCgwKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdDxsaSBcblx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdjYXQnICsgZ3JhZGUgKyBuZWlnaGJvcmhvb2RJZCB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMucHJvcHMub25OZWlnaGJvcmhvb2RDbGljayB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0b25Nb3VzZUVudGVyPXsgdGhpcy5wcm9wcy5vbk5laWdoYm9yaG9vZEhvdmVyIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRvbk1vdXNlTGVhdmU9eyB0aGlzLnByb3BzLm9uTmVpZ2hib3Job29kT3V0IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRpZD17IG5laWdoYm9yaG9vZElkIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnIGlkPXsgbmVpZ2hib3Job29kSWQgfT57IG5laWdoYm9yaG9vZElkIH08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHR7ICh0aGlzLnByb3BzLm5laWdoYm9yaG9vZE5hbWVzW25laWdoYm9yaG9vZElkXSkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnIGlkPXsgbmVpZ2hib3Job29kSWQgfT57ICcgJyArIHRoaXMucHJvcHMubmVpZ2hib3Job29kTmFtZXNbbmVpZ2hib3Job29kSWRdfTwvc3Bhbj46XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDogXG5cdFx0XHRcdFx0XHRcdFx0XHR7ICh0eXBlb2YoaWRpb3N5bmNyYXRpY0Rpc3BsYXkpID09PSAnZnVuY3Rpb24nKSA/IGlkaW9zeW5jcmF0aWNEaXNwbGF5KGNhdGVnb3J5RGF0YVtuZWlnaGJvcmhvb2RJZF0pIDogdGhpcy5yZW5kZXJEYXR1bShjYXRlZ29yeURhdGFbbmVpZ2hib3Job29kSWRdKSB9XG5cdFx0XHRcdFx0XHRcdFx0PC9saT5cblxuXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSl9XG5cdFx0XHRcdDwvdWw+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyRGF0dW0oZGF0dW0sIG5laWdoYm9yaG9vZElkKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxzcGFuPnsgKGRhdHVtKSA/IDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyBkYXR1bSB9PC9zcGFuPiA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIxOTM3MDIwM181YyhkYXRhKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxzcGFuPlxuXHRcdFx0XHR7IHRoaXMucmVuZGVyRGF0dW0oZGF0YVsxXSl9OyB7IHRoaXMucmVuZGVyRGF0dW0oZGF0YVsyXSl9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlcjE5MzcwODI2XzVjID0gdGhpcy5yZW5kZXIxOTM3MDIwM181Yztcblx0cmVuZGVyMTkzNzAyMDNfNWQgPSB0aGlzLnJlbmRlcjE5MzcwMjAzXzVjO1xuXHRyZW5kZXIxOTM3MDgyNl81ZCA9IHRoaXMucmVuZGVyMTkzNzAyMDNfNWM7XG5cblx0cmVuZGVyMTkzNzAyMDNfNWcoZGF0YSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c3Bhbj5cblx0XHRcdFx0UG9wdWxhdGlvbiBpcyBpbmNyZWFzaW5nIHsgdGhpcy5yZW5kZXJEYXR1bShkYXRhWzFdKX07IGRlY3JlYXNpbmcgeyB0aGlzLnJlbmRlckRhdHVtKGRhdGFbMl0pfTsgc3RhdGljLlxuXHRcdFx0PC9zcGFuPlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIxOTM3MDgyNl81ZyA9IHRoaXMucmVuZGVyMTkzNzAyMDNfNWc7XG5cblx0cmVuZGVyMTkzNzAyMDNfOGEoZGF0YSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c3Bhbj57IHRoaXMucmVuZGVyRGF0dW0oZGF0YSkgfSU8L3NwYW4+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlcjE5MzcwODI2XzhhID0gdGhpcy5yZW5kZXIxOTM3MDIwM184YTtcblx0cmVuZGVyMTkzNzAyMDNfOGIgPSB0aGlzLnJlbmRlcjE5MzcwMjAzXzhhO1xuXHRyZW5kZXIxOTM3MDgyNl84YiA9IHRoaXMucmVuZGVyMTkzNzAyMDNfOGE7XG5cdHJlbmRlcjE5MzcwMjAzXzhjID0gdGhpcy5yZW5kZXIxOTM3MDIwM184YTtcblx0cmVuZGVyMTkzNzA4MjZfOGMgPSB0aGlzLnJlbmRlcjE5MzcwMjAzXzhhO1xuXG5cdHJlbmRlciAoKSB7XG5cblx0XHRsZXQgcHJldmlvdXNDYXQgPSB0aGlzLnByb3BzLnByZXZpb3VzQ2F0SWRzLFxuXHRcdFx0bmV4dENhdCA9IHRoaXMucHJvcHMubmV4dENhdElkcztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nQURDYXRlZ29yeSc+XG5cblx0XHRcdFx0PGgyPnt0aGlzLnByb3BzLnRpdGxlfSA8c3BhbiBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNsb3NlIH0+eDwvc3Bhbj48L2gyPlxuXG5cdFx0XHRcdHsgKHRoaXMucHJvcHMucHJldmlvdXNDYXRJZHMpID9cblx0XHRcdFx0XHQ8ZGl2IFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPSdhZE5hdicgXG5cdFx0XHRcdFx0XHRzdHlsZT17IHRoaXMucHJvcHMucHJldmlvdXNTdHlsZSB9XG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBcblx0XHRcdFx0XHRcdGlkPXsgdGhpcy5nZXRDYXRlZ29yeVN0cmluZyguLi5wcmV2aW91c0NhdCkgfSBcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IChwcmV2aW91c0NhdFsxXSkgPyBwcmV2aW91c0NhdFswXSArIHByZXZpb3VzQ2F0WzFdIDogcHJldmlvdXNDYXRbMF0gfVxuXHRcdFx0XHRcdDwvZGl2PiA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0fVxuXG5cdFx0XHRcblxuXHRcdFx0XHR7ICh0aGlzLnByb3BzLm5leHRDYXRJZHMpID9cblx0XHRcdFx0XHQ8ZGl2IFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPSdhZE5hdicgXG5cdFx0XHRcdFx0XHRzdHlsZT17IHRoaXMucHJvcHMubmV4dFN0eWxlIH1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2F0ZWdvcnlDbGljayB9IFxuXHRcdFx0XHRcdFx0aWQ9eyB0aGlzLmdldENhdGVnb3J5U3RyaW5nKC4uLm5leHRDYXQpIH0gXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyAobmV4dENhdFsxXSkgPyBuZXh0Q2F0WzBdICsgbmV4dENhdFsxXSA6IG5leHRDYXRbMF0gfVxuXHRcdFx0XHRcdDwvZGl2PiA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJHcmFkZSgnQScpIH1cblx0XHRcdFx0eyB0aGlzLnJlbmRlckdyYWRlKCdCJykgfVxuXHRcdFx0XHR7IHRoaXMucmVuZGVyR3JhZGUoJ0MnKSB9XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJHcmFkZSgnRCcpIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxufSIsIlxuaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5pbXBvcnQgU2lkZWJhck5laWdoYm9yaG9vZE5hdiBmcm9tICcuL1NpZGViYXJOZWlnaGJvcmhvb2ROYXYuanN4JztcbmltcG9ydCBTaWRlYmFyTmVpZ2hib3Job29kVGl0bGUgZnJvbSAnLi9TaWRlYmFyTmVpZ2hib3Job29kVGl0bGUuanN4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJlYURlc2NyaXB0aW9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuXHQvLyBwcm9wZXJ0eSB2YWxpZGF0aW9uXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0YXJlYURlc2NyaXB0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbXG5cdFx0XHRQcm9wVHlwZXMub2JqZWN0LFxuXHRcdFx0UHJvcFR5cGVzLmJvb2xcblx0XHRdKVxuXHR9O1xuXG5cdC8vIChpbnN0ZWFkIG9mIEVTNS1zdHlsZSBnZXREZWZhdWx0UHJvcHMpXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0YXJlYURlc2NyaXB0aW9uczoge31cblx0fTtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIChuZXh0UHJvcHMuYXJlYUlkICE9PSB0aGlzLnByb3BzLmFyZWFJZCB8fCBuZXh0UHJvcHMuY2l0eUlkICE9PSB0aGlzLnByb3BzLmNpdHlJZCB8fCBuZXh0UHJvcHMucHJldmlvdXNTdHlsZSAhPT0gdGhpcy5wcm9wcy5wcmV2aW91c1N0eWxlKTtcblx0fVxuXG5cdHJlbmRlciAoKSB7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J2FyZWFEZXNjcmlwdGlvbic+XG5cblx0XHRcdFx0PFNpZGViYXJOZWlnaGJvcmhvb2RUaXRsZVxuXHRcdFx0XHRcdGFyZWFJZD17IHRoaXMucHJvcHMuYXJlYUlkIH1cblx0XHRcdFx0XHRuYW1lPXsgdGhpcy5wcm9wcy5uZWlnaGJvcmhvb2ROYW1lc1t0aGlzLnByb3BzLmFyZWFJZF0gfVxuXHRcdFx0XHRcdG9uQ2xvc2U9eyB0aGlzLnByb3BzLm9uQ2xvc2UgfVxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdHsgKHRoaXMucHJvcHMucHJldmlvdXNBcmVhSWQpID9cblx0XHRcdFx0XHQ8U2lkZWJhck5laWdoYm9yaG9vZE5hdlxuXHRcdFx0XHRcdFx0c3R5bGU9eyB0aGlzLnByb3BzLnByZXZpb3VzU3R5bGUgfVxuXHRcdFx0XHRcdFx0b25IT0xDSURDbGljaz17IHRoaXMucHJvcHMub25IT0xDSURDbGljayB9IFxuXHRcdFx0XHRcdFx0YXJlYUlkID17IHRoaXMucHJvcHMucHJldmlvdXNBcmVhSWQgfSBcblx0XHRcdFx0XHRcdG5hbWU9eyB0aGlzLnByb3BzLm5laWdoYm9yaG9vZE5hbWVzW3RoaXMucHJvcHMucHJldmlvdXNBcmVhSWRdIH1cblx0XHRcdFx0XHQvPiA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHsgKHRoaXMucHJvcHMubmV4dEFyZWFJZCAmJiB0aGlzLnByb3BzLm5leHRBcmVhSWQgIT09ICdudWxsJykgP1xuXHRcdFx0XHRcdDxTaWRlYmFyTmVpZ2hib3Job29kTmF2XG5cdFx0XHRcdFx0XHRzdHlsZT17IHRoaXMucHJvcHMubmV4dFN0eWxlIH1cblx0XHRcdFx0XHRcdG9uSE9MQ0lEQ2xpY2s9eyB0aGlzLnByb3BzLm9uSE9MQ0lEQ2xpY2sgfSBcblx0XHRcdFx0XHRcdGFyZWFJZCA9eyB0aGlzLnByb3BzLm5leHRBcmVhSWQgfSBcblx0XHRcdFx0XHRcdG5hbWU9eyB0aGlzLnByb3BzLm5laWdoYm9yaG9vZE5hbWVzW3RoaXMucHJvcHMubmV4dEFyZWFJZF0gfVxuXHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHR9XG5cblxuXHRcblx0XHRcdFx0eyAoWzE5MzcwMjAzLDE5MzcwODI2XS5pbmRleE9mKHBhcnNlSW50KHRoaXMucHJvcHMuZm9ybUlkKSkgPj0gMCkgPyB0aGlzLnJlbmRlck5TRm9ybThfMTkzNzAyMDMoKSA6XG5cdFx0XHRcdCAgKHBhcnNlSW50KHRoaXMucHJvcHMuZm9ybUlkKSA9PSAxOTM3MTAwMSkgPyB0aGlzLnJlbmRlck5TRm9ybThfMTkzNzEwMDEoKSA6XG5cdFx0XHRcdCAgbnVsbFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0PGZpZ3VyZSBjbGFzc05hbWU9J2FkVGh1bWJuYWlsJz5cblx0XHRcdFx0XHQ8aW1nIHNyYz17IHRoaXMucHJvcHMudGh1bWJuYWlsVXJsIH0gb25DbGljaz17IHRoaXMucHJvcHMub25BZEltYWdlQ2xpY2tlZCB9IC8+XG5cdFx0XHRcdFx0PGZpZ2NhcHRpb24+Q2xpY2sgb24gdGhlIHRodW1ibmFpbCB0byBzZWUgYSB6b29tYWJsZSB2ZXJzaW9uLjwvZmlnY2FwdGlvbj5cblx0XHRcdFx0PC9maWd1cmU+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXG5cblx0fVxuXG5cblx0cmVuZGVyTlNGb3JtOF8xOTM3MDIwMygpIHtcblx0XHRsZXQgQUQgPSB0aGlzLnByb3BzLmFyZWFEZXNjcmlwdGlvbnM7XG5cblx0XHRpZiAoQUQgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblxuXHRcdFx0PHVsIGNsYXNzTmFtZT0nYXJlYV9kZXNjcmlwdGlvbiBOU0Zvcm04Jz5cblxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjE8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5OYW1lIG9mIENpdHk8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFsxXSAmJiBBRFsxXVsxXSApID8gQURbMV1bMV0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlx0XHRcdFx0XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lIGluZGVudCc+IFNlY3VyaXR5IEdyYWRlIDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzFdICYmIEFEWzFdWzJdICkgPyBBRFsxXVsyXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lIGluZGVudCc+IEFyZWEgTm8uIDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzFdICYmIEFEWzFdWzNdICkgPyBBRFsxXVszXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlQ2F0ZWdvcnkoMiwgJ0Rlc2NyaXB0aW9uIG9mIFRlcnJhaW4nKSB9XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVDYXRlZ29yeSgzLCAnRmF2b3JhYmxlIEluZmx1ZW5jZXMnKSB9XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVDYXRlZ29yeSg0LCAnRGV0cmltZW50YWwgSW5mbHVlbmNlcycpIH1cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz41PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+SW5oYWJpdGFudHM8L3NwYW4+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDUsICdhJywgJ1R5cGUnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNSwgJ2InLCAnRXN0aW1hdGVkIGFubnVhbCBmYW1pbHkgaW5jb21lJykgfVxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlciBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD0nNS1jJz5jPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9JzUtYyc+Rm9yZWlnbi1ib3JuPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzVdICYmIEFEWzVdWydjJ11bJzEnXSApID8gQURbNV1bJ2MnXVsnMSddIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH07IHsgKEFEWzVdICYmIEFEWzVdWydjJ11bJzInXSApID8gQURbNV1bJ2MnXVsnMiddIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlciBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD0nNS1kJz5kPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9JzUtZCc+TmVncm88L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbNV0gJiYgQURbNV1bJ2QnXVsnMSddICkgPyBBRFs1XVsnZCddWycxJ10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTsgeyAoQURbNV0gJiYgQURbNV1bJ2QnXVsnMiddICkgPyBBRFs1XVsnZCddWycyJ10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNSwgJ2UnLCAnSW5maWx0cmF0aW9uIG9mJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDUsICdmJywgJ1JlbGllZiBmYW1pbGllcycpIH1cblx0XHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXIgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9JzUtZyc+Zzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXROYW1lIGNhdFNlbGVjdGFibGUnIG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2F0ZWdvcnlDbGljayB9IGlkPSc1LWcnPlBvcHVsYXRpb24gaXMgaW5jcmVhc2luZzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs1XSAmJiBBRFs1XVsnZyddWycxJ10gKSA/IEFEWzVdWydnJ11bJzEnXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnPjsgZGVjcmVhc2luZzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs1XSAmJiBBRFs1XVsnZyddWycyJ10gKSA/IEFEWzVdWydnJ11bJzInXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPjsgXG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSc+OyBzdGF0aWM8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz42PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+QnVpbGRpbmdzPC9zcGFuPlxuXHRcdFx0XHRcdDx1bD5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg2LCAnYScsICdUeXBlIG9yIFR5cGVzJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDYsICdiJywgJ1R5cGUgb2YgY29uc3RydWN0aW9uJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDYsICdjJywgJ0F2ZXJhZ2UgYWdlJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDYsICdkJywgJ1JlcGFpcicpIH1cblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjc8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5IaXN0b3J5PC9zcGFuPlxuXHRcdFx0XHRcdDx0YWJsZT5cblx0XHRcdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5TYWxlcyBWYWx1ZXM8L3RoPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlllYXI8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5SYW5nZTwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlByZWRvbWluYXRpbmc8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD4lPC90aD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdDwvdGhlYWQ+XG5cdFx0XHRcdFx0XHQ8dGJvZHk+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+MTkyOSBsZXZlbDwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzFdICkgPyBBRFs3XVsxXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMl0gKSA/IEFEWzddWzJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD4xMDAlPC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD57IEFEWzddWzVdIH0gbGV2ZWw8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVs2XSApID8gQURbN11bNl0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzddICkgPyBBRFs3XVs3XSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bOF0gKSA/IEFEWzddWzhdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPnsgQURbN11bMTJdIH0gIGxldmVsPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMTNdICkgPyBBRFs3XVsxM10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzE0XSApID8gQURbN11bMTRdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsxNV0gKSA/IEFEWzddWzE1XSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdDwvdGJvZHk+XG5cdFx0XHRcdFx0PC90YWJsZT5cblxuXHRcdFx0XHRcdDx0YWJsZT5cblx0XHRcdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5SZW50YWwgVmFsdWVzPC90aD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5ZZWFyPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+UmFuZ2U8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5QcmVkb21pbmF0aW5nPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+JTwvdGg+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHQ8L3RoZWFkPlxuXHRcdFx0XHRcdFx0PHRib2R5PlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPjE5MjkgbGV2ZWw8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVszXSApID8gQURbN11bM10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzRdICkgPyBBRFs3XVs0XSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+MTAwJTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+eyAoQURbN10gJiYgQURbN11bNV0gKSA/IEFEWzddWzVdIDogJyd9IGxldmVsPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bOV0gKSA/IEFEWzddWzldIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsxMF0gKSA/IEFEWzddWzEwXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMTFdICkgPyBBRFs3XVsxMV0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+eyBBRFs3XVsxMl0gfSAgbGV2ZWw8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsxNl0gKSA/IEFEWzddWzE2XSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMTddICkgPyBBRFs3XVsxN10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzE4XSApID8gQURbN11bMThdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0PC90Ym9keT5cblx0XHRcdFx0XHQ8L3RhYmxlPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdwZXJjZW50YWdlJz5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSc+UGVhayBTYWxlcyB2YWx1ZXMgb2NjdXJyZWQgaW48L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzddICYmIEFEWzddWzE5XSApID8gQURbN11bMTldIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnPiBhbmQgd2VyZSA8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzddICYmIEFEWzddWzIwXSApID8gQURbN11bMjBdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnPiUgb2YgdGhlIDE5MjkgbGV2ZWwuPC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdwZXJjZW50YWdlJz5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSc+UGVhayByZW50YWwgdmFsdWVzIG9jY3VycmVkIGluPC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs3XSAmJiBBRFs3XVsyMV0gKSA/IEFEWzddWzIxXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXROYW1lJz4gYW5kIHdlcmUgPC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs3XSAmJiBBRFs3XVsyMl0gKSA/IEFEWzddWzIyXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXROYW1lJz4lIG9mIHRoZSAxOTI5IGxldmVsLjwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz44PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+T2NjdXBhbmN5PC9zcGFuPlxuXHRcdFx0XHRcdDx1bD5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg4LCAnYScsICdMYW5kJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDgsICdiJywgJ0R3ZWxsaW5nIHVuaXRzJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDgsICdjJywgJ0hvbWUgT3duZXJzJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+OTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlNhbGVzIERlbWFuZDwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoOSwgJ2EnLCAnJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDksICdiJywgJycpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg5LCAnYycsICdBY3Rpdml0eSBpcycpIH1cblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjEwPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+UmVudGFsIERlbWFuZDwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMTAsICdhJywgJycpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxMCwgJ2InLCAnJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDEwLCAnYycsICdBY3Rpdml0eSBpcycpIH1cblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjExPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+TmV3IENvbnN0cnVjdGlvbjwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMTEsICdhJywgJ1R5cGVzJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDExLCAnYicsICdBbW91bnQgbGFzdCB5ZWFyJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+MTI8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5BdmFpbGFiaWxpdHkgb2YgTW9ydGdhZ2UgRnVuZHM8L3NwYW4+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDEyLCAnYScsICdIb21lIHB1cmNoYXNlJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDEyLCAnYicsICdIb21lIGJ1aWxkaW5nJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVDYXRlZ29yeSgxMywgJ1RyZW5kIG9mIERlc2lyZWFiaWxpdHkgTmV4dCAxMC0xNSBZZWFycycpIH1cblx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZUNhdGVnb3J5KDE0LCAnQ2xhcmlmeWluZyBSZW1hcmtzJykgfVxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjE1PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+SW5mb3JtYXRpb24gZm9yIHRoaXMgZm9ybSB3YXMgb2J0YWluZWQgZnJvbTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzE1XSAgJiYgdHlwZW9mKEFEWzE1XSkgPT0gJ3N0cmluZycgKSA/IEFEWzE1XSA6IChBRFsxNV0gJiYgQURbMTVdWzFdKSA/IEFEWzE1XVsxXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHR7ICh0eXBlb2YoQURbMTVdKSA9PT0gJ29iamVjdCcpID9cblx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUgaW5kZW50Jz5EYXRlPC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFsxNV0gJiYgQURbMTVdWzJdICkgPyBBRFsxNV1bMl0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSBpbmRlbnQnPjE5Mzwvc3Bhbj48c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzE1XSAmJiBBRFsxNV1bM10gKSA/IEFEWzE1XVszXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdDwvbGk+IDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHR9XG5cdFx0XHQ8L3VsPlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXJOU0Zvcm04XzE5MzcxMDAxKCkge1xuXHRcdGxldCBBRCA9IHRoaXMucHJvcHMuYXJlYURlc2NyaXB0aW9ucztcblxuXHRcdGlmIChBRCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PHVsIGNsYXNzTmFtZT0nYXJlYV9kZXNjcmlwdGlvbiBOU0Zvcm04Jz5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz4xPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+QXJlYSBDaGFyYWN0ZXJpc3RpY3M8L3NwYW4+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDEsICdhJywgJ0Rlc2NyaXB0aW9uIG9mIFRlcnJhaW4nKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMSwgJ2InLCAnRmF2b3JhYmxlIEluZmx1ZW5jZXMnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMSwgJ2MnLCAnRGV0cmltZW50YWwgSW5mbHVlbmNlcycpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxLCAnZCcsICdQZXJjZW50YWdlIG9mIGxhbmQgaW1wcm92ZWQnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMSwgJ2UnLCAnVHJlbmQgb2YgZGVzaXJlYWJpbGl0eSBuZXh0IDEwLTE1IHlycy4nKSB9XG5cdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz4yPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+SW5oYWJpdGFudHM8L3NwYW4+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDIsICdhJywgJ09jY3VwYXRpb24nKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMiwgJ2InLCAnRXN0aW1hdGVkIEFubnVhbCBGYW1pbHkgSW5jb21lJykgfVxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+Yzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5Gb3JlaWduLWJvcm4gZmFtaWxpZXM8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMiwgJ2MnLCAxKSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU7PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPiB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgyLCAnYycsIDIpIH08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+ICBwcmVkb21pbmF0aW5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+TmVncm88L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMiwgJ2QnLCAxKSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU7PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPiB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgyLCAnZCcsIDIpIH08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+ICBwcmVkb21pbmF0aW5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgyLCAnZScsICdJbmZpbHRyYXRpb24gb2YnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMiwgJ2YnLCAnUmVsaWVmIGZhbWlsaWVzJykgfVxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+Zzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5Qb3B1bGF0aW9uIGlzIGluY3JlYXNpbmc8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDIsICdnJywgMSkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz47IGRlY3JlYXNpbmc8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDIsICdnJywgMikgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz47IHN0YXRpYzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz4geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMiwgJ2cnLCAzKSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjM8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5CdWlsZGluZ3M8L3NwYW4+XG5cdFx0XHRcdFx0PHRhYmxlPlxuXHRcdFx0XHRcdFx0PHRoZWFkPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPjwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlByZWRvbWluYXRpbmcgeyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgbnVsbCwgMSkgfSU8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5PdGhlciBUeXBlIHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsIG51bGwsIDIpIH0lPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+T3RoZXIgVHlwZSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCBudWxsLCAzKSB9JTwvdGg+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHQ8L3RoZWFkPlxuXHRcdFx0XHRcdFx0PHRib2R5PlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmE8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlR5cGU8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2EnLCAxKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2EnLCAyKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2EnLCAzKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5iPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5Db25zdHJ1Y3Rpb248L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2InLCAxKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2InLCAyKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2InLCAzKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5jPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5BdmVyYWdlIGFnZTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYycsIDEpIH0gPHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5ZZWFyczwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYycsIDIpIH0gPHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5ZZWFyczwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYycsIDMpIH0gPHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5ZZWFyczwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlJlcGFpcjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZCcsIDEpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZCcsIDIpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZCcsIDMpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmU8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPk9jY3VwYW5jeTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZScsIDEpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2UnLCAyKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdlJywgMykgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmY8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkhvbWUgT3duZXJzaGlwPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdmJywgMSkgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZicsIDIpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2YnLCAzKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+Zzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+Q29uc3RydWN0ZWQgcGFzdCB5ci48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2cnLCAxKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2cnLCAyKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2cnLCAzKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5oPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xOTI5IFByaWNlIHJhbmdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaCcsIDEpIH0gPHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaCcsIDIpIH0gPHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaCcsIDMpIH0gPHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+aTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2knLCAxKSB9IFByaWNlIHJhbmdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDIpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2knLCAzKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDQpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2knLCA1KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDYpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2knLCA3KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+ajwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2onLCAxKSB9IFByaWNlIHJhbmdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDIpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2onLCAzKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDQpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2onLCA1KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDYpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2onLCA3KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+azwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+U2FsZXMgZGVtYW5kIFVwIHRvPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdrJywgMSkgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlVwIHRvIHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdrJywgMikgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdrJywgMykgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+bDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+QWN0aXZpdHk8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2wnLCAxKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2wnLCAyKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2wnLCAzKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5tPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xOTI5IFJlbnQgcmFuZ2U8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdtJywgMSkgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdtJywgMikgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdtJywgMykgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5uPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbicsIDEpIH0gUmVudCByYW5nZTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD48c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiQ8L3NwYW4+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ24nLCAyKSB9IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICduJywgMykgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+MTAwJTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD48c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiQ8L3NwYW4+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ24nLCA0KSB9IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICduJywgNSkgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD48c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiQ8L3NwYW4+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ24nLCA2KSB9IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICduJywgNykgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPm88L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdvJywgMSkgfSBSZW50IHJhbmdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbycsIDIpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ28nLCAzKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbycsIDQpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ28nLCA1KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbycsIDYpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ28nLCA3KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+cDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+UmVudGFsIGRlbWFuZCBVcCB0bzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAncCcsIDEpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5VcCB0byB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAncCcsIDIpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAncCcsIDMpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPnE8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkFjdGl2aXR5PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdxJywgMSkgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdxJywgMikgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdxJywgMykgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHQ8L3Rib2R5PlxuXHRcdFx0XHRcdDwvdGFibGU+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+NDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkF2YWlsYWJpbGl0eSBvZiBNb3J0Z2FnZSBGdW5kczwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNCwgJ2EnLCAnSG9tZSBwdXJjaGFzZScpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg0LCAnYicsICdIb21lIGJ1aWxkaW5nJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVDYXRlZ29yeSg1LCAnQ2xhcmlmeWluZyBSZW1hcmtzJykgfVxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjY8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5OYW1lIGFuZCBMb2NhdGlvbjwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzZdICYmIEFEWzZdWzFdICkgPyBBRFs2XVsxXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+U2VjdXJpdHkgR3JhZGU8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs2XSAmJiBBRFs2XVsyXSApID8gQURbNl1bMl0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkFyZWEgTm8uPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbNl0gJiYgQURbNl1bM10gKSA/IEFEWzZdWzNdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXJTaW1wbGVDYXRlZ29yeShjYXROdW0sIGNhdE5hbWUpIHtcblx0XHRsZXQgQUQgPSB0aGlzLnByb3BzLmFyZWFEZXNjcmlwdGlvbnM7XG5cdFx0XG5cdFx0cmV0dXJuIChcblx0XHRcdDxsaSBrZXk9eydBRC0nICsgY2F0TnVtfT5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0gY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9eyBjYXROdW0gfT57IGNhdE51bSB9PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9eyBjYXROdW0gfT57IGNhdE5hbWUgfTwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXREYXRhJz57IChBRFtjYXROdW1dICkgPyBBRFtjYXROdW1dIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+fTwvc3Bhbj5cblx0XHRcdDwvbGk+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KGNhdE51bSwgY2F0TGV0dGVyLCBzdWJjYXROYW1lKSB7XG5cdFx0bGV0IEFEID0gdGhpcy5wcm9wcy5hcmVhRGVzY3JpcHRpb25zOyBcblxuXHRcdGlmIChBRCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIUFEW2NhdE51bV0pIHtcblx0XHRcdGNvbnNvbGUud2FybihjYXROdW0gKyBjYXRMZXR0ZXIgKyAnIGlzIG5vdCBkZWZpbmVkJywgQUQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgQURbY2F0TnVtXVtjYXRMZXR0ZXJdID09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oY2F0TnVtICsgY2F0TGV0dGVyICsgJyBpcyBhbiBvYmplY3Qgd2hlbiBhIHN0cmluZyB3YXMgZXhwZWN0ZWQnKTtcblx0XHR9XG5cdFx0cmV0dXJuIChcblx0XHRcdDxsaT5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXIgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9eyBjYXROdW0gKyAnLScgKyBjYXRMZXR0ZXIgfT57IGNhdExldHRlciB9PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9eyBjYXROdW0gKyAnLScgKyBjYXRMZXR0ZXIgfT57IHN1YmNhdE5hbWUgfTwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFtjYXROdW1dICYmIEFEW2NhdE51bV1bY2F0TGV0dGVyXSAmJiB0eXBlb2YgQURbY2F0TnVtXVtjYXRMZXR0ZXJdICE9PSAnb2JqZWN0JyApID8gQURbY2F0TnVtXVtjYXRMZXR0ZXJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+fTwvc3Bhbj5cblx0XHRcdDwvbGk+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlclNpbXBsZURhdGEoY2F0TnVtLCBzdWJjYXRMZXR0ZXIgPSAnJywgb3JkZXIgPSBudWxsKSB7XG5cdFx0bGV0IEFEID0gdGhpcy5wcm9wcy5hcmVhRGVzY3JpcHRpb25zO1xuXHRcdGlmIChvcmRlciA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8c3Bhbj57IChBRFtjYXROdW1dICYmIEFEW2NhdE51bV1bc3ViY2F0TGV0dGVyXSApID8gQURbY2F0TnVtXVtzdWJjYXRMZXR0ZXJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoc3ViY2F0TGV0dGVyID09ICcnKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8c3Bhbj57IChBRFtjYXROdW1dICYmIEFEW2NhdE51bV1bb3JkZXJdICkgPyBBRFtjYXROdW1dW29yZGVyXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PHNwYW4+eyAoQURbY2F0TnVtXSAmJiBBRFtjYXROdW1dW3N1YmNhdExldHRlcl0gJiYgQURbY2F0TnVtXVtzdWJjYXRMZXR0ZXJdW29yZGVyXSApID8gQURbY2F0TnVtXVtzdWJjYXRMZXR0ZXJdW29yZGVyXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxufVxuIiwiaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtHZW9Kc29ufSAgZnJvbSAncmVhY3QtbGVhZmxldCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZWFQb2x5Z29uIGV4dGVuZHMgR2VvSnNvbiB7XG5cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRpZiAobmV4dFByb3BzLmRhdGEgIT09IHRoaXMucHJvcHMuZGF0YSkge1xuXHRcdFx0dGhpcy5sZWFmbGV0RWxlbWVudC5jbGVhckxheWVycygpO1xuXHRcdH1cblx0XHRpZiAobmV4dFByb3BzLmNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdHRoaXMubGVhZmxldEVsZW1lbnQub3B0aW9ucy5jbGFzc05hbWUgPSBuZXh0UHJvcHMuY2xhc3NOYW1lO1xuXHRcdH1cblxuXHRcdGlmIChuZXh0UHJvcHMuZmlsbE9wYWNpdHkgIT09IHRoaXMucHJvcHMuZmlsbE9wYWNpdHkpIHtcblx0XHRcdGNvbnNvbGUubG9nKHRoaXMubGVhZmxldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5sZWFmbGV0RWxlbWVudC5vcHRpb25zLmZpbGxPcGFjaXR5ID0gbmV4dFByb3BzLmZpbGxPcGFjaXR5O1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcblx0XHRpZiAocHJldlByb3BzLmRhdGEgIT09IHRoaXMucHJvcHMuZGF0YSkge1xuXHRcdFx0dGhpcy5sZWFmbGV0RWxlbWVudC5hZGREYXRhKHRoaXMucHJvcHMuZGF0YSk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLnN0eWxlLCB0aGlzLnByb3BzLnN0eWxlKTtcblx0fVxufVxuXG5BcmVhUG9seWdvbi5wcm9wVHlwZXMgPSB7XG5cdGRhdGE6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTsiLCJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2l0eVNuaXBwZXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvLyBwcm9wZXJ0eSB2YWxpZGF0aW9uXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0Y2l0eURhdGE6IFByb3BUeXBlcy5vYmplY3Rcblx0fTtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8vdGhpcy5kM0NoYXJ0ID0gdGhpcy5kM0NoYXJ0LmJpbmQodGhpcyk7XG5cdH1cblxuXHRzaG91bGRDb21wb25lbnRVcGRhdGUgKG5leHRQcm9wcykge1xuXHRcdHJldHVybiAobmV4dFByb3BzLmNpdHlEYXRhLmNpdHkgIT09IHRoaXMucHJvcHMuY2l0eURhdGEuY2l0eSk7XG5cdH0gXG5cblx0Y29tcG9uZW50V2lsbE1vdW50ICgpIHt9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMuY2l0eURhdGEuaGFzUG9seWdvbnMpIHtcblx0XHRcdC8vdGhpcy5kM0NoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMuYmFyY2hhcnQsIHRoaXMucGFyc2VQZXJjZW50cygpLCB0aGlzLnByb3BzLmFyZWFDaGFydFdpZHRoKTtcblx0XHRcdC8vdGhpcy5kM1BpZUNoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMucGllY2hhcnQsIHRoaXMucGFyc2VQZXJjZW50cygpKTtcblx0XHRcdHRoaXMuZDNCYXJDaGFydC51cGRhdGUodGhpcy5yZWZzLmJhcmNoYXJ0LCB0aGlzLnBhcnNlUGVyY2VudHMoKSk7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VQZXJjZW50cyAoKSB7XG5cblx0XHRyZXR1cm4gKHRoaXMucHJvcHMuY2l0eURhdGEuaGFzUG9seWdvbnMpID8gW1xuXHRcdFx0eydncmFkZSc6ICdBJywgJ3BlcmNlbnQnOiB0aGlzLnByb3BzLmNpdHlEYXRhLmFyZWEuYSAvIHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS50b3RhbCB9LFxuXHRcdFx0eydncmFkZSc6ICdCJywgJ3BlcmNlbnQnOiB0aGlzLnByb3BzLmNpdHlEYXRhLmFyZWEuYiAvIHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS50b3RhbCB9LFxuXHRcdFx0eydncmFkZSc6ICdDJywgJ3BlcmNlbnQnOiB0aGlzLnByb3BzLmNpdHlEYXRhLmFyZWEuYyAvIHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS50b3RhbCB9LFxuXHRcdFx0eydncmFkZSc6ICdEJywgJ3BlcmNlbnQnOiB0aGlzLnByb3BzLmNpdHlEYXRhLmFyZWEuZCAvIHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS50b3RhbCB9XG5cdFx0XSA6IGZhbHNlO1xuXHR9XG5cblx0cmVuZGVyICgpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBcblx0XHRcdFx0Y2xhc3NOYW1lPSdjaXR5LXNuaXBwZXQnIFxuXHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNpdHlDbGljayB9IFxuXHRcdFx0XHRpZD17IHRoaXMucHJvcHMuY2l0eURhdGEuYWRfaWQgfVxuXHRcdFx0PlxuXHRcdFx0XHR7ICh0aGlzLnByb3BzLmNpdHlEYXRhLmhhc0FEcykgP1xuXHRcdFx0XHRcdDxoND5hcmVhIGRlc2NyaXB0aW9ucyBhdmFpbGFibGU8L2g0PiA6IFxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdH1cblx0XHRcdFx0eyAodGhpcy5wcm9wcy5jaXR5RGF0YS5oYXNQb2x5Z29ucykgP1xuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdiYXJjaGFydCcgcmVmPSdiYXJjaGFydCc+PC9kaXY+IDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdH1cblx0XHRcdFx0PGgzID57dGhpcy5wcm9wcy5jaXR5RGF0YS5uYW1lICsgKCh0aGlzLnByb3BzLmRpc3BsYXlTdGF0ZSkgPyAnLCAnICsgdGhpcy5wcm9wcy5jaXR5RGF0YS5zdGF0ZSA6ICcnKSB9PC9oMz5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J3BvcHVsYXRpb25TdGF0cyc+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5Qb3B1bGF0aW9uICgxOTQwKTo8L3NwYW4+IDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyB0aGlzLnByb3BzLmNpdHlEYXRhLnBvcHVsYXRpb25fMTk0MC50b0xvY2FsZVN0cmluZygpIH08L3NwYW4+PC9kaXY+XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJfcG9wdWxhdGlvbl9kZXRhaWxzKCkgfVxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyX3BvcHVsYXRpb25fZGV0YWlscyAoKSB7XG5cdFx0bGV0IENEID0gdGhpcy5wcm9wcy5jaXR5RGF0YSxcblx0XHRcdGFnZ3JlZ2F0ZWRfcG9wID0gQ0Qud2hpdGVfcG9wXzE5NDAgKyBDRC5ibGFja19wb3BfMTk0MCArIENELmFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTk0MCArIENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MDtcblx0XHRpZiAoYWdncmVnYXRlZF9wb3AgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcHJvcG9ydGlvbnMgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQnbGFiZWwnOiAnd2hpdGUnLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0Qud2hpdGVfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FmcmljYW4gQW1lcmljYW4nLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0QuYmxhY2tfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FzaWFuIEFtZXJpY2FuJyxcblx0XHRcdFx0XHQncHJvcG9ydGlvbic6IENELmFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQnbGFiZWwnOiAnTmF0aXZlIEFtZXJpY2FuJyxcblx0XHRcdFx0XHQncHJvcG9ydGlvbic6IENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXG5cdFx0XHRcdH1cblx0XHRcdF07XG5cdFx0XHRwcm9wb3J0aW9ucy5zb3J0KChhLGIpID0+IGEucHJvcG9ydGlvbiA8IGIucHJvcG9ydGlvbik7XG5cdFx0XHRyZXR1cm4gPHVsPlxuXHRcdFx0XHR7IHByb3BvcnRpb25zLm1hcCgocG9wKSA9PiB7XG5cdFx0XHRcdFx0aWYgKE1hdGgucm91bmQocG9wLnByb3BvcnRpb24gKiAxMDApICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gPGxpIGtleT17ICdwb3AxOTQwJyArIHBvcC5sYWJlbC5yZXBsYWNlKC8gL2csJycpIH0+eyBNYXRoLnJvdW5kKHBvcC5wcm9wb3J0aW9uICogMTAwKSArICclICcgKyBwb3AubGFiZWwgfTwvbGk+O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSl9XG5cdFx0XHRcdDwvdWw+O1xuXHRcdH1cblx0fVxuXG5cdGQzUGllQ2hhcnQgPSB7XG5cdFx0cmFkaXVzOiAzMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgZ3JhZGVTdGF0cykge1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGdyYWRlU3RhdHMpLmxlbmd0aCA9PT0gMCkgeyBcblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdHJldHVybjsgXG5cdFx0XHR9XG5cblx0XHRcdGxldCBzY29wZSA9IHRoaXM7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gWycjNDE4ZTQxJywgJyM0YTRhZTQnLCAnI2Y0ZjU3MCcsICcjZWIzZjNmJ11baV07IH07XG5cdFx0XHR2YXIgY29sb3JCb3JkZXIgPSBmdW5jdGlvbihpKSB7IHJldHVybiBbJyM0MThlNDEnLCAnIzRhNGFlNCcsICcjQTNBMzRCJywgJyNlYjNmM2YnXVtpXTsgfTtcblx0XHRcdHZhciBjb2xvckdyYWRlID0gZnVuY3Rpb24oZ3JhZGUpIHtcblx0XHRcdFx0bGV0IGdyYWRlQ29sb3JzID0geydBJzonIzQxOGU0MScsJ0InOicjNGE0YWU0JywnQyc6JyNmNGY1NzAnLCdEJzonI2ViM2YzZid9O1xuXHRcdFx0XHRyZXR1cm4gZ3JhZGVDb2xvcnNbZ3JhZGVdO1xuXHRcdFx0fTtcblxuXHRcdFx0bGV0IHBpZSA9IGQzLmxheW91dC5waWUoKVxuXHRcdFx0XHQudmFsdWUoKGQpID0+IGQucGVyY2VudClcblx0XHRcdFx0LnNvcnQobnVsbCk7XG5cdFx0XHR2YXIgYXJjID0gZDMuc3ZnLmFyYygpXG5cdFx0XHRcdCAgLm91dGVyUmFkaXVzKHNjb3BlLnJhZGl1cyAtIDEwKVxuXHRcdFx0XHQgIC5pbm5lclJhZGl1cygwKTtcblx0XHRcdHZhciBwZXJjZW50ID0gZDMuZm9ybWF0KCcsJScpO1xuXG5cdFx0XHRsZXQgdGhlQ2hhcnQgPSBkMy5zZWxlY3Qobm9kZSlcblx0XHRcdFx0LmFwcGVuZCgnc3ZnJylcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgc2NvcGUucmFkaXVzICogMilcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLnJhZGl1cyAqIDIpXG5cdFx0XHRcdC5hdHRyKCdpZCcsICdwaWVjaGFydCcpXG5cdFx0XHRcdC5hcHBlbmQoJ2cnKVxuXHRcdFx0XHQuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc2NvcGUucmFkaXVzICsgJywnICsgc2NvcGUucmFkaXVzICsgJyknKTtcblxuXHRcdFx0Ly8gdGhlQ2hhcnRcblx0XHRcdC8vICAgLnNlbGVjdEFsbCgncmVjdCcpXG5cdFx0XHQvLyAgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQvLyAgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0XHQvLyAgIC8vLmF0dHIoJ2NsYXNzJywgKGQsaSxqKSA9PiAnYXJlYUJhciBiYXJHcmFkZScgKyBkLnBlcmNlbnRzW2pdLmdyYWRlICsgJyByaW5nJyArIChpICsgMSkpXG5cdFx0XHQvLyAgIC5hdHRyKCdoZWlnaHQnLCBzY29wZS5IRUlHSFQpXG5cdFx0XHQvLyAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLndpZHRoKVxuXHRcdFx0Ly8gICAuYXR0cignb3BhY2l0eScsIC43KVxuXHRcdFx0Ly8gICAuYXR0cigneScsIDApXG5cdFx0XHQvLyAgIC5hdHRyKCd4JywgKGQpID0+IGQueCArIHNjb3BlLk1BUkdJTilcblx0XHRcdC8vICAgLmF0dHIoJ2ZpbGwnLCAoZCkgPT4gY29sb3JHcmFkZShkLmdyYWRlKSk7XG5cblx0XHRcdHRoZUNoYXJ0XG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3BhdGgnKVxuXHRcdFx0ICAuZGF0YShwaWUoZ3JhZGVTdGF0cykpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG5cdFx0XHQgIC5hdHRyKFwiZFwiLCBhcmMpXG5cdFx0XHQgIC5maWx0ZXIoKGQpID0+IGQuZGF0YS5wZXJjZW50ID4gMClcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpKSA9PiBjb2xvckdyYWRlKGQuZGF0YS5ncmFkZSkpXG5cdFx0XHQgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKVxuXHRcdFx0ICAuYXR0cignY2xhc3MnLCAoZCkgPT4gJ3NsaWNlR3JhZGUnICsgZC5kYXRhLmdyYWRlKVxuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0ZDMuc2VsZWN0KG5vZGUpLmh0bWwoJycpO1xuXHRcdH0gXG5cdH1cblxuXHRkM0JhckNoYXJ0ID0ge1xuXHRcdC8vIGxheW91dCBjb25zdGFudHNcblx0XHRXSURUSDogOTAsXG5cdFx0SEVJR0hUOiA0MCxcblx0XHRNQVJHSU46IDI0LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihub2RlLCBncmFkZVN0YXRzLCB3aWR0aCA9IGZhbHNlKSB7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoZ3JhZGVTdGF0cykubGVuZ3RoID09PSAwKSB7IFxuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0cmV0dXJuOyBcblx0XHRcdH1cblxuXHRcdFx0bGV0IHNjb3BlID0gdGhpcztcblxuXHRcdFx0aWYgKHdpZHRoKSB7XG5cdFx0XHRcdC8vc2NvcGUuV0lEVEggPSB3aWR0aDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbG9yID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gWycjNDE4ZTQxJywgJyM0YTRhZTQnLCAnI2Y0ZjU3MCcsICcjZWIzZjNmJ11baV07IH07XG5cdFx0XHR2YXIgY29sb3JCb3JkZXIgPSBmdW5jdGlvbihpKSB7IHJldHVybiBbJyM0MThlNDEnLCAnIzRhNGFlNCcsICcjQTNBMzRCJywgJyNlYjNmM2YnXVtpXTsgfTtcblx0XHRcdHZhciBjb2xvckdyYWRlID0gZnVuY3Rpb24oZ3JhZGUpIHtcblx0XHRcdFx0bGV0IGdyYWRlQ29sb3JzID0geydBJzonIzQxOGU0MScsJ0InOicjNGE0YWU0JywnQyc6JyNDQ0NDMDAnLCdEJzonI2ViM2YzZid9O1xuXHRcdFx0XHRyZXR1cm4gZ3JhZGVDb2xvcnNbZ3JhZGVdO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBlcmNlbnQgPSBkMy5mb3JtYXQoJywlJyk7XG5cdFx0XHR2YXIgd2lkdGggPSBkMy5zY2FsZS5saW5lYXIoKVxuXHRcdFx0XHQucmFuZ2VSb3VuZChbMCwgc2NvcGUuV0lEVEhdKTtcblxuXHRcdFx0bGV0IHggPSAwO1xuXHRcdFx0Z3JhZGVTdGF0cy5mb3JFYWNoKChkLCBpKSA9PiB7XG5cdFx0XHRcdGdyYWRlU3RhdHNbaV0gPSB7IHg6IHgsIHdpZHRoOiB3aWR0aChkLnBlcmNlbnQpLCBwZXJjZW50OiBkLnBlcmNlbnQsIGdyYWRlOiBkLmdyYWRlIH07XG5cdFx0XHRcdHggKz0gd2lkdGgoZC5wZXJjZW50KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgdGhlQ2hhcnQgPSBkMy5zZWxlY3Qobm9kZSlcblx0XHRcdFx0LmFwcGVuZCgnc3ZnJylcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgc2NvcGUuV0lEVEgpXG5cdFx0XHRcdC5hdHRyKCdoZWlnaHQnLCBzY29wZS5IRUlHSFQgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHRcdC5hdHRyKCdpZCcsICdiYXJjaGFydCcpXG5cdFx0XHRcdC5zZWxlY3RBbGwoJ2cnKVxuXHRcdFx0XHQuZGF0YShncmFkZVN0YXRzKVxuXHRcdFx0XHQuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcblxuXHRcdFx0dGhlQ2hhcnRcblx0XHRcdCAgLnNlbGVjdEFsbCgncmVjdCcpXG5cdFx0XHQgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0XHQgIC8vLmF0dHIoJ2NsYXNzJywgKGQsaSxqKSA9PiAnYXJlYUJhciBiYXJHcmFkZScgKyBkLnBlcmNlbnRzW2pdLmdyYWRlICsgJyByaW5nJyArIChpICsgMSkpXG5cdFx0XHQgIC5hdHRyKCdoZWlnaHQnLCBzY29wZS5IRUlHSFQvNCAtIDQpXG5cdFx0XHQgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLndpZHRoKVxuXHRcdFx0ICAuYXR0cignb3BhY2l0eScsIC43KVxuXHRcdFx0ICAuYXR0cigneScsIChkLGkpID0+IHNjb3BlLk1BUkdJTiArIHNjb3BlLkhFSUdIVC80ICogaSlcblx0XHRcdCAgLmF0dHIoJ3gnLCAoZCkgPT4gc2NvcGUuV0lEVEggLSBkLndpZHRoKVxuXHRcdFx0ICAuYXR0cignZmlsbCcsIChkKSA9PiBjb2xvckdyYWRlKGQuZ3JhZGUpKTtcblxuXHRcdFx0Ly8gdGhlQ2hhcnRcblx0XHRcdC8vICAgLnNlbGVjdEFsbCgndGV4dCcpXG5cdFx0XHQvLyAgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQvLyAgIC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG5cdFx0XHQvLyAgIC5hdHRyKCd4JywgKGQpID0+IGQueCArIGQud2lkdGggLyAyICsgc2NvcGUuTUFSR0lOKVxuXHRcdFx0Ly8gICAuYXR0cigneScsIDExKVxuXHRcdFx0Ly8gICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcblx0XHRcdC8vICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKVxuXHRcdFx0Ly8gICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxuXHRcdFx0Ly8gICAuYXR0cignZmlsbCcsIChkKSA9PiAoZC5ncmFkZSA9PSAnQycpID8gJ2JsYWNrJyA6ICd3aGl0ZScpXG5cdFx0XHQvLyAgIC50ZXh0KChkKSA9PiAoZC5wZXJjZW50ID4gMC4wMykgPyBwZXJjZW50KGQucGVyY2VudCkgOiAnJyk7XG5cdFx0fSwgXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0ZDMuc2VsZWN0KG5vZGUpLmh0bWwoJycpO1xuXHRcdH0gXG5cdH1cblxuXHRkM0NoYXJ0ID0ge1xuXHRcdC8vIGxheW91dCBjb25zdGFudHNcblx0XHRXSURUSDogKHRoaXMucHJvcHMgJiYgdGhpcy5wcm9wcy5hcmVhQ2hhcnRXaWR0aCkgPyB0aGlzLnByb3BzLmFyZWFDaGFydFdpZHRoIDogMjUwLFxuXHRcdEhFSUdIVDogMTUsXG5cdFx0TUFSR0lOOiAyMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgZ3JhZGVTdGF0cywgd2lkdGggPSBmYWxzZSkge1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGdyYWRlU3RhdHMpLmxlbmd0aCA9PT0gMCkgeyBcblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdHJldHVybjsgXG5cdFx0XHR9XG5cblx0XHRcdGxldCBzY29wZSA9IHRoaXM7XG5cblx0XHRcdGlmICh3aWR0aCkge1xuXHRcdFx0XHQvL3Njb3BlLldJRFRIID0gd2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb2xvciA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFsnIzQxOGU0MScsICcjNGE0YWU0JywgJyNmNGY1NzAnLCAnI2ViM2YzZiddW2ldOyB9O1xuXHRcdFx0dmFyIGNvbG9yQm9yZGVyID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gWycjNDE4ZTQxJywgJyM0YTRhZTQnLCAnI0EzQTM0QicsICcjZWIzZjNmJ11baV07IH07XG5cdFx0XHR2YXIgY29sb3JHcmFkZSA9IGZ1bmN0aW9uKGdyYWRlKSB7XG5cdFx0XHRcdGxldCBncmFkZUNvbG9ycyA9IHsnQSc6JyM0MThlNDEnLCdCJzonIzRhNGFlNCcsJ0MnOicjZjRmNTcwJywnRCc6JyNlYjNmM2YnfTtcblx0XHRcdFx0cmV0dXJuIGdyYWRlQ29sb3JzW2dyYWRlXTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBwZXJjZW50ID0gZDMuZm9ybWF0KCcsJScpO1xuXHRcdFx0dmFyIHdpZHRoID0gZDMuc2NhbGUubGluZWFyKClcblx0XHRcdFx0LnJhbmdlUm91bmQoWzAsIHNjb3BlLldJRFRIXSk7XG5cblx0XHRcdGxldCB4ID0gMDtcblx0XHRcdGdyYWRlU3RhdHMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuXHRcdFx0XHRncmFkZVN0YXRzW2ldID0geyB4OiB4LCB3aWR0aDogd2lkdGgoZC5wZXJjZW50KSwgcGVyY2VudDogZC5wZXJjZW50LCBncmFkZTogZC5ncmFkZSB9O1xuXHRcdFx0XHR4ICs9IHdpZHRoKGQucGVyY2VudCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0bGV0IHRoZUNoYXJ0ID0gZDMuc2VsZWN0KG5vZGUpXG5cdFx0XHRcdC5hcHBlbmQoJ3N2ZycpXG5cdFx0XHRcdC5hdHRyKCd3aWR0aCcsIHNjb3BlLldJRFRIICsgc2NvcGUuTUFSR0lOKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0Jywgc2NvcGUuSEVJR0hUKVxuXHRcdFx0XHQuYXR0cignaWQnLCAnYmFyY2hhcnQnKVxuXHRcdFx0XHQuc2VsZWN0QWxsKCdnJylcblx0XHRcdFx0LmRhdGEoZ3JhZGVTdGF0cylcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCdnJyk7XG5cblx0XHRcdHRoZUNoYXJ0XG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuXHRcdFx0ICAuZGF0YShncmFkZVN0YXRzKVxuXHRcdFx0ICAuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuXHRcdFx0ICAvLy5hdHRyKCdjbGFzcycsIChkLGksaikgPT4gJ2FyZWFCYXIgYmFyR3JhZGUnICsgZC5wZXJjZW50c1tqXS5ncmFkZSArICcgcmluZycgKyAoaSArIDEpKVxuXHRcdFx0ICAuYXR0cignaGVpZ2h0Jywgc2NvcGUuSEVJR0hUKVxuXHRcdFx0ICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZC53aWR0aClcblx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAuNylcblx0XHRcdCAgLmF0dHIoJ3knLCAwKVxuXHRcdFx0ICAuYXR0cigneCcsIChkKSA9PiBkLnggKyBzY29wZS5NQVJHSU4pXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IGNvbG9yR3JhZGUoZC5ncmFkZSkpO1xuXG5cdFx0XHR0aGVDaGFydFxuXHRcdFx0ICAuc2VsZWN0QWxsKCd0ZXh0Jylcblx0XHRcdCAgLmRhdGEoZ3JhZGVTdGF0cylcblx0XHRcdCAgLmVudGVyKCkuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdCAgLmF0dHIoJ3gnLCAoZCkgPT4gZC54ICsgZC53aWR0aCAvIDIgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHQgIC5hdHRyKCd5JywgMTEpXG5cdFx0XHQgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuXHRcdFx0ICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXG5cdFx0XHQgIC5hdHRyKCdmb250LXNpemUnLCAnMTBweCcpXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IChkLmdyYWRlID09ICdDJykgPyAnYmxhY2snIDogJ3doaXRlJylcblx0XHRcdCAgLnRleHQoKGQpID0+IChkLnBlcmNlbnQgPiAwLjAzKSA/IHBlcmNlbnQoZC5wZXJjZW50KSA6ICcnKTtcblx0XHR9LCBcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRkMy5zZWxlY3Qobm9kZSkuaHRtbCgnJyk7XG5cdFx0fSBcblx0fVxufSIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgQXBwQWN0aW9ucyB9IGZyb20gJy4uL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXR5U3RhdHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRyaW5nU3RhdHM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLmJvb2xdKSxcblx0XHRncmFkZVN0YXRzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5ib29sXSksXG5cdFx0YXJlYVNlbGVjdGVkOiBQcm9wVHlwZXMuZnVuYyxcblx0XHRhcmVhVW5zZWxlY3RlZDogUHJvcFR5cGVzLmZ1bmMsXG5cdFx0Z3JhZGVTZWxlY3RlZDogUHJvcFR5cGVzLmZ1bmMsXG5cdFx0Z3JhZGVVbnNlbGVjdGVkOiBQcm9wVHlwZXMuZnVuYyxcblx0XHR0b2dnbGVCdXJnZXNzRGlhZ3JhbTogUHJvcFR5cGVzLmZ1bmMsXG5cdFx0YnVyZ2Vzc0RpYWdyYW1WaXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblx0XHRjaXR5RGF0YTogUHJvcFR5cGVzLm9iamVjdFxuXHR9O1xuXG5cdC8vIChpbnN0ZWFkIG9mIEVTNS1zdHlsZSBnZXREZWZhdWx0UHJvcHMpXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0bmFtZTogJycsXG5cdFx0cmluZ1N0YXRzOiB7XG5cdFx0XHQxOiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAnZGVuc2l0eSc6IDB9LFxuXHRcdFx0MjogeydBJzogMCwgJ0InOiAwLCAnQyc6IDAsICdEJzogMCwgJ2RlbnNpdHknOiAwfSxcblx0XHRcdDM6IHsnQSc6IDAsICdCJzogMCwgJ0MnOiAwLCAnRCc6IDAsICdkZW5zaXR5JzogMH0sXG5cdFx0XHQ0OiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAnZGVuc2l0eSc6IDB9XG5cdFx0fSxcblx0XHRncmFkZVN0YXRzOiB7XG5cdFx0XHQnQSc6eydhcmVhJzowLCdwZXJjZW50JzowfSxcblx0XHRcdCdCJzp7J2FyZWEnOjAsJ3BlcmNlbnQnOjB9LFxuXHRcdFx0J0MnOnsnYXJlYSc6MCwncGVyY2VudCc6MH0sXG5cdFx0XHQnRCc6eydhcmVhJzowLCdwZXJjZW50JzowfSxcblx0XHR9XG5cdH07XG5cblx0Y29uc3RydWN0b3IgKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHR9O1xuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuXHRcdGlmIChuZXh0UHJvcHMuaGFzQURzICE9PSB0aGlzLnByb3BzLmhhc0FEcykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdC8vIGRvbid0IGtub3cgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5LCBidXQgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGluZyBvbiBtb3VzZW92ZXItLXRoaXMgcHJldmVudHMgdGhhdC5cblx0XHRyZXR1cm4gKG5leHRQcm9wcy5idXJnZXNzRGlhZ3JhbVZpc2libGUgIT09IHRoaXMucHJvcHMuYnVyZ2Vzc0RpYWdyYW1WaXNpYmxlIHx8IG5leHRQcm9wcy5yaW5nU3RhdHMgIT09IHRoaXMucHJvcHMucmluZ1N0YXRzKTtcblx0fTtcblx0XG5cdGNvbXBvbmVudFdpbGxNb3VudCAoKSB7fTtcblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLmQzTmVzdGVkUGllQ2hhcnQub25Ib3ZlciA9IHRoaXMucHJvcHMuYXJlYVNlbGVjdGVkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0Lm9uSG92ZXJPdXQgPSB0aGlzLnByb3BzLmFyZWFVbnNlbGVjdGVkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0Lm9uR3JhZGVIb3ZlciA9IHRoaXMucHJvcHMuZ3JhZGVTZWxlY3RlZC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZDNOZXN0ZWRQaWVDaGFydC5vbkdyYWRlSG92ZXJPdXQgPSB0aGlzLnByb3BzLmdyYWRlVW5zZWxlY3RlZC5iaW5kKHRoaXMpO1xuXHRcdGlmICh0aGlzLnByb3BzLnJpbmdTdGF0cykge1xuXHRcdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMuY29udGVudCwgdGhpcy5wcm9wcy5yaW5nU3RhdHMsIHRoaXMucHJvcHMuZ3JhZGVTdGF0cyk7XG5cdFx0fVxuXHR9XG5cblx0Y29tcG9uZW50RGlkVXBkYXRlICgpIHtcblx0XHR0aGlzLmQzTmVzdGVkUGllQ2hhcnQuZGVzdHJveSh0aGlzLnJlZnMuY29udGVudCk7XG5cdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0Lm9uSG92ZXIgPSB0aGlzLnByb3BzLmFyZWFTZWxlY3RlZC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZDNOZXN0ZWRQaWVDaGFydC5vbkhvdmVyT3V0ID0gdGhpcy5wcm9wcy5hcmVhVW5zZWxlY3RlZC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZDNOZXN0ZWRQaWVDaGFydC5vbkdyYWRlSG92ZXIgPSB0aGlzLnByb3BzLmdyYWRlU2VsZWN0ZWQuYmluZCh0aGlzKTtcblx0XHR0aGlzLmQzTmVzdGVkUGllQ2hhcnQub25HcmFkZUhvdmVyT3V0ID0gdGhpcy5wcm9wcy5ncmFkZVVuc2VsZWN0ZWQuYmluZCh0aGlzKTtcblx0XHRpZiAodGhpcy5wcm9wcy5yaW5nU3RhdHMpIHtcblx0XHRcdHRoaXMuZDNOZXN0ZWRQaWVDaGFydC51cGRhdGUodGhpcy5yZWZzLmNvbnRlbnQsIHRoaXMucHJvcHMucmluZ1N0YXRzLCB0aGlzLnByb3BzLmdyYWRlU3RhdHMpO1xuXHRcdH1cblx0fVxuXG5cdGFyZWFIb3ZlciAoc2VsZWN0ZWRSaW5nSWQsIHNlbGVjdGVkR3JhZGUpIHtcblx0XHRBcHBBY3Rpb25zLnJpbmdBcmVhU2VsZWN0ZWQoc2VsZWN0ZWRSaW5nSWQsIHNlbGVjdGVkR3JhZGUpO1xuXHR9XG5cblx0Z2V0UG9wTGFiZWwgKGtleSkge1xuXHRcdGNvbnN0IGxhYmVscyA9IHtcblx0XHRcdHdoaXRlOiAnd2hpdGUnLFxuXHRcdFx0YmxhY2s6ICdBZnJpY2FuIEFtZXJpY2FuJyxcblx0XHRcdGFzaWFuQW1lcmljYW46ICdBc2lhbiBBbWVyaWNhbicsXG5cdFx0XHRuYXRpdmVBbWVyaWNhbjogJ05hdGl2ZSBBbWVyaWNhbidcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWxzW2tleV07XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXG5cdFx0bGV0IGJ1cmdlc3NDbGFzc05hbWUgPSAodGhpcy5wcm9wcy5idXJnZXNzRGlhZ3JhbVZpc2libGUpID8gJycgOiAnaGlkZGVuJyxcblx0XHRcdHBvcHVsYXRpb24xOTMwID0gKHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTMwICYmIHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTMwICE9PSAwKSA/IHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTMwLnRvTG9jYWxlU3RyaW5nKCkgOiBudWxsLFxuXHRcdFx0cG9wdWxhdGlvbjE5NDAgPSAodGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5NDAgJiYgdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5NDAgIT09IDApID8gdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5NDAudG9Mb2NhbGVTdHJpbmcoKSA6IG51bGwsXG5cdFx0XHRhcmVhID0gKHRoaXMucHJvcHMuYXJlYSkgPyBNYXRoLnJvdW5kKHRoaXMucHJvcHMuYXJlYSAqIDEwMCkgLyAxMDAgKyAnc3EgbWknIDogJyc7XG5cblx0XHRsZXQgQ0QgPSB0aGlzLnByb3BzLmNpdHlEYXRhLFxuXHRcdFx0YWdncmVnYXRlZF9wb3BfMTkzMCA9IENELndoaXRlX3BvcF8xOTMwICsgQ0QuYmxhY2tfcG9wXzE5MzAgKyBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwICsgQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwLFxuXHRcdFx0YWdncmVnYXRlZF9wb3BfMTk0MCA9IENELndoaXRlX3BvcF8xOTQwICsgQ0QuYmxhY2tfcG9wXzE5NDAgKyBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTQwICsgQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTQwLFxuXHRcdFx0cG9wU3RhdHMgPSB7XG5cdFx0XHRcdDE5MzA6IHtcblx0XHRcdFx0XHQvL3RvdGFsOiAodGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgJiYgdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgIT09IDApID8gdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgOiBudWxsLFxuXHRcdFx0XHRcdHdoaXRlOiBDRC53aGl0ZV9wb3BfMTkzMCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5MzAsXG5cdFx0XHRcdFx0YmxhY2s6IENELmJsYWNrX3BvcF8xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMCxcblx0XHRcdFx0XHRhc2lhbkFtZXJpY2FuOiBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMCxcblx0XHRcdFx0XHRuYXRpdmVBbWVyaWNhbjogQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQxOTQwOiB7XG5cdFx0XHRcdFx0Ly90b3RhbDogKHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTQwICYmIHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTQwICE9PSAwKSA/IHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTQwIDogbnVsbCxcblx0XHRcdFx0XHR3aGl0ZTogQ0Qud2hpdGVfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcF8xOTQwLFxuXHRcdFx0XHRcdGJsYWNrOiBDRC5ibGFja19wb3BfMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5NDAsXG5cdFx0XHRcdFx0YXNpYW5BbWVyaWNhbjogQ0QuYXNpYW5fcGFjaWZpY19pbHNsYW5kZXJfMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5NDAsXG5cdFx0XHRcdFx0bmF0aXZlQW1lcmljYW46IENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5NDBcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGxldCBvcmRlcmVkS2V5cyA9IE9iamVjdC5rZXlzKHBvcFN0YXRzWzE5NDBdKS5zb3J0KChhLGIpID0+IChwb3BTdGF0c1sxOTQwXVthXSA8IHBvcFN0YXRzWzE5NDBdW2JdKSk7XG5cblxuXHRcdFx0XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPSdjaXR5U3RhdHMnPlxuXHRcdFx0XHQ8aDI+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLm5hbWUgKyAnLCAnfVxuXHRcdFx0XHRcdDxzcGFuIFxuXHRcdFx0XHRcdFx0Ly9vbkNsaWNrPXsgdGhpcy5vblN0YXRlU2VsZWN0ZWQgfSBcblx0XHRcdFx0XHRcdGlkPXsgdGhpcy5wcm9wcy5zdGF0ZSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLnN0YXRlIH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nZG93bmxvYWRpY29uJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkRvd25sb2FkQ2xpY2tlZCB9PjwvZGl2PlxuXHRcdFx0XHQ8L2gyPlxuXG5cdFx0XHRcdHsgKHRoaXMucHJvcHMuaGFzQURzKSA/XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2FkSW5zdHJ1Y3Rpb25zJz5jbGljayBvbiBuZWlnaGJvcmhvb2RzIG9uIHRoZSBtYXAgdG8gcmVhZCB0aGVpciBhcmVhIGRlc2NyaXB0aW9uPC9kaXY+IDogXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2FkSW5zdHJ1Y3Rpb25zJz5hcmVhIGRlc2NyaXB0aW9ucyBhcmVuJ3QgYXZhaWxhYmxlIGZvciB0aGlzIGNpdHksIGJ1dCB3aWxsIGJlIHNvb248L2Rpdj5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdDx0YWJsZSBjbGFzc05hbWU9J3BvcHVsYXRpb24tc3RhdHMnPlxuXHRcdFx0XHRcdDx0Ym9keT5cblx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0PHRoPjwvdGg+XG5cdFx0XHRcdFx0XHRcdDx0aD4xOTMwPC90aD5cblx0XHRcdFx0XHRcdFx0PHRoPjE5NDA8L3RoPlxuXHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0PHRkPlBvcHVsYXRpb248L3RkPlxuXHRcdFx0XHRcdFx0XHQ8dGQgY2xhc3NOYW1lPSd0b3RhbCcga2V5PSd0b3RhbDE5MzAnPnsgcG9wdWxhdGlvbjE5MzAgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDx0ZCBjbGFzc05hbWU9J3RvdGFsJyBrZXk9J3RvdGFsMTk0MCc+eyBwb3B1bGF0aW9uMTk0MCB9PC90ZD5cblx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHR7IG9yZGVyZWRLZXlzLm1hcChwb3BrZXkgPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKChwb3BTdGF0c1sxOTMwXVtwb3BrZXldID4gMC4wMSB8fCBwb3BTdGF0c1sxOTMwXVtwb3BrZXldID4gMC4wMSkgP1xuXHRcdFx0XHRcdFx0XHRcdDx0ciBrZXk9eyBwb3BrZXkgfT5cblx0XHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMuZ2V0UG9wTGFiZWwocG9wa2V5KSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDx0ZD57IChNYXRoLnJvdW5kKHBvcFN0YXRzWzE5MzBdW3BvcGtleV0gKiAxMDAwKSAvIDEwKSArICclJyB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDx0ZD57IChNYXRoLnJvdW5kKHBvcFN0YXRzWzE5NDBdW3BvcGtleV0gKiAxMDAwKSAvIDEwKSArICclJyB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8L3RyPiA6XG5cdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHQ8L3Rib2R5PlxuXHRcdFx0XHQ8L3RhYmxlPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSduZXN0ZWRwaWVjaGFydCc+XG5cdFx0XHRcdFx0PGJ1dHRvbiBcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT0naW50cm8tYnV0dG9uJyBcblx0XHRcdFx0XHRcdCBcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2ljb24gaW5mbycgaWQ9J2J1cmdlc3MnIG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9wZW5CdXJnZXNzIH0gLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHR7ICh0aGlzLnByb3BzLnJpbmdTdGF0cykgP1xuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbnRlbnQnIHJlZj0nY29udGVudCc+PC9kaXY+IDpcblx0XHRcdFx0XHRcdDxwPkFyZWEgZGVzY3JpcHRpb25zIGFyZSBub3QgeWV0IGF2YWlsYWJsZSBidXQgd2lsbCBiZSBldmVudHVhbGx5LjwvcD5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdGQzTmVzdGVkUGllQ2hhcnQgPSB7XG5cdFx0Ly8gbGF5b3V0IGNvbnN0YW50c1xuXHRcdEhFQURFUjogMjUsXG5cdFx0V0lEVEg6IDI1MCxcblx0XHRESUFNRVRFUjogMjUwLCAvLyBvZiB0aGUgZG9udXRcblx0XHRTVEFUU0hFSUdIVDogMTgsXG5cdFx0RE9OVVRXSURUSDogMzUsXG5cdFx0TUFSR0lOOiAxMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgcmluZ3N0YXRzLCBncmFkZVN0YXRzKSB7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMocmluZ3N0YXRzKS5sZW5ndGggPT09IDApIHsgXG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRyZXR1cm47IFxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgc2NvcGUgPSB0aGlzO1x0XG5cdFx0XHR2YXIgY29sb3IgPSBmdW5jdGlvbihpKSB7IHJldHVybiBbJyM0MThlNDEnLCAnIzRhNGFlNCcsICcjZmZkZjAwJywgJyNlYjNmM2YnXVtpXTsgfTtcblx0XHRcdHZhciBjb2xvckJvcmRlciA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFsnIzQxOGU0MScsICcjNGE0YWU0JywgJyNmZmRmMDAnLCAnI2ViM2YzZiddW2ldOyB9O1xuXHRcdFx0dmFyIGNvbG9yR3JhZGUgPSBmdW5jdGlvbihncmFkZSkge1xuXHRcdFx0XHRsZXQgZ3JhZGVDb2xvcnMgPSB7J0EnOicjNDE4ZTQxJywnQic6JyM0YTRhZTQnLCdDJzonI2ZmZGYwMCcsJ0QnOicjZWIzZjNmJ307XG5cdFx0XHRcdHJldHVybiBncmFkZUNvbG9yc1tncmFkZV07XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcGllID0gZDMubGF5b3V0LnBpZSgpXG5cdFx0XHRcdC52YWx1ZSgoZCkgPT4gZC5wZXJjZW50KVxuXHRcdFx0XHQuc29ydChudWxsKTtcblx0XHRcdHZhciBhcmMgPSBkMy5zdmcuYXJjKClcblx0XHRcdFx0LmlubmVyUmFkaXVzKChkKSA9PiAoZC5kYXRhLnJpbmdJZCAtIDEuNSkgKiBzY29wZS5ET05VVFdJRFRIKVxuXHRcdFx0XHQub3V0ZXJSYWRpdXMoKGQpID0+IChkLmRhdGEucmluZ0lkIC0gMC41KSAqIHNjb3BlLkRPTlVUV0lEVEgpO1xuXHRcdFx0dmFyIGFyY0JvcmRlciA9IGQzLnN2Zy5hcmMoKVxuXHRcdFx0XHQuaW5uZXJSYWRpdXMoKGQpID0+IChkLmRhdGEucmluZ0lkIC0gMC41KSAqIHNjb3BlLkRPTlVUV0lEVEgpXG5cdFx0XHRcdC5vdXRlclJhZGl1cygoZCkgPT4gKGQuZGF0YS5yaW5nSWQgLSAwLjUpICogc2NvcGUuRE9OVVRXSURUSCk7XG5cdFx0XHR2YXIgcGVyY2VudCA9IGQzLmZvcm1hdCgnLCUnKTtcblx0XG5cdFx0XHQvLyA8Zz4gZm9yIGVhY2ggcmluZ1xuXHRcdFx0bGV0IHJpbmdOb2RlcyA9IGQzLnNlbGVjdChub2RlKVxuXHRcdFx0XHQuYXBwZW5kKCdzdmcnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCBzY29wZS5XSURUSClcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLkhFQURFUiAqIDIgKyBzY29wZS5NQVJHSU4gKiA1ICsgc2NvcGUuU1RBVFNIRUlHSFQgKyBzY29wZS5ESUFNRVRFUilcblx0XHRcdFx0LmF0dHIoJ2lkJywgJ3BpZWNoYXJ0Jylcblx0XHRcdFx0LnNlbGVjdEFsbCgnZycpXG5cdFx0XHRcdC5kYXRhKHJpbmdzdGF0cylcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCdnJyk7XG5cdFx0XHRcdC8vLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChzY29wZS5XSURUSCAvIDIpICsgJywnICsgKHNjb3BlLkhFSUdIVCAvIDIgKyA1MCkgKyAnKScpO1xuXHRcblx0XHRcdC8vIHBhdGggZm9yIGVhY2ggcGllIHBpZWNlXG5cdFx0XHRsZXQgYnVyZ2VzcyA9IHJpbmdOb2Rlc1xuXHRcdFx0ICAuc2VsZWN0QWxsKCdwYXRoJylcblx0XHRcdCAgLmRhdGEoKGQpID0+IHBpZShkLnBlcmNlbnRzKSlcblx0XHRcdCAgLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcblx0XHRcdCAgLmZpbHRlcigoZCkgPT4gZC5kYXRhLnBlcmNlbnQgPiAwKVxuXHRcdFx0ICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHNjb3BlLldJRFRIIC8gMikgKyAnLCcgKyAoc2NvcGUuSEVBREVSICogMiArIHNjb3BlLk1BUkdJTiAqIDUgKyBzY29wZS5TVEFUU0hFSUdIVCArIHNjb3BlLkRJQU1FVEVSIC8gMikgKyAnKScpXG5cdFx0XHQgIC5hdHRyKCdkJywgYXJjKVxuXHRcdFx0ICAuYXR0cignZmlsbCcsIChkLGkpID0+IGNvbG9yR3JhZGUoZC5kYXRhLmdyYWRlKSlcblx0XHRcdCAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIChkKSA9PiBkLmRhdGEub3BhY2l0eSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZScsIChkLGkpID0+IGNvbG9yR3JhZGUoZC5kYXRhLmdyYWRlKSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApXG5cdFx0XHQgIC5hdHRyKCdkYXRhLW9wYWNpdHknLCAoZCkgPT4gZC5kYXRhLm9wYWNpdHkpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnc2xpY2VHcmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHQgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHQgIGQzLnNlbGVjdCh0aGlzKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oMjAwMClcblx0XHRcdFx0ICBcdC5hdHRyKCdmaWxsLW9wYWNpdHknLCAxKTtcblx0XHRcdFx0ICBkMy5zZWxlY3QoJyNyaW5nJyArIGQuZGF0YS5yaW5nSWQgKyAnZ3JhZGUnICsgZC5kYXRhLmdyYWRlKVxuXHRcdFx0XHQgICAgLmF0dHIoJ29wYWNpdHknLCAxKTtcblx0XHRcdFx0ICBkMy5zZWxlY3RBbGwoJy5hcmVhQmFyJylcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0LmR1cmF0aW9uKDIwMDApXG5cdFx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLlNUQVRTSEVJR0hUICogMC41KVxuXHRcdFx0XHRcdC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSICsgc2NvcGUuTUFSR0lOICsgc2NvcGUuU1RBVFNIRUlHSFQgKiAwLjI1KVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgLjI1KTtcblx0XHRcdFx0ICBkMy5zZWxlY3RBbGwoJy5iYXJHcmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHRcdFx0LmZpbHRlcignLnJpbmcnICsgZC5kYXRhLnJpbmdJZClcblx0XHRcdFx0XHQuYXR0cignaGVpZ2h0Jywgc2NvcGUuU1RBVFNIRUlHSFQpXG5cdFx0XHRcdFx0LmF0dHIoJ3knLCBzY29wZS5IRUFERVIgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5kdXJhdGlvbigyMDAwKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMSk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcuYmFyR3JhZGVQZXJjZW50JyArIGQuZGF0YS5ncmFkZSlcblx0XHRcdFx0XHQuZmlsdGVyKCcucmluZycgKyBkLmRhdGEucmluZ0lkKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oNTAwKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMSk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcub3ZlcmFsbFBlcmNlbnQnKVxuXHRcdFx0XHQgIFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMCk7XG5cdFx0XHRcdCAgc2NvcGUub25Ib3ZlcihkLmRhdGEucmluZ0lkLCBkLmRhdGEuZ3JhZGUpO1xuXHRcdFx0ICB9KVxuXHRcdFx0ICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHQgIHNjb3BlLm9uSG92ZXJPdXQoKTtcblx0XHRcdFx0ICBkMy5zZWxlY3QodGhpcylcblx0XHRcdFx0ICAgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuYXR0cignZmlsbC1vcGFjaXR5JywgKGQpID0+IGQuZGF0YS5vcGFjaXR5KTtcblx0XHRcdFx0ICBkMy5zZWxlY3QoJyNyaW5nJyArIGQuZGF0YS5yaW5nSWQgKyAnZ3JhZGUnICsgZC5kYXRhLmdyYWRlIClcblx0XHRcdFx0XHQuYXR0cignb3BhY2l0eScsIDApO1xuXHRcdFx0XHQgIGQzLnNlbGVjdEFsbCgnLmFyZWFCYXInKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oMjAwMClcblx0XHRcdFx0XHQuYXR0cignaGVpZ2h0Jywgc2NvcGUuU1RBVFNIRUlHSFQpXG5cdFx0XHRcdFx0LmF0dHIoJ3knLCBzY29wZS5IRUFERVIgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHRcdFx0LmF0dHIoJ29wYWNpdHknLCAuNyk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcuYXJlYUJhclBlcmNlbnQnKVxuXHRcdFx0XHQgIFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMCk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcub3ZlcmFsbFBlcmNlbnQnKVxuXHRcdFx0XHQgIFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMSk7XG5cdFx0XHQgIH0pO1x0XG5cblx0XHRcdC8vIGFkZCB0aGluIHN0cm9rZSBsaW5lIGZvciBlYWNoIHNsaWNlIG9mIHBpZXNcblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuc2VsZWN0QWxsKCdwYXRoLmJvcmRlcicpXG5cdFx0XHQgIC5kYXRhKChkKSA9PiBwaWUoZC5wZXJjZW50cykgKVxuXHRcdFx0ICAuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuXHRcdFx0ICAuY2xhc3NlZCgnYm9yZGVyJywgdHJ1ZSlcblx0XHRcdCAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChzY29wZS5XSURUSCAvIDIpICsgJywnICsgKHNjb3BlLkhFQURFUiAqIDIgKyBzY29wZS5NQVJHSU4gKiA1ICsgc2NvcGUuU1RBVFNIRUlHSFQgKyBzY29wZS5ESUFNRVRFUiAvIDIpICsgJyknKVxuXHRcdFx0ICAuYXR0cignZCcsIGFyY0JvcmRlcilcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpKSA9PiBjb2xvcihpKSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZScsIChkLGkpID0+IGNvbG9yQm9yZGVyKGkpKVxuXHRcdFx0ICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC4yNSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZS1vcGFjaXR5JywgMC43KTtcblxuXHRcdFx0Ly8gYSB0cmFucGFyZW50IGJvcmRlciBhcm91bmQgZWFjaCBzbGljZVxuXHRcdFx0Ly8gaXQncyBtYWRlIG9wYXF1ZSBmb3IgaGlnaGxpZ2h0aW5nIGFuZCB0aHVzIG5lZWRzXG5cdFx0XHQvLyB0byBiZSBhZGRlZCBhZnRlciB0aGUgc2xpY2UgYW5kIHRoZSBib3JkZXJcblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuc2VsZWN0QWxsKCdwYXRocy5zbGljZUJvcmRlcicpXG5cdFx0XHQgIC5kYXRhKChkKSA9PiBwaWUoZC5wZXJjZW50cykpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG5cdFx0XHQgIC5maWx0ZXIoKGQpID0+IGQuZGF0YS5wZXJjZW50ID4gMClcblx0XHRcdCAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChzY29wZS5XSURUSCAvIDIpICsgJywnICsgKHNjb3BlLkhFQURFUiAqIDIgKyBzY29wZS5NQVJHSU4gKiA1ICsgc2NvcGUuU1RBVFNIRUlHSFQgKyBzY29wZS5ESUFNRVRFUiAvIDIpICsgJyknKVxuXHRcdFx0ICAuYXR0cignZCcsIGFyYylcblx0XHRcdCAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDApXG5cdFx0XHQgIC5hdHRyKCdzdHJva2UnLCAoZCxpKSA9PiBjb2xvckdyYWRlKGQuZGF0YS5ncmFkZSkpXG5cdFx0XHQgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKVxuXHRcdFx0ICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnc2xpY2VCb3JkZXIgZ3JhZGUnICsgZC5kYXRhLmdyYWRlKTtcblxuXHRcdFx0Ly8gYWRkIHRleHQgZm9yIGVhY2ggc2xpY2Ugb2YgcGllXG5cdFx0XHRyaW5nTm9kZXNcblx0XHRcdCAgLnNlbGVjdEFsbCgndGV4dC5idXJnZXNzU2xpY2VQZXJjZW50Jylcblx0XHRcdCAgLmRhdGEoKGQpID0+IHBpZShkLnBlcmNlbnRzKSApXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG5cdFx0XHQgIC5maWx0ZXIoKGQpID0+IGQuZGF0YS5wZXJjZW50ID4gMClcblx0XHRcdCAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiAndHJhbnNsYXRlKCcgKyAoYXJjLmNlbnRyb2lkKGQpWzBdICsgc2NvcGUuV0lEVEggLyAyKSArICcsJyArIChhcmMuY2VudHJvaWQoZClbMV0gKyBzY29wZS5IRUFERVIgKiAyICsgc2NvcGUuTUFSR0lOICogNSArIHNjb3BlLlNUQVRTSEVJR0hUICsgc2NvcGUuRElBTUVURVIgLyAyKSArICcpJylcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC5zdHlsZSgnZm9udCcsICcxMXB4IEFyaWFsJylcblx0XHRcdCAgLmF0dHIoJ2R5JywgNS41KVxuXHRcdFx0ICBcblx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAwKVxuXHRcdFx0ICAuYXR0cignaWQnLCAoZCkgPT4gJ3JpbmcnICsgZC5kYXRhLnJpbmdJZCArICdncmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnYnVyZ2Vzc1NsaWNlUGVyY2VudCBncmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IChkLmRhdGEuZ3JhZGUgPT0gJ0MnKSA/ICdibGFjaycgOiAnd2hpdGUnKVxuXHRcdFx0ICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG5cdFx0XHQgIC50ZXh0KChkKSA9PiBwZXJjZW50KGQudmFsdWUpKTtcblxuXHRcdFx0cmluZ05vZGVzXG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuXHRcdFx0ICAuZGF0YShyaW5nc3RhdHMpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkLGksaikgPT4gJ2FyZWFCYXIgYmFyR3JhZGUnICsgZC5wZXJjZW50c1tqXS5ncmFkZSArICcgcmluZycgKyAoaSArIDEpKVxuXHRcdFx0ICAuYXR0cignaGVpZ2h0Jywgc2NvcGUuU1RBVFNIRUlHSFQpXG5cdFx0XHQgIC5hdHRyKCd3aWR0aCcsIChkLGksaikgPT4gTWF0aC5yb3VuZChkLnBlcmNlbnRzW2pdLm92ZXJhbGxQZXJjZW50ICogc2NvcGUuV0lEVEgpKVxuXHRcdFx0ICAuYXR0cignb3BhY2l0eScsIC43KVxuXHRcdFx0ICAuYXR0cigneScsIHNjb3BlLkhFQURFUiArIHNjb3BlLk1BUkdJTilcblx0XHRcdCAgLmF0dHIoJ3gnLCAoZCxpLGopID0+IHtcblx0XHRcdFx0bGV0IHggPSAwO1xuXHRcdFx0XHRmb3IgKGxldCBqMCA9IDA7IGowIDw9IDM7IGowKyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpMCA9IDA7IGkwIDw9IDM7IGkwKyspIHtcblx0XHRcdFx0XHRcdGlmIChyaW5nc3RhdHNbajBdLnBlcmNlbnRzW2kwXS5ncmFkZSA8IGQucGVyY2VudHNbal0uZ3JhZGUgfHwgKHJpbmdzdGF0c1tqMF0ucGVyY2VudHNbaTBdLmdyYWRlID09IGQucGVyY2VudHNbal0uZ3JhZGUgJiYgcmluZ3N0YXRzW2owXS5wZXJjZW50c1tpMF0ucmluZ0lkIDwgZC5wZXJjZW50c1tqXS5yaW5nSWQpKSB7XG5cdFx0XHRcdFx0XHRcdHgrPSBNYXRoLnJvdW5kKHJpbmdzdGF0c1tqMF0ucGVyY2VudHNbaTBdLm92ZXJhbGxQZXJjZW50ICogc2NvcGUuV0lEVEgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdCAgfSlcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpLGopID0+IGNvbG9yKGopKVxuXHRcdFx0ICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSxqKSB7XG5cdFx0XHRcdGxldCBncmFkZSA9IFsnQScsJ0InLCdDJywnRCddW2pdO1xuXHRcdFx0XHRkMy5zZWxlY3RBbGwoJy5hcmVhQmFyJylcblx0XHRcdFx0ICAudHJhbnNpdGlvbigpXG5cdFx0XHRcdCAgLmR1cmF0aW9uKDEwMDApXG5cdFx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAuNCk7XG5cdFx0XHRcdGQzLnNlbGVjdEFsbCgncmVjdC5iYXJHcmFkZScgKyBncmFkZSlcblx0XHRcdFx0ICAudHJhbnNpdGlvbigpXG5cdFx0XHRcdCAgLmR1cmF0aW9uKDEwMDApXG5cdFx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAxKTtcblx0XHRcdFx0ZDMuc2VsZWN0QWxsKCcuc2xpY2VCb3JkZXInKVxuXHRcdFx0XHQgIC5maWx0ZXIoJy5ncmFkZScgKyBncmFkZSlcblx0XHRcdFx0ICAudHJhbnNpdGlvbigpXG5cdFx0XHRcdCAgLmR1cmF0aW9uKDEwMDApXG5cdFx0XHRcdCAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDUpO1xuXHRcdFx0XHRkMy5zZWxlY3RBbGwoJy5idXJnZXNzU2xpY2VQZXJjZW50Jylcblx0XHRcdFx0ICAuZmlsdGVyKCcuZ3JhZGUnICsgZ3JhZGUpXG5cdFx0XHRcdCAgLmZpbHRlcigoZCkgPT4gZC5kYXRhLnBlcmNlbnQgPiAuMDYpXG5cdFx0XHRcdCAgLnRyYW5zaXRpb24oKVxuXHRcdFx0XHQgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcblx0XHRcdFx0ICAuYXR0cignb3BhY2l0eScsIDEpO1xuXHRcdFx0XHRzY29wZS5vbkdyYWRlSG92ZXIoZ3JhZGUpO1xuXHRcdFx0ICB9KS5cblx0XHRcdCAgb24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpLGopIHtcblx0XHRcdFx0bGV0IGdyYWRlID0gWydBJywnQicsJ0MnLCdEJ11bal07XG5cdFx0XHRcdGQzLnNlbGVjdEFsbCgnLmFyZWFCYXInKVxuXHRcdFx0XHQgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0ICAuYXR0cignb3BhY2l0eScsIC43KTtcblx0XHRcdFx0ZDMuc2VsZWN0QWxsKCcuc2xpY2VCb3JkZXInKVxuXHRcdFx0XHQgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0ICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XG5cdFx0XHRcdGQzLnNlbGVjdEFsbCgnLmJ1cmdlc3NTbGljZVBlcmNlbnQnKVxuXHRcdFx0XHQgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0ICAuYXR0cignb3BhY2l0eScsIDApXG5cdFx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCkgPT4gKGQuZGF0YS5ncmFkZSA9PSAnQycpID8gJ2JsYWNrJyA6ICd3aGl0ZScpO1xuXHRcdFx0XHRzY29wZS5vbkdyYWRlSG92ZXJPdXQoKTtcblx0XHRcdCAgfSk7XG5cblx0XHRcdC8vIHBlcmNlbnRzIGZvciBlYWNoIG9mIHRoZXNlIHNsaWNlcyBpbiB0aGUgYXJlYSBjaGFydFxuXHRcdFx0cmluZ05vZGVzXG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3RleHQuc2xpY2VQZXJjZW50Jylcblx0XHRcdCAgLmRhdGEocmluZ3N0YXRzKVxuXHRcdFx0ICAuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0ICAuYXR0cigneCcsIChkLGksaikgPT4ge1xuXHRcdFx0XHRsZXQgeCA9IDA7XG5cdFx0XHRcdGZvciAobGV0IGowID0gMDsgajAgPD0gMzsgajArKykge1xuXHRcdFx0XHRcdGZvciAobGV0IGkwID0gMDsgaTAgPD0gMzsgaTArKykge1xuXHRcdFx0XHRcdFx0aWYgKHJpbmdzdGF0c1tqMF0ucGVyY2VudHNbaTBdLmdyYWRlIDwgZC5wZXJjZW50c1tqXS5ncmFkZSB8fCAocmluZ3N0YXRzW2owXS5wZXJjZW50c1tpMF0uZ3JhZGUgPT0gZC5wZXJjZW50c1tqXS5ncmFkZSAmJiByaW5nc3RhdHNbajBdLnBlcmNlbnRzW2kwXS5yaW5nSWQgPCBkLnBlcmNlbnRzW2pdLnJpbmdJZCkpIHtcblx0XHRcdFx0XHRcdFx0eCs9IE1hdGgucm91bmQocmluZ3N0YXRzW2owXS5wZXJjZW50c1tpMF0ub3ZlcmFsbFBlcmNlbnQgKiBzY29wZS5XSURUSCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHggKz0gTWF0aC5yb3VuZChkLnBlcmNlbnRzW2pdLm92ZXJhbGxQZXJjZW50ICogc2NvcGUuV0lEVEggLyAyKTtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHQgIH0pXG5cdFx0XHQgIC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSICsgc2NvcGUuTUFSR0lOICsgMTMpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkLGksaikgPT4gJ2FyZWFCYXJQZXJjZW50IGJhckdyYWRlUGVyY2VudCcgKyBkLnBlcmNlbnRzW2pdLmdyYWRlICsgJyByaW5nJyArIChpICsgMSkpXG5cdFx0XHQgIC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJylcblx0XHRcdCAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMHB4Jylcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpLGopID0+IChkLnBlcmNlbnRzW2pdLmdyYWRlID09ICdDJykgPyAnYmxhY2snIDogJ3doaXRlJylcblx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAwKVxuXHRcdFx0ICAudGV4dCgoZCxpLGopID0+IHBlcmNlbnQoZC5wZXJjZW50c1tqXS5vdmVyYWxsUGVyY2VudCkpO1xuXG5cdFx0XHRyaW5nTm9kZXNcblx0XHRcdCAgLnNlbGVjdEFsbCgndGV4dC5vdmVyYWxsUGVyY2VudCcpXG5cdFx0XHQgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQgIC5lbnRlcigpXG5cdFx0XHQgIC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0ICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG5cdFx0XHRcdGxldCB4ID0gZC5wZXJjZW50ICogc2NvcGUuV0lEVEggLyAyO1xuXHRcdFx0XHRmb3IgKGxldCBpMCA9IDA7IGkwIDwgaTsgaTArKykge1xuXHRcdFx0XHRcdHggKz0gZ3JhZGVTdGF0c1tpMF0ucGVyY2VudCAqIHNjb3BlLldJRFRIO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0ICB9KVxuXHRcdFx0ICAuYXR0cigneScsIHNjb3BlLkhFQURFUiArIHNjb3BlLk1BUkdJTiArIDEzKVxuXHRcdFx0ICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG5cdFx0XHQgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuXHRcdFx0ICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXG5cdFx0XHQgIC5hdHRyKCdmb250LXNpemUnLCAnMTBweCcpXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IChkLmdyYWRlID09ICdDJykgPyAnYmxhY2snIDogJ3doaXRlJylcblx0XHRcdCAgLmNsYXNzZWQoJ292ZXJhbGxQZXJjZW50JywgdHJ1ZSlcblx0XHRcdCAgLnRleHQoKGQpID0+IHBlcmNlbnQoZC5wZXJjZW50KSk7XG5cblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdCAgLmF0dHIoJ3gnLCBzY29wZS5XSURUSCAvIDIpXG5cdFx0XHQgIC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSKVxuXHRcdFx0ICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcblx0XHRcdCAgLnRleHQoJ0dyYWRpbmcgaW4gVGVybXMgb2YgQXJlYScpO1xuXG5cdFx0XHRyaW5nTm9kZXNcblx0XHRcdCAgLmFwcGVuZCgndGV4dCcpXG5cdFx0XHQgIC5hdHRyKCd4Jywgc2NvcGUuV0lEVEggLyAyKVxuXHRcdFx0ICAuYXR0cigneScsIHNjb3BlLkhFQURFUiArIHNjb3BlLk1BUkdJTiAqIDQgKyBzY29wZS5TVEFUU0hFSUdIVClcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC50ZXh0KCdHcmFkaW5nICYgRGVuc2l0eSBPdXR3YXJkJyk7XG5cblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdCAgLmF0dHIoJ3gnLCBzY29wZS5XSURUSCAvIDIpXG5cdFx0XHQgIC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSICogMiArIHNjb3BlLk1BUkdJTiAqIDQgKyBzY29wZS5TVEFUU0hFSUdIVClcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC50ZXh0KCdmcm9tIENpdHkgQ2VudGVyJyk7XG5cblx0XHRcdGQzLnhtbCgnc3RhdGljL2J1cmdlc3Muc3ZnJykuZ2V0KChlcnJvciwgeG1sKSA9PiB7XG5cdFx0XHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cblx0XHRcdFx0bGV0IGJ1cmdlc3NEaWFncmFtID0gcmluZ05vZGVzLm5vZGUoKS5hcHBlbmRDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblxuXHRcdFx0XHR2YXIgaW5uZXJTVkcgPSByaW5nTm9kZXMuc2VsZWN0KFwic3ZnXCIpO1xuXG5cdFx0XHRcdGlubmVyU1ZHXG5cdFx0XHRcdFx0LmF0dHIoJ3gnLCAtNSlcblx0XHRcdFx0XHQuYXR0cigneScsIDEwMik7XG5cblx0XHRcdFx0aW5uZXJTVkcudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMDAwKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgLjM1KTtcblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gYm91bmQgaW4gY29tcG9uZW50RGlkTW91bnQgdG8gdGhlIGFyZWFTZWxlY3RlZCBtZXRob2Qgb2YgQXBwIChwYXNzZWQgaW4gYXMgYSBwcm9wcylcblx0XHR9LFxuXG5cdFx0b25Ib3Zlck91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBib3VuZCBpbiBjb21wb25lbnREaWRNb3VudCB0byB0aGUgYXJlYVVuc2VsZWN0ZWQgbWV0dGhvZCBvZiBBcHBcblx0XHR9LFxuXG5cdFx0b25HcmFkZUhvdmVyOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGJvdW5kIGluIGNvbXBvbmVudERpZE1vdW50IHRvIHRoZSBncmFkZVNlbGVjdGVkIG1ldGhvZCBvZiBBcHAgKHBhc3NlZCBpbiBhcyBhIHByb3BzKVxuXHRcdH0sXG5cblx0XHRvbkdyYWRlSG92ZXJPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gYm91bmQgaW4gY29tcG9uZW50RGlkTW91bnQgdG8gdGhlIGdyYWRlVW5zZWxlY3RlZCBtZXR0aG9kIG9mIEFwcFxuXHRcdH0sXG5cdFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRkMy5zZWxlY3Qobm9kZSkuaHRtbCgnJyk7XG5cdFx0fVxuXHR9XG5cbn07XG4iLCJpbXBvcnQgUmVhY3QsIHtQcm9wVHlwZXN9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBhdGgsIFByb3BUeXBlcyBhcyBMZWFmbGV0UHJvcFR5cGVzIH0gZnJvbSAncmVhY3QtbGVhZmxldCc7XG5pbXBvcnQgZG9udXQgZnJvbSAnLi9MLkRvbnV0LmpzJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb251dCBleHRlbmRzIFBhdGgge1xuXHQvLyBSYWRpaSBhcmUgaW4gbWV0ZXJzXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0Y2VudGVyOiBMZWFmbGV0UHJvcFR5cGVzLmxhdGxuZy5pc1JlcXVpcmVkLFxuXHRcdG91dGVyUmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cdFx0aW5uZXJSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcblx0fTtcblxuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge307XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRjb25zdCB7Y2VudGVyLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG5cdFx0c3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0dGhpcy5sZWFmbGV0RWxlbWVudCA9IG5ldyBkb251dChjZW50ZXIsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgcHJvcHMpO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuXHRcdGlmICh0aGlzLnByb3BzLmNlbnRlciAhPT0gcHJldlByb3BzLmNlbnRlcikge1xuXHRcdFx0dGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmcodGhpcy5wcm9wcy5jZW50ZXIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BzLm91dGVyUmFkaXVzICE9PSBwcmV2UHJvcHMub3V0ZXJSYWRpdXMgfHwgdGhpcy5wcm9wcy5pbm5lclJhZGl1cyAhPT0gcHJldlByb3BzLmlubmVyUmFkaXVzKSB7XG5cdFx0XHR0aGlzLmxlYWZsZXRFbGVtZW50LnNldFJhZGl1cyh0aGlzLnByb3BzLm91dGVyUmFkaXVzLCB0aGlzLnByb3BzLmlubmVyUmFkaXVzKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG5cdH1cbn0iLCJpbXBvcnQgKiBhcyBMIGZyb20gJ2xlYWZsZXQnO1xuXG5jb25zdCBEb251dCA9IChmdW5jdGlvbiAoTCkge1xuXG5cdHJldHVybiBMLkNpcmNsZS5leHRlbmQoe1xuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBvcHRpb25zKSB7XG5cdFx0XHRMLlBhdGgucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHRcdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHRcdHRoaXMuX21PdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuXHRcdFx0dGhpcy5fbUlubmVyUmFkaXVzID0gdGhpcy5fdmFsaWRhdGVJbm5lclJhZGl1cyhvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuXHRcdH0sXG5cblx0XHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpIHtcblx0XHRcdHRoaXMuX21PdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuXHRcdFx0dGhpcy5fbUlubmVyUmFkaXVzID0gdGhpcy5fdmFsaWRhdGVJbm5lclJhZGl1cyhvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdFx0fSxcblxuXHRcdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbG5nUmFkaXVzID0gdGhpcy5fZ2V0TG5nUmFkaXVzKCksXG5cdFx0XHRcdCAgbGF0bG5nID0gdGhpcy5fbGF0bG5nLFxuXHRcdFx0XHQgIG91dGVyUG9pbnRMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZyAtIGxuZ1JhZGl1c1swXV0pLFxuXHRcdFx0XHQgIGlubmVyUG9pbnRMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZyAtIGxuZ1JhZGl1c1sxXV0pO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKTtcblx0XHRcdHRoaXMuX291dGVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5fcG9pbnQueCAtIG91dGVyUG9pbnRMZWZ0LngsIDEpO1xuXHRcdFx0dGhpcy5faW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLl9wb2ludC54IC0gaW5uZXJQb2ludExlZnQueCwgMSk7XG5cdFx0fSxcblxuXHRcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxuZ1JhZGl1cyA9IHRoaXMuX2dldExuZ1JhZGl1cygpWzBdLFxuXHRcdFx0XHQgIGxhdFJhZGl1cyA9IHRoaXMuX2dldExhdFJhZGl1cygpWzBdLFxuXHRcdFx0XHQgIGxhdGxuZyA9IHRoaXMuX2xhdGxuZztcblxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHRcdFx0XHRcdFx0W2xhdGxuZy5sYXQgLSBsYXRSYWRpdXMsIGxhdGxuZy5sbmcgLSBsbmdSYWRpdXNdLFxuXHRcdFx0XHRcdFx0XHRbbGF0bG5nLmxhdCArIGxhdFJhZGl1cywgbGF0bG5nLmxuZyArIGxuZ1JhZGl1c10pO1xuXHRcdH0sXG5cblx0XHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBbdGhpcy5fbU91dGVyUmFkaXVzLCB0aGlzLl9tSW5uZXJSYWRpdXNdO1xuXHRcdH0sXG5cblx0XHRfZ2V0TGF0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gWyh0aGlzLl9tT3V0ZXJSYWRpdXMgLyA0MDA3NTAxNykgKiAzNjAsICh0aGlzLl9tSW5uZXJSYWRpdXMgLyA0MDA3NTAxNykgKiAzNjBdO1xuXHRcdH0sXG5cblx0XHRfZ2V0TG5nUmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcmFkaWkgPSB0aGlzLl9nZXRMYXRSYWRpdXMoKTtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0KHJhZGlpWzBdIC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIHRoaXMuX2xhdGxuZy5sYXQpKSxcblx0XHRcdFx0KHJhZGlpWzFdIC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIHRoaXMuX2xhdGxuZy5sYXQpKVxuXHRcdFx0XTtcblx0XHR9LFxuXG5cdFx0X2NoZWNrSWZFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdnAgPSB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCxcblx0XHRcdFx0ICBvdXRlclJhZGl1cyA9IHRoaXMuX291dGVyUmFkaXVzLFxuXHRcdFx0XHQgIHAgPSB0aGlzLl9wb2ludDtcblxuXHRcdFx0cmV0dXJuIHAueCAtIG91dGVyUmFkaXVzID4gdnAubWF4LnggfHwgcC55IC0gb3V0ZXJSYWRpdXMgPiB2cC5tYXgueSB8fFxuXHRcdFx0XHRcdFx0IHAueCArIG91dGVyUmFkaXVzIDwgdnAubWluLnggfHwgcC55ICsgb3V0ZXJSYWRpdXMgPCB2cC5taW4ueTtcblx0XHR9LFxuXG5cdFx0X3ZhbGlkYXRlSW5uZXJSYWRpdXM6IGZ1bmN0aW9uKG91dGVyLCBpbm5lcikge1xuXHRcdFx0aWYgKGlubmVyID49IG91dGVyKSByZXR1cm4gb3V0ZXIgLSAxO1xuXHRcdFx0cmV0dXJuIGlubmVyO1xuXHRcdH0sXG5cblx0XHRnZXRBcmM6IGZ1bmN0aW9uKHB0LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpIHtcblx0XHRcdHZhciB4MiA9IHB0LnggLSAwLjAxO1xuXHRcdFx0dmFyIHkxID0gcHQueSAtIG91dGVyUmFkaXVzO1xuXHRcdFx0dmFyIHkyID0gcHQueSAtIGlubmVyUmFkaXVzO1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHQnTScsIHB0LngsIHkxLFxuXHRcdFx0XHQnQScsIG91dGVyUmFkaXVzLCBvdXRlclJhZGl1cywgMCwgMSwgMSwgeDIsIHkxLFxuXHRcdFx0XHQnTScsIHgyLCB5Mixcblx0XHRcdFx0J0EnLCBpbm5lclJhZGl1cywgaW5uZXJSYWRpdXMsIDAsIDEsIDAsIHB0LngsIHkyLFxuXHRcdFx0XHQnWidcblx0XHRcdF0uam9pbignICcpO1xuXHRcdH0sXG5cblx0XHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0XHQgIG91dGVyUmFkaXVzID0gdGhpcy5fb3V0ZXJSYWRpdXMsXG5cdFx0XHRcdCAgaW5uZXJSYWRpdXMgPSB0aGlzLl9pbm5lclJhZGl1cztcblxuXHRcdFx0aWYgKHRoaXMuX2NoZWNrSWZFbXB0eSgpKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKEwuQnJvd3Nlci5zdmcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXJjKHAsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cyk7XG5cdFx0XHR9IGVsc2UgeyAvLyBUT0RPOiBWTUwgRG9udXQgcGF0aFxuXHRcdFx0XHRwLl9yb3VuZCgpO1xuXHRcdFx0XHRyID0gTWF0aC5yb3VuZChyKTtcblx0XHRcdFx0cmV0dXJuICdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgb3V0ZXJSYWRpdXMgKyAnLCcgKyBvdXRlclJhZGl1cyArICcgMCwnICsgKDY1NTM1ICogMzYwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KShMKTtcblxuZXhwb3J0IGRlZmF1bHQgRG9udXQ7IiwiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG93bmxvYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRtYXB1cmw6IFByb3BUeXBlcy5zdHJpbmcsXG5cdFx0bmFtZTogUHJvcFR5cGVzLnN0cmluZ1xuXHR9O1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZG93bmxvYWRHZW9qc29uID0gdGhpcy5kb3dubG9hZEdlb2pzb24uYmluZCh0aGlzKTsgXG5cdH1cblxuXHRkb3dubG9hZEdlb2pzb24gKCkge1xuXHRcdGxldCBnZW9qc29uID0gdGhpcy5wcm9wcy5hZEdlb2pzb247XG5cdFx0bGV0IGJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZ2VvanNvbildKTsgXG5cblx0XHRsZXQgZ2VvanNvblVSTCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdGxldCB0ZW1wTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0XHR0ZW1wTGluay5ocmVmID0gZ2VvanNvblVSTDtcblx0XHR0ZW1wTGluay5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgJ2FyZWFkZXNjcmlwdGlvbi5nZW9qc29uJyk7XG5cdFx0dGVtcExpbmsuY2xpY2soKTtcblx0fVxuXG5cdHJlbmRlciAoKSB7XG5cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nZG93bmxvYWRfbWVudSc+XG5cdFx0XHRcdDxoMj5cblx0XHRcdFx0XHQ8c3Bhbj57IHRoaXMucHJvcHMubmFtZSArICcsICcgKyB0aGlzLnByb3BzLnN0YXRlIH08L3NwYW4+XG5cdFx0XHRcdFx0PGRpdiBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkRvd25sb2FkQ2xpY2tlZCB9Png8L2Rpdj5cblx0XHRcdFx0PC9oMj5cblx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdDxpbWcgc3JjPXt0aGlzLnByb3BzLnRodW1ibmFpbCB9IC8+XG5cdFx0XHRcdFx0XHQ8aDM+PGEgaHJlZj17dGhpcy5wcm9wcy5tYXB1cmx9IGRvd25sb2FkPXsgdGhpcy5wcm9wcy5uYW1lICsgJ0hPTENNYXAuanBnJ30+RG93bmxvYWQgSE9MQyBtYXAgKG9yaWdpbmFsKTwvYT48L2gzPlx0XHRcdFxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0PGltZyBzcmM9e3RoaXMucHJvcHMubWFwVGh1bWJuYWlsIH0gLz5cblx0XHRcdFx0XHRcdDxoMz48YSBvbkNsaWNrPXsgdGhpcy5kb3dubG9hZEdlb2pzb24gfT5Eb3dubG9hZCBIT0xDIGFyZWEgZGVzY3JpcHRpb248L2E+PC9oMz5cblx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdDxpbWcgc3JjPXt0aGlzLnByb3BzLm1hcFRodW1ibmFpbCB9IC8+XG5cdFx0XHRcdFx0XHQ8aDM+PGEgaHJlZj17dGhpcy5wcm9wcy5tYXB1cmx9IGRvd25sb2FkPXsgdGhpcy5wcm9wcy5uYW1lICsgJ0hPTENNYXAuanBnJ30+RG93bmxvYWQgSE9MQyBnZW9yZWZlcmVuY2VkIG1hcDwvYT48L2gzPlxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDwvdWw+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5cbi8vIHN0b3Jlc1xuaW1wb3J0IEFyZWFEZXNjcmlwdGlvbnNTdG9yZSBmcm9tICcuLi9zdG9yZXMvQXJlYURlc2NyaXB0aW9uc1N0b3JlJztcbmltcG9ydCBDaXR5U3RvcmUgZnJvbSAnLi4vc3RvcmVzL0NpdHlTdG9yZSc7XG5pbXBvcnQgTWFwU3RhdGVTdG9yZSBmcm9tICcuLi9zdG9yZXMvTWFwU3RhdGVTdG9yZSc7XG5pbXBvcnQgUmFzdGVyU3RvcmUgZnJvbSAnLi4vc3RvcmVzL1Jhc3RlclN0b3JlJztcbmltcG9ydCBVc2VyTG9jYXRpb25TdG9yZSBmcm9tICcuLi9zdG9yZXMvVXNlckxvY2F0aW9uU3RvcmUnO1xuXG4vLyBjb21wb25lbnRzXG5pbXBvcnQgeyBNYXAsIFRpbGVMYXllciwgR2VvSnNvbiwgQ2lyY2xlLCBMYXllckdyb3VwLCBNYXJrZXIsIHNldEljb25EZWZhdWx0SW1hZ2VQYXRoIH0gZnJvbSAncmVhY3QtbGVhZmxldCc7XG5pbXBvcnQgeyBDYXJ0b0RCVGlsZUxheWVyLCBMZWdlbmQgfSBmcm9tICdAcGFub3JhbWEvdG9vbGtpdCc7XG5pbXBvcnQgQXJlYVBvbHlnb24gZnJvbSAnLi9BcmVhUG9seWdvbi5qc3gnO1xuaW1wb3J0IERvbnV0IGZyb20gJy4vRG9udXQvRG9udXQuanN4JztcblxuXG5pbXBvcnQgY2FydG9kYkNvbmZpZyBmcm9tICcuLi8uLi9iYXNlbWFwcy9jYXJ0b2RiL2NvbmZpZy5qc29uJztcbmltcG9ydCBjYXJ0b2RiTGF5ZXJzIGZyb20gJy4uLy4uL2Jhc2VtYXBzL2NhcnRvZGIvYmFzZW1hcHMuanNvbic7XG5pbXBvcnQgdGlsZUxheWVycyBmcm9tICcuLi8uLi9iYXNlbWFwcy90aWxlTGF5ZXJzLmpzb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIT0xDTWFwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuXHRjb25zdHJ1Y3RvciAocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdH1cblxuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuXG5cdH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG5cblx0fVxuXG5cdHJlbmRlciAoKSB7XG5cblx0XHRjb25zdCBBRHMgPSBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0VmlzaWJsZSgpLFxuXHRcdFx0YWJvdmVUaHJlc2hvbGQgPSBNYXBTdGF0ZVN0b3JlLmlzQWJvdmVab29tVGhyZXNob2xkKCksXG5cdFx0XHRvdXRlclJhZGl1cyA9IENpdHlTdG9yZS5nZXRPdXRlclJpbmdSYWRpdXMoKSxcblx0XHRcdHZpc2libGVNYXBzTGlzdCA9IE1hcFN0YXRlU3RvcmUuZ2V0VmlzaWJsZUhPTENNYXBzTGlzdCgpLFxuXHRcdFx0bGVnZW5kRGF0YSA9IHtcblx0XHRcdFx0aXRlbXM6IFtcblx0XHRcdFx0XHQnQSBGaXJzdCBHcmFkZScsXG5cdFx0XHRcdFx0J0IgU2Vjb25kIEdyYWRlJyxcblx0XHRcdFx0XHQnQyBUaGlyZCBHcmFkZScsXG5cdFx0XHRcdFx0J0QgRm91cnRoIEdyYWRlJyxcblx0XHRcdFx0XVxuXHRcdFx0fTtcblxuXHRcdGlmICghYWJvdmVUaHJlc2hvbGQpIHtcblx0XHRcdGxlZ2VuZERhdGEuaXRlbXMucHVzaCgnQXJlYSBmb3IgZWFjaCBncmFkZScpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblxuXHRcdFx0PE1hcCBcblx0XHRcdFx0cmVmPSd0aGVfbWFwJyBcblx0XHRcdFx0Y2VudGVyPXsgdGhpcy5wcm9wcy5zdGF0ZS5tYXAuY2VudGVyIH0gXG5cdFx0XHRcdHpvb209eyB0aGlzLnByb3BzLnN0YXRlLm1hcC56b29tIH0gIFxuXHRcdFx0XHRvbk1vdmVlbmQ9eyB0aGlzLnByb3BzLm9uTWFwTW92ZWQgfSBcblx0XHRcdFx0Y2xhc3NOYW1lPSd0aGVfbWFwJ1xuXHRcdFx0PlxuXG5cdFx0XHRcdHsvKiBiYXNlIG1hcCAqL31cblx0XHRcdFx0PFRpbGVMYXllclxuXHRcdFx0XHRcdGtleT17IChhYm92ZVRocmVzaG9sZCkgPyAnbGFiZWxzJyA6ICdub0xhYmVscycgfVxuXHRcdFx0XHRcdHVybD17IChhYm92ZVRocmVzaG9sZCkgPyB0aWxlTGF5ZXJzLmxheWVyc1swXS51cmxMYWJlbHMgOiB0aWxlTGF5ZXJzLmxheWVyc1swXS51cmxOb0xhYmVscyB9XG5cdFx0XHRcdFx0ekluZGV4PXsgLTEgfVxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdHsvKiBob2xjIHRpbGVzICovfVxuXHRcdFx0XHR7IHZpc2libGVNYXBzTGlzdC5tYXAoKGl0ZW0sIGkpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PFRpbGVMYXllclxuXHRcdFx0XHRcdFx0XHRrZXk9eyAnaG9sY3RpbGVzJyArIGl0ZW0uaWR9XG5cdFx0XHRcdFx0XHRcdHVybD17IGl0ZW0udXJsIH1cblx0XHRcdFx0XHRcdFx0bWluWm9vbT17IGl0ZW0ubWluWm9vbSB9XG5cdFx0XHRcdFx0XHRcdGJvdW5kcz0geyBpdGVtLmJvdW5kcyB9XG5cdFx0XHRcdFx0XHRcdG9wYWNpdHk9eyB0aGlzLnByb3BzLnN0YXRlLnJhc3Rlci5vcGFjaXR5IH1cblx0XHRcdFx0XHRcdFx0ekluZGV4PXsgKGl0ZW0uYWRfaWQgPT0gdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZENpdHkpID8gMSA6IG51bGwgfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KSB9XG5cblx0XHRcdFx0ey8qIHRleHQgbGFiZWxzIGZvciBjaXRpZXMgKi99XG5cdFx0XHRcdHsgKCFhYm92ZVRocmVzaG9sZCkgP1xuXHRcdFx0XHRcdGNhcnRvZGJMYXllcnMubGF5ZXJncm91cC5sYXllcnMubWFwKChpdGVtLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHQ8Q2FydG9EQlRpbGVMYXllclxuXHRcdFx0XHRcdFx0XHRcdGtleT17ICdjYXJ0b2RiLXRpbGUtbGF5ZXItJyArIGkgfVxuXHRcdFx0XHRcdFx0XHRcdHVzZXJJZD17IGNhcnRvZGJDb25maWcudXNlcklkIH1cblx0XHRcdFx0XHRcdFx0XHRzcWw9eyBpdGVtLm9wdGlvbnMuc3FsIH1cblx0XHRcdFx0XHRcdFx0XHRjYXJ0b2Nzcz17IGl0ZW0ub3B0aW9ucy5jYXJ0b2NzcyB9XG5cdFx0XHRcdFx0XHRcdFx0ekluZGV4PXsxMDAwfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ey8qIHJpbmdzOiBkb251dCBob2xlcyAqL31cblx0XHRcdFx0eyAoYWJvdmVUaHJlc2hvbGQgJiYgb3V0ZXJSYWRpdXMgPiAwKSA/XG5cdFx0XHRcdFx0PENpcmNsZSBcblx0XHRcdFx0XHRcdGNlbnRlcj17IENpdHlTdG9yZS5nZXRMb29wTGF0TG5nKCkgfSBcblx0XHRcdFx0XHRcdHJhZGl1cz17IG91dGVyUmFkaXVzIC8gNyB9IFxuXHRcdFx0XHRcdFx0ZmlsbE9wYWNpdHk9eyAodGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5yaW5nSWQgPj0gMikgPyAwLjc1IDogMCB9IFxuXHRcdFx0XHRcdFx0ZmlsbENvbG9yPSB7ICcjMDAwJyB9IFxuXHRcdFx0XHRcdFx0Y2xpY2thYmxlPXsgZmFsc2UgfSBcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdkb251dGhvbGUnIH0gXG5cdFx0XHRcdFx0XHRrZXk9eyAnZG9udXRob2xlJyB9IFxuXHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHR7LyogcmluZ3M6IGRvbnV0cyAqL31cblx0XHRcdFx0eyAoYWJvdmVUaHJlc2hvbGQgJiYgb3V0ZXJSYWRpdXMgPiAwKSA/XG5cdFx0XHRcdFx0WzIsMyw0LDVdLm1hcCgocmluZ051bSkgPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0PERvbnV0IFxuXHRcdFx0XHRcdFx0XHRcdGNlbnRlcj17IENpdHlTdG9yZS5nZXRMb29wTGF0TG5nKCkgfSBcblx0XHRcdFx0XHRcdFx0XHRpbm5lclJhZGl1cz17IChyaW5nTnVtICogMiAtIDMpIC8gNyAqIG91dGVyUmFkaXVzIH1cblx0XHRcdFx0XHRcdFx0XHRvdXRlclJhZGl1cz17IChyaW5nTnVtID09IDUpID8gb3V0ZXJSYWRpdXMgKiAxMDAgOiAocmluZ051bSAqIDIgLSAxKSAvIDcgKiBvdXRlclJhZGl1c31cblx0XHRcdFx0XHRcdFx0XHRjbGlja2FibGU9eyBmYWxzZSB9IFxuXHRcdFx0XHRcdFx0XHRcdGZpbGxPcGFjaXR5PXsgKHRoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRSaW5nR3JhZGUucmluZ0lkID4gMCAmJiByaW5nTnVtICE9PSB0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCkgPyAwLjc1IDogMCB9IFxuXHRcdFx0XHRcdFx0XHRcdGZpbGxDb2xvcj0geyAnIzAwMCcgfSBcblx0XHRcdFx0XHRcdFx0XHR3ZWlnaHQ9eyAxIH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnZG9udXQnIH0gXG5cdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2RvbnV0JyArIFN0cmluZyhyaW5nTnVtKSB9IFxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ey8qIHJpbmdzOiBzZWxlY3RlZCByaW5nICovfVxuXHRcdFx0XHR7IChhYm92ZVRocmVzaG9sZCAmJiB0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCA+IDApID9cblx0XHRcdFx0XHQ8TGF5ZXJHcm91cD5cblx0XHRcdFx0XHRcdDxHZW9Kc29uIFxuXHRcdFx0XHRcdFx0XHRkYXRhPXsgQ2l0eVN0b3JlLmdldEludmVydGVkR2VvSnNvbkZvclNlbGVjdGVkUmluZ0FyZWEodGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5yaW5nSWQsIHRoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRSaW5nR3JhZGUuZ3JhZGUpIH1cblx0XHRcdFx0XHRcdFx0Y2xpY2thYmxlPXsgZmFsc2UgfVxuXHRcdFx0XHRcdFx0XHRrZXk9eyAnaW52ZXJ0ZWRSaW5nU3Ryb2tlJ30gXG5cdFx0XHRcdFx0XHRcdGZpbGxDb2xvcj17ICcjMDAwJ31cblx0XHRcdFx0XHRcdFx0ZmlsbE9wYWNpdHk9eyAwLjYgfVxuXHRcdFx0XHRcdFx0XHRjb2xvcj17ICcjZmZmJyB9XG5cdFx0XHRcdFx0XHRcdHdlaWdodD17IDIgfVxuXHRcdFx0XHRcdFx0XHRvcGFjaXR5PXsgMC45IH1cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgJ2ludmVydGVkUmluZ0dyYWRlZEFyZWEnIH1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8R2VvSnNvbiBcblx0XHRcdFx0XHRcdFx0ZGF0YT17IENpdHlTdG9yZS5nZXRHZW9Kc29uRm9yU2VsZWN0ZWRSaW5nQXJlYSh0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCwgdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5ncmFkZSkgfVxuXHRcdFx0XHRcdFx0XHRjbGlja2FibGU9eyBmYWxzZSB9XG5cdFx0XHRcdFx0XHRcdGtleT17ICdyaW5nU3Ryb2tlJ30gXG5cdFx0XHRcdFx0XHRcdGZpbGxPcGFjaXR5PXsgKDEgLSB0aGlzLnByb3BzLnN0YXRlLnJhc3Rlci5vcGFjaXR5KSAvIDIgfVxuXHRcdFx0XHRcdFx0XHR3ZWlnaHQ9eyAyIH1cblx0XHRcdFx0XHRcdFx0b3BhY2l0eT17IDAuOSB9XG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdyaW5nR3JhZGVkQXJlYSBncmFkZScgKyB0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLmdyYWRlfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L0xheWVyR3JvdXA+IDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR7Lyogc2VsZWN0ZWQgZ3JhZGUgKi99XG5cdFx0XHRcdHsgKGFib3ZlVGhyZXNob2xkICYmIHRoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRHcmFkZSkgP1xuXHRcdFx0XHRcdDxBcmVhUG9seWdvbiBcblx0XHRcdFx0XHRcdGRhdGE9eyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0R2VvSnNvbkZvckdyYWRlKHRoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRDaXR5LCB0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkR3JhZGUpIH1cblx0XHRcdFx0XHRcdGtleT17ICdzZWxlY3RlZEdyYWRlZE5laWdoYm9yaG9vZHMnIH0gXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnc2VsZWN0ZWRHcmFkZWROZWlnaGJvcmhvb2RzIGdyYWRlJyArIHRoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRHcmFkZSB9IFxuXHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR7IChhYm92ZVRocmVzaG9sZCAmJiB0aGlzLnByb3BzLnN0YXRlLmhpZ2hsaWdodGVkTmVpZ2hib3Job29kICYmIEFEc1t0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkQ2l0eV0gJiYgQURzW3RoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRDaXR5XVt0aGlzLnByb3BzLnN0YXRlLmhpZ2hsaWdodGVkTmVpZ2hib3Job29kXSAmJiBBRHNbdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMucHJvcHMuc3RhdGUuaGlnaGxpZ2h0ZWROZWlnaGJvcmhvb2RdLmFyZWFfZ2VvanNvbl9pbnZlcnRlZCkgP1xuXHRcdFx0XHRcdDxBcmVhUG9seWdvblxuXHRcdFx0XHRcdFx0ZGF0YT17IEFEc1t0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5wcm9wcy5zdGF0ZS5oaWdobGlnaHRlZE5laWdoYm9yaG9vZF0uYXJlYV9nZW9qc29uX2ludmVydGVkIH0gXG5cdFx0XHRcdFx0XHRjbGlja2FibGU9eyBmYWxzZSB9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnbmVpZ2hib3Job29kUG9seWdvbkludmVydGVkIGdyYWRlJyArIEFEc1t0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5wcm9wcy5zdGF0ZS5oaWdobGlnaHRlZE5laWdoYm9yaG9vZF0uaG9sY19ncmFkZSB9IFxuXHRcdFx0XHRcdFx0a2V5PXsgJ25laWdoYm9yaG9vZFBvbHlnb25JbnZlcnRlZCcgKyB0aGlzLnByb3BzLnN0YXRlLmhpZ2hsaWdodGVkTmVpZ2hib3Job29kIH1cblx0XHRcdFx0XHQvPiA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ey8qIHNlbGVjdGVkIG5laWdoYm9yaG9vZCAqL31cblx0XHRcdFx0eyAoYWJvdmVUaHJlc2hvbGQgJiYgdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCAmJiBBRHNbdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZENpdHldICYmIEFEc1t0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZF0gJiYgQURzW3RoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRDaXR5XVt0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kXS5hcmVhX2dlb2pzb25faW52ZXJ0ZWQpID9cblx0XHRcdFx0XHQ8QXJlYVBvbHlnb25cblx0XHRcdFx0XHRcdGRhdGE9eyBBRHNbdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2RdLmFyZWFfZ2VvanNvbl9pbnZlcnRlZCB9IFxuXHRcdFx0XHRcdFx0Y2xpY2thYmxlPXsgZmFsc2UgfVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgJ25laWdoYm9yaG9vZFBvbHlnb25JbnZlcnRlZCBncmFkZScgKyBBRHNbdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2RdLmhvbGNfZ3JhZGUgfSBcblx0XHRcdFx0XHRcdGtleT17ICduZWlnaGJvcmhvb2RQb2x5Z29uSW52ZXJ0ZWQnICsgdGhpcy5wcm9wcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCB9XG5cdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdG51bGxcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHsvKiBuZWlnaGJvcmhvb2QgcG9seWdvbnM6IHNob3duIG9uIHpvb20gbGV2ZWwgMTAgYW5kIGhpZ2hlciAqL31cblx0XHRcdFx0eyAoYWJvdmVUaHJlc2hvbGQpID9cblx0XHRcdFx0XHRPYmplY3Qua2V5cyhBRHMpLm1hcChhZElkID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKEFEc1thZElkXSkubWFwKChhcmVhSWQpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0PEFyZWFQb2x5Z29uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGE9eyBBRHNbYWRJZF1bYXJlYUlkXS5hcmVhX2dlb2pzb24gfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnbmVpZ2hib3Job29kUG9seWdvbiBncmFkZScgKyBBRHNbYWRJZF1bYXJlYUlkXS5ob2xjX2dyYWRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ25laWdoYm9yaG9vZFBvbHlnb24nICsgYWRJZCArICctJyArIGFyZWFJZCB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbk5laWdoYm9yaG9vZFBvbHlnb25DbGljayB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkSWQ9eyBhZElkIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVpZ2hib3Job29kSWQ9eyBhcmVhSWQgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly9maWxsT3BhY2l0eT17IChpZCA9PSB0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKSA/IDEgOiAwIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9e3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcGFjaXR5Oih0aGlzLnByb3BzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCA+IDApID8gKDEgLSB0aGlzLnByb3BzLnN0YXRlLnJhc3Rlci5vcGFjaXR5KSAvIDUgOiAoMSAtIHRoaXMucHJvcHMuc3RhdGUucmFzdGVyLm9wYWNpdHkpIC8gMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWxsT3BhY2l0eTogKHRoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRSaW5nR3JhZGUucmluZ0lkID4gMCkgPyAwIDogKDEgLSB0aGlzLnByb3BzLnN0YXRlLnJhc3Rlci5vcGFjaXR5KSAvIDVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ey8qIGNhcnRvZ3JhbSBtYXJrZXIgZm9yIGNpdHk6IHNob3duIGJlbG93IHpvb20gbGV2ZWwgMTAgKi99XG5cdFx0XHRcdHsgKCFhYm92ZVRocmVzaG9sZCkgP1xuXHRcdFx0XHRcdEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRBRHNMaXN0KCkubWFwKChpdGVtLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKChpdGVtLnJhZGlpICYmIGl0ZW0uY2VudGVyTGF0KSA/XG5cdFx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKGl0ZW0ucmFkaWkpLm1hcCgoZ3JhZGUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKGl0ZW0ucmFkaWlbZ3JhZGVdLmlubmVyID09IDApID9cblx0XHRcdFx0XHRcdFx0XHRcdDxDaXJjbGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2VudGVyPXsgW2l0ZW0uY2VudGVyTGF0LCBpdGVtLmNlbnRlckxuZ10gfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyYWRpdXM9eyBpdGVtLnJhZGlpW2dyYWRlXS5vdXRlciB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkPXsgaXRlbS5hZF9pZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2l0eU1hcmtlclNlbGVjdGVkIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2NsaWNrYWJsZURvbnV0JyArIGl0ZW0uYWRfaWQgKyBncmFkZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdzaW1wbGVEb251dCBncmFkZV8nICsgZ3JhZGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdFx0XHRcdFx0PERvbnV0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNlbnRlcj17IFtpdGVtLmNlbnRlckxhdCwgaXRlbS5jZW50ZXJMbmddIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5uZXJSYWRpdXM9eyBpdGVtLnJhZGlpW2dyYWRlXS5pbm5lciB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyUmFkaXVzPXsgaXRlbS5yYWRpaVtncmFkZV0ub3V0ZXIgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZD17IGl0ZW0uYWRfaWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNpdHlNYXJrZXJTZWxlY3RlZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdjbGlja2FibGVEb251dCcgKyBpdGVtLmFkX2lkICsgZ3JhZGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnc2ltcGxlRG9udXQgZ3JhZGVfJyArIGdyYWRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRcdFx0KCFpdGVtLnBhcmVudF9pZCAgJiYgaXRlbS5jZW50ZXJMYXQpID9cblx0XHRcdFx0XHRcdFx0XHQ8Q2lyY2xlXG5cdFx0XHRcdFx0XHRcdFx0XHRjZW50ZXI9eyBbaXRlbS5jZW50ZXJMYXQsIGl0ZW0uY2VudGVyTG5nXSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRyYWRpdXM9eyAyNTAwMCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZD17IGl0ZW0uYWRfaWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMub25DaXR5TWFya2VyU2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2NsaWNrYWJsZU1hcCcgKyBpdGVtLmFkX2lkIH1cblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdjaXR5Q2lyY2xlICd9XG5cdFx0XHRcdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR7LyogbWFya2VyIGZvciB1c2VyJ3MgbG9jYXRpb24gKi99XG5cdFx0XHRcdHsgKHRoaXMucHJvcHMuc3RhdGUudXNlckxvY2F0aW9uKSA/XG5cdFx0XHRcdFx0PE1hcmtlciBwb3NpdGlvbj17IHRoaXMucHJvcHMuc3RhdGUudXNlckxvY2F0aW9uIH0gLz4gOlxuXHRcdFx0XHRcdG51bGxcblx0XHRcdFx0fVxuXG5cdFx0XHRcdDxMZWdlbmQgeyAuLi5sZWdlbmREYXRhIH0gb25JdGVtU2VsZWN0ZWQ9eyB0aGlzLm9uR3JhZGVIb3ZlciB9IC8+XG5cblx0XHRcdDwvTWFwPlxuXHRcdCk7XG5cdH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU2lkZWJhck5laWdoYm9yaG9vZE5hdiBmcm9tICcuL1NpZGViYXJOZWlnaGJvcmhvb2ROYXYuanN4JztcbmltcG9ydCBTaWRlYmFyTmVpZ2hib3Job29kVGl0bGUgZnJvbSAnLi9TaWRlYmFyTmVpZ2hib3Job29kVGl0bGUuanN4JztcbmltcG9ydCBIT0xDTWFwIGZyb20gJy4vSE9MQ01hcC5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaWRlYmFyTWFwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuXHQvLyBwcm9wZXJ0eSB2YWxpZGF0aW9uXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cblx0fTtcblxuXHQvLyAoaW5zdGVhZCBvZiBFUzUtc3R5bGUgZ2V0RGVmYXVsdFByb3BzKVxuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXG5cdH07XG5cblx0Y29uc3RydWN0b3IgKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHRzaG91bGRDb21wb25lbnRVcGRhdGUgKG5leHRQcm9wcykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmVuZGVyICgpIHtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nYXJlYURlc2NyaXB0aW9uJz5cblxuXHRcdFx0XHQ8U2lkZWJhck5laWdoYm9yaG9vZFRpdGxlXG5cdFx0XHRcdFx0YXJlYUlkPXsgdGhpcy5wcm9wcy5hcmVhSWQgfVxuXHRcdFx0XHRcdG5hbWU9eyB0aGlzLnByb3BzLm5laWdoYm9yaG9vZE5hbWVzW3RoaXMucHJvcHMuYXJlYUlkXSB9XG5cdFx0XHRcdFx0b25DbG9zZT17IHRoaXMucHJvcHMub25DbG9zZSB9XG5cdFx0XHRcdC8+XG5cblx0XHRcdFx0eyAodGhpcy5wcm9wcy5wcmV2aW91c0FyZWFJZCkgP1xuXHRcdFx0XHRcdDxTaWRlYmFyTmVpZ2hib3Job29kTmF2XG5cdFx0XHRcdFx0XHRzdHlsZT17IHRoaXMucHJvcHMucHJldmlvdXNTdHlsZSB9XG5cdFx0XHRcdFx0XHRvbkhPTENJRENsaWNrPXsgdGhpcy5wcm9wcy5vbkhPTENJRENsaWNrIH0gXG5cdFx0XHRcdFx0XHRhcmVhSWQgPXsgdGhpcy5wcm9wcy5wcmV2aW91c0FyZWFJZCB9IFxuXHRcdFx0XHRcdFx0bmFtZT17IHRoaXMucHJvcHMubmVpZ2hib3Job29kTmFtZXNbdGhpcy5wcm9wcy5wcmV2aW91c0FyZWFJZF0gfVxuXHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0eyAodGhpcy5wcm9wcy5uZXh0QXJlYUlkICYmIHRoaXMucHJvcHMubmV4dEFyZWFJZCAhPT0gJ251bGwnKSA/XG5cdFx0XHRcdFx0PFNpZGViYXJOZWlnaGJvcmhvb2ROYXZcblx0XHRcdFx0XHRcdHN0eWxlPXsgdGhpcy5wcm9wcy5uZXh0U3R5bGUgfVxuXHRcdFx0XHRcdFx0b25IT0xDSURDbGljaz17IHRoaXMucHJvcHMub25IT0xDSURDbGljayB9IFxuXHRcdFx0XHRcdFx0YXJlYUlkID17IHRoaXMucHJvcHMubmV4dEFyZWFJZCB9IFxuXHRcdFx0XHRcdFx0bmFtZT17IHRoaXMucHJvcHMubmVpZ2hib3Job29kTmFtZXNbdGhpcy5wcm9wcy5uZXh0QXJlYUlkXSB9XG5cdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ8ZGl2IHN0eWxlPXsgdGhpcy5wcm9wcy5tYXBTdHlsZSB9PlxuXHRcdFx0XHRcdDxIT0xDTWFwXG5cdFx0XHRcdFx0XHRyZWY9J2hvbGNfbWFwJ1xuXHRcdFx0XHRcdFx0c3RhdGU9eyB0aGlzLnByb3BzLnN0YXRlIH1cblx0XHRcdFx0XHRcdG9uTWFwTW92ZWQ9eyB0aGlzLnByb3BzLm9uTWFwTW92ZWQgfVxuXHRcdFx0XHRcdFx0b25OZWlnaGJvcmhvb2RQb2x5Z29uQ2xpY2s9eyB0aGlzLnByb3BzLm9uTmVpZ2hib3Job29kUG9seWdvbkNsaWNrIH1cblx0XHRcdFx0XHRcdG9uQ2l0eU1hcmtlclNlbGVjdGVkPSB7IHRoaXMucHJvcHMub25DaXR5TWFya2VyU2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0c3R5bGU9eyB0aGlzLnByb3BzLm1hcFN0eWxlIH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lkZWJhck5laWdoYm9yaG9vZE5hdiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cblx0cmVuZGVyKCkge1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgXG5cdFx0XHRcdGNsYXNzTmFtZT0nYWROYXYnIFxuXHRcdFx0XHRzdHlsZT17IHRoaXMucHJvcHMuc3R5bGUgfVxuXHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkhPTENJRENsaWNrIH0gXG5cdFx0XHRcdGlkPXsgdGhpcy5wcm9wcy5hcmVhSWQgfSBcblx0XHRcdD5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmFyZWFJZCB9XG5cdFx0XHRcdHsgKHRoaXMucHJvcHMubmFtZSkgP1xuXHRcdFx0XHRcdCcgJyArIHRoaXMucHJvcHMubmFtZSA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0fSBcblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxufSIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZGViYXJOZWlnaGJvcmhvb2ROYXYgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG5cdHJlbmRlcigpIHtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8aDIgY2xhc3NOYW1lPSdzaWRlYmFyVGl0bGUnPlxuXHRcdFx0XHQ8c3Bhbj57IHRoaXMucHJvcHMuYXJlYUlkfTwvc3Bhbj5cblx0XHRcdFx0eyAodGhpcy5wcm9wcy5uYW1lKSA/XG5cdFx0XHRcdFx0PHNwYW4+eyAnICcgKyB0aGlzLnByb3BzLm5hbWUgfTwvc3Bhbj4gOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2Nsb3NlaWNvbicgb25DbGljaz17IHRoaXMucHJvcHMub25DbG9zZSB9Png8L3NwYW4+XG5cdFx0XHQ8L2gyPiBcblx0XHQpO1xuXHR9XG5cbn0iLCJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDaXR5U25pcHBldCBmcm9tICcuL0NpdHlTbmlwcGV0LmpzeCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVTdGF0cyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRzdGF0ZU5hbWU6IFByb3BUeXBlcy5zdHJpbmdcblx0fTtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdHJlbmRlciAoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxoMj57IHRoaXMucHJvcHMuc3RhdGVOYW1lIH08L2gyPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuY2l0aWVzLm1hcCgoY2l0eURhdGEpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gPENpdHlTbmlwcGV0IFxuXHRcdFx0XHRcdFx0Y2l0eURhdGE9eyBjaXR5RGF0YSB9IFxuXHRcdFx0XHRcdFx0b25DaXR5Q2xpY2s9eyB0aGlzLnByb3BzLm9uQ2l0eUNsaWNrIH0gXG5cdFx0XHRcdFx0XHRrZXk9eyAnY2l0eScgKyBjaXR5RGF0YS5hZF9pZCB9IFxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdH0pIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn0iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDaXR5U25pcHBldCBmcm9tICcuL0NpdHlTbmlwcGV0LmpzeCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZUFoZWFkQ2l0eVNuaXBwZXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0cmVuZGVyICgpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdj5cblx0XHRcdFx0eyB0aGlzLnByb3BzLm9wdGlvbnMubWFwKChjaXR5RGF0YSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiA8Q2l0eVNuaXBwZXQgY2l0eURhdGE9eyBjaXR5RGF0YSB9IG9uQ2l0eUNsaWNrPXsgdGhpcy5wcm9wcy5vbk9wdGlvblNlbGVjdGVkIH0gZGlzcGxheVN0YXRlPXsgdHJ1ZSB9IGtleT17ICdjaXR5JyArIGNpdHlEYXRhLmFkX2lkIH0gLz5cblx0XHRcdFx0fSkgfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAuanN4JztcblxuLy9wcm9jZXNzLmVudi5OT0RFX0VOViA9ICdkZXZlbG9wbWVudCc7XG4vL2ltcG9ydCBQZXJmIGZyb20gJ3JlYWN0LWFkZG9ucy1wZXJmJztcbi8vd2luZG93LlBlcmYgPSBQZXJmO1xuXG4vL1BlcmYuc3RhcnQoKTtcblxuUmVhY3RET00ucmVuZGVyKDxBcHAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcC1jb250YWluZXInKSk7XG4vL1BlcmYuc3RvcCgpO1xuLy9QZXJmLnByaW50V2FzdGVkKCk7IiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBBcHBEaXNwYXRjaGVyIGZyb20gJy4uL3V0aWxzL0FwcERpc3BhdGNoZXInO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDYXJ0b0RCTG9hZGVyIGZyb20gJy4uL3V0aWxzL0NhcnRvREJMb2FkZXInO1xuaW1wb3J0IGZvcm1zTWV0YWRhdGEgZnJvbSAnLi4vLi4vZGF0YS9mb3Jtc01ldGFkYXRhLmpzb24nO1xuaW1wb3J0IE1hcFN0YXRlU3RvcmUgZnJvbSAnLi4vc3RvcmVzL01hcFN0YXRlU3RvcmUnO1xuaW1wb3J0IHN0YXRlQWJicnMgZnJvbSAnLi4vLi4vZGF0YS9zdGF0ZV9hYmJyLmpzb24nO1xuXG5cbmNvbnN0IEFyZWFEZXNjcmlwdGlvbnNTdG9yZSA9IHtcblxuXHRkYXRhOiB7XG5cdFx0YWRJZHM6IFtdLFxuXHRcdGFyZWFEZXNjcmlwdGlvbnM6IHt9LFxuXHRcdGFkc01ldGFkYXRhOiB7fSxcblx0XHRoYXNMb2FkZWQ6IGZhbHNlXG5cdH0sXG5cblx0ZGF0YUxvYWRlcjogQ2FydG9EQkxvYWRlcixcblxuXHRsb2FkQURNZXRhZGF0YTogZnVuY3Rpb24gKCkge1xuXHRcdGNvbnN0IHF1ZXJ5ID0gXCJXSVRIIHBvbHlnb25fYm91bmRzIGFzIChzZWxlY3QgYWRfaWQsIHN0X3htaW4oc3RfZW52ZWxvcGUoc3RfY29sbGVjdChob2xjX3BvbHlnb25zLnRoZV9nZW9tKSkpIGFzIGJieG1pbiwgc3RfeW1pbihzdF9lbnZlbG9wZShzdF9jb2xsZWN0KGhvbGNfcG9seWdvbnMudGhlX2dlb20pKSkgYXMgYmJ5bWluLCBzdF94bWF4KHN0X2VudmVsb3BlKHN0X2NvbGxlY3QoaG9sY19wb2x5Z29ucy50aGVfZ2VvbSkpKSBhcyBiYnhtYXgsIHN0X3ltYXgoc3RfZW52ZWxvcGUoc3RfY29sbGVjdChob2xjX3BvbHlnb25zLnRoZV9nZW9tKSkpIGFzIGJieW1heCBGUk9NIGhvbGNfcG9seWdvbnMgZ3JvdXAgYnkgYWRfaWQpIFNFTEVDVCBob2xjX3BvbHlnb25zLmFkX2lkLCBjaXR5LCBzdGF0ZSwgbG9vcGxhdCwgbG9vcGxuZywgcG9wdWxhdGlvbl8xOTQwLCBwb3B1bGF0aW9uXzE5MzAsIGFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTkzMCwgYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTQwLCBhc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwIGFzIGFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTkzMCwgYXNpYW5fcGFjaWZpY19pbHNsYW5kZXJfMTk0MCBhcyBhc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5NDAsIGJsYWNrX3BvcF8xOTMwLCBibGFja19wb3BfMTk0MCwgd2hpdGVfcG9wXzE5MzAsIHdoaXRlX3BvcF8xOTQwLCBzdW0oc3RfYXJlYShob2xjX3BvbHlnb25zLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSkgLyAxNjA5LjM0XjIgYXMgdG90YWxfYXJlYSwgc3VtKENBU0UgV0hFTiBob2xjX2dyYWRlID0gJ0EnIFRIRU4gc3RfYXJlYShob2xjX3BvbHlnb25zLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSBFTFNFIDAgRU5EKSAvIDE2MDkuMzReMiBhcyBhcmVhX2EsIHN1bShDQVNFIFdIRU4gaG9sY19ncmFkZSA9ICdCJyBUSEVOIHN0X2FyZWEoaG9sY19wb2x5Z29ucy50aGVfZ2VvbV93ZWJtZXJjYXRvcikgRUxTRSAwIEVORCkgLyAxNjA5LjM0XjIgYXMgYXJlYV9iLCBzdW0oQ0FTRSBXSEVOIGhvbGNfZ3JhZGUgPSAnQycgVEhFTiBzdF9hcmVhKGhvbGNfcG9seWdvbnMudGhlX2dlb21fd2VibWVyY2F0b3IpIEVMU0UgMCBFTkQpIC8gMTYwOS4zNF4yIGFzIGFyZWFfYywgc3VtKENBU0UgV0hFTiBob2xjX2dyYWRlID0gJ0QnIFRIRU4gc3RfYXJlYShob2xjX3BvbHlnb25zLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSBFTFNFIDAgRU5EKSAvIDE2MDkuMzReMiBhcyBhcmVhX2QsIGJieG1pbiwgYmJ5bWluLCBiYnhtYXgsIGJieW1heCBGUk9NIGhvbGNfcG9seWdvbnMgam9pbiBob2xjX2FkcyBvbiBob2xjX3BvbHlnb25zLmFkX2lkID0gaG9sY19hZHMuY2l0eV9pZCBqb2luIHBvbHlnb25fYm91bmRzIG9uIGhvbGNfYWRzLmNpdHlfaWQgPSBwb2x5Z29uX2JvdW5kcy5hZF9pZCBncm91cCBieSBob2xjX3BvbHlnb25zLmFkX2lkLCBjaXR5LCBzdGF0ZSwgbG9vcGxhdCwgbG9vcGxuZywgcG9wdWxhdGlvbl8xOTQwLCBwb3B1bGF0aW9uXzE5MzAsIGFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTkzMCwgYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTQwLCBhc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwLCBhc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTQwLCBibGFja19wb3BfMTkzMCwgYmxhY2tfcG9wXzE5NDAsIHdoaXRlX3BvcF8xOTMwLCB3aGl0ZV9wb3BfMTk0MCwgYmJ4bWluLCBiYnltaW4sIGJieG1heCwgYmJ5bWF4ICBvcmRlciBieSBhZF9pZCBkZXNjXCI7XG5cblx0XHR0aGlzLmRhdGFMb2FkZXIucXVlcnkoW3txdWVyeTogcXVlcnksIGZvcm1hdDogJ0pTT04nfV0pLnRoZW4oKHJlc3BvbnNlcykgPT4ge1xuXHRcdFx0cmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2UubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHJlc3BvbnNlc1swXS5mb3JFYWNoKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5hZHNNZXRhZGF0YVtyZXNwb25zZS5hZF9pZF0gPSB7XG5cdFx0XHRcdFx0XHRcdGFkX2lkOiByZXNwb25zZS5hZF9pZCxcblx0XHRcdFx0XHRcdFx0c3RhdGU6IHJlc3BvbnNlLnN0YXRlLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiByZXNwb25zZS5jaXR5LFxuXHRcdFx0XHRcdFx0XHRzZWFyY2hOYW1lOiByZXNwb25zZS5jaXR5ICsgJywgJyArIHN0YXRlQWJicnNbcmVzcG9uc2Uuc3RhdGVdLFxuXHRcdFx0XHRcdFx0XHRjZW50ZXJMYXQ6IHJlc3BvbnNlLmxvb3BsYXQsXG5cdFx0XHRcdFx0XHRcdGNlbnRlckxuZzogcmVzcG9uc2UubG9vcGxuZyxcblx0XHRcdFx0XHRcdFx0Ym91bmRzOiBbW3Jlc3BvbnNlLmJieW1pbiwgcmVzcG9uc2UuYmJ4bWluXSwgW3Jlc3BvbnNlLmJieW1heCwgcmVzcG9uc2UuYmJ4bWF4XV0sXG5cdFx0XHRcdFx0XHRcdHBvcHVsYXRpb25fMTkzMDogcmVzcG9uc2UucG9wdWxhdGlvbl8xOTMwLFxuXHRcdFx0XHRcdFx0XHRwb3B1bGF0aW9uXzE5NDA6IHJlc3BvbnNlLnBvcHVsYXRpb25fMTk0MCxcblx0XHRcdFx0XHRcdFx0YW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwOiByZXNwb25zZS5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5MzAsXG5cdFx0XHRcdFx0XHRcdGFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MDogcmVzcG9uc2UuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTQwLFxuXHRcdFx0XHRcdFx0XHRhc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5MzA6IHJlc3BvbnNlLmFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTkzMCxcblx0XHRcdFx0XHRcdFx0YXNpYW5fcGFjaWZpY19pc2xhbmRlcl8xOTQwOiByZXNwb25zZS5hc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5NDAsXG5cdFx0XHRcdFx0XHRcdGJsYWNrX3BvcF8xOTMwOiByZXNwb25zZS5ibGFja19wb3BfMTkzMCxcblx0XHRcdFx0XHRcdFx0YmxhY2tfcG9wXzE5NDA6IHJlc3BvbnNlLmJsYWNrX3BvcF8xOTQwLFxuXHRcdFx0XHRcdFx0XHR3aGl0ZV9wb3BfMTkzMDogcmVzcG9uc2Uud2hpdGVfcG9wXzE5MzAsXG5cdFx0XHRcdFx0XHRcdHdoaXRlX3BvcF8xOTQwOiByZXNwb25zZS53aGl0ZV9wb3BfMTk0MCxcblx0XHRcdFx0XHRcdFx0aGFzUG9seWdvbnM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGhhc0FEczogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGFyZWEgOiB7XG5cdFx0XHRcdFx0XHRcdFx0dG90YWw6IHJlc3BvbnNlLnRvdGFsX2FyZWEsXG5cdFx0XHRcdFx0XHRcdFx0YTogcmVzcG9uc2UuYXJlYV9hLFxuXHRcdFx0XHRcdFx0XHRcdGI6IHJlc3BvbnNlLmFyZWFfYixcblx0XHRcdFx0XHRcdFx0XHRjOiByZXNwb25zZS5hcmVhX2MsXG5cdFx0XHRcdFx0XHRcdFx0ZDogcmVzcG9uc2UuYXJlYV9kXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmFkc01ldGFkYXRhW3Jlc3BvbnNlLmFkX2lkXS5yYWRpaSA9IHRoaXMuY2FsY3VsYXRlU2ltcGxlUmluZ3NSYWRpaSh0aGlzLmRhdGEuYWRzTWV0YWRhdGFbcmVzcG9uc2UuYWRfaWRdLmFyZWEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5kYXRhLmhhc0xvYWRlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXG5cdFx0fSwgKGVycm9yKSA9PiB7XG5cdFx0XHQvLyBUT0RPOiBoYW5kbGUgdGhpcy5cblx0XHRcdGNvbnNvbGUubG9nKCdBcmVhRGVzY3JpcHRpb25zU3RvcmUgcmVjZWl2ZWQgZXJyb3I6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fSk7XG5cdH0sXG5cblx0bG9hZERhdGE6IGZ1bmN0aW9uIChhZElkcykge1xuXG5cdFx0dGhpcy5kYXRhLmFkSWRzID0gYWRJZHMubWFwKGFkSWQgPT4gcGFyc2VJbnQoYWRJZCkpO1xuXG5cdFx0Ly8gY3JlYXRlIHF1ZXJpZXMgZm9yIHRob3NlIHRoYXQgYXJlbid0IGFscmVhZHkgaW4gbWVtb3J5XG5cdFx0bGV0IHF1ZXJpZXMgPSBbXTtcblx0XHRhZElkcy5mb3JFYWNoKGFkSWQgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSkge1xuXHRcdFx0XHRxdWVyaWVzLnB1c2goe1xuXHRcdFx0XHRcdHF1ZXJ5OiAnU0VMRUNUIGhvbGNfYWRzLmNpdHlfaWQgYXMgYWRfaWQsIGhvbGNfbWFwcy5maWxlX25hbWUsIGhvbGNfYWRzLnllYXIsIGhvbGNfYWRzLnN0YXRlLCBob2xjX3BvbHlnb25zLm5hbWUsIGZvcm1faWQsIGhvbGNfaWQsIGhvbGNfZ3JhZGUsIHBvbHlnb25faWQsIGNhdF9pZCwgc3ViX2NhdF9pZCwgX29yZGVyIGFzIG9yZGVyLCBkYXRhLCBTVF9hc2dlb2pzb24gKGhvbGNfcG9seWdvbnMudGhlX2dlb20sIDQpIGFzIHRoZV9nZW9qc29uLCBzdF94bWluKHN0X2VudmVsb3BlKGhvbGNfcG9seWdvbnMudGhlX2dlb20pKSBhcyBiYnhtaW4sIHN0X3ltaW4oc3RfZW52ZWxvcGUoaG9sY19wb2x5Z29ucy50aGVfZ2VvbSkpIGFzIGJieW1pbiwgc3RfeG1heChzdF9lbnZlbG9wZShob2xjX3BvbHlnb25zLnRoZV9nZW9tKSkgYXMgYmJ4bWF4LCBzdF95bWF4KHN0X2VudmVsb3BlKGhvbGNfcG9seWdvbnMudGhlX2dlb20pKSBhcyBiYnltYXgsIHN0X3koc3RfY2VudHJvaWQoaG9sY19wb2x5Z29ucy50aGVfZ2VvbSkpIGFzIGNlbnRlcmxhdCwgc3RfeChzdF9jZW50cm9pZChob2xjX3BvbHlnb25zLnRoZV9nZW9tKSkgYXMgY2VudGVybG5nLCBzdF9hcmVhKGhvbGNfcG9seWdvbnMudGhlX2dlb206Omdlb2dyYXBoeSkvMTAwMDAwMCAqIDAuMzg2MTAyIGFzIHNxbWkgRlJPTSBob2xjX2FkX2RhdGEgcmlnaHQgam9pbiBob2xjX3BvbHlnb25zIG9uIGhvbGNfYWRfZGF0YS5wb2x5Z29uX2lkID0gaG9sY19wb2x5Z29ucy5uZWlnaGJvcmhvb2RfaWQgam9pbiBob2xjX2FkcyBvbiBob2xjX2Fkcy5jaXR5X2lkID0gaG9sY19wb2x5Z29ucy5hZF9pZCBqb2luIGhvbGNfbWFwc19hZHNfam9pbiBvbiBob2xjX21hcHNfYWRzX2pvaW4uYWRfaWQgPSBob2xjX2Fkcy5jaXR5X2lkIGpvaW4gaG9sY19tYXBzIG9uIGhvbGNfbWFwcy5tYXBfaWQgPSBob2xjX21hcHNfYWRzX2pvaW4ubWFwX2lkIGFuZCBwYXJlbnRfaWQgaXMgbnVsbCAgd2hlcmUgaG9sY19hZHMuY2l0eV9pZCA9ICcgKyBhZElkICsgJyBvcmRlciBieSBob2xjX2lkLCBjYXRfaWQsIHN1Yl9jYXRfaWQsIF9vcmRlcicsXG5cdFx0XHRcdFx0Zm9ybWF0OiAnSlNPTidcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmRhdGFMb2FkZXIucXVlcnkocXVlcmllcykudGhlbigocmVzcG9uc2VzKSA9PiB7XG5cdFx0XHRyZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWRJZCA9IHJlc3BvbnNlWzBdLmFkX2lkO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdID0ge1xuXHRcdFx0XHRcdFx0Zm9ybUlkOiByZXNwb25zZVswXS5mb3JtX2lkLFxuXHRcdFx0XHRcdFx0YnlOZWlnaGJvcmhvb2Q6IHRoaXMucGFyc2VBcmVhRGVzY3JpcHRpb25zKHJlc3BvbnNlKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlDYXRlZ29yeSA9IHRoaXMucGFyc2VBRHNCeUNhdCh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZCk7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYXJlYSA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKS5tYXAoKEhPTENJZCwgaSkgPT4gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbSE9MQ0lkXS5zcW1pICkucmVkdWNlKChhLGIpID0+IGErYiwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblxuXHRcdH0sIChlcnJvcikgPT4ge1xuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIHRoaXMuXG5cdFx0XHRjb25zb2xlLmxvZygnQXJlYURlc2NyaXB0aW9uc1N0b3JlIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHBhcnNlQXJlYURlc2NyaXB0aW9uczogZnVuY3Rpb24ocmF3QWREYXRhKSB7XG5cdFx0bGV0IGFkRGF0YSA9IHt9O1xuXG5cdFx0Zm9yKHZhciByb3cgaW4gcmF3QWREYXRhKSB7XG5cdFx0XHRsZXQgZCA9IHJhd0FkRGF0YVtyb3ddO1xuXG5cdFx0XHQvLyBkZWZpbmUgaWQgaWYgdW5kZWZpbmVkXG5cdFx0XHRpZih0eXBlb2YgYWREYXRhW2QuaG9sY19pZF0gPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0gPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIGFzc2lnbiBwcm9wZXJ0aWVzICAgIFxuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYV9nZW9qc29uID0gKCFhZERhdGFbZC5ob2xjX2lkXS5hcmVhX2dlb2pzb24pID8gSlNPTi5wYXJzZShkLnRoZV9nZW9qc29uKSA6IGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFfZ2VvanNvbjtcblx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFfZ2VvanNvbl9pbnZlcnRlZCA9ICghYWREYXRhW2QuaG9sY19pZF0uYXJlYV9nZW9qc29uX2ludmVydGVkKSA/IHRoaXMucGFyc2VJbnZlcnRlZEdlb0pzb24oSlNPTi5wYXJzZShkLnRoZV9nZW9qc29uKSkgOiBhZERhdGFbZC5ob2xjX2lkXS5hcmVhX2dlb2pzb25faW52ZXJ0ZWQ7XG5cdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5jZW50ZXIgPSBbZC5jZW50ZXJsYXQsZC5jZW50ZXJsbmddO1xuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYm91bmRpbmdCb3ggPSBbW2QuYmJ5bWluLGQuYmJ4bWluXSxbZC5iYnltYXgsZC5iYnhtYXhdXTtcblx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLm5hbWUgPSBkLm5hbWU7XG5cdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5ob2xjX2dyYWRlID0gZC5ob2xjX2dyYWRlO1xuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0uc3FtaSA9IGQuc3FtaTtcblxuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0udXJsID0gJ2h0dHA6Ly9ob2xjLnMzLXdlYnNpdGUtdXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vdGlsZXMvJyArIGQuc3RhdGUgKyAnLycgKyBkLmZpbGVfbmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKSAgKyAnLycgKyBkLnllYXIgKyAnL2Z1bGwtc2l6ZS8nICsgZC5ob2xjX2lkICsgJy5qcGcnO1xuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0udGlsZVVybCA9ICdodHRwOi8vaG9sYy5zMy13ZWJzaXRlLXVzLWVhc3QtMS5hbWF6b25hd3MuY29tL2Fkcy8nICsgZC5zdGF0ZSArICcvJyArIGQuZmlsZV9uYW1lLnJlcGxhY2UoL1xccysvZywgJycpICArICcvJyArIGQueWVhciArICcvJyArIGQuaG9sY19pZCArICcve3p9L3t4fV97eX0ucG5nJztcblx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLnRodW1ibmFpbFVybCA9ICdodHRwOi8vaG9sYy5zMy13ZWJzaXRlLXVzLWVhc3QtMS5hbWF6b25hd3MuY29tL2Fkcy8nICsgZC5zdGF0ZSArICcvJyArIGQuZmlsZV9uYW1lLnJlcGxhY2UoL1xccysvZywgJycpICArICcvJyArIGQueWVhciArICcvJyArIGQuaG9sY19pZCArICcvdGh1bWJuYWlsLmpwZyc7XG5cdFx0XHRcblx0XHRcdC8vIGRlZmluZSBhcmVhIGRlc2NyaXB0aW9uIGlmIHVuZGVmaW5lZFxuXHRcdFx0aWYodHlwZW9mIGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjID0ge307XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGRlZmluZSBjYXRlZ29yeSBpZCBmb3IgYXJlYSBkZXNjcmlwdGlvbiBpZiB1bmRlZmluZWRcblx0XHRcdGlmIChkLmNhdF9pZCAmJiBkLnN1Yl9jYXRfaWQgPT09ICcnICYmIGQub3JkZXIgPT09IG51bGwpIHtcblx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2NbZC5jYXRfaWRdID0gZC5kYXRhO1xuXHRcdFx0fSBlbHNlIGlmKGQuY2F0X2lkICYmIHR5cGVvZiBhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzY1tkLmNhdF9pZF0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjW2QuY2F0X2lkXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2hlY2sgZm9yIHN1YmNhdGVnb3JpZXNcblx0XHRcdGlmKGQuc3ViX2NhdF9pZCkge1xuXHRcdFx0XHQvLyBjcmVhdGUgc3ViLW9iamVjdCBpZiB3ZSBoYXZlIGEgc3ViY2F0ZWdvcnkuLi5cblx0XHRcdFx0aWYodHlwZW9mIGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjW2QuY2F0X2lkXVtkLnN1Yl9jYXRfaWRdID09ICd1bmRlZmluZWQnKSB7XG5cblx0XHRcdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzY1tkLmNhdF9pZF1bZC5zdWJfY2F0X2lkXSA9IHt9O1xuXG5cdFx0XHRcdFx0Ly8gbG9vayBmb3Igb3JkZXJcblx0XHRcdFx0XHRpZihkLm9yZGVyKSB7XG5cdFx0XHRcdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzY1tkLmNhdF9pZF1bZC5zdWJfY2F0X2lkXVtkLm9yZGVyXSA9ZC5kYXRhO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzY1tkLmNhdF9pZF1bZC5zdWJfY2F0X2lkXSA9IGQuZGF0YTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gXG5cblx0XHRcdC8vIGxvb2sgZm9yIG9yZGVyXG5cdFx0XHRlbHNlIGlmIChkLm9yZGVyKSB7IFxuXHRcdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzY1tkLmNhdF9pZF1bZC5vcmRlcl0gPSByYXdBZERhdGFbcm93XS5kYXRhO1xuXHRcdFx0fSBcblxuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2MgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdH0gIC8vIGVuZCBpZlxuXG5cdFx0cmV0dXJuIGFkRGF0YTtcblx0fSxcblxuXHRwYXJzZUFEc0J5Q2F0OiBmdW5jdGlvbihBRHMpIHtcblx0XHRsZXQgQURzQnlDYXQgPSB7fTtcblx0XHRPYmplY3Qua2V5cyhBRHMpLmZvckVhY2goZnVuY3Rpb24obmVpZ2hib3Job29kSWQpIHtcblx0XHRcdE9iamVjdC5rZXlzKEFEc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2MpLmZvckVhY2goZnVuY3Rpb24oY2F0KSB7XG5cdFx0XHRcdC8vIGluaXRpYWxpemUgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdEFEc0J5Q2F0W2NhdF0gPSBBRHNCeUNhdFtjYXRdIHx8IHt9O1xuXHRcdFx0XHRpZiAodHlwZW9mKEFEc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2NbY2F0XSkgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRBRHNCeUNhdFtjYXRdW25laWdoYm9yaG9vZElkXSA9IEFEc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2NbY2F0XTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YoQURzW25laWdoYm9yaG9vZElkXS5hcmVhRGVzY1tjYXRdKSA9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdE9iamVjdC5rZXlzKEFEc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2NbY2F0XSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViY2F0KSB7XG5cdFx0XHRcdFx0XHRBRHNCeUNhdFtjYXRdW3N1YmNhdF0gPSBBRHNCeUNhdFtjYXRdW3N1YmNhdF0gfHwge307XG5cdFx0XHRcdFx0XHRBRHNCeUNhdFtjYXRdW3N1YmNhdF1bbmVpZ2hib3Job29kSWRdID0gQURzW25laWdoYm9yaG9vZElkXS5hcmVhRGVzY1tjYXRdW3N1YmNhdF07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIEFEc0J5Q2F0O1xuXHR9LFxuXG5cdHBhcnNlSW52ZXJ0ZWRHZW9Kc29uOiBmdW5jdGlvbihnZW9qc29uKSB7XG5cdFx0Ly9DcmVhdGUgYSBuZXcgc2V0IG9mIGxhdGxuZ3MsIGFkZGluZyBvdXIgd29ybGQtc2l6ZWQgcmluZyBmaXJzdFxuXHRcdGxldCBOV0hlbWlzcGhlcmUgPSBbWzAsMF0sIFswLCA5MF0sIFstMTgwLCA5MF0sIFstMTgwLCAwXSwgWzAsMF1dLFxuXHRcdFx0bmV3TGF0TG5ncyA9IFsgTldIZW1pc3BoZXJlIF0sXG5cdFx0XHRob2xlcyA9W107XG5cblx0XHRnZW9qc29uLmNvb3JkaW5hdGVzLmZvckVhY2goKHBvbHlnb24sIGkpID0+IHtcblx0XHRcdHBvbHlnb24uZm9yRWFjaCgocG9seWdvbnBpZWNlcywgaTIpID0+IHtcblx0XHRcdFx0aWYgKGkyID09IDApIHtcblx0XHRcdFx0XHRuZXdMYXRMbmdzLnB1c2gocG9seWdvbnBpZWNlcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aG9sZXMucHVzaChwb2x5Z29ucGllY2VzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Z2VvanNvbi5jb29yZGluYXRlcyA9IChob2xlcy5sZW5ndGggPiAwKSA/IFtuZXdMYXRMbmdzLmNvbmNhdChob2xlcyldIDogW25ld0xhdExuZ3NdXG5cdFx0cmV0dXJuIGdlb2pzb247XG5cdH0sXG5cblx0Y2FsY3VsYXRlU2ltcGxlUmluZ3NSYWRpaTogZnVuY3Rpb24gKGFyZWFEYXRhKSB7XG5cdFx0bGV0IGZ1cnRoZXN0UmFkaXVzID0gMjUwMDAsXG5cdFx0XHRmdWxsQXJlYSA9IE1hdGguUEkgKiBmdXJ0aGVzdFJhZGl1cyAqIGZ1cnRoZXN0UmFkaXVzLFxuXHRcdFx0b3V0ZXJSYWRpdXMsXG5cdFx0XHRpbm5lclJhZGl1cyA9IDAsXG5cdFx0XHRkb251dEFyZWEsXG5cdFx0XHRncmFkZUFyZWEsXG5cdFx0XHRyYWRpaSA9IHt9O1xuXG5cdFx0WydkJywnYycsJ2InLCdhJ10uZm9yRWFjaCgoZ3JhZGUpID0+IHtcblx0XHRcdGxldCBkb251dGhvbGVBcmVhID0gTWF0aC5QSSAqIGlubmVyUmFkaXVzICogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdGdyYWRlQXJlYSA9IGZ1bGxBcmVhICogKGFyZWFEYXRhW2dyYWRlXSAvIGFyZWFEYXRhLnRvdGFsKSxcblx0XHRcdFx0b3V0ZXJSYWRpdXMgPSBNYXRoLnJvdW5kKE1hdGguc3FydCgoZ3JhZGVBcmVhICsgZG9udXRob2xlQXJlYSkgLyBNYXRoLlBJKSk7XG5cdFx0XHRyYWRpaVtncmFkZV0gPSB7XG5cdFx0XHRcdCdpbm5lcic6IGlubmVyUmFkaXVzLFxuXHRcdFx0XHQnb3V0ZXInOiBvdXRlclJhZGl1c1xuXHRcdFx0fTtcblx0XHRcdGlubmVyUmFkaXVzID0gb3V0ZXJSYWRpdXM7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcmFkaWk7XG5cdH0sXG5cblx0Z2V0TmFtZTogZnVuY3Rpb24oYWRJZCwgSE9MQ0lkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSAmJiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZFtIT0xDSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW0hPTENJZF0ubmFtZSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0VGh1bWJuYWlsVXJsOiBmdW5jdGlvbihhZElkLCBIT0xDSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW0hPTENJZF0pID8gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbSE9MQ0lkXS50aHVtYm5haWxVcmwgOiBudWxsO1xuXHR9LFxuXG5cdGdldEFkVXJsOiBmdW5jdGlvbihhZElkLCBIT0xDSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW0hPTENJZF0pID8gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbSE9MQ0lkXS51cmwgOiBudWxsO1xuXHR9LFxuXG5cdGdldEFkVGlsZVVybDogZnVuY3Rpb24oYWRJZCwgSE9MQ0lkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSAmJiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZCAmJiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZFtIT0xDSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW0hPTENJZF0udGlsZVVybCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVpZ2hib3Job29kTmFtZXM6IGZ1bmN0aW9uIChhZElkKSB7XG5cdFx0bGV0IG5hbWVzID0ge307XG5cdFx0aWYgKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKSB7XG5cdFx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZCkuZm9yRWFjaChob2xjSWQgPT4ge1xuXHRcdFx0XHRuYW1lc1tob2xjSWRdID0gdGhpcy5nZXROYW1lKGFkSWQsIGhvbGNJZCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWVzO1xuXHR9LFxuXG5cdGdldEFyZWFEZXNjcmlwdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9ucztcblx0fSxcblxuXHRnZXRBRHM6IGZ1bmN0aW9uKGFkSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kIDogZmFsc2U7XG5cdH0sXG5cblx0Z2V0QURzTWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuYWRzTWV0YWRhdGE7XG5cdH0sXG5cblx0Ly8gcmV0dXJuIGEgZmxhdCBsaXN0IG9mIHRoZSBIT0xDIG1hcHMgZm9yIHJlbmRlcmluZ1xuXHRnZXRBRHNMaXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hZHNNZXRhZGF0YSkubWFwKChhZElkKSA9PiB0aGlzLmRhdGEuYWRzTWV0YWRhdGFbYWRJZF0pOyB9LFxuXG5cdGdldEdlb0pzb25Gb3JHcmFkZTogZnVuY3Rpb24oYWRJZCwgZ3JhZGUpIHtcblx0XHRsZXQgcG9seWdvbnMgPSBbW1swLDBdLCBbMCwgOTBdLCBbLTE4MCwgOTBdLCBbLTE4MCwgMF0sIFswLDBdXV0sXG5cdFx0XHRob2xlcyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKS5mb3JFYWNoKChpZCwgaSkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW2lkXS5ob2xjX2dyYWRlID09IGdyYWRlKSB7XG5cdFx0XHRcdHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW2lkXS5hcmVhX2dlb2pzb24uY29vcmRpbmF0ZXMuZm9yRWFjaChjb29yZHNldCA9PiB7XG5cdFx0XHRcdFx0Y29vcmRzZXQuZm9yRWFjaCgoY29vcmRzLCBpMikgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGkyID09IDApIHtcblx0XHRcdFx0XHRcdFx0cG9seWdvbnMucHVzaChjb29yZHMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aG9sZXMucHVzaChjb29yZHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHBvbHlnb25zID0gKGhvbGVzLmxlbmd0aCA+IDApID8gW3BvbHlnb25zLmNvbmNhdChob2xlcyldIDogW3BvbHlnb25zXVxuXG5cdFx0bGV0IGdlb2pzb24gPSB7XG5cdFx0XHQndHlwZSc6ICdGZWF0dXJlJyxcblx0XHRcdCdnZW9tZXRyeSc6IHtcblx0XHRcdFx0J3R5cGUnOiAnTXVsdGlQb2x5Z29uJyxcblx0XHRcdFx0J2Nvb3JkaW5hdGVzJzogcG9seWdvbnNcblx0XHRcdH0sXG5cdFx0XHQncHJvcGVydGllcyc6IHt9XG5cdFx0fTtcblxuXHRcdHJldHVybiBnZW9qc29uO1xuXHR9LFxuXG5cdGdldEFEc0Zvck5laWdoYm9yaG9vZDogZnVuY3Rpb24oYWRJZCwgaG9sY0lkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSAmJiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZFtob2xjSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW2hvbGNJZF0uYXJlYURlc2MgOiBmYWxzZTtcblx0fSxcblxuXHRnZXRBRHNGb3JDYXRlZ29yeTogZnVuY3Rpb24oYWRJZCwgY2F0ZWdvcnkpIHtcblx0XHRpZiAoIXRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdIHx8ICFjYXRlZ29yeSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IFtjYXROdW0sIGNhdExldHRlcl0gPSBjYXRlZ29yeS5zcGxpdCgnLScpO1xuXG5cdFx0aWYgKCFjYXROdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieUNhdGVnb3J5O1xuXHRcdH1cblxuXHRcdGlmICghY2F0TGV0dGVyICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5Q2F0ZWdvcnlbY2F0TnVtXSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5Q2F0ZWdvcnlbY2F0TnVtXTtcblx0XHR9IGVsc2UgaWYgKGNhdExldHRlciAmJiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieUNhdGVnb3J5W2NhdE51bV0gJiYgdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlDYXRlZ29yeVtjYXROdW1dW2NhdExldHRlcl0pIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieUNhdGVnb3J5W2NhdE51bV1bY2F0TGV0dGVyXTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblxuXHRnZXRWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRsZXQgQURzID0ge307XG5cdFx0dGhpcy5kYXRhLmFkSWRzLmZvckVhY2goYWRJZCA9PiB7XG5cdFx0XHRpZiAodGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0pIHtcblx0XHRcdFx0QURzW2FkSWRdID0gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2Q7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIEFEcztcblx0fSxcblxuXHRnZXRWaXNpYmxlTWFwSWRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFkSWRzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKGFkSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmFyZWEgOiBudWxsO1xuXHR9LFxuXG5cdGdldE5laWdoYm9yaG9vZEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYWRJZCwgaG9sY0lkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSkgPyB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZFtob2xjSWRdLmJvdW5kaW5nQm94IDogbnVsbDtcblx0fSxcblxuXHRnZXROZWlnaGJvcmhvb2RDZW50ZXI6IGZ1bmN0aW9uIChhZElkLCBob2xjSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kW2hvbGNJZF0uY2VudGVyIDogbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c0hPTENJZDogZnVuY3Rpb24oYWRJZCwgSE9MQ0lkKSB7XG5cdFx0aWYgKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSB7XG5cdFx0XHRsZXQgZm9ybUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKS5zb3J0KHRoaXMuYWxwaGFudW1DYXNlKTtcblx0XHRcdHJldHVybiBmb3JtSWRzW2Zvcm1JZHMuaW5kZXhPZihIT0xDSWQpIC0gMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TmV4dEhPTENJZDogZnVuY3Rpb24oYWRJZCwgSE9MQ0lkKSB7XG5cdFx0aWYgKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSB7XG5cdFx0XHRsZXQgZm9ybUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKS5zb3J0KHRoaXMuYWxwaGFudW1DYXNlKTtcblx0XHRcdHJldHVybiBmb3JtSWRzW2Zvcm1JZHMuaW5kZXhPZihIT0xDSWQpICsgMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Rm9ybUlkOiBmdW5jdGlvbihhZElkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSkgPyB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5mb3JtSWQgOiBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzQ2F0SWRzOiBmdW5jdGlvbihhZElkLCBjYXROdW0sIGNhdExldHRlcikge1xuXHRcdGlmICghdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZvcm1JZCA9IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmZvcm1JZDtcblx0XHRmb3IgKGxldCBjaGVja0NhdE51bSA9ICghY2F0TGV0dGVyIHx8IGNhdExldHRlciA9PSAnYScpID8gcGFyc2VJbnQoY2F0TnVtKSAtIDEgOiBwYXJzZUludChjYXROdW0pOyBjaGVja0NhdE51bSA+PSAxOyBjaGVja0NhdE51bS0tKSB7XG5cdFx0XHRmb3IgKGxldCBjaGVja0NhdExldHRlciA9ICghY2F0TGV0dGVyIHx8IGNhdExldHRlciA9PSAnYScpID8gJ3onIDogU3RyaW5nLmZyb21DaGFyQ29kZShjYXRMZXR0ZXIuY2hhckNvZGVBdCgpLTEpOyBjaGVja0NhdExldHRlciA+PSAnYSc7IGNoZWNrQ2F0TGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGVja0NhdExldHRlci5jaGFyQ29kZUF0KCktMSksIGNhdExldHRlciA9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjaGVja0NhdE51bV0pID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJldHVybiBbY2hlY2tDYXROdW0sIHVuZGVmaW5lZF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NoZWNrQ2F0TnVtXSAmJiBmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2hlY2tDYXROdW1dLnN1YmNhdHMgJiYgdHlwZW9mKGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjaGVja0NhdE51bV0uc3ViY2F0c1tjaGVja0NhdExldHRlcl0pID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHJldHVybiBbY2hlY2tDYXROdW0sIGNoZWNrQ2F0TGV0dGVyXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXROZXh0Q2F0SWRzOiBmdW5jdGlvbihhZElkLCBjYXROdW0sIGNhdExldHRlcikge1xuXHRcdGlmICghdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZvcm1JZCA9IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmZvcm1JZDtcblx0XHRmb3IgKGxldCBjaGVja0NhdE51bSA9ICghY2F0TGV0dGVyKSA/IHBhcnNlSW50KGNhdE51bSkgKyAxIDogcGFyc2VJbnQoY2F0TnVtKTsgY2hlY2tDYXROdW0gPCAzMDsgY2hlY2tDYXROdW0rKykge1xuXHRcdFx0Zm9yIChsZXQgY2hlY2tDYXRMZXR0ZXIgPSAoIWNhdExldHRlciB8fCBjYXRMZXR0ZXIgPT0gJ3onKSA/ICdhJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2F0TGV0dGVyLmNoYXJDb2RlQXQoKSsxKTsgY2hlY2tDYXRMZXR0ZXIgPD0gJ3onOyBjaGVja0NhdExldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hlY2tDYXRMZXR0ZXIuY2hhckNvZGVBdCgpKzEpLCBjYXRMZXR0ZXIgPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZihmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2hlY2tDYXROdW1dKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2NoZWNrQ2F0TnVtLCB1bmRlZmluZWRdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjaGVja0NhdE51bV0gJiYgZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NoZWNrQ2F0TnVtXS5zdWJjYXRzICYmIHR5cGVvZihmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2hlY2tDYXROdW1dLnN1YmNhdHNbY2hlY2tDYXRMZXR0ZXJdKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2NoZWNrQ2F0TnVtLCBjaGVja0NhdExldHRlcl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0Q2F0VGl0bGU6IGZ1bmN0aW9uKGFkSWQsIGNhdCwgc3ViY2F0KSB7XG5cdFx0aWYgKCF0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZm9ybUlkID0gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uZm9ybUlkO1xuXHRcdGlmICghc3ViY2F0KSB7XG5cdFx0XHRyZXR1cm4gY2F0ICsgJyAnICsgZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NhdF07XG5cdFx0fSBlbHNlIGlmIChzdWJjYXQpIHtcblx0XHRcdHJldHVybiBjYXQgKyBzdWJjYXQgKyAnICcgKyBmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2F0XS5oZWFkZXIgKyAoKGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjYXRdLnN1YmNhdHNbc3ViY2F0XSAhPT0gJycpID8gJzogJyArIGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjYXRdLnN1YmNhdHNbc3ViY2F0XSA6ICcnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEFEc0FzR2VvanNvbiAoYWRJZCkge1xuXHRcdGNvbnNvbGUubG9nKGFkSWQpO1xuXHRcdGxldCBBRHMgPSB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZDtcblx0XHRsZXQgZmVhdHVyZXMgPSBPYmplY3Qua2V5cyhBRHMpLm1hcCgoaG9sY0lkKSA9PiB7IFxuXHRcdFx0bGV0IHRoZV9nZW9qc29uID0ge1xuXHRcdFx0XHR0eXBlOiBcIkZlYXR1cmVcIixcblx0XHRcdFx0Z2VvbWV0cnk6IEFEc1tob2xjSWRdLmFyZWFfZ2VvanNvbixcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdGlkOiBob2xjSWQsXG5cdFx0XHRcdFx0Z3JhZGU6IEFEc1tob2xjSWRdLmhvbGNfZ3JhZGUsXG5cdFx0XHRcdFx0bmFtZTogQURzW2hvbGNJZF0ubmFtZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdE9iamVjdC5rZXlzKEFEc1tob2xjSWRdLmFyZWFEZXNjKS5mb3JFYWNoKGNhdE51bSA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgQURzW2hvbGNJZF0uYXJlYURlc2NbY2F0TnVtXSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHRoZV9nZW9qc29uLnByb3BlcnRpZXNbJ2FkJyArIGNhdE51bV0gPSBBRHNbaG9sY0lkXS5hcmVhRGVzY1tjYXROdW1dO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5rZXlzKEFEc1tob2xjSWRdLmFyZWFEZXNjW2NhdE51bV0pLmZvckVhY2goY2F0TGV0dGVyID0+IHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgQURzW2hvbGNJZF0uYXJlYURlc2NbY2F0TnVtXVtjYXRMZXR0ZXJdID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRcdHRoZV9nZW9qc29uLnByb3BlcnRpZXNbJ2FkJyArIGNhdE51bSArIGNhdExldHRlcl0gPSBBRHNbaG9sY0lkXS5hcmVhRGVzY1tjYXROdW1dW2NhdExldHRlcl07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhBRHNbaG9sY0lkXS5hcmVhRGVzY1tjYXROdW1dW2NhdExldHRlcl0pLmZvckVhY2goc3VicGFydCA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0dGhlX2dlb2pzb24ucHJvcGVydGllc1snYWQnICsgY2F0TnVtICsgY2F0TGV0dGVyICsgc3VicGFydF0gPSBBRHNbaG9sY0lkXS5hcmVhRGVzY1tjYXROdW1dW2NhdExldHRlcl1bc3VicGFydF07XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHRoZV9nZW9qc29uO1xuXHRcdH0gKTtcblx0XHRsZXQgZ2VvanNvbiA9IHtcblx0XHRcdHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcblx0XHRcdGZlYXR1cmVzOiBmZWF0dXJlc1xuXHRcdH1cblxuXHRcdHJldHVybiBnZW9qc29uO1xuXHR9LFxuXG5cdGhhc0xvYWRlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuaGFzTG9hZGVkO1xuXHR9LFxuXG5cdGhhc0FERGF0YTogZnVuY3Rpb24oYWRJZCkge1xuXHRcdHJldHVybiAodGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0gJiYgdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbJ0MxJ10pO1xuXHR9LFxuXG5cdC8qIGFscGhhbnVtLmpzIChDKSBCcmlhbiBIdWlzbWFuXG5cdCogQmFzZWQgb24gdGhlIEFscGhhbnVtIEFsZ29yaXRobSBieSBEYXZpZCBLb2VsbGVcblx0KiBUaGUgQWxwaGFudW0gQWxnb3JpdGhtIGlzIGRpc2N1c3NlZCBhdCBodHRwOi8vd3d3LkRhdmVLb2VsbGUuY29tXG5cdCpcblx0KiBEaXN0cmlidXRlZCB1bmRlciBzYW1lIGxpY2Vuc2UgYXMgb3JpZ2luYWxcblx0KiBcblx0KiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG5cdCogbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuXHQqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuXHQqIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciBhbnkgbGF0ZXIgdmVyc2lvbi5cblx0KiBcblx0KiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcblx0KiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuXHQqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG5cdCogTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblx0KiBcblx0KiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG5cdCogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuXHQqIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgIDAyMTEwLTEzMDEgIFVTQVxuXHQqL1xuXHRhbHBoYW51bUNhc2U6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRmdW5jdGlvbiBjaHVua2lmeSh0KSB7XG5cdFx0XHR2YXIgdHogPSBuZXcgQXJyYXkoKTtcblx0XHRcdHZhciB4ID0gMCwgeSA9IC0xLCBuID0gMCwgaSwgajtcblx0XHRcdHdoaWxlIChpID0gKGogPSB0LmNoYXJBdCh4KyspKS5jaGFyQ29kZUF0KDApKSB7XG5cdFx0XHRcdHZhciBtID0gKGkgPT0gNDYgfHwgKGkgPj00OCAmJiBpIDw9IDU3KSk7XG5cdFx0XHRcdGlmIChtICE9PSBuKSB7XG5cdFx0XHRcdFx0dHpbKyt5XSA9ICcnO1xuXHRcdFx0XHRcdG4gPSBtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR6W3ldICs9IGo7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHo7XG5cdFx0fVxuXG5cdFx0dmFyIGFhID0gKGEubmVpZ2hib3Job29kSWQpID8gY2h1bmtpZnkoYS5uZWlnaGJvcmhvb2RJZC50b0xvd2VyQ2FzZSgpKSA6IGNodW5raWZ5KGEudG9Mb3dlckNhc2UoKSk7XG5cdFx0dmFyIGJiID0gKGIubmVpZ2hib3Job29kSWQpID8gY2h1bmtpZnkoYi5uZWlnaGJvcmhvb2RJZC50b0xvd2VyQ2FzZSgpKSA6IGNodW5raWZ5KGIudG9Mb3dlckNhc2UoKSk7XHRcblx0XHRmb3IgKGxldCB4ID0gMDsgYWFbeF0gJiYgYmJbeF07IHgrKykge1xuXHRcdFx0aWYgKGFhW3hdICE9PSBiYlt4XSkge1xuXHRcdFx0XHR2YXIgYyA9IE51bWJlcihhYVt4XSksIGQgPSBOdW1iZXIoYmJbeF0pO1xuXHRcdFx0XHRpZiAoYyA9PSBhYVt4XSAmJiBkID09IGJiW3hdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGMgLSBkO1xuXHRcdFx0XHR9IGVsc2UgcmV0dXJuIChhYVt4XSA+IGJiW3hdKSA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGFhLmxlbmd0aCAtIGJiLmxlbmd0aDtcblx0fVxuXG59O1xuXG4vLyBNaXhpbiBFdmVudEVtaXR0ZXIgZnVuY3Rpb25hbGl0eVxuT2JqZWN0LmFzc2lnbihBcmVhRGVzY3JpcHRpb25zU3RvcmUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBSZWdpc3RlciBjYWxsYmFjayB0byBoYW5kbGUgYWxsIHVwZGF0ZXNcbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoKGFjdGlvbikgPT4ge1xuXG5cblxuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmxvYWRJbml0aWFsRGF0YTpcblx0XHRcdEFwcERpc3BhdGNoZXIud2FpdEZvcihbTWFwU3RhdGVTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG5cdFx0XHRBcmVhRGVzY3JpcHRpb25zU3RvcmUubG9hZEFETWV0YWRhdGEoKTtcblx0XHRcdGlmIChhY3Rpb24uc3RhdGUuc2VsZWN0ZWRDaXR5KSB7XG5cdFx0XHRcdEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5sb2FkRGF0YShbYWN0aW9uLnN0YXRlLnNlbGVjdGVkQ2l0eV0pO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLm1hcE1vdmVkOlxuXHRcdFx0QXBwRGlzcGF0Y2hlci53YWl0Rm9yKFtNYXBTdGF0ZVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcblxuXHRcdFx0bGV0IHZpc2libGVIT0xDTWFwc0lkcyA9IE1hcFN0YXRlU3RvcmUuZ2V0VmlzaWJsZUhPTENNYXBzSWRzKCksXG5cdFx0XHRcdHZpc2libGVBRElkcyA9IE1hcFN0YXRlU3RvcmUuZ2V0VmlzaWJsZUFkSWRzKCk7XG5cblx0XHRcdGlmICh2aXNpYmxlQURJZHMgJiYgTWFwU3RhdGVTdG9yZS5pc0Fib3ZlWm9vbVRocmVzaG9sZCgpKSB7XG5cdFx0XHRcdEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5sb2FkRGF0YSh2aXNpYmxlQURJZHMpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXG5cdHJldHVybiB0cnVlO1xuXG59KTtcblxuXG5leHBvcnQgZGVmYXVsdCBBcmVhRGVzY3JpcHRpb25zU3RvcmU7IiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBBcHBEaXNwYXRjaGVyIGZyb20gJy4uL3V0aWxzL0FwcERpc3BhdGNoZXInO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDYXJ0b0RCTG9hZGVyIGZyb20gJy4uL3V0aWxzL0NhcnRvREJMb2FkZXInO1xuaW1wb3J0IGZvcm1zTWV0YWRhdGEgZnJvbSAnLi4vLi4vZGF0YS9mb3Jtc01ldGFkYXRhLmpzb24nO1xuaW1wb3J0IE1hcFN0YXRlU3RvcmUgZnJvbSAnLi4vc3RvcmVzL01hcFN0YXRlU3RvcmUnO1xuXG4vKiBDaXR5IFN0b3JlIGlzIHJlc3BvbnNpYmxlIGZvciBtYWludGFpbmluZyBtb3N0IG9mIHRoZSBpbXBvcnRhbnQgc3RhdGVcbnZhcmlhYmxlczogZS5nLiBzZWxlY3RlZCBjaXR5LCBuZWlnaGJvcmhvb2QsIGNhdGVnb3J5LCByaW5nLCBncmFkZSwgZXRjLiAqL1xuY29uc3QgQ2l0eVN0b3JlID0ge1xuXG5cdGRhdGE6IHtcblx0XHRpZDogbnVsbCxcblx0XHRuYW1lOiBudWxsLFxuXHRcdHN0YXRlOiBudWxsLFxuXHRcdHllYXI6IG51bGwsXG5cdFx0c2VsZWN0ZWRSaW5nR3JhZGU6IHtcblx0XHRcdHJpbmdJZDogLTEsXG5cdFx0XHRncmFkZTogbnVsbFxuXHRcdH0sXG5cdFx0c2VsZWN0ZWRIb2xjSWQ6IG51bGwsXG5cdFx0c2VsZWN0ZWRDYXRlZ29yeTogbnVsbCxcblx0XHRzZWxlY3RlZEdyYWRlOiBudWxsLFxuXHRcdGhpZ2hsaWdodGVkSG9sY0lkOiBudWxsLFxuXHRcdGFyZWFzOiB7fSxcblx0XHRyaW5nQXJlYXNHZW9tZXRyeTogW10sIC8vIG5vdCB0aGUgcmluZ3MgdGhlbXNlbHZlcyBidXQgdGhlIGludGVyc2VjdGlvbiBvZiByaW5ncyBhbmQgYXJlYXNcblx0XHRsb29wTGF0TG5nOiBbXSxcblx0XHQvLyB0aGUgZGlzdGFuY2UgaW4gbWV0ZXJzIGJldHdlZW4gdGhlIGxvb3AgY2VudGVyIGFuZCB0aGUgb3V0ZXJtb3N0IHBvaW50XG5cdFx0b3V0ZXJSaW5nUmFkaXVzOiBudWxsLFxuXHRcdGNpdHlEYXRhOiB7fSxcblxuXHRcdC8qKiBQZXJjZW50YWdlcyBvZiBlYWNoIHJpbmcgZm9yIGVhY2ggZ3JhZGUsIHdpdGggXG5cdFx0ICogZGVuc2l0eSByZWNvcmRpbmcgdGhlIGFtb3VudCBvZiBuZWlnaGJvcmhvb2QgYXJlYSBcblx0XHQgKiBpbiB0aGUgcmluZy5cblx0XHQgKiB7XG5cdFx0ICogICAxOiB7XG5cdFx0ICogICAgICdBJzogZmxvYXQsXG5cdFx0ICogICAgICdCJzogZmxvYXQsXG5cdFx0ICogICAgICdDJzogZmxvYXQsXG5cdFx0ICogICAgICdEJzogZmxvYXQsXG5cdFx0ICogICAgICdkZW5zaXR5JzogZmxvYXQsXG5cdFx0ICogICB9LFxuXHRcdCAqICAgMjogeyAuLi4gfSxcblx0XHQgKiAgIC4uLlxuXHRcdCB9XG5cdFx0ICogfVxuXHRcdCAqL1xuXHRcdHJpbmdTdGF0czogW10sXG5cdFx0Z3JhZGVTdGF0czogW10sXG5cblx0XHRBRHNCeUNhdDoge30sXG5cdFx0cG9seWdvbkJvdW5kaW5nQm94OiBudWxsLFxuXHRcdHBvbHlnb25zQ2VudGVyOiBudWxsLFxuXHRcdGdyYWRlZEFyZWE6IG51bGwsXG5cdFx0Z3JhZGVkQXJlYU9mUmluZ3M6IHt9LFxuXHRcdGdyYWRlZEFyZWFCeUdyYWRlOiB7fSxcblx0XHR1c2Vyczoge1xuXHRcdFx0bGF0TG5nOiBudWxsLFxuXHRcdFx0YWRJZDogbnVsbCxcblx0XHRcdGNpdHk6IG51bGwsXG5cdFx0XHRuZWlnaGJvcmhvb2Q6IG51bGwsXG5cdFx0XHRvZmZlclpvb21UbzogZmFsc2Vcblx0XHR9LFxuXHRcdHNlbGVjdGVkQnlVc2VyOiBmYWxzZSxcblx0XHRoYXNMb2FkZWQ6IGZhbHNlXG5cdH0sXG5cblx0Y2FjaGU6IHt9LFxuXG5cdC8vIFRPRE86IE1ha2UgYSBnZW5lcmljIERhdGFMb2FkZXIgY2xhc3MgdG8gZGVmaW5lIGFuIGludGVyZmFjZSxcblx0Ly8gYW5kIGxldCBDYXJ0b0RCTG9hZGVyIGV4dGVuZCBhbmQgaW1wbGVtZW50IHRoYXQ/XG5cdC8vIEJhc2ljIGlkZWEgaXMgdGhhdCBhbnl0aGluZyB3aXRoIGEgcXVlcnkgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFByb21pc2Vcblx0Ly8gdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIHJlc3BvbnNlIGRhdGEgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG5cdC8vIGNhbiBiZSB1c2VkIGhlcmUuXG5cdGRhdGFMb2FkZXI6IENhcnRvREJMb2FkZXIsXG5cblx0bG9hZERhdGE6IGZ1bmN0aW9uIChjaXR5SWQsIHNlbGVjdGVkQnlVc2VyKSB7XG5cdFx0aWYgKGNpdHlJZCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmRhdGEuaWQgPSBudWxsO1xuXHRcdFx0dGhpcy5kYXRhLnNlbGVjdGVkSG9sY0lkID0gbnVsbDtcblx0XHRcdHRoaXMuZGF0YS5zZWxlY3RlZENhdGVnb3J5ID0gbnVsbDtcblx0XHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjaXR5SWQgPT0gdGhpcy5kYXRhLmlkKSB7XG5cdFx0XHQvLyBhbHJlYWR5IGxvYWRlZDtcblx0XHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgY2l0eSBkYXRhIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIGFuZCBzdG9yZWQgaW4gY2FjaGVcblx0XHQvLyBpZiAodGhpcy5jYWNoZVtjaXR5SWRdKSB7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZyh0aGlzLmNhY2hlKTtcblx0XHQvLyBcdHRoaXMuZGF0YSA9IHRoaXMuY2FjaGVbY2l0eUlkXTtcblx0XHQvLyBcdGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG5cdFx0Ly8gXHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0XHQvLyBcdHJldHVybjtcblx0XHQvLyB9XG5cblx0XHR0aGlzLmRhdGFMb2FkZXIucXVlcnkoW1xuXHRcdFx0e1xuXHRcdFx0XHRxdWVyeTogJ1NFTEVDVCAqIGZyb20gaG9sY19hZHMgd2hlcmUgY2l0eV9pZCA9ICcgKyBjaXR5SWQsXG5cdFx0XHRcdGZvcm1hdDogJ0pTT04nXG5cdFx0XHR9LFxuXHRcdFx0Ly8gZ2V0IHJpbmcgcG9seWdvbnNcblx0XHRcdHtcblx0XHRcdFx0cXVlcnk6ICdXSVRIIHRoZV9odWxsIGFzIChzZWxlY3QgU1RfQ29sbGVjdChkaWdpdGFsc2Nob2xhcnNoaXBsYWIuaG9sY19wb2x5Z29ucy50aGVfZ2VvbV93ZWJtZXJjYXRvcikgYXMgaHVsbCwgYWRfaWQgRlJPTSBkaWdpdGFsc2Nob2xhcnNoaXBsYWIuaG9sY19wb2x5Z29ucyB3aGVyZSBhZF9pZCA9ICcgKyBjaXR5SWQgKyAnIEdST1VQIEJZIGFkX2lkKSwgbWF4ZGlzdCBhcyAoU0VMRUNUIHN0X2Rpc3RhbmNlX3NwaGVyZShzdF90cmFuc2Zvcm0oc3RfZW5kcG9pbnQoc3RfbG9uZ2VzdGxpbmUoc3RfdHJhbnNmb3JtKFNUX1NldFNSSUQoU1RfTWFrZVBvaW50KGxvb3BsbmcsbG9vcGxhdCksNDMyNiksMzg1NyksIGh1bGwpKSwgNDMyNiksIFNUX1NldFNSSUQoU1RfTWFrZVBvaW50KGxvb3BsbmcsbG9vcGxhdCksIDQzMjYpKSBhcyBvdXRlcnJpbmdyYWRpdXMsIHN0X2xlbmd0aChzdF9sb25nZXN0bGluZShzdF90cmFuc2Zvcm0oU1RfU2V0U1JJRChTVF9Qb2ludChsb29wbG5nLGxvb3BsYXQpLDQzMjYpLDM4NTcpLCBodWxsKSkgLyAzLjUgYXMgZGlzdGludHYsIFNUX1RyYW5zZm9ybShTVF9TZXRTUklEKFNUX01ha2VQb2ludChsb29wbG5nLGxvb3BsYXQpLDQzMjYpLDM4NTcpOjpnZW9tZXRyeSBhcyB0aGVfcG9pbnQgZnJvbSB0aGVfaHVsbCBqb2luIGhvbGNfYWRzIG9uIHRoZV9odWxsLmFkX2lkID0gaG9sY19hZHMuY2l0eV9pZCBhbmQgaG9sY19hZHMuY2l0eV9pZCA9ICcgKyBjaXR5SWQgKyAnIE9yZGVyIGJ5IGRpc3RpbnR2IERFU0MgTGltaXQgMSApLCBjaXR5X2J1ZmZlcnMgYXMgKFNFTEVDVCBTVF9UcmFuc2Zvcm0oKFNUX0J1ZmZlcih0aGVfcG9pbnQsZGlzdGludHYgKiAzLjUsXFwncXVhZF9zZWdzPTMyXFwnKTo6Z2VvbWV0cnkpLDM4NTcpIGFzIGJ1ZmZlcjQsIFNUX1RyYW5zZm9ybSgoU1RfQnVmZmVyKHRoZV9wb2ludCxkaXN0aW50diAqIDIuNSxcXCdxdWFkX3NlZ3M9MzJcXCcpOjpnZW9tZXRyeSksMzg1NykgYXMgYnVmZmVyMywgU1RfVHJhbnNmb3JtKChTVF9CdWZmZXIodGhlX3BvaW50LGRpc3RpbnR2ICogMS41LFxcJ3F1YWRfc2Vncz0zMlxcJyk6Omdlb21ldHJ5KSwzODU3KSBhcyBidWZmZXIyLCBTVF9UcmFuc2Zvcm0oKFNUX0J1ZmZlcih0aGVfcG9pbnQsZGlzdGludHYgKiAwLjUsXFwncXVhZF9zZWdzPTMyXFwnKTo6Z2VvbWV0cnkpLDM4NTcpIGFzIGJ1ZmZlcjEgRlJPTSBtYXhkaXN0KSwgY2l0eV9yaW5ncyBhcyAoU0VMRUNUIFNUX0RpZmZlcmVuY2UoYnVmZmVyNCwgYnVmZmVyMykgYXMgdGhlX2dlb21fd2VibWVyY2F0b3IsIDQgYXMgcmluZ19pZCwgc3RfYXJlYShTVF9EaWZmZXJlbmNlKGJ1ZmZlcjQsIGJ1ZmZlcjMpKSBhcyByaW5nX2FyZWEgZnJvbSBjaXR5X2J1ZmZlcnMgdW5pb24gYWxsIHNlbGVjdCBTVF9EaWZmZXJlbmNlKGJ1ZmZlcjMsIGJ1ZmZlcjIpIGFzIHRoZV9nZW9tX3dlYm1lcmNhdG9yLCAzIGFzIHJpbmdfaWQsIHN0X2FyZWEoU1RfRGlmZmVyZW5jZShidWZmZXIzLCBidWZmZXIyKSkgYXMgcmluZ19hcmVhIGZyb20gY2l0eV9idWZmZXJzIHVuaW9uIGFsbCBzZWxlY3QgU1RfRGlmZmVyZW5jZShidWZmZXIyLCBidWZmZXIxKSBhcyB0aGVfZ2VvbV93ZWJtZXJjYXRvciwgMiBhcyByaW5nX2lkLCBzdF9hcmVhKFNUX0RpZmZlcmVuY2UoYnVmZmVyMiwgYnVmZmVyMSkpIGFzIHJpbmdfYXJlYSBmcm9tIGNpdHlfYnVmZmVycyB1bmlvbiBhbGwgc2VsZWN0IGJ1ZmZlcjEgYXMgdGhlX3dlYm1lcmNhdG9yLCAxIGFzIHJpbmdfaWQsIHN0X2FyZWEoYnVmZmVyMSkgYXMgcmluZ19hcmVhIGZyb20gY2l0eV9idWZmZXJzICksIGNvbWJpbmVkX2dyYWRlcyBhcyAoU0VMRUNUIGhvbGNfZ3JhZGUsIFNUX3VuaW9uKHRoZV9nZW9tX3dlYm1lcmNhdG9yKSBhcyB0aGVfZ2VvbV93ZWJtZXJjYXRvciBGUk9NIGRpZ2l0YWxzY2hvbGFyc2hpcGxhYi5ob2xjX3BvbHlnb25zIHdoZXJlIGFkX2lkID0gJyArIGNpdHlJZCArICcgZ3JvdXAgYnkgaG9sY19ncmFkZSkgU0VMRUNUIGhvbGNfZ3JhZGUgYXMgZ3JhZGUsIHJpbmdfaWQgYXMgcmluZywgU1RfQXNHZW9KU09OKFNUX1RyYW5zZm9ybShTVF9JbnRlcnNlY3Rpb24oY2l0eV9yaW5ncy50aGVfZ2VvbV93ZWJtZXJjYXRvciwgY29tYmluZWRfZ3JhZGVzLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSw0MzI2KSwgNCkgYXMgdGhlX2dlb2pzb24sIFNUX0FzR2VvSlNPTihTVF9UcmFuc2Zvcm0oU1RfRGlmZmVyZW5jZShjaXR5X3JpbmdzLnRoZV9nZW9tX3dlYm1lcmNhdG9yLCBjb21iaW5lZF9ncmFkZXMudGhlX2dlb21fd2VibWVyY2F0b3IpLDQzMjYpLCA0KSBhcyBpbnZlcnRlZF9nZW9qc29uLCBzdF9hcmVhKFNUX0ludGVyc2VjdGlvbihjaXR5X3JpbmdzLnRoZV9nZW9tX3dlYm1lcmNhdG9yLCBjb21iaW5lZF9ncmFkZXMudGhlX2dlb21fd2VibWVyY2F0b3IpKSBhcyBhcmVhLCBTVF9BcmVhKGNpdHlfcmluZ3MudGhlX2dlb21fd2VibWVyY2F0b3IpIGFzIHJpbmdfYXJlYSwgb3V0ZXJyaW5ncmFkaXVzIEZST00gY2l0eV9yaW5ncywgY29tYmluZWRfZ3JhZGVzLCBtYXhkaXN0Jyxcblx0XHRcdFx0Zm9ybWF0OiAnSlNPTidcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXJ5OiAnU2VsZWN0IHN0X3goc3RfY2VudHJvaWQoU1RfU2V0U1JJRChzdF9leHRlbnQodGhlX2dlb20pLDQzMjYpKSkgYXMgY2VudGVyTG5nLCBzdF95KHN0X2NlbnRyb2lkKFNUX1NldFNSSUQoc3RfZXh0ZW50KHRoZV9nZW9tKSw0MzI2KSkpIGFzIGNlbnRlckxhdCwgc3RfeG1pbihTVF9TZXRTUklEKHN0X2V4dGVudCh0aGVfZ2VvbSksNDMyNikpIGFzIG1pbmxuZywgc3RfeW1pbihTVF9TZXRTUklEKHN0X2V4dGVudCh0aGVfZ2VvbSksNDMyNikpIGFzIG1pbmxhdCwgc3RfeG1heChTVF9TZXRTUklEKHN0X2V4dGVudCh0aGVfZ2VvbSksNDMyNikpIGFzIG1heGxuZywgc3RfeW1heChTVF9TZXRTUklEKHN0X2V4dGVudCh0aGVfZ2VvbSksNDMyNikpIGFzIG1heGxhdCBmcm9tIGRpZ2l0YWxzY2hvbGFyc2hpcGxhYi5ob2xjX3BvbHlnb25zIHdoZXJlIGFkX2lkID0gJyArIGNpdHlJZCxcblx0XHRcdFx0Zm9ybWF0OiAnSlNPTidcblx0XHRcdH1cblx0XHRdKS50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0dGhpcy5kYXRhLmlkID0gcGFyc2VJbnQoY2l0eUlkKTtcblx0XHRcdHRoaXMuZGF0YS5zZWxlY3RlZEJ5VXNlciA9IHNlbGVjdGVkQnlVc2VyO1xuXG5cdFx0XHRsZXQgY2l0eURhdGEgPSByZXNwb25zZVswXVswXTtcblx0XHRcdHRoaXMuZGF0YS5uYW1lID0gY2l0eURhdGEuY2l0eTtcblx0XHRcdHRoaXMuZGF0YS5zdGF0ZSA9IGNpdHlEYXRhLnN0YXRlO1xuXHRcdFx0dGhpcy5kYXRhLnllYXIgPSBjaXR5RGF0YS55ZWFyO1xuXHRcdFx0dGhpcy5kYXRhLmZvcm1faWQgPSBjaXR5RGF0YS5mb3JtX2lkO1xuXHRcdFx0dGhpcy5kYXRhLmNpdHlEYXRhID0gY2l0eURhdGE7XG5cblx0XHRcdGNvbnN0IHJpbmdEYXRhID0gcmVzcG9uc2VbMV07XG5cdFx0XHR0aGlzLmRhdGEuZ3JhZGVkQXJlYSA9IHRoaXMuY2FsY3VsYXRlZEdyYWRlZEFyZWEocmluZ0RhdGEpO1xuXHRcdFx0dGhpcy5kYXRhLmdyYWRlZEFyZWFPZlJpbmdzID0gdGhpcy5jYWxjdWxhdGVHcmFkZWRBcmVhT2ZSaW5ncyhyaW5nRGF0YSk7XG5cdFx0XHR0aGlzLmRhdGEuZ3JhZGVkQXJlYUJ5R3JhZGUgPSB0aGlzLmNhbGN1bGF0ZUdyYWRlZEFyZWFCeUdyYWRlKHJpbmdEYXRhKTtcblx0XHRcdHRoaXMuZGF0YS5yaW5nQXJlYXNHZW9tZXRyeSA9IHRoaXMucGFyc2VSaW5nQXJlYUdlb21ldHJ5KHJpbmdEYXRhKTtcblx0XHRcdHRoaXMuZGF0YS5yaW5nU3RhdHMgPSB0aGlzLnBhcnNlUmluZ1N0YXRzKHRoaXMuZGF0YS5yaW5nQXJlYXNHZW9tZXRyeSk7XG5cdFx0XHR0aGlzLmRhdGEub3V0ZXJSaW5nUmFkaXVzID0gKHJlc3BvbnNlWzFdWzBdKSA/IHJlc3BvbnNlWzFdWzBdLm91dGVycmluZ3JhZGl1cyA6IGZhbHNlO1xuXHRcdFx0dGhpcy5kYXRhLmxvb3BMYXRMbmcgPSAoY2l0eURhdGEpID8gW2NpdHlEYXRhLmxvb3BsYXQsIGNpdHlEYXRhLmxvb3BsbmddIDogZmFsc2U7XG5cdFx0XHR0aGlzLmRhdGEuZ3JhZGVTdGF0cyA9IHRoaXMucGFyc2VHcmFkZVN0YXRzKHRoaXMuZGF0YS5yaW5nQXJlYXNHZW9tZXRyeSk7XG5cdFx0XHRcblx0XHRcdGxldCBwb2x5Z29uTGF0TG5ncyA9IHJlc3BvbnNlWzJdWzBdO1xuXHRcdFx0aWYgKHBvbHlnb25MYXRMbmdzLm1pbmxhdCkge1xuXHRcdFx0XHR0aGlzLmRhdGEucG9seWdvbkJvdW5kaW5nQm94ID0gWyBbcG9seWdvbkxhdExuZ3MubWlubGF0LCBwb2x5Z29uTGF0TG5ncy5taW5sbmddLCBbcG9seWdvbkxhdExuZ3MubWF4bGF0LCBwb2x5Z29uTGF0TG5ncy5tYXhsbmddIF07XG5cdFx0XHRcdHRoaXMuZGF0YS5wb2x5Z29uc0NlbnRlciA9IFsgcG9seWdvbkxhdExuZ3MuY2VudGVybGF0LCBwb2x5Z29uTGF0TG5ncy5jZW50ZXJsbmcgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGF0YS5wb2x5Z29uQm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdFx0XHR0aGlzLmRhdGEucG9seWdvbnNDZW50ZXIgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmRhdGEuaGFzTG9hZGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ0NpdHlTdG9yZSBmaW5pc2hlZCBsb2FkaW5nJyk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLmRhdGEpO1xuXG5cdFx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblxuXHRcdH0sIChlcnJvcikgPT4ge1xuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIHRoaXMuXG5cdFx0XHRjb25zb2xlLmxvZygnQ2l0eVN0b3JlIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGdldENpdHlGcm9tUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0bGV0IGFkSWQ7XG5cdFx0dGhpcy5kYXRhTG9hZGVyLnF1ZXJ5KFtcblx0XHRcdHtcblx0XHRcdFx0cXVlcnk6ICdTRUxFQ1QgYWRfaWQsIGNpdHksIFNUX2Rpc3RhbmNlKFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KGhvbGNfbWFwcy5sb29wbG5nLCBob2xjX21hcHMubG9vcGxhdCksNDMyNiksIFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KCcgKyBwb2ludFsxXSArJywgJyArIHBvaW50WzBdICsgJyksNDMyNikpIGFzIGRpc3RhbmNlLCBzdF94bWluKCBzdF9lbnZlbG9wZShzdF9jb2xsZWN0KFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KCcgKyBwb2ludFsxXSArJywgJyArIHBvaW50WzBdICsgJyksNDMyNiksIGhvbGNfbWFwcy50aGVfZ2VvbSkpKSBhcyBiYnhtaW4sIHN0X3htYXgoIHN0X2VudmVsb3BlKHN0X2NvbGxlY3QoU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoJyArIHBvaW50WzFdICsnLCAnICsgcG9pbnRbMF0gKyAnKSw0MzI2KSwgaG9sY19tYXBzLnRoZV9nZW9tKSkpIGFzIGJieG1heCwgc3RfeW1pbiggc3RfZW52ZWxvcGUoc3RfY29sbGVjdChTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpLCBob2xjX21hcHMudGhlX2dlb20pKSkgYXMgYmJ5bWluLCBzdF95bWF4KCBzdF9lbnZlbG9wZShzdF9jb2xsZWN0KFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KCcgKyBwb2ludFsxXSArJywgJyArIHBvaW50WzBdICsgJyksNDMyNiksIGhvbGNfbWFwcy50aGVfZ2VvbSkpKSBhcyBiYnltYXggZnJvbSBob2xjX21hcHMgam9pbiBob2xjX21hcHNfYWRzX2pvaW4gb24gaG9sY19tYXBzLm1hcF9pZCA9IGhvbGNfbWFwc19hZHNfam9pbi5tYXBfaWQgam9pbiBob2xjX2FkcyBvbiBob2xjX2Fkcy5jaXR5X2lkID0gaG9sY19tYXBzX2Fkc19qb2luLmFkX2lkIG9yZGVyIGJ5IGRpc3RhbmNlIGxpbWl0IDEnLFxuXHRcdFx0XHRmb3JtYXQ6ICdKU09OJ1xuXHRcdFx0fVxuXHRcdF0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHR0aGlzLmRhdGEudXNlcnMuY2l0eSA9IHJlc3BvbnNlWzBdWzBdLmNpdHk7XG5cdFx0XHR0aGlzLmRhdGEudXNlcnMuYWRJZCA9IHJlc3BvbnNlWzBdWzBdLmFkX2lkO1xuXG5cdFx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMudXNlckxvY2F0ZWQpO1xuXHRcdH0sIChlcnJvcikgPT4ge1xuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIHRoaXMuXG5cdFx0XHRjb25zb2xlLmxvZygnTG9jYXRpb24gcmVjZWl2ZWQgZXJyb3I6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fSk7XG5cdH0sXG5cblx0Lyogc2V0dGVyIGZ1bmN0aW9ucyBmb3Igc3RhdGUgdmFyaWFibGUgKi9cblxuXHRzZXRIaWdobGlnaHRlZEhvbGNJZDogZnVuY3Rpb24gKGhvbGNJZCkge1xuXHRcdHRoaXMuZGF0YS5oaWdobGlnaHRlZEhvbGNJZCA9IGhvbGNJZDtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZENhdGVnb3J5OiBmdW5jdGlvbiAoaWQpIHtcblx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRDYXRlZ29yeSA9IGlkO1xuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkSG9sY0lkOiBmdW5jdGlvbiAoaG9sY0lkKSB7XG5cdFx0dGhpcy5kYXRhLnNlbGVjdGVkSG9sY0lkID0gaG9sY0lkO1xuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkR3JhZGU6IGZ1bmN0aW9uIChncmFkZSkge1xuXHRcdHRoaXMuZGF0YS5zZWxlY3RlZEdyYWRlID0gZ3JhZGU7XG5cdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWRSaW5nR3JhZGU6IGZ1bmN0aW9uIChzZWxlY3RlZFJpbmdHcmFkZSkge1xuXHRcdHRoaXMuZGF0YS5zZWxlY3RlZFJpbmdHcmFkZSA9IHNlbGVjdGVkUmluZ0dyYWRlO1xuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdC8qIGdldHRlciBmdW5jdGlvbnMgKi9cblxuXHRnZXRIaWdobGlnaHRlZEhvbGNJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5oaWdobGlnaHRlZEhvbGNJZDtcblx0fSxcblxuXHRnZXRJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5pZDtcblx0fSxcblxuXHRnZXRTZWxlY3RlZENhdGVnb3J5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnNlbGVjdGVkQ2F0ZWdvcnk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRIb2xjSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc2VsZWN0ZWRIb2xjSWQ7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRHcmFkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZEdyYWRlO1xuXHR9LFxuXG5cdGdldFNlbGVjdGVkUmluZ0dyYWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnNlbGVjdGVkUmluZ0dyYWRlO1xuXHR9LFxuXG5cdGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEubmFtZTtcblx0fSxcblxuXHRnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zdGF0ZTtcblx0fSxcblxuXHRnZXRGb3JtSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuZm9ybV9pZDtcblx0fSxcblxuXHRnZXRSaW5nU3RhdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEucmluZ1N0YXRzO1xuXHR9LFxuXG5cdGdldFJpbmdBcmVhc0dlb21ldHJ5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnJpbmdBcmVhc0dlb21ldHJ5O1xuXHR9LFxuXG5cdGdldEdyYWRlU3RhdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuZ3JhZGVTdGF0cztcblx0fSxcblxuXHRnZXRDaXR5RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jaXR5RGF0YTtcblx0fSxcblxuXHRnZXRTZWxlY3RlZEdyYWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnNlbGVjdGVkR3JhZGU7XG5cdH0sXG5cblx0Z2V0R2VvSnNvbkZvclNlbGVjdGVkUmluZ0FyZWE6IGZ1bmN0aW9uKHJpbmcsIGdyYWRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5yaW5nQXJlYXNHZW9tZXRyeVtyaW5nXVtncmFkZV0udGhlX2dlb2pzb247XG5cdH0sXG5cblx0Z2V0SW52ZXJ0ZWRHZW9Kc29uRm9yU2VsZWN0ZWRSaW5nQXJlYTogZnVuY3Rpb24ocmluZywgZ3JhZGUpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnJpbmdBcmVhc0dlb21ldHJ5W3JpbmddW2dyYWRlXS5pbnZlcnRlZF9nZW9qc29uO1xuXHR9LFxuXG5cdGdldE91dGVyUmluZ1JhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5vdXRlclJpbmdSYWRpdXM7XG5cdH0sXG5cblx0Z2V0TG9vcExhdExuZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sb29wTGF0TG5nO1xuXHR9LFxuXG5cdGdldFBvbHlnb25zQm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnBvbHlnb25Cb3VuZGluZ0JveDtcblx0fSxcblxuXHRnZXRQb2x5Z29uc0NlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5wb2x5Z29uc0NlbnRlcjtcblx0fSxcblxuXHRnZXRTZWxlY3RlZEJ5VXNlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZEJ5VXNlcjtcblx0fSxcblxuXHRnZXRVc2Vyc0NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudXNlcnMuY2l0eTtcblx0fSxcblxuXHRnZXRVc2Vyc0FkSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudXNlcnMuYWRJZDtcblx0fSxcblxuXHRnZXRVc2Vyc05laWdoYm9yaG9vZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS51c2Vycy5uZWlnaGJvcmhvb2Q7XG5cdH0sXG5cblx0Z2V0QURzQnlDYXQ6IGZ1bmN0aW9uKGNhdCwgc3ViY2F0KSB7XG5cdFx0aWYgKCFjYXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuQURzQnlDYXQ7XG5cdFx0fVxuXG5cdFx0aWYgKCFzdWJjYXQgJiYgdGhpcy5kYXRhLkFEc0J5Q2F0W2NhdF0pIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuQURzQnlDYXRbY2F0XTtcblx0XHR9IGVsc2UgaWYgKHN1YmNhdCAmJiB0aGlzLmRhdGEuQURzQnlDYXRbY2F0XSAmJiB0aGlzLmRhdGEuQURzQnlDYXRbY2F0XVtzdWJjYXRdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLkFEc0J5Q2F0W2NhdF1bc3ViY2F0XTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENhdGVnb3J5U3RyaW5nOiBmdW5jdGlvbihjYXROdW0sIGNhdExldHRlcikge1xuXHRcdHJldHVybiBjYXROdW0gKyAoKGNhdExldHRlcikgPyAnLScgKyBjYXRMZXR0ZXIgOiAnJyk7XG5cdH0sXG5cblx0Z2V0Q2F0VGl0bGU6IGZ1bmN0aW9uKGNhdCwgc3ViY2F0KSB7XG5cdFx0bGV0IGZvcm1JZCA9IHRoaXMuZ2V0Rm9ybUlkKCk7XG5cdFx0aWYgKCFzdWJjYXQpIHtcblx0XHRcdHJldHVybiBjYXQgKyAnICcgKyBmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2F0XTtcblx0XHR9IGVsc2UgaWYgKHN1YmNhdCkge1xuXHRcdFx0cmV0dXJuIGNhdCArIHN1YmNhdCArICcgJyArIGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjYXRdLmhlYWRlciArICgoZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NhdF0uc3ViY2F0c1tzdWJjYXRdICE9PSAnJykgPyAnOiAnICsgZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NhdF0uc3ViY2F0c1tzdWJjYXRdIDogJycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdHF1ZXJ5Q2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdE51bSwgY2F0TGV0dGVyKSB7XG5cdFx0aWYgKE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zKS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHRsZXQgYXJyID0gW107IC8vIGFycmF5IHRvIHN0b3JlIHJlc3VsdHNcblxuXHRcdE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zKS5tYXAoKG5laWdoYm9yaG9vZElkLCBpKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjLmhhc093blByb3BlcnR5KGNhdE51bSkgJiYgdHlwZW9mKGNhdExldHRlcikgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0YXJyLnB1c2goIHsgbmVpZ2hib3Job29kSWQ6IG5laWdoYm9yaG9vZElkLCBhbnN3ZXI6IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW25laWdoYm9yaG9vZElkXS5hcmVhRGVzY1tjYXROdW1dLmEgfSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW25laWdoYm9yaG9vZElkXS5hcmVhRGVzYy5oYXNPd25Qcm9wZXJ0eShjYXROdW0pICYmdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjW2NhdE51bV0uaGFzT3duUHJvcGVydHkoY2F0TGV0dGVyKSkge1xuXHRcdFx0XHRhcnIucHVzaCggeyBuZWlnaGJvcmhvb2RJZDogbmVpZ2hib3Job29kSWQsIGFuc3dlcjogdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjW2NhdE51bV1bY2F0TGV0dGVyXS5hIH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyLnB1c2goeyBuZWlnaGJvcmhvb2RJZDogbmVpZ2hib3Job29kSWQsIGFuc3dlcjogbnVsbCB9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFyci5zb3J0KHRoaXMuYWxwaGFudW1DYXNlKTtcblxuXHRcdHJldHVybiBhcnI7XG5cdH0sXG5cblx0Y2FsY3VsYXRlZEdyYWRlZEFyZWE6IGZ1bmN0aW9uKGdlb21ldHJpZXMpIHtcblx0XHRsZXQgZ3JhZGVkVG90YWxBcmVhID0gMDtcblx0XHRnZW9tZXRyaWVzLmZvckVhY2goKGQpID0+IHtcblx0XHRcdGdyYWRlZFRvdGFsQXJlYSArPSBkLmFyZWE7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZ3JhZGVkVG90YWxBcmVhO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZUdyYWRlZEFyZWFPZlJpbmdzOiBmdW5jdGlvbihnZW9tZXRyaWVzKSB7XG5cdFx0bGV0IGdyYWRlZEFyZWFPZlJpbmdzID0gezE6MCwyOjAsMzowLDQ6MH07XG5cdFx0Z2VvbWV0cmllcy5mb3JFYWNoKChkKSA9PiB7XG5cdFx0XHRncmFkZWRBcmVhT2ZSaW5nc1tkLnJpbmddICs9IGQuYXJlYTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBncmFkZWRBcmVhT2ZSaW5ncztcblx0fSxcblxuXHRjYWxjdWxhdGVHcmFkZWRBcmVhQnlHcmFkZTogZnVuY3Rpb24oZ2VvbWV0cmllcykge1xuXHRcdGxldCBncmFkZWRBcmVhQnlHcmFkZSA9IHsnQSc6MCwnQic6MCwnQyc6MCwnRCc6MH07XG5cdFx0Z2VvbWV0cmllcy5mb3JFYWNoKChkKSA9PiB7XG5cdFx0XHRncmFkZWRBcmVhQnlHcmFkZVtkLmdyYWRlXSArPSBkLmFyZWE7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZ3JhZGVkQXJlYUJ5R3JhZGU7XG5cdH0sXG5cblx0cGFyc2VSaW5nQXJlYUdlb21ldHJ5OiBmdW5jdGlvbihnZW9tZXRyaWVzKSB7XG5cdFx0aWYgKGdlb21ldHJpZXMubGVuZ3RoID09IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRsZXQgZGVmYXVsdFByb3BzID0ge1xuXHRcdFx0XHR0aGVfZ2VvanNvbjoge30sXG5cdFx0XHRcdGludmVydGVkX2dlb2pzb246IHt9LFxuXHRcdFx0XHRwZXJjZW50OiAwLFxuXHRcdFx0XHRvdmVyYWxsUGVyY2VudDogMFxuXHRcdFx0fSxcblx0XHRcdHJpbmdBcmVhc0dlb21ldHJ5ICA9IHtcblx0XHRcdFx0MToge0E6IGRlZmF1bHRQcm9wcywgQjogZGVmYXVsdFByb3BzLCBDOiBkZWZhdWx0UHJvcHMsIEQ6IGRlZmF1bHRQcm9wc30sXG5cdFx0XHRcdDI6IHtBOiBkZWZhdWx0UHJvcHMsIEI6IGRlZmF1bHRQcm9wcywgQzogZGVmYXVsdFByb3BzLCBEOiBkZWZhdWx0UHJvcHN9LFxuXHRcdFx0XHQzOiB7QTogZGVmYXVsdFByb3BzLCBCOiBkZWZhdWx0UHJvcHMsIEM6IGRlZmF1bHRQcm9wcywgRDogZGVmYXVsdFByb3BzfSxcblx0XHRcdFx0NDoge0E6IGRlZmF1bHRQcm9wcywgQjogZGVmYXVsdFByb3BzLCBDOiBkZWZhdWx0UHJvcHMsIEQ6IGRlZmF1bHRQcm9wc31cblx0XHRcdH07XG5cblx0XHRnZW9tZXRyaWVzLmZvckVhY2goKGQpID0+IHtcblx0XHRcdHJpbmdBcmVhc0dlb21ldHJ5W2QucmluZ10uZGVuc2l0eSA9IHRoaXMuZGF0YS5ncmFkZWRBcmVhT2ZSaW5nc1tkLnJpbmddIC8gZC5yaW5nX2FyZWE7XG5cdFx0XHRyaW5nQXJlYXNHZW9tZXRyeVtkLnJpbmddW2QuZ3JhZGVdID0ge1xuXHRcdFx0XHQndGhlX2dlb2pzb24nOiBKU09OLnBhcnNlKGQudGhlX2dlb2pzb24pLFxuXHRcdFx0XHQnaW52ZXJ0ZWRfZ2VvanNvbic6IEpTT04ucGFyc2UoZC5pbnZlcnRlZF9nZW9qc29uKSxcblx0XHRcdFx0J3BlcmNlbnQnOiBkLmFyZWEgLyB0aGlzLmRhdGEuZ3JhZGVkQXJlYU9mUmluZ3NbZC5yaW5nXSxcblx0XHRcdFx0J292ZXJhbGxQZXJjZW50JzogZC5hcmVhIC8gdGhpcy5kYXRhLmdyYWRlZEFyZWFcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcmluZ0FyZWFzR2VvbWV0cnk7XG5cdH0sXG5cblx0cGFyc2VSaW5nU3RhdHM6IGZ1bmN0aW9uKHJpbmdTdGF0cykge1xuXHRcdGlmICghcmluZ1N0YXRzIHx8IHJpbmdTdGF0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIGxldCByaW5nQ3VtdWxhdGl2ZSA9IHtcblx0XHRcdFx0MTogeydBJzogMCwgJ0InOiAwLCAnQyc6IDAsICdEJzogMCwgJ3RvdGFsJzogMH0sXG5cdFx0XHRcdDI6IHsnQSc6IDAsICdCJzogMCwgJ0MnOiAwLCAnRCc6IDAsICd0b3RhbCc6IDB9LFxuXHRcdFx0XHQzOiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAndG90YWwnOiAwfSxcblx0XHRcdFx0NDogeydBJzogMCwgJ0InOiAwLCAnQyc6IDAsICdEJzogMCwgJ3RvdGFsJzogMH1cblx0XHRcdH0sXG5cdFx0XHRhcmVhT2ZSaW5ncyA9IHt9LFxuXHRcdFx0dG90YWxHcmFkZWRBcmVhID0gMCwgXG5cdFx0XHRyaW5nU3RhdHMgPSB7IDEgOiB7fSwgMjoge30sIDM6IHt9LCA0OiB7fSB9O1xuXHRcdHJpbmdBcmVhR2VvbWV0cnkuZm9yRWFjaCgocmluZykgPT4ge1xuXHRcdFx0cmluZ0N1bXVsYXRpdmVbcmluZy5yaW5nX2lkXVtyaW5nLmhvbGNfZ3JhZGVdICs9IHJpbmcuYXJlYTtcblx0XHRcdHJpbmdDdW11bGF0aXZlW3JpbmcucmluZ19pZF0udG90YWwgKz0gcmluZy5hcmVhO1xuXHRcdFx0YXJlYU9mUmluZ3NbcmluZy5yaW5nX2lkXSA9IHJpbmcucmluZ19hcmVhO1xuXHRcdFx0dG90YWxHcmFkZWRBcmVhICs9IHJpbmcuYXJlYTtcblx0XHR9KTtcblx0XHRjb25zb2xlLmxvZyh0b3RhbEdyYWRlZEFyZWEpO1xuXHRcdE9iamVjdC5rZXlzKHJpbmdDdW11bGF0aXZlKS5tYXAoKHJpbmdfaWQpID0+IHtcblx0XHRcdE9iamVjdC5rZXlzKHJpbmdDdW11bGF0aXZlW3JpbmdfaWRdKS5tYXAoKGdyYWRlKSA9PiB7XG5cdFx0XHRcdHJpbmdTdGF0c1tyaW5nX2lkXVtncmFkZV0gPSAocmluZ1N0YXRzW3JpbmdfaWRdW2dyYWRlXSkgPyByaW5nU3RhdHNbcmluZ19pZF1bZ3JhZGVdIDoge307XG5cdFx0XHRcdHJpbmdTdGF0c1tyaW5nX2lkXVtncmFkZV0ucGVyY2VudCA9IHJpbmdDdW11bGF0aXZlW3JpbmdfaWRdW2dyYWRlXSAvIHJpbmdDdW11bGF0aXZlW3JpbmdfaWRdLnRvdGFsO1xuXHRcdFx0XHRyaW5nU3RhdHNbcmluZ19pZF0uZGVuc2l0eSA9IHJpbmdDdW11bGF0aXZlW3JpbmdfaWRdLnRvdGFsIC8gYXJlYU9mUmluZ3NbcmluZ19pZF07XG5cdFx0XHRcdHJpbmdTdGF0c1tyaW5nX2lkXVtncmFkZV0ub3ZlcmFsbFBlcmNlbnQgPSByaW5nQ3VtdWxhdGl2ZVtyaW5nX2lkXVtncmFkZV0gLyB0b3RhbEdyYWRlZEFyZWE7XG5cdFx0XHR9KTtcblx0XHR9KTsgKi9cblxuXHRcdC8vZm9ybWF0IGZvciBEM1xuXHRcdGxldCBmb3JtYXR0ZWRTdGF0cyA9IFtdO1xuXHRcdGZvciAobGV0IHJpbmdJZCA9IDE7IHJpbmdJZCA8PSA0OyByaW5nSWQrKykge1xuXHRcdFx0Zm9ybWF0dGVkU3RhdHMucHVzaCh7IFxuXHRcdFx0XHRwZXJjZW50czogWyBcblx0XHRcdFx0XHR7IHBlcmNlbnQ6IHJpbmdTdGF0c1tyaW5nSWRdLkEucGVyY2VudCwgb3ZlcmFsbFBlcmNlbnQ6IHJpbmdTdGF0c1tyaW5nSWRdLkEub3ZlcmFsbFBlcmNlbnQsIHJpbmdJZDogcmluZ0lkLCBvcGFjaXR5OiByaW5nU3RhdHNbcmluZ0lkXS5kZW5zaXR5LCBncmFkZTogJ0EnIH0sIFxuXHRcdFx0XHRcdHsgcGVyY2VudDogcmluZ1N0YXRzW3JpbmdJZF0uQi5wZXJjZW50LCBvdmVyYWxsUGVyY2VudDogcmluZ1N0YXRzW3JpbmdJZF0uQi5vdmVyYWxsUGVyY2VudCwgcmluZ0lkOiByaW5nSWQsIG9wYWNpdHk6IHJpbmdTdGF0c1tyaW5nSWRdLmRlbnNpdHksIGdyYWRlOiAnQicgfSwgXG5cdFx0XHRcdFx0eyBwZXJjZW50OiByaW5nU3RhdHNbcmluZ0lkXS5DLnBlcmNlbnQsIG92ZXJhbGxQZXJjZW50OiByaW5nU3RhdHNbcmluZ0lkXS5DLm92ZXJhbGxQZXJjZW50LCByaW5nSWQ6IHJpbmdJZCwgb3BhY2l0eTogcmluZ1N0YXRzW3JpbmdJZF0uZGVuc2l0eSwgZ3JhZGU6ICdDJyB9LCBcblx0XHRcdFx0XHR7IHBlcmNlbnQ6IHJpbmdTdGF0c1tyaW5nSWRdLkQucGVyY2VudCwgb3ZlcmFsbFBlcmNlbnQ6IHJpbmdTdGF0c1tyaW5nSWRdLkQub3ZlcmFsbFBlcmNlbnQsIHJpbmdJZDogcmluZ0lkLCBvcGFjaXR5OiByaW5nU3RhdHNbcmluZ0lkXS5kZW5zaXR5LCBncmFkZTogJ0QnIH0gXG5cdFx0XHRcdF0gfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvcm1hdHRlZFN0YXRzO1xuXHR9LFxuXG5cdGhhc0xvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5oYXNMb2FkZWQ7XG5cdH0sXG5cblx0cGFyc2VHcmFkZVN0YXRzOiBmdW5jdGlvbihyaW5nQXJlYXNHZW9tZXRyeSkge1xuXHRcdGxldCBncmFkZXMgPSBbJ0EnLCdCJywnQycsJ0QnXTtcblxuXHRcdC8vZm9ybWF0IGZvciBEM1xuXHRcdHJldHVybiBncmFkZXMubWFwKChncmFkZSkgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Z3JhZGU6IGdyYWRlLFxuXHRcdFx0XHRwZXJjZW50OiB0aGlzLmRhdGEuZ3JhZGVkQXJlYUJ5R3JhZGVbZ3JhZGVdIC8gdGhpcy5kYXRhLmdyYWRlZEFyZWFcblx0XHRcdH07XG5cdFx0fSk7XG5cdH0sXG5cblx0cGFyc2VJbnZlcnRlZEdlb0pzb246IGZ1bmN0aW9uKGdlb2pzb24pIHtcblx0XHQvL0NyZWF0ZSBhIG5ldyBzZXQgb2YgbGF0bG5ncywgYWRkaW5nIG91ciB3b3JsZC1zaXplZCByaW5nIGZpcnN0XG5cdFx0bGV0IE5XSGVtaXNwaGVyZSA9IFtbMCwwXSwgWzAsIDkwXSwgWy0xODAsIDkwXSwgWy0xODAsIDBdLCBbMCwwXV0sXG5cdFx0XHRuZXdMYXRMbmdzID0gWyBOV0hlbWlzcGhlcmUgXSxcblx0XHRcdGhvbGVzID1bXTtcblxuXHRcdGdlb2pzb24uY29vcmRpbmF0ZXMuZm9yRWFjaCgocG9seWdvbiwgaSkgPT4ge1xuXHRcdFx0cG9seWdvbi5mb3JFYWNoKChwb2x5Z29ucGllY2VzLCBpMikgPT4ge1xuXHRcdFx0XHRpZiAoaTIgPT0gMCkge1xuXHRcdFx0XHRcdG5ld0xhdExuZ3MucHVzaChwb2x5Z29ucGllY2VzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRob2xlcy5wdXNoKHBvbHlnb25waWVjZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRnZW9qc29uLmNvb3JkaW5hdGVzID0gKGhvbGVzLmxlbmd0aCA+IDApID8gW25ld0xhdExuZ3MuY29uY2F0KGhvbGVzKV0gOiBbbmV3TGF0TG5nc11cblx0XHRyZXR1cm4gZ2VvanNvbjtcblx0fSxcblxuXHQvKiBhbHBoYW51bS5qcyAoQykgQnJpYW4gSHVpc21hblxuXHQqIEJhc2VkIG9uIHRoZSBBbHBoYW51bSBBbGdvcml0aG0gYnkgRGF2aWQgS29lbGxlXG5cdCogVGhlIEFscGhhbnVtIEFsZ29yaXRobSBpcyBkaXNjdXNzZWQgYXQgaHR0cDovL3d3dy5EYXZlS29lbGxlLmNvbVxuXHQqXG5cdCogRGlzdHJpYnV0ZWQgdW5kZXIgc2FtZSBsaWNlbnNlIGFzIG9yaWdpbmFsXG5cdCogXG5cdCogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuXHQqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcblx0KiBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcblx0KiB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgYW55IGxhdGVyIHZlcnNpb24uXG5cdCogXG5cdCogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5cdCogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcblx0KiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuXHQqIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cdCogXG5cdCogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuXHQqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcblx0KiBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BICAwMjExMC0xMzAxICBVU0Fcblx0Ki9cblx0YWxwaGFudW1DYXNlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0ZnVuY3Rpb24gY2h1bmtpZnkodCkge1xuXHRcdFx0dmFyIHR6ID0gbmV3IEFycmF5KCk7XG5cdFx0XHR2YXIgeCA9IDAsIHkgPSAtMSwgbiA9IDAsIGksIGo7XG5cdFx0XHR3aGlsZSAoaSA9IChqID0gdC5jaGFyQXQoeCsrKSkuY2hhckNvZGVBdCgwKSkge1xuXHRcdFx0XHR2YXIgbSA9IChpID09IDQ2IHx8IChpID49NDggJiYgaSA8PSA1NykpO1xuXHRcdFx0XHRpZiAobSAhPT0gbikge1xuXHRcdFx0XHRcdHR6WysreV0gPSAnJztcblx0XHRcdFx0XHRuID0gbTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0elt5XSArPSBqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHR6O1xuXHRcdH1cblxuXHRcdHZhciBhYSA9IChhLm5laWdoYm9yaG9vZElkKSA/IGNodW5raWZ5KGEubmVpZ2hib3Job29kSWQudG9Mb3dlckNhc2UoKSkgOiBjaHVua2lmeShhLnRvTG93ZXJDYXNlKCkpO1xuXHRcdHZhciBiYiA9IChiLm5laWdoYm9yaG9vZElkKSA/IGNodW5raWZ5KGIubmVpZ2hib3Job29kSWQudG9Mb3dlckNhc2UoKSkgOiBjaHVua2lmeShiLnRvTG93ZXJDYXNlKCkpO1x0XG5cdFx0Zm9yIChsZXQgeCA9IDA7IGFhW3hdICYmIGJiW3hdOyB4KyspIHtcblx0XHRcdGlmIChhYVt4XSAhPT0gYmJbeF0pIHtcblx0XHRcdFx0dmFyIGMgPSBOdW1iZXIoYWFbeF0pLCBkID0gTnVtYmVyKGJiW3hdKTtcblx0XHRcdFx0aWYgKGMgPT0gYWFbeF0gJiYgZCA9PSBiYlt4XSkge1xuXHRcdFx0XHRcdHJldHVybiBjIC0gZDtcblx0XHRcdFx0fSBlbHNlIHJldHVybiAoYWFbeF0gPiBiYlt4XSkgPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhYS5sZW5ndGggLSBiYi5sZW5ndGg7XG5cdH1cbn07XG5cbi8vIE1peGluIEV2ZW50RW1pdHRlciBmdW5jdGlvbmFsaXR5XG5PYmplY3QuYXNzaWduKENpdHlTdG9yZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIGhhbmRsZSBhbGwgdXBkYXRlc1xuQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKChhY3Rpb24pID0+IHtcblxuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLkFEQ2F0ZWdvcnlTZWxlY3RlZDpcblx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZENhdGVnb3J5KGFjdGlvbi52YWx1ZSk7XG5cdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRIb2xjSWQobnVsbCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMubG9hZEluaXRpYWxEYXRhOlxuXHRcdFx0aWYgKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHkpIHtcblx0XHRcdFx0Q2l0eVN0b3JlLmxvYWREYXRhKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCkge1xuXHRcdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRIb2xjSWQoYWN0aW9uLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKTtcblx0XHRcdH1cblx0XHRcdGlmIChhY3Rpb24uc3RhdGUuc2VsZWN0ZWRDYXRlZ29yeSkge1xuXHRcdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRDYXRlZ29yeShhY3Rpb24uc3RhdGUuc2VsZWN0ZWRDYXRlZ29yeSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMuY2l0eVNlbGVjdGVkOlxuXHRcdFx0Q2l0eVN0b3JlLmxvYWREYXRhKGFjdGlvbi52YWx1ZSwgYWN0aW9uLnNlbGVjdGVkQnlVc2VyKTtcblx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZEhvbGNJZChudWxsKTtcblx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZENhdGVnb3J5KG51bGwpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmdyYWRlU2VsZWN0ZWQ6XG5cdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRHcmFkZShhY3Rpb24udmFsdWUpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLm5laWdoYm9yaG9vZEhpZ2hsaWdodGVkOlxuXHRcdFx0Q2l0eVN0b3JlLnNldEhpZ2hsaWdodGVkSG9sY0lkKGFjdGlvbi5ob2xjSWQpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLm5laWdoYm9yaG9vZFNlbGVjdGVkOlxuXHRcdFx0Q2l0eVN0b3JlLnNldFNlbGVjdGVkQ2F0ZWdvcnkobnVsbCk7XG5cdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRIb2xjSWQoYWN0aW9uLmhvbGNJZCk7XG5cdFx0XHRpZiAoYWN0aW9uLmFkSWQgIT09IENpdHlTdG9yZS5nZXRJZCgpKSB7XG5cdFx0XHRcdENpdHlTdG9yZS5sb2FkRGF0YShhY3Rpb24uYWRJZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLnJpbmdHcmFkZVNlbGVjdGVkOlxuXHRcdFx0Q2l0eVN0b3JlLnNldFNlbGVjdGVkUmluZ0dyYWRlKGFjdGlvbi52YWx1ZSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMubWFwTW92ZWQ6XG5cdFx0XHRBcHBEaXNwYXRjaGVyLndhaXRGb3IoW01hcFN0YXRlU3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuXG5cdFx0XHQvLyB5b3UgaGF2ZSB0byB3YWl0IGZvciBpbml0aWFsIGxvYWQgb2YgbWFwc3RvcmVcblx0XHRcdGNvbnN0IHdhaXRpbmdJbml0aWFsTG9hZCA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh3YWl0aW5nSW5pdGlhbExvYWQpO1xuXG5cdFx0XHRcdGxldCB2aXNpYmxlQWRJZHMgPSBNYXBTdGF0ZVN0b3JlLmdldFZpc2libGVBZElkcygpO1xuXHRcdFx0XHQvLyB1bmxvYWQgY2l0eSBpZiBub3RoaW5nJ3MgdmlzaWJsZSBvciBiZWxvdyB6b29tIHRocmVzaG9sZFxuXHRcdFx0XHRpZiAodmlzaWJsZUFkSWRzLmxlbmd0aCA9PSAwIHx8ICFNYXBTdGF0ZVN0b3JlLmlzQWJvdmVab29tVGhyZXNob2xkKCkpIHtcblx0XHRcdFx0XHRDaXR5U3RvcmUubG9hZERhdGEobnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbG9hZCBhIGNpdHkgaWYgdGhlcmUncyBvbmx5IG9uZSB2aXNpYmxlIGFuZCBpdCdzIGRpZmZlcmVudFxuXHRcdFx0XHRlbHNlIGlmICh2aXNpYmxlQWRJZHMubGVuZ3RoID09IDEgJiYgdmlzaWJsZUFkSWRzWzBdICE9PSBDaXR5U3RvcmUuZ2V0SWQoKSkge1xuXHRcdFx0XHRcdENpdHlTdG9yZS5sb2FkRGF0YSh2aXNpYmxlQWRJZHNbMF0sIHsgem9vbVRvOiBmYWxzZSB9KTtcblx0XHRcdFx0fSBcblx0XHRcdFx0Ly8gdW5sb2FkIHRoZSBjaXR5IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIGJ1dCBpdCdzIG5vdCBhbW9uZyB0aGVtXG5cdFx0XHRcdGVsc2UgaWYgKHZpc2libGVBZElkcy5sZW5ndGggPiAxICYmIHZpc2libGVBZElkcy5pbmRleE9mKENpdHlTdG9yZS5nZXRJZCgpKSA9PSAtMSkge1xuXHRcdFx0XHRcdENpdHlTdG9yZS5sb2FkRGF0YShudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1bmxvYWQgY2l0eSBpZiBtb3JlIHRoYW4gb25lIGFyZSB2aXNpYmxlIGFuZCBpdCdzIGJlbG93IHRoZSB6b29tIHRocmVzaG9sZFxuXHRcdFx0XHRlbHNlIGlmICh2aXNpYmxlQWRJZHMubGVuZ3RoID4gMSAmJiAhTWFwU3RhdGVTdG9yZS5pc0Fib3ZlWm9vbVRocmVzaG9sZCgpKSB7XG5cdFx0XHRcdFx0Q2l0eVN0b3JlLmxvYWREYXRhKG51bGwpO1xuXHRcdFx0XHR9IFxuXHRcdFx0fSwgMTAwKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cblxuXHRyZXR1cm4gdHJ1ZTtcblxufSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2l0eVN0b3JlOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgQXBwRGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5cbmNvbnN0IERpbWVuc2lvbnNTdG9yZSA9IHtcblxuXHRkYXRhOiB7XG5cdFx0Y29udGFpbmVyUGFkZGluZzogMjAsXG5cdFx0aGVhZGVySGVpZ2h0OiAxMDAsXG5cdFx0dGlsZXNIZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIDE0MCwgLy8gdHdvIHBhZGRpbmdzICsgaGVhZGVySGVpZ2h0XG5cdFx0c2lkZWJhclRpdGxlQm90dG9tTWFyZ2luOiAxMCxcblx0XHRhZE5hdkhlaWdodDogMjAsXG5cblx0XHRzaWRlYmFyV2lkdGg6IDAsXG5cdFx0bWFpblBhbmVXaWR0aDogMCxcblx0XHRzaWRlYmFyVGl0bGVIZWlnaHQ6IDBcblx0fSxcblxuXHRjb21wdXRlQ29tcG9uZW50RGltZW5zaW9ucyAoKSB7XG5cdFx0dGhpcy5kYXRhLnRpbGVzSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5kYXRhLmhlYWRlckhlaWdodCAtIDIqdGhpcy5kYXRhLmNvbnRhaW5lclBhZGRpbmc7XG5cdFx0dGhpcy5kYXRhLnNpZGViYXJXaWR0aCA9KGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RhdGFWaWV3ZXInKS5sZW5ndGggPiAwKSA/IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RhdGFWaWV3ZXInKVswXS5vZmZzZXRXaWR0aCA6IDA7XG5cdFx0dGhpcy5kYXRhLm1haW5QYW5lV2lkdGggPSAoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFpbi1wYW5lJykubGVuZ3RoID4gMCkgPyBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYWluLXBhbmUnKVswXS5vZmZzZXRXaWR0aCA6IDA7XG5cdFx0dGhpcy5kYXRhLnNpZGViYXJUaXRsZUhlaWdodCA9IChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzaWRlYmFyVGl0bGUnKS5sZW5ndGggPiAwKSA/IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NpZGViYXJUaXRsZScpWzBdLm9mZnNldEhlaWdodDogMDtcblxuXHRcdGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG5cblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRnZXREaW1lbnNpb25zICgpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhO1xuXHR9LFxuXG5cdGdldE1haW5QYW5lU3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7IGhlaWdodDogdGhpcy5kYXRhLnRpbGVzSGVpZ2h0ICsgJ3B4JyB9O1xuXHR9LFxuXG5cdGdldFNpZGViYXJIZWlnaHRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc2FtZSBhcyB0aGUgbWFpbiBwYW5lbCBzdHlsZSBhcyBpdCdzIGp1c3QgdGhlIGhlaWdodFxuXHRcdHJldHVybiB0aGlzLmdldE1haW5QYW5lU3R5bGUoKTtcblx0fSxcblxuXHRnZXRBRFZpZXdlclN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVpZ2h0OiAodGhpcy5kYXRhLnRpbGVzSGVpZ2h0IC0gdGhpcy5kYXRhLmNvbnRhaW5lclBhZGRpbmcgKiAyKSArICdweCcsXG5cdFx0XHR3aWR0aDogKHRoaXMuZGF0YS5tYWluUGFuZVdpZHRoIC0gdGhpcy5kYXRhLmNvbnRhaW5lclBhZGRpbmcgKiAyKSArICdweCdcblx0XHR9XG5cdH0sXG5cblx0Ly8gdGhpcyBuZWVkcyB0byBiZSByZWRvbmVcblxuXHRnZXRTZWFyY2hTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiAod2luZG93LmlubmVyV2lkdGggLyAzIC0gMiAqIHRoaXMuZGF0YS5jb250YWluZXJQYWRkaW5nKSArICdweCcsXG5cdFx0XHRoZWlnaHQ6ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSAyICogdGhpcy5kYXRhLmNvbnRhaW5lclBhZGRpbmcpICsgJ3B4J1xuXHRcdH1cblx0fSxcblxuXHRnZXRBRE5hdlByZXZpb3VzU3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogdGhpcy5kYXRhLnRpbGVzSGVpZ2h0ICsgJ3B4Jyxcblx0XHRcdHRvcDogKCh0aGlzLmRhdGEudGlsZXNIZWlnaHQgKyB0aGlzLmRhdGEuY29udGFpbmVyUGFkZGluZykgLyAyICsgdGhpcy5kYXRhLmhlYWRlckhlaWdodCkgKyAncHgnLFxuXHRcdFx0cmlnaHQ6ICh0aGlzLmRhdGEuY29udGFpbmVyUGFkZGluZyAqIDEuNSAtIHRoaXMuZGF0YS50aWxlc0hlaWdodCAvIDIgKyB0aGlzLmRhdGEuc2lkZWJhcldpZHRoIC0gdGhpcy5kYXRhLmFkTmF2SGVpZ2h0KSArICdweCdcblx0XHR9XG5cdH0sXG5cblx0Z2V0QUROYXZOZXh0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogdGhpcy5kYXRhLnRpbGVzSGVpZ2h0ICsgJ3B4Jyxcblx0XHRcdHRvcDogKCh0aGlzLmRhdGEudGlsZXNIZWlnaHQgKyB0aGlzLmRhdGEuY29udGFpbmVyUGFkZGluZykgLyAyICsgdGhpcy5kYXRhLmhlYWRlckhlaWdodCkgKyAncHgnLFxuXHRcdFx0cmlnaHQ6ICh0aGlzLmRhdGEuY29udGFpbmVyUGFkZGluZyAqIDEuNSAtIHRoaXMuZGF0YS50aWxlc0hlaWdodCAvIDIpICsgJ3B4J1xuXHRcdH1cblx0fSxcblxuXHRnZXRTaWRlYmFyTWFwU3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKHRoaXMuZGF0YS50aWxlc0hlaWdodCwgdGhpcy5kYXRhLnNpZGViYXJUaXRsZUhlaWdodCwgdGhpcy5kYXRhLmNvbnRhaW5lclBhZGRpbmcpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogKHRoaXMuZGF0YS5zaWRlYmFyV2lkdGggLSAyKnRoaXMuZGF0YS5hZE5hdkhlaWdodCkgKyAncHgnLFxuXHRcdFx0aGVpZ2h0OiAodGhpcy5kYXRhLnRpbGVzSGVpZ2h0IC0gdGhpcy5kYXRhLnNpZGViYXJUaXRsZUhlaWdodCAtIHRoaXMuZGF0YS5zaWRlYmFyVGl0bGVCb3R0b21NYXJnaW4gLSAyKnRoaXMuZGF0YS5jb250YWluZXJQYWRkaW5nKSArICdweCdcblx0XHR9XG5cdH1cblxuXG59XG5cbi8vIE1peGluIEV2ZW50RW1pdHRlciBmdW5jdGlvbmFsaXR5XG5PYmplY3QuYXNzaWduKERpbWVuc2lvbnNTdG9yZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIGhhbmRsZSBhbGwgdXBkYXRlc1xuRGltZW5zaW9uc1N0b3JlLmRpc3BhdGNoVG9rZW4gPSBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKChhY3Rpb24pID0+IHtcblxuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5sb2FkSW5pdGlhbERhdGE6XG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5tYXBJbml0aWFsaXplZDpcblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLndpbmRvd1Jlc2l6ZWQ6XG5cdFx0XHREaW1lbnNpb25zU3RvcmUuY29tcHV0ZUNvbXBvbmVudERpbWVuc2lvbnMoKTtcblx0XHRcdGJyZWFrO1xuXHR9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRGltZW5zaW9uc1N0b3JlOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgQXBwRGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5pbXBvcnQgQXJlYURlc2NyaXB0aW9uc1N0b3JlIGZyb20gJy4uL3N0b3Jlcy9BcmVhRGVzY3JpcHRpb25zU3RvcmUnO1xuaW1wb3J0IENpdHlTdG9yZSBmcm9tICcuLi9zdG9yZXMvQ2l0eVN0b3JlJztcbmltcG9ydCBSYXN0ZXJTdG9yZSBmcm9tICcuLi9zdG9yZXMvUmFzdGVyU3RvcmUnO1xuXG5jb25zdCBNYXBTdGF0ZVN0b3JlID0ge1xuXG5cdGRhdGE6IHtcblx0XHR0aGVNYXA6IG51bGwsXG5cdFx0Y2VudGVyOiBbMzkuODMzMzMzMywtOTguNTg1NTIyXSxcblx0XHR6b29tOiAxMixcblx0XHRib3VuZHM6IG51bGwsXG5cdFx0dmlzaWJsZUhPTENNYXBzOiB7fSxcblx0XHR2aXNpYmxlSE9MQ01hcHNJZHM6IFtdLFxuXHRcdHZpc2libGVBZElkczogW10sXG5cdFx0YWRab29tVGhyZXNob2xkOiA5LFxuXHRcdGhhc0xvYWRlZDogZmFsc2Vcblx0fSxcblxuXHRsb2FkRGF0YTogZnVuY3Rpb24gKHRoZU1hcCwgcmFzdGVycywgYWRzTWV0YWRhdGEpIHtcblx0XHRjb25zdCB0aGVCb3VuZHMgPSB0aGVNYXAuZ2V0Qm91bmRzKCk7XG5cdFx0bGV0IHZpc2libGVIT0xDTWFwcyA9IHt9LFxuXHRcdFx0dmlzaWJsZUhPTENNYXBzSWRzID0gW10sXG5cdFx0XHR2aXNpYmxlSE9MQ01hcHNCeVN0YXRlID0ge30sXG5cdFx0XHR2aXNpYmxlQWRJZHMgPSBbXTtcblxuXHRcdE9iamVjdC5rZXlzKHJhc3RlcnMpLmZvckVhY2goKGlkKSA9PiB7XG5cdFx0XHRpZiAodGhlQm91bmRzLmludGVyc2VjdHMocmFzdGVyc1tpZF0uYm91bmRzKSkge1xuXHRcdFx0XHR2aXNpYmxlSE9MQ01hcHNbaWRdID0gcmFzdGVyc1tpZF07XG5cdFx0XHRcdHZpc2libGVIT0xDTWFwc0lkcy5wdXNoKHBhcnNlSW50KGlkKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRPYmplY3Qua2V5cyhhZHNNZXRhZGF0YSkuZm9yRWFjaChhZF9pZCA9PiB7XG5cdFx0XHRpZiAodGhlQm91bmRzLmludGVyc2VjdHMoYWRzTWV0YWRhdGFbYWRfaWRdLmJvdW5kcykpIHtcblx0XHRcdFx0aWYgKHZpc2libGVBZElkcy5pbmRleE9mKGFkX2lkKSA9PSAtMSkge1xuXHRcdFx0XHRcdHZpc2libGVBZElkcy5wdXNoKHBhcnNlSW50KGFkX2lkKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIC8vIG9yZ2FuaXplIGJ5IHN0YXRlXG5cdFx0Ly8gdmlzaWJsZUhPTENNYXBzSWRzLmZvckVhY2goKGlkKSA9PiB7XG5cdFx0Ly8gXHR2aXNpYmxlSE9MQ01hcHNCeVN0YXRlW3Zpc2libGVIT0xDTWFwc1tpZF0uc3RhdGVdID0gKHZpc2libGVIT0xDTWFwc0J5U3RhdGVbdmlzaWJsZUhPTENNYXBzW2lkXS5zdGF0ZV0pID8gdmlzaWJsZUhPTENNYXBzQnlTdGF0ZVt2aXNpYmxlSE9MQ01hcHNbaWRdLnN0YXRlXSA6IFtdO1xuXHRcdC8vIFx0dmlzaWJsZUhPTENNYXBzQnlTdGF0ZVt2aXNpYmxlSE9MQ01hcHNbaWRdLnN0YXRlXS5wdXNoKHZpc2libGVIT0xDTWFwc1tpZF0pO1xuXHRcdC8vIH0pO1xuXHRcdC8vIC8vIGFscGhhYmV0aXplXG5cdFx0Ly8gT2JqZWN0LmtleXModmlzaWJsZUhPTENNYXBzQnlTdGF0ZSkuZm9yRWFjaCgodGhlX3N0YXRlKSA9PiB7XG5cdFx0Ly8gXHR2aXNpYmxlSE9MQ01hcHNCeVN0YXRlW3RoZV9zdGF0ZV0uc29ydCgoYSxiKSA9PiBhLmNpdHkgPiBiLmNpdHkpO1xuXHRcdC8vIH0pO1xuXG5cdFx0Ly8gb3JnYW5pemUgYnkgc3RhdGVcblx0XHR2aXNpYmxlQWRJZHMuZm9yRWFjaCgoaWQpID0+IHtcblx0XHRcdGlmIChhZHNNZXRhZGF0YVtpZF0pIHtcblx0XHRcdFx0dmlzaWJsZUhPTENNYXBzQnlTdGF0ZVthZHNNZXRhZGF0YVtpZF0uc3RhdGVdID0gKHZpc2libGVIT0xDTWFwc0J5U3RhdGVbYWRzTWV0YWRhdGFbaWRdLnN0YXRlXSkgPyB2aXNpYmxlSE9MQ01hcHNCeVN0YXRlW2Fkc01ldGFkYXRhW2lkXS5zdGF0ZV0gOiBbXTtcblx0XHRcdFx0dmlzaWJsZUhPTENNYXBzQnlTdGF0ZVthZHNNZXRhZGF0YVtpZF0uc3RhdGVdLnB1c2goYWRzTWV0YWRhdGFbaWRdKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvLyBhbHBoYWJldGl6ZVxuXHRcdE9iamVjdC5rZXlzKHZpc2libGVIT0xDTWFwc0J5U3RhdGUpLmZvckVhY2goKHRoZV9zdGF0ZSkgPT4ge1xuXHRcdFx0dmlzaWJsZUhPTENNYXBzQnlTdGF0ZVt0aGVfc3RhdGVdLnNvcnQoKGEsYikgPT4gYS5jaXR5ID4gYi5jaXR5KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuZGF0YS50aGVNYXAgPSB0aGVNYXA7XG5cdFx0dGhpcy5kYXRhLmNlbnRlciA9IFt0aGVNYXAuZ2V0Q2VudGVyKCkubGF0LCB0aGVNYXAuZ2V0Q2VudGVyKCkubG5nXTtcblx0XHR0aGlzLmRhdGEuem9vbSA9IHRoZU1hcC5nZXRab29tKCk7XG5cdFx0dGhpcy5kYXRhLmJvdW5kcyA9IHRoZUJvdW5kcztcblx0XHR0aGlzLmRhdGEudmlzaWJsZUhPTENNYXBzID0gdmlzaWJsZUhPTENNYXBzO1xuXHRcdHRoaXMuZGF0YS52aXNpYmxlSE9MQ01hcHNJZHMgPSB2aXNpYmxlSE9MQ01hcHNJZHM7XG5cdFx0dGhpcy5kYXRhLnZpc2libGVIT0xDTWFwc0J5U3RhdGUgPSB2aXNpYmxlSE9MQ01hcHNCeVN0YXRlO1xuXHRcdHRoaXMuZGF0YS52aXNpYmxlQWRJZHMgPSB2aXNpYmxlQWRJZHM7XG5cblx0XHR0aGlzLmRhdGEuaGFzTG9hZGVkID0gdHJ1ZTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdNYXBTdGF0ZVN0b3JlIGZpbmlzaGVkIGxvYWRpbmcnKTtcblxuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdHNldFZpZXc6IGZ1bmN0aW9uICh6b29tLCBjZW50ZXIpIHtcblx0XHR0aGlzLmRhdGEuem9vbSA9IHpvb207XG5cdFx0dGhpcy5kYXRhLmNlbnRlciA9IGNlbnRlcjtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRnZXRUaGVNYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudGhlTWFwO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jZW50ZXI7XG5cdH0sXG5cblx0Z2V0Wm9vbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS56b29tO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5ib3VuZHM7XG5cdH0sXG5cblx0Z2V0VmlzaWJsZUhPTENNYXBzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnZpc2libGVIT0xDTWFwcztcblx0fSxcblxuXHRnZXRWaXNpYmxlSE9MQ01hcHNMaXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhLnZpc2libGVIT0xDTWFwcykubWFwKG1hcElkID0+IHRoaXMuZGF0YS52aXNpYmxlSE9MQ01hcHNbbWFwSWRdKTtcblx0fSxcblxuXHRnZXRWaXNpYmxlSE9MQ01hcHNJZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudmlzaWJsZUhPTENNYXBzSWRzO1xuXHR9LFxuXG5cdGdldFZpc2libGVIT0xDTWFwc0J5U3RhdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS52aXNpYmxlSE9MQ01hcHNCeVN0YXRlO1xuXHR9LFxuXG5cdGdldFZpc2libGVBZElkczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS52aXNpYmxlQWRJZHM7XG5cdH0sXG5cblx0aXNBYm92ZVpvb21UaHJlc2hvbGQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS56b29tID49IHRoaXMuZGF0YS5hZFpvb21UaHJlc2hvbGQ7XG5cdH1cbn1cblxuLy8gTWl4aW4gRXZlbnRFbWl0dGVyIGZ1bmN0aW9uYWxpdHlcbk9iamVjdC5hc3NpZ24oTWFwU3RhdGVTdG9yZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIGhhbmRsZSBhbGwgdXBkYXRlc1xuTWFwU3RhdGVTdG9yZS5kaXNwYXRjaFRva2VuID0gQXBwRGlzcGF0Y2hlci5yZWdpc3RlcigoYWN0aW9uKSA9PiB7XG5cblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5sb2FkSW5pdGlhbERhdGE6XG5cdFx0XHQvLyB5b3UgaGF2ZSB0byB3YWl0IGZvciBSYXN0ZXJTdG9yZSBhbmQsIGlmIGEgY2l0eSBpcyByZXF1ZXN0ZWQgaW4gdGhlIGhhc2gsIENpdHlTdG9yZSB0byBmaW5pc2ggdGhlaXIgaW5pdGlhbCBsb2FkXG5cdFx0XHRsZXQgd2FpdGluZ0luaXRpYWxMb2FkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0XHRpZiAoUmFzdGVyU3RvcmUuaGFzTG9hZGVkKCkgJiYgKCFhY3Rpb24uc3RhdGUuc2VsZWN0ZWRDaXR5IHx8IENpdHlTdG9yZS5oYXNMb2FkZWQoKSkpIHtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKHdhaXRpbmdJbml0aWFsTG9hZCk7XG5cblx0XHRcdFx0XHRsZXQgem9vbSxcblx0XHRcdFx0XHRcdGNlbnRlcjtcblxuXHRcdFx0XHRcdGlmIChhY3Rpb24uaGFzaFN0YXRlLmxvYykge1xuXHRcdFx0XHRcdFx0em9vbSA9IGFjdGlvbi5oYXNoU3RhdGUubG9jLnpvb207XG5cdFx0XHRcdFx0XHRjZW50ZXIgPSBhY3Rpb24uaGFzaFN0YXRlLmxvYy5jZW50ZXI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChDaXR5U3RvcmUuZ2V0SWQoKSkge1xuXHRcdFx0XHRcdFx0em9vbSA9IDEyO1xuXHRcdFx0XHRcdFx0Y2VudGVyID0gKENpdHlTdG9yZS5nZXRQb2x5Z29uc0NlbnRlcigpKSA/IENpdHlTdG9yZS5nZXRQb2x5Z29uc0NlbnRlcigpIDogUmFzdGVyU3RvcmUuZ2V0Q2VudGVyKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHpvb20gPSBhY3Rpb24uc3RhdGUubWFwLnpvb207XG5cdFx0XHRcdFx0XHRjZW50ZXIgPSBhY3Rpb24uc3RhdGUubWFwLmNlbnRlcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRNYXBTdGF0ZVN0b3JlLnNldFZpZXcoem9vbSwgY2VudGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5tYXBJbml0aWFsaXplZDpcblx0XHRcdE1hcFN0YXRlU3RvcmUubG9hZERhdGEoYWN0aW9uLnRoZU1hcCwgYWN0aW9uLnJhc3RlcnMsIGFjdGlvbi5hZHNNZXRhZGF0YSk7XG5cblx0XHRcdC8vIGlmIGEgY2l0eSBoYXMgYmVlbiBzZWxlY3RlZCAodGhvdWdoIHRoZSBoYXNoKSwgc2V0IHRoZSBuZXcgYm91bmRzXG5cdFx0XHRpZiAoQ2l0eVN0b3JlLmdldElkKCkpIHtcblx0XHRcdFx0Y29uc3QgYm91bmRzID0gKENpdHlTdG9yZS5nZXRQb2x5Z29uc0JvdW5kcygpKSA/IENpdHlTdG9yZS5nZXRQb2x5Z29uc0JvdW5kcygpIDogUmFzdGVyU3RvcmUuZ2V0TWFwQm91bmRzKCksXG5cdFx0XHRcdFx0bmV3Wm9vbSA9IGFjdGlvbi50aGVNYXAuZ2V0Qm91bmRzWm9vbShib3VuZHMpLFxuXHRcdFx0XHRcdG5ld0NlbnRlciA9IChDaXR5U3RvcmUuZ2V0UG9seWdvbnNDZW50ZXIoKSkgPyBDaXR5U3RvcmUuZ2V0UG9seWdvbnNDZW50ZXIoKSA6IFJhc3RlclN0b3JlLmdldENlbnRlcigpO1xuXHRcdFx0XHQvL01hcFN0YXRlU3RvcmUuc2V0VmlldyhuZXdab29tLCBuZXdDZW50ZXIpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLm1hcE1vdmVkOlxuXHRcdFx0TWFwU3RhdGVTdG9yZS5sb2FkRGF0YShhY3Rpb24udGhlTWFwLCBhY3Rpb24ucmFzdGVycywgYWN0aW9uLmFkc01ldGFkYXRhKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5jaXR5U2VsZWN0ZWQ6XG5cdFx0XHQvLyB5b3UgaGF2ZSB0byB3YWl0IGZvciBDaXR5U3RvcmUgYW5kIFJhc3RlclN0b3JlIHRvIGZpbmlzaCB0aGVpciBpbml0aWFsIGxvYWRcblx0XHRcdEFwcERpc3BhdGNoZXIud2FpdEZvcihbUmFzdGVyU3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuXG5cdFx0XHRjb25zdCB3YWl0aW5nSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRcdGlmIChhY3Rpb24udmFsdWUgPT0gQ2l0eVN0b3JlLmdldElkKCkpIHtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKHdhaXRpbmdJZCk7XG5cblx0XHRcdFx0XHRpZiAoYWN0aW9uLnNlbGVjdGVkQnlVc2VyICYmIE1hcFN0YXRlU3RvcmUuZ2V0VGhlTWFwKCkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGJvdW5kcyA9IChDaXR5U3RvcmUuZ2V0UG9seWdvbnNCb3VuZHMoKSkgPyBDaXR5U3RvcmUuZ2V0UG9seWdvbnNCb3VuZHMoKSA6IFJhc3RlclN0b3JlLmdldE1hcEJvdW5kcygpLFxuXHRcdFx0XHRcdFx0XHRuZXdab29tID0gTWFwU3RhdGVTdG9yZS5nZXRUaGVNYXAoKS5nZXRCb3VuZHNab29tKGJvdW5kcyksXG5cdFx0XHRcdFx0XHRcdG5ld0NlbnRlciA9IChDaXR5U3RvcmUuZ2V0UG9seWdvbnNDZW50ZXIoKSkgPyBDaXR5U3RvcmUuZ2V0UG9seWdvbnNDZW50ZXIoKSA6IFJhc3RlclN0b3JlLmdldENlbnRlcigpO1xuXHRcdFx0XHRcdFx0TWFwU3RhdGVTdG9yZS5zZXRWaWV3KG5ld1pvb20sIG5ld0NlbnRlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCAxMDApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLkFESW1hZ2VPcGVuZWQ6XG5cdFx0XHRpZiAoTWFwU3RhdGVTdG9yZS5nZXRUaGVNYXAoKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBib3VuZHMgPSBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0TmVpZ2hib3Job29kQm91bmRpbmdCb3goYWN0aW9uLmFkSWQsIGFjdGlvbi5ob2xjSWQpLFxuXHRcdFx0XHRcdG5ld1pvb20gPSAtMSArIE1hcFN0YXRlU3RvcmUuZ2V0VGhlTWFwKCkuZ2V0Qm91bmRzWm9vbShib3VuZHMpLFxuXHRcdFx0XHRcdG5ld0NlbnRlciA9IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXROZWlnaGJvcmhvb2RDZW50ZXIoYWN0aW9uLmFkSWQsIGFjdGlvbi5ob2xjSWQpO1xuXHRcdFx0XHRNYXBTdGF0ZVN0b3JlLnNldFZpZXcobmV3Wm9vbSwgbmV3Q2VudGVyKTtcblx0XHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBNYXBTdGF0ZVN0b3JlOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgQXBwRGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5pbXBvcnQgQ2FydG9EQkxvYWRlciBmcm9tICcuLi91dGlscy9DYXJ0b0RCTG9hZGVyJztcblxuaW1wb3J0IHN0YXRlQWJicnMgZnJvbSAnLi4vLi4vZGF0YS9zdGF0ZV9hYmJyLmpzb24nO1xuXG5jb25zdCBSYXN0ZXJTdG9yZSA9IHtcblxuXHRkYXRhOiB7XG5cdFx0LyoqXG5cdFx0ICogTWV0YWRhdGEgYWJvdXQgdGhlIG1hcHNcblx0XHQgKiBieSB5ZWFyICh0aGlyZCBvcmRlciksIGNpdHkgKHNlY29uZCBvcmRlciksIGFuZCBzdGF0ZSwgZmlyc3Qgb3JkZXJcblx0XHQgKiB7XG5cdFx0ICogICBzdGF0ZVg6IHtcblx0XHQgKiAgICAgY2l0eVg6IHtcblx0XHQgKiAgICAgICB5ZWFyeDoge1xuXHRcdCAqICAgICAgICAgdXJsOiAnc3RyJyxcblx0XHQgKiAgICAgICAgIGJvdW5kczogJ2xhdGxuZ2JvdW5kcycsXG5cdFx0ICogICAgICAgICBtaW5ab29tOiBpbnQsXG5cdFx0ICogICAgICAgICBtYXh0Wm9vbTogaW50XG5cdFx0ICogICAgICAgfSxcblx0XHQgKiAgICAgICB5ZWFyWTogeyAuLi4gfVxuXHRcdCAqICAgICB9LFxuXHRcdCAqICAgICBjaXR5WTogeyAuLi4gfSxcblx0XHQgKiAgICAgbmFtZTogJ3N0cicsXG5cdFx0ICogICAgIGRlc2NyaXB0aW9uOiAnc3RyJyxcblx0XHQgKiAgICAgdW5pdHM6ICdzdHInXG5cdFx0ICogICB9LFxuXHRcdCAqICAgc3RhdGVZOiB7IC4uLiB9LFxuXHRcdCAqICAgLi4uXG5cdFx0ICogfVxuXHRcdCAqL1xuXHRcdCBtYXBzIDoge30sXG5cdFx0IGNpdGllc1dpdGhQb2x5Z29uczoge30sIFxuXHRcdCBjaXR5SWRzV2l0aEFEczogW10sXG5cblx0XHQgc2VsZWN0ZWRDaXR5OiBudWxsLFxuXHRcdCBzZWxlY3RlZFN0YXRlOiBudWxsLFxuXHRcdCBsb2FkZWQ6IGZhbHNlXG5cblx0fSxcblxuXHQvLyBUT0RPOiBNYWtlIGEgZ2VuZXJpYyBEYXRhTG9hZGVyIGNsYXNzIHRvIGRlZmluZSBhbiBpbnRlcmZhY2UsXG5cdC8vIGFuZCBsZXQgQ2FydG9EQkxvYWRlciBleHRlbmQgYW5kIGltcGxlbWVudCB0aGF0P1xuXHQvLyBCYXNpYyBpZGVhIGlzIHRoYXQgYW55dGhpbmcgd2l0aCBhIHF1ZXJ5IG1ldGhvZCB0aGF0IHJldHVybnMgYSBQcm9taXNlXG5cdC8vIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiByZXNwb25zZSBkYXRhIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuXHQvLyBjYW4gYmUgdXNlZCBoZXJlLlxuXHRkYXRhTG9hZGVyOiBDYXJ0b0RCTG9hZGVyLFxuXG5cblx0bG9hZEluaXRpYWxEYXRhOiBmdW5jdGlvbiAoc3RhdGUpIHtcblxuXHRcdHRoaXMuZGF0YUxvYWRlci5xdWVyeShbXG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXJ5OiAnU0VMRUNUIHBvcHVsYXRpb25fMTk0MCwgcG9wdWxhdGlvbl8xOTMwLCBhbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5MzAsIGFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MCwgYXNpYW5fcGFjaWZpY19pbHNsYW5kZXJfMTkzMCBhcyBhc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5MzAsIGFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5NDAgYXMgYXNpYW5fcGFjaWZpY19pc2xhbmRlcl8xOTQwLCBibGFja19wb3BfMTkzMCwgYmxhY2tfcG9wXzE5NDAsIHdoaXRlX3BvcF8xOTMwLCB3aGl0ZV9wb3BfMTk0MCwgYWRfaWQsIGhvbGNfbWFwcy4qLCBzdF94bWluKGhvbGNfbWFwcy50aGVfZ2VvbSkgYXMgbWluTG5nLCBzdF94bWF4KGhvbGNfbWFwcy50aGVfZ2VvbSkgYXMgbWF4TG5nLCBzdF95bWluKGhvbGNfbWFwcy50aGVfZ2VvbSkgYXMgbWluTGF0LCBzdF95bWF4KGhvbGNfbWFwcy50aGVfZ2VvbSkgYXMgbWF4TGF0LCBzdF94KHN0X2NlbnRyb2lkKGhvbGNfbWFwcy50aGVfZ2VvbSkpIGFzIGNlbnRlckxuZywgc3RfeShzdF9jZW50cm9pZChob2xjX21hcHMudGhlX2dlb20pKSBhcyBjZW50ZXJMYXQgRlJPTSBob2xjX21hcHMgam9pbiBob2xjX21hcHNfYWRzX2pvaW4gaG1haiBvbiBobWFqLm1hcF9pZCA9IGhvbGNfbWFwcy5tYXBfaWQgam9pbiBob2xjX2FkcyBvbiBob2xjX2Fkcy5jaXR5X2lkID0gaG1hai5hZF9pZCBvcmRlciBieSBwYXJlbnRfaWQgZGVzYycsXG5cdFx0XHRcdGZvcm1hdDogJ0pTT04nXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRxdWVyeTogJ1NFTEVDVCBkaXN0aW5jdChob2xjX2Fkcy5jaXR5X2lkKSwgc3RhdGUsIGNpdHkgRlJPTSBob2xjX2FkX2RhdGEgam9pbiBkaWdpdGFsc2Nob2xhcnNoaXBsYWIuaG9sY19wb2x5Z29ucyBvbiBwb2x5Z29uX2lkID0gaG9sY19wb2x5Z29ucy5uZWlnaGJvcmhvb2RfaWQgam9pbiBob2xjX2FkcyBvbiBob2xjX3BvbHlnb25zLmFkX2lkID0gaG9sY19hZHMuY2l0eV9pZCBvcmRlciBieSBzdGF0ZSwgY2l0eScsXG5cdFx0XHRcdGZvcm1hdDogJ0pTT04nXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRxdWVyeTogXCJTRUxFQ1QgYWRfaWQsIHN1bShzdF9hcmVhKHRoZV9nZW9tX3dlYm1lcmNhdG9yKSkgLyAxNjA5LjM0XjIgYXMgdG90YWxfYXJlYSwgc3VtKENBU0UgV0hFTiBob2xjX2dyYWRlID0gJ0EnIFRIRU4gc3RfYXJlYSh0aGVfZ2VvbV93ZWJtZXJjYXRvcikgRUxTRSAwIEVORCkgLyAxNjA5LjM0XjIgYXMgYXJlYV9hLCBzdW0oQ0FTRSBXSEVOIGhvbGNfZ3JhZGUgPSAnQicgVEhFTiBzdF9hcmVhKHRoZV9nZW9tX3dlYm1lcmNhdG9yKSBFTFNFIDAgRU5EKSAvIDE2MDkuMzReMiBhcyBhcmVhX2IsIHN1bShDQVNFIFdIRU4gaG9sY19ncmFkZSA9ICdDJyBUSEVOIHN0X2FyZWEodGhlX2dlb21fd2VibWVyY2F0b3IpIEVMU0UgMCBFTkQpIC8gMTYwOS4zNF4yIGFzIGFyZWFfYywgc3VtKENBU0UgV0hFTiBob2xjX2dyYWRlID0gJ0QnIFRIRU4gc3RfYXJlYSh0aGVfZ2VvbV93ZWJtZXJjYXRvcikgRUxTRSAwIEVORCkgLyAxNjA5LjM0XjIgYXMgYXJlYV9kIEZST00gZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMgZ3JvdXAgYnkgYWRfaWQgb3JkZXIgYnkgYWRfaWQgZGVzY1wiLFxuXHRcdFx0XHRmb3JtYXQ6ICdKU09OJ1xuXHRcdFx0fVxuXHRcdF0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHR0aGlzLmRhdGEubWFwcyA9IHRoaXMucGFyc2VNYXBEYXRhKHJlc3BvbnNlWzBdLCByZXNwb25zZVsyXSwgcmVzcG9uc2VbMV0pO1xuXHRcdFx0dGhpcy5kYXRhLmNpdHlJZHNXaXRoQURzID0gcmVzcG9uc2VbMV0ubWFwKChyb3cpID0+IHJvdy5pZCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuZGF0YS5zZWxlY3RlZENpdHkgPSBzdGF0ZS5zZWxlY3RlZENpdHk7XG5cdFx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRTdGF0ZSA9IHJlc3BvbnNlWzJdWzBdLnN0YXRlO1xuXG5cdFx0XHR0aGlzLmRhdGEubG9hZGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1Jhc3RlclN0b3JlIGZpbmlzaGVkIGxvYWRpbmcnKTtcblxuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdFx0fSxcblx0XHQoZXJyb3IpID0+IHtcblx0XHRcdC8vIFRPRE86IGhhbmRsZSB0aGlzLlxuXHRcdFx0Y29uc29sZS5sb2coJ1Jhc3RlclN0b3JlIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgc2VsZWN0ZWQgY2l0eSBmb3IgdGhlIHdob2xlIGFwcGxpY2F0aW9uIHRvIGRpc3BsYXkuXG5cdCAqL1xuXHRzZXRTZWxlY3RlZENpdHk6IGZ1bmN0aW9uIChjaXR5SWQpIHtcblx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRDaXR5ID0gY2l0eUlkOyAgXG5cdH0sXG5cblx0c2V0U2VsZWN0ZWRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0aWYgKHR5cGVvZihzdGF0ZSkgIT09ICd1bmRlZmluZWQnICYmIHN0YXRlICE9PSB0aGlzLmRhdGEuc2VsZWN0ZWRTdGF0ZSkge1xuXHRcdFx0dGhpcy5kYXRhLnNlbGVjdGVkQ2l0eSA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRBbGxSYXN0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGEubWFwczsgfSxcblxuXHRnZXRTZWxlY3RlZENpdHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZENpdHk7IH0sXG5cblx0Z2V0QWxsQ2l0aWVzV2l0aFBvbHlnb25zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGF0YS5jaXRpZXNXaXRoUG9seWdvbnM7IH0sXG5cblx0Ly8gcmV0dXJucyBldmVyeXRoaW5nIG9yIGEgc3BlY2lmaWVkIGF0dHJpYnV0ZVxuXHRnZXRTZWxlY3RlZENpdHlNZXRhZGF0YTogZnVuY3Rpb24oa2V5PW51bGwpIHsgXG5cdFx0aWYgKCF0aGlzLmdldFNlbGVjdGVkQ2l0eSgpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIChrZXkpID8gdGhpcy5kYXRhLm1hcHNbdGhpcy5nZXRTZWxlY3RlZENpdHkoKV1ba2V5XSA6IHRoaXMuZGF0YS5tYXBzW3RoaXMuZ2V0U2VsZWN0ZWRDaXR5KCldOyBcblx0fSxcblxuXHRnZXRDaXR5TWV0YWRhdGE6IGZ1bmN0aW9uKGNpdHlfaWQsIGtleT1udWxsKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEubWFwc1tjaXR5X2lkXSkgPyAoa2V5ICYmIHRoaXMuZGF0YS5tYXBzW2NpdHlfaWRdW2tleV0pID8gdGhpcy5kYXRhLm1hcHNbY2l0eV9pZF1ba2V5XSA6IHRoaXMuZGF0YS5tYXBzW2NpdHlfaWRdIDogbnVsbDtcblx0fSxcblxuXHRnZXRTZWxlY3RlZFN0YXRlICgpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnNlbGVjdGVkU3RhdGU7XG5cdH0sXG5cblx0Z2V0TWFwQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsgXG5cdFx0XHRbIHRoaXMuZ2V0U2VsZWN0ZWRDaXR5TWV0YWRhdGEoJ21pbkxhdCcpLCB0aGlzLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCdtaW5MbmcnKSBdLCBcblx0XHRcdFsgdGhpcy5nZXRTZWxlY3RlZENpdHlNZXRhZGF0YSgnbWF4TGF0JyksIHRoaXMuZ2V0U2VsZWN0ZWRDaXR5TWV0YWRhdGEoJ21heExuZycpIF0gXG5cdFx0XTtcblx0fSxcblxuXHRnZXRNYXBCb3VuZHNCeUFkSWQ6IGZ1bmN0aW9uKGFkSWQpIHtcblx0XHRyZXR1cm4gWyBcblx0XHRcdFsgdGhpcy5kYXRhLm1hcHNbYWRJZF0ubWluTGF0LCB0aGlzLmRhdGEubWFwc1thZElkXS5taW5MbmcgXSwgXG5cdFx0XHRbIHRoaXMuZGF0YS5tYXBzW2FkSWRdLm1heExhdCwgdGhpcy5kYXRhLm1hcHNbYWRJZF0ubWF4TG5nIF0gXG5cdFx0XTtcblx0fSxcblxuXHRnZXRDaXR5TmFtZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhLm1hcHMpLm1hcCgoaWQpID0+IHRoaXMuZGF0YS5tYXBzW2lkXS5jaXR5ICsgJywgJyArc3RhdGVBYmJyc1t0aGlzLmRhdGEubWFwc1tpZF0uc3RhdGVdKTtcblx0fSxcblxuXHRnZXRDaXR5SWRzV2l0aE5hbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0bGV0IGlkc0FuZE5hbWVzID0ge307XG5cblx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEubWFwcykuZm9yRWFjaCgoaWQpID0+IHtcblx0XHRcdGlkc0FuZE5hbWVzW2lkXSA9IHRoaXMuZGF0YS5tYXBzW2lkXS5jaXR5ICsgJywgJyArc3RhdGVBYmJyc1t0aGlzLmRhdGEubWFwc1tpZF0uc3RhdGVdXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gaWRzQW5kTmFtZXM7XG5cdH0sXG5cblx0Z2V0Q2l0eUlkc0FuZE5hbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YS5tYXBzKS5tYXAoKGlkKSA9PiB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpZDogcGFyc2VJbnQoaWQpLFxuXHRcdFx0XHRjaXR5TmFtZTogdGhpcy5kYXRhLm1hcHNbaWRdLmNpdHkgKyAnLCAnICsgc3RhdGVBYmJyc1t0aGlzLmRhdGEubWFwc1tpZF0uc3RhdGVdXG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gWyB0aGlzLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCdjZW50ZXJMYXQnKSwgdGhpcy5nZXRTZWxlY3RlZENpdHlNZXRhZGF0YSgnY2VudGVyTG5nJyldO1xuXHR9LFxuXG5cdGdldENlbnRlck9sZDogZnVuY3Rpb24oKSB7XG5cdFx0bGV0IGJvdW5kcyA9IHRoaXMuZ2V0TWFwQm91bmRzKCk7XG5cdFx0cmV0dXJuIFsoYm91bmRzWzBdWzBdICsgYm91bmRzWzFdWzBdKSAvIDIsIChib3VuZHNbMF1bMV0gKyBib3VuZHNbMV1bMV0pIC8gMl07XG5cdH0sXG5cblx0Z2V0TWFwQm91bmRzRm9yU3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHRcdGxldCBtaW5MYXQgPSA5MCwgbWluTG5nID0gMCwgbWF4TGF0ID0gMCwgbWF4TG5nID0gLTE4MDtcblx0XHRsZXQgY2l0aWVzRm9yU3RhdGUgPSB0aGlzLmdldENpdGllc0ZvclN0YXRlKHN0YXRlKTtcblxuXHRcdGNpdGllc0ZvclN0YXRlLmZvckVhY2goKGNpdHlEYXRhKSA9PiB7XG5cdFx0XHRtaW5MYXQgPSAoY2l0eURhdGEubWluTGF0ICYmIGNpdHlEYXRhLm1pbkxhdCA8IG1pbkxhdCkgPyBjaXR5RGF0YS5taW5MYXQgOiBtaW5MYXQ7XG5cdFx0XHRtYXhMYXQgPSAoY2l0eURhdGEubWF4TGF0ICYmIGNpdHlEYXRhLm1heExhdCA+IG1heExhdCkgPyBjaXR5RGF0YS5tYXhMYXQgOiBtYXhMYXQ7XG5cdFx0XHRtaW5MbmcgPSAoY2l0eURhdGEubWluTG5nICYmIGNpdHlEYXRhLm1pbkxuZyA8IG1pbkxuZykgPyBjaXR5RGF0YS5taW5MbmcgOiBtaW5Mbmc7XG5cdFx0XHRtYXhMbmcgPSAoY2l0eURhdGEubWF4TG5nICYmIGNpdHlEYXRhLm1heExuZyA+IG1heExuZykgPyBjaXR5RGF0YS5tYXhMbmcgOiBtYXhMbmc7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW1sgbWluTGF0LCBtaW5MbmcgXSxbIG1heExhdCwgbWF4TG5nIF1dO1xuXHR9LFxuXG5cdGdldENlbnRlckZvclN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdGxldCBib3VuZHMgPSB0aGlzLmdldE1hcEJvdW5kc0ZvclN0YXRlKHN0YXRlKTtcblx0XHRyZXR1cm4gWyhib3VuZHNbMF1bMF0gKyBib3VuZHNbMV1bMF0pIC8gMiwgKGJvdW5kc1swXVsxXSArIGJvdW5kc1sxXVsxXSkgLyAyXTtcblx0fSxcblxuXHRnZXRDaXRpZXNGb3JTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2l0aWVzTGlzdCgpLmZpbHRlcihmdW5jdGlvbihjaXR5RGF0YSkgeyByZXR1cm4gKGNpdHlEYXRhLnN0YXRlID09IHN0YXRlKTsgfSk7XG5cdH0sXG5cblx0Z2V0TWFwVXJsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2VsZWN0ZWRDaXR5TWV0YWRhdGEoJ21hcHVybCcpO1xuXHR9LFxuXG5cdGdldE1hcFRodW1ibmFpbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCdtYXBUaHVtYm5haWwnKTtcblx0fSxcblxuXHQvLyByZXR1cm4gYSBmbGF0IGxpc3Qgb2YgdGhlIEhPTEMgbWFwcyBmb3IgcmVuZGVyaW5nXG5cdGdldENpdGllc0xpc3Q6IGZ1bmN0aW9uKCkgeyBcblx0XHRsZXQgY2l0aWVzID0gdGhpcy5jb21iaW5lQ2l0aWVzTGlzdHMoKTtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMoY2l0aWVzKS5tYXAoY2l0eUlkID0+IGNpdGllc1tjaXR5SWRdKTsgXG5cdH0sXG5cblx0Z2V0U3RhdGVzT2JqZWN0OiBmdW5jdGlvbigpIHtcblx0XHRsZXQgc3RhdGVzT2JqZWN0ID0ge307XG5cdFx0T2JqZWN0LmtleXModGhpcy5kYXRhLm1hcHMpLm1hcChjaXR5SWQgPT4ge1xuXHRcdFx0c3RhdGVzT2JqZWN0W3RoaXMuZGF0YS5tYXBzW2NpdHlJZF0uc3RhdGVdID0ge1xuXHRcdFx0XHRpZDogdGhpcy5kYXRhLm1hcHNbY2l0eUlkXS5zdGF0ZSxcblx0XHRcdFx0bmFtZTogc3RhdGVBYmJyc1t0aGlzLmRhdGEubWFwc1tjaXR5SWRdLnN0YXRlXSxcblx0XHRcdFx0Y2l0aWVzSWRzOiB0aGlzLmdldENpdGllc0ZvclN0YXRlKHRoaXMuZGF0YS5tYXBzW2NpdHlJZF0uc3RhdGUpLm1hcCgoY2l0eURhdGEpID0+IGNpdHlEYXRhLmlkKVxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRyZXR1cm4gc3RhdGVzT2JqZWN0O1xuXHR9LFxuXG5cdGdldFN0YXRlc0xpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdGxldCBzdGF0ZXMgPSB0aGlzLmdldFN0YXRlc09iamVjdCgpO1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZXMpLm1hcChzdGF0ZUFiYnIgPT4gc3RhdGVzW3N0YXRlQWJicl0pO1xuXHR9LFxuXG5cdGdldFN0YXRlc1dpdGhGaXJzdENpdGllczogZnVuY3Rpb24oKSB7XG5cdFx0bGV0IHN0YXRlcyA9IFtdLFxuXHRcdFx0ICBjaXRpZXMgPSB0aGlzLmNvbWJpbmVDaXRpZXNMaXN0cygpLFxuXHRcdFx0ICBzdGF0ZUluTGlzdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0XHRcdCAgbGV0IGluTGlzdCA9IGZhbHNlO1xuXHRcdFx0XHQgIHN0YXRlcy5tYXAoKGNpdHlEYXRhKSA9PiB7XG5cdFx0XHRcdFx0ICBpZiAoY2l0eURhdGEuc3RhdGUgPT0gc3RhdGUpIHtcblx0XHRcdFx0XHRcdCAgaW5MaXN0ID0gdHJ1ZTtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0ICB9KTtcblx0XHRcdFx0ICByZXR1cm4gaW5MaXN0O1xuXHRcdFx0ICB9O1xuXG5cdFx0T2JqZWN0LmtleXMoY2l0aWVzKS5tYXAoKGNpdHlJZCkgPT4ge1xuXHRcdFx0aWYgKCFzdGF0ZUluTGlzdCh0aGlzLmRhdGEubWFwc1tjaXR5SWRdLnN0YXRlKSkge1xuXHRcdFx0XHRzdGF0ZXMucHVzaChPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRhdGEubWFwc1tjaXR5SWRdKSk7XG5cdFx0XHR9XG5cdFx0fSk7IFxuXG5cdFx0c3RhdGVzLm1hcCgoY2l0eURhdGEpID0+IHsgY2l0eURhdGEubmFtZSA9IHN0YXRlQWJicnNbY2l0eURhdGEuc3RhdGVdOyB9KTtcblxuXHRcdHJldHVybiBzdGF0ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaXR5T2ZTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRsZXQgc3RhdGVzV2l0aEZpcnN0Q2l0aWVzID0gdGhpcy5nZXRTdGF0ZXNXaXRoRmlyc3RDaXRpZXMoKTtcblx0XHRmb3IgKGxldCBpIGluIHN0YXRlc1dpdGhGaXJzdENpdGllcykge1xuXHRcdFx0aWYgKHN0YXRlc1dpdGhGaXJzdENpdGllc1tpXS5zdGF0ZSA9PSBzdGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGVzV2l0aEZpcnN0Q2l0aWVzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRoYXNMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEubG9hZGVkO1xuXHR9LFxuXG5cdHNlbGVjdGVkSGFzUG9seWdvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kYXRhLm1hcHNbdGhpcy5kYXRhLnNlbGVjdGVkQ2l0eV0pID8gdGhpcy5kYXRhLm1hcHNbdGhpcy5kYXRhLnNlbGVjdGVkQ2l0eV0uaGFzUG9seWdvbnMgOiBmYWxzZTtcblx0fSxcblxuXHRjYWxjdWxhdGVTaW1wbGVSaW5nc1JhZGlpOiBmdW5jdGlvbiAoYXJlYURhdGEpIHtcblx0XHRsZXQgZnVydGhlc3RSYWRpdXMgPSAyNTAwMCxcblx0XHRcdGZ1bGxBcmVhID0gTWF0aC5QSSAqIGZ1cnRoZXN0UmFkaXVzICogZnVydGhlc3RSYWRpdXMsXG5cdFx0XHRvdXRlclJhZGl1cyxcblx0XHRcdGlubmVyUmFkaXVzID0gMCxcblx0XHRcdGRvbnV0QXJlYSxcblx0XHRcdGdyYWRlQXJlYSxcblx0XHRcdHJhZGlpID0ge307XG5cblx0XHRbJ2QnLCdjJywnYicsJ2EnXS5mb3JFYWNoKChncmFkZSkgPT4ge1xuXHRcdFx0bGV0IGRvbnV0aG9sZUFyZWEgPSBNYXRoLlBJICogaW5uZXJSYWRpdXMgKiBpbm5lclJhZGl1cyxcblx0XHRcdFx0Z3JhZGVBcmVhID0gZnVsbEFyZWEgKiAoYXJlYURhdGFbZ3JhZGVdIC8gYXJlYURhdGEudG90YWwpLFxuXHRcdFx0XHRvdXRlclJhZGl1cyA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KChncmFkZUFyZWEgKyBkb251dGhvbGVBcmVhKSAvIE1hdGguUEkpKTtcblx0XHRcdHJhZGlpW2dyYWRlXSA9IHtcblx0XHRcdFx0J2lubmVyJzogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdCdvdXRlcic6IG91dGVyUmFkaXVzXG5cdFx0XHR9O1xuXHRcdFx0aW5uZXJSYWRpdXMgPSBvdXRlclJhZGl1cztcblx0XHR9KTtcblxuXHRcdHJldHVybiByYWRpaTtcblx0fSxcblxuXHRnZXRTZWxlY3RlZE1hcHM6IGZ1bmN0aW9uIChyZXF1ZXN0ZWRNYXBJZHMsIHNlbGVjdGVkQWQgPSBudWxsKSB7XG5cdFx0bGV0IHNlbGVjdGVkTWFwcyA9IFtdO1xuXHRcdGNvbnN0IGFsbE1hcHMgPSB0aGlzLmdldE1hcHNMaXN0KCk7XG5cblx0XHRhbGxNYXBzLmZvckVhY2gobWFwID0+IHtcblx0XHRcdGlmIChyZXF1ZXN0ZWRNYXBJZHMuaW5kZXhPZihtYXAuYWRfaWQpICE9PSAtMSAmJiBtYXAuYWRfaWQgIT09IHNlbGVjdGVkQWQpIHtcblx0XHRcdFx0c2VsZWN0ZWRNYXBzLnB1c2gobWFwKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFsbE1hcHMuZm9yRWFjaChtYXAgPT4ge1xuXHRcdFx0aWYgKHJlcXVlc3RlZE1hcElkcy5pbmRleE9mKG1hcC5hZF9pZCkgIT09IC0xICYmIG1hcC5hZF9pZCA9PSBzZWxlY3RlZEFkKSB7XG5cdFx0XHRcdHNlbGVjdGVkTWFwcy5wdXNoKG1hcCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHRcdHJldHVybiBzZWxlY3RlZE1hcHM7XG5cdH0sXG5cdFxuXHQvLyByZXR1cm4gYSBmbGF0IGxpc3Qgb2YgdGhlIEhPTEMgbWFwcyBmb3IgcmVuZGVyaW5nXG5cdGdldE1hcHNMaXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YS5tYXBzKS5tYXAoKGNpdHlJZCkgPT4gdGhpcy5kYXRhLm1hcHNbY2l0eUlkXSk7IH0sXG5cblx0cGFyc2VNYXBEYXRhOiBmdW5jdGlvbiAoY2l0aWVzRGF0YSwgY2l0aWVzV2l0aFBvbHlnb25zRGF0YSwgY2l0aWVzV2l0aEFEcykge1xuXHRcdGxldCBtYXBzID0ge307XG5cblx0XHRjaXRpZXNEYXRhLmZvckVhY2gobWFwRGF0YSA9PiB7XG5cdFx0XHRtYXBzW21hcERhdGEubWFwX2lkXSA9IHtcblx0XHRcdFx0Y2l0eUlkIDogbWFwRGF0YS5hZF9pZCxcblx0XHRcdFx0aWQ6IG1hcERhdGEubWFwX2lkLFxuXHRcdFx0XHRhZF9pZDogcGFyc2VJbnQobWFwRGF0YS5hZF9pZCksXG5cdFx0XHRcdHBhcmVudF9pZDogbWFwRGF0YS5wYXJlbnRfaWQsXG5cdFx0XHRcdGNpdHk6IG1hcERhdGEubmFtZSxcblx0XHRcdFx0c3RhdGU6IG1hcERhdGEuc3RhdGUsXG5cdFx0XHRcdHNlYXJjaE5hbWU6IChtYXBEYXRhLnBhcmVudF9pZCkgPyAnJyA6IG1hcERhdGEubmFtZSArICcsICcgKyBzdGF0ZUFiYnJzW21hcERhdGEuc3RhdGVdLFxuXHRcdFx0XHRuYW1lOiBtYXBEYXRhLm5hbWUsIC8vICsgXCIsIFwiICsgbWFwRGF0YS5zdGF0ZSxcblx0XHRcdFx0bWluWm9vbTogbWFwRGF0YS5taW56b29tLFxuXHRcdFx0XHRtYXhab29tOiBtYXBEYXRhLm1heHpvb20sXG5cdFx0XHRcdGJvdW5kczogWyBbbWFwRGF0YS5taW5sYXQsbWFwRGF0YS5taW5sbmddLCBbbWFwRGF0YS5tYXhsYXQsbWFwRGF0YS5tYXhsbmddIF0sXG5cdFx0XHRcdG1pbkxhdDogbWFwRGF0YS5taW5sYXQsXG5cdFx0XHRcdG1heExhdDogbWFwRGF0YS5tYXhsYXQsXG5cdFx0XHRcdG1pbkxuZzogbWFwRGF0YS5taW5sbmcsXG5cdFx0XHRcdG1heExuZzogbWFwRGF0YS5tYXhsbmcsXG5cdFx0XHRcdGNlbnRlckxhdDogbWFwRGF0YS5jZW50ZXJsYXQsXG5cdFx0XHRcdGNlbnRlckxuZzogbWFwRGF0YS5jZW50ZXJsbmcsXG5cdFx0XHRcdHBvcHVsYXRpb25fMTkzMDogbWFwRGF0YS5wb3B1bGF0aW9uXzE5MzAsXG5cdFx0XHRcdHBvcHVsYXRpb25fMTk0MDogbWFwRGF0YS5wb3B1bGF0aW9uXzE5NDAsXG5cdFx0XHRcdGFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTkzMDogbWFwRGF0YS5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5MzAsXG5cdFx0XHRcdGFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MDogbWFwRGF0YS5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5NDAsXG5cdFx0XHRcdGFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTkzMDogbWFwRGF0YS5hc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5MzAsXG5cdFx0XHRcdGFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTk0MDogbWFwRGF0YS5hc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5NDAsXG5cdFx0XHRcdGJsYWNrX3BvcF8xOTMwOiBtYXBEYXRhLmJsYWNrX3BvcF8xOTMwLFxuXHRcdFx0XHRibGFja19wb3BfMTk0MDogbWFwRGF0YS5ibGFja19wb3BfMTk0MCxcblx0XHRcdFx0d2hpdGVfcG9wXzE5MzA6IG1hcERhdGEud2hpdGVfcG9wXzE5MzAsXG5cdFx0XHRcdHdoaXRlX3BvcF8xOTQwOiBtYXBEYXRhLndoaXRlX3BvcF8xOTQwLFxuXHRcdFx0XHRoYXNQb2x5Z29uczogZmFsc2UsXG5cdFx0XHRcdGhhc0FEczogZmFsc2UsXG5cdFx0XHRcdHVybDogJ2h0dHA6Ly9ob2xjLnMzLXdlYnNpdGUtdXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vdGlsZXMvJyArIG1hcERhdGEuc3RhdGUgKyAnLycgK21hcERhdGEuXHRmaWxlX25hbWUucmVwbGFjZSgvXFxzKy9nLCAnJykgICsgJy8nICsgbWFwRGF0YS55ZWFyICsgJy97en0ve3h9L3t5fS5wbmcnLFxuXHRcdFx0XHRtYXB1cmw6ICdodHRwOi8vaG9sYy5zMy13ZWJzaXRlLXVzLWVhc3QtMS5hbWF6b25hd3MuY29tL3RpbGVzLycgKyBtYXBEYXRhLnN0YXRlICsgJy8nICttYXBEYXRhXHQuZmlsZV9uYW1lLnJlcGxhY2UoL1xccysvZywgJycpICArICcvJyArIG1hcERhdGEueWVhciArICcvaG9sYy1zY2FuLmpwZycsXG5cdFx0XHRcdG1hcFRodW1ibmFpbDogJy8vaG9sYy5zMy13ZWJzaXRlLXVzLWVhc3QtMS5hbWF6b25hd3MuY29tL3RpbGVzLycgKyBtYXBEYXRhLnN0YXRlICsgJy8nICsgXHRtYXBEYXRhLmZpbGVfbmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKSAgKyAnLycgKyBtYXBEYXRhLnllYXIgKyAnL3RodW1ibmFpbC5qcGcnXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjaXRpZXNXaXRoUG9seWdvbnNEYXRhLmZvckVhY2goYXJlYURhdGEgPT4ge1xuXHRcdFx0aWYgKG1hcHNbYXJlYURhdGEuYWRfaWRdKSB7XG5cdFx0XHRcdG1hcHNbYXJlYURhdGEuYWRfaWRdLmhhc1BvbHlnb25zID0gdHJ1ZSxcblx0XHRcdFx0bWFwc1thcmVhRGF0YS5hZF9pZF0uYXJlYSA9IHtcblx0XHRcdFx0XHQndG90YWwnIDogYXJlYURhdGEudG90YWxfYXJlYSxcblx0XHRcdFx0XHQnYSc6IGFyZWFEYXRhLmFyZWFfYSxcblx0XHRcdFx0XHQnYic6IGFyZWFEYXRhLmFyZWFfYixcblx0XHRcdFx0XHQnYyc6IGFyZWFEYXRhLmFyZWFfYyxcblx0XHRcdFx0XHQnZCc6IGFyZWFEYXRhLmFyZWFfZFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtYXBzW2FyZWFEYXRhLmFkX2lkXS5yYWRpaSA9IHRoaXMuY2FsY3VsYXRlU2ltcGxlUmluZ3NSYWRpaShtYXBzW2FyZWFEYXRhLmFkX2lkXS5hcmVhKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y2l0aWVzV2l0aEFEcy5mb3JFYWNoKGFyZWFEYXRhID0+IHtcblx0XHRcdGlmIChtYXBzW2FyZWFEYXRhLmlkXSkge1xuXHRcdFx0XHRtYXBzW2FyZWFEYXRhLmlkXS5oYXNBRHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG1hcHM7XG5cblx0fSxcblxuXHRwYXJzZUNpdGllc1dpdGhQb2x5Z29uc0RhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0bGV0IGNpdGllcyA9IHt9O1xuXG5cdFx0ZGF0YS5mb3JFYWNoKGNpdGllc0RhdGEgPT4ge1xuXHRcdFx0Y2l0aWVzW2NpdGllc0RhdGEuaWRdID0ge1xuXHRcdFx0XHRhZElkOiAgY2l0aWVzRGF0YS5pZCxcblx0XHRcdFx0aWQ6IGNpdGllc0RhdGEuaWQsXG5cdFx0XHRcdGNpdHk6IGNpdGllc0RhdGEuY2l0eSxcblx0XHRcdFx0c3RhdGU6IGNpdGllc0RhdGEuc3RhdGUsXG5cdFx0XHRcdG5hbWU6IGNpdGllc0RhdGEuY2l0eSArICAoKHRoaXMuZGF0YS5jaXR5SWRzV2l0aEFEcy5pbmRleE9mKGNpdGllc0RhdGEuaWQgKSAhPSAtMSkgPyAnICoqJyA6ICcgKicpLCAvLyBcIiwgXCIgKyBzdGF0ZUFiYnJzW2NpdGllc0RhdGEuc3RhdGVdICtcblx0XHRcdFx0bWluTGF0OiBjaXRpZXNEYXRhLm1pbmxhdCxcblx0XHRcdFx0bWF4TGF0OiBjaXRpZXNEYXRhLm1heGxhdCxcblx0XHRcdFx0bWluTG5nOiBjaXRpZXNEYXRhLm1pbmxuZyxcblx0XHRcdFx0bWF4TG5nOiBjaXRpZXNEYXRhLm1heGxuZyxcblx0XHRcdFx0Y2VudGVyTGF0OiBjaXRpZXNEYXRhLmNlbnRlcmxhdCxcblx0XHRcdFx0Y2VudGVyTG5nOiBjaXRpZXNEYXRhLmNlbnRlcmxuZyxcblx0XHRcdFx0aGFzUG9seWdvbnM6IHRydWUsXG5cdFx0XHRcdGhhc0FEczogKHRoaXMuZGF0YS5jaXR5SWRzV2l0aEFEcy5pbmRleE9mKGNpdGllc0RhdGEuaWQgKSAhPSAtMSlcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY2l0aWVzO1xuXHR9LFxuXG5cdGNvbWJpbmVDaXRpZXNMaXN0czogZnVuY3Rpb24gKCkge1xuXHRcdGxldCBjb21iaW5lZExpc3QgPSB7fTtcblx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEubWFwcykubWFwKChpZCwgaSkgPT4ge1xuXHRcdFx0Y29tYmluZWRMaXN0W2lkXSA9ICh0aGlzLmRhdGEuY2l0aWVzV2l0aFBvbHlnb25zW2lkXSkgPyB0aGlzLmRhdGEuY2l0aWVzV2l0aFBvbHlnb25zW2lkXSA6IHRoaXMuZGF0YS5tYXBzW2lkXTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjb21iaW5lZExpc3Q7XG5cdH1cblxufTtcblxuLy8gTWl4aW4gRXZlbnRFbWl0dGVyIGZ1bmN0aW9uYWxpdHlcbk9iamVjdC5hc3NpZ24oUmFzdGVyU3RvcmUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBSZWdpc3RlciBjYWxsYmFjayB0byBoYW5kbGUgYWxsIHVwZGF0ZXNcblJhc3RlclN0b3JlLmRpc3BhdGNoVG9rZW4gPSBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKChhY3Rpb24pID0+IHtcblxuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmxvYWRJbml0aWFsRGF0YTpcblx0XHRcdFJhc3RlclN0b3JlLmxvYWRJbml0aWFsRGF0YShhY3Rpb24uc3RhdGUpO1xuXHRcdFx0aWYgKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHkpIHtcblx0XHRcdFx0UmFzdGVyU3RvcmUuc2V0U2VsZWN0ZWRDaXR5KGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHkpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmNpdHlTZWxlY3RlZDpcblx0XHRcdFJhc3RlclN0b3JlLnNldFNlbGVjdGVkQ2l0eShhY3Rpb24udmFsdWUpO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhc3RlclN0b3JlOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgQXBwRGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5cbmNvbnN0IFRleHRzU3RvcmUgPSB7XG5cblx0ZGF0YToge1xuXHRcdG1vZGFsOiB7XG5cdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdHN1YmplY3Q6IG51bGxcblx0XHR9LFxuXHRcdGFib3V0OiBbXG5cdFx0XHRcIjxoMj5JbnRyb2R1Y3Rpb248L2gyPlwiLFxuXHRcdFx0XCI8cD48Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IHVwZGF0ZXMgdGhlIHN0dWR5IG9mIE5ldyBEZWFsIEFtZXJpY2EsIHRoZSBmZWRlcmFsIGdvdmVybm1lbnQsIGhvdXNpbmcsIGFuZCBpbmVxdWFsaXR5IGZvciB0aGUgdHdlbnR5LWZpcnN0IGNlbnR1cnkuIEl0IG9mZmVycyB1bnByZWNlZGVudGVkIG9ubGluZSBhY2Nlc3MgdG8gdGhlIG5hdGlvbmFsIGNvbGxlY3Rpb24gb2YgXFxcIlx0c2VjdXJpdHkgbWFwc1xcXCIgYW5kIGFyZWEgZGVzY3JpcHRpb25zIHByb2R1Y2VkIGJldHdlZW4gMTkzNSBhbmQgMTk0MCBieSBvbmUgb2YgdGhlIE5ldyBEZWFsJ3MgbW9zdCBpbXBvcnRhbnQgYWdlbmNpZXMsIHRoZSBIb21lIE93bmVycycgTG9hbiBDb3Jwb3JhdGlvbiBvciBIT0xDIChwcm9ub3VuY2VkIFxcXCJob2xrXFxcIikuIDwvcD5cIixcblx0XHRcdFwiPHA+SE9MQyByZWNydWl0ZWQgbW9ydGdhZ2UgbGVuZGVycywgZGV2ZWxvcGVycywgYW5kIHJlYWwgZXN0YXRlIGFwcHJhaXNlcnMgaW4gbmVhcmx5IDI1MCBjaXRpZXMgdG8gY3JlYXRlIG1hcHMgdGhhdCBjb2xvci1jb2RlZCBjcmVkaXQgd29ydGhpbmVzcyBhbmQgcmlzayBvbiBuZWlnaGJvcmhvb2QgYW5kIG1ldHJvcG9saXRhbiBsZXZlbHMuIFRoZXNlIG1hcHMgYW5kIHRoZWlyIGFjY29tcGFueWluZyBkb2N1bWVudGF0aW9uIGhlbHBlZCBzZXQgdGhlIHJ1bGVzIGZvciBuZWFybHkgYSBjZW50dXJ5IG9mIHJlYWwgZXN0YXRlIHByYWN0aWNlLiBUaGV5IGhhdmUgYWxzbyBzZXJ2ZWQgYXMgY3JpdGljYWwgZXZpZGVuY2UgaW4gY291bnRsZXNzIHVyYmFuIHN0dWRpZXMgaW4gdGhlIGZpZWxkcyBvZiBoaXN0b3J5LCBzb2Npb2xvZ3ksIGVjb25vbWljcywgYW5kIGxhdy4gIEluZGVlZCwgbW9yZSB0aGFuIGEgaGFsZi1jZW50dXJ5IG9mIHJlc2VhcmNoIGhhcyBzaG93biBob3VzaW5nIHRvIGJlIGZvciB0aGUgdHdlbnRpZXRoIGNlbnR1cnkgd2hhdCBzbGF2ZXJ5IHdhcyB0byB0aGUgYW50ZWJlbGx1bSBwZXJpb2QsIG5hbWVseSB0aGUgYnJvYWQgZm91bmRhdGlvbiBvZiBib3RoIEFtZXJpY2FuIHByb3NwZXJpdHkgYW5kIHJhY2lhbCBpbmVxdWFsaXR5LiAgVGhyb3VnaCBvZmZlcmluZyBhIGRpZ2l0YWwgbGlicmFyeSBvZiB0aGUgc3RhdGUncyByb2xlIGluIGhvdXNpbmcgZGV2ZWxvcG1lbnQsIE1hcHBpbmcgSW5lcXVhbGl0eSBpbGx1c3RyYXRlcyB2aXZpZGx5IHRoZSBpbnRlcnBsYXkgYmV0d2VlbiByYWNpc20sIGFkbWluaXN0cmF0aXZlIGN1bHR1cmUsIGVjb25vbWljcywgYW5kIHRoZSBidWlsdCBlbnZpcm9ubWVudC48L3A+XCIsXG5cdFx0XHRcIjxwPjxjaXRlPk1hcHBpbmcgSW5lcXVhbGl0eTwvY2l0ZT4gaW50cm9kdWNlcyB2aWV3ZXJzIHRvIHRoZSByZWNvcmRzIG9mIHRoZSBIb21lIE93bmVycyBMb2FuIENvcnBvcmF0aW9uIHdpdGggYWNjZXNzaWJpbGl0eSBhbmQgb24gYSBzY2FsZSB0aGF0IGlzIHVucHJlY2VkZW50ZWQuIFZpc2l0b3JzIGNhbiBicm93c2Ugb3ZlciB0d28taHVuZHJlZCBpbnRlcmFjdGl2ZSBtYXBzIGFuZCBnZXQgYSB2aWV3IG9mIERlcHJlc3Npb24tZXJhIEFtZXJpY2EgYXMgZGV2ZWxvcGVycywgcmVhbHRvcnMsIHRheCBhc3Nlc3NvcnMsIGFuZCBzdXJ2ZXlvcnMgc2F3IGl0JiM4MjEyO2Egc2V0IG9mIGludGVybG9ja2luZyBjb2xvci1saW5lcywgcmFjaWFsIGdyb3VwcywgYW5kIGVudmlyb25tZW50YWwgcmlza3MuICBUaGV5IGNhbiBhbHNvIHVzZSB0aGUgbWFwcyBhbmQgYXJlYSBkZXNjcmlwdGlvbnMgdG8gZHJhdyBjb25uZWN0aW9ucyBiZXR3ZWVuIHBhc3Qgc3RhdGUgYWN0aW9ucyAoYW5kIGluYWN0aW9ucykgYW5kIGNvbnRlbXBvcmFyeSBBbWVyaWNhbiBwcm9ibGVtcy48L3A+XCIsXG5cdFx0XHRcIjxoMz5BcmNoaXZpbmcgSW5lcXVhbGl0eSBmb3IgdGhlIERpZ2l0YWwgQWdlPC9oMz5cIixcblx0XHRcdFwiPHA+TGlrZSBzbyBtYW55IG90aGVyIGdvdmVybm1lbnQgYWdlbmNpZXMgZHVyaW5nIHRoZSBOZXcgRGVhbCwgSE9MQyBhbmQgaXRzIHBhcmVudCBidXJlYXUsIHRoZSBGZWRlcmFsIEhvbWUgTG9hbiBCYW5rIEJvYXJkLCBzaGFwZWQgQW1lcmljYW5zJyBsaXZlcyBhbmQgbGl2ZWxpaG9vZHMgcHJvZm91bmRseSBkdXJpbmcgYW5kIGFmdGVyIHRoZSBHcmVhdCBEZXByZXNzaW9uIG9mIHRoZSAxOTMwcy4gQm90aCBwcm92ZWQgY3JpdGljYWwgdG8gcHJvdGVjdGluZyBhbmQgZXhwYW5kaW5nIGhvbWUgb3duZXJzaGlwLCB0byBzdGFuZGFyZGl6aW5nIGxlbmRpbmcgcHJhY3RpY2VzLCBhbmQgdG8gZW5jb3VyYWdpbmcgcmVzaWRlbnRpYWwgYW5kIGNvbW1lcmNpYWwgcmVhbCBlc3RhdGUgaW52ZXN0bWVudCBpbiBhIGZsYWdnaW5nIGVjb25vbXkuICBBY3Jvc3MgdGhlIG1pZGRsZSB0aGlyZCBvZiB0aGUgdHdlbnRpZXRoIGNlbnR1cnksIGFyZ3VhYmx5IHRoZSBtb3N0IHByb3NwZXJvdXMgZGVjYWRlcyBpbiBBbWVyaWNhbiBoaXN0b3J5LCB0aGVzZSBhZ2VuY2llcyB3b3JrZWQgd2l0aCBwdWJsaWMgYW5kIHByaXZhdGUgc2VjdG9yIHBhcnRuZXJzIHRvIGNyZWF0ZSBtaWxsaW9ucyBvZiBqb2JzIGFuZCBoZWxwIG1pbGxpb25zIG9mIEFtZXJpY2FucyBidXkgb3Iga2VlcCB0aGVpciBob21lcy4gQXQgdGhlIHZlcnkgc2FtZSB0aW1lLCBmZWRlcmFsIGhvdXNpbmcgcHJvZ3JhbXMgaGVscGVkIGNvZGlmeSBhbmQgZXhwYW5kIHByYWN0aWNlcyBvZiByYWNpYWwgYW5kIGNsYXNzIHNlZ3JlZ2F0aW9uLiAgVGhleSBlbnN1cmVkLCBtb3Jlb3ZlciwgdGhhdCByYW1wYW50IHJlYWwgZXN0YXRlIHNwZWN1bGF0aW9uIGFuZCBlbnZpcm9ubWVudGFsIGRlZ3JhZGF0aW9uIHdvdWxkIGFjY29tcGFueSBBbWVyaWNhJ3MgcmVtYXJrYWJsZSBlY29ub21pYyByZWNvdmVyeSBhbmQgZ3Jvd3RoLjwvcD5cIixcblx0XHRcdFwiPHA+PGNpdGU+TWFwcGluZyBJbmVxdWFsaXR5PC9jaXRlPiBicmluZ3Mgb25lIG9mIHRoZSBjb3VudHJ5J3MgbW9zdCBpbXBvcnRhbnQgYXJjaGl2ZXMgdG8gdGhlIHB1YmxpYy4gIEhPTEMncyBkb2N1bWVudHMgY29udGFpbiBhIHdlYWx0aCBvZiBpbmZvcm1hdGlvbiBhYm91dCBob3cgZ292ZXJubWVudCBvZmZpY2lhbHMsIGxlbmRlcnMsIGFuZCByZWFsIGVzdGF0ZSBpbnRlcmVzdHMgc3VydmV5ZWQgYW5kIGVuc3VyZWQgdGhlIGVjb25vbWljIGhlYWx0aCBvZiBBbWVyaWNhbiBjaXRpZXMuICBBbmQgd2l0aCB0aGUgaGVscCBvZiBvbmdvaW5nIHJlc2VhcmNoLCB3ZSBjb250aW51ZSB0byBsZWFybiBhdCB3aGF0IGNvc3Qgc3VjaCBtZWFzdXJlcyB3ZXJlIHJlYWxpemVkLjwvcD5cIixcblx0XHRcdFwiPHA+T3ZlciB0aGUgbGFzdCB0aGlydHkgeWVhcnMgZXNwZWNpYWxseSwgc2Nob2xhcnMgaGF2ZSBjaGFyYWN0ZXJpemVkIEhPTEMncyBwcm9wZXJ0eSBhc3Nlc3NtZW50IGFuZCByaXNrIG1hbmFnZW1lbnQgcHJhY3RpY2VzLCBhcyB3ZWxsIGFzIHRob3NlIG9mIHRoZSBGZWRlcmFsIEhvdXNpbmcgQWRtaW5pc3RyYXRpb24sIFZldGVyYW5zIEFkbWluaXN0cmF0aW9uLCBhbmQgVVMuIEhvdXNpbmcgQXV0aG9yaXR5LCBhcyBzb21lIG9mIHRoZSBtb3N0IGltcG9ydGFudCBmYWN0b3JzIGluIHByZXNlcnZpbmcgcmFjaWFsIHNlZ3JlZ2F0aW9uLCBpbnRlcmdlbmVyYXRpb25hbCBwb3ZlcnR5LCBhbmQgdGhlIGNvbnRpbnVlZCB3ZWFsdGggZ2FwIGJldHdlZW4gd2hpdGUgQW1lcmljYW5zIGFuZCBtb3N0IG90aGVyIGdyb3VwcyBpbiB0aGUgVS5TLiAgTWFueSBvZiB0aGVzZSBhZ2VuY2llcyBvcGVyYXRlZCB1bmRlciB0aGUgaW5mbHVlbmNlIG9mIHBvd2VyZnVsIHJlYWwgZXN0YXRlIGxvYmJpZXMgb3Igd3JvdGUgdGhlaXIgcG9saWNpZXMgc3RlZXBlZCBpbiB3aGF0IHdlcmUsIGF0IHRoZSB0aW1lLCB3aWRlc3ByZWFkIGFzc3VtcHRpb25zIGFib3V0IHRoZSBwcm9maXRhYmlsaXR5IG9mIHJhY2lhbCBzZWdyZWdhdGlvbiBhbmQgdGhlIHJlc2lkZW50aWFsIGluY29tcGF0aWJpbGl0eSBvZiBjZXJ0YWluIHJhY2lhbCBhbmQgZXRobmljIGdyb3Vwcy4gIFRocm91Z2ggSE9MQywgaW4gcGFydGljdWxhciwgcmVhbCBlc3RhdGUgYXBwcmFpc2VycyB1c2VkIHRoZSBhcHBhcmVudCByYWNpYWwgYW5kIGN1bHR1cmFsIHZhbHVlIG9mIGEgY29tbXVuaXR5IHRvIGRldGVybWluZSBpdHMgZWNvbm9taWMgdmFsdWUuICA8Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IG9mZmVycyBhIHdpbmRvdyBpbnRvIHRoZSBOZXcgRGVhbCBlcmEgaG91c2luZyBwb2xpY2llcyB0aGF0IGhlbHBlZCBzZXQgdGhlIGNvdXJzZSBmb3IgY29udGVtcG9yYXJ5IEFtZXJpY2EuIFRoaXMgcHJvamVjdCBwcm92aWRlcyB2aXNpdG9ycyB3aXRoIGEgbmV3IHZpZXcsIGFuZCBwZXJoYXBzIGV2ZW4gYSBuZXcgbGFuZ3VhZ2UsIGZvciBkZXNjcmliaW5nIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB3ZWFsdGggYW5kIHBvdmVydHkgaW4gQW1lcmljYS48L3A+XCJcblx0XHRdLFxuXHRcdGJpYmxpb2dyYXBoOiBbXG5cdFx0XHRcIjxoMj5CaWJsaW9ncmFwaGljIE5vdGU8L2gyPlwiLFxuXHRcdFx0XCI8cD5UaGUgSG9tZSBPd25lcnMgTG9hbiBDb3Jwb3JhdGlvbiAoSE9MQykgaGFzIGxvbmcgYmVlbiBzZWVuIGFzIGJvdGggYSBzYXZpb3IgdG8gdGhlIGhvdXNpbmcgc2VjdG9yIGFuZCBhIGZvcmNlIGZvciByYWNpYWwgc2VncmVnYXRpb24uICBBcyB0aGUgZWNvbm9taWMgY29sbGFwc2Ugb2YgdGhlIDE5MzBzIHJlY2VkZXMgYmV5b25kIGxpdmluZyBtZW1vcnksIGhpc3RvcmlhbnMgaGF2ZSBmb2N1c2VkIG1vcmUgb24gdGhlIHNlZ3JlZ2F0aW9uaXN0IG5hdHVyZSBvZiBob3VzaW5nIHBvbGljeeKAlGhvdyByYWNpc20gaGVscGVkIHNhdmUgdGhlIEFtZXJpY2FuIGVjb25vbXkuICBUaGUgbGVnaXNsYXRpb24gY3JlYXRpbmcgSE9MQyBjYW1lIG91dCBvZiB0aGUgZmlyc3QgMTAwIGRheXMgb2YgdGhlIFJvb3NldmVsdCBhZG1pbmlzdHJhdGlvbiBhbmQgcHJvdmlkZWQgYmlsbGlvbnMgb2YgZG9sbGFycyBmb3IgdGhlIHJlc2N1ZSBvZiBiYW5rcywgdGhyaWZ0cywgYW5kIGRpc3RyZXNzZWQgaG9tZW93bmVycy4gIE5ldyBEZWFsIGxlZ2lzbGF0aW9uIHdhcyBoaWdobHkgcG9wdWxhciBpbiB0aGUgbWlkc3Qgb2YgYW4gZWNvbm9taWMgY3Jpc2lz4oCUdGhlIERlbW9jcmF0aWNhbGx5LWNvbnRyb2xsZWQgSG91c2Ugb2YgUmVwcmVzZW50YXRpdmVzIHBhc3NlZCB0aGUgYmlsbCAzODMtNC48L3A+XCIsXG5cdFx0XHRcIjxwPkhPTEMgaGVscGVkIHJlc3RydWN0dXJlIHRoZSBBbWVyaWNhbiBtb3J0Z2FnZSBsZW5kaW5nIG1hcmtldCBieSBjcmVhdGluZyBhbmQgc3RhbmRhcmRpemluZyBzZXZlcmFsIG9mIGl0cyBlbGVtZW50cy4gIEhPTEMgaW5jb3Jwb3JhdGVkIGFwcHJhaXNhbCBvZiBob21lIHZhbHVlIGludG8gaXRzIGxlbmRpbmcgcHJvY2Vzc2VzLCBhIHByYWN0aWNlIG9ubHkgaW4gaXRzIGluZmFuY3kgYXQgdGhlIHRpbWUuICBIT0xDIHN1cHBvcnRlZCB0aGUgdHJhaW5pbmcgb2YgaG9tZSBhcHByYWlzZXJzIGFuZCBlbXBsb3llZCBodW5kcmVkcyBvZiBhcHByYWlzZXJzIHRocm91Z2hvdXQgdGhlIDE5MzBzLCB3b3JraW5nIGluIGNvbmNlcnQgd2l0aCB0aGUgbmF0aW9u4oCZcyByZWFsdG9ycyB0byBpbmF1Z3VyYXRlIGFuZCBhZHZhbmNlIHJlYWwgZXN0YXRlIGFwcHJhaXNhbCBhcyBhIHByb2Zlc3Npb24uICBIT0xD4oCZcyBkZXBhcnRtZW50IG9mIFJlc2VhcmNoIGFuZCBTdGF0aXN0aWNzIGRyZXcgdXBvbiBpdHMgbmV0d29yayBvZiByZWFsdG9ycywgZGV2ZWxvcGVycywgbGVuZGVycywgYW5kIGFwcHJhaXNlcnMgdG8gY3JlYXRlIGEgbmVpZ2hib3Job29kLWJ5LW5laWdoYm9yaG9vZCBhc3Nlc3NtZW50IG9mIG1vcmUgdGhhbiAyMDAgY2l0aWVzIGluIHRoZSBjb3VudHJ5LiAgVGhlc2UgYXNzZXNzbWVudHMgaW5jbHVkZWQgZGVtb2dyYXBoaWMgZGF0YSwgZWNvbm9taWMgcmVwb3J0cywgYW5kIHRoZSBjb2xvci1jb2RlZCBTZWN1cml0eSBNYXBzIGxhdGVyIGRlZW1lZCBpbmZhbW91cyBhcyBpbnN0cnVtZW50cyBvZiDigJxyZWRsaW5pbmcu4oCdPC9wPlwiLFxuXHRcdFx0XCI8cD5UaGUgbWFpbnN0cmVhbSB3aGl0ZSBwcmVzc+KAlG1ham9yIGRhaWx5IG5ld3NwYXBlcnMgYW5kIHBlcmlvZGljYWxz4oCUZ3JlZXRlZCB0aGUgYWdlbmN5IGFuZCBpdHMgcHJvZ3JhbXMgd2l0aCBhcHByb3ZhbC4gIFRoZXkgZXhwbGFpbmVkIHRoZSBwcm9ncmFtIGFuZCBmb3JlY2FzdCB1cHR1cm5zIGluIHRoZSByZWFsIGVzdGF0ZSBhbmQgY29uc3RydWN0aW9uIHNlY3RvcnMsIGFzIHRoZSBwcm9ncmFtIGVuam95ZWQgcG9wdWxhciBzdXBwb3J0LiAgSW4gQ2hpY2Fnbywgc2V2ZW50ZWVuIHRob3VzYW5kIHBlb3BsZSBzdG9vZCBpbiBsaW5lIGF0IEhPTEPigJlzIG9mZmljZSB0aGUgZmlyc3QgZGF5IGl0IG9wZW5lZCBpbiBBdWd1c3Qgb2YgMTkzMyB0byBpbnF1aXJlIG9yIGFwcGx5IGZvciBhaWQuICBUaGUgY29ycG9yYXRpb27igJlzIG1haW4gbGVuZGluZyBwaGFzZSBlbmRlZCBhZnRlciB0aHJlZSB5ZWFycyBhbmQgdGhlIGNvcnBvcmF0aW9uIHJlY2VkZWQgZnJvbSBtYWluc3RyZWFtIHB1YmxpYyB2aWV3LiAgSE9MQyBzbG93bHkgcmVkdWNlZCBpdHMgb3BlcmF0aW9ucyBkdXJpbmcgdGhlIDE5NDBzIHRvIG1hbmFnZSB0aGUgbG9hbnMgYW5kIGhvbWVzIGl0IGFjcXVpcmVkIGluIGl0cyBrZXkgcGhhc2Ugb2YgYWN0aXZpdHkuPC9wPlwiLFxuXHRcdFx0XCI8cD5BZnJpY2FuIEFtZXJpY2FucyBsYW1iYXN0ZWQgSE9MQyBzdGFmZmluZyBkZWNpc2lvbnMgYW5kIGluZnJhc3RydWN0dXJlIHRoYXQgZmF2b3JlZCB3aGl0ZSBob21lb3duZXJzIGFuZCBidXNpbmVzc2VzIGF0IHRoZSBleHBlbnNlIG9mIGJsYWNrcy4gIEhvd2V2ZXIsIGRpc2N1c3Npb24gaW4gYmxhY2sgbmV3c3BhcGVycywgc3VjaCBhcyB0aGUgPGNpdGU+Q2hpY2FnbyBEZWZlbmRlcjwvY2l0ZT4sIHByb21wdGVkIG9ubHkgbW9kZXN0IHJlc3BvbnNlIGJ5IHBvbGljeSBhbmQgbWVkaWEgZWxpdGVzLiAgVGhlIFJvb3NldmVsdCBhZG1pbmlzdHJhdGlvbiByZWJ1ZmZlZCBOQUFDUCBjb25jZXJucyBhYm91dCByZXN0cmljdGl2ZSBjb3ZlbmFudHMsIGV2ZW4gd2hlbiBIT0xDIHJlZGxpbmluZyB3YXMgZXhwb3NlZCBpbiAxOTM4LiAgQmxhY2sgaG91c2luZyBvZmZpY2lhbHMgb2Z0ZW4gd29ya2VkIGluY3JlbWVudGFsbHkgb24gYSBob3N0IG9mIGlzc3VlcywgaW5jbHVkaW5nIGVuZGluZyB3aGl0ZSB0ZXJyb3Jpc20gYW5kIGdldHRpbmcgbmV3IGJsYWNrIGhvdXNpbmcgYnVpbHQsIGV2ZW4gaWYgdGhhdCBtZWFudCBvcGVyYXRpbmcgd2l0aGluIHRoZSBzZWdyZWdhdGlvbmlzdCBzdHJpY3R1cmVzIG9mIGZlZGVyYWwgcG9saWN5LiAgUmFjaWFsIHNlZ3JlZ2F0aW9uIGluIGhvdXNpbmcgd2FzIG5vdCBmb3JtYWxseSBkZWVtZWQgaWxsZWdhbCB1bnRpbCB0aGUgRmFpciBIb3VzaW5nIEFjdCBvZiAxOTY4LjwvcD5cIixcblx0XHRcdFwiPHA+U2Nob2xhcnMgdmlld2VkIEhPTEMgZmF2b3JhYmx5LCBzaGFwZWQgYnkgZWNvbm9taXN0IEMuIExvd2VsbCBIYXJyaXNz4oCZIDxjaXRlPkhpc3RvcnkgYW5kIFBvbGljaWVzIG9mIHRoZSBIb21lIE93bmVyc+KAmSBMb2FuIENvcnBvcmF0aW9uPC9jaXRlPiwgcHVibGlzaGVkIGluIDE5NTEgYXMgdGhlIGZlZGVyYWwgZ292ZXJubWVudCB1bndvdW5kIHRoZSBhZ2VuY3kuICBIT0xDIGhhZCByZWZpbmFuY2VkIGEgbWlsbGlvbiBob21lcyBhbmQgcmV0dXJuZWQgYSBwcm9maXQgb2YgJDE0IG1pbGxpb24gdG8gdGhlIFUuUy4gVHJlYXN1cnkuICBJdCB3YXMgYSBzdWNjZXNzZnVsIGJ1c2luZXNzIHZlbnR1cmUgZm9yIGFuIGFnZW5jeSBjcmVhdGVkIGFzIGVtZXJnZW5jeSByZWxpZWYgdGhhdCBoZWxwZWQgc3RhYmlsaXplIGFuZCBldmVuIHJlc3VycmVjdCBhIG1vcmlidW5kIG1vcnRnYWdlIG1hcmtldCBhbmQgc3RhZ25hbnQgaG9tZSBidWlsZGluZyBzZWN0b3IuPC9wPlwiLFxuXHRcdFx0XCI8cD5JbiB0aGUgMTk4MHMgZGlzY292ZXJ5IG9mIHRoZSBIT0xDIHNlY3VyaXR5IG1hcHMgY2hhbmdlZCB0aGUgd2F5IGhpc3RvcmlhbnMgdGhvdWdodCBhYm91dCBIT0xDIGFuZCBOZXcgRGVhbCBob3VzaW5nIHBvbGljeS4gIEhvdXNpbmcgYWN0aXZpc3RzIGluIHRoZSAxOTYwcyBhbmQgMTk3MHMgaGFkIGNyaXRpY2l6ZWQgYW5kIHByb3Rlc3RlZCBkaXNjcmltaW5hdGlvbiBpbiByZWFsIGVzdGF0ZSBsZW5kaW5nIGFuZCBidXlpbmcsIGNvaW5pbmcgdGhlIHRlcm0g4oCccmVkbGluaW5n4oCdIHRvIGlsbHVzdHJhdGUgdGhlIGdlb2dyYXBoaWMgZGltZW5zaW9ucyBvZiBob3VzaW5nIGRpc2NyaW1pbmF0aW9uLiAgSGlzdG9yaWFuIEtlbm5ldGggSmFja3NvbiBmb3VuZCB0aGUgbWFwcyBpbiB0aGUgTmF0aW9uYWwgQXJjaGl2ZXMsIHN0YXRpbmcgaW4gaGlzIGF3YXJkLXdpbm5pbmcgYm9vayA8Y2l0ZT5DcmFiZ3Jhc3MgRnJvbnRpZXI8L2NpdGU+IHRoYXQgSE9MQyDigJxkZXZpc2VkIGEgcmF0aW5nIHN5c3RlbSB0aGF0IHVuZGVydmFsdWVkIG5laWdoYm9yaG9vZHMgdGhhdCB3ZXJlIGRlbnNlLCBtaXhlZCwgb3IgYWdpbmcs4oCdIGFuZCByYXRoZXIgdGhhbiBjcmVhdGluZyByYWNpYWwgZGlzY3JpbWluYXRpb24sIOKAnGFwcGxpZWQgW2V4aXN0aW5nXSBub3Rpb25zIG9mIGV0aG5pYyBhbmQgcmFjaWFsIHdvcnRoIHRvIHJlYWwtZXN0YXRlIGFwcHJhaXNpbmcgb24gYW4gdW5wcmVjZWRlbnRlZCBzY2FsZS7igJ0gIEZlZGVyYWwgaG91c2luZyBwb2xpY3kgc2ltcGx5IGJsb2NrZWQgQWZyaWNhbiBBbWVyaWNhbnMgZnJvbSBhY2Nlc3NpbmcgcmVhbCBlc3RhdGUgY2FwaXRhbCwgbGVhZGluZyB0byB0aGUgY3JlYXRpb24gb2Ygc2VncmVnYXRlZCBtYXNzIHN1YnVyYmlhIGFuZCwgbmVpZ2hib3Job29kIGJ5IG5laWdoYm9yaG9vZCwgb3BlbmVkIHJlc2lkZW50cyB0byBvcHBvcnR1bml0eSBhbmQgd2VhbHRoIGFjY3VtdWxhdGlvbiBvciBjbG9zZWQgY2l0aXplbnMgb2ZmIGZyb20gdGhlIEFtZXJpY2FuIGRyZWFtLiAgRm9sbG93aW5nIEphY2tzb27igJlzIHdvcmssIGhpc3RvcmlhbiBUaG9tYXMgU3VncnVlIHdyb3RlIG9mIHRoZSBsZWdhY3kgb2YgZmVkZXJhbCBob3VzaW5nIHBvbGljeSBpbiBEZXRyb2l0OiDigJxnZW9ncmFwaHkgaXMgZGVzdGlueS7igJ0gIE91dHNpZGUgb2YgaGlzdG9yeSwgc2Nob2xhcnMgYW5kIGpvdXJuYWxpc3RzLCBpbmNsdWRpbmcgc29jaW9sb2dpc3QgRG91Z2xhcyBNYXNzZXkgYW5kIHdyaXRlciBUYS1OZWhpc2kgQ29hdGVzLCBwb2ludCB0byBIT0xDIHJlZGxpbmluZyBhcyBhIGtleSBmYWN0b3IgaW4gcmFjaWFsIGRpc3Bhcml0aWVzIGluIHdlYWx0aCBhbmQgb3Bwb3J0dW5pdHkgdGhhdCBjb250aW51ZSB0byB0aGUgcHJlc2VudCBkYXkuPC9wPlwiLFxuXHRcdFx0XCI8cD5XaGVuIGhpc3RvcmlhbnMgaW5jb3Jwb3JhdGVkIG5ldyBkYXRhIHRlY2hub2xvZ3kgaW4gdGhlaXIgcmVzZWFyY2gsIHRoZXkgYmVnYW4gdG8gZHJhdyBuZXcgY29uY2x1c2lvbnMgYWJvdXQgSE9MQ+KAmXMgbGVnYWN5LiAgTWFwcGluZyB3aXRoIGdlb2dyYXBoaWMgaW5mb3JtYXRpb24gc3lzdGVtcyAoR0lTKSBhbmQgcXVhbnRpdGF0aXZlIHN0YXRpc3RpY2FsIG1ldGhvZHMgZnJvbSB0aGUgc29jaWFsIHNjaWVuY2VzLCBzY2hvbGFycyBpbmNsdWRpbmcgQW15IEhpbGxpZXIgYW5kIEphbWVzIEdyZWVyIGhhdmUgY291bnRlcmVkIEphY2tzb27igJlzIGluaXRpYWwgYXNzZXNzbWVudC4gIFNvbWUgQWZyaWNhbiBBbWVyaWNhbnMgZGlkIGdhaW4gYWNjZXNzIHRvIEhPTEMgZmluYW5jaW5nLCBhbmQgYSBuZWlnaGJvcmhvb2QgcmF0aW5nIHdhcyBuZWl0aGVyIGEgYmxhbmtldCBndWFyYW50ZWUgbm9yIHByb3NjcmlwdGlvbiBmb3IgTmV3IERlYWwgYWlk4oCU4oCcQ+KAnSBhbmQg4oCcROKAnS1yYXRlZCBuZWlnaGJvcmhvb2RzIG9mdGVuIHJlY2VpdmVkIG1vcmUgbW9ydGdhZ2VzIHRoYW4gbmVhcmJ5IOKAnEHigJ0gbmVpZ2hib3Job29kcy4gIFRoZSBhYmlsaXR5IHRvIHdvcmsgd2l0aCBkaWdpdGFsIGRhdGEgYW5kIHRvIHRyYW5zbWl0IGluZm9ybWF0aW9uIG92ZXIgdGhlIHdlYiBoYXMgb3BlbmVkIG1hbnkgbmV3IGF2ZW51ZXMgZm9yIHNjaG9sYXJseSBpbnF1aXJ5LCBpbmNsdWRpbmcgYXNzZXNzaW5nIHRoZSBpbXBvcnRhbmNlIG9mIHJlc3RyaWN0aXZlIGNvdmVuYW50cyBhbmQgYXNraW5nIHJlc2VhcmNoIHF1ZXN0aW9ucyBhYm91dCB0aGUgd2hvbGUgcHJvZ3JhbSwgcmF0aGVyIHRoYW4ganVzdCBpbmRpdmlkdWFsIGNpdGllcy4gIE1hbmFnaW5nIG1hc3NpdmUgYW1vdW50cyBvZiByZWFsIGVzdGF0ZSBhbmQgZGVtb2dyYXBoaWMgZGF0YSBoYXMgYmVlbiBhIGhlcmN1bGVhbiB0YXNrIHVwIHVudGlsIHJlY2VudGx5IGJ1dCBpcyBub3cgcG9zc2libGUgd2l0aCBtYXBwaW5nLCB2aXN1YWxpemF0aW9uLCBhbmQgc3RhdGlzdGljYWwgdG9vbHMuPC9wPlwiLFxuXHRcdFx0XCI8cD48Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IG9wZW5zIHRoZSBIT0xDIGZpbGVzIGF0IHRoZSBOYXRpb25hbCBBcmNoaXZlcyB0byBzY2hvbGFycywgc3R1ZGVudHMsIGFuZCByZXNpZGVudHMgYW5kIHBvbGljeSBsZWFkZXJzIGluIGxvY2FsIGNvbW11bml0aWVzLiAgVGhpcyBzaXRlIG1ha2VzIHRoZSB3ZWxsLWtub3duIHNlY3VyaXR5IG1hcHMgb2YgSE9MQyBhdmFpbGFibGUgaW4gZGlnaXRhbCBmb3JtLCBhcyB3ZWxsIGFzIHRoZSBkYXRhIGFuZCB0ZXh0dWFsIGFzc2Vzc21lbnRzIG9mIHRoZSBhcmVhIGRlc2NyaXB0aW9ucyB0aGF0IHdlcmUgY3JlYXRlZCB0byBnbyB3aXRoIHRoZSBtYXBzLiAgQnkgYnJpbmdpbmcgc3R1ZHkgb2YgSE9MQyBpbnRvIHRoZSBkaWdpdGFsIHJlYWxtLCA8Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IGVtYnJhY2VzIGEgYmlnIGRhdGEgYXBwcm9hY2ggdGhhdCBjYW4gc2ltdWx0YW5lb3VzbHkgZ2l2ZSBhIG5hdGlvbmFsIHZpZXcgb2YgdGhlIHByb2dyYW0gb3IgYSBuZWlnaGJvcmhvb2QtbGV2ZWwgYXNzZXNzbWVudCBvZiB0aGUgMTkzMHMgcmVhbCBlc3RhdGUgcmVzY3VlLiAgUHJvamVjdCByZXNlYXJjaGVycyBhcmUgcHJvdmlkaW5nIGFjY2VzcyB0byBzb21lIG9mIHRoZSBkaWdpdGFsIHRvb2xzIGFuZCBpbnRlcmFjdGl2ZSByZXNvdXJjZXMgdGhleSBhcmUgdXNpbmcgaW4gdGhlaXIgb3duIHJlc2VhcmNoLCBpbiB0aGUgaG9wZSB0aGF0IHRoZSBwdWJsaWMgd2lsbCBiZSBhYmxlIHRvIHVuZGVyc3RhbmQgdGhlIGVmZmVjdHMgb2YgZmVkZXJhbCBob3VzaW5nIHBvbGljeSBhbmQgbG9jYWwgaW1wbGVtZW50YXRpb24gaW4gdGhlaXIgb3duIGNvbW11bml0aWVzLjwvcD5cIixcblx0XHRcdFwiPGgyPkJpYmxpb2dyYXBoeTwvaDI+XCIsXG5cdFx0XHRcIjxoMz5UZXh0Ym9va3MgYW5kIE1hbnVhbHMgb24gSG9tZSBBcHByYWlzYWwgYW5kIFZhbHVhdGlvbjwvaDM+XCIsXG5cdFx0XHRcIjx1bD5cIixcblx0XHRcdFwiPGxpPjxjaXRlPkZIQSBVbmRlcndyaXRpbmcgTWFudWFsPC9jaXRlPiAoV2FzaGluZ3RvbiwgREM6IEZlZGVyYWwgSG91c2luZyBBZG1pbmlzdHJhdGlvbiwgMTkzNik8L2xpPlwiLFxuXHRcdFx0XCI8bGk+RnJlZGVyaWNrIEJhYmNvY2ssIDxjaXRlPlRoZSBWYWx1YXRpb24gb2YgUmVhbCBFc3RhdGU8L2NpdGU+IChNY0dyYXcgSGlsbCBCb29rIENvLjogTmV3IFlvcmssIDE5MzIpLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5SaWNoYXJkIEVseSBhbmQgR2VvcmdlIFdlaHJ3ZWluLCA8Y2l0ZT5MYW5kIEVjb25vbWljczwvY2l0ZT4gKE1hZGlzb24sIFdJOiBVbml2ZXJzaXR5IG9mIFdpc2NvbnNpbiBQcmVzcywgcmV2LiAxOTY0KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+RXJuZXN0IEZpc2hlciwgPGNpdGU+UHJpbmNpcGxlcyBvZiBSZWFsIEVzdGF0ZSBQcmFjdGljZTwvY2l0ZT4gKE5ldyBZb3JrOiBUaGUgTWFjTWlsbGFuIENvLiwgMTkyNCkuPC9saT5cIixcblx0XHRcdFwiPGxpPlJpY2hhcmQgSHVyZCwgPGNpdGU+UHJpbmNpcGxlcyBvZiBDaXR5IExhbmQgVmFsdWVzIDwvY2l0ZT4oTmV3IFlvcms6IFRoZSBSZWNvcmQgYW5kIEd1aWRlLCAxOTI0KS48L2xpPlwiLFxuXHRcdFx0XCI8L3VsPlwiLFxuXHRcdFx0XCI8aDM+Q29udGVtcG9yYW5lb3VzIFN0dWRpZXMgb2YgSE9MQyBhbmQgUmFjaWFsIFNlZ3JlZ2F0aW9uPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+Q2hhcmxlcyBBYnJhbXMsIDxjaXRlPkZvcmJpZGRlbiBOZWlnaGJvcnM6IEEgU3R1ZHkgb2YgUHJlanVkaWNlIGluIEhvdXNpbmcgPC9jaXRlPihOZXcgWW9yazogSGFycGVyICZhbXA7IEJyb3RoZXJzLCAxOTU1KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+Qy4gTG93ZWxsIEhhcnJpc3MsIDxjaXRlPkhpc3RvcnkgYW5kIFBvbGljaWVzIG9mIHRoZSBIb21lIE93bmVycyZyc3F1bzsgTG9hbiBDb3Jwb3JhdGlvbjwvY2l0ZT4gKFdhc2hpbmd0b24sIEQuQy4sIE5hdGlvbmFsIEJ1cmVhdSBvZiBFY29ub21pYyBSZXNlYXJjaCwgMTk1MSkuPC9saT5cIixcblx0XHRcdFwiPGxpPlJvYmVydCBDLiBXZWF2ZXIsIDxjaXRlPlRoZSBOZWdybyBHaGV0dG8gPC9jaXRlPihOZXcgWW9yazogSGFyY291cnQsIEJyYWNlLCAxOTQ4KS48L2xpPlwiLFxuXHRcdFx0XCI8L3VsPlwiLFxuXHRcdFx0XCI8aDM+SGlzdG9yaWNhbCBTdHVkaWVzIG9mIEhPTEMsIFNlZ3JlZ2F0aW9uLCBhbmQgSG9tZSBGaW5hbmNlPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+RGF2aWQgTS4gUC4gRnJldW5kLCA8Y2l0ZT5Db2xvcmVkIFByb3BlcnR5OiBTdGF0ZSBQb2xpY3kgYW5kIFdoaXRlIFJhY2lhbCBQb2xpdGljcyBpbiBTdWJ1cmJhbiBBbWVyaWNhPC9jaXRlPiAoQ2hpY2FnbzogVW5pdmVyc2l0eSBvZiBDaGljYWdvIFByZXNzLCAyMDA3KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+TWFyZ2FyZXQgR2FyYiwgPGNpdGU+Q2l0eSBvZiBBbWVyaWNhbiBEcmVhbXM6IEEgSGlzdG9yeSBvZiBIb21lIE93bmVyc2hpcCBhbmQgSG91c2luZyBSZWZvcm0gaW4gQ2hpY2FnbywgMTg3MS0xOTE5PC9jaXRlPi4mbmJzcDsgKENoaWNhZ286IFVuaXZlcnNpdHkgb2YgQ2hpY2FnbyBQcmVzcywgMjAwNSkuPC9saT5cIixcblx0XHRcdFwiPGxpPkFteSBFLiBIaWxsaWVyLCAmbGRxdW87UmVkbGluaW5nIGFuZCB0aGUgSG9tZSBPd25lcnMmcnNxdW87IExvYW4gQ29ycG9yYXRpb24sJnJkcXVvOyA8Y2l0ZT5Kb3VybmFsIG9mIFVyYmFuIEhpc3Rvcnk8L2NpdGU+IDI5LCBuby4gNCAoTWF5IDIwMDMpOiAzOTQtNDIwLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5BbXkgRS4gSGlsbGllciwgJmxkcXVvO1Jlc2lkZW50aWFsIFNlY3VyaXR5IE1hcHMgYW5kIE5laWdoYm9yaG9vZCBBcHByYWlzYWxzOiBUaGUgSG9tZSBPd25lcnMmcnNxdW87IExvYW4gQ29ycG9yYXRpb24gYW5kIHRoZSBDYXNlIG9mIFBoaWxhZGVscGhpYSwmcmRxdW87IDxjaXRlPlNvY2lhbCBTY2llbmNlIEhpc3Rvcnk8L2NpdGU+IDI5LCBuby4gMiAoU3VtbWVyIDIwMDUpOiBYWFhYPC9saT5cIixcblx0XHRcdFwiPGxpPkFteSBFLiBIaWxsaWVyLCAmbGRxdW87U2VhcmNoaW5nIGZvciBSZWQgTGluZXM6IFNwYXRpYWwgQW5hbHlzaXMgb2YgTGVuZGluZyBQYXR0ZXJucyBpbiBQaGlsYWRlbHBoaWEsIDE5NDAtMTk2MCwmcmRxdW87IDxjaXRlPlBlbm5zeWx2YW5pYSBIaXN0b3J5PC9jaXRlPiA3Miwgbm8uIDEgKFdpbnRlciAyMDA1KTogWFhYPC9saT5cIixcblx0XHRcdFwiPGxpPkFybm9sZCBSLiBIaXJzY2gsICZsZHF1bztDb250YWlubWVudCBvbiB0aGUgSG9tZSBGcm9udDogUmFjZSBhbmQgRmVkZXJhbCBIb3VzaW5nIFBvbGljeSBmcm9tIHRoZSBOZXcgRGVhbCB0byB0aGUgQ29sZCBXYXIsJnJkcXVvOyA8Y2l0ZT5Kb3VybmFsIG9mIFVyYmFuIEhpc3Rvcnk8L2NpdGU+IDI2LCBuby4gMiAoSmFudWFyeSAyMDAwKTogMTU4LTE4OTwvbGk+XCIsXG5cdFx0XHRcIjxsaT5LZW5uZXRoIFQuIEphY2tzb24sICZsZHF1bztSYWNlIEV0aG5pY2l0eSwgYW5kIFJlYWwgRXN0YXRlIEFwcHJhaXNhbDogVGhlIEhvbWUgT3duZXJzIExvYW4gQ29ycG9yYXRpb24gYW5kIHRoZSBGZWRlcmFsIEhvdXNpbmcgQWRtaW5pc3RyYXRpb24sJnJkcXVvOyA8Y2l0ZT5Kb3VybmFsIG9mIFVyYmFuIEhpc3Rvcnk8L2NpdGU+IDYsIG5vLiA0IChBdWd1c3QsIDE5ODApOiA0MTktNDUyLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5LZW5uZXRoIFQuIEphY2tzb24sIDxjaXRlPkNyYWJncmFzcyBGcm9udGllcjogVGhlIFN1YnVyYmFuaXphdGlvbiBvZiB0aGUgVW5pdGVkIFN0YXRlczwvY2l0ZT4gKE94Zm9yZDogT3hmb3JkIFVuaXZlcnNpdHkgUHJlc3MsIDE5ODUpLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5KZW5uaWZlciBTLiBMaWdodCwgJmxkcXVvO05hdGlvbmFsaXR5IGFuZCBOZWlnaGJvcmhvb2QgUmlzayBhdCB0aGUgT3JpZ2lucyBvZiBGSEEgVW5kZXJ3cml0aW5nLCZyZHF1bzsgPGNpdGU+Sm91cm5hbCBvZiBVcmJhbiBIaXN0b3J5PC9jaXRlPiAzNiAoNSk6IDYzNC02NzEuPC9saT5cIixcblx0XHRcdFwiPGxpPkxvdWlzIExlZSBXb29kcyBJSSwgJmxkcXVvO1RoZSBGZWRlcmFsIEhvbWUgTG9hbiBCYW5rIEJvYXJkLCBSZWRsaW5pbmcsIGFuZCB0aGUgTmF0aW9uYWwgUHJvbGlmZXJhdGlvbiBvZiBSYWNpYWwgTGVuZGluZyBEaXNjcmltaW5hdGlvbiwgMTkyMS0xOTUwLCZyZHF1bzsgPGNpdGU+Sm91cm5hbCBvZiBVcmJhbiBIaXN0b3J5PC9jaXRlPjsgVm9sdW1lIDM4LCBJc3N1ZSA2IChOb3ZlbWJlciAyMDEyKTogMTAzNi0xMDU5LjwvbGk+XCIsXG5cdFx0XHRcIjwvdWw+XCIsXG5cdFx0XHRcIjxoMz5IaXN0b3JpY2FsIENvbW11bml0eSBTdHVkaWVzIEZlYXR1cmluZyBBbmFseXNpcyBvZiBIT0xDPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+V2VuZGVsbCBQcml0Y2hldHQsIDxjaXRlPkJyb3duc3ZpbGxlLCBCcm9va2x5bjogQmxhY2tzLCBKZXdzLCBhbmQgdGhlIENoYW5naW5nIEZhY2Ugb2YgdGhlIEdoZXR0byA8L2NpdGU+KENoaWNhZ286IFVuaXZlcnNpdHkgb2YgQ2hpY2FnbyBQcmVzcywgMjAwMikuPC9saT5cIixcblx0XHRcdFwiPGxpPkJlcnlsIFNhdHRlciwgPGNpdGU+RmFtaWx5IFByb3BlcnRpZXM6IFJhY2UsIFJlYWwgRXN0YXRlLCBhbmQgdGhlIEV4cGxvaXRhdGlvbiBvZiBCbGFjayBVcmJhbiBBbWVyaWNhPC9jaXRlPiAoTWV0cm9wb2xpdGFuIEJvb2tzLCAyMDA5KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+Um9iZXJ0IE8uIFNlbGYsIDxjaXRlPkFtZXJpY2FuIEJhYnlsb24sIFJhY2UgYW5kIHRoZSBTdHJ1Z2dsZSBmb3IgUG9zdHdhciBPYWtsYW5kPC9jaXRlPiAoUHJpbmNldG9uOiBQcmluY2V0b24gVW5pdmVyc2l0eSBQcmVzcywgMjAwMykuPC9saT5cIixcblx0XHRcdFwiPGxpPlRob21hcyBKLiBTdWdydWUsIDxjaXRlPk9yaWdpbnMgb2YgdGhlIFVyYmFuIENyaXNpczogUmFjZSBhbmQgSW5lcXVhbGl0eSBpbiBQb3N0d2FyIERldHJvaXQ8L2NpdGU+IChQcmluY2V0b246IFByaW5jZXRvbiBVbml2ZXJzaXR5IFByZXNzLCAxOTk2KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+Q3JhaWcgU3RldmVuIFdpbGRlciwgPGNpdGU+Q292ZW5hbnQgV2l0aCBDb2xvcjogUmFjZSBhbmQgU29jaWFsIFBvd2VyIGluIEJyb29rbHluPC9jaXRlPiAoTmV3IFlvcms6IENvbHVtYmlhIFVuaXZlcnNpdHkgUHJlc3MsIDIwMDEpLjwvbGk+XCIsXG5cdFx0XHRcIjwvdWw+XCIsXG5cdFx0XHRcIjxoMz5Tb2Npb2xvZ2ljYWwgU3R1ZGllcyBvZiBSYWNpYWwgRGlzY3JpbWluYXRpb24gYW5kIFNlZ3JlZ2F0aW9uPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+Um9zZSBIZWxwZXIsIDxjaXRlPlJhY2lhbCBQb2xpY2llcyBhbmQgUHJhY3RpY2VzIG9mIFJlYWwgRXN0YXRlIEJyb2tlcnM8L2NpdGU+LiAoTWlubmVhcG9saXM6IFVuaXZlcnNpdHkgb2YgTWlubmVzb3RhIFByZXNzLCAxOTY5KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+RG91Z2xhcyBTLiBNYXNzZXkgYW5kIE5hbmN5IEEuIERlbnRvbiwgPGNpdGU+QW1lcmljYW4gQXBhcnRoZWlkOiBTZWdyZWdhdGlvbiBhbmQgdGhlIE1ha2luZyBvZiB0aGUgVW5kZXJjbGFzczwvY2l0ZT4gKENhbWJyaWRnZTogSGFydmFyZCBVbml2ZXJzaXR5IFByZXNzLCAxOTkzKS48L2xpPlwiLFxuXHRcdFx0XCI8L3VsPlwiXG5cdFx0XSxcblx0XHRcImJ1cmdlc3NcIjogW1xuXHRcdFx0XCI8cD48c3Ryb25nPkluc3BpcmVkIGJ5IHRoZSAxOTIwcy1lcmEgXFxcImNvbmNlbnRyaWMgem9uZXMgdGhlb3J5XFxcIiBvZiBFcm5lc3QgVy4gQnVyZ2VzcywgdGhpcyBpbnRlcmFjdGl2ZSB2aXN1YWxpemF0aW9uIG9mZmVycyBhIHZpZXcgb2YgaG93IHJlZGxpbmluZyBjb25jZW50cmF0ZWQgcG9wdWxhdGlvbnMsIGFuZCBkaWQgc28gYWxvbmcgYSBnZW5lcmFsbHkgY29uc2lzdGVudCBwYXR0ZXJuLjwvc3Ryb25nPjwvcD5cIixcblx0XHRcdFwiPHA+QW4gdXJiYW4gc29jaW9sb2dpc3Qgb2YgdGhlIGV4dHJhb3JkaW5hcmlseSBpbmZsdWVudGlhbCBDaGljYWdvIFNjaG9vbCBvZiBTb2Npb2xvZ3ksIEJ1cmdlc3MgZXhwb3VuZGVkIHRoaXMgdGhlb3J5IGluIGEgMTkyNSBzdHVkeSA8Y2l0ZT5UaGUgQ2l0eTwvY2l0ZT4uIEFjY29yZGluZyB0byBCdXJnZXNzLCBldmVyeSBjaXR5IGRldmVsb3BlZCBhcyBhIHNlcmllcyBvZiBjb25jZW50cmljIGNpcmNsZXMuICBEb3dudG93biBidXNpbmVzcyBkaXN0cmljdHMgd291bGQgYmUgc3Vycm91bmRlZCBieSBmYWN0b3J5IHpvbmVzLiAgRmFjdG9yeSB6b25lcyB3b3VsZCB0cmFuc2l0aW9uIHRvIHNsdW1zLCBmb2xsb3dlZCB0aGVuIGJ5IHByb2dyZXNzaXZlbHkgbW9yZSBhZmZsdWVudCBob3VzaW5nIGZvciB3b3JraW5nIHBlb3BsZSBhbmQgdGhlIGludmVzdG9yIGNsYXNzLCBiZWZvcmUgdGhlbiByZWFjaGluZyB0aGUgZmluYWwgem9uZSwgZnJvbSB3aGVuY2UgY29tbXV0ZXJzIGNhbWUgaW50byB0aGUgY2l0eS4gQXMgdGhlIGhpc3RvcmlhbiBFbGFpbmUgTGV3aW5uZWsgcG9pbnRzIG91dCwgXFxcIkJ1cmdlc3MgYWRhcHRlZCBhIGhhbGYtY2VudHVyeSBvZiBDaGljYWdvIG1hcHMgYW5kIGNvZGlmaWVkIHRoZW0gaW4gYSBtb2RlbCBvZiBhYnN0cmFjdGlvbiBhbmQgdXJiYW4gdGhlb3J5IHRoYXQgaGFzIGJlZW4gY2FsbGVkJiM4MjEyO3dpdGggc29tZSBoeXBlcmJvbGUmIzgyMTI7J3RoZSBtb3N0IGZhbW91cyBkaWFncmFtIGluIHNvY2lhbCBzY2llbmNlLidcXFwiICg8Y2l0ZT5UaGUgV29ya2luZyBNYW7igJlzIFJld2FyZDogQ2hpY2Fnb+KAmXMgRWFybHkgU3VidXJicyBhbmQgVGhlIFJvb3RzIG9mIEFtZXJpY2FuIFNwcmF3bDwvY2l0ZT4gKE94Zm9yZCwgMjAxNCksIDEzMC4pPC9wPlwiLFxuXHRcdFx0XCI8aW1nIHNyYz0nLi9zdGF0aWMvYnVyZ2Vzcy5wbmcnIC8+XCIsXG5cdFx0XHRcIjxwPkluIEJ1cmdlc3MncyBtb2RlbCwgZWFjaCByaW5nIGhhZCBjdWx0dXJhbCBhbmQgZWNvbm9taWMgZmVhdHVyZXMmIzgyMTI7ZmVhdHVyZXMgdGhhdCBoZSBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCBldGhuaWMgYW5kIHJhY2lhbCBwb3B1bGF0aW9ucy4gUmVjZW50IGltbWlncmFudHMgYW5kIGJsYWNrIG1pZ3JhbnRzIG9jY3VwaWVkIGNlbnRyYWwgc2x1bSBkaXN0cmljdHMgcmlmZSB3aXRoIHZpY2UgZGVucyBhbmQgcnVuIGRvd24gcm9vbWluZyBob3VzZXMuICBTZWNvbmQtZ2VuZXJhdGlvbiBFdXJvcGVhbiBpbW1pZ3JhbnRzIGFuZCBmYWN0b3J5IGFuZCBhIHNob3Agd29ya2VycywgXFxcInNraWxsZWQgYW5kIHRocmlmdHksXFxcIiBsaXZlZCBvbiB0aGUgb3V0ZXIgZWRnZSBvZiB0aGUgc2x1bXMgYW5kIG9uIHRoZSBpbm5lciBlZGdlIG9mIHRoZSByaW5nIG9mIHdlbGwta2VwdCBhcGFydG1lbnQgaG91c2VzIGFuZCBcXFwid29ya2luZ21lbidzIGhvbWVzLlxcXCIgQmV5b25kIHRoZW0gd2FzIHRoZSBcXFwiUHJvbWlzZWQgTGFuZFxcXCIgb2YgcmVzaWRlbnRpYWwgaG90ZWxzIGFuZCBzaW5nbGUtZmFtaWx5IGhvbWVzLiAgSW4gY29udHJhc3QgdG8gdGhlIHN3YXJ0aHksIGNvbmdlc3RlZCBzbHVtcywgdGhlc2Ugd2VyZSBcXFwiYnJpZ2h0IGxpZ2h0IGFyZWFzXFxcIiBzYWZlbHkgcHJvdGVjdGVkIGJ5IHJlc3RyaWN0aXZlIGNvdmVuYW50cyBhbmQgaGlnaCBwcmljZSBwb2ludHMuPC9wPlwiLFxuXHRcdFx0XCI8ZmlndXJlPjxpbWcgc3JjPScuL3N0YXRpYy9idXJnZXNzLWNoaWNhZ28ucG5nJyAvPjxmaWdjYXB0aW9uPkJ1cmdlc3MncyB0aGVvcnkgd2FzIGRyYXduIGZyb20gYW5kIGFwcGxpZWQgdG8gQ2hpY2Fnby48L2ZpZ2NhcHRpb24+PC9maWd1cmU+XCIsXG5cdFx0XHRcIjxwPkJ1cmdlc3MncyBtb2RlbCwgaW4gYWRkaXRpb24gdG8gcmVmbGVjdGluZyB0aGUgaG9tZXMgb2YgcmVhbCBlc3RhdGUgaW52ZXN0b3IgY29tbXVuaXRpZXMsIHNlcnZlZCBhcyBhbiBleHRlbnNpb24gb2Ygd2lkZXIgc2VncmVnYXRpb25pc3QgdGhpbmtpbmcgZHJpdmluZyBib3RoIHNvY2lvbG9neSBhcyBhIGRpc2NpcGxpbmUgYW5kIGFkbWluaXN0cmF0aXZlIHByYWN0aWNlIGR1cmluZyB0aGUgcHJvZ3Jlc3NpdmUgZXJhLiAgT2JzZXNzaW9uIHdpdGggY2l0aWVzIGFzIFxcXCJvcmdhbmlzbXNcXFwiIG9mIHNvY2lldHksIHRoZXkgYmVsaWV2ZWQgaW4gd2hhdCB0aGUgc29jaW9sb2dpc3QgTG91aXMgV2lydGggYmVuaWdubHkgZGVzY3JpYmVkIGFzIHRoZSBcXFwiZXVnZW5pY3Mgb2YgdGhlIGNpdHkuXFxcIjwvcD5cIixcblx0XHRcdFwiPHA+TWFueSBvZiB0aGUgSE9MQyBtYXBzIHJlZmxlY3RlZCBib3RoIHRoZSBjYXRlZ29yaWNhbCBpbXB1bHNlIGFuZCBzcGF0aWFsIG9yZ2FuaXphdGlvbiBvZiBCdXJnZXNzIG1vZGVsIHdpdGggRCBhbmQgQyBuZWlnaGJvcmhvb2RzIG1vcmUgbGlrZWx5IHRvIGJlIGxvY2F0ZWQgYXJvdW5kIGNlbnRyYWwgYnVzaW5lc3MgZGlzdHJpY3RzIGFuZCBBIGFuZCBCIG5laWdoYm9yaG9vZHMgaW4gaW5jcmVhc2luZ2x5IHN1YnVyYmFuIHBlcmlwaGVyaWVzLiBUaGUgZGlhZ3JhbSB2aXN1YWxpemVzIHRoZSByZWxhdGl2ZSBkaXN0cmlidXRpb24gb2YgSE9MQyBncmFkZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNlbnRlciBvZiB0aGUgY2l0eS4gVGhlIG9wYWNpdHkgb2YgdGhlIHJpbmdzIHJlZmxlY3RzIHRoZSByZWxhdGl2ZSBkZW5zaXR5IG9mIHpvbmVkIGFyZWFzIG9uIHRoZSBtYXAuIEhvdmVyaW5nIG92ZXIgdGhlIHJpbmdzIHdpbGwgaGlnaGxpZ2h0IGFyZWFzIGZvciB0aGF0IGdyYWRlLjwvcD5cIixcblx0XHRcdFwiPHA+T3VyIGFkYXB0YXRpb24gb2YgQnVyZ2VzcyBkaWFncmFtcyBpcyBub3QgbWVhbnQgdG8gcmVzdXNjaXRhdGUgaGlzIGRpc2NyZWRpdGVkIHRoZW9yeS4gIFJhdGhlciwgd2UgYWltIHRvIHNob3cganVzdCBob3cgcHJvZm91bmRseSBzZWdyZWdhdGlvbmlzdCBwcmFjdGljZXMgb2YgcmVkbGluaW5nIGFjdHVhbGx5IHNoYXBlZCBBbWVyaWNhbiBjaXRpZXMgdG8gcmVzZW1ibGUgYSByb3VuZGx5IGRpc2NyZWRpdGVkIHNvY2lhbCB0aGVvcnkuICBTZWdyZWdhdGlvbiB3YXMgbm90IG5hdHVyYWwuICBRdWl0ZSB0aGUgY29udHJhcnksIHJlZGxpbmluZyBncmVhdGx5IGltcGVkZWQgdGhlIG5hdHVyYWwgZmxvd3Mgb2YgcGVvcGxlIGFuZCBjYXBpdGFsLiAgVGhyb3VnaCBmZWRlcmFsIGFjdGlvbiBhbmQgbG9jYWwgbWFuaXB1bGF0aW9uLCBsaWZlIHdhcyBtYWRlIHRvIGltaXRhdGUgYXJ0LjwvcD5cIlxuXG5cdFx0XVxuXHR9LFxuXG5cdHNldFNob3c6IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG5cdFx0dGhpcy5kYXRhLm1vZGFsID0ge1xuXHRcdFx0b3BlbjogKHN1YmplY3QgIT09IG51bGwpLFxuXHRcdFx0c3ViamVjdDogc3ViamVjdFxuXHRcdH1cblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRnZXRNb2RhbENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kYXRhLm1vZGFsLm9wZW4pID8gdGhpcy5wYXJzZU1vZGFsQ29weSh0aGlzLmRhdGFbdGhpcy5kYXRhLm1vZGFsLnN1YmplY3RdKSA6IG51bGw7XG5cdH0sXG5cblx0bWFpbk1vZGFsSXNPcGVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLm1vZGFsLm9wZW47XG5cdH0sXG5cblx0cGFyc2VNb2RhbENvcHkgKHJhd0NvbnRlbnQpIHtcblx0XHRsZXQgbW9kYWxDb3B5ID0gJyc7XG5cblx0XHR0cnkge1xuXHRcdFx0bW9kYWxDb3B5ID0gcmF3Q29udGVudC5qb2luKCdcXG4nKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS53YXJuKCdFcnJvciBwYXJzaW5nIG1vZGFsIGNvcHk6ICcpO1xuXHRcdFx0bW9kYWxDb3B5ID0gJ0Vycm9yIHBhcnNpbmcgbW9kYWwgY29weS4nO1xuXHRcdH1cblxuXHRcdC8vIFJlYWN0IHJlcXVpcmVzIHRoaXMgZm9ybWF0IHRvIHJlbmRlciBhIHN0cmluZyBhcyBIVE1MLFxuXHRcdC8vIHZpYSBkYW5nZXJvdXNseVNldElubmVySFRNTC5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X19odG1sOiBtb2RhbENvcHlcblx0XHR9O1xuXHR9XG5cbn1cblxuLy8gTWl4aW4gRXZlbnRFbWl0dGVyIGZ1bmN0aW9uYWxpdHlcbk9iamVjdC5hc3NpZ24oVGV4dHNTdG9yZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIGhhbmRsZSBhbGwgdXBkYXRlc1xuQXBwRGlzcGF0Y2hlci5yZWdpc3RlcigoYWN0aW9uKSA9PiB7XG5cblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5vbk1vZGFsQ2xpY2s6XG5cdFx0XHRUZXh0c1N0b3JlLnNldFNob3coYWN0aW9uLnN1YmplY3QpO1xuXHRcdFx0YnJlYWs7XG5cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0c1N0b3JlOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgQXBwRGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5pbXBvcnQgQ2FydG9EQkxvYWRlciBmcm9tICcuLi91dGlscy9DYXJ0b0RCTG9hZGVyJztcblxuY29uc3QgVXNlckxvY2F0aW9uU3RvcmUgPSB7XG5cblx0ZGF0YToge1xuXHRcdGxhdExuZzogbnVsbCxcblx0XHRhZElkOiBudWxsLFxuXHRcdGNpdHk6IG51bGwsXG5cdFx0bmVpZ2hib3Job29kOiBudWxsLFxuXHRcdG9mZmVyWm9vbVRvOiBmYWxzZVxuXHR9LFxuXG5cdGRhdGFMb2FkZXI6IENhcnRvREJMb2FkZXIsXG5cblx0bG9hZERhdGE6IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdHRoaXMuZGF0YS5sYXRMbmcgPSBwb2ludDtcblxuXHRcdHRoaXMuZGF0YUxvYWRlci5xdWVyeShbXG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXJ5OiAnU0VMRUNUIGFkX2lkLCBjaXR5LCBTVF9kaXN0YW5jZShTVF9zZXRzcmlkKFNUX01ha2VQb2ludChob2xjX21hcHMubG9vcGxuZywgaG9sY19tYXBzLmxvb3BsYXQpLDQzMjYpLCBTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpKSBhcyBkaXN0YW5jZSwgc3RfeG1pbiggc3RfZW52ZWxvcGUoc3RfY29sbGVjdChTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpLCBob2xjX21hcHMudGhlX2dlb20pKSkgYXMgYmJ4bWluLCBzdF94bWF4KCBzdF9lbnZlbG9wZShzdF9jb2xsZWN0KFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KCcgKyBwb2ludFsxXSArJywgJyArIHBvaW50WzBdICsgJyksNDMyNiksIGhvbGNfbWFwcy50aGVfZ2VvbSkpKSBhcyBiYnhtYXgsIHN0X3ltaW4oIHN0X2VudmVsb3BlKHN0X2NvbGxlY3QoU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoJyArIHBvaW50WzFdICsnLCAnICsgcG9pbnRbMF0gKyAnKSw0MzI2KSwgaG9sY19tYXBzLnRoZV9nZW9tKSkpIGFzIGJieW1pbiwgc3RfeW1heCggc3RfZW52ZWxvcGUoc3RfY29sbGVjdChTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpLCBob2xjX21hcHMudGhlX2dlb20pKSkgYXMgYmJ5bWF4IGZyb20gaG9sY19tYXBzIGpvaW4gaG9sY19tYXBzX2Fkc19qb2luIG9uIGhvbGNfbWFwcy5tYXBfaWQgPSBob2xjX21hcHNfYWRzX2pvaW4ubWFwX2lkIGpvaW4gaG9sY19hZHMgb24gaG9sY19hZHMuaWQgPSBob2xjX21hcHNfYWRzX2pvaW4uYWRfaWQgb3JkZXIgYnkgZGlzdGFuY2UgbGltaXQgMScsXG5cdFx0XHRcdGZvcm1hdDogJ0pTT04nXG5cdFx0XHR9XG5cdFx0XSkudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdHRoaXMuZGF0YS5jaXR5ID0gcmVzcG9uc2VbMF1bMF0uY2l0eTtcblx0XHRcdHRoaXMuZGF0YS5hZElkID0gcmVzcG9uc2VbMF1bMF0uYWRfaWQ7XG5cdFx0XHR0aGlzLmRhdGEub2ZmZXJab29tVG8gPSB0cnVlO1xuXG5cdFx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0XHR9LCAoZXJyb3IpID0+IHtcblx0XHRcdC8vIFRPRE86IGhhbmRsZSB0aGlzLlxuXHRcdFx0Y29uc29sZS5sb2coJ0xvY2F0aW9uIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXG5cdH0sXG5cblx0c2V0T2ZmZXJab29tVG86IGZ1bmN0aW9uICh0cnVlT3JGYWxzZSkge1xuXHRcdHRoaXMuZGF0YS5vZmZlclpvb21UbyA9IHRydWVPckZhbHNlO1xuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmxhdExuZztcblx0fSxcblxuXHRnZXRBZElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFkSWQ7XG5cdH0sXG5cblx0Z2V0Q2l0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jaXR5O1xuXHR9LFxuXG5cdGdldE5laWdoYm9yaG9vZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5uZWlnaGJvcmhvb2Q7XG5cdH0sXG5cblx0Z2V0T2ZmZXJab29tVG86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEub2ZmZXJab29tVG87XG5cdH0sXG59XG5cbi8vIE1peGluIEV2ZW50RW1pdHRlciBmdW5jdGlvbmFsaXR5XG5PYmplY3QuYXNzaWduKFVzZXJMb2NhdGlvblN0b3JlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLy8gUmVnaXN0ZXIgY2FsbGJhY2sgdG8gaGFuZGxlIGFsbCB1cGRhdGVzXG5BcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKChhY3Rpb24pID0+IHtcblxuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLnVzZXJMb2NhdGVkOlxuXHRcdFx0aWYgKGFjdGlvbi5wb2ludCkge1xuXHRcdFx0XHRVc2VyTG9jYXRpb25TdG9yZS5sb2FkRGF0YShhY3Rpb24ucG9pbnQpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLnVzZXJSZXNwb25kZWRUb1pvb21PZmZlcjpcblx0XHRcdFVzZXJMb2NhdGlvblN0b3JlLnNldE9mZmVyWm9vbVRvKGZhbHNlKTtcblx0XHRcdGJyZWFrO1xuXG5cdH1cblx0cmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVXNlckxvY2F0aW9uU3RvcmU7IiwiaW1wb3J0IEFwcERpc3BhdGNoZXIgZnJvbSAnLi9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCBSYXN0ZXJTdG9yZSBmcm9tICcuLi9zdG9yZXMvUmFzdGVyU3RvcmUnO1xuaW1wb3J0IEFyZWFEZXNjcmlwdGlvbnNTdG9yZSBmcm9tICcuLi9zdG9yZXMvQXJlYURlc2NyaXB0aW9uc1N0b3JlJztcblxuZXhwb3J0IGNvbnN0IEFwcEFjdGlvblR5cGVzID0ge1xuXG5cdC8vIE5vdGU6IHN0b3JlcyBlbWl0IHRoaXMgdHlwZSBvZiBldmVudC5cblx0Ly8gVGhvdWdoIGl0IGlzIG5vdCBhY3R1YWxseSBhbiBBY3Rpb24gdHlwZTtcblx0Ly8gaXQncyBlbnVtZXJhdGVkIGhlcmUgZm9yIGVhc2Ugb2YgYWNjZXNzLlxuXHRzdG9yZUNoYW5nZWQ6ICdzdG9yZUNoYW5nZWQnLFxuXG5cdEFEQ2F0ZWdvcnlTZWxlY3RlZDogJ0FEQ2F0ZWdvcnlTZWxlY3RlZCcsXG5cdEFESW1hZ2VPcGVuZWQ6ICdBREltYWdlT3BlbmVkJyxcblx0bG9hZEluaXRpYWxEYXRhOiAnbG9hZEluaXRpYWxEYXRhJyxcblx0aW5pdGlhbERhdGFMb2FkZWQ6ICdpbml0aWFsRGF0YUxvYWRlZCcsXG5cdGdldEluaXRpYWxEYXRhOiAnZ2V0SW5pdGlhbERhdGEnLFxuXHRjaXR5U2VsZWN0ZWQ6ICdjaXR5U2VsZWN0ZWQnLFxuXHRncmFkZVNlbGVjdGVkOiAnZ3JhZGVTZWxlY3RlZCcsXG5cdG5laWdoYm9yaG9vZEhpZ2hsaWdodGVkOiAnbmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQnLFxuXHRuZWlnaGJvcmhvb2RTZWxlY3RlZDogJ25laWdoYm9yaG9vZFNlbGVjdGVkJyxcblx0cmluZ0dyYWRlU2VsZWN0ZWQ6ICdyaW5nR3JhZGVTZWxlY3RlZCcsXG5cdG1hcEluaXRpYWxpemVkOiAnbWFwSW5pdGlhbGl6ZWQnLFxuXHRtYXBNb3ZlZDogJ21hcE1vdmVkJyxcblx0dXNlckxvY2F0ZWQ6ICd1c2VyTG9jYXRlZCcsXG5cdHVzZXJSZXNwb25kZWRUb1pvb21PZmZlcjogJ3VzZXJSZXNwb25kZWRUb1pvb21PZmZlcicsXG5cdG9uTW9kYWxDbGljazogJ29uTW9kYWxDbGljaycsXG5cdHdpbmRvd1Jlc2l6ZWQ6ICd3aW5kb3dSZXNpemVkJ1xuXG59O1xuXG5leHBvcnQgY29uc3QgQXBwQWN0aW9ucyA9IHtcblxuXHRBRENhdGVnb3J5U2VsZWN0ZWQ6ICh2YWx1ZSkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMuQURDYXRlZ29yeVNlbGVjdGVkLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExvYWQgZGF0YSBuZWVkZWQgYnkgdGhlIGFwcGxpY2F0aW9uIG9uIGluaXQuXG5cdCAqL1xuXHRsb2FkSW5pdGlhbERhdGE6IChzdGF0ZSwgaGFzaFN0YXRlKSA9PiB7XG5cdFx0Ly9jb25zb2xlLmxvZyhgWzFhXSBBICckeyBBcHBBY3Rpb25UeXBlcy5sb2FkSW5pdGlhbERhdGEgfScgZXZlbnQgaXMgYnJvYWRjYXN0IGdsb2JhbGx5IGZyb20gQXBwQWN0aW9uQ3JlYXRvci5sb2FkSW5pdGlhbERhdGEoKS5gKTtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLmxvYWRJbml0aWFsRGF0YSxcblx0XHRcdHN0YXRlOiBzdGF0ZSxcblx0XHRcdGhhc2hTdGF0ZTogaGFzaFN0YXRlXG5cdFx0fSk7XG5cdH0sXG5cblx0aW5pdGlhbERhdGFMb2FkZWQ6IChzdGF0ZSkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMuaW5pdGlhbERhdGFMb2FkZWQsXG5cdFx0XHRzdGF0ZTogc3RhdGVcblx0XHR9KTtcblx0fSxcblxuXHRBREltYWdlT3BlbmVkOiAoaG9sY0lkLCBhZElkKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5BREltYWdlT3BlbmVkLFxuXHRcdFx0aG9sY0lkOiBob2xjSWQsXG5cdFx0XHRhZElkOiBhZElkXG5cdFx0fSk7XG5cdH0sXG5cblx0Y2l0eVNlbGVjdGVkOiAoY2l0eSwgc2VsZWN0ZWRCeVVzZXIgPSBmYWxzZSkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMuY2l0eVNlbGVjdGVkLFxuXHRcdFx0dmFsdWU6IGNpdHksXG5cdFx0XHRzZWxlY3RlZEJ5VXNlcjogdHJ1ZVxuXHRcdH0pO1xuXHR9LFxuXG5cdGdyYWRlU2VsZWN0ZWQ6IChncmFkZSkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMuZ3JhZGVTZWxlY3RlZCxcblx0XHRcdHZhbHVlOiBncmFkZVxuXHRcdH0pO1xuXHR9LFxuXG5cdG5laWdoYm9yaG9vZEhpZ2hsaWdodGVkOiAoaG9sY0lkLCBhZElkKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5uZWlnaGJvcmhvb2RIaWdobGlnaHRlZCxcblx0XHRcdGhvbGNJZDogaG9sY0lkXG5cdFx0fSlcblx0fSxcblxuXHRuZWlnaGJvcmhvb2RTZWxlY3RlZDogKGhvbGNJZCwgYWRJZCkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMubmVpZ2hib3Job29kU2VsZWN0ZWQsXG5cdFx0XHRob2xjSWQ6IGhvbGNJZCxcblx0XHRcdGFkSWQ6IGFkSWRcblx0XHR9KVxuXHR9LFxuXG5cdHN0YXRlU2VsZWN0ZWQ6IChzdGF0ZSkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMuc3RhdGVTZWxlY3RlZCxcblx0XHRcdHZhbHVlOiBzdGF0ZVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJpbmdHcmFkZVNlbGVjdGVkOiAoc2VsZWN0ZWRSaW5nR3JhZGUpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLnJpbmdHcmFkZVNlbGVjdGVkLFxuXHRcdFx0dmFsdWU6IHNlbGVjdGVkUmluZ0dyYWRlXG5cdFx0fSk7XG5cdH0sXG5cblx0Ly8gbWFwTW92ZWQ6ICh2aXNpYmxlQWRJZHMsIGJlbG93QWRUaHJlc2hvbGQgPSBmYWxzZSkgPT4ge1xuXHQvLyBcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHQvLyBcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMubWFwTW92ZWQsXG5cdC8vIFx0XHR2YWx1ZTogdmlzaWJsZUFkSWRzLFxuXHQvLyBcdFx0YmVsb3dBZFRocmVzaG9sZDogYmVsb3dBZFRocmVzaG9sZFxuXHQvLyBcdH0pXG5cdC8vIH0sXG5cblx0b25Nb2RhbENsaWNrOiAoc3ViamVjdCkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMub25Nb2RhbENsaWNrLFxuXHRcdFx0c3ViamVjdDogc3ViamVjdFxuXHRcdH0pXG5cdH0sXG5cblx0dXNlckxvY2F0ZWQ6IChwb2ludCkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMudXNlckxvY2F0ZWQsXG5cdFx0XHRwb2ludDogcG9pbnRcblx0XHR9KTtcblx0fSxcblxuXHR1c2VyUmVzcG9uZGVkVG9ab29tT2ZmZXI6ICgpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLnVzZXJSZXNwb25kZWRUb1pvb21PZmZlclxuXHRcdH0pO1xuXHR9LFxuXG5cdG1hcEluaXRpYWxpemVkOiAodGhlTWFwKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5tYXBJbml0aWFsaXplZCxcblx0XHRcdHRoZU1hcDogdGhlTWFwLFxuXHRcdFx0cmFzdGVyczogUmFzdGVyU3RvcmUuZ2V0QWxsUmFzdGVycygpLFxuXHRcdFx0YWRzTWV0YWRhdGE6IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRBRHNNZXRhZGF0YSgpXG5cdFx0fSk7XG5cdH0sXG5cblx0bWFwTW92ZWQ6ICh0aGVNYXApID0+IHtcblx0XHQvLyB0aGlzIGhhcyBmaXJlZCByZXBlYXRlZGx5IHdoZW4gaXQgc2hvdWxkIGZpcmUgb25seSBvbmNlLlxuXHRcdC8vIEkgdGhpbmsgdGhpcyBtaWdodCBiZSByZWxhdGVkIHRvIHJlLXJlbmRlcmluZyBoYXBwZW5pbmcgXG5cdFx0Ly8gZHVyaW5nIGxlYWZsZXQgYW5pbWF0aW9uLlxuXHRcdGlmICghQXBwRGlzcGF0Y2hlci5pc0Rpc3BhdGNoaW5nKCkpIHtcblx0XHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5tYXBNb3ZlZCxcblx0XHRcdFx0dGhlTWFwOiB0aGVNYXAsXG5cdFx0XHRcdHJhc3RlcnM6IFJhc3RlclN0b3JlLmdldEFsbFJhc3RlcnMoKSxcblx0XHRcdFx0YWRzTWV0YWRhdGE6IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRBRHNNZXRhZGF0YSgpXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0d2luZG93UmVzaXplZDogKCkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMud2luZG93UmVzaXplZFxuXHRcdH0pO1xuXHR9XG59O1xuXG4iLCJpbXBvcnQgeyBEaXNwYXRjaGVyIH0gZnJvbSAnZmx1eCc7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBEaXNwYXRjaGVyKCk7XG4iLCIvKlxuICogVE9ETzogTW92ZSB0aGlzIGludG8gQHBhbm9yYW1hL3Rvb2xraXQuXG4gKiBcbiAqIENvbnNpZGVyIHB1bGxpbmcgY2FydG9kYi1jbGllbnQgaW50byB0aGlzIGFuZCBwYWNrYWdpbmcgdGhlIHdob2xlIHRoaW5nIGFzIGEgY29tcG9uZW50LFxuICogbGVhdmluZyBgcXVlcnlgIGFzIHRoZSBvbmx5IHB1YmxpYyBtZXRob2QuXG4gKiBcbiAqIEFsc28sIG5vdGUgdGhpcyBpcyBwcmV0dHkgc2ltaWxhciB0byBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9jYXJ0b2RiIGFscmVhZHkgPi48XG4gKi9cblxuaW1wb3J0IFF1ZXVlIGZyb20gJ3F1ZXVlLWFzeW5jJztcblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi8uLi9iYXNlbWFwcy9jYXJ0b2RiL2NvbmZpZy5qc29uJztcbmltcG9ydCBDYXJ0b0RCQ2xpZW50IGZyb20gJ2NhcnRvZGItY2xpZW50JztcblxuY29uc3QgY2FydG9EQkNsaWVudCA9IG5ldyBDYXJ0b0RCQ2xpZW50KGNvbmZpZy51c2VySWQpO1xuXG5jb25zdCBDYXJ0b0RCTG9hZGVyID0ge1xuXHRcblx0LyoqIFVzZSBgcXVldWUtYXN5bmNgIHRvIGRlZmVyKCkgdXAgYW4gYXJyYXkgb2YgcXVlcmllcyxcblx0ICogYW5kIHJldHVybiBhIFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cblx0ICogQWNjZXB0cyBhIGxpc3Qgb2Ygb2JqZWN0cyBmb3JtYXR0ZWQgYXMgeyBxdWVyeSwgZm9ybWF0IH0uXG5cdCAqL1xuXHRxdWVyeTogZnVuY3Rpb24gKHF1ZXJ5Q29uZmlncykge1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuXHRcdFx0Ly8gUnVuIHVwIHRvIDMgcmVxdWVzdHMgaW4gcGFyYWxsZWxcblx0XHRcdGxldCBxdWV1ZSA9IFF1ZXVlKDMpO1xuXHRcdFx0cXVlcnlDb25maWdzLmZvckVhY2goKHF1ZXJ5Q29uZmlnKSA9PiB7XG5cdFx0XHRcdHF1ZXVlLmRlZmVyKHRoaXMucmVxdWVzdCwgcXVlcnlDb25maWcpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHF1ZXVlLmF3YWl0QWxsKChlcnJvciwgLi4ucmVzcG9uc2VzKSA9PiB7XG5cdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZSguLi5yZXNwb25zZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdH0pO1xuXG5cdH0sXG5cblx0cmVxdWVzdDogZnVuY3Rpb24gKHF1ZXJ5Q29uZmlnLCBjYWxsYmFjaykge1xuXG5cdFx0Y2FydG9EQkNsaWVudC5zcWxSZXF1ZXN0KHF1ZXJ5Q29uZmlnLnF1ZXJ5LCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG5cdFx0XHRpZiAoIWVycikge1xuXHRcdFx0XHRsZXQgaW5uZXJSZXNwb25zZTtcblx0XHRcdFx0c3dpdGNoIChxdWVyeUNvbmZpZy5mb3JtYXQudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdGNhc2UgJ2dlb2pzb24nOlxuXHRcdFx0XHRcdFx0aW5uZXJSZXNwb25zZSA9IHJlc3BvbnNlLmZlYXR1cmVzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlubmVyUmVzcG9uc2UgPSByZXNwb25zZS5yb3dzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgaW5uZXJSZXNwb25zZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdCdmb3JtYXQnOiBxdWVyeUNvbmZpZy5mb3JtYXQsXG5cdFx0XHQnZGFuZ2Vyb3VzbHlFeHBvc2VkQVBJS2V5JzogY29uZmlnLmFwaUtleVxuXHRcdH0pO1xuXG5cdH1cblx0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYXJ0b0RCTG9hZGVyO1xuIl19
