(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/cartodb/basemaps.json":[function(require,module,exports){
module.exports={"name":"PanoramaBasemap","version":"0.0.1","layergroup":{"version":"1.3.0","layers":[{"type":"mapnik","options":{"sql":"SELECT cartodb_id, city, ST_Transform(ST_SetSRID(st_makepoint(looplng,looplat),4326), 3857) as the_geom_webmercator FROM holc_ads\n","cartocss":"#holc_ads::labels {\n  text-name: [city];\n  text-face-name: 'DejaVu Sans Book';\n  text-size: 10;\n  text-label-position-tolerance: 0;\n  text-fill: #0F3B82;\n  text-halo-fill: #FFF;\n  text-halo-radius: 1;\n  text-dy: -10;\n  text-allow-overlap: false;\n  text-placement: point;\n  text-placement-type: dummy;\n}","cartocss_version":"2.1.1"}}],"minzoom":2,"maxzoom":9}}

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/cartodb/config.json":[function(require,module,exports){
module.exports={
	"userId": "digitalscholarshiplab",
	"apiKey": ""
}

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/tileLayers.json":[function(require,module,exports){
module.exports={
	"layers": [
		{
			"urlNoLabels": "http://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png",
			"urlLabels": "http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
		}
	]
}

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/data/formsMetadata.json":[function(require,module,exports){
module.exports={
	"19370203": {
		"1": [
			"Name of City",
			"Security Grade",
			"Area No"
		],
		"2": "Description of Terrain",
		"3": "Favorable Influences",
		"4": "Detrimental Influences",
		"5": {
			"header": "Inhabitants",
			"subcats": {
				"a": "Type",
				"b": "Estimated annual family income",
				"c": "Foreign-born",
				"d": "Negro",
				"e": "Infiltration of",
				"f": "Relief families",
				"g": "Population is"
			}
		},
		"6": {
			"header": "Buildings",
			"subcats": {
				"a": "Type or Types",
				"b": "Type of Construction",
				"c": "Average age",
				"d": "Repair"
			}
		},
		"8": {
			"header": "Occupancy",
			"subcats": {
				"a": "Land",
				"b": "Dwelling units",
				"c": "Home Owners"
			}
		},
		"9": {
			"header": "Sales Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"10": {
			"header": "Rental Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"11": {
			"header": "New Construction",
			"subcats": {
				"a": "Types",
				"b": "Amount last year"
			}
		},
		"12": {
			"header": "Availability of Mortgage Funds",
			"subcats": {
				"a": "Home purchase",
				"b": "Home building"
			}
		},
		"13": "Trend of Desireability Next 10-15 Years",
		"14": "Clarifying Remarks",
		"15": "Information for this form was obtained from"
	},
	"19370826": {
		"1": [
			"Name of City",
			"Security Grade",
			"Area No"
		],
		"2": "Description of Terrain",
		"3": "Favorable Influences",
		"4": "Detrimental Influences",
		"5": {
			"header": "Inhabitants",
			"subcats": {
				"a": "Type",
				"b": "Estimated annual family income",
				"c": "Foreign-born",
				"d": "Negro",
				"e": "Infiltration of",
				"f": "Relief families",
				"g": "Population is"
			}
		},
		"6": {
			"header": "Buildings",
			"subcats": {
				"a": "Type or Types",
				"b": "Type of Construction",
				"c": "Average age",
				"d": "Repair"
			}
		},
		"8": {
			"header": "Occupancy",
			"subcats": {
				"a": "Land",
				"b": "Dwelling units",
				"c": "Home Owners"
			}
		},
		"9": {
			"header": "Sales Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"10": {
			"header": "Rental Demand",
			"subcats": {
				"a": "",
				"b": "",
				"c": "Activity is"
			}
		},
		"11": {
			"header": "New Construction",
			"subcats": {
				"a": "Types",
				"b": "Amount last year"
			}
		},
		"12": {
			"header": "Availability of Mortgage Funds",
			"subcats": {
				"a": "Home purchase",
				"b": "Home building"
			}
		},
		"13": "Trend of Desireability Next 10-15 Years",
		"14": "Clarifying Remarks",
		"15": "Information for this form was obtained from"
	},
	"19371001": {
		"1": {
			"header": "Area Characteristics",
			"subcats": {
				"a": "Description of Terrain",
				"b": "Favorable Influences",
				"c": "Detrimental Influences",
				"d": "Percentage of land improved",
				"e": "Trend of desireability next 10-15 yrs."
			}
		},
		"2": {
			"header": "Inhabitants",
			"subcats": {
				"a": "Occupation",
				"b": "Estimated Annual Family Income",
				"c": "Foreign-born families",
				"d": "Negro",
				"e": "Infiltration of",
				"f": "Relief families",
				"g": "Population is"
			}
		},
		"4": {
			"header": "Availability of Mortgage Funds",
			"subcats": {
				"a": "Home purchase",
				"b": "Home building"
			}
		},
		"5": "Clarifying Remarks",
		"6": [
			"Name and Location",
			"Security Grade",
			"Area No."
		],
	}

}
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/data/panorama_nav.json":[function(require,module,exports){
module.exports=[
	{
		"title"         : "The Forced Migration of Enslaved People",
		"url"           : "http://dsl.richmond.edu/panorama/forcedmigration/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/forced-migration-img.png",
		"start_year"    : 1810,
		"end_year"      : 1860,
		"tags"          : []
	},
	{
		"title"         : "The Overland Trails",
		"url"           : "http://dsl.richmond.edu/panorama/overlandtrails/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/overland-img.png",
		"start_year"    : 1840,
		"end_year"      : 1860,
		"tags"          : []
	},
	{
		"title"         : "Foreign-Born Population",
		"url"           : "http://dsl.richmond.edu/panorama/foreignborn/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/foreign-born-img.png",
		"start_year"    : 1850,
		"end_year"      : 2010,
		"tags"          : []
	},
	{
		"title"         : "Canals",
		"url"           : "http://dsl.richmond.edu/panorama/canals/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/canal-img.png",
		"start_year"    : 1800,
		"end_year"      : 1860,
		"tags"          : []
	},
	{
		"title"         : "Mapping Inequality",
		"url"           : "http://dsl.richmond.edu/panorama/holc/",
		"screenshot"    : "http://dsl.richmond.edu/panorama/static/images/holc-img.png",
		"start_year"    : 1800,
		"end_year"      : 1860,
		"tags"          : []
	}
]
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/data/state_abbr.json":[function(require,module,exports){
module.exports={
    "AL": "Alabama",
    "AK": "Alaska",
    "AS": "American Samoa",
    "AZ": "Arizona",
    "AR": "Arkansas",
    "CA": "California",
    "CO": "Colorado",
    "CT": "Connecticut",
    "DE": "Delaware",
    "DC": "District Of Columbia",
    "FM": "Federated States Of Micronesia",
    "FL": "Florida",
    "GA": "Georgia",
    "GU": "Guam",
    "HI": "Hawaii",
    "ID": "Idaho",
    "IL": "Illinois",
    "IN": "Indiana",
    "IA": "Iowa",
    "KS": "Kansas",
    "KY": "Kentucky",
    "LA": "Louisiana",
    "ME": "Maine",
    "MH": "Marshall Islands",
    "MD": "Maryland",
    "MA": "Massachusetts",
    "MI": "Michigan",
    "MN": "Minnesota",
    "MS": "Mississippi",
    "MO": "Missouri",
    "MT": "Montana",
    "NE": "Nebraska",
    "NV": "Nevada",
    "NH": "New Hampshire",
    "NJ": "New Jersey",
    "NM": "New Mexico",
    "NY": "New York",
    "NC": "North Carolina",
    "ND": "North Dakota",
    "MP": "Northern Mariana Islands",
    "OH": "Ohio",
    "OK": "Oklahoma",
    "OR": "Oregon",
    "PW": "Palau",
    "PA": "Pennsylvania",
    "PR": "Puerto Rico",
    "RI": "Rhode Island",
    "SC": "South Carolina",
    "SD": "South Dakota",
    "TN": "Tennessee",
    "TX": "Texas",
    "UT": "Utah",
    "VT": "Vermont",
    "VI": "Virgin Islands",
    "VA": "Virginia",
    "WA": "Washington",
    "WV": "West Virginia",
    "WI": "Wisconsin",
    "WY": "Wyoming"
}
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/@panorama/toolkit/dist/components.min.js":[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("react"),require("d3"),require("leaflet"),require("react-leaflet"),require("react-dom"),require("cartodb-client"),require("intro.js"),require("queue-async")):"function"==typeof define&&define.amd?define(["react","d3","leaflet","react-leaflet","react-dom","cartodb-client","intro.js","queue-async"],e):"object"==typeof exports?exports["@panorama/toolkit"]=e(require("react"),require("d3"),require("leaflet"),require("react-leaflet"),require("react-dom"),require("cartodb-client"),require("intro.js"),require("queue-async")):t["@panorama/toolkit"]=e(t.React,t.d3,t.leaflet,t["react-leaflet"],t["react-dom"],t["cartodb-client"],t["intro.js"],t["queue-async"])}(this,function(t,e,n,o,i,s,a,u){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}(function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e))switch(typeof t[e]){case"function":break;case"object":t[e]=function(e){var n=e.slice(1),r=t[e[0]];return function(t,e,o){r.apply(this,[t,e,o].concat(n))}}(t[e]);break;default:t[e]=t[t[e]]}return t}([function(t,e,n){"use strict";var r=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var o=n(45),i=r(o),s=n(72),a=r(s),u=n(73),l=r(u),c=n(74),p=r(c),f=n(46),h=r(f),d=n(81),y=r(d),v=n(75),m=r(v),g=n(76),x=r(g),b=n(78),k=r(b),_=n(79),P=r(_),T=n(80),O=r(T),w=n(84),M=r(w),E=n(85),C=r(E),S=n(87),j=r(S),A=n(89),L=r(A),I=n(90),R=r(I),D=n(31),N=n(92),F=r(N),H=n(97),U=r(H),q=n(93),W=r(q),B=n(83),z=r(B),K=n(95),G=r(K);e["default"]={AreaChart:i["default"],CartoDBLoader:a["default"],CartoDBTileLayer:l["default"],ChartSlider:p["default"],DiscreteBarChart:h["default"],Donut:y["default"],HashManager:m["default"],HorizontalDiscreteBarChart:x["default"],IntroManager:k["default"],ItemSelector:P["default"],LeafletChoropleth:O["default"],Legend:M["default"],LineChart:C["default"],MapChoropleth:j["default"],Navigation:L["default"],OffsetAreaChart:R["default"],PanoramaDispatcher:D.PanoramaDispatcher,PanoramaEventTypes:D.PanoramaEventTypes,Punchcard:F["default"],TimeBasedMarkers:U["default"],Tooltip:z["default"],ScatterPlot:W["default"],TexturalList:G["default"]},t.exports=e["default"]},function(t,e){"use strict";e["default"]=function(t){return t&&t.__esModule?t:{"default":t}},e.__esModule=!0},function(t,e){"use strict";e["default"]=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},e.__esModule=!0},function(t,e,n){"use strict";var r=n(102)["default"];e["default"]=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),r(t,o.key,o)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),e.__esModule=!0},function(t,e,n){"use strict";var r=n(103)["default"];e["default"]=function(t,e,n){for(var o=!0;o;){var i=t,s=e,a=n;o=!1,null===i&&(i=Function.prototype);var u=r(i,s);if(void 0!==u){if("value"in u)return u.value;var l=u.get;if(void 0===l)return;return l.call(a)}var c=Object.getPrototypeOf(i);if(null===c)return;t=c,e=s,n=a,o=!0,u=c=void 0}},e.__esModule=!0},function(t,e,n){"use strict";var r=n(101)["default"],o=n(105)["default"];e["default"]=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=r(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(o?o(t,e):t.__proto__=e)},e.__esModule=!0},function(e,n){e.exports=t},function(t,n){t.exports=e},function(t,e){var n=t.exports={version:"1.2.6"};"number"==typeof __e&&(__e=n)},function(t,e){var n=Object;t.exports={create:n.create,getProto:n.getPrototypeOf,isEnum:{}.propertyIsEnumerable,getDesc:n.getOwnPropertyDescriptor,setDesc:n.defineProperty,setDescs:n.defineProperties,getKeys:n.keys,getNames:n.getOwnPropertyNames,getSymbols:n.getOwnPropertySymbols,each:[].forEach}},function(t,e,n){var r=n(132)("wks"),o=n(138),i=n(12).Symbol;t.exports=function(t){return r[t]||(r[t]=i&&i[t]||(i||o)("Symbol."+t))}},function(t,e,n){"use strict";var r=n(23)["default"];e["default"]=r||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},e.__esModule=!0},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(t,e,n){"use strict";var r=n(3)["default"],o=n(2)["default"],i=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var s=n(7),a=i(s),u=n(98),l=i(u),c=function(){function t(e){o(this,t),this._props=e,this.root=null,this.mounted=!1,this.axes=[],this.tooltip=null,this.dispatch=a["default"].dispatch("mounted","updated","mouseOver","mouseOut","mouseMove","click")}return r(t,[{key:"willMount",value:function(){}},{key:"onMount",value:function(){var t=this;this.mounted||(this.addEvents(),this.root=a["default"].select(this.selector),this.svg=this.root.append("svg").classed("interactive",this.props.interactive),this.props.interactive&&this.props.tooltip&&this.svg.on("mousemove",this.dispatch.mouseMove),this.base=this.svg.append("g"),this.updateDimensions(),this.axes.forEach(function(e){return e.onMount(t.base)}),this.tooltipRef&&(this.tooltip=new l["default"](this.tooltipRef,this.props.tooltipOptions||{}),this.tooltip.relativeContainer=this.svg),this.mounted=!0,this.dispatch.mounted())}},{key:"onUpdate",value:function(){this.mounted&&(this.updateDimensions(),this._render(),this.dispatch.updated())}},{key:"onUnMount",value:function(){this.axes.forEach(function(t){return t.onUnMount()}),this.axes.length=0,this.removeEvents(),this.svg.on("move",null),this.svg.remove(),this.root=this.svg=null,this.mounted=!1,this.props=null}},{key:"addEvents",value:function(){this.dispatch.on("mounted",this.onMountedHandler.bind(this)),this.dispatch.on("updated",this.onUpdatedHandler.bind(this)),this.dispatch.on("mouseOver",this.onMouseOverHandler.bind(this)),this.dispatch.on("mouseOut",this.onMouseOutHandler.bind(this)),this.dispatch.on("click",this.onClickHandler.bind(this)),this.dispatch.on("mouseMove",this.onMouseMoveHandler.bind(this))}},{key:"removeEvents",value:function(){this.dispatch.on("mounted",null),this.dispatch.on("updated",null),this.dispatch.on("mouseOver",null),this.dispatch.on("mouseOut",null),this.dispatch.on("mouseMove",null),this.dispatch.on("click",null)}},{key:"onMountedHandler",value:function(){"function"==typeof this.props.onMountHandler&&this.props.onMountHandler()}},{key:"onUpdatedHandler",value:function(){"function"==typeof this.props.onUpdatedHandler&&this.props.onUpdatedHandler()}},{key:"onMouseOverHandler",value:function(t){this.tooltip&&this.tooltip.show(a["default"].event,t),"function"==typeof this.props.onMouseOverHandler&&this.props.onMouseOverHandler(t)}},{key:"onMouseOutHandler",value:function(t){this.tooltip&&this.tooltip.hide(),"function"==typeof this.props.onMouseOutHandler&&this.props.onMouseOutHandler(t)}},{key:"onMouseMoveHandler",value:function(){this.tooltip&&this.tooltip.setPosition(a["default"].event)}},{key:"onClickHandler",value:function(t){"function"==typeof this.props.onClickHandler&&this.props.onClickHandler(t)}},{key:"setAxis",value:function(t){"Axis"===t.toString()&&this.axes.push(t)}},{key:"updateAxis",value:function(t,e,n){this.axes[t].update(e,n)}},{key:"_render",value:function(){this.props.data&&(this.preRender(),this.axes.forEach(function(t){return t.render()}),this.render(),this.postRender())}},{key:"preRender",value:function(){}},{key:"render",value:function(){throw new Error("render function should be implemented")}},{key:"postRender",value:function(){}},{key:"updateDimensions",value:function(){var t=this,e=this.props,n=e.width,r=e.height,o=e.margin;(this.width!==n||this.height!==r)&&(this.width=n-o.left-o.right,this.height=r-o.top-o.bottom,this.svg.attr("width",n).attr("height",r),this.base.attr("transform","translate("+o.left+","+o.top+")"),this.axes.forEach(function(e){e.width=t.width,e.height=t.height}))}},{key:"selector",get:function(){return this._selector},set:function(t){this._selector=t}},{key:"props",get:function(){return this._props},set:function(t){this._props=t}},{key:"tooltipRef",set:function(t){this._tooltipRef=t},get:function(){return this._tooltipRef}}]),t}();e["default"]=c,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(32);n(163);var p=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,[{key:"componentWillMount",value:function(){if(!this.chartConstructor)throw new Error("Need to set chartConstructor");this.chart=new this.chartConstructor(this.props),this.chart.willMount()}},{key:"componentDidMount",value:function(){this.chart.selector=this.refs.chart,this.chart.tooltipRef=this.refs.tooltip,this.chart.props=this.props,this.chart.onMount()}},{key:"componentDidUpdate",value:function(){this.chart.props=this.props,this.chart.onUpdate()}},{key:"componentWillUnmount",value:function(){this.chart.onUnMount(),this.chart=null}},{key:"getClassName",value:function(){return this.props.className?" "+this.props.className:""}},{key:"render",value:function(){return l["default"].createElement("div",{className:"panorama"+this.getClassName()},l["default"].createElement("div",{ref:"chart",className:"panorama--chart-container"},this.props.tooltip&&l["default"].createElement("div",{ref:"tooltip",className:"panorama--tooltip"})))}}],[{key:"propTypes",value:c.DefaultTypes,enumerable:!0},{key:"defaultProps",value:c.DefaultProps,enumerable:!0}]),e}(u.Component);e["default"]=p,t.exports=e["default"]},function(t,e,n){var r=n(25);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,e){t.exports={}},function(t,e){function n(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}t.exports=n},function(t,e,n){"use strict";var r=n(3)["default"],o=n(2)["default"],i=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var s=n(7),a=i(s),u=n(32),l=function(){function t(e,n){o(this,t),this._options=e,this.axis=a["default"].svg.axis().scale(n),this.element=null}return r(t,[{key:"update",value:function(t,e){this.options=e,this.axis.scale(t),this.setAxisMethods()}},{key:"onMount",value:function(t){this.element=t.append("g").attr("class",this.options.className||""),this.setAxisMethods(),this.axisLabel()}},{key:"onUpdate",value:function(){}},{key:"onUnMount",value:function(){this.element&&this.element.remove(),this._options=null,this.element=null,this.axis=null}},{key:"render",value:function(){this.setPosition(),this.element.call(this.axis),this.renderTickExtras(),this.renderLabelExtras()}},{key:"renderTickExtras",value:function(){var t=this.element.selectAll("text");this.options.attr&&t.attr(this.options.attr),this.options.style&&t.style(this.options.style)}},{key:"renderLabelExtras",value:function(){if(this.label&&this.options.label){var t=this.options.label;t.attr&&this.label.attr(t.attr),t.style&&this.label.style(t.style)}}},{key:"setPosition",value:function(){var t=this.options.position;if(t)switch(t){case"bottom":this.element.attr("transform","translate(0,"+this.height+")");break;case"right":this.element.attr("transform","translate("+this.width+",0)")}}},{key:"setAxisMethods",value:function(){var t=this;u.axisMethods.forEach(function(e){t.options.hasOwnProperty(e)&&t.axis[e](t.options[e])})}},{key:"axisLabel",value:function(){this.options.label&&(this.label=this.element.append("text").text(this.options.label.text))}},{key:"toString",value:function(){return"Axis"}},{key:"options",get:function(){return this._options},set:function(t){this._options=t}},{key:"width",get:function(){return this._width},set:function(t){this._width=t}},{key:"height",get:function(){return this._height},set:function(t){this._height=t}}]),t}();e["default"]=l,t.exports=e["default"]},function(t,e,n){var r=n(34);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,o){return t.call(e,n,r,o)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){var r=n(12),o=n(8),i=n(19),s="prototype",a=function(t,e,n){var u,l,c,p=t&a.F,f=t&a.G,h=t&a.S,d=t&a.P,y=t&a.B,v=t&a.W,m=f?o:o[e]||(o[e]={}),g=f?r:h?r[e]:(r[e]||{})[s];f&&(n=e);for(u in n)l=!p&&g&&u in g,l&&u in m||(c=l?g[u]:n[u],m[u]=f&&"function"!=typeof g[u]?n[u]:y&&l?i(c,r):v&&g[u]==c?function(t){var e=function(e){return this instanceof t?new t(e):t(e)};return e[s]=t[s],e}(c):d&&"function"==typeof c?i(Function.call,c):c,d&&((m[s]||(m[s]={}))[u]=c))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,t.exports=a},function(t,e){t.exports=n},function(t,e){t.exports=o},function(t,e,n){t.exports={"default":n(110),__esModule:!0}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e,n){function r(t){return null!=t&&i(o(t))}var o=n(174),i=n(27);t.exports=r},function(t,e){function n(t){return"number"==typeof t&&t>-1&&t%1==0&&r>=t}var r=9007199254740991;t.exports=n},function(t,e){function n(t){return!!t&&"object"==typeof t}t.exports=n},function(t,e,n){var r=n(63),o=n(27),i=n(28),s="[object Array]",a=Object.prototype,u=a.toString,l=r(Array,"isArray"),c=l||function(t){return i(t)&&o(t.length)&&u.call(t)==s};t.exports=c},function(t,e){t.exports=i},function(t,e,n){"use strict";var r=n(23)["default"];Object.defineProperty(e,"__esModule",{value:!0});var o=n(70),i={Legend:{selected:"Legend:selected"},ItemSelector:{selected:"ItemSelector:selected"},ChartSlider:{selected:"ChartSlider:selected"}};e.PanoramaEventTypes=i;var s={Legend:{selected:function(t,e){s.emit(i.Legend.selected,t,e)}},ItemSelector:{selected:function(t,e){s.emit(i.ItemSelector.selected,t,e)}},ChartSlider:{selected:function(t){s.emit(i.ChartSlider.selected,t)}}};e.PanoramaDispatcher=s,r(s,o.EventEmitter.prototype)},function(t,e,n){"use strict";var r=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var o=n(6),i=n(7),s=r(i),a={width:o.PropTypes.number,height:o.PropTypes.number,margin:o.PropTypes.shape({top:o.PropTypes.number,right:o.PropTypes.number,bottom:o.PropTypes.number,left:o.PropTypes.number}),xAccessor:o.PropTypes.func,yAccessor:o.PropTypes.func,selectionAccessor:o.PropTypes.func,xScale:o.PropTypes.func,yScale:o.PropTypes.func,xaxis:o.PropTypes.object,yaxis:o.PropTypes.object,interactive:o.PropTypes.bool,tooltip:o.PropTypes.bool};e.DefaultTypes=a;var u={width:960,height:500,margin:{top:20,right:30,bottom:20,left:30},selectionAccessor:function(t){return t.key},xAccessor:function(t){return t.key},yAccessor:function(t){return t.value},xScale:s["default"].scale.linear(),yScale:s["default"].scale.linear(),interactive:!0,tooltip:!1};e.DefaultProps=u;var l=["orient","ticks","tickValues","tickSize","innerTickSize","outerTickSize","tickPadding","tickFormat"];e.axisMethods=l;var c={closeDelay:100,align:"top center",offset:[0,-10]};e.tooltipDefaultOptions=c},function(t,e){"use strict";e["default"]=function(t,e){var n={};for(var r in t)e.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n},e.__esModule=!0},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,e,n){var r=n(24),o=n(10)("toStringTag"),i="Arguments"==r(function(){return arguments}());t.exports=function(t){var e,n,s;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=(e=Object(t))[o])?n:i?r(e):"Object"==(s=r(e))&&"function"==typeof e.callee?"Arguments":s}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,e,n){t.exports=!n(38)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,e){t.exports=function(t){try{return!!t()}catch(e){return!0}}},function(t,e,n){var r=n(9),o=n(54);t.exports=n(37)?function(t,e,n){return r.setDesc(t,e,o(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(9).setDesc,o=n(49),i=n(10)("toStringTag");t.exports=function(t,e,n){t&&!o(t=n?t:t.prototype,i)&&r(t,i,{configurable:!0,value:e})}},function(t,e,n){"use strict";var r=n(135)(!0);n(51)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e,n){n(141);var r=n(16);r.NodeList=r.HTMLCollection=r.Array},function(t,e){function n(t,e){return t="number"==typeof t||r.test(t)?+t:-1,e=null==e?o:e,t>-1&&t%1==0&&e>t}var r=/^\d+$/,o=9007199254740991;t.exports=n},function(t,e,n){function r(t){return i(t)&&o(t)&&a.call(t,"callee")&&!u.call(t,"callee")}var o=n(26),i=n(28),s=Object.prototype,a=s.hasOwnProperty,u=s.propertyIsEnumerable;t.exports=r},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=u(l),p=n(6),f=n(14),h=u(f),d=n(71),y=u(d);n(148);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},h["default"].propTypes,{fillColor:p.PropTypes.oneOfType([p.PropTypes.string,p.PropTypes.number]),fillOpacity:p.PropTypes.number,interpolate:p.PropTypes.string}),enumerable:!0},{key:"defaultProps",value:a({},h["default"].defaultProps,{xScale:c["default"].scale.ordinal(),className:"area-chart",interpolate:"basis",xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(h["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=n(7),p=u(c),f=n(14),h=u(f),d=n(47),y=u(d);n(150);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},h["default"].propTypes,{barSpacing:l.PropTypes.number}),enumerable:!0},{key:"defaultProps",value:a({},h["default"].defaultProps,{barSpacing:.1,xScale:p["default"].scale.ordinal(),className:"bar-chart vertical",xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(h["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale))}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this._render()}},{key:"preRender",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale;o.rangeRoundBands([0,this.width],this.barSpacing),o.domain(e.map(function(t){return n(t)})),i.range([this.height,0]),i.domain([0,p["default"].max(e,function(t){return r(t)})]),this.updateAxis(0,o,this.props.xaxis),this.updateAxis(1,i,this.props.yaxis)}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=e.xAccessor,o=e.yAccessor,i=e.xScale,s=e.yScale,a=this.base.selectAll(".bar").data(n);a.exit().remove(),a.enter().append("rect").attr("class","bar"),a.attr("x",function(t){return i(r(t))}).attr("y",function(t){return s(o(t))}).attr("width",i.rangeBand()).attr("height",function(e){return t.height-s(o(e))})}},{key:"postRender",value:function(){var t=this.props,e=t.selected,n=t.selectionAccessor,r=t.interactive,o=this.base.selectAll(".bar");r&&o.on("click",this.dispatch.click).on("mouseover",this.dispatch.mouseOver).on("mouseout",this.dispatch.mouseOut),e&&o.classed("selected",function(t){return n(t)===e})}},{key:"barSpacing",get:function(){return this.props.barSpacing||.1}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e){"use strict";e["default"]=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e["default"]=t,e},e.__esModule=!0},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e,n){var r=n(24);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,e,n){"use strict";var r=n(52),o=n(20),i=n(55),s=n(39),a=n(49),u=n(16),l=n(124),c=n(40),p=n(9).getProto,f=n(10)("iterator"),h=!([].keys&&"next"in[].keys()),d="@@iterator",y="keys",v="values",m=function(){return this};t.exports=function(t,e,n,g,x,b,k){l(n,e,g);var _,P,T=function(t){if(!h&&t in E)return E[t];switch(t){case y:return function(){return new n(this,t)};case v:return function(){return new n(this,t)}}return function(){return new n(this,t)}},O=e+" Iterator",w=x==v,M=!1,E=t.prototype,C=E[f]||E[d]||x&&E[x],S=C||T(x);if(C){var j=p(S.call(new t));c(j,O,!0),!r&&a(E,d)&&s(j,f,m),w&&C.name!==v&&(M=!0,S=function(){return C.call(this)})}if(r&&!k||!h&&!M&&E[f]||s(E,f,S),u[e]=S,u[O]=m,x)if(_={values:w?S:T(v),keys:b?S:T(y),entries:w?T("entries"):S},k)for(P in _)P in E||i(E,P,_[P]);else o(o.P+o.F*(h||M),e,_);return _}},function(t,e){t.exports=!0},function(t,e,n){var r=n(20),o=n(8),i=n(38);t.exports=function(t,e){var n=(o.Object||{})[t]||Object[t],s={};s[t]=e(n),r(r.S+r.F*i(function(){n(1)}),"Object",s)}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e,n){t.exports=n(39)},function(t,e,n){var r=n(9).getDesc,o=n(25),i=n(15),s=function(t,e){if(i(t),!o(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,e,o){try{o=n(19)(Function.call,r(Object.prototype,"__proto__").set,2),o(t,[]),e=!(t instanceof Array)}catch(i){e=!0}return function(t,n){return s(t,n),e?t.__proto__=n:o(t,n),t}}({},!1):void 0),check:s}},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e,n){var r=n(50),o=n(36);t.exports=function(t){return r(o(t))}},function(t,e,n){var r=n(36);t.exports=function(t){return Object(r(t))}},function(t,e,n){var r=n(35),o=n(10)("iterator"),i=n(16);t.exports=n(8).getIteratorMethod=function(t){return void 0!=t?t[o]||t["@@iterator"]||i[r(t)]:void 0}},function(t,e){function n(t,e){if("function"!=typeof t)throw new TypeError(r);return e=o(void 0===e?t.length-1:+e||0,0),function(){for(var n=arguments,r=-1,i=o(n.length-e,0),s=Array(i);++r<i;)s[r]=n[e+r];switch(e){case 0:return t.call(this,s);case 1:return t.call(this,n[0],s);case 2:return t.call(this,n[0],n[1],s)}var a=Array(e+1);for(r=-1;++r<e;)a[r]=n[r];return a[e]=s,t.apply(this,a)}}var r="Expected a function",o=Math.max;t.exports=n},function(t,e,n){function r(t,e,n){if("function"!=typeof t)return o;if(void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 3:return function(n,r,o){return t.call(e,n,r,o)};case 4:return function(n,r,o,i){return t.call(e,n,r,o,i)};case 5:return function(n,r,o,i,s){return t.call(e,n,r,o,i,s)}}return function(){return t.apply(e,arguments)}}var o=n(182);t.exports=r},function(t,e,n){function r(t,e){var n=null==t?void 0:t[e];return o(n)?n:void 0}var o=n(180);t.exports=r},function(t,e,n){function r(t){return o(t)?t:Object(t)}var o=n(17);t.exports=r},function(t,e,n){var r=n(165),o=n(166),i=n(172),s=i(function(t,e,n){return n?r(t,e,n):o(t,e)});t.exports=s},function(t,e,n){var r=n(63),o=n(26),i=n(17),s=n(178),a=r(Object,"keys"),u=a?function(t){var e=null==t?void 0:t.constructor;return"function"==typeof e&&e.prototype===t||"function"!=typeof t&&o(t)?s(t):i(t)?a(t):[]}:s;t.exports=u},function(t,e,n){function r(t){if(null==t)return[];u(t)||(t=Object(t));var e=t.length;e=e&&a(e)&&(i(t)||o(t))&&e||0;for(var n=t.constructor,r=-1,l="function"==typeof n&&n.prototype===t,p=Array(e),f=e>0;++r<e;)p[r]=r+"";for(var h in t)f&&s(h,e)||"constructor"==h&&(l||!c.call(t,h))||p.push(h);return p}var o=n(44),i=n(29),s=n(43),a=n(27),u=n(17),l=Object.prototype,c=l.hasOwnProperty;t.exports=r},function(t,e){function n(t,e){var n=t.nodeName.toLowerCase();return(/input|select|textarea|button|object/.test(n)?!t.disabled:"a"===n?t.href||e:e)&&o(t)}function r(t){return t.offsetWidth<=0&&t.offsetHeight<=0||"none"===t.style.display}function o(t){for(;t&&t!==document.body;){if(r(t))return!1;t=t.parentNode}return!0}function i(t){var e=t.getAttribute("tabindex");null===e&&(e=void 0);var r=isNaN(e);return(r||e>=0)&&n(t,!r)}function s(t){return[].slice.call(t.querySelectorAll("*"),0).filter(function(t){return i(t)})}t.exports=s},function(t,e,n){function r(t){return function(e){return null==e?void 0:e[t]}}function o(t){return null!=t&&s(g(t))}function i(t,e){return t="number"==typeof t||h.test(t)?+t:-1,e=null==e?m:e,t>-1&&t%1==0&&e>t}function s(t){return"number"==typeof t&&t>-1&&t%1==0&&m>=t}function a(t){for(var e=l(t),n=e.length,r=n&&t.length,o=!!r&&s(r)&&(f(t)||p(t)),a=-1,u=[];++a<n;){var c=e[a];(o&&i(c,r)||y.call(t,c))&&u.push(c)}return u}function u(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function l(t){if(null==t)return[];u(t)||(t=Object(t));var e=t.length;e=e&&s(e)&&(f(t)||p(t))&&e||0;for(var n=t.constructor,r=-1,o="function"==typeof n&&n.prototype===t,a=Array(e),l=e>0;++r<e;)a[r]=r+"";for(var c in t)l&&i(c,e)||"constructor"==c&&(o||!y.call(t,c))||a.push(c);return a}var c=n(198),p=n(199),f=n(200),h=/^\d+$/,d=Object.prototype,y=d.hasOwnProperty,v=c(Object,"keys"),m=9007199254740991,g=r("length"),x=v?function(t){var e=null==t?void 0:t.constructor;return"function"==typeof e&&e.prototype===t||"function"!=typeof t&&o(t)?a(t):u(t)?v(t):[]}:a;t.exports=x},function(t,e){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function r(t){return"function"==typeof t}function o(t){return"number"==typeof t}function i(t){return"object"==typeof t&&null!==t}function s(t){return void 0===t}t.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(t){if(!o(t)||0>t||isNaN(t))throw TypeError("n must be a positive number");return this._maxListeners=t,this},n.prototype.emit=function(t){var e,n,o,a,u,l;if(this._events||(this._events={}),"error"===t&&(!this._events.error||i(this._events.error)&&!this._events.error.length)){if(e=arguments[1],e instanceof Error)throw e;throw TypeError('Uncaught, unspecified "error" event.')}if(n=this._events[t],s(n))return!1;if(r(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),n.apply(this,a)}else if(i(n))for(a=Array.prototype.slice.call(arguments,1),l=n.slice(),o=l.length,u=0;o>u;u++)l[u].apply(this,a);return!0},n.prototype.addListener=function(t,e){var o;if(!r(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",t,r(e.listener)?e.listener:e),this._events[t]?i(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,i(this._events[t])&&!this._events[t].warned&&(o=s(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,o&&o>0&&this._events[t].length>o&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),"function"==typeof console.trace&&console.trace())),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(t,e){function n(){this.removeListener(t,n),o||(o=!0,e.apply(this,arguments))}if(!r(e))throw TypeError("listener must be a function");var o=!1;return n.listener=e,this.on(t,n),this},n.prototype.removeListener=function(t,e){var n,o,s,a;if(!r(e))throw TypeError("listener must be a function");if(!this._events||!this._events[t])return this;if(n=this._events[t],s=n.length,o=-1,n===e||r(n.listener)&&n.listener===e)delete this._events[t],this._events.removeListener&&this.emit("removeListener",t,e);else if(i(n)){for(a=s;a-- >0;)if(n[a]===e||n[a].listener&&n[a].listener===e){o=a;break}if(0>o)return this;1===n.length?(n.length=0,delete this._events[t]):n.splice(o,1),this._events.removeListener&&this.emit("removeListener",t,e)}return this},n.prototype.removeAllListeners=function(t){var e,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(n=this._events[t],r(n))this.removeListener(t,n);else if(n)for(;n.length;)this.removeListener(t,n[n.length-1]);return delete this._events[t],this},n.prototype.listeners=function(t){var e;return e=this._events&&this._events[t]?r(this._events[t])?[this._events[t]]:this._events[t].slice():[]},n.prototype.listenerCount=function(t){if(this._events){var e=this._events[t];if(r(e))return 1;if(e)return e.length}return 0},n.listenerCount=function(t,e){return t.listenerCount(e)}},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){var t=this.props,e=t.xAccessor,n=t.yAccessor,r=t.xScale,o=t.yScale,i=t.interpolate;this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale)),this.points=[],this.areaGenerator=p["default"].svg.area().interpolate(i).x(function(t){return r(e(t))}).y0(function(t){return o(0)}).y1(function(t){return o(n(t))})}},{key:"onMount",value:function(){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this),this.baseLayer=this.base.append("g").classed("area-layer",!0),this._render()}},{key:"getClosestDataIndex",value:function(t){if(!this.points.length)return null;var e=this.props;e.data,e.xAccessor;return this.points.forEach(function(e){e.d=Math.abs(e.x-t)}),this.points.sort(function(t,e){return p["default"].ascending(t.d,e.d)}),this.points[0].i}},{key:"onMouseMoveHandler",value:function(){if(this.hover&&this.tooltip){var t=p["default"].mouse(this.baseLayer.node()),e=(this.props.xScale.invert(t[0]),this.getClosestDataIndex(t[0]));this.tooltip.setPosition(p["default"].event),null!==e&&this.tooltip.setContent(this.props.data[0][e])}}},{key:"preRender",value:function(){var t=this,e=this.props,n=e.data,r=e.xScale,o=e.yScale,i=e.interpolate,s=e.xAccessor,a=e.yAccessor;r.range([0,this.width]),o.range([this.height,0]),
this.updateAxis(0,r,this.props.xaxis),this.updateAxis(1,o,this.props.yaxis),this.areaGenerator.interpolate(i).x(function(t){return r(s(t))}).y0(function(t){return o(0)}).y1(function(t){return o(a(t))}),this.points=[],n.length&&n[0].forEach(function(e,n){var o=r(s(e));t.points.push({x:o,i:n})})}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=(e.xAccessor,e.yAccessor,e.xScale,e.yScale,e.fillColor),o=e.fillOpacity,i=this.baseLayer.selectAll("path.area").data(n);i.exit().remove(),i.enter().append("path").attr("class","area"),i.attr("d",function(e){return t.areaGenerator(e)}).style("fill",r).style("opacity",o)}},{key:"postRender",value:function(){this.props.interactive&&this.baseLayer.selectAll("path.area").on("mouseover",this.onOver.bind(this)).on("mouseout",this.onOut.bind(this))}},{key:"onOver",value:function(){this.hover=!0,this.tooltip&&this.tooltip.show()}},{key:"onOut",value:function(){this.hover=!1,this.tooltip&&this.tooltip.hide()}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";function r(t,e){function n(t){return new o(function(e,n){var o=(0,a["default"])(3);t.forEach(function(t){o.defer(r,t)}),o.awaitAll(function(t){for(var r=arguments.length,o=Array(r>1?r-1:0),i=1;r>i;i++)o[i-1]=arguments[i];t?n(t):e.apply(void 0,o)})})}function r(t,n){i.sqlRequest(t.query,function(e,r){if(e)n(e);else{var o=void 0;switch(t.format.toLowerCase()){case"geojson":o=r.features;break;default:o=r.rows}n(null,o)}},{format:t.format,dangerouslyExposedAPIKey:e})}var i=new l["default"](t);return{query:n}}var o=n(106)["default"],i=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0}),e["default"]=r;var s=n(203),a=i(s),u=n(201),l=i(u);t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"];Object.defineProperty(e,"__esModule",{value:!0});var a=n(6),u=n(21),l=n(22),c=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"componentWillMount",value:function(){if(r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this),!cartodb)throw new Error('CartoDBTileLayer requires `cartodb`. `cartodb` is not currently available as an npm package and therefore must be loaded as a global, e.g. via a CDN script in your index.html, such as <script src="http://libs.cartocdn.com/cartodb.js/v3/3.15/cartodb.core.js">');this.leafletElement=(0,u.tileLayer)("",this.props),this._getCartoDBTilesTemplates(function(t,e){t?console.error(t):this.leafletElement.setUrl(e.tiles[0])}.bind(this))}},{key:"_getCartoDBTilesTemplates",value:function(t){cartodb.Tiles.getTiles({type:"cartodb",user_name:this.props.userId,sublayers:[{sql:this.props.sql,cartocss:this.props.cartocss}]},function(e,n){!e||n?(n||(n="Empty response."),t(n,e)):t(null,e)})}}],[{key:"propTypes",value:{userId:a.PropTypes.string,sql:a.PropTypes.string,cartocss:a.PropTypes.string},enumerable:!0}]),e}(l.BaseTileLayer);e["default"]=c,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(30),p=a(c),f=n(7),h=a(f);n(149);var d=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{width:u.PropTypes.number,height:u.PropTypes.number,scale:u.PropTypes.func,orient:u.PropTypes.string,margin:u.PropTypes.shape({top:u.PropTypes.number,right:u.PropTypes.number,bottom:u.PropTypes.number,left:u.PropTypes.number}),children:l["default"].PropTypes.node,selectedValue:u.PropTypes.number,onClickOrMove:u.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{scale:h["default"].scale.linear().clamp(!0),orient:"bottom",margin:{top:20,right:30,bottom:20,left:30},onClickOrMove:null},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){y.create(this.refs.axis,this.props.scale,this.props.orient,this.props.margin,this.props.onClickOrMove);try{this.containerNode=p["default"].findDOMNode(this)}catch(t){}this.forceUpdate()}},{key:"componentDidUpdate",value:function(){y.update(this.refs.axis,this.props.scale,this.props.orient,this.props.margin,this.props.selectedValue,this.props.onClickOrMove);try{this.containerNode=p["default"].findDOMNode(this)}catch(t){}}},{key:"componentWillUnmount",value:function(){y.destroy(this.refs.axis)}},{key:"render",value:function(){var t=u.Children.count(this.props.children);return t>1&&console.warn("ChartSlider is designed to wrap only one child component, but it found "+t+" children."),l["default"].createElement("div",{className:"panorama chart-slider"},l["default"].cloneElement(this.props.children,{width:this.containerNode?this.containerNode.offsetWidth:this.props.width,height:this.props.height}),l["default"].createElement("div",{className:"top-rule",style:{marginLeft:this.props.margin.left+"px",marginRight:this.props.margin.right+"px",width:"calc(100% - "+(this.props.margin.left+this.props.margin.right)+"px)"}}),l["default"].createElement("div",{className:"d3-chart-slider",ref:"axis"}))}}]),e}(l["default"].Component);e["default"]=d;var y={create:function(t,e,n,r,o){this.onBrushMoved=this.onBrushMoved.bind(this),this.node=t;var i=13;this.axisPrimary=h["default"].svg.axis().orient(n).ticks(5).tickFormat(String).tickSize(i),this.axisSecondary=h["default"].svg.axis().orient(n).ticks(10).tickFormat(function(t){return""}).tickSize(i-3),this.axisTertiary=h["default"].svg.axis().orient(n).ticks(40).tickFormat(function(t){return""}).tickSize(i-6),this.brush=h["default"].svg.brush().on("brush",this.onBrushMoved);var s=h["default"].select(t).append("svg");s.append("g").attr("class","axis tertiary"),s.append("g").attr("class","axis secondary"),s.append("g").attr("class","axis primary"),this.handle=s.append("g").attr("class","handle");var a=t.offsetHeight-r.bottom+i+3,u=this.handle.append("g").attr("class","handle-elements");u.append("line").attr({x1:0,x2:0,y1:0,y2:a});var l=10;u.append("path").attr("d","M 30 0 L 70 0 C 85 0 93.29179606750063 13.416407864998739 86.58359213500125 26.832815729997478 L 63.41640786499873 73.16718427000252 C 56.708203932499366 86.58359213500125 43.29179606750063 86.58359213500125 36.58359213500126 73.16718427000252 L 13.416407864998739 26.832815729997478 C 6.708203932499369 13.416407864998739 15 0 30 0 Z ").attr("transform","scale("+l/100+") translate(-50, 0)"),u.append("path").attr("d","M 30 0 L 70 0 C 85 0 93.29179606750063 13.416407864998739 86.58359213500125 26.832815729997478 L 63.41640786499873 73.16718427000252 C 56.708203932499366 86.58359213500125 43.29179606750063 86.58359213500125 36.58359213500126 73.16718427000252 L 13.416407864998739 26.832815729997478 C 6.708203932499369 13.416407864998739 15 0 30 0 Z ").attr("transform","rotate(180) scale("+l/100+") translate(-50, "+-(100/l*a)+")"),this.update(t,e,n,r)},update:function(t,e,n,r,o,i){this.node=t,this.onClickOrMove=i,e.range([0,t.offsetWidth-r.left-r.right]),this.axisPrimary.scale(e),this.axisSecondary.scale(e),this.axisTertiary.scale(e),this.brush.x(e);var s="translate("+r.left+", "+(t.offsetHeight-r.bottom)+")",a=h["default"].select(t).select("svg");a.attr("width","100%").attr("height","100%"),a.select(".axis.primary").call(this.axisPrimary).attr("transform",s).selectAll("text").attr("y",Math.floor(2/3*r.bottom)),a.select(".axis.secondary").call(this.axisSecondary).attr("transform",s),a.select(".axis.tertiary").call(this.axisTertiary).attr("transform",s),this.handle.call(this.brush).attr("transform","translate("+r.left+", 0)").select(".background").on("mousedown.brush",this.onBrushMoved).on("touchstart.brush",this.onBrushMoved),this.handle.selectAll(".background").attr("height","100%"),"undefined"!=typeof o&&this.onSelectedValueChanged(o)},destroy:function(t){h["default"].select(t).html(""),this.node=null,this.axisPrimary=null,this.axisSecondary=null,this.axisTertiary=null,this.brush=null,this.handle=null},onBrushMoved:function(){var t=this.brush.x(),e=t.domain(),n=h["default"].mouse(h["default"].select(this.node).select(".axis")[0][0])[0],r=t.invert(n);r=Math.round(Math.max(e[0],Math.min(e[1],r))),this.onClickOrMove&&this.onClickOrMove(r)},onSelectedValueChanged:function(t){this.handle.call(this.brush.extent([t,t+2]));var e=this.brush.x()(t);this.handle.select(".handle-elements").attr("transform","translate("+e+", 0)")}};t.exports=e["default"]},function(t,e,n){"use strict";var r=n(23)["default"],o=n(104)["default"];Object.defineProperty(e,"__esModule",{value:!0});var i=n(70),s=function(){function t(t){var e=r({},h,t);for(var n in e)null==e[n]?delete e[n]:n===p&&(e[n]=l(e[p]));var i="#"+o(e).map(function(t){return t+"="+e[t]}).join("&");document.location.hash!==i&&document.location.replace(i)}function e(){var t=arguments.length<=0||void 0===arguments[0]?null:arguments[0];return t?h[t]:r({},h)}function n(t,e){h=t,e||f.emit(c,r({},h))}function s(){n(a(window.location.hash))}function a(t){var e=t.replace(/^#\/?|\/$/g,"").split("&").reduce(function(t,e){return e=e.split("="),e[0]===p&&(e[1]=u(e[1])),t[e[0]]=e[1],t},{});return e}function u(t){if(t=t.split("/"),3==t.length){var e=parseInt(t[0],10),n=parseFloat(t[1]),r=parseFloat(t[2]);return isNaN(e)||isNaN(n)||isNaN(r)?!1:{center:[n,r],zoom:e}}return!1}function l(t){var e=void 0,n=void 0,r=t.zoom,o=Math.max(0,Math.ceil(Math.log(r)/Math.LN2));return Array.isArray(t.center)?(e=t.center[0],n=t.center[1]):(e=t.center.lat,n=t.center.lng),[r,e.toFixed(o),n.toFixed(o)].join("/")}var c="hashChanged",p="loc",f={},h={};return r(f,i.EventEmitter.prototype),window.addEventListener("hashchange",s),n(a(window.location.hash),!0),f.EVENT_HASH_CHANGED=c,f.MAP_STATE_KEY=p,f.updateHash=t,f.getState=e,f}();e["default"]=s,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=u(l),p=n(46),f=u(p),h=n(77),d=u(h),y=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=d["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{xScale:c["default"].scale.linear(),yScale:c["default"].scale.ordinal()}),enumerable:!0}]),e}(f["default"]);e["default"]=y,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(7),l=a(u),c=n(47),p=a(c),f=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"preRender",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale;i.rangeRoundBands([0,this.height],this.barSpacing),i.domain(e.map(function(t){return r(t)})),o.range([0,this.width]),o.domain([0,l["default"].max(e,function(t){return n(t)})]),this.updateAxis(0,o,this.props.xaxis),this.updateAxis(1,i,this.props.yaxis)}},{key:"render",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale,s=this.base.selectAll(".bar").data(e);s.exit().remove(),s.enter().append("rect").attr("class","bar"),s.attr("x","0").attr("y",function(t){return i(r(t))}).attr("width",function(t){return o(n(t))}).attr("height",i.rangeBand())}}]),e}(p["default"]);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(23)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(202),c=n(6),p=u(c);n(151);var f=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.onIntroExit=this.onIntroExit.bind(this),this.initIntro()}return o(e,t),i(e,null,[{key:"propTypes",value:{open:c.PropTypes.bool,step:c.PropTypes.oneOfType([c.PropTypes.number,c.PropTypes.string]),steps:c.PropTypes.arrayOf(c.PropTypes.shape({element:c.PropTypes.string,intro:c.PropTypes.string,position:function(t,e,n){return/top|right|bottom|left/.test(t[e])?void 0:new Error("`position` must be one of 'top', 'right', 'bottom', or 'left'.")}})).isRequired,config:c.PropTypes.object,onExit:c.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{open:!1,step:0,steps:[],config:{showStepNumbers:!1,skipLabel:"×",nextLabel:"⟩",prevLabel:"⟨",doneLabel:"×"},onExit:null},enumerable:!0}]),i(e,[{key:"initIntro",value:function(){this.intro=(0,l.introJs)(document.querySelector("body")),this.intro.onexit(this.onIntroExit),this.intro.oncomplete(this.onIntroExit),this.introIsOpen=!1}},{key:"onIntroExit",value:function(){this.introIsOpen=!1,this.props.onExit&&this.props.onExit()}},{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){if(this.props.open){if(this.introIsOpen)return;if(this.intro._introItems)this.props.step&&1!==this.props.step?this.intro.goToStep(this.props.step-1).start():this.intro.start();else{var t={steps:this.props.steps};t=a(t,this.props.config),this.intro.setOptions(t),this.intro.goToStep(this.props.step).start()}this.introIsOpen=!0}else this.intro.exit()}},{key:"getDefaultState",value:function(){return{}}},{key:"render",value:function(){return p["default"].createElement("div",{className:"panorama intro-manager"})}}]),e}(p["default"].Component);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(31);n(152);var p=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.onItemClick=this.onItemClick.bind(this),this.onArrowMouseDown=this.onArrowMouseDown.bind(this),this.onArrowMouseUp=this.onArrowMouseUp.bind(this),this.animateScrollPosition=this.animateScrollPosition.bind(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{title:u.PropTypes.string,items:u.PropTypes.array.isRequired,selectedIndex:u.PropTypes.oneOfType([u.PropTypes.string,u.PropTypes.number]),selectedItem:u.PropTypes.object,onItemSelected:u.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{title:"",items:[],selectedIndex:"",selectedItem:null,onItemSelected:null},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){this.scrollToSelectedItem()}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){this.scrollToSelectedItem()}},{key:"onItemClick",value:function(t){t.currentTarget&&t.currentTarget.dataset&&(this.props.onItemSelected&&this.props.onItemSelected(this.props.items[t.currentTarget.dataset.index],t.currentTarget.dataset.index),c.PanoramaDispatcher.ItemSelector.selected(this.props.items[t.currentTarget.dataset.index],t.currentTarget.dataset.index))}},{key:"onArrowMouseDown",value:function(t){var e=void 0;if(t.target.classList.contains("up-arrow")?e=-1:t.target.classList.contains("down-arrow")&&(e=1),e){var n=this.refs["item-list"],r=16,o=0,i=n.querySelector("li"),s=window.getComputedStyle(i),a=i.offsetHeight+(s?parseFloat(s["margin-bottom"].replace("px","")):0);this.arrowMouseUp=!1;var u=function(){o--<=1&&(this.scrollToPosition(n.scrollTop+e*a),o=r=Math.max(1,Math.floor(.75*r))),this.arrowMouseUp||window.requestAnimationFrame(u)}.bind(this);window.requestAnimationFrame(u)}}},{key:"onArrowMouseUp",value:function(t){this.arrowMouseUp=!0}},{key:"scrollToPosition",value:function(t){"undefined"==typeof this.targetScrollPosition?(this.targetScrollPosition=t,this.animateScrollPosition()):this.targetScrollPosition=t}},{key:"scrollToSelectedItem",value:function(){var t=this.refs["item-list"],e=t.querySelector(".selected");e&&this.scrollToPosition(e.offsetTop-t.offsetHeight)}},{key:"animateScrollPosition",value:function(){var t=this.refs["item-list"],e=void 0;"undefined"==typeof this.scrollPosition&&(this.scrollPosition=t.scrollTop),e=this.targetScrollPosition-this.scrollPosition,Math.abs(e)>1?(this.scrollPosition+=.25*e,t.scrollTop=this.scrollPosition,window.requestAnimationFrame(this.animateScrollPosition)):(t.scrollTop=this.targetScrollPosition,this.targetScrollPosition=void 0,this.scrollPosition=void 0)}},{key:"getDefaultState",value:function(){return{}}},{key:"render",value:function(){var t=this,e=void 0;return l["default"].createElement("div",{className:"panorama item-selector"},l["default"].createElement("h3",null,this.props.title),l["default"].createElement("div",{className:"scroll-arrow up-arrow",onMouseDown:this.onArrowMouseDown,onMouseUp:this.onArrowMouseUp}),l["default"].createElement("ul",{ref:"item-list"},this.props.items.map(function(n,r){return e=t.props.selectedItem.id==n.id||t.props.selectedItem===n||t.props.selectedIndex===r,l["default"].createElement("li",{className:"item"+(e?" selected":"")+(n.className?" "+n.className:""),"data-index":r,key:r,onClick:t.onItemClick},l["default"].createElement("span",null,n.name))})),l["default"].createElement("div",{className:"scroll-arrow down-arrow",onMouseDown:this.onArrowMouseDown,onMouseUp:this.onArrowMouseUp}))}}]),e}(l["default"].Component);e["default"]=p,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(33)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=(u(l),n(22)),p=n(21),f=n(181),h=u(f),d=n(17),y=(u(d),n(29)),v=(u(y),n(65)),m=(u(v),["stroke","color","weight","opacity","fill","fillColor","fillOpacity","fillRule","dashArray","lineCap","lineJoin","clickable","pointerEvents","className"]);n(153);var g=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this),this.mouseTimer=null,this.currentId=null,this.hasTooltip=!1,this.state={showTooltip:!1,tooltipPosition:null,tooltipContent:""}}return o(e,t),i(e,null,[{key:"PropTypes",value:{styler:l.PropTypes.func,onEachFeature:l.PropTypes.func,setTooltipContent:l.PropTypes.func,selectedStyle:l.PropTypes.object,onFeatureClick:l.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{selectedStyle:{}},enumerable:!0}]),i(e,[{key:"shouldComponentUpdate",value:function(t){return!0}},{key:"componentWillMount",value:function(){r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this);var t=this.props.data,n=this.setGeoJSONOptions();this.setTooltipFlag(),this.leafletElement=(0,p.geoJson)(t,n)}},{key:"componentDidMount",value:function(){var t=this.props.map;this.leafletElement.addTo(t),this.hasTooltip&&t.on("mousemove",this.onMouseMove.bind(this))}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(t){var e=this.props.data;t.data!==e&&this.leafletElement.addData(e)}},{key:"setGeoJSONOptions",value:function(){var t=a(this.props,[]);return{style:t.style||null,onEachFeature:t.onEachFeature||this.onEachFeature.bind(this),filter:t.filter||null,pointToLayer:t.pointToLayer||null,coordsToLatLng:t.coordsToLatLng||null}}},{key:"setTooltipFlag",value:function(){var t=this,e=this.props.children;l.Children.forEach(e,function(e){e.type&&e.type.name&&"Tooltip"===e.type.name&&(t.hasTooltip=!0)})}},{key:"getPathOptions",value:function(t){return(0,h["default"])(t,m)}},{key:"getTooltipContent",value:function(t){return"function"==typeof this.props.setTooltipContent?this.props.setTooltipContent(t):""}},{key:"onMouseOver",value:function(t){if(this.currentId!==t.target){if(t.target.setStyle(this.props.selectedStyle),this.currentId!==t.target){this.currentId=t.target;var e=this.getTooltipContent(t.target.feature);this.setState({showTooltip:!0,tooltipPosition:t.latlng,tooltipContent:e})}L.Browser.ie||L.Browser.opera||t.target.bringToFront()}}},{key:"onMouseOut",value:function(t){var e=this;this.leafletElement.resetStyle(t.target),this.currentId=null,clearTimeout(this.mouseTimer),this.mouseTimer=setTimeout(function(){null===e.currentId&&(e.currentId=null,e.setState({showTooltip:!1}))},200)}},{key:"onMouseMove",value:function(t){this.currentId&&(p.DomEvent.stopPropagation(t),this.setState({tooltipPosition:t.latlng}))}},{key:"onClick",value:function(t){"function"==typeof this.props.onFeatureClick&&this.props.onFeatureClick(t.target,this.props.map)}},{key:"onEachFeature",value:function(t,e){this.hasTooltip&&e.on({mouseover:this.onMouseOver.bind(this),mouseout:this.onMouseOut.bind(this)}),e.on("click",this.onClick.bind(this))}},{key:"render",value:function(){return this.renderChildrenWithProps({tooltipContainer:this.leafletElement,popupContainer:this.leafletElement,position:this.state.tooltipPosition,isOpen:this.state.showTooltip,content:this.state.tooltipContent})}}]),e}(c.MapLayer);e["default"]=g,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(33)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=(u(l),n(22)),p=(n(21),n(82)),f=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{center:c.PropTypes.latlng.isRequired,outerRadius:l.PropTypes.number.isRequired,innerRadius:l.PropTypes.number.isRequired},enumerable:!0},{key:"defaultProps",value:{},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){var t=this.props,n=t.center,o=t.outerRadius,i=t.innerRadius,s=a(t,["center","outerRadius","innerRadius"]);r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this),this.leafletElement=new p.LeafletDonut(n,o,i,this.getPathOptions(s))}},{key:"componentDidUpdate",value:function(t){this.props.center!==t.center&&this.leafletElement.setLatLng(this.props.center),(this.props.outerRadius!==t.outerRadius||this.props.innerRadius!==t.innerRadius)&&this.leafletElement.setRadius(this.props.outerRadius,this.props.innerRadius),this.setStyleIfChanged(t,this.props)}}]),e}(c.Path);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var o=n(48)["default"];Object.defineProperty(e,"__esModule",{value:!0});var i=n(21),s=o(i),a=function(t){return t.Circle.extend({initialize:function(e,n,r,o){t.Path.prototype.initialize.call(this,o),this._latlng=t.latLng(e),this._mOuterRadius=n,this._mInnerRadius=this._validateInnerRadius(n,r)},setRadius:function(t,e){return this._mOuterRadius=t,this._mInnerRadius=this._validateInnerRadius(t,e),this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,n=this._map.latLngToLayerPoint([e.lat,e.lng-t[0]]),r=this._map.latLngToLayerPoint([e.lat,e.lng-t[1]]);this._point=this._map.latLngToLayerPoint(e),this._outerRadius=Math.max(this._point.x-n.x,1),this._innerRadius=Math.max(this._point.x-r.x,1)},getBounds:function(){var e=this._getLngRadius()[0],n=this._getLatRadius()[0],r=this._latlng;return new t.LatLngBounds([r.lat-n,r.lng-e],[r.lat+n,r.lng+e])},getRadius:function(){return[this._mOuterRadius,this._mInnerRadius]},_getLatRadius:function(){return[this._mOuterRadius/40075017*360,this._mInnerRadius/40075017*360]},_getLngRadius:function(){var e=this._getLatRadius();return[e[0]/Math.cos(t.LatLng.DEG_TO_RAD*this._latlng.lat),e[1]/Math.cos(t.LatLng.DEG_TO_RAD*this._latlng.lat)]},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._outerRadius,n=this._point;return n.x-e>t.max.x||n.y-e>t.max.y||n.x+e<t.min.x||n.y+e<t.min.y},_validateInnerRadius:function(t,e){return e>=t?t-1:e},getArc:function(t,e,n){var r=t.x-.01,o=t.y-e,i=t.y-n;return["M",t.x,o,"A",e,e,0,1,1,r,o,"M",r,i,"A",n,n,0,1,0,t.x,i,"Z"].join(" ")},getPathString:function(){var e=this._point,n=this._outerRadius,o=this._innerRadius;return this._checkIfEmpty()?"":t.Browser.svg?this.getArc(e,n,o):(e._round(),r=Math.round(r),"AL "+e.x+","+e.y+" "+n+","+n+" 0,23592600")}})}(s);e.LeafletDonut=a},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(33)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=n(22),p=n(21),f=n(65),h=u(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"componentWillMount",value:function(){r(Object.getPrototypeOf(e.prototype),"componentWillMount",this).call(this);var t=this.props,n=(t.children,t.map,a(t,["children","map"])),o=(0,h["default"])({},n);o.className=o.className?o.className+" panorama-leaflet-tip":"panorama-leaflet-tip",o.closeButton=!1,o.offset=o.offset||[0,-3],this.leafletElement=(0,p.popup)(o)}},{key:"componentDidMount",value:function(){}},{key:"componentDidUpdate",value:function(t){var e=this.props,n=e.map,r=e.position,o=e.isOpen,i=e.content;r!==t.position&&this.leafletElement.setLatLng(r),i!==t.content&&this.leafletElement.setContent(i),o!==t.isOpen&&(o?(this.leafletElement.openOn(n),this.renderPopupContent()):(n.closePopup(),this.removePopupContent()))}}],[{key:"propTypes",value:{children:l.PropTypes.node,map:l.PropTypes.instanceOf(p.Map),tooltipContainer:l.PropTypes.object,position:c.PropTypes.latlng},enumerable:!0}]),e}(c.Popup);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(31);n(154);var p=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.onItemClick=this.onItemClick.bind(this),this.onItemEnter=this.onItemEnter.bind(this),this.onItemLeave=this.onItemLeave.bind(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{items:u.PropTypes.array.isRequired,selectedItem:u.PropTypes.string,onItemSelected:u.PropTypes.func},enumerable:!0},{key:"defaultProps",value:{items:[],selectedItem:"",onItemSelected:null},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){}},{key:"onItemClick",value:function(t){t.currentTarget&&t.currentTarget.dataset&&(this.props.onItemSelected&&this.props.onItemSelected(t.currentTarget.dataset.item,this.props.items.indexOf(t.currentTarget.dataset.item)),c.PanoramaDispatcher.Legend.selected(t.currentTarget.dataset.item,this.props.items.indexOf(t.currentTarget.dataset.item)))}},{key:"onItemEnter",value:function(t){}},{key:"onItemLeave",value:function(t){}},{key:"render",value:function(){var t=this;return l["default"].createElement("div",{className:"panorama legend"},l["default"].createElement("ul",null,this.props.items.map(function(e,n){var r=t.props.selectedItem===e||t.props.selectedItem==n;return l["default"].createElement("li",{className:"item"+(r?" selected":""),"data-item":e,key:e,onClick:t.onItemClick,onMouseEnter:t.onItemEnter,onMouseLeave:t.onItemLeave},l["default"].createElement("span",null,t.capitalize(e)))})))}},{key:"capitalize",value:function(t){return t.charAt(0).toUpperCase()+t.slice(1)}}]),e}(l["default"].Component);e["default"]=p,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=(u(l),n(6)),p=n(14),f=u(p),h=n(86),d=u(h);n(155);var y=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=d["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes,{strokeColor:c.PropTypes.oneOfType([c.PropTypes.string,c.PropTypes.number]),strokeOpacity:c.PropTypes.number,isInterpolated:c.PropTypes.bool,interpolate:c.PropTypes.string}),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{className:"line-chart",isInterpolated:!1,interpolate:"basis",xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(f["default"]);e["default"]=y,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale)),this.lineGenerator=p["default"].svg.line()}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this.lineLayer=this.base.append("g").classed("line-layer",!0),this._render()}},{key:"preRender",value:function(){var t=this.props,e=(t.data,t.xAccessor),n=t.yAccessor,r=t.xScale,o=t.yScale,i=t.isInterpolated,s=t.interpolate;r.range([0,this.width]),o.range([this.height,0]),this.updateAxis(0,r,this.props.xaxis),this.updateAxis(1,o,this.props.yaxis);var a=i?s:"linear";this.lineGenerator.interpolate(a).x(function(t){return r(e(t))}).y(function(t){return o(n(t))})}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=(e.xAccessor,e.yAccessor,e.xScale,e.yScale,e.strokeColor),o=e.strokeOpacity,i=this.lineLayer.selectAll("path.line").data(n);i.exit().remove(),i.enter().append("path").attr("class","line"),i.attr("d",function(e){return t.lineGenerator(e)}).style({stroke:r,strokeOpacity:o})}},{key:"postRender",value:function(){}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=(u(l),n(6)),p=n(14),f=u(p),h=n(88),d=u(h);n(156);var y=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=d["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes,{projection:c.PropTypes.string,mapScale:c.PropTypes.oneOfType([c.PropTypes.number,c.PropTypes.string]),selected:c.PropTypes.any,selectedAccessor:c.PropTypes.func,hoverStyle:c.PropTypes.object}),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{projection:"albersUsa",className:"map choropleth",mapScale:500}),enumerable:!0}]),e}(f["default"]);e["default"]=y,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(107)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(13),c=u(l),p=n(7),f=u(p),h=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this._path=f["default"].geo.path(),this._projection=f["default"].geo[this.props.projection](),this._render(),this._selected=null,this._hoverElement=null}},{key:"preRender",value:function(){this.updateProjection()}},{key:"render",value:function(){var t=this.props,e=t.data,n=t.styler,r=t.interactive,o=t.selected,i=t.selectedAccessor;if(e&&e.features){var s=this,a=this.base.selectAll("path").data(e.features);a.exit().remove(),a.enter().append("path").attr("class","geometry").attr("d",this._path),a.each(function(t){f["default"].select(this).style(n(t))}),r&&(f["default"].selectAll(".hover-dupe").remove(),
this._hoverElement=null,a.on("click",null).on("mouseover",null).on("mouseout",null).on("click",this.dispatch.click).on("mouseenter",function(t){i(t)!==o&&(s._hoverElement=s.bringToTop(this,"hover-dupe sel-"+i(t),s.props.hoverStyle||null),s.dispatch.mouseOver(t))}).on("mouseleave",function(t){s._hoverElement&&s._hoverElement.remove(),s._hoverElement=null,s.dispatch.mouseOut(t)})),o&&o!==this._selected&&(this._selected=o,f["default"].selectAll(".selected-dupe").remove(),a.filter(function(t){return i(t)===o}).each(function(){s.bringToTop(this,"selected-dupe")}))}}},{key:"postRender",value:function(){}},{key:"bringToTop",value:function(t,e,n){var r=f["default"].select(t.parentNode.appendChild(t.cloneNode(!0),t.nextSibling)).classed(e,!0);return n&&r.style(n),r}},{key:"updateProjection",value:function(){var t=this.props,e=t.data,n=t.mapScale,r=t.projection,o=n,i=[this.width/2,this.height/2];if("auto"===n){var s=this.fitMap(e),u=a(s,2);o=u[0],i=u[1]}this._projection=f["default"].geo[r]().scale(o).translate(i),this._path.projection(this._projection)}},{key:"fitMap",value:function(t){var e=this.props.projection,n=f["default"].geo[e]().scale(1).translate([0,0]),r=f["default"].geo.path().projection(n),o=r.bounds(t),i=.95/Math.max((o[1][0]-o[0][0])/this.width,(o[1][1]-o[0][1])/this.height),s=[(this.width-i*(o[1][0]+o[0][0]))/2,(this.height-i*(o[1][1]+o[0][1]))/2];return[i,s]}}]),e}(c["default"]);e["default"]=h,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(188),p=a(c);n(157);var f=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{nav_data:u.PropTypes.array.isRequired,show_menu:u.PropTypes.bool,on_hamburger_click:u.PropTypes.func,style:u.PropTypes.object,title:u.PropTypes.string,home_url:u.PropTypes.string,links:u.PropTypes.array,link_separator:u.PropTypes.string},enumerable:!0},{key:"defaultProps",value:{title:"American Panorama",home_url:"http://dsl.richmond.edu/panorama",links:[],link_separator:" ",nav_data:{},show_menu:!1,on_hamburger_click:null,style:{overlay:{position:"fixed",top:0,left:0,backgroundColor:"rgba(0,0,0,0.5)"},content:{position:"absolute",top:0,left:0,bottom:"auto",right:"auto",border:0,background:"rgba(0,0,0,0.5)",overflow:"auto",WebkitOverflowScrolling:"touch",borderRadius:"4px",outline:"none",padding:0}}},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){}},{key:"computeDimensions",value:function(){return(window.innerWidth-40*this.props.nav_data.length)/this.props.nav_data.length}},{key:"render",value:function(){var t=this;return l["default"].createElement("div",null,l["default"].createElement("div",{id:"hamburger"},l["default"].createElement("img",{src:"http://dsl.richmond.edu/panorama/static/images/menu.svg",onClick:this.props.on_hamburger_click})),l["default"].createElement(p["default"],{isOpen:this.props.show_menu,onRequestClose:this.props.on_hamburger_click,className:"nav_header",style:this.props.style},l["default"].createElement("div",{id:"nav_header"},l["default"].createElement("div",{id:"navburger"},l["default"].createElement("img",{src:"http://dsl.richmond.edu/panorama/static/images/menu-close.svg",onClick:this.props.on_hamburger_click})),this.props.title&&this.props.home_url?l["default"].createElement("h1",null,l["default"].createElement("a",{href:this.props.home_url},this.props.title)):"",l["default"].createElement("h2",null,this.props.links.map(function(e,n){return l["default"].createElement("a",{href:e.url,key:"pan_nav_links_"+n},n<t.props.links.length-1?e.name+t.props.link_separator:e.name)})),l["default"].createElement("div",{id:"maps"},this.props.nav_data.map(function(e,n){return l["default"].createElement("div",{className:"pan_nav_item",key:"pan_nav_item_"+n,style:{width:t.computeDimensions()+"px"}},l["default"].createElement("a",{href:e.url},l["default"].createElement("img",{src:e.screenshot,style:{width:t.computeDimensions()+"px"}})),l["default"].createElement("br",null),l["default"].createElement("h4",null,l["default"].createElement("a",{href:e.url},e.title)))})))))}}]),e}(l["default"].Component);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(6),c=(u(l),n(7)),p=(u(c),n(14)),f=u(p),h=n(45),d=(u(h),n(91)),y=u(d);n(158);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"],this.chartIdAccessor=t.chartIdAccessor}return o(e,t),i(e,null,[{key:"propTypes",value:a({},f["default"].propTypes,{areaChartData:l.PropTypes.array,chartSpacing:l.PropTypes.number,colorPalette:l.PropTypes.array,selectedChartId:l.PropTypes.oneOfType([l.PropTypes.string,l.PropTypes.number]),chartIdAccessor:l.PropTypes.func,metadataAccessor:l.PropTypes.func,interpolate:l.PropTypes.string,circleRadius:l.PropTypes.number}),enumerable:!0},{key:"defaultProps",value:a({},f["default"].defaultProps,{className:"offset-area-chart",areaChartData:[],chartSpacing:4,colorPalette:null,selectedChartId:null,chartIdAccessor:null,metadataAccessor:null,interpolate:"basis",circleRadius:2}),enumerable:!0}]),e}(f["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=(a(f),function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){var t=this.props,e=t.xAccessor,n=t.yAccessor,r=t.xScale,o=t.yScale,i=t.interpolate;this.areaGenerator=p["default"].svg.area().interpolate(i).x(function(t){return r(e(t))}).y0(function(t){return o(0)}).y1(function(t){return o(n(t))})}},{key:"onMount",value:function(){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this),this.lineLayer=this.base.append("g").classed("offset-area-lines",!0),this._render()}},{key:"preRender",value:function(){var t=this.props,e=t.xScale,n=t.yScale,r=(t.xAccessor,t.yAccessor,t.areaChartConfig),o=t.interpolate,i=this.height-this.props.areaChartData.length*this.props.chartSpacing;e.range([0,this.width]),n.range([i,0]),this.areaGenerator=p["default"].svg.area().interpolate(o).x(function(t){return e(r.xAccessor(t))}).y0(function(t){return n(0)}).y1(function(t){return n(r.yAccessor(t))})}},{key:"areaOffsetTranslation",value:function(t){var e=this.props.chartSpacing;return"translate(0,"+e*t+")"}},{key:"lineOffsetTranslation",value:function(t){var e=this.props,n=e.data,r=e.chartSpacing,o=e.yScale,i=(o(0),n.length-t),s=-r*i;return"translate(0,"+s+")"}},{key:"render",value:function(){var t=this,e=this.props,n=e.data,r=e.xAccessor,o=(e.yAccessor,e.xScale),i=e.yScale,s=(e.fillColor,e.fillOpacity,e.areaChartData),a=e.colorPalette,u=e.metadataAccessor,l=e.chartIdAccessor,c=e.selectedChartId,p=e.circleRadius,f=(e.interactive,this.base.selectAll("g.area-container").data(s));f.exit().remove(),f.enter().append("g").attr("class","area-container").append("path").attr("class","area"),f.attr("transform",function(e,n){return t.areaOffsetTranslation(n)}).classed("selected",function(t){return l(t)===c?!0:!1}).selectAll("path").attr("d",function(e){return t.areaGenerator(e)}).attr("fill",function(t,e,n){return a[n%a.length]});var h=i(0)+this.props.areaChartData.length*this.props.chartSpacing,d=o.domain();this.lineLayer.attr("transform","translate(0, "+h+")");var y=this.lineLayer.selectAll("g.line-group").data(n);y.exit().remove(),y.enter().append("g").attr("class","line-group").append("line").attr("class","lifespan"),y.attr("transform",function(e,n){return t.lineOffsetTranslation(n)}).classed("selected",function(t){return l(t)==c?!0:!1}).selectAll("line").attr("x1",function(t){return o(Math.max(r(t,0),d[0]))}).attr("x2",function(t){return o(Math.min(r(t,1),d[1]))}).attr("y1",0).attr("y2",0).style("stroke",function(t,e){return a[e%a.length]});var v=y.selectAll("circle").data(function(t){return u(t)});v.exit().remove(),v.enter().append("circle"),v.attr("cx",function(t){return o(Math.max(t,d[0]))}).attr("cy",0).attr("r",p).style("fill",function(t,e,n){return a[n%a.length]})}},{key:"postRender",value:function(){}}]),e}(l["default"]));e["default"]=h,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"],l=n(48)["default"];Object.defineProperty(e,"__esModule",{value:!0});var c=n(6),p=u(c),f=n(7),h=l(f);n(159);var d=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{data:c.PropTypes.array.isRequired,onItemClick:c.PropTypes.func,loading:c.PropTypes.bool,noDataAvailableMsg:c.PropTypes.string,punchcardOptions:c.PropTypes.object,selectAccessor:c.PropTypes.func,textValueFormatter:c.PropTypes.func,headerMargin:c.PropTypes.number},enumerable:!0},{key:"defaultProps",value:{data:[],onItemClick:null,loading:!0,noDataAvailableMsg:"No commodities data available for this canal in the selected year.",radiusExtent:[2,10],textValueFormatter:function(t){return t},headerMargin:0},enumerable:!0}]),i(e,[{key:"componentWillMount",value:function(){}},{key:"componentDidMount",value:function(){this.renderVisualization()}},{key:"componentDidUpdate",value:function(){y.destroy(this.refs.content),this.renderVisualization()}},{key:"componentWillUnmount",value:function(){y.destroy(this.refs.content)}},{key:"render",value:function(){return p["default"].createElement("div",{className:"panorama punchcard"},this.renderPlaceholder(),p["default"].createElement("div",{className:"content",ref:"content",style:{marginTop:this.props.headerMargin+"px"}}))}},{key:"renderVisualization",value:function(){!this.isEmpty(this.props.data)&&this.refs.content&&y.update(this.refs.content,a({},this.props))}},{key:"renderPlaceholder",value:function(){var t=this.props,e=t.loading,n=t.noDataAvailableMsg;return e?p["default"].createElement("div",{className:"placeholder",ref:"placeholder"},p["default"].createElement("h4",null,"Loading...")):!this.props.loading&&this.isEmpty(this.props.data)?p["default"].createElement("div",{className:"placeholder",ref:"placeholder"},p["default"].createElement("h4",null,n)):null}},{key:"isEmpty",value:function(t){return t.length<1}}]),e}(p["default"].Component);e["default"]=d;var y={_setTextValueFormatter:function(t){return t},setTextValueFormatter:function(t){this._setTextValueFormatter=t},ROW_HEIGHT:25,COMMODITY_TEXT_OFFSET_Y:5,update:function(t,e){var n=this,r=e.colorScale,o=e.valueAccessor,i=e.onItemClick,s=e.textValueFormatter,a=e.selected,u=e.selectAccessor;"function"==typeof s&&this.setTextValueFormatter(s);var l=e.radiusExtent[1],c=this,p=h.scale.sqrt().range(e.radiusExtent).domain([1,e.radiusMaxValue]),f=p.domain(),d=f[0]+Math.sqrt(.25)*(f[1]-f[0]),y=h.select(t).selectAll("div").data(e.data).enter().append("div").attr("style",function(t){return"color: "+r(e.colorAccessor(t))+";"}).attr("class","category");y.append("h4").text(function(t){return t.name}),y=y.append("svg").attr("height",function(t){return t.commodities.length*c.ROW_HEIGHT}).style("stroke",function(t){return r(e.colorAccessor(t))}).style("fill",function(t){return r(e.colorAccessor(t))}),this.categoryNodeWidth=(y.node().offsetWidth||y.node().getBoundingClientRect().width)-2.5*this.ROW_HEIGHT;var v=y.selectAll("g").data(function(t){return t.commodities}).enter().append("g");v.classed("selected",function(t){return u(t)===a}),v.append("circle").attr("r",function(t){var e=o(t);return e?p(e):d}).style("fill",function(t){return o(t)?null:"none"}).style("stroke",function(t){return o(t)?"none":null}).style("stroke-width",function(t){return o(t)?null:2}),v.append("text").text(function(t){return t.name}).style("stroke","none").attr("x",2*c.ROW_HEIGHT).attr("y",c.COMMODITY_TEXT_OFFSET_Y).call(this.wrap,this.categoryNodeWidth);var m=void 0;y.each(function(t,e){h.select(this).selectAll("g").each(function(t,e){e||(m=0);var n=h.select(this);n.attr("transform","translate("+.5*c.ROW_HEIGHT+", "+(e+.5+m)*c.ROW_HEIGHT+")"),m+=n.selectAll("tspan").size()-1});var n=h.select(this);n.attr("height",parseFloat(n.attr("height"))+m*c.ROW_HEIGHT)}),v.append("rect").attr("x",-l).attr("y",-l).attr("width",this.categoryNodeWidth+2.5*this.ROW_HEIGHT).attr("height",this.ROW_HEIGHT).on("mouseover",function(t,e){c.onItemMouseOver(this,t,e)}).on("mouseout",function(t,e){c.onItemMouseOut(this,t,e)}).on("click",function(t,e){"function"==typeof i&&i.call(n,t,e)})},onItemMouseOver:function(t,e,n){var r=h.select(t.parentNode);r.select("text").text((e.prettyValue||this._setTextValueFormatter(e.value))+(e.units?" "+e.units:"")).style("font-weight",400)},onItemMouseOut:function(t,e,n){var r=h.select(t.parentNode);r.select("text").text(e.name).style("font-weight",null).call(this.wrap,this.categoryNodeWidth)},destroy:function(t){h.select(t).html("")},wrap:function(t,e){t.each(function(){var t=["/","&"],n=h.select(this),r=n.text(),o=void 0;t.forEach(function(t){r=r.replace(t,t+" ")});for(var i=r.split(/\s+/).reverse(),s=void 0,a=[],u=0,l=1.1,c=n.attr("x"),p=n.attr("y"),f=parseFloat(n.attr("dy")||0),d=n.text(null).append("tspan").attr("x",c).attr("y",p).attr("dy",f+"em");s=i.pop();)a.push(s),d.text(a.join(" ")),d.node().getComputedTextLength()>e&&(a.pop(),o=a.join(" "),t.forEach(function(t){o=o.replace(t+" ",t)}),d.text(o),a=[s],d=n.append("tspan").attr("x",c).attr("y",p).attr("dy",++u*l+f+"em").text(s))})}};t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(11)["default"],u=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var l=n(7),c=u(l),p=n(6),f=n(14),h=u(f),d=n(94),y=u(d);n(160);var v=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.chartConstructor=y["default"]}return o(e,t),i(e,null,[{key:"propTypes",value:a({},h["default"].propTypes,{dotRadiusScale:p.PropTypes.func,dotRadius:p.PropTypes.number,dotRadiusAccessor:p.PropTypes.func,dotColorScale:p.PropTypes.func,dotColorAccessor:p.PropTypes.func}),enumerable:!0},{key:"defaultProps",value:a({},h["default"].defaultProps,{xScale:c["default"].scale.linear(),yScale:c["default"].scale.linear(),className:"scatterplot",dotRadius:3,xaxis:{className:"x axis",orient:"bottom",position:"bottom",attr:{dx:"0",dy:"0.5em"},style:{"text-anchor":"middle"}},yaxis:{className:"y axis",orient:"left"}}),enumerable:!0}]),e}(h["default"]);e["default"]=v,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(13),l=a(u),c=n(7),p=a(c),f=n(18),h=a(f),d=function(t){function e(){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,arguments)}return o(e,t),i(e,[{key:"willMount",value:function(){this.props.xaxis&&this.setAxis(new h["default"](this.props.xaxis,this.props.xScale)),this.props.yaxis&&this.setAxis(new h["default"](this.props.yaxis,this.props.yScale))}},{key:"onMount",value:function(t){r(Object.getPrototypeOf(e.prototype),"onMount",this).call(this,t),this._render()}},{key:"preRender",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale,s=t.dotRadiusScale,a=t.dotRadiusAccessor;o.range([0,this.width]),o.domain(p["default"].extent(e,function(t){return n(t)})).nice(),i.range([this.height,0]),i.domain(p["default"].extent(e,function(t){return r(t)})).nice(),s&&a&&s.domain(p["default"].extent(e,function(t){return a(t)}))}},{key:"render",value:function(){var t=this.props,e=t.data,n=t.xAccessor,r=t.yAccessor,o=t.xScale,i=t.yScale,s=t.dotRadius,a=t.dotRadiusScale,u=t.dotRadiusAccessor,l=t.dotColorScale,c=t.dotColorAccessor,p=this.base.selectAll(".dot").data(e);p.exit().remove(),p.enter().append("circle").attr("class","dot"),p.attr("r",function(t){return a||u?a(u(t)):s}).attr("cx",function(t){return o(n(t))}).attr("cy",function(t){return i(r(t))}).style("fill",function(t){return l&&c?l(c(t)):"lime"})}},{key:"postRender",value:function(){var t=this.props,e=t.selected,n=t.selectionAccessor,r=t.interactive,o=this.base.selectAll(".dot");r&&o.on("click",this.dispatch.click).on("mouseover",this.dispatch.mouseOver).on("mouseout",this.dispatch.mouseOut),e&&o.classed("selected",function(t){return n(t)===e})}}]),e}(l["default"]);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=n(30),p=a(c),f=n(96),h=a(f);n(161);var d=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.selectedKey=null,this.currentKey=null,this.handleScroll=this.handleScroll.bind(this),this.onClickHandler=this.onClickHandler.bind(this)}return o(e,t),i(e,null,[{key:"propTypes",value:{items:u.PropTypes.array.isRequired,keyAccessor:u.PropTypes.func.isRequired,renderItem:u.PropTypes.func.isRequired,onItemClicked:u.PropTypes.func,selected:u.PropTypes.string,height:u.PropTypes.any,isItemDirty:u.PropTypes.func,onStoryScroll:u.PropTypes.func,sensitivity:u.PropTypes.number},enumerable:!0},{key:"defaultProps",value:{selected:null,height:400,sensitivity:30},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){this.listContainer=p["default"].findDOMNode(this.refs.list),this.listContainer.addEventListener("scroll",this.handleScroll,!1)}},{key:"componentWillUnmount",value:function(){this.listContainer.removeEventListener("scroll",this.handleScroll)}},{key:"componentDidUpdate",value:function(){var t=this.props.selected;this.buildItemCache(),this.anchors.length&&t!==this.selectedKey&&(this.selectedKey=t,this.setScrollPosition())}},{key:"buildItemCache",value:function(){var t=this;this.anchors=[],this.anchorMap={};var e=this.listContainer.querySelectorAll(".textural-list--item");[].forEach.call(e,function(e){var n={t:e.offsetTop,key:e.getAttribute("data-id")};t.anchorMap[n.key]=e,t.anchors.push(n)})}},{key:"setScrollPosition",value:function(){if(this.selectedKey&&this.listContainer){var t=this.selectedKey in this.anchorMap?this.anchorMap[this.selectedKey].offsetTop:null;t&&(this.listContainer.scrollTop=t)}}},{key:"handleScroll",value:function(){var t=this,e=this.props,n=e.onStoryScroll,r=e.sensitivity,o=this.listContainer.scrollTop,i=this.currentKey,s=this.listContainer.scrollHeight,a=this.listContainer.clientHeight,u=void 0;this.anchors&&(0>=o?this.currentKey=this.anchors[0].key:s-o===a?this.currentKey=this.anchors[this.anchors.length-1].key:this.anchors.forEach(function(e){u=o-e.t,r>u&&u>-r&&t.currentKey!==e.key&&(t.currentKey=e.key)}),i!==this.currentKey&&"function"==typeof n&&n(this.currentKey))}},{key:"getClosestItemNode",value:function(t){for(;t&&t!==document;t=t.parentNode)if(t.classList.contains("textural-list--item"))return t;return!1}},{key:"getDataItemForKey",value:function(t){var e=this,n=this.props,r=n.items,o=n.keyAccessor,i=r.filter(function(n){return e.coerceKey(o(n))===t});return i.length?i:null}},{key:"onClickHandler",value:function(t){var e=this.props.onItemClicked,n=t.target||null;if(n){var r=n.classList.contains("textural-list--item")?n:this.getClosestItemNode(n);if(r){var o=r.getAttribute("data-id");if(o){var i=this.getDataItemForKey(o);i.length&&"function"==typeof e&&e(i)}}}}},{key:"renderItems",value:function(){var t=this,e=this.props,n=e.renderItem,r=e.items,o=e.keyAccessor,i=e.isItemDirty,s="function"==typeof o?!0:!1,a="function"==typeof i?!0:!1;return r.map(function(e,r){var u=a?i(e):!0,c=s?o(e):r;return l["default"].createElement(h["default"],{key:c,renderItem:n,index:r,identifier:t.coerceKey(c),dirty:u})})}},{key:"coerceKey",value:function(t){return""+t}},{key:"isNumeric",value:function(t){return!isNaN(t)}},{key:"render",value:function(){var t=this.props.height,e=this.isNumeric(t)?{maxHeight:t}:null;return l["default"].createElement("div",{className:"panorama textural-list"},l["default"].createElement("div",{ref:"list",className:"textural-list--inner",style:e,onClick:this.onClickHandler},this.renderItems()))}}]),e}(u.Component);e["default"]=d,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=a(u),c=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t)}return o(e,t),i(e,null,[{key:"propTypes",value:{renderItem:u.PropTypes.func.isRequired,index:u.PropTypes.number.isRequired,dirty:u.PropTypes.bool,identifier:u.PropTypes.string},enumerable:!0},{key:"defaultProps",value:{dirty:!0},enumerable:!0}]),i(e,[{key:"shouldComponentUpdate",value:function(t,e){return t.dirty}},{key:"componentDidMount",value:function(){}},{key:"componentWillUnmount",value:function(){}},{key:"componentDidUpdate",value:function(){}},{key:"render",value:function(){var t=this.props,e=t.renderItem,n=t.index,r=t.identifier;return l["default"].createElement("div",{className:"textural-list--item","data-id":r},e(n))}}]),e}(u.Component);e["default"]=c,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(4)["default"],o=n(5)["default"],i=n(3)["default"],s=n(2)["default"],a=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var u=n(6),l=n(22),c=n(7),p=a(c);n(162);var f=function(t){function e(t){s(this,e),r(Object.getPrototypeOf(e.prototype),"constructor",this).call(this,t),this.map=null}return o(e,t),i(e,null,[{key:"propTypes",value:{features:u.PropTypes.object.isRequired,currentDate:u.PropTypes.instanceOf(Date)},enumerable:!0},{key:"defaultProps",value:{features:{},currentDate:null},enumerable:!0}]),i(e,[{key:"componentDidMount",value:function(){this.markers=[],this.map=this.props.map,this._el=L.DomUtil.create("div","panorama time-based-markers-layer leaflet-zoom-hide leaflet-d3-overlay"),this.map.getPanes().overlayPane.appendChild(this._el),this.svg=p["default"].select(this._el).append("svg"),this.container=this.svg.append("g").attr("class","panorama time-based-markers-container"),this.setOverlayPosition(),this.map.on("viewreset",this._reset,this),this.dirty&&this.draw(this.props.features)}},{key:"componentWillUnmount",value:function(){this.map.getPanes().overlayPane.removeChild(this._el),this.map.off("viewreset",this._reset,this),this.markers=[],this.line=null}},{key:"componentDidUpdate",value:function(){var t=this;this.props.features&&this.props.features.features.length&&!this.loaded&&this.draw(this.props.features),this.props.currentDate!==this.currentDate&&(this.currentDate=this.props.currentDate,this.filter()),setTimeout(function(){t.map.getPanes().overlayPane.appendChild(t._el)},1)}},{key:"render",value:function(){return!1}},{key:"setOverlayPosition",value:function(){var t=this.map.getBounds(),e=this.map.latLngToLayerPoint(t.getNorthWest());this.map.latLngToLayerPoint(t.getSouthEast());this.svg&&(p["default"].select(this._el).style("width",this.map.getSize().x+"px").style("height",this.map.getSize().y+"px").style("margin-left","0px").style("margin-top","0px").attr("transform","translate("+-e.x+","+-e.y+")"),this.svg.style("width",this.map.getSize().x+"px").style("height",this.map.getSize().y+"px"))}},{key:"_reset",value:function(){this.setOverlayPosition(),this.filter(),this.position()}},{key:"filter",value:function(){if(this.map){var t=this.props.currentDate||null,e=this.map.getZoom(),n=!1;this.markers.forEach(function(r){r.show="none",t&&e>=r.zoomStart&&e<=r.zoomEnd&&(r.start?!r.end&&t>=r.start?(r.show="block",n=!0):t>=r.start&&t<=r.end&&(r.show="block",n=!0):(r.show="block",n=!0)),r.elm.style("display",r.show)}),n&&this.position()}}},{key:"position",value:function(){if(this.markers&&this.map){var t=this;this.markers.forEach(function(e){if("none"!==e.show){var n;"icon"===e.markerType?(n=t.map.latLngToLayerPoint(e.coords),e.elm.attr("cx",n.x+"px").attr("cy",n.y+"px")):"label"===e.markerType?(n=t.map.latLngToLayerPoint(e.coords),e.elm.attr("x",n.x+"px").attr("y",n.y+"px")):"line"===e.markerType&&e.elm.attr("d",t.line(e.coords))}})}}},{key:"draw",value:function(t){function e(t,e){return i.container.append("circle").attr("class","time-based-"+[e.maptype,e.type].join(" ")).attr("cx",t.x+"px").attr("cy",t.y+"px").attr("r",3)}function n(t,e){var n="left"===e.justify?"start":"end";return i.container.append("text").attr("class","with-outlines time-based-"+[e.maptype,e.type].join(" ")).attr("x",t.x+"px").attr("y",t.y+"px").attr("text-anchor",n).text(e.location)}function r(t,e){return i.container.append("path").attr("class","time-based-"+[e.maptype,e.type].join(" ")).attr("d",i.line(t))}function o(o){t.features.forEach(function(t){var s,a,u,l=t.properties,c=t.geometry.type;l.maptype===o&&("icon"===l.maptype?(s=t.geometry.coordinates.reverse(),u=i.map.latLngToLayerPoint(s),a=e(u,l)):"label"===l.maptype?(s=t.geometry.coordinates.reverse(),u=i.map.latLngToLayerPoint(s),a=n(u,l)):"line"===l.maptype&&(s=t.geometry.coordinates,s.forEach(function(t){t.reverse()}),a=r(s,l)),a?i.markers.push({elm:a,coords:s,geometryType:c,markerType:l.maptype||"",start:l.start_year?new Date(l.start_year):null,end:l.end_year?new Date(l.end_year):null,zoomStart:l.startzoom?+l.startzoom:i.map.minZoom,zoomEnd:l.endzoom?+l.endzoom:i.map.maxZoom}):console.error("Unknown feature: ",t))})}if(t&&!this.loaded){if(this.loaded=!0,!this.map)return void(this.dirty=!0);this.dirty=!1;var i=this;if(this.markers.length)return position();this.line=p["default"].svg.line().x(function(t){return i.map.latLngToLayerPoint(t).x}).y(function(t){return i.map.latLngToLayerPoint(t).y}).interpolate("linear"),this.markers=[],o("label"),o("line"),o("icon"),this.filter()}}}]),e}(l.MapLayer);e["default"]=f,t.exports=e["default"]},function(t,e,n){"use strict";var r=n(3)["default"],o=n(2)["default"],i=n(11)["default"],s=n(1)["default"];Object.defineProperty(e,"__esModule",{value:!0});var a=n(7),u=s(a),l=n(32),c=function(){function t(e,n){o(this,t),this._options=i({},l.tooltipDefaultOptions,n),this._element=u["default"].select(e),this.closeTimer=null}return r(t,[{key:"unMount",value:function(){this._options={},this._element=null,this._relativeContainer=null,this.closeTimer&&(clearTimeout(this.closeTimer),this.closeTimer=null)}},{key:"setPosition",value:function(t){if(this.isShowing){var e=this.calcPosition(t);this.element.style("left",e[0]+"px").style("top",e[1]+"px")}}},{key:"calcPosition",value:function(t){var e=this.options,n=e.offset,r=e.align,o=r.split(" "),i=this.element.node().offsetWidth,s=this.element.node().offsetHeight,a=this.relativeContainer||t.target||t.srcElement,u=a.getBoundingClientRect(),l=t.clientX-u.left,c=t.clientY-u.top;switch(o[0]){case"top":c-=s-n[1];break;case"bottom":default:c-=n[1]}switch(o[1]){case"center":l-=i/2+n[0];break;case"right":l-=i+n[0];break;case"left":default:l+=n[0]}return[l,c]}},{key:"setContent",value:function(t){return"function"==typeof this.options.onSetTooltipContent?this.options.onSetTooltipContent(this.element,t):this.element.text(""),this}},{key:"show",value:function(t,e){return this.isShowing?void 0:(this.isShowing=!0,this.element.classed("active",!0),t&&this.setPosition(t),e&&this.setContent(e),this)}},{key:"hide",value:function(t){var e=this;if(this.isShowing)return this.closeTimer&&(clearTimeout(this.closeTimer),this.closeTimer=null),this.isShowing=!1,t||this.options.closeDelay<1?this.setActiveToFalse():this.closeTimer=setTimeout(function(){e.isShowing||e.setActiveToFalse()},this.options.closeDelay),this}},{key:"setActiveToFalse",value:function(){this.closeTimer=null,this.element.classed("active",!1)}},{key:"toString",value:function(){return"Tooltip"}},{key:"element",get:function(){return this._element},set:function(t){this._element=u["default"].select(t)}},{key:"options",get:function(){return this._options},set:function(t){this._options=i({},this.options,{obj:t})}},{key:"relativeContainer",get:function(){return this._relativeContainer},set:function(t){this._relativeContainer=t.node?t.node():t}}]),t}();e["default"]=c,t.exports=e["default"]},function(t,e,n){t.exports={"default":n(108),__esModule:!0}},function(t,e,n){t.exports={"default":n(109),__esModule:!0}},function(t,e,n){t.exports={"default":n(111),__esModule:!0}},function(t,e,n){t.exports={"default":n(112),__esModule:!0}},function(t,e,n){t.exports={"default":n(113),__esModule:!0}},function(t,e,n){t.exports={"default":n(114),__esModule:!0}},function(t,e,n){t.exports={"default":n(115),__esModule:!0}},function(t,e,n){t.exports={"default":n(116),__esModule:!0}},function(t,e,n){"use strict";var r=n(99)["default"],o=n(100)["default"];e["default"]=function(){function t(t,e){var n=[],o=!0,i=!1,s=void 0;try{for(var a,u=r(t);!(o=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);o=!0);}catch(l){i=!0,s=l}finally{try{!o&&u["return"]&&u["return"]()}finally{if(i)throw s}}return n}return function(e,n){if(Array.isArray(e))return e;if(o(Object(e)))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),e.__esModule=!0},function(t,e,n){n(42),n(41),t.exports=n(139)},function(t,e,n){n(42),n(41),t.exports=n(140)},function(t,e,n){n(142),t.exports=n(8).Object.assign},function(t,e,n){var r=n(9);t.exports=function(t,e){return r.create(t,e)}},function(t,e,n){var r=n(9);t.exports=function(t,e,n){return r.setDesc(t,e,n)}},function(t,e,n){var r=n(9);n(143),t.exports=function(t,e){return r.getDesc(t,e)}},function(t,e,n){n(144),t.exports=n(8).Object.keys},function(t,e,n){n(145),t.exports=n(8).Object.setPrototypeOf},function(t,e,n){n(146),n(41),n(42),n(147),t.exports=n(8).Promise},function(t,e){t.exports=function(){}},function(t,e,n){var r=n(25),o=n(12).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,e,n){var r=n(19),o=n(123),i=n(122),s=n(15),a=n(137),u=n(60);t.exports=function(t,e,n,l){var c,p,f,h=u(t),d=r(n,l,e?2:1),y=0;if("function"!=typeof h)throw TypeError(t+" is not iterable!");if(i(h))for(c=a(t.length);c>y;y++)e?d(s(p=t[y])[0],p[1]):d(t[y]);else for(f=h.call(t);!(p=f.next()).done;)o(f,d,p.value,e)}},function(t,e,n){t.exports=n(12).document&&document.documentElement},function(t,e){t.exports=function(t,e,n){var r=void 0===n;switch(e.length){case 0:return r?t():t.call(n);case 1:return r?t(e[0]):t.call(n,e[0]);case 2:return r?t(e[0],e[1]):t.call(n,e[0],e[1]);case 3:return r?t(e[0],e[1],e[2]):t.call(n,e[0],e[1],e[2]);case 4:return r?t(e[0],e[1],e[2],e[3]):t.call(n,e[0],e[1],e[2],e[3])}return t.apply(n,e)}},function(t,e,n){var r=n(16),o=n(10)("iterator"),i=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||i[o]===t)}},function(t,e,n){var r=n(15);t.exports=function(t,e,n,o){try{return o?e(r(n)[0],n[1]):e(n)}catch(i){var s=t["return"];throw void 0!==s&&r(s.call(t)),i}}},function(t,e,n){"use strict";var r=n(9),o=n(54),i=n(40),s={};n(39)(s,n(10)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=r.create(s,{next:o(1,n)}),i(t,e+" Iterator")}},function(t,e,n){var r=n(10)("iterator"),o=!1;try{var i=[7][r]();i["return"]=function(){o=!0},Array.from(i,function(){throw 2})}catch(s){}t.exports=function(t,e){if(!e&&!o)return!1;var n=!1;try{var i=[7],s=i[r]();s.next=function(){n=!0},i[r]=function(){return s},t(i)}catch(a){}return n}},function(t,e){t.exports=function(t,e){return{value:e,done:!!t}}},function(t,e,n){var r,o,i,s=n(12),a=n(136).set,u=s.MutationObserver||s.WebKitMutationObserver,l=s.process,c=s.Promise,p="process"==n(24)(l),f=function(){
var t,e,n;for(p&&(t=l.domain)&&(l.domain=null,t.exit());r;)e=r.domain,n=r.fn,e&&e.enter(),n(),e&&e.exit(),r=r.next;o=void 0,t&&t.enter()};if(p)i=function(){l.nextTick(f)};else if(u){var h=1,d=document.createTextNode("");new u(f).observe(d,{characterData:!0}),i=function(){d.data=h=-h}}else i=c&&c.resolve?function(){c.resolve().then(f)}:function(){a.call(s,f)};t.exports=function(t){var e={fn:t,next:void 0,domain:p&&l.domain};o&&(o.next=e),r||(r=e,i()),o=e}},function(t,e,n){var r=n(9),o=n(59),i=n(50);t.exports=n(38)(function(){var t=Object.assign,e={},n={},r=Symbol(),o="abcdefghijklmnopqrst";return e[r]=7,o.split("").forEach(function(t){n[t]=t}),7!=t({},e)[r]||Object.keys(t({},n)).join("")!=o})?function(t,e){for(var n=o(t),s=arguments,a=s.length,u=1,l=r.getKeys,c=r.getSymbols,p=r.isEnum;a>u;)for(var f,h=i(s[u++]),d=c?l(h).concat(c(h)):l(h),y=d.length,v=0;y>v;)p.call(h,f=d[v++])&&(n[f]=h[f]);return n}:Object.assign},function(t,e,n){var r=n(55);t.exports=function(t,e){for(var n in e)r(t,n,e[n]);return t}},function(t,e){t.exports=Object.is||function(t,e){return t===e?0!==t||1/t===1/e:t!=t&&e!=e}},function(t,e,n){"use strict";var r=n(8),o=n(9),i=n(37),s=n(10)("species");t.exports=function(t){var e=r[t];i&&e&&!e[s]&&o.setDesc(e,s,{configurable:!0,get:function(){return this}})}},function(t,e,n){var r=n(12),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,e,n){var r=n(15),o=n(34),i=n(10)("species");t.exports=function(t,e){var n,s=r(t).constructor;return void 0===s||void 0==(n=r(s)[i])?e:o(n)}},function(t,e){t.exports=function(t,e,n){if(!(t instanceof e))throw TypeError(n+": use the 'new' operator!");return t}},function(t,e,n){var r=n(57),o=n(36);t.exports=function(t){return function(e,n){var i,s,a=String(o(e)),u=r(n),l=a.length;return 0>u||u>=l?t?"":void 0:(i=a.charCodeAt(u),55296>i||i>56319||u+1===l||(s=a.charCodeAt(u+1))<56320||s>57343?t?a.charAt(u):i:t?a.slice(u,u+2):(i-55296<<10)+(s-56320)+65536)}}},function(t,e,n){var r,o,i,s=n(19),a=n(121),u=n(120),l=n(118),c=n(12),p=c.process,f=c.setImmediate,h=c.clearImmediate,d=c.MessageChannel,y=0,v={},m="onreadystatechange",g=function(){var t=+this;if(v.hasOwnProperty(t)){var e=v[t];delete v[t],e()}},x=function(t){g.call(t.data)};f&&h||(f=function(t){for(var e=[],n=1;arguments.length>n;)e.push(arguments[n++]);return v[++y]=function(){a("function"==typeof t?t:Function(t),e)},r(y),y},h=function(t){delete v[t]},"process"==n(24)(p)?r=function(t){p.nextTick(s(g,t,1))}:d?(o=new d,i=o.port2,o.port1.onmessage=x,r=s(i.postMessage,i,1)):c.addEventListener&&"function"==typeof postMessage&&!c.importScripts?(r=function(t){c.postMessage(t+"","*")},c.addEventListener("message",x,!1)):r=m in l("script")?function(t){u.appendChild(l("script"))[m]=function(){u.removeChild(this),g.call(t)}}:function(t){setTimeout(s(g,t,1),0)}),t.exports={set:f,clear:h}},function(t,e,n){var r=n(57),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,e){var n=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++n+r).toString(36))}},function(t,e,n){var r=n(15),o=n(60);t.exports=n(8).getIterator=function(t){var e=o(t);if("function"!=typeof e)throw TypeError(t+" is not iterable!");return r(e.call(t))}},function(t,e,n){var r=n(35),o=n(10)("iterator"),i=n(16);t.exports=n(8).isIterable=function(t){var e=Object(t);return void 0!==e[o]||"@@iterator"in e||i.hasOwnProperty(r(e))}},function(t,e,n){"use strict";var r=n(117),o=n(126),i=n(16),s=n(58);t.exports=n(51)(Array,"Array",function(t,e){this._t=s(t),this._i=0,this._k=e},function(){var t=this._t,e=this._k,n=this._i++;return!t||n>=t.length?(this._t=void 0,o(1)):"keys"==e?o(0,n):"values"==e?o(0,t[n]):o(0,[n,t[n]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,e,n){var r=n(20);r(r.S+r.F,"Object",{assign:n(128)})},function(t,e,n){var r=n(58);n(53)("getOwnPropertyDescriptor",function(t){return function(e,n){return t(r(e),n)}})},function(t,e,n){var r=n(59);n(53)("keys",function(t){return function(e){return t(r(e))}})},function(t,e,n){var r=n(20);r(r.S,"Object",{setPrototypeOf:n(56).set})},function(t,e){},function(t,e,n){"use strict";var r,o=n(9),i=n(52),s=n(12),a=n(19),u=n(35),l=n(20),c=n(25),p=n(15),f=n(34),h=n(134),d=n(119),y=n(56).set,v=n(130),m=n(10)("species"),g=n(133),x=n(127),b="Promise",k=s.process,_="process"==u(k),P=s[b],T=function(t){var e=new P(function(){});return t&&(e.constructor=Object),P.resolve(e)===e},O=function(){function t(e){var n=new P(e);return y(n,t.prototype),n}var e=!1;try{if(e=P&&P.resolve&&T(),y(t,P),t.prototype=o.create(P.prototype,{constructor:{value:t}}),t.resolve(5).then(function(){})instanceof t||(e=!1),e&&n(37)){var r=!1;P.resolve(o.setDesc({},"then",{get:function(){r=!0}})),e=r}}catch(i){e=!1}return e}(),w=function(t,e){return i&&t===P&&e===r?!0:v(t,e)},M=function(t){var e=p(t)[m];return void 0!=e?e:t},E=function(t){var e;return c(t)&&"function"==typeof(e=t.then)?e:!1},C=function(t){var e,n;this.promise=new t(function(t,r){if(void 0!==e||void 0!==n)throw TypeError("Bad Promise constructor");e=t,n=r}),this.resolve=f(e),this.reject=f(n)},S=function(t){try{t()}catch(e){return{error:e}}},j=function(t,e){if(!t.n){t.n=!0;var n=t.c;x(function(){for(var r=t.v,o=1==t.s,i=0,a=function(e){var n,i,s=o?e.ok:e.fail,a=e.resolve,u=e.reject;try{s?(o||(t.h=!0),n=s===!0?r:s(r),n===e.promise?u(TypeError("Promise-chain cycle")):(i=E(n))?i.call(n,a,u):a(n)):u(r)}catch(l){u(l)}};n.length>i;)a(n[i++]);n.length=0,t.n=!1,e&&setTimeout(function(){var e,n,o=t.p;A(o)&&(_?k.emit("unhandledRejection",r,o):(e=s.onunhandledrejection)?e({promise:o,reason:r}):(n=s.console)&&n.error&&n.error("Unhandled promise rejection",r)),t.a=void 0},1)})}},A=function(t){var e,n=t._d,r=n.a||n.c,o=0;if(n.h)return!1;for(;r.length>o;)if(e=r[o++],e.fail||!A(e.promise))return!1;return!0},L=function(t){var e=this;e.d||(e.d=!0,e=e.r||e,e.v=t,e.s=2,e.a=e.c.slice(),j(e,!0))},I=function(t){var e,n=this;if(!n.d){n.d=!0,n=n.r||n;try{if(n.p===t)throw TypeError("Promise can't be resolved itself");(e=E(t))?x(function(){var r={r:n,d:!1};try{e.call(t,a(I,r,1),a(L,r,1))}catch(o){L.call(r,o)}}):(n.v=t,n.s=1,j(n,!1))}catch(r){L.call({r:n,d:!1},r)}}};O||(P=function(t){f(t);var e=this._d={p:h(this,P,b),c:[],a:void 0,s:0,d:!1,v:void 0,h:!1,n:!1};try{t(a(I,e,1),a(L,e,1))}catch(n){L.call(e,n)}},n(129)(P.prototype,{then:function(t,e){var n=new C(g(this,P)),r=n.promise,o=this._d;return n.ok="function"==typeof t?t:!0,n.fail="function"==typeof e&&e,o.c.push(n),o.a&&o.a.push(n),o.s&&j(o,!1),r},"catch":function(t){return this.then(void 0,t)}})),l(l.G+l.W+l.F*!O,{Promise:P}),n(40)(P,b),n(131)(b),r=n(8)[b],l(l.S+l.F*!O,b,{reject:function(t){var e=new C(this),n=e.reject;return n(t),e.promise}}),l(l.S+l.F*(!O||T(!0)),b,{resolve:function(t){if(t instanceof P&&w(t.constructor,this))return t;var e=new C(this),n=e.resolve;return n(t),e.promise}}),l(l.S+l.F*!(O&&n(125)(function(t){P.all(t)["catch"](function(){})})),b,{all:function(t){var e=M(this),n=new C(e),r=n.resolve,i=n.reject,s=[],a=S(function(){d(t,!1,s.push,s);var n=s.length,a=Array(n);n?o.each.call(s,function(t,o){var s=!1;e.resolve(t).then(function(t){s||(s=!0,a[o]=t,--n||r(a))},i)}):r(a)});return a&&i(a.error),n.promise},race:function(t){var e=M(this),n=new C(e),r=n.reject,o=S(function(){d(t,!1,function(t){e.resolve(t).then(n.resolve,r)})});return o&&r(o.error),n.promise}})},function(t,e){},148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,function(t,e){function n(t,e){for(var n=-1,r=e.length,o=t.length;++n<r;)t[o+n]=e[n];return t}t.exports=n},function(t,e,n){function r(t,e,n){for(var r=-1,i=o(e),s=i.length;++r<s;){var a=i[r],u=t[a],l=n(u,e[a],a,t,e);(l===l?l===u:u!==u)&&(void 0!==u||a in t)||(t[a]=l)}return t}var o=n(66);t.exports=r},function(t,e,n){function r(t,e){return null==e?t:o(e,i(e),t)}var o=n(167),i=n(66);t.exports=r},function(t,e){function n(t,e,n){n||(n={});for(var r=-1,o=e.length;++r<o;){var i=e[r];n[i]=t[i]}return n}t.exports=n},function(t,e,n){function r(t,e,n,l){l||(l=[]);for(var c=-1,p=t.length;++c<p;){var f=t[c];u(f)&&a(f)&&(n||s(f)||i(f))?e?r(f,e,n,l):o(l,f):n||(l[l.length]=f)}return l}var o=n(164),i=n(44),s=n(29),a=n(26),u=n(28);t.exports=r},function(t,e,n){var r=n(173),o=r();t.exports=o},function(t,e,n){function r(t,e){return o(t,e,i)}var o=n(169),i=n(67);t.exports=r},function(t,e){function n(t){return function(e){return null==e?void 0:e[t]}}t.exports=n},function(t,e,n){function r(t){return s(function(e,n){var r=-1,s=null==e?0:n.length,a=s>2?n[s-2]:void 0,u=s>2?n[2]:void 0,l=s>1?n[s-1]:void 0;for("function"==typeof a?(a=o(a,l,5),s-=2):(a="function"==typeof l?l:void 0,s-=a?1:0),u&&i(n[0],n[1],u)&&(a=3>s?void 0:a,s=1);++r<s;){var c=n[r];c&&t(e,c,a)}return e})}var o=n(62),i=n(175),s=n(61);t.exports=r},function(t,e,n){function r(t){return function(e,n,r){for(var i=o(e),s=r(e),a=s.length,u=t?a:-1;t?u--:++u<a;){var l=s[u];if(n(i[l],l,i)===!1)break}return e}}var o=n(64);t.exports=r},function(t,e,n){var r=n(171),o=r("length");t.exports=o},function(t,e,n){function r(t,e,n){if(!s(n))return!1;var r=typeof e;if("number"==r?o(n)&&i(e,n.length):"string"==r&&e in n){var a=n[e];return t===t?t===a:a!==a}return!1}var o=n(26),i=n(43),s=n(17);t.exports=r},function(t,e,n){function r(t,e){t=o(t);for(var n=-1,r=e.length,i={};++n<r;){var s=e[n];s in t&&(i[s]=t[s])}return i}var o=n(64);t.exports=r},function(t,e,n){function r(t,e){var n={};return o(t,function(t,r,o){e(t,r,o)&&(n[r]=t)}),n}var o=n(170);t.exports=r},function(t,e,n){function r(t){for(var e=u(t),n=e.length,r=n&&t.length,l=!!r&&a(r)&&(i(t)||o(t)),p=-1,f=[];++p<n;){var h=e[p];(l&&s(h,r)||c.call(t,h))&&f.push(h)}return f}var o=n(44),i=n(29),s=n(43),a=n(27),u=n(67),l=Object.prototype,c=l.hasOwnProperty;t.exports=r},function(t,e,n){function r(t){return o(t)&&a.call(t)==i}var o=n(17),i="[object Function]",s=Object.prototype,a=s.toString;t.exports=r},function(t,e,n){function r(t){return null==t?!1:o(t)?c.test(u.call(t)):i(t)&&s.test(t)}var o=n(179),i=n(28),s=/^\[object .+?Constructor\]$/,a=Object.prototype,u=Function.prototype.toString,l=a.hasOwnProperty,c=RegExp("^"+u.call(l).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");t.exports=r},function(t,e,n){var r=n(168),o=n(62),i=n(176),s=n(177),a=n(61),u=a(function(t,e){return null==t?{}:"function"==typeof e[0]?s(t,o(e[0],e[1],3)):i(t,r(e))});t.exports=u},function(t,e){function n(t){return t}t.exports=n},function(t,e,n){function r(t){delete t.ref}var o=n(6),i=n(30),s=n(190),a=o.createFactory(n(184)),u=n(185),l=n(189),c=n(30).unstable_renderSubtreeIntoContainer,p=s.canUseDOM?window.HTMLElement:{};t.exports=o.createClass({displayName:"Modal",statics:{setAppElement:u.setElement,injectCSS:function(){}},propTypes:{isOpen:o.PropTypes.bool.isRequired,style:o.PropTypes.shape({content:o.PropTypes.object,overlay:o.PropTypes.object}),appElement:o.PropTypes.instanceOf(p),onRequestClose:o.PropTypes.func,closeTimeoutMS:o.PropTypes.number,ariaHideApp:o.PropTypes.bool},getDefaultProps:function(){return{isOpen:!1,ariaHideApp:!0,closeTimeoutMS:0}},componentDidMount:function(){this.node=document.createElement("div"),this.node.className="ReactModalPortal",document.body.appendChild(this.node),this.renderPortal(this.props)},componentWillReceiveProps:function(t){this.renderPortal(t)},componentWillUnmount:function(){i.unmountComponentAtNode(this.node),document.body.removeChild(this.node)},renderPortal:function(t){t.isOpen?l(document.body).add("ReactModal__Body--open"):l(document.body).remove("ReactModal__Body--open"),t.ariaHideApp&&u.toggle(t.isOpen,t.appElement),r(t),this.portal=c(this,a(t),this.node)},render:function(){return o.DOM.noscript()}})},function(t,e,n){function r(t){t.stopPropagation()}var o=n(6),i=o.DOM.div,s=n(186),a=n(187),u=n(191),l={overlay:{base:"ReactModal__Overlay",afterOpen:"ReactModal__Overlay--after-open",beforeClose:"ReactModal__Overlay--before-close"},content:{base:"ReactModal__Content",afterOpen:"ReactModal__Content--after-open",beforeClose:"ReactModal__Content--before-close"}},c={overlay:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(255, 255, 255, 0.75)"},content:{position:"absolute",top:"40px",left:"40px",right:"40px",bottom:"40px",border:"1px solid #ccc",background:"#fff",overflow:"auto",WebkitOverflowScrolling:"touch",borderRadius:"4px",outline:"none",padding:"20px"}};t.exports=o.createClass({displayName:"ModalPortal",getDefaultProps:function(){return{style:{overlay:{},content:{}}}},getInitialState:function(){return{afterOpen:!1,beforeClose:!1}},componentDidMount:function(){this.props.isOpen&&(this.setFocusAfterRender(!0),this.open())},componentWillUnmount:function(){clearTimeout(this.closeTimer)},componentWillReceiveProps:function(t){!this.props.isOpen&&t.isOpen?(this.setFocusAfterRender(!0),this.open()):this.props.isOpen&&!t.isOpen&&this.close()},componentDidUpdate:function(){this.focusAfterRender&&(this.focusContent(),this.setFocusAfterRender(!1))},setFocusAfterRender:function(t){this.focusAfterRender=t},open:function(){s.setupScopedFocus(this.node),s.markForFocusLater(),this.setState({isOpen:!0},function(){this.setState({afterOpen:!0})}.bind(this))},close:function(){this.ownerHandlesClose()&&(this.props.closeTimeoutMS>0?this.closeWithTimeout():this.closeWithoutTimeout())},focusContent:function(){this.refs.content.focus()},closeWithTimeout:function(){this.setState({beforeClose:!0},function(){this.closeTimer=setTimeout(this.closeWithoutTimeout,this.props.closeTimeoutMS)}.bind(this))},closeWithoutTimeout:function(){this.setState({afterOpen:!1,beforeClose:!1},this.afterClose)},afterClose:function(){s.returnFocus(),s.teardownScopedFocus()},handleKeyDown:function(t){9==t.keyCode&&a(this.refs.content,t),27==t.keyCode&&this.requestClose()},handleOverlayClick:function(){this.ownerHandlesClose()?this.requestClose():this.focusContent()},requestClose:function(){this.ownerHandlesClose()&&this.props.onRequestClose()},ownerHandlesClose:function(){return this.props.onRequestClose},shouldBeClosed:function(){return!this.props.isOpen&&!this.state.beforeClose},buildClassName:function(t,e){var n=l[t].base;return this.state.afterOpen&&(n+=" "+l[t].afterOpen),this.state.beforeClose&&(n+=" "+l[t].beforeClose),e?n+" "+e:n},render:function(){return this.shouldBeClosed()?i():i({ref:"overlay",className:this.buildClassName("overlay",this.props.overlayClassName),style:u({},c.overlay,this.props.style.overlay||{}),onClick:this.handleOverlayClick},i({ref:"content",style:u({},c.content,this.props.style.content||{}),className:this.buildClassName("content",this.props.className),tabIndex:"-1",onClick:r,onKeyDown:this.handleKeyDown},this.props.children))}})},function(t,e){function n(t){if("string"==typeof t){var e=document.querySelectorAll(t);t="length"in e?e[0]:e}u=t||u}function r(t){s(t),(t||u).setAttribute("aria-hidden","true")}function o(t){s(t),(t||u).removeAttribute("aria-hidden")}function i(t,e){t?r(e):o(e)}function s(t){if(!t&&!u)throw new Error("react-modal: You must set an element with `Modal.setAppElement(el)` to make this accessible")}function a(){u=document.body}var u="undefined"!=typeof document?document.body:null;e.toggle=i,e.setElement=n,e.show=o,e.hide=r,e.resetForTesting=a},function(t,e,n){function r(t){u=!0}function o(t){if(u){if(u=!1,!s)return;setTimeout(function(){if(!s.contains(document.activeElement)){var t=i(s)[0]||s;t.focus()}},0)}}var i=n(68),s=null,a=null,u=!1;e.markForFocusLater=function(){a=document.activeElement},e.returnFocus=function(){try{a.focus()}catch(t){console.warn("You tried to return focus to "+a+" but it is not in the DOM anymore")}a=null},e.setupScopedFocus=function(t){s=t,window.addEventListener?(window.addEventListener("blur",r,!1),document.addEventListener("focus",o,!0)):(window.attachEvent("onBlur",r),document.attachEvent("onFocus",o))},e.teardownScopedFocus=function(){s=null,window.addEventListener?(window.removeEventListener("blur",r),document.removeEventListener("focus",o)):(window.detachEvent("onBlur",r),document.detachEvent("onFocus",o))}},function(t,e,n){var r=n(68);t.exports=function(t,e){var n=r(t),o=n[e.shiftKey?0:n.length-1],i=o===document.activeElement||t===document.activeElement;if(i){e.preventDefault();var s=n[e.shiftKey?n.length-1:0];s.focus()}}},function(t,e,n){t.exports=n(183)},function(t,e){function n(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0,r=t.length;r>n;n++)if(t[n]===e)return n;return-1}function r(t){if(!(this instanceof r))return new r(t);t||(t={}),t.nodeType&&(t={el:t}),this.opts=t,this.el=t.el||document.body,"object"!=typeof this.el&&(this.el=document.querySelector(this.el))}t.exports=function(t){return new r(t)},r.prototype.add=function(t){var e=this.el;if(e){if(""===e.className)return e.className=t;var r=e.className.split(" ");return n(r,t)>-1?r:(r.push(t),e.className=r.join(" "),r)}},r.prototype.remove=function(t){var e=this.el;if(e&&""!==e.className){var r=e.className.split(" "),o=n(r,t);return o>-1&&r.splice(o,1),e.className=r.join(" "),r}},r.prototype.has=function(t){var e=this.el;if(e){var r=e.className.split(" ");return n(r,t)>-1}},r.prototype.toggle=function(t){var e=this.el;e&&(this.has(t)?this.remove(t):this.add(t))}},function(t,e,n){var r;!function(){"use strict";var o=!("undefined"==typeof window||!window.document||!window.document.createElement),i={canUseDOM:o,canUseWorkers:"undefined"!=typeof Worker,canUseEventListeners:o&&!(!window.addEventListener&&!window.attachEvent),canUseViewport:o&&!!window.screen};r=function(){return i}.call(e,n,e,t),!(void 0!==r&&(t.exports=r))}()},function(t,e,n){function r(t,e,n){for(var r=-1,o=s(e),i=o.length;++r<i;){var a=o[r],u=t[a],l=n(u,e[a],a,t,e);(l===l?l===u:u!==u)&&(void 0!==u||a in t)||(t[a]=l)}return t}var o=n(192),i=n(194),s=n(69),a=i(function(t,e,n){return n?r(t,e,n):o(t,e)});t.exports=a},function(t,e,n){function r(t,e){return null==e?t:o(e,i(e),t)}var o=n(193),i=n(69);t.exports=r},function(t,e){function n(t,e,n){n||(n={});for(var r=-1,o=e.length;++r<o;){var i=e[r];n[i]=t[i]}return n}t.exports=n},function(t,e,n){function r(t){return s(function(e,n){var r=-1,s=null==e?0:n.length,a=s>2?n[s-2]:void 0,u=s>2?n[2]:void 0,l=s>1?n[s-1]:void 0;for("function"==typeof a?(a=o(a,l,5),s-=2):(a="function"==typeof l?l:void 0,s-=a?1:0),u&&i(n[0],n[1],u)&&(a=3>s?void 0:a,s=1);++r<s;){var c=n[r];c&&t(e,c,a)}return e})}var o=n(195),i=n(196),s=n(197);t.exports=r},function(t,e){function n(t,e,n){if("function"!=typeof t)return r;if(void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 3:return function(n,r,o){return t.call(e,n,r,o)};case 4:return function(n,r,o,i){return t.call(e,n,r,o,i)};case 5:return function(n,r,o,i,s){return t.call(e,n,r,o,i,s)}}return function(){return t.apply(e,arguments)}}function r(t){return t}t.exports=n},function(t,e){function n(t){return function(e){return null==e?void 0:e[t]}}function r(t){return null!=t&&s(c(t))}function o(t,e){return t="number"==typeof t||u.test(t)?+t:-1,e=null==e?l:e,t>-1&&t%1==0&&e>t}function i(t,e,n){if(!a(n))return!1;var i=typeof e;if("number"==i?r(n)&&o(e,n.length):"string"==i&&e in n){var s=n[e];return t===t?t===s:s!==s}return!1}function s(t){return"number"==typeof t&&t>-1&&t%1==0&&l>=t}function a(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}var u=/^\d+$/,l=9007199254740991,c=n("length");t.exports=i},function(t,e){function n(t,e){if("function"!=typeof t)throw new TypeError(r);return e=o(void 0===e?t.length-1:+e||0,0),function(){for(var n=arguments,r=-1,i=o(n.length-e,0),s=Array(i);++r<i;)s[r]=n[e+r];switch(e){case 0:return t.call(this,s);case 1:return t.call(this,n[0],s);case 2:return t.call(this,n[0],n[1],s)}var a=Array(e+1);for(r=-1;++r<e;)a[r]=n[r];return a[e]=s,t.apply(this,a)}}var r="Expected a function",o=Math.max;t.exports=n},function(t,e){function n(t){return!!t&&"object"==typeof t}function r(t,e){var n=null==t?void 0:t[e];return s(n)?n:void 0}function o(t){return i(t)&&f.call(t)==a}function i(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function s(t){return null==t?!1:o(t)?h.test(c.call(t)):n(t)&&u.test(t)}var a="[object Function]",u=/^\[object .+?Constructor\]$/,l=Object.prototype,c=Function.prototype.toString,p=l.hasOwnProperty,f=l.toString,h=RegExp("^"+c.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");t.exports=r},function(t,e){function n(t){return!!t&&"object"==typeof t}function r(t){return function(e){return null==e?void 0:e[t]}}function o(t){return null!=t&&i(p(t))}function i(t){return"number"==typeof t&&t>-1&&t%1==0&&c>=t}function s(t){return n(t)&&o(t)&&u.call(t,"callee")&&!l.call(t,"callee")}var a=Object.prototype,u=a.hasOwnProperty,l=a.propertyIsEnumerable,c=9007199254740991,p=r("length");t.exports=s},function(t,e){function n(t){return!!t&&"object"==typeof t}function r(t,e){var n=null==t?void 0:t[e];return a(n)?n:void 0}function o(t){return"number"==typeof t&&t>-1&&t%1==0&&m>=t}function i(t){return s(t)&&d.call(t)==l}function s(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function a(t){return null==t?!1:i(t)?y.test(f.call(t)):n(t)&&c.test(t)}var u="[object Array]",l="[object Function]",c=/^\[object .+?Constructor\]$/,p=Object.prototype,f=Function.prototype.toString,h=p.hasOwnProperty,d=p.toString,y=RegExp("^"+f.call(h).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),v=r(Array,"isArray"),m=9007199254740991,g=v||function(t){return n(t)&&o(t.length)&&d.call(t)==u};t.exports=g},function(t,e){t.exports=s},function(t,e){t.exports=a},function(t,e){t.exports=u}]))});

},{"cartodb-client":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/cartodb-client/index.js","d3":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/d3/d3.js","intro.js":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/intro.js/intro.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","queue-async":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/queue-async/build/queue.js","react":"react","react-dom":"react-dom","react-leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/cartodb-client/index.js":[function(require,module,exports){
module.exports = require("./src/cartodb-client");

},{"./src/cartodb-client":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/cartodb-client/src/cartodb-client.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/cartodb-client/src/cartodb-client.js":[function(require,module,exports){
(function() {
  "use strict";

  function CartoDBClient(accountName,options) {

    options = options || {};

    var that = this;

    options.apiroot     = options.apiroot      || "http://{accountName}.cartodb.com/api/v2/";
    options.format      = options.format       || "GeoJSON";
    options.accountName = options.accountName  || accountName;

    //
    // Request remote data
    //
    function request(uri, callback) {

      if (window && window.XMLHttpRequest) {
        var xmlHttp = null;

        xmlHttp = new window.XMLHttpRequest();

        xmlHttp.onreadystatechange = function() {
          if ((xmlHttp.readyState|0) === 4) {
            if ((xmlHttp.status|0) === 200 ) {

              callback(null, xmlHttp);
            } else {
              callback(xmlHttp);
            }
          }
        };

        xmlHttp.open( "GET", uri, true );
        return xmlHttp.send( null );
      } else {
        return false;
      }
    }

    //
    // Build a string from a template and data
    //
    function buildTemplate(template, data) {
      var outString = template;

      for (var i in data) {
        if (data.hasOwnProperty(i)) {
          outString = outString.split("{" + i + "}").join(data[i]);
        }
      }

      return outString;
    }

    //
    // Request from the CartoDb SQL endpoint
    //
    function sqlRequest(sql, callback, _options) {

      _options = _options || {};

      //
      // Override defaults
      //
      if (Object.keys(_options).length) {
        for (var i in _options) {

          if (_options.hasOwnProperty(i)) {

            options[i] = _options[i];

          }

        }
      }

      var url = buildTemplate([
        buildTemplate(options.apiroot, options),
        "sql",
        "?format=" + options.format,
        "&q=" + sql
      ].join(""), options);

      if (options.dangerouslyExposedAPIKey) {
        console.warn("Exposing API key in URL! Do not push this to production.");
        url += ("&api_key=" + options.dangerouslyExposedAPIKey);
      }

      return request(url,
        function (err, response) {

          try {
            callback(err, JSON.parse(response.responseText), response);
          } catch (err) {
            callback(err, null, response);
          }

        }
      );

    }

    //
    // Promise request
    function requestPromise(params) {
      var opts = normalizeOptions(params.options);

      var url = (params.sql) ? buildTemplate([
                  buildTemplate(opts.apiroot, opts),
                  "sql",
                  "?format=" + opts.format,
                  "&q=" + params.sql
                ].join(""), opts) : params.url;

      var key = params.key;


      return new Promise(function(resolve, reject) {

        if (window && window.XMLHttpRequest) {
          // Do the usual XHR stuff
          var req = new XMLHttpRequest();
          req.open('GET', url);

          req.onload = function() {
            // This is called even on 404 etc
            // so check the status
            if (req.status == 200) {
              // Resolve the promise with the response text
              return resolve({
                payload: req.response || req.responseText,
                id: key
              });
            }
            else {
              // Otherwise reject with the status text
              // which will hopefully be a meaningful error
              reject({
                payload: Error(req.statusText),
                id: key
              });
            }
          };

          // Handle network errors
          req.onerror = function() {
            reject({
              payload: Error("Network Error"),
              id: key
            });
          };

          // Make the request
          req.send();

        } else {
          reject({
            payload: Error("XMLHttpRequest not supported"),
            id: key
          });
        }
      });



    }

    //
    //
    //
    function normalizeOptions(_options) {
      _options = _options || {};

      var rsp = {};
      for (var key in options) {
        var value = (_options.hasOwnProperty(key)) ? _options[key] : options[key];
        rsp[key] = value;
      }

      return rsp;
    }

    //
    // Public interface
    //
    that.sqlRequest = sqlRequest;
    that.requestPromise = requestPromise;
    that.requestPromiseParallel = function(queue) {
      return Promise.all(
        queue.map(function(q){
          return requestPromise(q).then(function(rsp) {
            return {
              response: rsp,
              key: rsp.id
            };
          }).catch(function(err) {
            return err;
          });
        })
      )
    };

    that.requestPromiseJSON = function(params) {
      return requestPromise(params).then(function(rsp) {
        return {
          response: JSON.parse(rsp.payload),
          key: rsp.id
        };
      }).catch(function(err) {
        return err;
      });
    };

    that.requestPromiseParallelJSON = function(queue) {
      return Promise.all(
        queue.map(that.requestPromiseJSON)
      )
    };

    return that;

  }



  //
  // If this is a CommonJS module
  //
  if (typeof module === "object" && module.exports) {
    module.exports = CartoDBClient;
  }

  //
  // If this is an AMD module
  //
  if (typeof define === "function") {
    define(CartoDBClient);
  }

  //
  // If just exports and it's an object
  //
  if (typeof module !== "object" && typeof exports === "object") {
    exports.CartoDBClient = CartoDBClient;
  }

  //
  // If none of those, add it to Window (as long as there is nothing named samesies)
  //
  if (typeof define !== "function" && typeof window === "object") {
    if (!window.STMN) {
      window.STMN = {};
    }
    window.STMN.CartoDBClient = CartoDBClient;
  }

}());
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/d3/d3.js":[function(require,module,exports){
!function() {
  var d3 = {
    version: "3.5.16"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/flux/lib/Dispatcher.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))

},{"_process":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/process/browser.js","fbjs/lib/invariant":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/flux/node_modules/fbjs/lib/invariant.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/flux/node_modules/fbjs/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/process/browser.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/intro.js/intro.js":[function(require,module,exports){
/**
 * Intro.js v1.1.1
 * https://github.com/usablica/intro.js
 * MIT licensed
 *
 * Copyright (C) 2013 usabli.ca - A weekend project by Afshin Mehrabani (@afshinmeh)
 */

(function (root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports);
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['exports'], factory);
  } else {
    // Browser globals
    factory(root);
  }
} (this, function (exports) {
  //Default config/variables
  var VERSION = '1.1.1';

  /**
   * IntroJs main class
   *
   * @class IntroJs
   */
  function IntroJs(obj) {
    this._targetElement = obj;

    this._options = {
      /* Next button label in tooltip box */
      nextLabel: 'Next &rarr;',
      /* Previous button label in tooltip box */
      prevLabel: '&larr; Back',
      /* Skip button label in tooltip box */
      skipLabel: 'Skip',
      /* Done button label in tooltip box */
      doneLabel: 'Done',
      /* Default tooltip box position */
      tooltipPosition: 'bottom',
      /* Next CSS class for tooltip boxes */
      tooltipClass: '',
      /* CSS class that is added to the helperLayer */
      highlightClass: '',
      /* Close introduction when pressing Escape button? */
      exitOnEsc: true,
      /* Close introduction when clicking on overlay layer? */
      exitOnOverlayClick: true,
      /* Show step numbers in introduction? */
      showStepNumbers: true,
      /* Let user use keyboard to navigate the tour? */
      keyboardNavigation: true,
      /* Show tour control buttons? */
      showButtons: true,
      /* Show tour bullets? */
      showBullets: true,
      /* Show tour progress? */
      showProgress: false,
      /* Scroll to highlighted element? */
      scrollToElement: true,
      /* Set the overlay opacity */
      overlayOpacity: 0.8,
      /* Precedence of positions, when auto is enabled */
      positionPrecedence: ["bottom", "top", "right", "left"],
      /* Disable an interaction with element? */
      disableInteraction: false
    };
  }

  /**
   * Initiate a new introduction/guide from an element in the page
   *
   * @api private
   * @method _introForElement
   * @param {Object} targetElm
   * @returns {Boolean} Success or not?
   */
  function _introForElement(targetElm) {
    var introItems = [],
        self = this;

    if (this._options.steps) {
      //use steps passed programmatically
      for (var i = 0, stepsLength = this._options.steps.length; i < stepsLength; i++) {
        var currentItem = _cloneObject(this._options.steps[i]);
        //set the step
        currentItem.step = introItems.length + 1;
        //use querySelector function only when developer used CSS selector
        if (typeof(currentItem.element) === 'string') {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        }

        //intro without element
        if (typeof(currentItem.element) === 'undefined' || currentItem.element == null) {
          var floatingElementQuery = document.querySelector(".introjsFloatingElement");

          if (floatingElementQuery == null) {
            floatingElementQuery = document.createElement('div');
            floatingElementQuery.className = 'introjsFloatingElement';

            document.body.appendChild(floatingElementQuery);
          }

          currentItem.element  = floatingElementQuery;
          currentItem.position = 'floating';
        }

        if (currentItem.element != null) {
          introItems.push(currentItem);
        }
      }

    } else {
      //use steps from data-* annotations
      var allIntroSteps = targetElm.querySelectorAll('*[data-intro]');
      //if there's no element to intro
      if (allIntroSteps.length < 1) {
        return false;
      }

      //first add intro items with data-step
      for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
        var currentElement = allIntroSteps[i];
        var step = parseInt(currentElement.getAttribute('data-step'), 10);

        if (step > 0) {
          introItems[step - 1] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: parseInt(currentElement.getAttribute('data-step'), 10),
            tooltipClass: currentElement.getAttribute('data-tooltipClass'),
            highlightClass: currentElement.getAttribute('data-highlightClass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
          };
        }
      }

      //next add intro items without data-step
      //todo: we need a cleanup here, two loops are redundant
      var nextStep = 0;
      for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
        var currentElement = allIntroSteps[i];

        if (currentElement.getAttribute('data-step') == null) {

          while (true) {
            if (typeof introItems[nextStep] == 'undefined') {
              break;
            } else {
              nextStep++;
            }
          }

          introItems[nextStep] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: nextStep + 1,
            tooltipClass: currentElement.getAttribute('data-tooltipClass'),
            highlightClass: currentElement.getAttribute('data-highlightClass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
          };
        }
      }
    }

    //removing undefined/null elements
    var tempIntroItems = [];
    for (var z = 0; z < introItems.length; z++) {
      introItems[z] && tempIntroItems.push(introItems[z]);  // copy non-empty values to the end of the array
    }

    introItems = tempIntroItems;

    //Ok, sort all items with given steps
    introItems.sort(function (a, b) {
      return a.step - b.step;
    });

    //set it to the introJs object
    self._introItems = introItems;

    //add overlay layer to the page
    if(_addOverlayLayer.call(self, targetElm)) {
      //then, start the show
      _nextStep.call(self);

      var skipButton     = targetElm.querySelector('.introjs-skipbutton'),
          nextStepButton = targetElm.querySelector('.introjs-nextbutton');

      self._onKeyDown = function(e) {
        if (e.keyCode === 27 && self._options.exitOnEsc == true) {
          //escape key pressed, exit the intro
          //check if exit callback is defined
          if (self._introExitCallback != undefined) {
            self._introExitCallback.call(self);
          }
          _exitIntro.call(self, targetElm);
        } else if(e.keyCode === 37) {
          //left arrow
          _previousStep.call(self);
        } else if (e.keyCode === 39) {
          //right arrow
          _nextStep.call(self);
        } else if (e.keyCode === 13) {
          //srcElement === ie
          var target = e.target || e.srcElement;
          if (target && target.className.indexOf('introjs-prevbutton') > 0) {
            //user hit enter while focusing on previous button
            _previousStep.call(self);
          } else if (target && target.className.indexOf('introjs-skipbutton') > 0) {
            //user hit enter while focusing on skip button
            if (self._introItems.length - 1 == self._currentStep && typeof (self._introCompleteCallback) === 'function') {
                self._introCompleteCallback.call(self);
            }
            //check if any callback is defined
            if (self._introExitCallback != undefined) {
              self._introExitCallback.call(self);
            }
            _exitIntro.call(self, targetElm);
          } else {
            //default behavior for responding to enter
            _nextStep.call(self);
          }

          //prevent default behaviour on hitting Enter, to prevent steps being skipped in some browsers
          if(e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }
      };

      self._onResize = function(e) {
        _setHelperLayerPosition.call(self, document.querySelector('.introjs-helperLayer'));
        _setHelperLayerPosition.call(self, document.querySelector('.introjs-tooltipReferenceLayer'));
      };

      if (window.addEventListener) {
        if (this._options.keyboardNavigation) {
          window.addEventListener('keydown', self._onKeyDown, true);
        }
        //for window resize
        window.addEventListener('resize', self._onResize, true);
      } else if (document.attachEvent) { //IE
        if (this._options.keyboardNavigation) {
          document.attachEvent('onkeydown', self._onKeyDown);
        }
        //for window resize
        document.attachEvent('onresize', self._onResize);
      }
    }
    return false;
  }

 /*
   * makes a copy of the object
   * @api private
   * @method _cloneObject
  */
  function _cloneObject(object) {
      if (object == null || typeof (object) != 'object' || typeof (object.nodeType) != 'undefined') {
        return object;
      }
      var temp = {};
      for (var key in object) {
        if (typeof (jQuery) != 'undefined' && object[key] instanceof jQuery) {
          temp[key] = object[key];
        } else {
          temp[key] = _cloneObject(object[key]);
        }
      }
      return temp;
  }
  /**
   * Go to specific step of introduction
   *
   * @api private
   * @method _goToStep
   */
  function _goToStep(step) {
    //because steps starts with zero
    this._currentStep = step - 2;
    if (typeof (this._introItems) !== 'undefined') {
      _nextStep.call(this);
    }
  }

  /**
   * Go to next step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _nextStep() {
    this._direction = 'forward';

    if (typeof (this._currentStep) === 'undefined') {
      this._currentStep = 0;
    } else {
      ++this._currentStep;
    }

    if ((this._introItems.length) <= this._currentStep) {
      //end of the intro
      //check if any callback is defined
      if (typeof (this._introCompleteCallback) === 'function') {
        this._introCompleteCallback.call(this);
      }
      _exitIntro.call(this, this._targetElement);
      return;
    }

    var nextStep = this._introItems[this._currentStep];
    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Go to previous step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _previousStep() {
    this._direction = 'backward';

    if (this._currentStep === 0) {
      return false;
    }

    var nextStep = this._introItems[--this._currentStep];
    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Exit from intro
   *
   * @api private
   * @method _exitIntro
   * @param {Object} targetElement
   */
  function _exitIntro(targetElement) {
    //remove overlay layer from the page
    var overlayLayer = targetElement.querySelector('.introjs-overlay');

    //return if intro already completed or skipped
    if (overlayLayer == null) {
      return;
    }

    //for fade-out animation
    overlayLayer.style.opacity = 0;
    setTimeout(function () {
      if (overlayLayer.parentNode) {
        overlayLayer.parentNode.removeChild(overlayLayer);
      }
    }, 500);

    //remove all helper layers
    var helperLayer = targetElement.querySelector('.introjs-helperLayer');
    if (helperLayer) {
      helperLayer.parentNode.removeChild(helperLayer);
    }

    var referenceLayer = targetElement.querySelector('.introjs-tooltipReferenceLayer');
    if (referenceLayer) {
      referenceLayer.parentNode.removeChild(referenceLayer);
    }
    //remove disableInteractionLayer
    var disableInteractionLayer = targetElement.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer) {
      disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
    }

    //remove intro floating element
    var floatingElement = document.querySelector('.introjsFloatingElement');
    if (floatingElement) {
      floatingElement.parentNode.removeChild(floatingElement);
    }

    //remove `introjs-showElement` class from the element
    var showElement = document.querySelector('.introjs-showElement');
    if (showElement) {
      showElement.className = showElement.className.replace(/introjs-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, ''); // This is a manual trim.
    }

    //remove `introjs-fixParent` class from the elements
    var fixParents = document.querySelectorAll('.introjs-fixParent');
    if (fixParents && fixParents.length > 0) {
      for (var i = fixParents.length - 1; i >= 0; i--) {
        fixParents[i].className = fixParents[i].className.replace(/introjs-fixParent/g, '').replace(/^\s+|\s+$/g, '');
      }
    }

    //clean listeners
    if (window.removeEventListener) {
      window.removeEventListener('keydown', this._onKeyDown, true);
    } else if (document.detachEvent) { //IE
      document.detachEvent('onkeydown', this._onKeyDown);
    }

    //set the step to zero
    this._currentStep = undefined;
  }

  /**
   * Render tooltip box in the page
   *
   * @api private
   * @method _placeTooltip
   * @param {HTMLElement} targetElement
   * @param {HTMLElement} tooltipLayer
   * @param {HTMLElement} arrowLayer
   * @param {HTMLElement} helperNumberLayer
   */
  function _placeTooltip(targetElement, tooltipLayer, arrowLayer, helperNumberLayer) {
    var tooltipCssClass = '',
        currentStepObj,
        tooltipOffset,
        targetOffset,
        windowSize,
        currentTooltipPosition;

    //reset the old style
    tooltipLayer.style.top        = null;
    tooltipLayer.style.right      = null;
    tooltipLayer.style.bottom     = null;
    tooltipLayer.style.left       = null;
    tooltipLayer.style.marginLeft = null;
    tooltipLayer.style.marginTop  = null;

    arrowLayer.style.display = 'inherit';

    if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
      helperNumberLayer.style.top  = null;
      helperNumberLayer.style.left = null;
    }

    //prevent error when `this._currentStep` is undefined
    if (!this._introItems[this._currentStep]) return;

    //if we have a custom css class for each step
    currentStepObj = this._introItems[this._currentStep];
    if (typeof (currentStepObj.tooltipClass) === 'string') {
      tooltipCssClass = currentStepObj.tooltipClass;
    } else {
      tooltipCssClass = this._options.tooltipClass;
    }

    tooltipLayer.className = ('introjs-tooltip ' + tooltipCssClass).replace(/^\s+|\s+$/g, '');

    currentTooltipPosition = this._introItems[this._currentStep].position;
    if ((currentTooltipPosition == "auto" || this._options.tooltipPosition == "auto")) {
      if (currentTooltipPosition != "floating") { // Floating is always valid, no point in calculating
        currentTooltipPosition = _determineAutoPosition.call(this, targetElement, tooltipLayer, currentTooltipPosition);
      }
    }
    targetOffset  = _getOffset(targetElement);
    tooltipOffset = _getOffset(tooltipLayer);
    windowSize    = _getWinSize();
    switch (currentTooltipPosition) {
      case 'top':
        arrowLayer.className = 'introjs-arrow bottom';

        var tooltipLayerStyleLeft = 15;
        _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.bottom = (targetOffset.height +  20) + 'px';
        break;
      case 'right':
        tooltipLayer.style.left = (targetOffset.width + 20) + 'px';
        if (targetOffset.top + tooltipOffset.height > windowSize.height) {
          // In this case, right would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          arrowLayer.className = "introjs-arrow left-bottom";
          tooltipLayer.style.top = "-" + (tooltipOffset.height - targetOffset.height - 20) + "px";
        } else {
          arrowLayer.className = 'introjs-arrow left';
        }
        break;
      case 'left':
        if (this._options.showStepNumbers == true) {
          tooltipLayer.style.top = '15px';
        }

        if (targetOffset.top + tooltipOffset.height > windowSize.height) {
          // In this case, left would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          tooltipLayer.style.top = "-" + (tooltipOffset.height - targetOffset.height - 20) + "px";
          arrowLayer.className = 'introjs-arrow right-bottom';
        } else {
          arrowLayer.className = 'introjs-arrow right';
        }
        tooltipLayer.style.right = (targetOffset.width + 20) + 'px';

        break;
      case 'floating':
        arrowLayer.style.display = 'none';

        //we have to adjust the top and left of layer manually for intro items without element
        tooltipLayer.style.left   = '50%';
        tooltipLayer.style.top    = '50%';
        tooltipLayer.style.marginLeft = '-' + (tooltipOffset.width / 2)  + 'px';
        tooltipLayer.style.marginTop  = '-' + (tooltipOffset.height / 2) + 'px';

        if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
          helperNumberLayer.style.left = '-' + ((tooltipOffset.width / 2) + 18) + 'px';
          helperNumberLayer.style.top  = '-' + ((tooltipOffset.height / 2) + 18) + 'px';
        }

        break;
      case 'bottom-right-aligned':
        arrowLayer.className      = 'introjs-arrow top-right';

        var tooltipLayerStyleRight = 0;
        _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
        tooltipLayer.style.top    = (targetOffset.height +  20) + 'px';
        break;

      case 'bottom-middle-aligned':
        arrowLayer.className      = 'introjs-arrow top-middle';

        var tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2;
        if (_checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
          tooltipLayer.style.right = null;
          _checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
        }
        tooltipLayer.style.top = (targetOffset.height + 20) + 'px';
        break;

      case 'bottom-left-aligned':
      // Bottom-left-aligned is the same as the default bottom
      case 'bottom':
      // Bottom going to follow the default behavior
      default:
        arrowLayer.className = 'introjs-arrow top';

        var tooltipLayerStyleLeft = 0;
        _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.top    = (targetOffset.height +  20) + 'px';
        break;
    }
  }

  /**
   * Set tooltip left so it doesn't go off the right side of the window
   *
   * @return boolean true, if tooltipLayerStyleLeft is ok.  false, otherwise.
   */
  function _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer) {
    if (targetOffset.left + tooltipLayerStyleLeft + tooltipOffset.width > windowSize.width) {
      // off the right side of the window
      tooltipLayer.style.left = (windowSize.width - tooltipOffset.width - targetOffset.left) + 'px';
      return false;
    }
    tooltipLayer.style.left = tooltipLayerStyleLeft + 'px';
    return true;
  }

  /**
   * Set tooltip right so it doesn't go off the left side of the window
   *
   * @return boolean true, if tooltipLayerStyleRight is ok.  false, otherwise.
   */
  function _checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer) {
    if (targetOffset.left + targetOffset.width - tooltipLayerStyleRight - tooltipOffset.width < 0) {
      // off the left side of the window
      tooltipLayer.style.left = (-targetOffset.left) + 'px';
      return false;
    }
    tooltipLayer.style.right = tooltipLayerStyleRight + 'px';
    return true;
  }

  /**
   * Determines the position of the tooltip based on the position precedence and availability
   * of screen space.
   *
   * @param {Object} targetElement
   * @param {Object} tooltipLayer
   * @param {Object} desiredTooltipPosition
   *
   */
  function _determineAutoPosition(targetElement, tooltipLayer, desiredTooltipPosition) {

    // Take a clone of position precedence. These will be the available
    var possiblePositions = this._options.positionPrecedence.slice();

    var windowSize = _getWinSize();
    var tooltipHeight = _getOffset(tooltipLayer).height + 10;
    var tooltipWidth = _getOffset(tooltipLayer).width + 20;
    var targetOffset = _getOffset(targetElement);

    // If we check all the possible areas, and there are no valid places for the tooltip, the element
    // must take up most of the screen real estate. Show the tooltip floating in the middle of the screen.
    var calculatedPosition = "floating";

    // Check if the width of the tooltip + the starting point would spill off the right side of the screen
    // If no, neither bottom or top are valid
    if (targetOffset.left + tooltipWidth > windowSize.width || ((targetOffset.left + (targetOffset.width / 2)) - tooltipWidth) < 0) {
      _removeEntry(possiblePositions, "bottom");
      _removeEntry(possiblePositions, "top");
    } else {
      // Check for space below
      if ((targetOffset.height + targetOffset.top + tooltipHeight) > windowSize.height) {
        _removeEntry(possiblePositions, "bottom");
      }

      // Check for space above
      if (targetOffset.top - tooltipHeight < 0) {
        _removeEntry(possiblePositions, "top");
      }
    }

    // Check for space to the right
    if (targetOffset.width + targetOffset.left + tooltipWidth > windowSize.width) {
      _removeEntry(possiblePositions, "right");
    }

    // Check for space to the left
    if (targetOffset.left - tooltipWidth < 0) {
      _removeEntry(possiblePositions, "left");
    }

    // At this point, our array only has positions that are valid. Pick the first one, as it remains in order
    if (possiblePositions.length > 0) {
      calculatedPosition = possiblePositions[0];
    }

    // If the requested position is in the list, replace our calculated choice with that
    if (desiredTooltipPosition && desiredTooltipPosition != "auto") {
      if (possiblePositions.indexOf(desiredTooltipPosition) > -1) {
        calculatedPosition = desiredTooltipPosition;
      }
    }

    return calculatedPosition;
  }

  /**
   * Remove an entry from a string array if it's there, does nothing if it isn't there.
   *
   * @param {Array} stringArray
   * @param {String} stringToRemove
   */
  function _removeEntry(stringArray, stringToRemove) {
    if (stringArray.indexOf(stringToRemove) > -1) {
      stringArray.splice(stringArray.indexOf(stringToRemove), 1);
    }
  }

  /**
   * Update the position of the helper layer on the screen
   *
   * @api private
   * @method _setHelperLayerPosition
   * @param {Object} helperLayer
   */
  function _setHelperLayerPosition(helperLayer) {
    if (helperLayer) {
      //prevent error when `this._currentStep` in undefined
      if (!this._introItems[this._currentStep]) return;

      var currentElement  = this._introItems[this._currentStep],
          elementPosition = _getOffset(currentElement.element),
          widthHeightPadding = 10;

      if (currentElement.position == 'floating') {
        widthHeightPadding = 0;
      }

      //set new position to helper layer
      helperLayer.setAttribute('style', 'width: ' + (elementPosition.width  + widthHeightPadding)  + 'px; ' +
                                        'height:' + (elementPosition.height + widthHeightPadding)  + 'px; ' +
                                        'top:'    + (elementPosition.top    - 5)   + 'px;' +
                                        'left: '  + (elementPosition.left   - 5)   + 'px;');

    }
  }

  /**
   * Add disableinteraction layer and adjust the size and position of the layer
   *
   * @api private
   * @method _disableInteraction
   */
  function _disableInteraction () {
    var disableInteractionLayer = document.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer === null) {
      disableInteractionLayer = document.createElement('div');
      disableInteractionLayer.className = 'introjs-disableInteraction';
      this._targetElement.appendChild(disableInteractionLayer);
    }

    _setHelperLayerPosition.call(this, disableInteractionLayer);
  }

  /**
   * Show an element on the page
   *
   * @api private
   * @method _showElement
   * @param {Object} targetElement
   */
  function _showElement(targetElement) {

    if (typeof (this._introChangeCallback) !== 'undefined') {
      this._introChangeCallback.call(this, targetElement.element);
    }

    var self = this,
        oldHelperLayer = document.querySelector('.introjs-helperLayer'),
        oldReferenceLayer = document.querySelector('.introjs-tooltipReferenceLayer'),
        highlightClass = 'introjs-helperLayer',
        elementPosition = _getOffset(targetElement.element);

    //check for a current step highlight class
    if (typeof (targetElement.highlightClass) === 'string') {
      highlightClass += (' ' + targetElement.highlightClass);
    }
    //check for options highlight class
    if (typeof (this._options.highlightClass) === 'string') {
      highlightClass += (' ' + this._options.highlightClass);
    }

    if (oldHelperLayer != null) {
      var oldHelperNumberLayer = oldReferenceLayer.querySelector('.introjs-helperNumberLayer'),
          oldtooltipLayer      = oldReferenceLayer.querySelector('.introjs-tooltiptext'),
          oldArrowLayer        = oldReferenceLayer.querySelector('.introjs-arrow'),
          oldtooltipContainer  = oldReferenceLayer.querySelector('.introjs-tooltip'),
          skipTooltipButton    = oldReferenceLayer.querySelector('.introjs-skipbutton'),
          prevTooltipButton    = oldReferenceLayer.querySelector('.introjs-prevbutton'),
          nextTooltipButton    = oldReferenceLayer.querySelector('.introjs-nextbutton');

      //update or reset the helper highlight class
      oldHelperLayer.className = highlightClass;
      //hide the tooltip
      oldtooltipContainer.style.opacity = 0;
      oldtooltipContainer.style.display = "none";

      if (oldHelperNumberLayer != null) {
        var lastIntroItem = this._introItems[(targetElement.step - 2 >= 0 ? targetElement.step - 2 : 0)];

        if (lastIntroItem != null && (this._direction == 'forward' && lastIntroItem.position == 'floating') || (this._direction == 'backward' && targetElement.position == 'floating')) {
          oldHelperNumberLayer.style.opacity = 0;
        }
      }

      //set new position to helper layer
      _setHelperLayerPosition.call(self, oldHelperLayer);
      _setHelperLayerPosition.call(self, oldReferenceLayer);

      //remove `introjs-fixParent` class from the elements
      var fixParents = document.querySelectorAll('.introjs-fixParent');
      if (fixParents && fixParents.length > 0) {
        for (var i = fixParents.length - 1; i >= 0; i--) {
          fixParents[i].className = fixParents[i].className.replace(/introjs-fixParent/g, '').replace(/^\s+|\s+$/g, '');
        };
      }

      //remove old classes
      var oldShowElement = document.querySelector('.introjs-showElement');
      oldShowElement.className = oldShowElement.className.replace(/introjs-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, '');

      //we should wait until the CSS3 transition is competed (it's 0.3 sec) to prevent incorrect `height` and `width` calculation
      if (self._lastShowElementTimer) {
        clearTimeout(self._lastShowElementTimer);
      }
      self._lastShowElementTimer = setTimeout(function() {
        //set current step to the label
        if (oldHelperNumberLayer != null) {
          oldHelperNumberLayer.innerHTML = targetElement.step;
        }
        //set current tooltip text
        oldtooltipLayer.innerHTML = targetElement.intro;
        //set the tooltip position
        oldtooltipContainer.style.display = "block";
        _placeTooltip.call(self, targetElement.element, oldtooltipContainer, oldArrowLayer, oldHelperNumberLayer);

        //change active bullet
        oldReferenceLayer.querySelector('.introjs-bullets li > a.active').className = '';
        oldReferenceLayer.querySelector('.introjs-bullets li > a[data-stepnumber="' + targetElement.step + '"]').className = 'active';

        oldReferenceLayer.querySelector('.introjs-progress .introjs-progressbar').setAttribute('style', 'width:' + _getProgress.call(self) + '%;');

        //show the tooltip
        oldtooltipContainer.style.opacity = 1;
        if (oldHelperNumberLayer) oldHelperNumberLayer.style.opacity = 1;

        //reset button focus
        if (nextTooltipButton.tabIndex === -1) {
          //tabindex of -1 means we are at the end of the tour - focus on skip / done
          skipTooltipButton.focus();
        } else {
          //still in the tour, focus on next
          nextTooltipButton.focus();
        }
      }, 350);

    } else {
      var helperLayer       = document.createElement('div'),
          referenceLayer    = document.createElement('div'),
          arrowLayer        = document.createElement('div'),
          tooltipLayer      = document.createElement('div'),
          tooltipTextLayer  = document.createElement('div'),
          bulletsLayer      = document.createElement('div'),
          progressLayer     = document.createElement('div'),
          buttonsLayer      = document.createElement('div');

      helperLayer.className = highlightClass;
      referenceLayer.className = 'introjs-tooltipReferenceLayer';

      //set new position to helper layer
      _setHelperLayerPosition.call(self, helperLayer);
      _setHelperLayerPosition.call(self, referenceLayer);

      //add helper layer to target element
      this._targetElement.appendChild(helperLayer);
      this._targetElement.appendChild(referenceLayer);

      arrowLayer.className = 'introjs-arrow';

      tooltipTextLayer.className = 'introjs-tooltiptext';
      tooltipTextLayer.innerHTML = targetElement.intro;

      bulletsLayer.className = 'introjs-bullets';

      if (this._options.showBullets === false) {
        bulletsLayer.style.display = 'none';
      }

      var ulContainer = document.createElement('ul');

      for (var i = 0, stepsLength = this._introItems.length; i < stepsLength; i++) {
        var innerLi    = document.createElement('li');
        var anchorLink = document.createElement('a');

        anchorLink.onclick = function() {
          self.goToStep(this.getAttribute('data-stepnumber'));
        };

        if (i === (targetElement.step-1)) anchorLink.className = 'active';

        anchorLink.href = 'javascript:void(0);';
        anchorLink.innerHTML = "&nbsp;";
        anchorLink.setAttribute('data-stepnumber', this._introItems[i].step);

        innerLi.appendChild(anchorLink);
        ulContainer.appendChild(innerLi);
      }

      bulletsLayer.appendChild(ulContainer);

      progressLayer.className = 'introjs-progress';

      if (this._options.showProgress === false) {
        progressLayer.style.display = 'none';
      }
      var progressBar = document.createElement('div');
      progressBar.className = 'introjs-progressbar';
      progressBar.setAttribute('style', 'width:' + _getProgress.call(this) + '%;');

      progressLayer.appendChild(progressBar);

      buttonsLayer.className = 'introjs-tooltipbuttons';
      if (this._options.showButtons === false) {
        buttonsLayer.style.display = 'none';
      }

      tooltipLayer.className = 'introjs-tooltip';
      tooltipLayer.appendChild(tooltipTextLayer);
      tooltipLayer.appendChild(bulletsLayer);
      tooltipLayer.appendChild(progressLayer);

      //add helper layer number
      if (this._options.showStepNumbers == true) {
        var helperNumberLayer = document.createElement('span');
        helperNumberLayer.className = 'introjs-helperNumberLayer';
        helperNumberLayer.innerHTML = targetElement.step;
        referenceLayer.appendChild(helperNumberLayer);
      }

      tooltipLayer.appendChild(arrowLayer);
      referenceLayer.appendChild(tooltipLayer);

      //next button
      var nextTooltipButton = document.createElement('a');

      nextTooltipButton.onclick = function() {
        if (self._introItems.length - 1 != self._currentStep) {
          _nextStep.call(self);
        }
      };

      nextTooltipButton.href = 'javascript:void(0);';
      nextTooltipButton.innerHTML = this._options.nextLabel;

      //previous button
      var prevTooltipButton = document.createElement('a');

      prevTooltipButton.onclick = function() {
        if (self._currentStep != 0) {
          _previousStep.call(self);
        }
      };

      prevTooltipButton.href = 'javascript:void(0);';
      prevTooltipButton.innerHTML = this._options.prevLabel;

      //skip button
      var skipTooltipButton = document.createElement('a');
      skipTooltipButton.className = 'introjs-button introjs-skipbutton';
      skipTooltipButton.href = 'javascript:void(0);';
      skipTooltipButton.innerHTML = this._options.skipLabel;

      skipTooltipButton.onclick = function() {
        if (self._introItems.length - 1 == self._currentStep && typeof (self._introCompleteCallback) === 'function') {
          self._introCompleteCallback.call(self);
        }

        if (self._introItems.length - 1 != self._currentStep && typeof (self._introExitCallback) === 'function') {
          self._introExitCallback.call(self);
        }

        _exitIntro.call(self, self._targetElement);
      };

      buttonsLayer.appendChild(skipTooltipButton);

      //in order to prevent displaying next/previous button always
      if (this._introItems.length > 1) {
        buttonsLayer.appendChild(prevTooltipButton);
        buttonsLayer.appendChild(nextTooltipButton);
      }

      tooltipLayer.appendChild(buttonsLayer);

      //set proper position
      _placeTooltip.call(self, targetElement.element, tooltipLayer, arrowLayer, helperNumberLayer);
    }

    //disable interaction
    if (this._options.disableInteraction === true) {
      _disableInteraction.call(self);
    }

    prevTooltipButton.removeAttribute('tabIndex');
    nextTooltipButton.removeAttribute('tabIndex');

    if (this._currentStep == 0 && this._introItems.length > 1) {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton introjs-disabled';
      prevTooltipButton.tabIndex = '-1';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton';
      skipTooltipButton.innerHTML = this._options.skipLabel;
    } else if (this._introItems.length - 1 == this._currentStep || this._introItems.length == 1) {
      skipTooltipButton.innerHTML = this._options.doneLabel;
      prevTooltipButton.className = 'introjs-button introjs-prevbutton';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton introjs-disabled';
      nextTooltipButton.tabIndex = '-1';
    } else {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton';
      skipTooltipButton.innerHTML = this._options.skipLabel;
    }

    //Set focus on "next" button, so that hitting Enter always moves you onto the next step
    nextTooltipButton.focus();

    //add target element position style
    targetElement.element.className += ' introjs-showElement';

    var currentElementPosition = _getPropValue(targetElement.element, 'position');
    if (currentElementPosition !== 'absolute' &&
        currentElementPosition !== 'relative') {
      //change to new intro item
      targetElement.element.className += ' introjs-relativePosition';
    }

    var parentElm = targetElement.element.parentNode;
    while (parentElm != null) {
      if (parentElm.tagName.toLowerCase() === 'body') break;

      //fix The Stacking Contenxt problem.
      //More detail: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
      var zIndex = _getPropValue(parentElm, 'z-index');
      var opacity = parseFloat(_getPropValue(parentElm, 'opacity'));
      var transform = _getPropValue(parentElm, 'transform') || _getPropValue(parentElm, '-webkit-transform') || _getPropValue(parentElm, '-moz-transform') || _getPropValue(parentElm, '-ms-transform') || _getPropValue(parentElm, '-o-transform');
      if (/[0-9]+/.test(zIndex) || opacity < 1 || (transform !== 'none' && transform !== undefined)) {
        parentElm.className += ' introjs-fixParent';
      }

      parentElm = parentElm.parentNode;
    }

    if (!_elementInViewport(targetElement.element) && this._options.scrollToElement === true) {
      var rect = targetElement.element.getBoundingClientRect(),
        winHeight = _getWinSize().height,
        top = rect.bottom - (rect.bottom - rect.top),
        bottom = rect.bottom - winHeight;

      //Scroll up
      if (top < 0 || targetElement.element.clientHeight > winHeight) {
        window.scrollBy(0, top - 30); // 30px padding from edge to look nice

      //Scroll down
      } else {
        window.scrollBy(0, bottom + 100); // 70px + 30px padding from edge to look nice
      }
    }

    if (typeof (this._introAfterChangeCallback) !== 'undefined') {
      this._introAfterChangeCallback.call(this, targetElement.element);
    }
  }

  /**
   * Get an element CSS property on the page
   * Thanks to JavaScript Kit: http://www.javascriptkit.com/dhtmltutors/dhtmlcascade4.shtml
   *
   * @api private
   * @method _getPropValue
   * @param {Object} element
   * @param {String} propName
   * @returns Element's property value
   */
  function _getPropValue (element, propName) {
    var propValue = '';
    if (element.currentStyle) { //IE
      propValue = element.currentStyle[propName];
    } else if (document.defaultView && document.defaultView.getComputedStyle) { //Others
      propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
    }

    //Prevent exception in IE
    if (propValue && propValue.toLowerCase) {
      return propValue.toLowerCase();
    } else {
      return propValue;
    }
  }

  /**
   * Provides a cross-browser way to get the screen dimensions
   * via: http://stackoverflow.com/questions/5864467/internet-explorer-innerheight
   *
   * @api private
   * @method _getWinSize
   * @returns {Object} width and height attributes
   */
  function _getWinSize() {
    if (window.innerWidth != undefined) {
      return { width: window.innerWidth, height: window.innerHeight };
    } else {
      var D = document.documentElement;
      return { width: D.clientWidth, height: D.clientHeight };
    }
  }

  /**
   * Add overlay layer to the page
   * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
   *
   * @api private
   * @method _elementInViewport
   * @param {Object} el
   */
  function _elementInViewport(el) {
    var rect = el.getBoundingClientRect();

    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      (rect.bottom+80) <= window.innerHeight && // add 80 to get the text right
      rect.right <= window.innerWidth
    );
  }

  /**
   * Add overlay layer to the page
   *
   * @api private
   * @method _addOverlayLayer
   * @param {Object} targetElm
   */
  function _addOverlayLayer(targetElm) {
    var overlayLayer = document.createElement('div'),
        styleText = '',
        self = this;

    //set css class name
    overlayLayer.className = 'introjs-overlay';

    //check if the target element is body, we should calculate the size of overlay layer in a better way
    if (targetElm.tagName.toLowerCase() === 'body') {
      styleText += 'top: 0;bottom: 0; left: 0;right: 0;position: fixed;';
      overlayLayer.setAttribute('style', styleText);
    } else {
      //set overlay layer position
      var elementPosition = _getOffset(targetElm);
      if (elementPosition) {
        styleText += 'width: ' + elementPosition.width + 'px; height:' + elementPosition.height + 'px; top:' + elementPosition.top + 'px;left: ' + elementPosition.left + 'px;';
        overlayLayer.setAttribute('style', styleText);
      }
    }

    targetElm.appendChild(overlayLayer);

    overlayLayer.onclick = function() {
      if (self._options.exitOnOverlayClick == true) {

        //check if any callback is defined
        if (self._introExitCallback != undefined) {
          self._introExitCallback.call(self);
        }
        _exitIntro.call(self, targetElm);
      }
    };

    setTimeout(function() {
      styleText += 'opacity: ' + self._options.overlayOpacity.toString() + ';';
      overlayLayer.setAttribute('style', styleText);
    }, 10);

    return true;
  }

  /**
   * Get an element position on the page
   * Thanks to `meouw`: http://stackoverflow.com/a/442474/375966
   *
   * @api private
   * @method _getOffset
   * @param {Object} element
   * @returns Element's position info
   */
  function _getOffset(element) {
    var elementPosition = {};

    //set width
    elementPosition.width = element.offsetWidth;

    //set height
    elementPosition.height = element.offsetHeight;

    //calculate element top and left
    var _x = 0;
    var _y = 0;
    while (element && !isNaN(element.offsetLeft) && !isNaN(element.offsetTop)) {
      _x += element.offsetLeft;
      _y += element.offsetTop;
      element = element.offsetParent;
    }
    //set top
    elementPosition.top = _y;
    //set left
    elementPosition.left = _x;

    return elementPosition;
  }

  /**
   * Gets the current progress percentage
   *
   * @api private
   * @method _getProgress
   * @returns current progress percentage
   */
  function _getProgress() {
    // Steps are 0 indexed
    var currentStep = parseInt((this._currentStep + 1), 10);
    return ((currentStep / this._introItems.length) * 100);
  }

  /**
   * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
   * via: http://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
   *
   * @param obj1
   * @param obj2
   * @returns obj3 a new object based on obj1 and obj2
   */
  function _mergeOptions(obj1,obj2) {
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }

  var introJs = function (targetElm) {
    if (typeof (targetElm) === 'object') {
      //Ok, create a new instance
      return new IntroJs(targetElm);

    } else if (typeof (targetElm) === 'string') {
      //select the target element with query selector
      var targetElement = document.querySelector(targetElm);

      if (targetElement) {
        return new IntroJs(targetElement);
      } else {
        throw new Error('There is no element with given selector.');
      }
    } else {
      return new IntroJs(document.body);
    }
  };

  /**
   * Current IntroJs version
   *
   * @property version
   * @type String
   */
  introJs.version = VERSION;

  //Prototype
  introJs.fn = IntroJs.prototype = {
    clone: function () {
      return new IntroJs(this);
    },
    setOption: function(option, value) {
      this._options[option] = value;
      return this;
    },
    setOptions: function(options) {
      this._options = _mergeOptions(this._options, options);
      return this;
    },
    start: function () {
      _introForElement.call(this, this._targetElement);
      return this;
    },
    goToStep: function(step) {
      _goToStep.call(this, step);
      return this;
    },
    nextStep: function() {
      _nextStep.call(this);
      return this;
    },
    previousStep: function() {
      _previousStep.call(this);
      return this;
    },
    exit: function() {
      _exitIntro.call(this, this._targetElement);
      return this;
    },
    refresh: function() {
      _setHelperLayerPosition.call(this, document.querySelector('.introjs-helperLayer'));
      _setHelperLayerPosition.call(this, document.querySelector('.introjs-tooltipReferenceLayer'));
      return this;
    },
    onbeforechange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introBeforeChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onbeforechange was not a function');
      }
      return this;
    },
    onchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onchange was not a function.');
      }
      return this;
    },
    onafterchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introAfterChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onafterchange was not a function');
      }
      return this;
    },
    oncomplete: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introCompleteCallback = providedCallback;
      } else {
        throw new Error('Provided callback for oncomplete was not a function.');
      }
      return this;
    },
    onexit: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introExitCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onexit was not a function.');
      }
      return this;
    }
  };

  exports.introJs = introJs;
  return introJs;
}));

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js":[function(require,module,exports){
/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
(function (window, document, undefined) {
var oldL = window.L,
    L = {};

L.version = '0.7.7';

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed

L.noConflict = function () {
	window.L = oldL;
	return this;
};

window.L = L;


/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	extend: function (dest) { // (Object[, Object, ...]) ->
		var sources = Array.prototype.slice.call(arguments, 1),
		    i, j, len, src;

		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j] || {};
			for (i in src) {
				if (src.hasOwnProperty(i)) {
					dest[i] = src[i];
				}
			}
		}
		return dest;
	},

	bind: function (fn, obj) { // (Function, Object) -> Function
		var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
		return function () {
			return fn.apply(obj, args || arguments);
		};
	},

	stamp: (function () {
		var lastId = 0,
		    key = '_leaflet_id';
		return function (obj) {
			obj[key] = obj[key] || ++lastId;
			return obj[key];
		};
	}()),

	invokeEach: function (obj, method, context) {
		var i, args;

		if (typeof obj === 'object') {
			args = Array.prototype.slice.call(arguments, 3);

			for (i in obj) {
				method.apply(context, [i, obj[i]].concat(args));
			}
			return true;
		}

		return false;
	},

	limitExecByInterval: function (fn, time, context) {
		var lock, execOnUnlock;

		return function wrapperFn() {
			var args = arguments;

			if (lock) {
				execOnUnlock = true;
				return;
			}

			lock = true;

			setTimeout(function () {
				lock = false;

				if (execOnUnlock) {
					wrapperFn.apply(context, args);
					execOnUnlock = false;
				}
			}, time);

			fn.apply(context, args);
		};
	},

	falseFn: function () {
		return false;
	},

	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	setOptions: function (obj, options) {
		obj.options = L.extend({}, obj.options, options);
		return obj.options;
	},

	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},
	template: function (str, data) {
		return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
			var value = data[key];
			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);
			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		var i, fn,
		    prefixes = ['webkit', 'moz', 'o', 'ms'];

		for (i = 0; i < prefixes.length && !fn; i++) {
			fn = window[prefixes[i] + name];
		}

		return fn;
	}

	var lastTime = 0;

	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame ||
	        getPrefixed('RequestAnimationFrame') || timeoutDefer;

	var cancelFn = window.cancelAnimationFrame ||
	        getPrefixed('CancelAnimationFrame') ||
	        getPrefixed('CancelRequestAnimationFrame') ||
	        function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate, element) {
		fn = L.bind(fn, context);

		if (immediate && requestFn === timeoutDefer) {
			fn();
		} else {
			return requestFn.call(window, fn, element);
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};

}());

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function (props) {

	// extended class with the new prototype
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		if (this._initHooks) {
			this.callInitHooks();
		}
	};

	// instantiate class without calling constructor
	var F = function () {};
	F.prototype = this.prototype;

	var proto = new F();
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	//inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (props.options && proto.options) {
		props.options = L.extend({}, proto.options, props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	var parent = this;
	// jshint camelcase: false
	NewClass.__super__ = parent.prototype;

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parent.prototype.callInitHooks) {
			parent.prototype.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};


/*
 * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
 */

var eventsKey = '_leaflet_events';

L.Mixin = {};

L.Mixin.Events = {

	addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

		// types can be a map of types/handlers
		if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey] = this[eventsKey] || {},
		    contextId = context && context !== this && L.stamp(context),
		    i, len, event, type, indexKey, indexLenKey, typeIndex;

		// types can be a string of space-separated words
		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			event = {
				action: fn,
				context: context || this
			};
			type = types[i];

			if (contextId) {
				// store listeners of a particular context in a separate hash (if it has an id)
				// gives a major performance boost when removing thousands of map layers

				indexKey = type + '_idx';
				indexLenKey = indexKey + '_len';

				typeIndex = events[indexKey] = events[indexKey] || {};

				if (!typeIndex[contextId]) {
					typeIndex[contextId] = [];

					// keep track of the number of keys in the index to quickly check if it's empty
					events[indexLenKey] = (events[indexLenKey] || 0) + 1;
				}

				typeIndex[contextId].push(event);


			} else {
				events[type] = events[type] || [];
				events[type].push(event);
			}
		}

		return this;
	},

	hasEventListeners: function (type) { // (String) -> Boolean
		var events = this[eventsKey];
		return !!events && ((type in events && events[type].length > 0) ||
		                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
	},

	removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

		if (!this[eventsKey]) {
			return this;
		}

		if (!types) {
			return this.clearAllEventListeners();
		}

		if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey],
		    contextId = context && context !== this && L.stamp(context),
		    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			type = types[i];
			indexKey = type + '_idx';
			indexLenKey = indexKey + '_len';

			typeIndex = events[indexKey];

			if (!fn) {
				// clear all listeners for a type if function isn't specified
				delete events[type];
				delete events[indexKey];
				delete events[indexLenKey];

			} else {
				listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

				if (listeners) {
					for (j = listeners.length - 1; j >= 0; j--) {
						if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
							removed = listeners.splice(j, 1);
							// set the old action to a no-op, because it is possible
							// that the listener is being iterated over as part of a dispatch
							removed[0].action = L.Util.falseFn;
						}
					}

					if (context && typeIndex && (listeners.length === 0)) {
						delete typeIndex[contextId];
						events[indexLenKey]--;
					}
				}
			}
		}

		return this;
	},

	clearAllEventListeners: function () {
		delete this[eventsKey];
		return this;
	},

	fireEvent: function (type, data) { // (String[, Object])
		if (!this.hasEventListeners(type)) {
			return this;
		}

		var event = L.Util.extend({}, data, { type: type, target: this });

		var events = this[eventsKey],
		    listeners, i, len, typeIndex, contextId;

		if (events[type]) {
			// make sure adding/removing listeners inside other listeners won't cause infinite loop
			listeners = events[type].slice();

			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].action.call(listeners[i].context, event);
			}
		}

		// fire event for the context-indexed listeners as well
		typeIndex = events[type + '_idx'];

		for (contextId in typeIndex) {
			listeners = typeIndex[contextId].slice();

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].action.call(listeners[i].context, event);
				}
			}
		}

		return this;
	},

	addOneTimeEventListener: function (types, fn, context) {

		if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

		var handler = L.bind(function () {
			this
			    .removeEventListener(types, fn, context)
			    .removeEventListener(types, handler, context);
		}, this);

		return this
		    .addEventListener(types, fn, context)
		    .addEventListener(types, handler, context);
	}
};

L.Mixin.Events.on = L.Mixin.Events.addEventListener;
L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ie = 'ActiveXObject' in window,
		ielt9 = ie && !document.addEventListener,

	    // terrible browser detection to work around Safari / iOS / Android browser bugs
	    ua = navigator.userAgent.toLowerCase(),
	    webkit = ua.indexOf('webkit') !== -1,
	    chrome = ua.indexOf('chrome') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android = ua.indexOf('android') !== -1,
	    android23 = ua.search('android [23]') !== -1,
		gecko = ua.indexOf('gecko') !== -1,

	    mobile = typeof orientation !== undefined + '',
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
		pointer = (window.PointerEvent && window.navigator.pointerEnabled) ||
				  msPointer,
	    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
	             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
	              window.matchMedia('(min-resolution:144dpi)').matches),

	    doc = document.documentElement,
	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera3d = 'OTransition' in doc.style,
	    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;

	var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {
		ie: ie,
		ielt9: ielt9,
		webkit: webkit,
		gecko: gecko && !webkit && !window.opera && !ie,

		android: android,
		android23: android23,

		chrome: chrome,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera3d: opera3d,
		any3d: any3d,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,

		touch: touch,
		msPointer: msPointer,
		pointer: pointer,

		retina: retina
	};

}());


/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};


/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};


/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};


/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return (typeof id === 'string' ? document.getElementById(id) : id);
	},

	getStyle: function (el, style) {

		var value = el.style[style];

		if (!value && el.currentStyle) {
			value = el.currentStyle[style];
		}

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	getViewportOffset: function (element) {

		var top = 0,
		    left = 0,
		    el = element,
		    docBody = document.body,
		    docEl = document.documentElement,
		    pos;

		do {
			top  += el.offsetTop  || 0;
			left += el.offsetLeft || 0;

			//add borders
			top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
			left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

			pos = L.DomUtil.getStyle(el, 'position');

			if (el.offsetParent === docBody && pos === 'absolute') { break; }

			if (pos === 'fixed') {
				top  += docBody.scrollTop  || docEl.scrollTop  || 0;
				left += docBody.scrollLeft || docEl.scrollLeft || 0;
				break;
			}

			if (pos === 'relative' && !el.offsetLeft) {
				var width = L.DomUtil.getStyle(el, 'width'),
				    maxWidth = L.DomUtil.getStyle(el, 'max-width'),
				    r = el.getBoundingClientRect();

				if (width !== 'none' || maxWidth !== 'none') {
					left += r.left + el.clientLeft;
				}

				//calculate full y offset since we're breaking out of the loop
				top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

				break;
			}

			el = el.offsetParent;

		} while (el);

		el = element;

		do {
			if (el === docBody) { break; }

			top  -= el.scrollTop  || 0;
			left -= el.scrollLeft || 0;

			el = el.parentNode;
		} while (el);

		return new L.Point(left, top);
	},

	documentIsLtr: function () {
		if (!L.DomUtil._docIsLtrCached) {
			L.DomUtil._docIsLtrCached = true;
			L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
		}
		return L.DomUtil._docIsLtr;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil._getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil._getClass(el);
			L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	_setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	_getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {

			var filter = false,
			    filterName = 'DXImageTransform.Microsoft.Alpha';

			// filters collection throws an error if we try to retrieve a filter that doesn't exist
			try {
				filter = el.filters.item(filterName);
			} catch (e) {
				// don't set opacity to 1 if we haven't already set an opacity,
				// it isn't needed and breaks transparent pngs.
				if (value === 1) { return; }
			}

			value = Math.round(value * 100);

			if (filter) {
				filter.Enabled = (value !== 100);
				filter.Opacity = value;
			} else {
				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
			}
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	getTranslateString: function (point) {
		// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
		// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
		// (same speed either way), Opera 12 doesn't support translate3d

		var is3d = L.Browser.webkit3d,
		    open = 'translate' + (is3d ? '3d' : '') + '(',
		    close = (is3d ? ',0' : '') + ')';

		return open + point.x + 'px,' + point.y + 'px' + close;
	},

	getScaleString: function (scale, origin) {

		var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
		    scaleStr = ' scale(' + scale + ') ';

		return preTranslateStr + scaleStr;
	},

	setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

		// jshint camelcase: false
		el._leaflet_pos = point;

		if (!disable3D && L.Browser.any3d) {
			el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		// jshint camelcase: false
		return el._leaflet_pos;
	}
};


// prefix style property names

L.DomUtil.TRANSFORM = L.DomUtil.testProp(
        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

L.DomUtil.TRANSITION = L.DomUtil.testProp(
        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

L.DomUtil.TRANSITION_END =
        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
        L.DomUtil.TRANSITION + 'End' : 'transitionend';

(function () {
    if ('onselectstart' in document) {
        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
            },

            enableTextSelection: function () {
                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
            }
        });
    } else {
        var userSelectProperty = L.DomUtil.testProp(
            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                if (userSelectProperty) {
                    var style = document.documentElement.style;
                    this._userSelect = style[userSelectProperty];
                    style[userSelectProperty] = 'none';
                }
            },

            enableTextSelection: function () {
                if (userSelectProperty) {
                    document.documentElement.style[userSelectProperty] = this._userSelect;
                    delete this._userSelect;
                }
            }
        });
    }

	L.extend(L.DomUtil, {
		disableImageDrag: function () {
			L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
		},

		enableImageDrag: function () {
			L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
		}
	});
})();


/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
	lat = parseFloat(lat);
	lng = parseFloat(lng);

	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = lat;
	this.lng = lng;

	if (alt !== undefined) {
		this.alt = parseFloat(alt);
	}
};

L.extend(L.LatLng, {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

L.LatLng.prototype = {
	equals: function (obj) { // (LatLng) -> Boolean
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= L.LatLng.MAX_MARGIN;
	},

	toString: function (precision) { // (Number) -> String
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
	// TODO move to projection code, LatLng shouldn't know about Earth
	distanceTo: function (other) { // (LatLng) -> Number
		other = L.latLng(other);

		var R = 6378137, // earth radius in meters
		    d2r = L.LatLng.DEG_TO_RAD,
		    dLat = (other.lat - this.lat) * d2r,
		    dLon = (other.lng - this.lng) * d2r,
		    lat1 = this.lat * d2r,
		    lat2 = other.lat * d2r,
		    sin1 = Math.sin(dLat / 2),
		    sin2 = Math.sin(dLon / 2);

		var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

		return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	},

	wrap: function (a, b) { // (Number, Number) -> LatLng
		var lng = this.lng;

		a = a || -180;
		b = b ||  180;

		lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

		return new L.LatLng(this.lat, lng);
	}
};

L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a)) {
		if (typeof a[0] === 'number' || typeof a[0] === 'string') {
			return new L.LatLng(a[0], a[1], a[2]);
		} else {
			return null;
		}
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b);
};



/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {
	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		if (!obj) { return this; }

		var latLng = L.latLng(obj);
		if (latLng !== null) {
			obj = latLng;
		} else {
			obj = L.latLngBounds(obj);
		}

		if (obj instanceof L.LatLng) {
			if (!this._southWest && !this._northEast) {
				this._southWest = new L.LatLng(obj.lat, obj.lng);
				this._northEast = new L.LatLng(obj.lat, obj.lng);
			} else {
				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
				this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
			}
		} else if (obj instanceof L.LatLngBounds) {
			this.extend(obj._southWest);
			this.extend(obj._northEast);
		}
		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};


/*
 * L.Projection contains various geographical projections used by CRS classes.
 */

L.Projection = {};


/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    x = latlng.lng * d,
		    y = lat * d;

		y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    lng = point.x * d,
		    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

		return new L.LatLng(lat, lng);
	}
};


/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	}
};


/*
 * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	project: function (latlng) {
		return this.projection.project(latlng);
	},

	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	getSize: function (zoom) {
		var s = this.scale(zoom);
		return L.point(s, s);
	}
};


/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	}
});


/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
 * and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS, {
	code: 'EPSG:3857',

	projection: L.Projection.SphericalMercator,
	transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

	project: function (latlng) { // (LatLng) -> Point
		var projectedPoint = this.projection.project(latlng),
		    earthRadius = 6378137;
		return projectedPoint.multiplyBy(earthRadius);
	}
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});


/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS, {
	code: 'EPSG:4326',

	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
});


/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
		trackResize: true,
		markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);


		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];

		this._layers = {};
		this._zoomBoundLayers = {};
		this._tileLayersNum = 0;

		this.callInitHooks();

		this._addLayers(options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	fitBounds: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return this.setView(center, zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		this.options.maxBounds = bounds;

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds, this);
		}

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds, this);
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	addLayer: function (layer) {
		// TODO method is too big, refactor

		var id = L.stamp(layer);

		if (this._layers[id]) { return this; }

		this._layers[id] = layer;

		// TODO getMaxZoom, getMinZoom in ILayer (instead of options)
		if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
			this._zoomBoundLayers[id] = layer;
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor!!!
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum++;
			this._tileLayersToLoad++;
			layer.on('load', this._onTileLayerLoad, this);
		}

		if (this._loaded) {
			this._layerAdd(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
		}

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum--;
			this._tileLayersToLoad--;
			layer.off('load', this._onTileLayerLoad, this);
		}

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {
		if (this._loaded) {
			this.fire('unload');
		}

		this._initEvents('off');

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		this._clearPanes();
		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		return this;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ?
			(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
			this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._initialTopLeftPoint;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom) {
		var crs = this.options.crs;
		return crs.scale(toZoom) / crs.scale(this._zoom);
	},

	getScaleZoom: function (scale) {
		return this._zoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};

		this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

		this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
		panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
		panes.shadowPane = this._createPane('leaflet-shadow-pane');
		panes.overlayPane = this._createPane('leaflet-overlay-pane');
		panes.markerPane = this._createPane('leaflet-marker-pane');
		panes.popupPane = this._createPane('leaflet-popup-pane');

		var zoomHide = ' leaflet-zoom-hide';

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, zoomHide);
			L.DomUtil.addClass(panes.shadowPane, zoomHide);
			L.DomUtil.addClass(panes.popupPane, zoomHide);
		}
	},

	_createPane: function (className, container) {
		return L.DomUtil.create('div', className, container || this._panes.objectsPane);
	},

	_clearPanes: function () {
		this._container.removeChild(this._mapPane);
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		} else {
			this._initialTopLeftPoint._add(this._getMapPanePos());
		}

		this._tileLayersToLoad = this._tileLayersNum;

		var loading = !this._loaded;
		this._loaded = true;

		this.fire('viewreset', {hard: !preserveMapOffset});

		if (loading) {
			this.fire('load');
			this.eachLayer(this._layerAdd, this);
		}

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_updateZoomLevels: function () {
		var i,
			minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (i in this._zoomBoundLayers) {
			var layer = this._zoomBoundLayers[i];
			if (!isNaN(layer.options.minZoom)) {
				minZoom = Math.min(minZoom, layer.options.minZoom);
			}
			if (!isNaN(layer.options.maxZoom)) {
				maxZoom = Math.max(maxZoom, layer.options.maxZoom);
			}
		}

		if (i === undefined) { // we have no tilelayers
			this._layersMaxZoom = this._layersMinZoom = undefined;
		} else {
			this._layersMaxZoom = maxZoom;
			this._layersMinZoom = minZoom;
		}

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// map events

	_initEvents: function (onOff) {
		if (!L.DomEvent) { return; }

		onOff = onOff || 'on';

		L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

		var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
		              'mouseleave', 'mousemove', 'contextmenu'],
		    i, len;

		for (i = 0, len = events.length; i < len; i++) {
			L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
		}

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_onMouseClick: function (e) {
		if (!this._loaded || (!e._simulated &&
		        ((this.dragging && this.dragging.moved()) ||
		         (this.boxZoom  && this.boxZoom.moved()))) ||
		            L.DomEvent._skipped(e)) { return; }

		this.fire('preclick');
		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type;

		type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

		if (!this.hasEventListeners(type)) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}

		var containerPoint = this.mouseEventToContainerPoint(e),
		    layerPoint = this.containerPointToLayerPoint(containerPoint),
		    latlng = this.layerPointToLatLng(layerPoint);

		this.fire(type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});
	},

	_onTileLayerLoad: function () {
		this._tileLayersToLoad--;
		if (this._tileLayersNum && !this._tileLayersToLoad) {
			this.fire('tilelayersload');
		}
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, this);
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	_layerAdd: function (layer) {
		layer.onAdd(this);
		this.fire('layeradd', {layer: layer});
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos());
	},

	_getNewTopLeftPoint: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._round();
	},

	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
		return this.project(latlng, newZoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	MAX_LATITUDE: 85.0840591556,

	R_MINOR: 6356752.314245179,
	R_MAJOR: 6378137,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    x = latlng.lng * d * r,
		    y = lat * d,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1.0 - tmp * tmp),
		    con = eccent * Math.sin(y);

		con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

		var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
		y = -r * Math.log(ts);

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    lng = point.x * d / r,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1 - (tmp * tmp)),
		    ts = Math.exp(- point.y / r),
		    phi = (Math.PI / 2) - 2 * Math.atan(ts),
		    numIter = 15,
		    tol = 1e-7,
		    i = numIter,
		    dphi = 0.1,
		    con;

		while ((Math.abs(dphi) > tol) && (--i > 0)) {
			con = eccent * Math.sin(phi);
			dphi = (Math.PI / 2) - 2 * Math.atan(ts *
			            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, lng);
	}
};



L.CRS.EPSG3395 = L.extend({}, L.CRS, {
	code: 'EPSG:3395',

	projection: L.Projection.Mercator,

	transformation: (function () {
		var m = L.Projection.Mercator,
		    r = m.R_MAJOR,
		    scale = 0.5 / (Math.PI * r);

		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});


/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',
		zoomOffset: 0,
		opacity: 1,
		/*
		maxNativeZoom: null,
		zIndex: null,
		tms: false,
		continuousWorld: false,
		noWrap: false,
		zoomReverse: false,
		detectRetina: false,
		reuseTiles: false,
		bounds: false,
		*/
		unloadInvisibleTiles: L.Browser.mobile,
		updateWhenIdle: L.Browser.mobile
	},

	initialize: function (url, options) {
		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			if (options.minZoom > 0) {
				options.minZoom--;
			}
			this.options.maxZoom--;
		}

		if (options.bounds) {
			options.bounds = L.latLngBounds(options.bounds);
		}

		this._url = url;

		var subdomains = this.options.subdomains;

		if (typeof subdomains === 'string') {
			this.options.subdomains = subdomains.split('');
		}
	},

	onAdd: function (map) {
		this._map = map;
		this._animated = map._zoomAnimated;

		// create a container div for tiles
		this._initContainer();

		// set up events
		map.on({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.on({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
			map.on('move', this._limitedUpdate, this);
		}

		this._reset();
		this._update();
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		this._container.parentNode.removeChild(this._container);

		map.off({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.off({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			map.off('move', this._limitedUpdate, this);
		}

		this._container = null;
		this._map = null;
	},

	bringToFront: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.appendChild(this._container);
			this._setAutoZIndex(pane, Math.max);
		}

		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.insertBefore(this._container, pane.firstChild);
			this._setAutoZIndex(pane, Math.min);
		}

		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}
		return this;
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (pane, compare) {

		var layers = pane.children,
		    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
		    zIndex, i, len;

		for (i = 0, len = layers.length; i < len; i++) {

			if (layers[i] !== this._container) {
				zIndex = parseInt(layers[i].style.zIndex, 10);

				if (!isNaN(zIndex)) {
					edgeZIndex = compare(edgeZIndex, zIndex);
				}
			}
		}

		this.options.zIndex = this._container.style.zIndex =
		        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
	},

	_updateOpacity: function () {
		var i,
		    tiles = this._tiles;

		if (L.Browser.ielt9) {
			for (i in tiles) {
				L.DomUtil.setOpacity(tiles[i], this.options.opacity);
			}
		} else {
			L.DomUtil.setOpacity(this._container, this.options.opacity);
		}
	},

	_initContainer: function () {
		var tilePane = this._map._panes.tilePane;

		if (!this._container) {
			this._container = L.DomUtil.create('div', 'leaflet-layer');

			this._updateZIndex();

			if (this._animated) {
				var className = 'leaflet-tile-container';

				this._bgBuffer = L.DomUtil.create('div', className, this._container);
				this._tileContainer = L.DomUtil.create('div', className, this._container);

			} else {
				this._tileContainer = this._container;
			}

			tilePane.appendChild(this._container);

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}
	},

	_reset: function (e) {
		for (var key in this._tiles) {
			this.fire('tileunload', {tile: this._tiles[key]});
		}

		this._tiles = {};
		this._tilesToLoad = 0;

		if (this.options.reuseTiles) {
			this._unusedTiles = [];
		}

		this._tileContainer.innerHTML = '';

		if (this._animated && e && e.hard) {
			this._clearBgBuffer();
		}

		this._initContainer();
	},

	_getTileSize: function () {
		var map = this._map,
		    zoom = map.getZoom() + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom,
		    tileSize = this.options.tileSize;

		if (zoomN && zoom > zoomN) {
			tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
		}

		return tileSize;
	},

	_update: function () {

		if (!this._map) { return; }

		var map = this._map,
		    bounds = map.getPixelBounds(),
		    zoom = map.getZoom(),
		    tileSize = this._getTileSize();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		var tileBounds = L.bounds(
		        bounds.min.divideBy(tileSize)._floor(),
		        bounds.max.divideBy(tileSize)._floor());

		this._addTilesFromCenterOut(tileBounds);

		if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
			this._removeOtherTiles(tileBounds);
		}
	},

	_addTilesFromCenterOut: function (bounds) {
		var queue = [],
		    center = bounds.getCenter();

		var j, i, point;

		for (j = bounds.min.y; j <= bounds.max.y; j++) {
			for (i = bounds.min.x; i <= bounds.max.x; i++) {
				point = new L.Point(i, j);

				if (this._tileShouldBeLoaded(point)) {
					queue.push(point);
				}
			}
		}

		var tilesToLoad = queue.length;

		if (tilesToLoad === 0) { return; }

		// load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center);
		});

		var fragment = document.createDocumentFragment();

		// if its the first batch of tiles to load
		if (!this._tilesToLoad) {
			this.fire('loading');
		}

		this._tilesToLoad += tilesToLoad;

		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment);
		}

		this._tileContainer.appendChild(fragment);
	},

	_tileShouldBeLoaded: function (tilePoint) {
		if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
			return false; // already loaded
		}

		var options = this.options;

		if (!options.continuousWorld) {
			var limit = this._getWrapTileNum();

			// don't load if exceeds world bounds
			if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
				tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
		}

		if (options.bounds) {
			var tileSize = this._getTileSize(),
			    nwPoint = tilePoint.multiplyBy(tileSize),
			    sePoint = nwPoint.add([tileSize, tileSize]),
			    nw = this._map.unproject(nwPoint),
			    se = this._map.unproject(sePoint);

			// TODO temporary hack, will be removed after refactoring projections
			// https://github.com/Leaflet/Leaflet/issues/1618
			if (!options.continuousWorld && !options.noWrap) {
				nw = nw.wrap();
				se = se.wrap();
			}

			if (!options.bounds.intersects([nw, se])) { return false; }
		}

		return true;
	},

	_removeOtherTiles: function (bounds) {
		var kArr, x, y, key;

		for (key in this._tiles) {
			kArr = key.split(':');
			x = parseInt(kArr[0], 10);
			y = parseInt(kArr[1], 10);

			// remove tile if it's out of bounds
			if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
				this._removeTile(key);
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		this.fire('tileunload', {tile: tile, url: tile.src});

		if (this.options.reuseTiles) {
			L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
			this._unusedTiles.push(tile);

		} else if (tile.parentNode === this._tileContainer) {
			this._tileContainer.removeChild(tile);
		}

		// for https://github.com/CloudMade/Leaflet/issues/137
		if (!L.Browser.android) {
			tile.onload = null;
			tile.src = L.Util.emptyImageUrl;
		}

		delete this._tiles[key];
	},

	_addTile: function (tilePoint, container) {
		var tilePos = this._getTilePos(tilePoint);

		// get unused tile - or create a new tile
		var tile = this._getTile();

		/*
		Chrome 20 layouts much faster with top/left (verify with timeline, frames)
		Android 4 browser has display issues with top/left and requires transform instead
		(other browsers don't currently care) - see debug/hacks/jitter.html for an example
		*/
		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

		this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

		this._loadTile(tile, tilePoint);

		if (tile.parentNode !== this._tileContainer) {
			container.appendChild(tile);
		}
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._map.getZoom();

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getTilePos: function (tilePoint) {
		var origin = this._map.getPixelOrigin(),
		    tileSize = this._getTileSize();

		return tilePoint.multiplyBy(tileSize).subtract(origin);
	},

	// image-specific code (override to implement e.g. Canvas or SVG tile layer)

	getTileUrl: function (tilePoint) {
		return L.Util.template(this._url, L.extend({
			s: this._getSubdomain(tilePoint),
			z: tilePoint.z,
			x: tilePoint.x,
			y: tilePoint.y
		}, this.options));
	},

	_getWrapTileNum: function () {
		var crs = this._map.options.crs,
		    size = crs.getSize(this._map.getZoom());
		return size.divideBy(this._getTileSize())._floor();
	},

	_adjustTilePoint: function (tilePoint) {

		var limit = this._getWrapTileNum();

		// wrap tile coordinates
		if (!this.options.continuousWorld && !this.options.noWrap) {
			tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
		}

		if (this.options.tms) {
			tilePoint.y = limit.y - tilePoint.y - 1;
		}

		tilePoint.z = this._getZoomForUrl();
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	_getTile: function () {
		if (this.options.reuseTiles && this._unusedTiles.length > 0) {
			var tile = this._unusedTiles.pop();
			this._resetTile(tile);
			return tile;
		}
		return this._createTile();
	},

	// Override if data stored on a tile needs to be cleaned up before reuse
	_resetTile: function (/*tile*/) {},

	_createTile: function () {
		var tile = L.DomUtil.create('img', 'leaflet-tile');
		tile.style.width = tile.style.height = this._getTileSize() + 'px';
		tile.galleryimg = 'no';

		tile.onselectstart = tile.onmousemove = L.Util.falseFn;

		if (L.Browser.ielt9 && this.options.opacity !== undefined) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}
		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.mobileWebkit3d) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer  = this;
		tile.onload  = this._tileOnLoad;
		tile.onerror = this._tileOnError;

		this._adjustTilePoint(tilePoint);
		tile.src     = this.getTileUrl(tilePoint);

		this.fire('tileloadstart', {
			tile: tile,
			url: tile.src
		});
	},

	_tileLoaded: function () {
		this._tilesToLoad--;

		if (this._animated) {
			L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
		}

		if (!this._tilesToLoad) {
			this.fire('load');

			if (this._animated) {
				// clear scaled tiles after all new tiles are loaded (for performance)
				clearTimeout(this._clearBgBufferTimer);
				this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
			}
		}
	},

	_tileOnLoad: function () {
		var layer = this._layer;

		//Only if we are loading an actual image
		if (this.src !== L.Util.emptyImageUrl) {
			L.DomUtil.addClass(this, 'leaflet-tile-loaded');

			layer.fire('tileload', {
				tile: this,
				url: this.src
			});
		}

		layer._tileLoaded();
	},

	_tileOnError: function () {
		var layer = this._layer;

		layer.fire('tileerror', {
			tile: this,
			url: this.src
		});

		var newUrl = layer.options.errorTileUrl;
		if (newUrl) {
			this.src = newUrl;
		}

		layer._tileLoaded();
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};


/*
 * L.TileLayer.WMS is used for putting WMS tile layers on the map.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	initialize: function (url, options) { // (String, Object)

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams),
		    tileSize = options.tileSize || this.options.tileSize;

		if (options.detectRetina && L.Browser.retina) {
			wmsParams.width = wmsParams.height = tileSize * 2;
		} else {
			wmsParams.width = wmsParams.height = tileSize;
		}

		for (var i in options) {
			// all keys that are not TileLayer options go to WMS params
			if (!this.options.hasOwnProperty(i) && i !== 'crs') {
				wmsParams[i] = options[i];
			}
		}

		this.wmsParams = wmsParams;

		L.setOptions(this, options);
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;

		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (tilePoint) { // (Point, Number) -> String

		var map = this._map,
		    tileSize = this.options.tileSize,

		    nwPoint = tilePoint.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
		    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
		    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
		        [se.y, nw.x, nw.y, se.x].join(',') :
		        [nw.x, se.y, se.x, nw.y].join(','),

		    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};


/*
 * L.TileLayer.Canvas is a class that you can use as a base for creating
 * dynamically drawn Canvas-based tile layers.
 */

L.TileLayer.Canvas = L.TileLayer.extend({
	options: {
		async: false
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}

		for (var i in this._tiles) {
			this._redrawTile(this._tiles[i]);
		}
		return this;
	},

	_redrawTile: function (tile) {
		this.drawTile(tile, tile._tilePoint, this._map._zoom);
	},

	_createTile: function () {
		var tile = L.DomUtil.create('canvas', 'leaflet-tile');
		tile.width = tile.height = this.options.tileSize;
		tile.onselectstart = tile.onmousemove = L.Util.falseFn;
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer = this;
		tile._tilePoint = tilePoint;

		this._redrawTile(tile);

		if (!this.options.async) {
			this.tileDrawn(tile);
		}
	},

	drawTile: function (/*tile, tilePoint*/) {
		// override with rendering code
	},

	tileDrawn: function (tile) {
		this._tileOnLoad.call(tile);
	}
});


L.tileLayer.canvas = function (options) {
	return new L.TileLayer.Canvas(options);
};


/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		opacity: 1
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._image) {
			this._initImage();
		}

		map._panes.overlayPane.appendChild(this._image);

		map.on('viewreset', this._reset, this);

		if (map.options.zoomAnimation && L.Browser.any3d) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._reset();
	},

	onRemove: function (map) {
		map.getPanes().overlayPane.removeChild(this._image);

		map.off('viewreset', this._reset, this);

		if (map.options.zoomAnimation) {
			map.off('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// TODO remove bringToFront/bringToBack duplication from TileLayer/Path
	bringToFront: function () {
		if (this._image) {
			this._map._panes.overlayPane.appendChild(this._image);
		}
		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.overlayPane;
		if (this._image) {
			pane.insertBefore(this._image, pane.firstChild);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;
		this._image.src = this._url;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	_initImage: function () {
		this._image = L.DomUtil.create('img', 'leaflet-image-layer');

		if (this._map.options.zoomAnimation && L.Browser.any3d) {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
		} else {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
		}

		this._updateOpacity();

		//TODO createImage util method to remove duplication
		L.extend(this._image, {
			galleryimg: 'no',
			onselectstart: L.Util.falseFn,
			onmousemove: L.Util.falseFn,
			onload: L.bind(this._onImageLoad, this),
			src: this._url
		});
	},

	_animateZoom: function (e) {
		var map = this._map,
		    image = this._image,
		    scale = map.getZoomScale(e.zoom),
		    nw = this._bounds.getNorthWest(),
		    se = this._bounds.getSouthEast(),

		    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
		    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
		    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

		image.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
	},

	_reset: function () {
		var image   = this._image,
		    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

		L.DomUtil.setPosition(image, topLeft);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_onImageLoad: function () {
		this.fire('load');
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};


/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	options: {
		/*
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		*/
		className: ''
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img;
		if (!oldIcon || oldIcon.tagName !== 'IMG') {
			img = this._createImg(src);
		} else {
			img = this._createImg(src, oldIcon);
		}
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor;

		if (name === 'shadow') {
			anchor = L.point(options.shadowAnchor || options.iconAnchor);
		} else {
			anchor = L.point(options.iconAnchor);
		}

		if (!anchor && size) {
			anchor = size.divideBy(2, true);
		}

		img.className = 'leaflet-marker-' + name + ' ' + options.className;

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
			return this.options[name + 'RetinaUrl'];
		}
		return this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};


/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],

		shadowSize: [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		if (L.Browser.retina && name === 'icon') {
			name += '-2x';
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, matches, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;
		matches = src.match(leafletRe);

		if (matches) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());


/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		icon: new L.Icon.Default(),
		title: '',
		alt: '',
		clickable: true,
		draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._map = map;

		map.on('viewreset', this.update, this);

		this._initIcon();
		this.update();
		this.fire('add');

		if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
			map.on('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		if (this.dragging) {
			this.dragging.disable();
		}

		this._removeIcon();
		this._removeShadow();

		this.fire('remove');

		map.off({
			'viewreset': this.update,
			'zoomanim': this._animateZoom
		}, this);

		this._map = null;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);

		this.update();

		return this.fire('move', { latlng: this._latlng });
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		this.update();

		return this;
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup);
		}

		return this;
	},

	update: function () {
		if (this._icon) {
			this._setPos(this._map.latLngToLayerPoint(this._latlng).round());
		}
		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    map = this._map,
		    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
		    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		this._initInteraction();

		if (options.riseOnHover) {
			L.DomEvent
				.on(icon, 'mouseover', this._bringToFront, this)
				.on(icon, 'mouseout', this._resetZIndex, this);
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		var panes = this._map._panes;

		if (addIcon) {
			panes.markerPane.appendChild(this._icon);
		}

		if (newShadow && addShadow) {
			panes.shadowPane.appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent
			    .off(this._icon, 'mouseover', this._bringToFront)
			    .off(this._icon, 'mouseout', this._resetZIndex);
		}

		this._map._panes.markerPane.removeChild(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			this._map._panes.shadowPane.removeChild(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.clickable) { return; }

		// TODO refactor into something shared with Map/Path/etc. to DRY it up

		var icon = this._icon,
		    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

		L.DomUtil.addClass(icon, 'leaflet-clickable');
		L.DomEvent.on(icon, 'click', this._onMouseClick, this);
		L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

		for (var i = 0; i < events.length; i++) {
			L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
		}

		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);

			if (this.options.draggable) {
				this.dragging.enable();
			}
		}
	},

	_onMouseClick: function (e) {
		var wasDragged = this.dragging && this.dragging.moved();

		if (this.hasEventListeners(e.type) || wasDragged) {
			L.DomEvent.stopPropagation(e);
		}

		if (wasDragged) { return; }

		if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});
	},

	_onKeyPress: function (e) {
		if (e.keyCode === 13) {
			this.fire('click', {
				originalEvent: e,
				latlng: this._latlng
			});
		}
	},

	_fireMouseEvent: function (e) {

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});

		// TODO proper custom event propagation
		// this line will always be called if marker is in a FeatureGroup
		if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousedown') {
			L.DomEvent.stopPropagation(e);
		} else {
			L.DomEvent.preventDefault(e);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._icon, this.options.opacity);
		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, this.options.opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};


/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html !== false) {
			div.innerHTML = options.html;
		} else {
			div.innerHTML = '';
		}

		if (options.bgPos) {
			div.style.backgroundPosition =
			        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}

		this._setIconStyles(div, 'icon');
		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};


/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minWidth: 50,
		maxWidth: 300,
		// maxHeight: null,
		autoPan: true,
		closeButton: true,
		offset: [0, 7],
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: null,
		// autoPanPaddingBottomRight: null,
		keepInView: false,
		className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
		this._animated = L.Browser.any3d && this.options.zoomAnimation;
		this._isOpen = false;
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initLayout();
		}

		var animFade = map.options.fadeAnimation;

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 0);
		}
		map._panes.popupPane.appendChild(this._container);

		map.on(this._getEvents(), this);

		this.update();

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.fire('open');

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this});
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		map._panes.popupPane.removeChild(this._container);

		L.Util.falseFn(this._container.offsetWidth); // force reflow

		map.off(this._getEvents(), this);

		if (map.options.fadeAnimation) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		this._map = null;

		this.fire('close');

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this});
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	_getEvents: function () {
		var events = {
			viewreset: this._updatePosition
		};

		if (this._animated) {
			events.zoomanim = this._zoomAnimation;
		}
		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
			        (this._animated ? 'animated' : 'hide'),
			container = this._container = L.DomUtil.create('div', containerClass),
			closeButton;

		if (this.options.closeButton) {
			closeButton = this._closeButton =
			        L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';
			L.DomEvent.disableClickPropagation(closeButton);

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper =
		        L.DomUtil.create('div', prefix + '-content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);

		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent.disableScrollPropagation(this._contentNode);
		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		if (typeof this._content === 'string') {
			this._contentNode.innerHTML = this._content;
		} else {
			while (this._contentNode.hasChildNodes()) {
				this._contentNode.removeChild(this._contentNode.firstChild);
			}
			this._contentNode.appendChild(this._content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    animated = this._animated,
		    offset = L.point(this.options.offset);

		if (animated) {
			L.DomUtil.setPosition(this._container, pos);
		}

		this._containerBottom = -offset.y - (animated ? 0 : pos.y);
		this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = this._containerBottom + 'px';
		this._container.style.left = this._containerLeft + 'px';
	},

	_zoomAnimation: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,

		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._animated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		this.closePopup();

		if (!(popup instanceof L.Popup)) {
			var content = popup;

			popup = new L.Popup(options)
			    .setLatLng(latlng)
			    .setContent(content);
		}
		popup._isOpen = true;

		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
			popup._isOpen = false;
		}
		return this;
	}
});


/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	openPopup: function () {
		if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
			this._popup.setLatLng(this._latlng);
			this._map.openPopup(this._popup);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function () {
		if (this._popup) {
			if (this._popup._isOpen) {
				this.closePopup();
			} else {
				this.openPopup();
			}
		}
		return this;
	},

	bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

		anchor = anchor.add(L.Popup.prototype.options.offset);

		if (options && options.offset) {
			anchor = anchor.add(options.offset);
		}

		options = L.extend({offset: anchor}, options);

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this.togglePopup, this)
			    .on('remove', this.closePopup, this)
			    .on('move', this._movePopup, this);
			this._popupHandlersAdded = true;
		}

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			this._popup = new L.Popup(options, this)
				.setContent(content);
		}

		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this.togglePopup, this)
			    .off('remove', this.closePopup, this)
			    .off('move', this._movePopup, this);
			this._popupHandlersAdded = false;
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});


/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Class.extend({
	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		this.eachLayer(this.removeLayer, this);
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this._map = map;
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
		this._map = null;
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};


/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({
	includes: L.Mixin.Events,

	statics: {
		EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
	},

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		if ('on' in layer) {
			layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.addLayer.call(this, layer);

		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions);
		}

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		if ('off' in layer) {
			layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		if (this._popupContent) {
			this.invoke('unbindPopup');
		}

		return this.fire('layerremove', {layer: layer});
	},

	bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke('bindPopup', content, options);
	},

	openPopup: function (latlng) {
		// open popup on the first layer
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break;
		}
		return this;
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		this.eachLayer(function (layer) {
			bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
		});

		return bounds;
	},

	_propagateEvent: function (e) {
		e = L.extend({
			layer: e.target,
			target: this
		}, e);
		this.fire(e.type, e);
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};


/*
 * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
 */

L.Path = L.Class.extend({
	includes: [L.Mixin.Events],

	statics: {
		// how much to extend the clip area around the map view
		// (relative to its size, e.g. 0.5 is half the screen in each direction)
		// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
		CLIP_PADDING: (function () {
			var max = L.Browser.mobile ? 1280 : 2000,
			    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
			return Math.max(0, Math.min(0.5, target));
		})()
	},

	options: {
		stroke: true,
		color: '#0033ff',
		dashArray: null,
		lineCap: null,
		lineJoin: null,
		weight: 5,
		opacity: 0.5,

		fill: false,
		fillColor: null, //same as color by default
		fillOpacity: 0.2,

		clickable: true
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initElements();
			this._initEvents();
		}

		this.projectLatlngs();
		this._updatePath();

		if (this._container) {
			this._map._pathRoot.appendChild(this._container);
		}

		this.fire('add');

		map.on({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		map._pathRoot.removeChild(this._container);

		// Need to fire remove event before we set _map to null as the event hooks might need the object
		this.fire('remove');
		this._map = null;

		if (L.Browser.vml) {
			this._container = null;
			this._stroke = null;
			this._fill = null;
		}

		map.off({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	projectLatlngs: function () {
		// do all projection stuff here
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._container) {
			this._updateStyle();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._updatePath();
		}
		return this;
	}
});

L.Map.include({
	_updatePathViewport: function () {
		var p = L.Path.CLIP_PADDING,
		    size = this.getSize(),
		    panePos = L.DomUtil.getPosition(this._mapPane),
		    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
		    max = min.add(size.multiplyBy(1 + p * 2)._round());

		this._pathViewport = new L.Bounds(min, max);
	}
});


/*
 * Extends L.Path with SVG-specific rendering code.
 */

L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

L.Path = L.Path.extend({
	statics: {
		SVG: L.Browser.svg
	},

	bringToFront: function () {
		var root = this._map._pathRoot,
		    path = this._container;

		if (path && root.lastChild !== path) {
			root.appendChild(path);
		}
		return this;
	},

	bringToBack: function () {
		var root = this._map._pathRoot,
		    path = this._container,
		    first = root.firstChild;

		if (path && first !== path) {
			root.insertBefore(path, first);
		}
		return this;
	},

	getPathString: function () {
		// form path string here
	},

	_createElement: function (name) {
		return document.createElementNS(L.Path.SVG_NS, name);
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._initPath();
		this._initStyle();
	},

	_initPath: function () {
		this._container = this._createElement('g');

		this._path = this._createElement('path');

		if (this.options.className) {
			L.DomUtil.addClass(this._path, this.options.className);
		}

		this._container.appendChild(this._path);
	},

	_initStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke-linejoin', 'round');
			this._path.setAttribute('stroke-linecap', 'round');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill-rule', 'evenodd');
		}
		if (this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', this.options.pointerEvents);
		}
		if (!this.options.clickable && !this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', 'none');
		}
		this._updateStyle();
	},

	_updateStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke', this.options.color);
			this._path.setAttribute('stroke-opacity', this.options.opacity);
			this._path.setAttribute('stroke-width', this.options.weight);
			if (this.options.dashArray) {
				this._path.setAttribute('stroke-dasharray', this.options.dashArray);
			} else {
				this._path.removeAttribute('stroke-dasharray');
			}
			if (this.options.lineCap) {
				this._path.setAttribute('stroke-linecap', this.options.lineCap);
			}
			if (this.options.lineJoin) {
				this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
			}
		} else {
			this._path.setAttribute('stroke', 'none');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill', this.options.fillColor || this.options.color);
			this._path.setAttribute('fill-opacity', this.options.fillOpacity);
		} else {
			this._path.setAttribute('fill', 'none');
		}
	},

	_updatePath: function () {
		var str = this.getPathString();
		if (!str) {
			// fix webkit empty string parsing bug
			str = 'M0 0';
		}
		this._path.setAttribute('d', str);
	},

	// TODO remove duplication with L.Map
	_initEvents: function () {
		if (this.options.clickable) {
			if (L.Browser.svg || !L.Browser.vml) {
				L.DomUtil.addClass(this._path, 'leaflet-clickable');
			}

			L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

			var events = ['dblclick', 'mousedown', 'mouseover',
			              'mouseout', 'mousemove', 'contextmenu'];
			for (var i = 0; i < events.length; i++) {
				L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
			}
		}
	},

	_onMouseClick: function (e) {
		if (this._map.dragging && this._map.dragging.moved()) { return; }

		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._map || !this.hasEventListeners(e.type)) { return; }

		var map = this._map,
		    containerPoint = map.mouseEventToContainerPoint(e),
		    layerPoint = map.containerPointToLayerPoint(containerPoint),
		    latlng = map.layerPointToLatLng(layerPoint);

		this.fire(e.type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});

		if (e.type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousemove') {
			L.DomEvent.stopPropagation(e);
		}
	}
});

L.Map.include({
	_initPathRoot: function () {
		if (!this._pathRoot) {
			this._pathRoot = L.Path.prototype._createElement('svg');
			this._panes.overlayPane.appendChild(this._pathRoot);

			if (this.options.zoomAnimation && L.Browser.any3d) {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

				this.on({
					'zoomanim': this._animatePathZoom,
					'zoomend': this._endPathZoom
				});
			} else {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
			}

			this.on('moveend', this._updateSvgViewport);
			this._updateSvgViewport();
		}
	},

	_animatePathZoom: function (e) {
		var scale = this.getZoomScale(e.zoom),
		    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

		this._pathRoot.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

		this._pathZooming = true;
	},

	_endPathZoom: function () {
		this._pathZooming = false;
	},

	_updateSvgViewport: function () {

		if (this._pathZooming) {
			// Do not update SVGs while a zoom animation is going on otherwise the animation will break.
			// When the zoom animation ends we will be updated again anyway
			// This fixes the case where you do a momentum move and zoom while the move is still ongoing.
			return;
		}

		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    max = vp.max,
		    width = max.x - min.x,
		    height = max.y - min.y,
		    root = this._pathRoot,
		    pane = this._panes.overlayPane;

		// Hack to make flicker on drag end on mobile webkit less irritating
		if (L.Browser.mobileWebkit) {
			pane.removeChild(root);
		}

		L.DomUtil.setPosition(root, min);
		root.setAttribute('width', width);
		root.setAttribute('height', height);
		root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

		if (L.Browser.mobileWebkit) {
			pane.appendChild(root);
		}
	}
});


/*
 * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
 */

L.Path.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			this._popup = content;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this._openPopup, this)
			    .on('remove', this.closePopup, this);

			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this._openPopup)
			    .off('remove', this.closePopup);

			this._popupHandlersAdded = false;
		}
		return this;
	},

	openPopup: function (latlng) {

		if (this._popup) {
			// open the popup from one of the path's points if not specified
			latlng = latlng || this._latlng ||
			         this._latlngs[Math.floor(this._latlngs.length / 2)];

			this._openPopup({latlng: latlng});
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	_openPopup: function (e) {
		this._popup.setLatLng(e.latlng);
		this._map.openPopup(this._popup);
	}
});


/*
 * Vector rendering for IE6-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
	statics: {
		VML: true,
		CLIP_PADDING: 0.02
	},

	_createElement: (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement(
				        '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	}()),

	_initPath: function () {
		var container = this._container = this._createElement('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape' +
			(this.options.className ? ' ' + this.options.className : ''));

		if (this.options.clickable) {
			L.DomUtil.addClass(container, 'leaflet-clickable');
		}

		container.coordsize = '1 1';

		this._path = this._createElement('path');
		container.appendChild(this._path);

		this._map._pathRoot.appendChild(container);
	},

	_initStyle: function () {
		this._updateStyle();
	},

	_updateStyle: function () {
		var stroke = this._stroke,
		    fill = this._fill,
		    options = this.options,
		    container = this._container;

		container.stroked = options.stroke;
		container.filled = options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = this._stroke = this._createElement('stroke');
				stroke.endcap = 'round';
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			if (options.lineCap) {
				stroke.endcap = options.lineCap.replace('butt', 'flat');
			}
			if (options.lineJoin) {
				stroke.joinstyle = options.lineJoin;
			}

		} else if (stroke) {
			container.removeChild(stroke);
			this._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = this._fill = this._createElement('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			this._fill = null;
		}
	},

	_updatePath: function () {
		var style = this._container.style;

		style.display = 'none';
		this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
		style.display = '';
	}
});

L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
	_initPathRoot: function () {
		if (this._pathRoot) { return; }

		var root = this._pathRoot = document.createElement('div');
		root.className = 'leaflet-vml-container';
		this._panes.overlayPane.appendChild(root);

		this.on('moveend', this._updatePathViewport);
		this._updatePathViewport();
	}
});


/*
 * Vector rendering for all browsers that support canvas.
 */

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
	statics: {
		//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
		CANVAS: true,
		SVG: false
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._requestUpdate();
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._map) {
			this._updateStyle();
			this._requestUpdate();
		}
		return this;
	},

	onRemove: function (map) {
		map
		    .off('viewreset', this.projectLatlngs, this)
		    .off('moveend', this._updatePath, this);

		if (this.options.clickable) {
			this._map.off('click', this._onClick, this);
			this._map.off('mousemove', this._onMouseMove, this);
		}

		this._requestUpdate();
		
		this.fire('remove');
		this._map = null;
	},

	_requestUpdate: function () {
		if (this._map && !L.Path._updateRequest) {
			L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
		}
	},

	_fireMapMoveEnd: function () {
		L.Path._updateRequest = null;
		this.fire('moveend');
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._ctx = this._map._canvasCtx;
	},

	_updateStyle: function () {
		var options = this.options;

		if (options.stroke) {
			this._ctx.lineWidth = options.weight;
			this._ctx.strokeStyle = options.color;
		}
		if (options.fill) {
			this._ctx.fillStyle = options.fillColor || options.color;
		}

		if (options.lineCap) {
			this._ctx.lineCap = options.lineCap;
		}
		if (options.lineJoin) {
			this._ctx.lineJoin = options.lineJoin;
		}
	},

	_drawPath: function () {
		var i, j, len, len2, point, drawMethod;

		this._ctx.beginPath();

		for (i = 0, len = this._parts.length; i < len; i++) {
			for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
				point = this._parts[i][j];
				drawMethod = (j === 0 ? 'move' : 'line') + 'To';

				this._ctx[drawMethod](point.x, point.y);
			}
			// TODO refactor ugly hack
			if (this instanceof L.Polygon) {
				this._ctx.closePath();
			}
		}
	},

	_checkIfEmpty: function () {
		return !this._parts.length;
	},

	_updatePath: function () {
		if (this._checkIfEmpty()) { return; }

		var ctx = this._ctx,
		    options = this.options;

		this._drawPath();
		ctx.save();
		this._updateStyle();

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke) {
			ctx.globalAlpha = options.opacity;
			ctx.stroke();
		}

		ctx.restore();

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_initEvents: function () {
		if (this.options.clickable) {
			this._map.on('mousemove', this._onMouseMove, this);
			this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);
		}
	},

	_fireMouseEvent: function (e) {
		if (this._containsPoint(e.layerPoint)) {
			this.fire(e.type, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		// TODO don't do on each move
		if (this._containsPoint(e.layerPoint)) {
			this._ctx.canvas.style.cursor = 'pointer';
			this._mouseInside = true;
			this.fire('mouseover', e);

		} else if (this._mouseInside) {
			this._ctx.canvas.style.cursor = '';
			this._mouseInside = false;
			this.fire('mouseout', e);
		}
	}
});

L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
	_initPathRoot: function () {
		var root = this._pathRoot,
		    ctx;

		if (!root) {
			root = this._pathRoot = document.createElement('canvas');
			root.style.position = 'absolute';
			ctx = this._canvasCtx = root.getContext('2d');

			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			this._panes.overlayPane.appendChild(root);

			if (this.options.zoomAnimation) {
				this._pathRoot.className = 'leaflet-zoom-animated';
				this.on('zoomanim', this._animatePathZoom);
				this.on('zoomend', this._endPathZoom);
			}
			this.on('moveend', this._updateCanvasViewport);
			this._updateCanvasViewport();
		}
	},

	_updateCanvasViewport: function () {
		// don't redraw while zooming. See _updateSvgViewport for more details
		if (this._pathZooming) { return; }
		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    size = vp.max.subtract(min),
		    root = this._pathRoot;

		//TODO check if this works properly on mobile webkit
		L.DomUtil.setPosition(root, min);
		root.width = size.x;
		root.height = size.y;
		root.getContext('2d').translate(-min.x, -min.y);
	}
});


/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

/*jshint bitwise:false */ // allow bitwise operations for this file

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max;

		if (code & 8) { // top
			return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
		} else if (code & 4) { // bottom
			return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
		} else if (code & 2) { // right
			return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
		} else if (code & 1) { // left
			return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
		}
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}
		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};


/*
 * L.Polyline is used to display polylines on a map.
 */

L.Polyline = L.Path.extend({
	initialize: function (latlngs, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlngs = this._convertLatLngs(latlngs);
	},

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0,
		noClip: false
	},

	projectLatlngs: function () {
		this._originalPoints = [];

		for (var i = 0, len = this._latlngs.length; i < len; i++) {
			this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
		}
	},

	getPathString: function () {
		for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
			str += this._getPathPartStr(this._parts[i]);
		}
		return str;
	},

	getLatLngs: function () {
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._latlngs = this._convertLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		this._latlngs.push(L.latLng(latlng));
		return this.redraw();
	},

	spliceLatLngs: function () { // (Number index, Number howMany)
		var removed = [].splice.apply(this._latlngs, arguments);
		this._convertLatLngs(this._latlngs, true);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

		for (var j = 0, jLen = parts.length; j < jLen; j++) {
			var points = parts[j];
			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];
				var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getBounds: function () {
		return new L.LatLngBounds(this.getLatLngs());
	},

	_convertLatLngs: function (latlngs, overwrite) {
		var i, len, target = overwrite ? latlngs : [];

		for (i = 0, len = latlngs.length; i < len; i++) {
			if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
				return;
			}
			target[i] = L.latLng(latlngs[i]);
		}
		return target;
	},

	_initEvents: function () {
		L.Path.prototype._initEvents.call(this);
	},

	_getPathPartStr: function (points) {
		var round = L.Path.VML;

		for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
			p = points[j];
			if (round) {
				p._round();
			}
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}
		return str;
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    len = points.length,
		    i, k, segment;

		if (this.options.noClip) {
			this._parts = [points];
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    vp = this._map._pathViewport,
		    lu = L.LineUtil;

		for (i = 0, k = 0; i < len - 1; i++) {
			segment = lu.clipSegment(points[i], points[i + 1], vp, i);
			if (!segment) {
				continue;
			}

			parts[k] = parts[k] || [];
			parts[k].push(segment[0]);

			// if segment goes out of screen, or it's the last one, it's the end of the line part
			if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
				parts[k].push(segment[1]);
				k++;
			}
		}
	},

	// simplify each clipped part of the polyline
	_simplifyPoints: function () {
		var parts = this._parts,
		    lu = L.LineUtil;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
		}
	},

	_updatePath: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();

		L.Path.prototype._updatePath.call(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};


/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

/*jshint bitwise:false */ // allow bitwise operations here

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};


/*
 * L.Polygon is used to display polygons on a map.
 */

L.Polygon = L.Polyline.extend({
	options: {
		fill: true
	},

	initialize: function (latlngs, options) {
		L.Polyline.prototype.initialize.call(this, latlngs, options);
		this._initWithHoles(latlngs);
	},

	_initWithHoles: function (latlngs) {
		var i, len, hole;
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._latlngs = this._convertLatLngs(latlngs[0]);
			this._holes = latlngs.slice(1);

			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
				if (hole[0].equals(hole[hole.length - 1])) {
					hole.pop();
				}
			}
		}

		// filter out last point if its equal to the first one
		latlngs = this._latlngs;

		if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
			latlngs.pop();
		}
	},

	projectLatlngs: function () {
		L.Polyline.prototype.projectLatlngs.call(this);

		// project polygon holes points
		// TODO move this logic to Polyline to get rid of duplication
		this._holePoints = [];

		if (!this._holes) { return; }

		var i, j, len, len2;

		for (i = 0, len = this._holes.length; i < len; i++) {
			this._holePoints[i] = [];

			for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
				this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
			}
		}
	},

	setLatLngs: function (latlngs) {
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._initWithHoles(latlngs);
			return this.redraw();
		} else {
			return L.Polyline.prototype.setLatLngs.call(this, latlngs);
		}
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    newParts = [];

		this._parts = [points].concat(this._holePoints);

		if (this.options.noClip) { return; }

		for (var i = 0, len = this._parts.length; i < len; i++) {
			var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
			if (clipped.length) {
				newParts.push(clipped);
			}
		}

		this._parts = newParts;
	},

	_getPathPartStr: function (points) {
		var str = L.Polyline.prototype._getPathPartStr.call(this, points);
		return str + (L.Browser.svg ? 'z' : 'x');
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};


/*
 * Contains L.MultiPolyline and L.MultiPolygon layers.
 */

(function () {
	function createMulti(Klass) {

		return L.FeatureGroup.extend({

			initialize: function (latlngs, options) {
				this._layers = {};
				this._options = options;
				this.setLatLngs(latlngs);
			},

			setLatLngs: function (latlngs) {
				var i = 0,
				    len = latlngs.length;

				this.eachLayer(function (layer) {
					if (i < len) {
						layer.setLatLngs(latlngs[i++]);
					} else {
						this.removeLayer(layer);
					}
				}, this);

				while (i < len) {
					this.addLayer(new Klass(latlngs[i++], this._options));
				}

				return this;
			},

			getLatLngs: function () {
				var latlngs = [];

				this.eachLayer(function (layer) {
					latlngs.push(layer.getLatLngs());
				});

				return latlngs;
			}
		});
	}

	L.MultiPolyline = createMulti(L.Polyline);
	L.MultiPolygon = createMulti(L.Polygon);

	L.multiPolyline = function (latlngs, options) {
		return new L.MultiPolyline(latlngs, options);
	};

	L.multiPolygon = function (latlngs, options) {
		return new L.MultiPolygon(latlngs, options);
	};
}());


/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};


/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 */

L.Circle = L.Path.extend({
	initialize: function (latlng, radius, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	options: {
		fill: true
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		return this.redraw();
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	projectLatlngs: function () {
		var lngRadius = this._getLngRadius(),
		    latlng = this._latlng,
		    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

		this._point = this._map.latLngToLayerPoint(latlng);
		this._radius = Math.max(this._point.x - pointLeft.x, 1);
	},

	getBounds: function () {
		var lngRadius = this._getLngRadius(),
		    latRadius = (this._mRadius / 40075017) * 360,
		    latlng = this._latlng;

		return new L.LatLngBounds(
		        [latlng.lat - latRadius, latlng.lng - lngRadius],
		        [latlng.lat + latRadius, latlng.lng + lngRadius]);
	},

	getLatLng: function () {
		return this._latlng;
	},

	getPathString: function () {
		var p = this._point,
		    r = this._radius;

		if (this._checkIfEmpty()) {
			return '';
		}

		if (L.Browser.svg) {
			return 'M' + p.x + ',' + (p.y - r) +
			       'A' + r + ',' + r + ',0,1,1,' +
			       (p.x - 0.1) + ',' + (p.y - r) + ' z';
		} else {
			p._round();
			r = Math.round(r);
			return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
		}
	},

	getRadius: function () {
		return this._mRadius;
	},

	// TODO Earth hardcoded, move into projection code!

	_getLatRadius: function () {
		return (this._mRadius / 40075017) * 360;
	},

	_getLngRadius: function () {
		return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
	},

	_checkIfEmpty: function () {
		if (!this._map) {
			return false;
		}
		var vp = this._map._pathViewport,
		    r = this._radius,
		    p = this._point;

		return p.x - r > vp.max.x || p.y - r > vp.max.y ||
		       p.x + r < vp.min.x || p.y + r < vp.min.y;
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};


/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Circle.extend({
	options: {
		radius: 10,
		weight: 2
	},

	initialize: function (latlng, options) {
		L.Circle.prototype.initialize.call(this, latlng, null, options);
		this._radius = this.options.radius;
	},

	projectLatlngs: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
	},

	_updateStyle : function () {
		L.Circle.prototype._updateStyle.call(this);
		this.setRadius(this.options.radius);
	},

	setLatLng: function (latlng) {
		L.Circle.prototype.setLatLng.call(this, latlng);
		if (this._popup && this._popup._isOpen) {
			this._popup.setLatLng(latlng);
		}
		return this;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};


/*
 * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
 */

L.Polyline.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, dist, part,
		    w = this.options.weight / 2;

		if (L.Browser.touch) {
			w += 10; // polyline click tolerance on touch devices
		}

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) {
					continue;
				}

				dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

				if (dist <= w) {
					return true;
				}
			}
		}
		return false;
	}
});


/*
 * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
 */

L.Polygon.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2,
		    i, j, k,
		    len, len2;

		// TODO optimization: check if within bounds first

		if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
			// click on polygon border
			return true;
		}

		// ray casting algorithm for detecting if point is in polygon

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) &&
						(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		return inside;
	}
});


/*
 * Extends L.Circle with Canvas-specific code.
 */

L.Circle.include(!L.Path.CANVAS ? {} : {
	_drawPath: function () {
		var p = this._point;
		this._ctx.beginPath();
		this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
	},

	_containsPoint: function (p) {
		var center = this._point,
		    w2 = this.options.stroke ? this.options.weight / 2 : 0;

		return (p.distanceTo(center) <= this._radius + w2);
	}
});


/*
 * CircleMarker canvas specific drawing parts.
 */

L.CircleMarker.include(!L.Path.CANVAS ? {} : {
	_updateStyle: function () {
		L.Path.prototype._updateStyle.call(this);
	}
});


/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// Only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(features[i]);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		var style = this.options.style;
		if (style) {
			// reset any custom styles
			L.Util.extend(layer.options, layer.defaultOptions);

			this._setLayerStyle(layer, style);
		}
	},

	setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    latlng, latlngs, i, len;

		coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
			latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
			return new L.Polyline(latlngs, vectorOptions);

		case 'Polygon':
			if (coords.length === 2 && !coords[1].length) {
				throw new Error('Invalid GeoJSON object.');
			}
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.Polygon(latlngs, vectorOptions);

		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.MultiPolyline(latlngs, vectorOptions);

		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
			return new L.MultiPolygon(latlngs, vectorOptions);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, pointToLayer, coordsToLatLng, vectorOptions));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
		var latlng, i, len,
		    latlngs = [];

		for (i = 0, len = coords.length; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		var coords = [latlng.lng, latlng.lat];

		if (latlng.alt !== undefined) {
			coords.push(latlng.alt);
		}
		return coords;
	},

	latLngsToCoords: function (latLngs) {
		var coords = [];

		for (var i = 0, len = latLngs.length; i < len; i++) {
			coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.include({
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'LineString',
			coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
		});
	}
});

L.Polygon.include({
	toGeoJSON: function () {
		var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
		    i, len, hole;

		coords[0].push(coords[0][0]);

		if (this._holes) {
			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
				hole.push(hole[0]);
				coords.push(hole);
			}
		}

		return L.GeoJSON.getFeature(this, {
			type: 'Polygon',
			coordinates: coords
		});
	}
});

(function () {
	function multiToGeoJSON(type) {
		return function () {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON().geometry.coordinates);
			});

			return L.GeoJSON.getFeature(this, {
				type: type,
				coordinates: coords
			});
		};
	}

	L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
	L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

	L.LayerGroup.include({
		toGeoJSON: function () {

			var geometry = this.feature && this.feature.geometry,
				jsons = [],
				json;

			if (geometry && geometry.type === 'MultiPoint') {
				return multiToGeoJSON('MultiPoint').call(this);
			}

			var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					json = layer.toGeoJSON();
					jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
				}
			});

			if (isGeometryCollection) {
				return L.GeoJSON.getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});
}());

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};


/*
 * L.DomEvent contains functions for working with DOM events.
 */

L.DomEvent = {
	/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
	addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler, originalHandler, newType;

		if (obj[key]) { return this; }

		handler = function (e) {
			return fn.call(context || obj, e || L.DomEvent._getEvent());
		};

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			return this.addPointerListener(obj, type, handler, id);
		}
		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);
		}

		if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {

				originalHandler = handler;
				newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

				handler = function (e) {
					if (!L.DomEvent._checkMouse(obj, e)) { return; }
					return originalHandler(e);
				};

				obj.addEventListener(newType, handler, false);

			} else if (type === 'click' && L.Browser.android) {
				originalHandler = handler;
				handler = function (e) {
					return L.DomEvent._filterClick(e, originalHandler);
				};

				obj.addEventListener(type, handler, false);
			} else {
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[key] = handler;

		return this;
	},

	removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler = obj[key];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);
		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
			} else {
				obj.removeEventListener(type, handler, false);
			}
		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[key] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		return L.DomEvent
			.on(el, 'mousewheel', stop)
			.on(el, 'MozMousePixelScroll', stop);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(el, L.Draggable.START[i], stop);
		}

		return L.DomEvent
			.on(el, 'click', L.DomEvent._fakeStop)
			.on(el, 'dblclick', stop);
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	_getEvent: function () { // evil magic for IE
		/*jshint noarg:false */
		var e = window.event;
		if (!e) {
			var caller = arguments.callee.caller;
			while (caller) {
				e = caller['arguments'][0];
				if (e && window.Event === e.constructor) {
					break;
				}
				caller = caller.caller;
			}
		}
		return e;
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		return handler(e);
	}
};

L.DomEvent.on = L.DomEvent.addListener;
L.DomEvent.off = L.DomEvent.removeListener;


/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Class.extend({
	includes: L.Mixin.Events,

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
	},

	enable: function () {
		if (this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (L.Draggable._disabled) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');
			this._lastTarget = e.target || e.srcElement;
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		this.fire('predrag');
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag');
	},

	_onUp: function () {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove)
			    .off(document, L.Draggable.END[i], this._onUp);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});


/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});


/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
	easeLinearity: 0.25,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				'dragstart': this._onDragStart,
				'drag': this._onDrag,
				'dragend': this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		var map = this._map;

		if (map._panAnim) {
			map._panAnim.stop();
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move')
		    .fire('drag');
	},

	_onViewReset: function () {
		// TODO fix hardcoded Earth values
		var pxCenter = this._map.getSize()._divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.project([0, 180]).x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,
		    delay = +new Date() - this._lastTime,

		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime + delay - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
		L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
		L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(40 - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.preventDefault(e);
		L.DomEvent.stopPropagation(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last,
		    doubleTap = false,
		    delay = 250,
		    touch,
		    pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend,
		    trackedTouches = [];

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length;
			} else {
				count = e.touches.length;
			}
			if (count > 1) {
				return;
			}

			var now = Date.now(),
				delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) {
					return;
				}
				trackedTouches.splice(idx, 1);
			}

			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = { },
						prop;

					// jshint forin:false
					for (var i in touch) {
						prop = touch[i];
						if (typeof prop === 'function') {
							newTouch[i] = prop.bind(touch);
						} else {
							newTouch[i] = prop;
						}
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}
		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
		// will not come through to us, so we will lose track of how many touches are ongoing
		var endElement = L.Browser.pointer ? document.documentElement : obj;

		obj.addEventListener(touchstart, onTouchStart, false);
		endElement.addEventListener(touchend, onTouchEnd, false);

		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_';

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		(L.Browser.pointer ? document.documentElement : obj).removeEventListener(
		        this._touchend, obj[pre + this._touchend + id], false);

		if (L.Browser.pointer) {
			document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
				false);
		}

		return this;
	}
});


/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	//static
	POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
	POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
	POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: [],
	_pointerDocumentListener: false,

	// Provides a touch events wrapper for (ms)pointer events.
	// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
	//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		switch (type) {
		case 'touchstart':
			return this.addPointerListenerStart(obj, type, handler, id);
		case 'touchend':
			return this.addPointerListenerEnd(obj, type, handler, id);
		case 'touchmove':
			return this.addPointerListenerMove(obj, type, handler, id);
		default:
			throw 'Unknown touch event type';
		}
	},

	addPointerListenerStart: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    pointers = this._pointers;

		var cb = function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				L.DomEvent.preventDefault(e);
			}

			var alreadyInArray = false;
			for (var i = 0; i < pointers.length; i++) {
				if (pointers[i].pointerId === e.pointerId) {
					alreadyInArray = true;
					break;
				}
			}
			if (!alreadyInArray) {
				pointers.push(e);
			}

			e.touches = pointers.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchstart' + id] = cb;
		obj.addEventListener(this.POINTER_DOWN, cb, false);

		// need to also listen for end events to keep the _pointers list accurate
		// this needs to be on the body and never go away
		if (!this._pointerDocumentListener) {
			var internalCb = function (e) {
				for (var i = 0; i < pointers.length; i++) {
					if (pointers[i].pointerId === e.pointerId) {
						pointers.splice(i, 1);
						break;
					}
				}
			};
			//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

			this._pointerDocumentListener = true;
		}

		return this;
	},

	addPointerListenerMove: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		function cb(e) {

			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches[i] = e;
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		}

		obj[pre + 'touchmove' + id] = cb;
		obj.addEventListener(this.POINTER_MOVE, cb, false);

		return this;
	},

	addPointerListenerEnd: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		var cb = function (e) {
			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches.splice(i, 1);
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchend' + id] = cb;
		obj.addEventListener(this.POINTER_UP, cb, false);
		obj.addEventListener(this.POINTER_CANCEL, cb, false);

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var pre = '_leaflet_',
		    cb = obj[pre + type + id];

		switch (type) {
		case 'touchstart':
			obj.removeEventListener(this.POINTER_DOWN, cb, false);
			break;
		case 'touchmove':
			obj.removeEventListener(this.POINTER_MOVE, cb, false);
			break;
		case 'touchend':
			obj.removeEventListener(this.POINTER_UP, cb, false);
			obj.removeEventListener(this.POINTER_CANCEL, cb, false);
			break;
		}

		return this;
	}
});


/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		if (map._panAnim) {
			map._panAnim.stop();
		}

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (this._scale === 1) { return; }

		if (!map.options.bounceAtZoomLimits) {
			if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
			    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
		}

		if (!this._moved) {
			L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(
		        this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map,
		    origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),
		    zoom = map.getScaleZoom(this._scale);

		map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		var map = this._map;

		this._zooming = false;
		L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),

		    oldZoom = map.getZoom(),
		    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
		    roundZoomDelta = (floatZoomDelta > 0 ?
		            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

		    zoom = map._limitZoom(oldZoom + roundZoomDelta),
		    scale = map.getZoomScale(zoom) / this._scale;

		map._animateZoom(center, zoom, origin, scale);
	},

	_getScaleOrigin: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		L.DomEvent
			.on(document, 'touchmove', this._onMove, this)
			.on(document, 'touchend', this._onUp, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent
			.off(document, 'touchmove', this._onMove, this)
			.off(document, 'touchend', this._onUp, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}


/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._moved = false;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
		this._moved = false;
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		this._moved = false;

		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

		L.DomEvent
		    .on(document, 'mousemove', this._onMouseMove, this)
		    .on(document, 'mouseup', this._onMouseUp, this)
		    .on(document, 'keydown', this._onKeyDown, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
			L.DomUtil.setPosition(this._box, this._startLayerPoint);

			//TODO refactor: move cursor to styles
			this._container.style.cursor = 'crosshair';
			this._map.fire('boxzoomstart');
		}

		var startPoint = this._startLayerPoint,
		    box = this._box,

		    layerPoint = this._map.mouseEventToLayerPoint(e),
		    offset = layerPoint.subtract(startPoint),

		    newPos = new L.Point(
		        Math.min(layerPoint.x, startPoint.x),
		        Math.min(layerPoint.y, startPoint.y));

		L.DomUtil.setPosition(box, newPos);

		this._moved = true;

		// TODO refactor: remove hardcoded 4 pixels
		box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
		box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
	},

	_finish: function () {
		if (this._moved) {
			this._pane.removeChild(this._box);
			this._container.style.cursor = '';
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent
		    .off(document, 'mousemove', this._onMouseMove)
		    .off(document, 'mouseup', this._onMouseUp)
		    .off(document, 'keydown', this._onKeyDown);
	},

	_onMouseUp: function (e) {

		this._finish();

		var map = this._map,
		    layerPoint = map.mouseEventToLayerPoint(e);

		if (this._startLayerPoint.equals(layerPoint)) { return; }

		var bounds = new L.LatLngBounds(
		        map.layerPointToLatLng(this._startLayerPoint),
		        map.layerPointToLatLng(layerPoint));

		map.fitBounds(bounds);

		map.fire('boxzoomend', {
			boxZoomBounds: bounds
		});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent
		    .on(container, 'focus', this._onFocus, this)
		    .on(container, 'blur', this._onBlur, this)
		    .on(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .on('focus', this._addHooks, this)
		    .on('blur', this._removeHooks, this);
	},

	removeHooks: function () {
		this._removeHooks();

		var container = this._map._container;

		L.DomEvent
		    .off(container, 'focus', this._onFocus, this)
		    .off(container, 'blur', this._onBlur, this)
		    .off(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .off('focus', this._addHooks, this)
		    .off('blur', this._removeHooks, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key]);

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;
		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon);
		}

		this._draggable
			.on('dragstart', this._onDragStart, this)
			.on('drag', this._onDrag, this)
			.on('dragend', this._onDragEnd, this);
		this._draggable.enable();
		L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable
			.off('dragstart', this._onDragStart, this)
			.off('drag', this._onDrag, this)
			.off('dragend', this._onDragEnd, this);

		this._draggable.disable();
		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function () {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;

		marker
		    .fire('move', {latlng: latlng})
		    .fire('drag');
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});


/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	removeFrom: function (map) {
		var pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		corner.removeChild(this._container);
		this._map = null;

		if (this.onRemove) {
			this.onRemove(map);
		}

		return this;
	},

	_refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.removeFrom(this);
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		this._container.removeChild(this._controlContainer);
	}
});


/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
	options: {
		position: 'topleft',
		zoomInText: '+',
		zoomInTitle: 'Zoom in',
		zoomOutText: '-',
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

		this._map = map;

		this._zoomInButton  = this._createButton(
		        this.options.zoomInText, this.options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn,  this);
		this._zoomOutButton = this._createButton(
		        this.options.zoomOutText, this.options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut, this);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	_zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1);
	},

	_zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1);
	},

	_createButton: function (html, title, className, container, fn, context) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
		    .on(link, 'click', stop)
		    .on(link, 'mousedown', stop)
		    .on(link, 'dblclick', stop)
		    .on(link, 'click', L.DomEvent.preventDefault)
		    .on(link, 'click', fn, context)
		    .on(link, 'click', this._refocusOnMap, context);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		L.DomEvent.disableClickPropagation(this._container);

		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}
		
		map
		    .on('layeradd', this._onLayerAdd, this)
		    .on('layerremove', this._onLayerRemove, this);

		this._update();

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerAdd)
		    .off('layerremove', this._onLayerRemove);

	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	},

	_onLayerAdd: function (e) {
		if (e.layer.getAttribution) {
			this.addAttribution(e.layer.getAttribution());
		}
	},

	_onLayerRemove: function (e) {
		if (e.layer.getAttribution) {
			this.removeAttribution(e.layer.getAttribution());
		}
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true,
		updateWhenIdle: false
	},

	onAdd: function (map) {
		this._map = map;

		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className, container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className + '-line', container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className + '-line', container);
		}
	},

	_update: function () {
		var bounds = this._map.getBounds(),
		    centerLat = bounds.getCenter().lat,
		    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
		    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

		    size = this._map.getSize(),
		    options = this.options,
		    maxMeters = 0;

		if (size.x > 0) {
			maxMeters = dist * (options.maxWidth / size.x);
		}

		this._updateScales(options, maxMeters);
	},

	_updateScales: function (options, maxMeters) {
		if (options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}

		if (options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters);

		this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
		this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    scale = this._iScale,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);

			scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
			scale.innerHTML = miles + ' mi';

		} else {
			feet = this._getRoundNum(maxFeet);

			scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
			scale.innerHTML = feet + ' ft';
		}
	},

	_getScaleWidth: function (ratio) {
		return Math.round(this.options.maxWidth * ratio) - 10;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};


/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		map
		    .on('layeradd', this._onLayerChange, this)
		    .on('layerremove', this._onLayerChange, this);

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerChange, this)
		    .off('layerremove', this._onLayerChange, this);
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		this._update();
		return this;
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		this._update();
		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);
		delete this._layers[id];
		this._update();
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent
				    .on(container, 'mouseover', this._expand, this)
				    .on(container, 'mouseout', this._collapse, this);
			}
			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			}
			else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}
			//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) {
			return;
		}

		this._baseLayersList.innerHTML = '';
		this._overlaysList.innerHTML = '';

		var baseLayersPresent = false,
		    overlaysPresent = false,
		    i, obj;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
	},

	_onLayerChange: function (e) {
		var obj = this._layers[L.stamp(e.layer)];

		if (!obj) { return; }

		if (!this._handlingClick) {
			this._update();
		}

		var type = obj.overlay ?
			(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'layeradd' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
		if (checked) {
			radioHtml += ' checked="checked"';
		}
		radioHtml += '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    input,
		    checked = this._map.hasLayer(obj.layer);

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var i, input, obj,
		    inputs = this._form.getElementsByTagName('input'),
		    inputsLen = inputs.length;

		this._handlingClick = true;

		for (i = 0; i < inputsLen; i++) {
			input = inputs[i];
			obj = this._layers[input.layerId];

			if (input.checked && !this._map.hasLayer(obj.layer)) {
				this._map.addLayer(obj.layer);

			} else if (!input.checked && this._map.hasLayer(obj.layer)) {
				this._map.removeLayer(obj.layer);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};


/*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */

L.PosAnimation = L.Class.extend({
	includes: L.Mixin.Events,

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;

		this.fire('start');

		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);

		// toggle reflow, Chrome flickers for some reason if you don't do this
		L.Util.falseFn(el.offsetWidth);

		// there's no native way to track value updates of transitioned properties, so we imitate this
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
	},

	stop: function () {
		if (!this._inProgress) { return; }

		// if we just removed the transition property, the element would jump to its final position,
		// so we need to make it stay at the current position

		L.DomUtil.setPosition(this._el, this._getPos());
		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
	},

	_onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return;
		}
		// jshint camelcase: false
		// make L.DomUtil.getPosition return intermediate position value during animation
		this._el._leaflet_pos = stepPos;

		this.fire('step');
	},

	// you can't easily get intermediate values of properties animated with CSS3 Transitions,
	// we need to parse computed style (in case of transform it returns matrix string)

	_transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

	_getPos: function () {
		var left, top, matches,
		    el = this._el,
		    style = window.getComputedStyle(el);

		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) { return; }
			left = parseFloat(matches[1]);
			top  = parseFloat(matches[2]);
		} else {
			left = parseFloat(style.left);
			top  = parseFloat(style.top);
		}

		return new L.Point(left, top, true);
	},

	_onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

		if (!this._inProgress) { return; }
		this._inProgress = false;

		this._el.style[L.DomUtil.TRANSITION] = '';

		// jshint camelcase: false
		// make sure L.DomUtil.getPosition returns the final position value after animation
		this._el._leaflet_pos = this._newPos;

		clearInterval(this._stepTimer);

		this.fire('step').fire('end');
	}

});


/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		if (this._panAnim) {
			this._panAnim.stop();
		}

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});


/*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */

L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step();
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function () {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration));
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});


/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

if (L.DomUtil.TRANSITION) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
				L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!L.DomUtil.TRANSITION ? {} : {

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
			origin = this._getCenterLayerPoint()._add(offset);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		this
		    .fire('movestart')
		    .fire('zoomstart');

		this._animateZoom(center, zoom, origin, scale, null, true);

		return true;
	},

	_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {

		if (!forTouchZoom) {
			this._animatingZoom = true;
		}

		// put transform transition on all layers with leaflet-zoom-animated class
		L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

		// remember what center/zoom to set after animation
		this._animateToCenter = center;
		this._animateToZoom = zoom;

		// disable any dragging during animation
		if (L.Draggable) {
			L.Draggable._disabled = true;
		}

		L.Util.requestAnimFrame(function () {
			this.fire('zoomanim', {
				center: center,
				zoom: zoom,
				origin: origin,
				scale: scale,
				delta: delta,
				backwards: backwards
			});
			// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689
			setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
		}, this);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		L.Util.requestAnimFrame(function () {
			this._resetView(this._animateToCenter, this._animateToZoom, true, true);

			if (L.Draggable) {
				L.Draggable._disabled = false;
			}
		}, this);
	}
});


/*
	Zoom animation logic for L.TileLayer.
*/

L.TileLayer.include({
	_animateZoom: function (e) {
		if (!this._animating) {
			this._animating = true;
			this._prepareBgBuffer();
		}

		var bg = this._bgBuffer,
		    transform = L.DomUtil.TRANSFORM,
		    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
		    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

		bg.style[transform] = e.backwards ?
				scaleStr + ' ' + initialTransform :
				initialTransform + ' ' + scaleStr;
	},

	_endZoomAnim: function () {
		var front = this._tileContainer,
		    bg = this._bgBuffer;

		front.style.visibility = '';
		front.parentNode.appendChild(front); // Bring to fore

		// force reflow
		L.Util.falseFn(bg.offsetWidth);

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			this._clearBgBuffer();
		}

		this._animating = false;
	},

	_clearBgBuffer: function () {
		var map = this._map;

		if (map && !map._animatingZoom && !map.touchZoom._zooming) {
			this._bgBuffer.innerHTML = '';
			this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
		}
	},

	_prepareBgBuffer: function () {

		var front = this._tileContainer,
		    bg = this._bgBuffer;

		// if foreground layer doesn't have many tiles but bg layer does,
		// keep the existing bg layer and just zoom it some more

		var bgLoaded = this._getLoadedTilesPercentage(bg),
		    frontLoaded = this._getLoadedTilesPercentage(front);

		if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

			front.style.visibility = 'hidden';
			this._stopLoadingImages(front);
			return;
		}

		// prepare the buffer to become the front tile pane
		bg.style.visibility = 'hidden';
		bg.style[L.DomUtil.TRANSFORM] = '';

		// switch out the current layer to be the new bg layer (and vice-versa)
		this._tileContainer = bg;
		bg = this._bgBuffer = front;

		this._stopLoadingImages(bg);

		//prevent bg buffer from clearing right after zoom
		clearTimeout(this._clearBgBufferTimer);
	},

	_getLoadedTilesPercentage: function (container) {
		var tiles = container.getElementsByTagName('img'),
		    i, len, count = 0;

		for (i = 0, len = tiles.length; i < len; i++) {
			if (tiles[i].complete) {
				count++;
			}
		}
		return count / len;
	},

	// stops loading all tiles in the background layer
	_stopLoadingImages: function (container) {
		var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
		    i, len, tile;

		for (i = 0, len = tiles.length; i < len; i++) {
			tile = tiles[i];

			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;

				tile.parentNode.removeChild(tile);
			}
		}
	}
});


/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		watch: false,
		setView: false,
		maxZoom: Infinity,
		timeout: 10000,
		maximumAge: 0,
		enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

		if (!navigator.geolocation) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),

		    latAccuracy = 180 * pos.coords.accuracy / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

		    bounds = L.latLngBounds(
		            [lat - latAccuracy, lng - lngAccuracy],
		            [lat + latAccuracy, lng + lngAccuracy]),

		    options = this._locateOptions;

		if (options.setView) {
			var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
			this.setView(latlng, zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});


}(window, document));
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/array/last.js":[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/collection/forEach.js":[function(require,module,exports){
var arrayEach = require('../internal/arrayEach'),
    baseEach = require('../internal/baseEach'),
    createForEach = require('../internal/createForEach');

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length" property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
var forEach = createForEach(arrayEach, baseEach);

module.exports = forEach;

},{"../internal/arrayEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayEach.js","../internal/baseEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseEach.js","../internal/createForEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createForEach.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/collection/reduce.js":[function(require,module,exports){
var arrayReduce = require('../internal/arrayReduce'),
    baseEach = require('../internal/baseEach'),
    createReduce = require('../internal/createReduce');

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` through `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not provided the first element of `collection` is used as the initial
 * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
 * and `sortByOrder`
 *
 * @static
 * @memberOf _
 * @alias foldl, inject
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.reduce([1, 2], function(total, n) {
 *   return total + n;
 * });
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
 *   result[key] = n * 3;
 *   return result;
 * }, {});
 * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
 */
var reduce = createReduce(arrayReduce, baseEach);

module.exports = reduce;

},{"../internal/arrayReduce":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayReduce.js","../internal/baseEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseEach.js","../internal/createReduce":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createReduce.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/function/restParam.js":[function(require,module,exports){
/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayCopy.js":[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function arrayCopy(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = arrayCopy;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayEach.js":[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayPush.js":[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayReduce.js":[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initFromArray] Specify using the first element of `array`
 *  as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initFromArray) {
  var index = -1,
      length = array.length;

  if (initFromArray && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arraySome.js":[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/assignWith.js":[function(require,module,exports){
var keys = require('../object/keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

module.exports = assignWith;

},{"../object/keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseAssign.js":[function(require,module,exports){
var baseCopy = require('./baseCopy'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"../object/keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js","./baseCopy":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseCopy.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseCallback.js":[function(require,module,exports){
var baseMatches = require('./baseMatches'),
    baseMatchesProperty = require('./baseMatchesProperty'),
    bindCallback = require('./bindCallback'),
    identity = require('../utility/identity'),
    property = require('../utility/property');

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return thisArg === undefined
      ? func
      : bindCallback(func, thisArg, argCount);
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return thisArg === undefined
    ? property(func)
    : baseMatchesProperty(func, thisArg);
}

module.exports = baseCallback;

},{"../utility/identity":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/identity.js","../utility/property":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/property.js","./baseMatches":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseMatches.js","./baseMatchesProperty":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseMatchesProperty.js","./bindCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseClone.js":[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    arrayEach = require('./arrayEach'),
    baseAssign = require('./baseAssign'),
    baseForOwn = require('./baseForOwn'),
    initCloneArray = require('./initCloneArray'),
    initCloneByTag = require('./initCloneByTag'),
    initCloneObject = require('./initCloneObject'),
    isArray = require('../lang/isArray'),
    isObject = require('../lang/isObject');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
cloneableTags[dateTag] = cloneableTags[float32Tag] =
cloneableTags[float64Tag] = cloneableTags[int8Tag] =
cloneableTags[int16Tag] = cloneableTags[int32Tag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[stringTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[mapTag] = cloneableTags[setTag] =
cloneableTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * The base implementation of `_.clone` without support for argument juggling
 * and `this` binding `customizer` functions.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The object `value` belongs to.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates clones with source counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return arrayCopy(value, result);
    }
  } else {
    var tag = objToString.call(value),
        isFunc = tag == funcTag;

    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return baseAssign(result, value);
      }
    } else {
      return cloneableTags[tag]
        ? initCloneByTag(value, tag, isDeep)
        : (object ? value : {});
    }
  }
  // Check for circular references and return its corresponding clone.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == value) {
      return stackB[length];
    }
  }
  // Add the source value to the stack of traversed objects and associate it with its clone.
  stackA.push(value);
  stackB.push(result);

  // Recursively populate clone (susceptible to call stack limits).
  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
  });
  return result;
}

module.exports = baseClone;

},{"../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js","./arrayCopy":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayCopy.js","./arrayEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayEach.js","./baseAssign":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseAssign.js","./baseForOwn":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseForOwn.js","./initCloneArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/initCloneArray.js","./initCloneByTag":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/initCloneByTag.js","./initCloneObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/initCloneObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseCopy.js":[function(require,module,exports){
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseEach.js":[function(require,module,exports){
var baseForOwn = require('./baseForOwn'),
    createBaseEach = require('./createBaseEach');

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./baseForOwn":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseForOwn.js","./createBaseEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createBaseEach.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseFlatten.js":[function(require,module,exports){
var arrayPush = require('./arrayPush'),
    isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, result) {
  result || (result = []);

  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index];
    if (isObjectLike(value) && isArrayLike(value) &&
        (isStrict || isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, isDeep, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"../lang/isArguments":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArguments.js","../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","./arrayPush":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arrayPush.js","./isArrayLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isArrayLike.js","./isObjectLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseFor.js":[function(require,module,exports){
var createBaseFor = require('./createBaseFor');

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./createBaseFor":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createBaseFor.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseForIn.js":[function(require,module,exports){
var baseFor = require('./baseFor'),
    keysIn = require('../object/keysIn');

/**
 * The base implementation of `_.forIn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForIn(object, iteratee) {
  return baseFor(object, iteratee, keysIn);
}

module.exports = baseForIn;

},{"../object/keysIn":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keysIn.js","./baseFor":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseFor.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseForOwn.js":[function(require,module,exports){
var baseFor = require('./baseFor'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"../object/keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js","./baseFor":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseFor.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseGet.js":[function(require,module,exports){
var toObject = require('./toObject');

/**
 * The base implementation of `get` without support for string paths
 * and default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path of the property to get.
 * @param {string} [pathKey] The key representation of path.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path, pathKey) {
  if (object == null) {
    return;
  }
  if (pathKey !== undefined && pathKey in toObject(object)) {
    path = [pathKey];
  }
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[path[index++]];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsEqual.js":[function(require,module,exports){
var baseIsEqualDeep = require('./baseIsEqualDeep'),
    isObject = require('../lang/isObject'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
}

module.exports = baseIsEqual;

},{"../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js","./baseIsEqualDeep":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsEqualDeep.js","./isObjectLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsEqualDeep.js":[function(require,module,exports){
var equalArrays = require('./equalArrays'),
    equalByTag = require('./equalByTag'),
    equalObjects = require('./equalObjects'),
    isArray = require('../lang/isArray'),
    isTypedArray = require('../lang/isTypedArray');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  if (!isLoose) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
    }
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

module.exports = baseIsEqualDeep;

},{"../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","../lang/isTypedArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isTypedArray.js","./equalArrays":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/equalArrays.js","./equalByTag":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/equalByTag.js","./equalObjects":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/equalObjects.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsMatch.js":[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} matchData The propery names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = toObject(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./baseIsEqual":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsEqual.js","./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseMatches.js":[function(require,module,exports){
var baseIsMatch = require('./baseIsMatch'),
    getMatchData = require('./getMatchData'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    var key = matchData[0][0],
        value = matchData[0][1];

    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === value && (value !== undefined || (key in toObject(object)));
    };
  }
  return function(object) {
    return baseIsMatch(object, matchData);
  };
}

module.exports = baseMatches;

},{"./baseIsMatch":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsMatch.js","./getMatchData":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getMatchData.js","./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseMatchesProperty.js":[function(require,module,exports){
var baseGet = require('./baseGet'),
    baseIsEqual = require('./baseIsEqual'),
    baseSlice = require('./baseSlice'),
    isArray = require('../lang/isArray'),
    isKey = require('./isKey'),
    isStrictComparable = require('./isStrictComparable'),
    last = require('../array/last'),
    toObject = require('./toObject'),
    toPath = require('./toPath');

/**
 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(path, srcValue) {
  var isArr = isArray(path),
      isCommon = isKey(path) && isStrictComparable(srcValue),
      pathKey = (path + '');

  path = toPath(path);
  return function(object) {
    if (object == null) {
      return false;
    }
    var key = pathKey;
    object = toObject(object);
    if ((isArr || !isCommon) && !(key in object)) {
      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
      if (object == null) {
        return false;
      }
      key = last(path);
      object = toObject(object);
    }
    return object[key] === srcValue
      ? (srcValue !== undefined || (key in object))
      : baseIsEqual(srcValue, object[key], undefined, true);
  };
}

module.exports = baseMatchesProperty;

},{"../array/last":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/array/last.js","../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","./baseGet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseGet.js","./baseIsEqual":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsEqual.js","./baseSlice":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseSlice.js","./isKey":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isKey.js","./isStrictComparable":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isStrictComparable.js","./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js","./toPath":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toPath.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseProperty.js":[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/basePropertyDeep.js":[function(require,module,exports){
var baseGet = require('./baseGet'),
    toPath = require('./toPath');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 */
function basePropertyDeep(path) {
  var pathKey = (path + '');
  path = toPath(path);
  return function(object) {
    return baseGet(object, path, pathKey);
  };
}

module.exports = basePropertyDeep;

},{"./baseGet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseGet.js","./toPath":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toPath.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseReduce.js":[function(require,module,exports){
/**
 * The base implementation of `_.reduce` and `_.reduceRight` without support
 * for callback shorthands and `this` binding, which iterates over `collection`
 * using the provided `eachFunc`.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initFromCollection Specify using the first or last element
 *  of `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initFromCollection
      ? (initFromCollection = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseSlice.js":[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  start = start == null ? 0 : (+start || 0);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : (+end || 0);
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseToString.js":[function(require,module,exports){
/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  return value == null ? '' : (value + '');
}

module.exports = baseToString;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js":[function(require,module,exports){
var identity = require('../utility/identity');

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/identity.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bufferClone.js":[function(require,module,exports){
(function (global){
/** Native method references. */
var ArrayBuffer = global.ArrayBuffer,
    Uint8Array = global.Uint8Array;

/**
 * Creates a clone of the given array buffer.
 *
 * @private
 * @param {ArrayBuffer} buffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function bufferClone(buffer) {
  var result = new ArrayBuffer(buffer.byteLength),
      view = new Uint8Array(result);

  view.set(new Uint8Array(buffer));
  return result;
}

module.exports = bufferClone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createAssigner.js":[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isIterateeCall = require('./isIterateeCall'),
    restParam = require('../function/restParam');

/**
 * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"../function/restParam":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/function/restParam.js","./bindCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js","./isIterateeCall":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIterateeCall.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createBaseEach.js":[function(require,module,exports){
var getLength = require('./getLength'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    var length = collection ? getLength(collection) : 0;
    if (!isLength(length)) {
      return eachFunc(collection, iteratee);
    }
    var index = fromRight ? length : -1,
        iterable = toObject(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./getLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getLength.js","./isLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js","./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createBaseFor.js":[function(require,module,exports){
var toObject = require('./toObject');

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{"./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createForEach.js":[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isArray = require('../lang/isArray');

/**
 * Creates a function for `_.forEach` or `_.forEachRight`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over an array.
 * @param {Function} eachFunc The function to iterate over a collection.
 * @returns {Function} Returns the new each function.
 */
function createForEach(arrayFunc, eachFunc) {
  return function(collection, iteratee, thisArg) {
    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
      ? arrayFunc(collection, iteratee)
      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
  };
}

module.exports = createForEach;

},{"../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","./bindCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createReduce.js":[function(require,module,exports){
var baseCallback = require('./baseCallback'),
    baseReduce = require('./baseReduce'),
    isArray = require('../lang/isArray');

/**
 * Creates a function for `_.reduce` or `_.reduceRight`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over an array.
 * @param {Function} eachFunc The function to iterate over a collection.
 * @returns {Function} Returns the new each function.
 */
function createReduce(arrayFunc, eachFunc) {
  return function(collection, iteratee, accumulator, thisArg) {
    var initFromArray = arguments.length < 3;
    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
      ? arrayFunc(collection, iteratee, accumulator, initFromArray)
      : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
  };
}

module.exports = createReduce;

},{"../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","./baseCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseCallback.js","./baseReduce":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseReduce.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/equalArrays.js":[function(require,module,exports){
var arraySome = require('./arraySome');

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
    return false;
  }
  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index],
        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

    if (result !== undefined) {
      if (result) {
        continue;
      }
      return false;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (isLoose) {
      if (!arraySome(other, function(othValue) {
            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          })) {
        return false;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
      return false;
    }
  }
  return true;
}

module.exports = equalArrays;

},{"./arraySome":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/arraySome.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/equalByTag.js":[function(require,module,exports){
/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

module.exports = equalByTag;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/equalObjects.js":[function(require,module,exports){
var keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isLoose) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  var skipCtor = isLoose;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key],
        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

    // Recursively compare objects (susceptible to call stack limits).
    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
      return false;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (!skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

module.exports = equalObjects;

},{"../object/keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getLength.js":[function(require,module,exports){
var baseProperty = require('./baseProperty');

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

module.exports = getLength;

},{"./baseProperty":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseProperty.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getMatchData.js":[function(require,module,exports){
var isStrictComparable = require('./isStrictComparable'),
    pairs = require('../object/pairs');

/**
 * Gets the propery names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = pairs(object),
      length = result.length;

  while (length--) {
    result[length][2] = isStrictComparable(result[length][1]);
  }
  return result;
}

module.exports = getMatchData;

},{"../object/pairs":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/pairs.js","./isStrictComparable":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isStrictComparable.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getNative.js":[function(require,module,exports){
var isNative = require('../lang/isNative');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

module.exports = getNative;

},{"../lang/isNative":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isNative.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/initCloneArray.js":[function(require,module,exports){
/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add array properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/initCloneByTag.js":[function(require,module,exports){
var bufferClone = require('./bufferClone');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return bufferClone(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      var buffer = object.buffer;
      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      var result = new Ctor(object.source, reFlags.exec(object));
      result.lastIndex = object.lastIndex;
  }
  return result;
}

module.exports = initCloneByTag;

},{"./bufferClone":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bufferClone.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/initCloneObject.js":[function(require,module,exports){
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  var Ctor = object.constructor;
  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
    Ctor = Object;
  }
  return new Ctor;
}

module.exports = initCloneObject;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isArrayLike.js":[function(require,module,exports){
var getLength = require('./getLength'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

module.exports = isArrayLike;

},{"./getLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getLength.js","./isLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIndex.js":[function(require,module,exports){
/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIterateeCall.js":[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isIndex = require('./isIndex'),
    isObject = require('../lang/isObject');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

module.exports = isIterateeCall;

},{"../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js","./isArrayLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isArrayLike.js","./isIndex":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIndex.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isKey.js":[function(require,module,exports){
var isArray = require('../lang/isArray'),
    toObject = require('./toObject');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  var type = typeof value;
  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
    return true;
  }
  if (isArray(value)) {
    return false;
  }
  var result = !reIsDeepProp.test(value);
  return result || (object != null && value in toObject(object));
}

module.exports = isKey;

},{"../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js":[function(require,module,exports){
/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js":[function(require,module,exports){
/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isStrictComparable.js":[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/pickByArray.js":[function(require,module,exports){
var toObject = require('./toObject');

/**
 * A specialized version of `_.pick` which picks `object` properties specified
 * by `props`.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property names to pick.
 * @returns {Object} Returns the new object.
 */
function pickByArray(object, props) {
  object = toObject(object);

  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index];
    if (key in object) {
      result[key] = object[key];
    }
  }
  return result;
}

module.exports = pickByArray;

},{"./toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/pickByCallback.js":[function(require,module,exports){
var baseForIn = require('./baseForIn');

/**
 * A specialized version of `_.pick` which picks `object` properties `predicate`
 * returns truthy for.
 *
 * @private
 * @param {Object} object The source object.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Object} Returns the new object.
 */
function pickByCallback(object, predicate) {
  var result = {};
  baseForIn(object, function(value, key, object) {
    if (predicate(value, key, object)) {
      result[key] = value;
    }
  });
  return result;
}

module.exports = pickByCallback;

},{"./baseForIn":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseForIn.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/shimKeys.js":[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    keysIn = require('../object/keysIn');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArguments.js","../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","../object/keysIn":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keysIn.js","./isIndex":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIndex.js","./isLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js":[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toPath.js":[function(require,module,exports){
var baseToString = require('./baseToString'),
    isArray = require('../lang/isArray');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  baseToString(value).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
}

module.exports = toPath;

},{"../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","./baseToString":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseToString.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/clone.js":[function(require,module,exports){
var baseClone = require('../internal/baseClone'),
    bindCallback = require('../internal/bindCallback'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
 * otherwise they are assigned by reference. If `customizer` is provided it's
 * invoked to produce the cloned values. If `customizer` returns `undefined`
 * cloning is handled by the method instead. The `customizer` is bound to
 * `thisArg` and invoked with up to three argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var shallow = _.clone(users);
 * shallow[0] === users[0];
 * // => true
 *
 * var deep = _.clone(users, true);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var el = _.clone(document.body, function(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(false);
 *   }
 * });
 *
 * el === document.body
 * // => false
 * el.nodeName
 * // => BODY
 * el.childNodes.length;
 * // => 0
 */
function clone(value, isDeep, customizer, thisArg) {
  if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
    isDeep = false;
  }
  else if (typeof isDeep == 'function') {
    thisArg = customizer;
    customizer = isDeep;
    isDeep = false;
  }
  return typeof customizer == 'function'
    ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))
    : baseClone(value, isDeep);
}

module.exports = clone;

},{"../internal/baseClone":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseClone.js","../internal/bindCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js","../internal/isIterateeCall":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIterateeCall.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArguments.js":[function(require,module,exports){
var isArrayLike = require('../internal/isArrayLike'),
    isObjectLike = require('../internal/isObjectLike');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{"../internal/isArrayLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isArrayLike.js","../internal/isObjectLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js":[function(require,module,exports){
var getNative = require('../internal/getNative'),
    isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var arrayTag = '[object Array]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

module.exports = isArray;

},{"../internal/getNative":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getNative.js","../internal/isLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js","../internal/isObjectLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isEqual.js":[function(require,module,exports){
var baseIsEqual = require('../internal/baseIsEqual'),
    bindCallback = require('../internal/bindCallback');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent. If `customizer` is provided it's invoked to compare values.
 * If `customizer` returns `undefined` comparisons are handled by the method
 * instead. The `customizer` is bound to `thisArg` and invoked with up to
 * three arguments: (value, other [, index|key]).
 *
 * **Note:** This method supports comparing arrays, booleans, `Date` objects,
 * numbers, `Object` objects, regexes, and strings. Objects are compared by
 * their own, not inherited, enumerable properties. Functions and DOM nodes
 * are **not** supported. Provide a customizer function to extend support
 * for comparing other values.
 *
 * @static
 * @memberOf _
 * @alias eq
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize value comparisons.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * object == other;
 * // => false
 *
 * _.isEqual(object, other);
 * // => true
 *
 * // using a customizer callback
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqual(array, other, function(value, other) {
 *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
 *     return true;
 *   }
 * });
 * // => true
 */
function isEqual(value, other, customizer, thisArg) {
  customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
}

module.exports = isEqual;

},{"../internal/baseIsEqual":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseIsEqual.js","../internal/bindCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isFunction.js":[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 which returns 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

module.exports = isFunction;

},{"./isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isNative.js":[function(require,module,exports){
var isFunction = require('./isFunction'),
    isObjectLike = require('../internal/isObjectLike');

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isNative;

},{"../internal/isObjectLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js","./isFunction":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isFunction.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js":[function(require,module,exports){
/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isTypedArray.js":[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
}

module.exports = isTypedArray;

},{"../internal/isLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js","../internal/isObjectLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isObjectLike.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isUndefined.js":[function(require,module,exports){
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/assign.js":[function(require,module,exports){
var assignWith = require('../internal/assignWith'),
    baseAssign = require('../internal/baseAssign'),
    createAssigner = require('../internal/createAssigner');

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it's invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"../internal/assignWith":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/assignWith.js","../internal/baseAssign":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseAssign.js","../internal/createAssigner":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/createAssigner.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js":[function(require,module,exports){
var getNative = require('../internal/getNative'),
    isArrayLike = require('../internal/isArrayLike'),
    isObject = require('../lang/isObject'),
    shimKeys = require('../internal/shimKeys');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/getNative":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/getNative.js","../internal/isArrayLike":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isArrayLike.js","../internal/shimKeys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/shimKeys.js","../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keysIn.js":[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('../internal/isIndex'),
    isLength = require('../internal/isLength'),
    isObject = require('../lang/isObject');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/isIndex":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isIndex.js","../internal/isLength":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isLength.js","../lang/isArguments":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArguments.js","../lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","../lang/isObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/pairs.js":[function(require,module,exports){
var keys = require('./keys'),
    toObject = require('../internal/toObject');

/**
 * Creates a two dimensional array of the key-value pairs for `object`,
 * e.g. `[[key1, value1], [key2, value2]]`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the new array of key-value pairs.
 * @example
 *
 * _.pairs({ 'barney': 36, 'fred': 40 });
 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 */
function pairs(object) {
  object = toObject(object);

  var index = -1,
      props = keys(object),
      length = props.length,
      result = Array(length);

  while (++index < length) {
    var key = props[index];
    result[index] = [key, object[key]];
  }
  return result;
}

module.exports = pairs;

},{"../internal/toObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/toObject.js","./keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/pick.js":[function(require,module,exports){
var baseFlatten = require('../internal/baseFlatten'),
    bindCallback = require('../internal/bindCallback'),
    pickByArray = require('../internal/pickByArray'),
    pickByCallback = require('../internal/pickByCallback'),
    restParam = require('../function/restParam');

/**
 * Creates an object composed of the picked `object` properties. Property
 * names may be specified as individual arguments or as arrays of property
 * names. If `predicate` is provided it's invoked for each property of `object`
 * picking the properties `predicate` returns truthy for. The predicate is
 * bound to `thisArg` and invoked with three arguments: (value, key, object).
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {Function|...(string|string[])} [predicate] The function invoked per
 *  iteration or property names to pick, specified as individual property
 *  names or arrays of property names.
 * @param {*} [thisArg] The `this` binding of `predicate`.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'user': 'fred', 'age': 40 };
 *
 * _.pick(object, 'user');
 * // => { 'user': 'fred' }
 *
 * _.pick(object, _.isString);
 * // => { 'user': 'fred' }
 */
var pick = restParam(function(object, props) {
  if (object == null) {
    return {};
  }
  return typeof props[0] == 'function'
    ? pickByCallback(object, bindCallback(props[0], props[1], 3))
    : pickByArray(object, baseFlatten(props));
});

module.exports = pick;

},{"../function/restParam":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/function/restParam.js","../internal/baseFlatten":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseFlatten.js","../internal/bindCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/bindCallback.js","../internal/pickByArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/pickByArray.js","../internal/pickByCallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/pickByCallback.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/identity.js":[function(require,module,exports){
/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/property.js":[function(require,module,exports){
var baseProperty = require('../internal/baseProperty'),
    basePropertyDeep = require('../internal/basePropertyDeep'),
    isKey = require('../internal/isKey');

/**
 * Creates a function that returns the property value at `path` on a
 * given object.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': { 'c': 2 } } },
 *   { 'a': { 'b': { 'c': 1 } } }
 * ];
 *
 * _.map(objects, _.property('a.b.c'));
 * // => [2, 1]
 *
 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
}

module.exports = property;

},{"../internal/baseProperty":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseProperty.js","../internal/basePropertyDeep":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/basePropertyDeep.js","../internal/isKey":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/isKey.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/uniqueId.js":[function(require,module,exports){
var baseToString = require('../internal/baseToString');

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is provided the ID is appended to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {string} [prefix] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return baseToString(prefix) + id;
}

module.exports = uniqueId;

},{"../internal/baseToString":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/internal/baseToString.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/object-assign/index.js":[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/queue-async/build/queue.js":[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('queue', factory) :
  (global.queue = factory());
}(this, function () { 'use strict';

  var slice = [].slice;

  function noop() {}

  var noabort = {};
  var success = [null];
  function newQueue(concurrency) {
    if (!(concurrency >= 1)) throw new Error;

    var q,
        tasks = [],
        results = [],
        waiting = 0,
        active = 0,
        ended = 0,
        starting, // inside a synchronous task callback?
        error,
        callback = noop,
        callbackAll = true;

    function start() {
      if (starting) return; // let the current task complete
      while (starting = waiting && active < concurrency) {
        var i = ended + active,
            t = tasks[i],
            j = t.length - 1,
            c = t[j];
        t[j] = end(i);
        --waiting, ++active, tasks[i] = c.apply(null, t) || noabort;
      }
    }

    function end(i) {
      return function(e, r) {
        if (!tasks[i]) throw new Error; // detect multiple callbacks
        --active, ++ended, tasks[i] = null;
        if (error != null) return; // only report the first error
        if (e != null) {
          abort(e);
        } else {
          results[i] = r;
          if (waiting) start();
          else if (!active) notify();
        }
      };
    }

    function abort(e) {
      error = e; // ignore new tasks and squelch active callbacks
      waiting = NaN; // stop queued tasks from starting
      notify();
    }

    function notify() {
      if (error != null) callback(error);
      else if (callbackAll) callback(null, results);
      else callback.apply(null, success.concat(results));
    }

    return q = {
      defer: function(f) {
        if (callback !== noop) throw new Error;
        var t = slice.call(arguments, 1);
        t.push(f);
        ++waiting, tasks.push(t);
        start();
        return q;
      },
      abort: function() {
        if (error == null) {
          var i = ended + active, t;
          while (--i >= 0) (t = tasks[i]) && t.abort && t.abort();
          abort(new Error("abort"));
        }
        return q;
      },
      await: function(f) {
        if (callback !== noop) throw new Error;
        callback = f, callbackAll = false;
        if (!waiting && !active) notify();
        return q;
      },
      awaitAll: function(f) {
        if (callback !== noop) throw new Error;
        callback = f, callbackAll = true;
        if (!waiting && !active) notify();
        return q;
      }
    };
  }

  function queue(concurrency) {
    return newQueue(arguments.length ? +concurrency : Infinity);
  }

  queue.version = "1.2.1";

  return queue;

}));
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Handle.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcTooltip = require('rc-tooltip');

var _rcTooltip2 = _interopRequireDefault(_rcTooltip);

var Handle = (function (_React$Component) {
  _inherits(Handle, _React$Component);

  function Handle(props) {
    _classCallCheck(this, Handle);

    _get(Object.getPrototypeOf(Handle.prototype), 'constructor', this).call(this, props);

    this.state = {
      isTooltipVisible: false
    };
  }

  _createClass(Handle, [{
    key: 'showTooltip',
    value: function showTooltip() {
      this.setState({
        isTooltipVisible: true
      });
    }
  }, {
    key: 'hideTooltip',
    value: function hideTooltip() {
      this.setState({
        isTooltipVisible: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var props = this.props;
      var className = props.className;
      var tipTransitionName = props.tipTransitionName;
      var tipFormatter = props.tipFormatter;
      var vertical = props.vertical;
      var offset = props.offset;
      var value = props.value;
      var dragging = props.dragging;
      var noTip = props.noTip;

      var style = vertical ? { bottom: offset + '%' } : { left: offset + '%' };
      var handle = _react2['default'].createElement('div', { className: className, style: style,
        onMouseUp: this.showTooltip.bind(this),
        onMouseEnter: this.showTooltip.bind(this),
        onMouseLeave: this.hideTooltip.bind(this) });

      if (noTip) {
        return handle;
      }

      var isTooltipVisible = dragging || this.state.isTooltipVisible;
      return _react2['default'].createElement(
        _rcTooltip2['default'],
        {
          prefixCls: className.replace('slider-handle', 'tooltip'),
          placement: 'top',
          visible: isTooltipVisible,
          overlay: _react2['default'].createElement(
            'span',
            null,
            tipFormatter(value)
          ),
          delay: 0,
          transitionName: tipTransitionName },
        handle
      );
    }
  }]);

  return Handle;
})(_react2['default'].Component);

exports['default'] = Handle;

Handle.propTypes = {
  className: _react2['default'].PropTypes.string,
  vertical: _react2['default'].PropTypes.bool,
  offset: _react2['default'].PropTypes.number,
  tipTransitionName: _react2['default'].PropTypes.string,
  tipFormatter: _react2['default'].PropTypes.func,
  value: _react2['default'].PropTypes.number,
  dragging: _react2['default'].PropTypes.bool,
  noTip: _react2['default'].PropTypes.bool
};
module.exports = exports['default'];
},{"rc-tooltip":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Marks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var Marks = function Marks(_ref) {
  var className = _ref.className;
  var vertical = _ref.vertical;
  var marks = _ref.marks;
  var included = _ref.included;
  var upperBound = _ref.upperBound;
  var lowerBound = _ref.lowerBound;
  var max = _ref.max;
  var min = _ref.min;

  var marksKeys = Object.keys(marks);
  var marksCount = marksKeys.length;
  var unit = 100 / (marksCount - 1);
  var markWidth = unit * 0.9;

  var range = max - min;
  var elements = marksKeys.map(parseFloat).sort(function (a, b) {
    return a - b;
  }).map(function (point) {
    var _classNames;

    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var markClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, className + '-text', true), _defineProperty(_classNames, className + '-text-active', isActived), _classNames));

    var bottomStyle = {
      // height: markWidth + '%',
      marginBottom: '-200' + '%',
      bottom: (point - min) / range * 100 + '%'
    };

    var leftStyle = {
      width: markWidth + '%',
      marginLeft: -markWidth / 2 + '%',
      left: (point - min) / range * 100 + '%'
    };

    var style = vertical ? bottomStyle : leftStyle;

    var markPoint = marks[point];
    var markPointIsObject = typeof markPoint === 'object' && !_react2['default'].isValidElement(markPoint);
    var markLabel = markPointIsObject ? markPoint.label : markPoint;
    var markStyle = markPointIsObject ? _extends({}, style, markPoint.style) : style;
    return _react2['default'].createElement(
      'span',
      { className: markClassName, style: markStyle, key: point },
      markLabel
    );
  });

  return _react2['default'].createElement(
    'div',
    { className: className },
    elements
  );
};

exports['default'] = Marks;
module.exports = exports['default'];
},{"classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/classnames/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Slider.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcUtilLibDomAddEventListener = require('rc-util/lib/Dom/addEventListener');

var _rcUtilLibDomAddEventListener2 = _interopRequireDefault(_rcUtilLibDomAddEventListener);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _Handle = require('./Handle');

var _Handle2 = _interopRequireDefault(_Handle);

var _Steps = require('./Steps');

var _Steps2 = _interopRequireDefault(_Steps);

var _Marks = require('./Marks');

var _Marks2 = _interopRequireDefault(_Marks);

function noop() {}

function isNotTouchEvent(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === 'touchend' && e.touches.length > 0;
}

function getTouchPosition(vertical, e) {
  return vertical ? e.touches[0].clientY : e.touches[0].pageX;
}

function getMousePosition(vertical, e) {
  return vertical ? e.clientY : e.pageX;
}

function pauseEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}

var Slider = (function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);

    var range = props.range;
    var min = props.min;
    var max = props.max;

    var initialValue = range ? [min, min] : min;
    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;
    var value = props.value !== undefined ? props.value : defaultValue;

    var upperBound = undefined;
    var lowerBound = undefined;
    if (props.range) {
      lowerBound = this.trimAlignValue(value[0]);
      upperBound = this.trimAlignValue(value[1]);
    } else {
      upperBound = this.trimAlignValue(value);
    }

    var recent = undefined;
    if (props.range && upperBound === lowerBound) {
      recent = lowerBound === max ? 'lowerBound' : 'upperBound';
    } else {
      recent = 'upperBound';
    }

    this.state = {
      handle: null,
      recent: recent,
      upperBound: upperBound,
      // If Slider is not range, set `lowerBound` equal to `min`.
      lowerBound: lowerBound || min
    };
  }

  _createClass(Slider, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;

      var _state = this.state;
      var lowerBound = _state.lowerBound;
      var upperBound = _state.upperBound;

      if (nextProps.range) {
        var value = nextProps.value || [lowerBound, upperBound];
        var nextUpperBound = this.trimAlignValue(value[1], nextProps);
        var nextLowerBound = this.trimAlignValue(value[0], nextProps);
        if (nextLowerBound === lowerBound && nextUpperBound === upperBound) return;

        this.setState({
          upperBound: nextUpperBound,
          lowerBound: nextLowerBound
        });
        if (this.isValueOutOfBounds(upperBound, nextProps) || this.isValueOutOfBounds(lowerBound, nextProps)) {
          this.props.onChange([nextLowerBound, nextUpperBound]);
        }
      } else {
        var value = nextProps.value !== undefined ? nextProps.value : upperBound;
        var nextValue = this.trimAlignValue(value, nextProps);
        if (nextValue === upperBound && lowerBound === nextProps.min) return;

        this.setState({
          upperBound: nextValue,
          lowerBound: nextProps.min
        });
        if (this.isValueOutOfBounds(upperBound, nextProps)) {
          this.props.onChange(nextValue);
        }
      }
    }
  }, {
    key: 'onChange',
    value: function onChange(state) {
      var props = this.props;
      var isNotControlled = !('value' in props);
      if (isNotControlled) {
        this.setState(state);
      } else if (state.handle) {
        this.setState({ handle: state.handle });
      }

      var data = _extends({}, this.state, state);
      var changedValue = props.range ? [data.lowerBound, data.upperBound] : data.upperBound;
      props.onChange(changedValue);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var position = getMousePosition(this.props.vertical, e);
      this.onMove(e, position);
    }
  }, {
    key: 'onTouchMove',
    value: function onTouchMove(e) {
      if (isNotTouchEvent(e)) {
        this.end('touch');
        return;
      }

      var position = getTouchPosition(this.props.vertical, e);
      this.onMove(e, position);
    }
  }, {
    key: 'onMove',
    value: function onMove(e, position) {
      pauseEvent(e);
      var props = this.props;
      var state = this.state;

      var diffPosition = position - this.startPosition;
      diffPosition = this.props.vertical ? -diffPosition : diffPosition;
      var diffValue = diffPosition / this.getSliderLength() * (props.max - props.min);

      var value = this.trimAlignValue(this.startValue + diffValue);
      var oldValue = state[state.handle];
      if (value === oldValue) return;

      if (props.allowCross && value < state.lowerBound && state.handle === 'upperBound') {
        this.onChange({
          handle: 'lowerBound',
          lowerBound: value,
          upperBound: this.state.lowerBound
        });
        return;
      }
      if (props.allowCross && value > state.upperBound && state.handle === 'lowerBound') {
        this.onChange({
          handle: 'upperBound',
          upperBound: value,
          lowerBound: this.state.upperBound
        });
        return;
      }

      this.onChange(_defineProperty({}, state.handle, value));
    }
  }, {
    key: 'onTouchStart',
    value: function onTouchStart(e) {
      if (isNotTouchEvent(e)) return;

      var position = getTouchPosition(this.props.vertical, e);
      this.onStart(position);
      this.addDocumentEvents('touch');
      pauseEvent(e);
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      if (e.button !== 0) {
        return;
      }
      var position = getMousePosition(this.props.vertical, e);
      this.onStart(position);
      this.addDocumentEvents('mouse');
      pauseEvent(e);
    }
  }, {
    key: 'onStart',
    value: function onStart(position) {
      var props = this.props;
      props.onBeforeChange(this.getValue());

      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;

      var state = this.state;
      var upperBound = state.upperBound;
      var lowerBound = state.lowerBound;

      var valueNeedChanging = 'upperBound';
      if (this.props.range) {
        var isLowerBoundCloser = Math.abs(upperBound - value) > Math.abs(lowerBound - value);
        if (isLowerBoundCloser) {
          valueNeedChanging = 'lowerBound';
        }

        var isAtTheSamePoint = upperBound === lowerBound;
        if (isAtTheSamePoint) {
          valueNeedChanging = state.recent;
        }

        if (isAtTheSamePoint && value !== upperBound) {
          valueNeedChanging = value < upperBound ? 'lowerBound' : 'upperBound';
        }
      }

      this.setState({
        handle: valueNeedChanging,
        recent: valueNeedChanging
      });

      var oldValue = state[valueNeedChanging];
      if (value === oldValue) return;

      this.onChange(_defineProperty({}, valueNeedChanging, value));
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var _state2 = this.state;
      var lowerBound = _state2.lowerBound;
      var upperBound = _state2.upperBound;

      return this.props.range ? [lowerBound, upperBound] : upperBound;
    }
  }, {
    key: 'getSliderLength',
    value: function getSliderLength() {
      var slider = this.refs.slider;
      if (!slider) {
        return 0;
      }

      return this.props.vertical ? slider.clientHeight : slider.clientWidth;
    }
  }, {
    key: 'getSliderStart',
    value: function getSliderStart() {
      var slider = this.refs.slider;
      var rect = slider.getBoundingClientRect();

      return this.props.vertical ? rect.top : rect.left;
    }
  }, {
    key: 'getPrecision',
    value: function getPrecision(step) {
      var stepString = step.toString();
      var precision = 0;
      if (stepString.indexOf('.') >= 0) {
        precision = stepString.length - stepString.indexOf('.') - 1;
      }
      return precision;
    }
  }, {
    key: 'isValueOutOfBounds',
    value: function isValueOutOfBounds(value, props) {
      return value < props.min || value > props.max;
    }
  }, {
    key: 'trimAlignValue',
    value: function trimAlignValue(v, nextProps) {
      var state = this.state || {};
      var handle = state.handle;
      var lowerBound = state.lowerBound;
      var upperBound = state.upperBound;

      var _extends2 = _extends({}, this.props, nextProps || {});

      var marks = _extends2.marks;
      var step = _extends2.step;
      var min = _extends2.min;
      var max = _extends2.max;
      var allowCross = _extends2.allowCross;

      var val = v;
      if (val <= min) {
        val = min;
      }
      if (val >= max) {
        val = max;
      }
      if (!allowCross && handle === 'upperBound' && val <= lowerBound) {
        val = lowerBound;
      }
      if (!allowCross && handle === 'lowerBound' && val >= upperBound) {
        val = upperBound;
      }

      var points = Object.keys(marks).map(parseFloat);
      if (step !== null) {
        var closestStep = Math.round(val / step) * step;
        points.push(closestStep);
      }

      var diffs = points.map(function (point) {
        return Math.abs(val - point);
      });
      var closestPoint = points[diffs.indexOf(Math.min.apply(Math, diffs))];

      return step !== null ? parseFloat(closestPoint.toFixed(this.getPrecision(step))) : closestPoint;
    }
  }, {
    key: 'calcOffset',
    value: function calcOffset(value) {
      var _props = this.props;
      var min = _props.min;
      var max = _props.max;

      var ratio = (value - min) / (max - min);
      return ratio * 100;
    }
  }, {
    key: 'calcValue',
    value: function calcValue(offset) {
      var _props2 = this.props;
      var vertical = _props2.vertical;
      var min = _props2.min;
      var max = _props2.max;

      var ratio = Math.abs(offset / this.getSliderLength());
      var value = vertical ? (1 - ratio) * (max - min) + min : ratio * (max - min) + min;
      return value;
    }
  }, {
    key: 'calcValueByPos',
    value: function calcValueByPos(position) {
      var pixelOffset = position - this.getSliderStart();
      var nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
      return nextValue;
    }
  }, {
    key: 'addDocumentEvents',
    value: function addDocumentEvents(type) {
      if (type === 'touch') {
        // just work for chrome iOS Safari and Android Browser
        this.onTouchMoveListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'touchmove', this.onTouchMove.bind(this));
        this.onTouchUpListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'touchend', this.end.bind(this, 'touch'));
      } else if (type === 'mouse') {
        this.onMouseMoveListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'mousemove', this.onMouseMove.bind(this));
        this.onMouseUpListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'mouseup', this.end.bind(this, 'mouse'));
      }
    }
  }, {
    key: 'removeEvents',
    value: function removeEvents(type) {
      if (type === 'touch') {
        this.onTouchMoveListener.remove();
        this.onTouchUpListener.remove();
      } else if (type === 'mouse') {
        this.onMouseMoveListener.remove();
        this.onMouseUpListener.remove();
      }
    }
  }, {
    key: 'end',
    value: function end(type) {
      this.removeEvents(type);
      this.props.onAfterChange(this.getValue());
      this.setState({ handle: null });
    }
  }, {
    key: 'render',
    value: function render() {
      var _classNames;

      var _state3 = this.state;
      var handle = _state3.handle;
      var upperBound = _state3.upperBound;
      var lowerBound = _state3.lowerBound;
      var _props3 = this.props;
      var className = _props3.className;
      var prefixCls = _props3.prefixCls;
      var disabled = _props3.disabled;
      var vertical = _props3.vertical;
      var dots = _props3.dots;
      var included = _props3.included;
      var range = _props3.range;
      var step = _props3.step;
      var marks = _props3.marks;
      var max = _props3.max;
      var min = _props3.min;
      var tipTransitionName = _props3.tipTransitionName;
      var tipFormatter = _props3.tipFormatter;
      var children = _props3.children;

      var customHandle = this.props.handle;

      var upperOffset = this.calcOffset(upperBound);
      var lowerOffset = this.calcOffset(lowerBound);

      var handleClassName = prefixCls + '-handle';
      var isNoTip = step === null || tipFormatter === null;

      var upper = (0, _react.cloneElement)(customHandle, { className: handleClassName,
        noTip: isNoTip, tipTransitionName: tipTransitionName, tipFormatter: tipFormatter,
        vertical: vertical, offset: upperOffset, value: upperBound, dragging: handle === 'upperBound' });

      var lower = null;
      if (range) {
        lower = (0, _react.cloneElement)(customHandle, { className: handleClassName,
          noTip: isNoTip, tipTransitionName: tipTransitionName, tipFormatter: tipFormatter,
          vertical: vertical, offset: lowerOffset, value: lowerBound, dragging: handle === 'lowerBound' });
      }

      var sliderClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, prefixCls, true), _defineProperty(_classNames, prefixCls + '-disabled', disabled), _defineProperty(_classNames, className, !!className), _defineProperty(_classNames, prefixCls + '-vertical', this.props.vertical), _classNames));
      var isIncluded = included || range;
      return _react2['default'].createElement(
        'div',
        { ref: 'slider', className: sliderClassName,
          onTouchStart: disabled ? noop : this.onTouchStart.bind(this),
          onMouseDown: disabled ? noop : this.onMouseDown.bind(this) },
        upper,
        lower,
        _react2['default'].createElement(_Track2['default'], { className: prefixCls + '-track', vertical: vertical, included: isIncluded,
          offset: lowerOffset, length: upperOffset - lowerOffset }),
        _react2['default'].createElement(_Steps2['default'], { prefixCls: prefixCls, vertical: vertical, marks: marks, dots: dots, step: step,
          included: isIncluded, lowerBound: lowerBound,
          upperBound: upperBound, max: max, min: min }),
        _react2['default'].createElement(_Marks2['default'], { className: prefixCls + '-mark', vertical: vertical, marks: marks,
          included: isIncluded, lowerBound: lowerBound,
          upperBound: upperBound, max: max, min: min }),
        children
      );
    }
  }]);

  return Slider;
})(_react2['default'].Component);

Slider.propTypes = {
  min: _react2['default'].PropTypes.number,
  max: _react2['default'].PropTypes.number,
  step: _react2['default'].PropTypes.number,
  defaultValue: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  value: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  marks: _react2['default'].PropTypes.object,
  included: _react2['default'].PropTypes.bool,
  className: _react2['default'].PropTypes.string,
  prefixCls: _react2['default'].PropTypes.string,
  disabled: _react2['default'].PropTypes.bool,
  children: _react2['default'].PropTypes.any,
  onBeforeChange: _react2['default'].PropTypes.func,
  onChange: _react2['default'].PropTypes.func,
  onAfterChange: _react2['default'].PropTypes.func,
  handle: _react2['default'].PropTypes.element,
  tipTransitionName: _react2['default'].PropTypes.string,
  tipFormatter: _react2['default'].PropTypes.func,
  dots: _react2['default'].PropTypes.bool,
  range: _react2['default'].PropTypes.bool,
  vertical: _react2['default'].PropTypes.bool,
  allowCross: _react2['default'].PropTypes.bool
};

Slider.defaultProps = {
  prefixCls: 'rc-slider',
  className: '',
  tipTransitionName: '',
  min: 0,
  max: 100,
  step: 1,
  marks: {},
  handle: _react2['default'].createElement(_Handle2['default'], null),
  onBeforeChange: noop,
  onChange: noop,
  onAfterChange: noop,
  tipFormatter: function tipFormatter(value) {
    return value;
  },
  included: true,
  disabled: false,
  dots: false,
  range: false,
  vertical: false,
  allowCross: true
};

exports['default'] = Slider;
module.exports = exports['default'];
},{"./Handle":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Handle.js","./Marks":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Marks.js","./Steps":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Steps.js","./Track":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Track.js","classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/classnames/index.js","rc-util/lib/Dom/addEventListener":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Steps.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function calcPoints(vertical, marks, dots, step, min, max) {
  (0, _warning2['default'])(dots ? step > 0 : true, '`Slider[step]` should be a positive number in order to make Slider[dots] work.');
  var points = Object.keys(marks).map(parseFloat);
  if (dots) {
    for (var i = min; i <= max; i = i + step) {
      if (points.indexOf(i) >= 0) continue;
      points.push(i);
    }
  }
  return points;
}

var Steps = function Steps(_ref) {
  var prefixCls = _ref.prefixCls;
  var vertical = _ref.vertical;
  var marks = _ref.marks;
  var dots = _ref.dots;
  var step = _ref.step;
  var included = _ref.included;
  var lowerBound = _ref.lowerBound;
  var upperBound = _ref.upperBound;
  var max = _ref.max;
  var min = _ref.min;

  var range = max - min;
  var elements = calcPoints(vertical, marks, dots, step, min, max).map(function (point) {
    var _classNames;

    var offset = Math.abs(point - min) / range * 100 + '%';
    var style = vertical ? { bottom: offset } : { left: offset };

    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var pointClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, prefixCls + '-dot', true), _defineProperty(_classNames, prefixCls + '-dot-active', isActived), _classNames));

    return _react2['default'].createElement('span', { className: pointClassName, style: style, key: point });
  });

  return _react2['default'].createElement(
    'div',
    { className: prefixCls + '-step' },
    elements
  );
};

exports['default'] = Steps;
module.exports = exports['default'];
},{"classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/classnames/index.js","react":"react","warning":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/warning/browser.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Track.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var Track = function Track(_ref) {
  var className = _ref.className;
  var included = _ref.included;
  var vertical = _ref.vertical;
  var offset = _ref.offset;
  var length = _ref.length;

  var style = {
    visibility: included ? 'visible' : 'hidden'
  };
  if (vertical) {
    style.bottom = offset + '%';
    style.height = length + '%';
  } else {
    style.left = offset + '%';
    style.width = length + '%';
  }
  return _react2['default'].createElement('div', { className: className, style: style });
};

exports['default'] = Track;
module.exports = exports['default'];
},{"react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./Slider');
},{"./Slider":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/Slider.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/classnames/index.js":[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/Tooltip.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _placements = require('./placements');

var _rcTrigger = require('rc-trigger');

var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var Tooltip = _react2["default"].createClass({
  displayName: 'Tooltip',

  propTypes: {
    trigger: _react.PropTypes.any,
    children: _react.PropTypes.any,
    defaultVisible: _react.PropTypes.bool,
    visible: _react.PropTypes.bool,
    placement: _react.PropTypes.string,
    transitionName: _react.PropTypes.string,
    animation: _react.PropTypes.any,
    onVisibleChange: _react.PropTypes.func,
    afterVisibleChange: _react.PropTypes.func,
    overlay: _react.PropTypes.oneOfType([_react2["default"].PropTypes.node, _react2["default"].PropTypes.func]).isRequired,
    overlayStyle: _react.PropTypes.object,
    overlayClassName: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    getTooltipContainer: _react.PropTypes.func,
    destroyTooltipOnHide: _react.PropTypes.bool,
    align: _react.PropTypes.object,
    arrowContent: _react.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-tooltip',
      mouseEnterDelay: 0,
      destroyTooltipOnHide: false,
      mouseLeaveDelay: 0.1,
      align: {},
      placement: 'right',
      trigger: ['hover'],
      arrowContent: null
    };
  },
  getPopupElement: function getPopupElement() {
    var _props = this.props;
    var arrowContent = _props.arrowContent;
    var overlay = _props.overlay;
    var prefixCls = _props.prefixCls;

    return [_react2["default"].createElement(
      'div',
      { className: prefixCls + '-arrow', key: 'arrow' },
      arrowContent
    ), _react2["default"].createElement(
      'div',
      { className: prefixCls + '-inner', key: 'content' },
      typeof overlay === 'function' ? overlay() : overlay
    )];
  },
  getPopupDomNode: function getPopupDomNode() {
    return this.refs.trigger.getPopupDomNode();
  },
  render: function render() {
    var _props2 = this.props;
    var overlayClassName = _props2.overlayClassName;
    var trigger = _props2.trigger;
    var mouseEnterDelay = _props2.mouseEnterDelay;
    var mouseLeaveDelay = _props2.mouseLeaveDelay;
    var overlayStyle = _props2.overlayStyle;
    var prefixCls = _props2.prefixCls;
    var children = _props2.children;
    var onVisibleChange = _props2.onVisibleChange;
    var transitionName = _props2.transitionName;
    var animation = _props2.animation;
    var placement = _props2.placement;
    var align = _props2.align;
    var destroyTooltipOnHide = _props2.destroyTooltipOnHide;
    var defaultVisible = _props2.defaultVisible;
    var getTooltipContainer = _props2.getTooltipContainer;

    var restProps = _objectWithoutProperties(_props2, ['overlayClassName', 'trigger', 'mouseEnterDelay', 'mouseLeaveDelay', 'overlayStyle', 'prefixCls', 'children', 'onVisibleChange', 'transitionName', 'animation', 'placement', 'align', 'destroyTooltipOnHide', 'defaultVisible', 'getTooltipContainer']);

    var extraProps = _extends({}, restProps);
    if ('visible' in this.props) {
      extraProps.popupVisible = this.props.visible;
    }
    return _react2["default"].createElement(
      _rcTrigger2["default"],
      _extends({
        popupClassName: overlayClassName,
        ref: 'trigger',
        prefixCls: prefixCls,
        popup: this.getPopupElement,
        action: trigger,
        builtinPlacements: _placements.placements,
        popupPlacement: placement,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltipOnHide,
        mouseLeaveDelay: mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay: mouseEnterDelay
      }, extraProps),
      children
    );
  }
});

exports["default"] = Tooltip;
module.exports = exports['default'];
},{"./placements":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/placements.js","rc-trigger":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./Tooltip');
},{"./Tooltip":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/Tooltip.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/lib/placements.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};

var targetOffset = [0, 0];

var placements = exports.placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  }
};

exports["default"] = placements;
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/LazyRenderBox.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var LazyRenderBox = _react2["default"].createClass({
  displayName: 'LazyRenderBox',

  propTypes: {
    children: _react.PropTypes.any,
    className: _react.PropTypes.string,
    visible: _react.PropTypes.bool,
    hiddenClassName: _react.PropTypes.string
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    return nextProps.hiddenClassName || nextProps.visible;
  },
  render: function render() {
    var _props = this.props;
    var hiddenClassName = _props.hiddenClassName;
    var visible = _props.visible;

    var props = _objectWithoutProperties(_props, ['hiddenClassName', 'visible']);

    if (hiddenClassName || _react2["default"].Children.count(props.children) > 1) {
      if (!visible && hiddenClassName) {
        props.className += ' ' + hiddenClassName;
      }
      return _react2["default"].createElement('div', props);
    }

    return _react2["default"].Children.only(props.children);
  }
});

exports["default"] = LazyRenderBox;
module.exports = exports['default'];
},{"react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Popup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _rcAlign = require('rc-align');

var _rcAlign2 = _interopRequireDefault(_rcAlign);

var _rcAnimate = require('rc-animate');

var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

var _PopupInner = require('./PopupInner');

var _PopupInner2 = _interopRequireDefault(_PopupInner);

var _LazyRenderBox = require('./LazyRenderBox');

var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Popup = _react2["default"].createClass({
  displayName: 'Popup',

  propTypes: {
    visible: _react.PropTypes.bool,
    style: _react.PropTypes.object,
    getClassNameFromAlign: _react.PropTypes.func,
    onAlign: _react.PropTypes.func,
    getRootDomNode: _react.PropTypes.func,
    onMouseEnter: _react.PropTypes.func,
    align: _react.PropTypes.any,
    destroyPopupOnHide: _react.PropTypes.bool,
    className: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    onMouseLeave: _react.PropTypes.func
  },

  componentDidMount: function componentDidMount() {
    this.rootNode = this.getPopupDomNode();
  },
  onAlign: function onAlign(popupDomNode, align) {
    var props = this.props;
    var alignClassName = props.getClassNameFromAlign(props.align);
    var currentAlignClassName = props.getClassNameFromAlign(align);
    if (alignClassName !== currentAlignClassName) {
      this.currentAlignClassName = currentAlignClassName;
      popupDomNode.className = this.getClassName(currentAlignClassName);
    }
    props.onAlign(popupDomNode, align);
  },
  getPopupDomNode: function getPopupDomNode() {
    return _reactDom2["default"].findDOMNode(this.refs.popup);
  },
  getTarget: function getTarget() {
    return this.props.getRootDomNode();
  },
  getMaskTransitionName: function getMaskTransitionName() {
    var props = this.props;
    var transitionName = props.maskTransitionName;
    var animation = props.maskAnimation;
    if (!transitionName && animation) {
      transitionName = props.prefixCls + '-' + animation;
    }
    return transitionName;
  },
  getTransitionName: function getTransitionName() {
    var props = this.props;
    var transitionName = props.transitionName;
    if (!transitionName && props.animation) {
      transitionName = props.prefixCls + '-' + props.animation;
    }
    return transitionName;
  },
  getClassName: function getClassName(currentAlignClassName) {
    return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
  },
  getPopupElement: function getPopupElement() {
    var props = this.props;
    var align = props.align;
    var style = props.style;
    var visible = props.visible;
    var prefixCls = props.prefixCls;
    var destroyPopupOnHide = props.destroyPopupOnHide;

    var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
    var hiddenClassName = prefixCls + '-hidden';
    if (!visible) {
      this.currentAlignClassName = null;
    }
    var newStyle = _extends({}, style, this.getZIndexStyle());
    var popupInnerProps = {
      className: className,
      prefixCls: prefixCls,
      ref: 'popup',
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      style: newStyle
    };
    if (destroyPopupOnHide) {
      return _react2["default"].createElement(
        _rcAnimate2["default"],
        {
          component: '',
          exclusive: true,
          transitionAppear: true,
          transitionName: this.getTransitionName()
        },
        visible ? _react2["default"].createElement(
          _rcAlign2["default"],
          {
            target: this.getTarget,
            key: 'popup',
            ref: this.saveAlign,
            monitorWindowResize: true,
            align: align,
            onAlign: this.onAlign
          },
          _react2["default"].createElement(
            _PopupInner2["default"],
            _extends({
              visible: true
            }, popupInnerProps),
            props.children
          )
        ) : null
      );
    }
    return _react2["default"].createElement(
      _rcAnimate2["default"],
      {
        component: '',
        exclusive: true,
        transitionAppear: true,
        transitionName: this.getTransitionName(),
        showProp: 'xVisible'
      },
      _react2["default"].createElement(
        _rcAlign2["default"],
        {
          target: this.getTarget,
          key: 'popup',
          ref: this.saveAlign,
          monitorWindowResize: true,
          xVisible: visible,
          childrenProps: { visible: 'xVisible' },
          disabled: !visible,
          align: align,
          onAlign: this.onAlign
        },
        _react2["default"].createElement(
          _PopupInner2["default"],
          _extends({
            hiddenClassName: hiddenClassName
          }, popupInnerProps),
          props.children
        )
      )
    );
  },
  getZIndexStyle: function getZIndexStyle() {
    var style = {};
    var props = this.props;
    if (props.zIndex !== undefined) {
      style.zIndex = props.zIndex;
    }
    return style;
  },
  getMaskElement: function getMaskElement() {
    var props = this.props;
    var maskElement = void 0;
    if (props.mask) {
      var maskTransition = this.getMaskTransitionName();
      maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
        style: this.getZIndexStyle(),
        key: 'mask',
        className: props.prefixCls + '-mask',
        hiddenClassName: props.prefixCls + '-mask-hidden',
        visible: props.visible
      });
      if (maskTransition) {
        maskElement = _react2["default"].createElement(
          _rcAnimate2["default"],
          {
            key: 'mask',
            showProp: 'visible',
            transitionAppear: true,
            component: '',
            transitionName: maskTransition
          },
          maskElement
        );
      }
    }
    return maskElement;
  },
  saveAlign: function saveAlign(align) {
    this.alignInstance = align;
  },
  render: function render() {
    return _react2["default"].createElement(
      'div',
      null,
      this.getMaskElement(),
      this.getPopupElement()
    );
  }
});

exports["default"] = Popup;
module.exports = exports['default'];
},{"./LazyRenderBox":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/LazyRenderBox.js","./PopupInner":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/PopupInner.js","rc-align":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/index.js","rc-animate":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/index.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/PopupInner.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _LazyRenderBox = require('./LazyRenderBox');

var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var PopupInner = _react2["default"].createClass({
  displayName: 'PopupInner',

  propTypes: {
    hiddenClassName: _react.PropTypes.string,
    className: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    onMouseEnter: _react.PropTypes.func,
    onMouseLeave: _react.PropTypes.func,
    children: _react.PropTypes.any
  },
  render: function render() {
    var props = this.props;
    var className = props.className;
    if (!props.visible) {
      className += ' ' + props.hiddenClassName;
    }
    return _react2["default"].createElement(
      'div',
      {
        className: className,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        style: props.style
      },
      _react2["default"].createElement(
        _LazyRenderBox2["default"],
        { className: props.prefixCls + '-content', visible: props.visible },
        props.children
      )
    );
  }
});

exports["default"] = PopupInner;
module.exports = exports['default'];
},{"./LazyRenderBox":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/LazyRenderBox.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Trigger.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _createChainedFunction = require('rc-util/lib/createChainedFunction');

var _createChainedFunction2 = _interopRequireDefault(_createChainedFunction);

var _contains = require('rc-util/lib/Dom/contains');

var _contains2 = _interopRequireDefault(_contains);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _Popup = require('./Popup');

var _Popup2 = _interopRequireDefault(_Popup);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function noop() {}

function returnEmptyString() {
  return '';
}

var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];

var Trigger = _react2["default"].createClass({
  displayName: 'Trigger',

  propTypes: {
    action: _react.PropTypes.any,
    showAction: _react.PropTypes.any,
    hideAction: _react.PropTypes.any,
    getPopupClassNameFromAlign: _react.PropTypes.any,
    onPopupVisibleChange: _react.PropTypes.func,
    afterPopupVisibleChange: _react.PropTypes.func,
    popup: _react.PropTypes.oneOfType([_react.PropTypes.node, _react.PropTypes.func]).isRequired,
    popupStyle: _react.PropTypes.object,
    prefixCls: _react.PropTypes.string,
    popupClassName: _react.PropTypes.string,
    popupPlacement: _react.PropTypes.string,
    builtinPlacements: _react.PropTypes.object,
    popupTransitionName: _react.PropTypes.string,
    popupAnimation: _react.PropTypes.any,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    zIndex: _react.PropTypes.number,
    focusDelay: _react.PropTypes.number,
    blurDelay: _react.PropTypes.number,
    getPopupContainer: _react.PropTypes.func,
    destroyPopupOnHide: _react.PropTypes.bool,
    mask: _react.PropTypes.bool,
    onPopupAlign: _react.PropTypes.func,
    popupAlign: _react.PropTypes.object,
    popupVisible: _react.PropTypes.bool,
    maskTransitionName: _react.PropTypes.string,
    maskAnimation: _react.PropTypes.string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-trigger-popup',
      getPopupClassNameFromAlign: returnEmptyString,
      onPopupVisibleChange: noop,
      afterPopupVisibleChange: noop,
      onPopupAlign: noop,
      popupClassName: '',
      mouseEnterDelay: 0,
      mouseLeaveDelay: 0.1,
      focusDelay: 0,
      blurDelay: 0.15,
      popupStyle: {},
      destroyPopupOnHide: false,
      popupAlign: {},
      defaultPopupVisible: false,
      mask: false,
      action: [],
      showAction: [],
      hideAction: []
    };
  },
  getInitialState: function getInitialState() {
    var props = this.props;
    var popupVisible = void 0;
    if ('popupVisible' in props) {
      popupVisible = !!props.popupVisible;
    } else {
      popupVisible = !!props.defaultPopupVisible;
    }
    return {
      popupVisible: popupVisible
    };
  },
  componentDidMount: function componentDidMount() {
    this.componentDidUpdate({}, {
      popupVisible: this.state.popupVisible
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if ('popupVisible' in nextProps) {
      this.setState({
        popupVisible: !!nextProps.popupVisible
      });
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    var _this = this;

    var props = this.props;
    var state = this.state;
    if (this.popupRendered) {
      var _ret = function () {
        var self = _this;
        _reactDom2["default"].unstable_renderSubtreeIntoContainer(_this, _this.getPopupElement(), _this.getPopupContainer(), function mounted() {
          self.popupInstance = this;
          if (prevState.popupVisible !== state.popupVisible) {
            props.afterPopupVisibleChange(state.popupVisible);
          }
        });
        if (_this.isClickToHide()) {
          if (state.popupVisible) {
            if (!_this.clickOutsideHandler) {
              _this.clickOutsideHandler = (0, _addEventListener2["default"])(document, 'mousedown', _this.onDocumentClick);
              _this.touchOutsideHandler = (0, _addEventListener2["default"])(document, 'touchstart', _this.onDocumentClick);
            }
            return {
              v: void 0
            };
          }
        }
        if (_this.clickOutsideHandler) {
          _this.clickOutsideHandler.remove();
          _this.touchOutsideHandler.remove();
          _this.clickOutsideHandler = null;
          _this.touchOutsideHandler = null;
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    var popupContainer = this.popupContainer;
    if (popupContainer) {
      _reactDom2["default"].unmountComponentAtNode(popupContainer);
      popupContainer.parentNode.removeChild(popupContainer);
      this.popupContainer = null;
    }
    this.clearDelayTimer();
    if (this.clickOutsideHandler) {
      this.clickOutsideHandler.remove();
      this.touchOutsideHandler.remove();
      this.clickOutsideHandler = null;
      this.touchOutsideHandler = null;
    }
  },
  onMouseEnter: function onMouseEnter() {
    this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
  },
  onMouseLeave: function onMouseLeave(e) {
    // https://github.com/react-component/trigger/pull/13
    // react bug?
    if (e.relatedTarget && !e.relatedTarget.setTimeout && (0, _contains2["default"])(this.popupContainer, e.relatedTarget)) {
      return;
    }
    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
  },
  onFocus: function onFocus() {
    // incase focusin and focusout
    this.clearDelayTimer();
    if (this.isFocusToShow()) {
      this.focusTime = Date.now();
      this.delaySetPopupVisible(true, this.props.focusDelay);
    }
  },
  onMouseDown: function onMouseDown() {
    this.preClickTime = Date.now();
  },
  onTouchStart: function onTouchStart() {
    this.preTouchTime = Date.now();
  },
  onBlur: function onBlur() {
    this.clearDelayTimer();
    if (this.isBlurToHide()) {
      this.delaySetPopupVisible(false, this.props.blurDelay);
    }
  },
  onClick: function onClick(event) {
    // focus will trigger click
    if (this.focusTime) {
      var preTime = void 0;
      if (this.preClickTime && this.preTouchTime) {
        preTime = Math.min(this.preClickTime, this.preTouchTime);
      } else if (this.preClickTime) {
        preTime = this.preClickTime;
      } else if (this.preTouchTime) {
        preTime = this.preTouchTime;
      }
      if (Math.abs(preTime - this.focusTime) < 20) {
        return;
      }
      this.focusTime = 0;
    }
    this.preClickTime = 0;
    this.preTouchTime = 0;
    event.preventDefault();
    var nextVisible = !this.state.popupVisible;
    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
      this.setPopupVisible(!this.state.popupVisible);
    }
  },
  onDocumentClick: function onDocumentClick(event) {
    var target = event.target;
    var root = (0, _reactDom.findDOMNode)(this);
    var popupNode = this.getPopupDomNode();
    if (!(0, _contains2["default"])(root, target) && !(0, _contains2["default"])(popupNode, target)) {
      this.setPopupVisible(false);
    }
  },
  getPopupDomNode: function getPopupDomNode() {
    // for test
    if (this.popupInstance) {
      return this.popupInstance.isMounted() ? this.popupInstance.getPopupDomNode() : null;
    }
    return null;
  },
  getRootDomNode: function getRootDomNode() {
    return _reactDom2["default"].findDOMNode(this);
  },
  getPopupContainer: function getPopupContainer() {
    if (!this.popupContainer) {
      this.popupContainer = document.createElement('div');
      var mountNode = this.props.getPopupContainer ? this.props.getPopupContainer((0, _reactDom.findDOMNode)(this)) : document.body;
      mountNode.appendChild(this.popupContainer);
    }
    return this.popupContainer;
  },
  getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
    var className = [];
    var props = this.props;
    var popupPlacement = props.popupPlacement;
    var builtinPlacements = props.builtinPlacements;
    var prefixCls = props.prefixCls;

    if (popupPlacement && builtinPlacements) {
      className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
    }
    if (props.getPopupClassNameFromAlign) {
      className.push(props.getPopupClassNameFromAlign(align));
    }
    return className.join(' ');
  },
  getPopupAlign: function getPopupAlign() {
    var props = this.props;
    var popupPlacement = props.popupPlacement;
    var popupAlign = props.popupAlign;
    var builtinPlacements = props.builtinPlacements;

    if (popupPlacement && builtinPlacements) {
      return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
    }
    return popupAlign;
  },
  getPopupElement: function getPopupElement() {
    var props = this.props;
    var state = this.state;

    var mouseProps = {};
    if (this.isMouseEnterToShow()) {
      mouseProps.onMouseEnter = this.onMouseEnter;
    }
    if (this.isMouseLeaveToHide()) {
      mouseProps.onMouseLeave = this.onMouseLeave;
    }
    return _react2["default"].createElement(
      _Popup2["default"],
      _extends({
        prefixCls: props.prefixCls,
        destroyPopupOnHide: props.destroyPopupOnHide,
        visible: state.popupVisible,
        className: props.popupClassName,
        action: props.action,
        align: this.getPopupAlign(),
        onAlign: props.onPopupAlign,
        animation: props.popupAnimation,
        getClassNameFromAlign: this.getPopupClassNameFromAlign
      }, mouseProps, {
        getRootDomNode: this.getRootDomNode,
        style: props.popupStyle,
        mask: props.mask,
        zIndex: props.zIndex,
        transitionName: props.popupTransitionName,
        maskAnimation: props.maskAnimation,
        maskTransitionName: props.maskTransitionName
      }),
      typeof props.popup === 'function' ? props.popup() : props.popup
    );
  },
  setPopupVisible: function setPopupVisible(popupVisible) {
    this.clearDelayTimer();
    if (this.state.popupVisible !== popupVisible) {
      if (!('popupVisible' in this.props)) {
        this.setState({
          popupVisible: popupVisible
        });
      }
      this.props.onPopupVisibleChange(popupVisible);
    }
  },
  delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
    var _this2 = this;

    var delay = delayS * 1000;
    this.clearDelayTimer();
    if (delay) {
      this.delayTimer = setTimeout(function () {
        _this2.setPopupVisible(visible);
        _this2.clearDelayTimer();
      }, delay);
    } else {
      this.setPopupVisible(visible);
    }
  },
  clearDelayTimer: function clearDelayTimer() {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
  },
  isClickToShow: function isClickToShow() {
    var _props = this.props;
    var action = _props.action;
    var showAction = _props.showAction;

    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
  },
  isClickToHide: function isClickToHide() {
    var _props2 = this.props;
    var action = _props2.action;
    var hideAction = _props2.hideAction;

    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
  },
  isMouseEnterToShow: function isMouseEnterToShow() {
    var _props3 = this.props;
    var action = _props3.action;
    var showAction = _props3.showAction;

    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
  },
  isMouseLeaveToHide: function isMouseLeaveToHide() {
    var _props4 = this.props;
    var action = _props4.action;
    var hideAction = _props4.hideAction;

    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
  },
  isFocusToShow: function isFocusToShow() {
    var _props5 = this.props;
    var action = _props5.action;
    var showAction = _props5.showAction;

    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
  },
  isBlurToHide: function isBlurToHide() {
    var _props6 = this.props;
    var action = _props6.action;
    var hideAction = _props6.hideAction;

    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
  },
  forcePopupAlign: function forcePopupAlign() {
    if (this.state.popupVisible && this.popupInstance && this.popupInstance.alignInstance) {
      this.popupInstance.alignInstance.forceAlign();
    }
  },
  render: function render() {
    this.popupRendered = this.popupRendered || this.state.popupVisible;
    var props = this.props;
    var children = props.children;
    var child = _react2["default"].Children.only(children);
    var childProps = child.props || {};
    var newChildProps = {};

    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = (0, _createChainedFunction2["default"])(this.onClick, childProps.onClick);
      newChildProps.onMouseDown = (0, _createChainedFunction2["default"])(this.onMouseDown, childProps.onMouseDown);
      newChildProps.onTouchStart = (0, _createChainedFunction2["default"])(this.onTouchStart, childProps.onTouchStart);
    }
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseEnter = (0, _createChainedFunction2["default"])(this.onMouseEnter, childProps.onMouseEnter);
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseLeave = (0, _createChainedFunction2["default"])(this.onMouseLeave, childProps.onMouseLeave);
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = (0, _createChainedFunction2["default"])(this.onFocus, childProps.onFocus);
      newChildProps.onBlur = (0, _createChainedFunction2["default"])(this.onBlur, childProps.onBlur);
    }

    ALL_HANDLERS.forEach(function (handler) {
      var newFn = void 0;
      if (props[handler] && newChildProps[handler]) {
        newFn = (0, _createChainedFunction2["default"])(props[handler], newChildProps[handler]);
      } else {
        newFn = props[handler] || newChildProps[handler];
      }
      if (newFn) {
        newChildProps[handler] = newFn;
      }
    });

    return _react2["default"].cloneElement(child, newChildProps);
  }
});

exports["default"] = Trigger;
module.exports = exports['default'];
},{"./Popup":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Popup.js","./utils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/utils.js","rc-util/lib/Dom/addEventListener":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js","rc-util/lib/Dom/contains":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/contains.js","rc-util/lib/createChainedFunction":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/createChainedFunction.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./Trigger');
},{"./Trigger":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/Trigger.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/lib/utils.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getAlignFromPlacement = getAlignFromPlacement;
exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;
function isPointsEq(a1, a2) {
  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _extends({}, baseAlign, align);
}

function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
  var points = align.points;
  for (var placement in builtinPlacements) {
    if (builtinPlacements.hasOwnProperty(placement)) {
      if (isPointsEq(builtinPlacements[placement].points, points)) {
        return prefixCls + '-placement-' + placement;
      }
    }
  }
  return '';
}
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/Align.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _domAlign = require('dom-align');

var _domAlign2 = _interopRequireDefault(_domAlign);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _isWindow = require('./isWindow');

var _isWindow2 = _interopRequireDefault(_isWindow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function buffer(fn, ms) {
  var timer = void 0;
  return function bufferFn() {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(fn, ms);
  };
}

var Align = _react2["default"].createClass({
  displayName: 'Align',

  propTypes: {
    childrenProps: _react.PropTypes.object,
    align: _react.PropTypes.object.isRequired,
    target: _react.PropTypes.func,
    onAlign: _react.PropTypes.func,
    monitorBufferTime: _react.PropTypes.number,
    monitorWindowResize: _react.PropTypes.bool,
    disabled: _react.PropTypes.bool,
    children: _react.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      target: function target() {
        return window;
      },
      onAlign: function onAlign() {},

      monitorBufferTime: 50,
      monitorWindowResize: false,
      disabled: false
    };
  },
  componentDidMount: function componentDidMount() {
    var props = this.props;
    // if parent ref not attached .... use document.getElementById
    this.forceAlign();
    if (!props.disabled && props.monitorWindowResize) {
      this.startMonitorWindowResize();
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    var reAlign = false;
    var props = this.props;

    if (!props.disabled) {
      if (prevProps.disabled || prevProps.align !== props.align) {
        reAlign = true;
      } else {
        var lastTarget = prevProps.target();
        var currentTarget = props.target();
        if ((0, _isWindow2["default"])(lastTarget) && (0, _isWindow2["default"])(currentTarget)) {
          reAlign = false;
        } else if (lastTarget !== currentTarget) {
          reAlign = true;
        }
      }
    }

    if (reAlign) {
      this.forceAlign();
    }

    if (props.monitorWindowResize && !props.disabled) {
      this.startMonitorWindowResize();
    } else {
      this.stopMonitorWindowResize();
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this.stopMonitorWindowResize();
  },
  startMonitorWindowResize: function startMonitorWindowResize() {
    if (!this.resizeHandler) {
      this.resizeHandler = (0, _addEventListener2["default"])(window, 'resize', buffer(this.forceAlign, this.props.monitorBufferTime));
    }
  },
  stopMonitorWindowResize: function stopMonitorWindowResize() {
    if (this.resizeHandler) {
      this.resizeHandler.remove();
      this.resizeHandler = null;
    }
  },
  forceAlign: function forceAlign() {
    var props = this.props;
    if (!props.disabled) {
      var source = _reactDom2["default"].findDOMNode(this);
      props.onAlign(source, (0, _domAlign2["default"])(source, props.target(), props.align));
    }
  },
  render: function render() {
    var _props = this.props;
    var childrenProps = _props.childrenProps;
    var children = _props.children;

    var child = _react2["default"].Children.only(children);
    if (childrenProps) {
      var newProps = {};
      for (var prop in childrenProps) {
        if (childrenProps.hasOwnProperty(prop)) {
          newProps[prop] = this.props[childrenProps[prop]];
        }
      }
      return _react2["default"].cloneElement(child, newProps);
    }
    return child;
  }
});

exports["default"] = Align;
module.exports = exports['default'];
},{"./isWindow":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/isWindow.js","dom-align":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/index.js","rc-util/lib/Dom/addEventListener":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Align = require('./Align');

var _Align2 = _interopRequireDefault(_Align);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports["default"] = _Align2["default"]; // export this package's api

module.exports = exports['default'];
},{"./Align":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/Align.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/lib/isWindow.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isWindow;
function isWindow(obj) {
  /* eslint no-eq-null: 0 */
  /* eslint eqeqeq: 0 */
  return obj != null && obj == obj.window;
}
module.exports = exports['default'];
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/adjustForViewport.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = _utils2['default'].clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }

  // Right edge outside viewport, try to move it.
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }

  // Top edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }

  // Bottom edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return _utils2['default'].mix(pos, size);
}

exports['default'] = adjustForViewport;
module.exports = exports['default'];
},{"./utils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getAlignOffset.js":[function(require,module,exports){
/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = undefined;
  var y = undefined;

  x = region.left;
  y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

exports['default'] = getAlignOffset;
module.exports = exports['default'];
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getElFuturePos.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _getAlignOffset = require('./getAlignOffset');

var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var xy = undefined;
  var diff = undefined;
  var p1 = undefined;
  var p2 = undefined;

  xy = {
    left: elRegion.left,
    top: elRegion.top
  };

  p1 = (0, _getAlignOffset2['default'])(refNodeRegion, points[1]);
  p2 = (0, _getAlignOffset2['default'])(elRegion, points[0]);

  diff = [p2.left - p1.left, p2.top - p1.top];

  return {
    left: xy.left - diff[0] + offset[0] - targetOffset[0],
    top: xy.top - diff[1] + offset[1] - targetOffset[1]
  };
}

exports['default'] = getElFuturePos;
module.exports = exports['default'];
},{"./getAlignOffset":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getAlignOffset.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getOffsetParent.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

/**
 * 得到会导致元素显示不全的祖先元素
 */

function getOffsetParent(element) {
  // ie 这个也不是完全可行
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法
  var doc = element.ownerDocument;
  var body = doc.body;
  var parent = undefined;
  var positionStyle = _utils2['default'].css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
  }

  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
    positionStyle = _utils2['default'].css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}

exports['default'] = getOffsetParent;
module.exports = exports['default'];
},{"./utils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getRegion.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function getRegion(node) {
  var offset = undefined;
  var w = undefined;
  var h = undefined;
  if (!_utils2['default'].isWindow(node) && node.nodeType !== 9) {
    offset = _utils2['default'].offset(node);
    w = _utils2['default'].outerWidth(node);
    h = _utils2['default'].outerHeight(node);
  } else {
    var win = _utils2['default'].getWindow(node);
    offset = {
      left: _utils2['default'].getWindowScrollLeft(win),
      top: _utils2['default'].getWindowScrollTop(win)
    };
    w = _utils2['default'].viewportWidth(win);
    h = _utils2['default'].viewportHeight(win);
  }
  offset.width = w;
  offset.height = h;
  return offset;
}

exports['default'] = getRegion;
module.exports = exports['default'];
},{"./utils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getVisibleRectForElement.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _getOffsetParent = require('./getOffsetParent');

var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

/**
 * 获得元素的显示部分的区域
 */
function getVisibleRectForElement(element) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = (0, _getOffsetParent2['default'])(element);
  var scrollX = undefined;
  var scrollY = undefined;
  var winSize = undefined;
  var doc = element.ownerDocument;
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && _utils2['default'].css(el, 'overflow') !== 'visible') {
      var pos = _utils2['default'].offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = (0, _getOffsetParent2['default'])(el);
  }

  // Clip by window's viewport.
  scrollX = _utils2['default'].getWindowScrollLeft(win);
  scrollY = _utils2['default'].getWindowScrollTop(win);
  visibleRect.left = Math.max(visibleRect.left, scrollX);
  visibleRect.top = Math.max(visibleRect.top, scrollY);
  winSize = {
    width: _utils2['default'].viewportWidth(win),
    height: _utils2['default'].viewportHeight(win)
  };
  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

exports['default'] = getVisibleRectForElement;
module.exports = exports['default'];
},{"./getOffsetParent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getOffsetParent.js","./utils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/index.js":[function(require,module,exports){
/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _getOffsetParent = require('./getOffsetParent');

var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

var _getVisibleRectForElement = require('./getVisibleRectForElement');

var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);

var _adjustForViewport = require('./adjustForViewport');

var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);

var _getRegion = require('./getRegion');

var _getRegion2 = _interopRequireDefault(_getRegion);

var _getElFuturePos = require('./getElFuturePos');

var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);

// http://yiminghe.iteye.com/blog/1124720

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  _utils2['default'].each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n = undefined;
  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }
  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}

function domAlign(el, refNode, align) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var target = align.target || refNode;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};

  var fail = 0;
  // 当前节点可以被放置的显示区域
  var visibleRect = (0, _getVisibleRectForElement2['default'])(source);
  // 当前节点所占的区域, left/top/width/height
  var elRegion = (0, _getRegion2['default'])(source);
  // 参照节点所占的区域, left/top/width/height
  var refNodeRegion = (0, _getRegion2['default'])(target);
  // 将 offset 转换成数值，支持百分比
  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, refNodeRegion);
  // 当前节点将要被放置的位置
  var elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
  // 当前节点将要所处的区域
  var newElRegion = _utils2['default'].merge(elRegion, elFuturePos);

  // 如果可视区域不能完全放置当前节点时允许调整
  if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/ig, {
          l: 'r',
          r: 'l'
        });
        // 偏移量也反下
        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[tb]/ig, {
          t: 'b',
          b: 't'
        });
        // 偏移量也反下
        var newOffset = flipOffset(offset, 1);
        var newTargetOffset = flipOffset(targetOffset, 1);
        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailY(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    // 如果失败，重新计算当前节点将要被放置的位置
    if (fail) {
      elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
      _utils2['default'].mix(newElRegion, elFuturePos);
    }

    // 检查反下后的位置是否可以放下了
    // 如果仍然放不下只有指定了可以调整当前方向才调整
    newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);

    newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);

    // 确实要调整，甚至可能会调整高度宽度
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = (0, _adjustForViewport2['default'])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }

  // need judge to in case set fixed with in css on height auto element
  if (newElRegion.width !== elRegion.width) {
    _utils2['default'].css(source, 'width', source.width() + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    _utils2['default'].css(source, 'height', source.height() + newElRegion.height - elRegion.height);
  }

  // https://github.com/kissyteam/kissy/issues/190
  // http://localhost:8888/kissy/src/overlay/demo/other/relative_align/align.html
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>
  _utils2['default'].offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom
  });

  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}

domAlign.__getOffsetParent = _getOffsetParent2['default'];

domAlign.__getVisibleRectForElement = _getVisibleRectForElement2['default'];

exports['default'] = domAlign;

/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/
module.exports = exports['default'];
},{"./adjustForViewport":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/adjustForViewport.js","./getElFuturePos":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getElFuturePos.js","./getOffsetParent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getOffsetParent.js","./getRegion":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getRegion.js","./getVisibleRectForElement":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/getVisibleRectForElement.js","./utils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-align/node_modules/dom-align/lib/utils.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

var getComputedStyleX = undefined;

function css(el, name, v) {
  var value = v;
  if (typeof name === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = value + 'px';
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box = undefined;
  var x = undefined;
  var y = undefined;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top;

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;

  return { left: x, top: y };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = elem.ownerDocument;
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;

    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
}

// 设置 elem 相对 elem.ownerDocument 的坐标
function setOffset(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = presetH + 'px';
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = presetV + 'px';
  }
  var old = getOffset(elem);
  var ret = {};
  var key = undefined;
  for (key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      if (dir === key) {
        ret[dir] = preset + offset[key] - old[key];
      } else {
        ret[dir] = preset + old[key] - offset[key];
      }
    }
  }
  css(elem, ret);
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = undefined;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = undefined;
  var j = undefined;
  var i = undefined;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = undefined;
        if (prop === 'border') {
          cssProp = prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

var domUtils = {};

each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name],
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var val = undefined;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i = undefined;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    for (var i = 0; i < args.length; i++) {
      utils.mix(ret, args[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};

mix(utils, domUtils);

exports['default'] = utils;
module.exports = exports['default'];
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/Animate.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _ChildrenUtils = require('./ChildrenUtils');

var _AnimateChild = require('./AnimateChild');

var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultKey = 'rc_animate_' + Date.now();


function getChildrenFromProps(props) {
  var children = props.children;
  if (_react2["default"].isValidElement(children)) {
    if (!children.key) {
      return _react2["default"].cloneElement(children, {
        key: defaultKey
      });
    }
  }
  return children;
}

function noop() {}

var Animate = _react2["default"].createClass({
  displayName: 'Animate',

  propTypes: {
    component: _react2["default"].PropTypes.any,
    animation: _react2["default"].PropTypes.object,
    transitionName: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.string, _react2["default"].PropTypes.object]),
    transitionEnter: _react2["default"].PropTypes.bool,
    transitionAppear: _react2["default"].PropTypes.bool,
    exclusive: _react2["default"].PropTypes.bool,
    transitionLeave: _react2["default"].PropTypes.bool,
    onEnd: _react2["default"].PropTypes.func,
    onEnter: _react2["default"].PropTypes.func,
    onLeave: _react2["default"].PropTypes.func,
    onAppear: _react2["default"].PropTypes.func,
    showProp: _react2["default"].PropTypes.string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      animation: {},
      component: 'span',
      transitionEnter: true,
      transitionLeave: true,
      transitionAppear: false,
      onEnd: noop,
      onEnter: noop,
      onLeave: noop,
      onAppear: noop
    };
  },
  getInitialState: function getInitialState() {
    this.currentlyAnimatingKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
    return {
      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
    };
  },
  componentDidMount: function componentDidMount() {
    var _this = this;

    var showProp = this.props.showProp;
    var children = this.state.children;
    if (showProp) {
      children = children.filter(function (child) {
        return !!child.props[showProp];
      });
    }
    children.forEach(function (child) {
      if (child) {
        _this.performAppear(child.key);
      }
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    this.nextProps = nextProps;
    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
    var props = this.props;
    // exclusive needs immediate response
    if (props.exclusive) {
      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
        _this2.stop(key);
      });
    }
    var showProp = props.showProp;
    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
    // last props children if exclusive
    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
    // in case destroy in showProp mode
    var newChildren = [];
    if (showProp) {
      currentChildren.forEach(function (currentChild) {
        var nextChild = currentChild && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
        var newChild = void 0;
        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
          newChild = _react2["default"].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
        } else {
          newChild = nextChild;
        }
        if (newChild) {
          newChildren.push(newChild);
        }
      });
      nextChildren.forEach(function (nextChild) {
        if (!nextChild || !(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
          newChildren.push(nextChild);
        }
      });
    } else {
      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
    }

    // need render to avoid update
    this.setState({
      children: newChildren
    });

    nextChildren.forEach(function (child) {
      var key = child && child.key;
      if (child && currentlyAnimatingKeys[key]) {
        return;
      }
      var hasPrev = child && (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
      if (showProp) {
        var showInNext = child.props[showProp];
        if (hasPrev) {
          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
          if (!showInNow && showInNext) {
            _this2.keysToEnter.push(key);
          }
        } else if (showInNext) {
          _this2.keysToEnter.push(key);
        }
      } else if (!hasPrev) {
        _this2.keysToEnter.push(key);
      }
    });

    currentChildren.forEach(function (child) {
      var key = child && child.key;
      if (child && currentlyAnimatingKeys[key]) {
        return;
      }
      var hasNext = child && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
      if (showProp) {
        var showInNow = child.props[showProp];
        if (hasNext) {
          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
          if (!showInNext && showInNow) {
            _this2.keysToLeave.push(key);
          }
        } else if (showInNow) {
          _this2.keysToLeave.push(key);
        }
      } else if (!hasNext) {
        _this2.keysToLeave.push(key);
      }
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);
    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },
  performEnter: function performEnter(key) {
    // may already remove by exclusive
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
    }
  },
  performAppear: function performAppear(key) {
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
    }
  },
  handleDoneAdding: function handleDoneAdding(key, type) {
    var props = this.props;
    delete this.currentlyAnimatingKeys[key];
    // if update on exclusive mode, skip check
    if (props.exclusive && props !== this.nextProps) {
      return;
    }
    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
    if (!this.isValidChildByKey(currentChildren, key)) {
      // exclusive will not need this
      this.performLeave(key);
    } else {
      if (type === 'appear') {
        if (_util2["default"].allowAppearCallback(props)) {
          props.onAppear(key);
          props.onEnd(key, true);
        }
      } else {
        if (_util2["default"].allowEnterCallback(props)) {
          props.onEnter(key);
          props.onEnd(key, true);
        }
      }
    }
  },
  performLeave: function performLeave(key) {
    // may already remove by exclusive
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
    }
  },
  handleDoneLeaving: function handleDoneLeaving(key) {
    var props = this.props;
    delete this.currentlyAnimatingKeys[key];
    // if update on exclusive mode, skip check
    if (props.exclusive && props !== this.nextProps) {
      return;
    }
    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
    // in case state change is too fast
    if (this.isValidChildByKey(currentChildren, key)) {
      this.performEnter(key);
    } else {
      var end = function end() {
        if (_util2["default"].allowLeaveCallback(props)) {
          props.onLeave(key);
          props.onEnd(key, false);
        }
      };
      /* eslint react/no-is-mounted:0 */
      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
        this.setState({
          children: currentChildren
        }, end);
      } else {
        end();
      }
    }
  },
  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
    var showProp = this.props.showProp;
    if (showProp) {
      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
    }
    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
  },
  stop: function stop(key) {
    delete this.currentlyAnimatingKeys[key];
    var component = this.refs[key];
    if (component) {
      component.stop();
    }
  },
  render: function render() {
    var props = this.props;
    this.nextProps = props;
    var stateChildren = this.state.children;
    var children = null;
    if (stateChildren) {
      children = stateChildren.map(function (child) {
        if (child === null || child === undefined) {
          return child;
        }
        if (!child.key) {
          throw new Error('must set key for <rc-animate> children');
        }
        return _react2["default"].createElement(
          _AnimateChild2["default"],
          {
            key: child.key,
            ref: child.key,
            animation: props.animation,
            transitionName: props.transitionName,
            transitionEnter: props.transitionEnter,
            transitionAppear: props.transitionAppear,
            transitionLeave: props.transitionLeave
          },
          child
        );
      });
    }
    var Component = props.component;
    if (Component) {
      var passedProps = props;
      if (typeof Component === 'string') {
        passedProps = {
          className: props.className,
          style: props.style
        };
      }
      return _react2["default"].createElement(
        Component,
        passedProps,
        children
      );
    }
    return children[0] || null;
  }
});

exports["default"] = Animate;
module.exports = exports['default'];
},{"./AnimateChild":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/AnimateChild.js","./ChildrenUtils":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/ChildrenUtils.js","./util":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/util.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/AnimateChild.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _cssAnimation = require('css-animation');

var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var transitionMap = {
  enter: 'transitionEnter',
  appear: 'transitionAppear',
  leave: 'transitionLeave'
};

var AnimateChild = _react2["default"].createClass({
  displayName: 'AnimateChild',

  propTypes: {
    children: _react2["default"].PropTypes.any
  },

  componentWillUnmount: function componentWillUnmount() {
    this.stop();
  },
  componentWillEnter: function componentWillEnter(done) {
    if (_util2["default"].isEnterSupported(this.props)) {
      this.transition('enter', done);
    } else {
      done();
    }
  },
  componentWillAppear: function componentWillAppear(done) {
    if (_util2["default"].isAppearSupported(this.props)) {
      this.transition('appear', done);
    } else {
      done();
    }
  },
  componentWillLeave: function componentWillLeave(done) {
    if (_util2["default"].isLeaveSupported(this.props)) {
      this.transition('leave', done);
    } else {
      // always sync, do not interupt with react component life cycle
      // update hidden -> animate hidden ->
      // didUpdate -> animate leave -> unmount (if animate is none)
      done();
    }
  },
  transition: function transition(animationType, finishCallback) {
    var _this = this;

    var node = _reactDom2["default"].findDOMNode(this);
    var props = this.props;
    var transitionName = props.transitionName;
    var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) === 'object';
    this.stop();
    var end = function end() {
      _this.stopper = null;
      finishCallback();
    };
    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
      var name = nameIsObj ? transitionName[animationType] : transitionName + '-' + animationType;
      this.stopper = (0, _cssAnimation2["default"])(node, name, end);
    } else {
      this.stopper = props.animation[animationType](node, end);
    }
  },
  stop: function stop() {
    var stopper = this.stopper;
    if (stopper) {
      this.stopper = null;
      stopper.stop();
    }
  },
  render: function render() {
    return this.props.children;
  }
});

exports["default"] = AnimateChild;
module.exports = exports['default'];
},{"./util":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/util.js","css-animation":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/index.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/ChildrenUtils.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayChildren = toArrayChildren;
exports.findChildInChildrenByKey = findChildInChildrenByKey;
exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
exports.isSameChildren = isSameChildren;
exports.mergeChildren = mergeChildren;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function toArrayChildren(children) {
  var ret = [];
  _react2["default"].Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}

function findChildInChildrenByKey(children, key) {
  var ret = null;
  if (children) {
    children.forEach(function (child) {
      if (ret) {
        return;
      }
      if (child && child.key === key) {
        ret = child;
      }
    });
  }
  return ret;
}

function findShownChildInChildrenByKey(children, key, showProp) {
  var ret = null;
  if (children) {
    children.forEach(function (child) {
      if (child && child.key === key && child.props[showProp]) {
        if (ret) {
          throw new Error('two child with same key for <rc-animate> children');
        }
        ret = child;
      }
    });
  }
  return ret;
}

function findHiddenChildInChildrenByKey(children, key, showProp) {
  var found = 0;
  if (children) {
    children.forEach(function (child) {
      if (found) {
        return;
      }
      found = child && child.key === key && !child.props[showProp];
    });
  }
  return found;
}

function isSameChildren(c1, c2, showProp) {
  var same = c1.length === c2.length;
  if (same) {
    c1.forEach(function (child, index) {
      var child2 = c2[index];
      if (child && child2) {
        if (child && !child2 || !child && child2) {
          same = false;
        } else if (child.key !== child2.key) {
          same = false;
        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
          same = false;
        }
      }
    });
  }
  return same;
}

function mergeChildren(prev, next) {
  var ret = [];

  // For each key of `next`, the list of keys to insert before that key in
  // the combined list
  var nextChildrenPending = {};
  var pendingChildren = [];
  prev.forEach(function (child) {
    if (child && findChildInChildrenByKey(next, child.key)) {
      if (pendingChildren.length) {
        nextChildrenPending[child.key] = pendingChildren;
        pendingChildren = [];
      }
    } else {
      pendingChildren.push(child);
    }
  });

  next.forEach(function (child) {
    if (child && nextChildrenPending.hasOwnProperty(child.key)) {
      ret = ret.concat(nextChildrenPending[child.key]);
    }
    ret.push(child);
  });

  ret = ret.concat(pendingChildren);

  return ret;
}
},{"react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/index.js":[function(require,module,exports){
'use strict';

// export this package's api
module.exports = require('./Animate');
},{"./Animate":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/Animate.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/lib/util.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {
  isAppearSupported: function isAppearSupported(props) {
    return props.transitionName && props.transitionAppear || props.animation.appear;
  },
  isEnterSupported: function isEnterSupported(props) {
    return props.transitionName && props.transitionEnter || props.animation.enter;
  },
  isLeaveSupported: function isLeaveSupported(props) {
    return props.transitionName && props.transitionLeave || props.animation.leave;
  },
  allowAppearCallback: function allowAppearCallback(props) {
    return props.transitionAppear || props.animation.appear;
  },
  allowEnterCallback: function allowEnterCallback(props) {
    return props.transitionEnter || props.animation.enter;
  },
  allowLeaveCallback: function allowLeaveCallback(props) {
    return props.transitionLeave || props.animation.leave;
  }
};
exports["default"] = util;
module.exports = exports['default'];
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/Event.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },

  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
      var baseEvents = EVENT_NAME_MAP[baseEventName];
      for (var styleName in baseEvents) {
        if (styleName in style) {
          endEvents.push(baseEvents[styleName]);
          break;
        }
      }
    }
  }
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },


  endEvents: endEvents,

  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

exports["default"] = TransitionEvents;
module.exports = exports['default'];
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Event = require('./Event');

var _Event2 = _interopRequireDefault(_Event);

var _componentClasses = require('component-classes');

var _componentClasses2 = _interopRequireDefault(_componentClasses);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;


var capitalPrefixes = ['Webkit', 'Moz', 'O',
// ms is special .... !
'ms'];
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getDuration(node, name) {
  var style = window.getComputedStyle(node);

  var ret = '';
  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);
    if (ret) {
      break;
    }
  }
  return ret;
}

function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;
    var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;
    var time = Math.max(transitionDuration, animationDuration);
    // sometimes, browser bug
    node.rcEndAnimTimeout = setTimeout(function () {
      node.rcEndAnimTimeout = null;
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1000 + 200);
  }
}

function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}

var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
  var className = transitionName;
  var activeClassName = className + '-active';
  var end = endCallback;
  var start = void 0;
  var active = void 0;
  var nodeClasses = (0, _componentClasses2["default"])(node);

  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }

  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);

    nodeClasses.remove(className);
    nodeClasses.remove(activeClassName);

    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;

    // Usually this optional end is used for informing an owner of
    // a leave animation and telling it to remove the child.
    if (end) {
      end();
    }
  };

  _Event2["default"].addEndEventListener(node, node.rcEndListener);

  if (start) {
    start();
  }
  nodeClasses.add(className);

  node.rcAnimTimeout = setTimeout(function () {
    node.rcAnimTimeout = null;
    nodeClasses.add(activeClassName);
    if (active) {
      setTimeout(active, 0);
    }
    fixBrowserByTimeout(node);
    // 30ms for firefox
  }, 30);

  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};

cssAnimation.style = function (node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);

    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;

    // Usually this optional callback is used for informing an owner of
    // a leave animation and telling it to remove the child.
    if (callback) {
      callback();
    }
  };

  _Event2["default"].addEndEventListener(node, node.rcEndListener);

  node.rcAnimTimeout = setTimeout(function () {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }
    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};

cssAnimation.setTransition = function (node, p, value) {
  var property = p;
  var v = value;
  if (value === undefined) {
    v = property;
    property = '';
  }
  property = property || '';
  capitalPrefixes.forEach(function (prefix) {
    node.style[prefix + 'Transition' + property] = v;
  });
};

cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

exports["default"] = cssAnimation;
module.exports = exports['default'];
},{"./Event":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/lib/Event.js","component-classes":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/index.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

try {
  var index = require('indexof');
} catch (err) {
  var index = require('component-indexof');
}

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

},{"component-indexof":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/node_modules/component-indexof/index.js","indexof":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/node_modules/component-indexof/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-tooltip/node_modules/rc-trigger/node_modules/rc-animate/node_modules/css-animation/node_modules/component-classes/node_modules/component-indexof/index.js":[function(require,module,exports){
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/addEventListener.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListenerWrap;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _addDomEventListener = require('add-dom-event-listener');

var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function addEventListenerWrap(target, eventType, cb) {
  /* eslint camelcase: 2 */
  var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
    _reactDom2['default'].unstable_batchedUpdates(cb, e);
  } : cb;
  return (0, _addDomEventListener2['default'])(target, eventType, callback);
}

module.exports = exports['default'];
},{"add-dom-event-listener":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/index.js","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/Dom/contains.js":[function(require,module,exports){
"use strict";

module.exports = function contains(root, n) {
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }

  return false;
};
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/lib/createChainedFunction.js":[function(require,module,exports){
/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @returns {function|null}
 */
"use strict";

function createChainedFunction() {
  var args = arguments;
  return function chainedFunction() {
    for (var i = 0; i < args.length; i++) {
      if (args[i] && args[i].apply) {
        args[i].apply(this, arguments);
      }
    }
  };
}

module.exports = createChainedFunction;
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventBaseObject.js":[function(require,module,exports){
/**
 * @ignore
 * base event object for custom and dom event.
 * @author yiminghe@gmail.com
 */

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

function EventBaseObject() {
  this.timeStamp = Date.now();
  this.target = undefined;
  this.currentTarget = undefined;
}

EventBaseObject.prototype = {
  isEventObject: 1,

  constructor: EventBaseObject,

  isDefaultPrevented: returnFalse,

  isPropagationStopped: returnFalse,

  isImmediatePropagationStopped: returnFalse,

  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
  },

  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
  },

  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    // fixed 1.2
    // call stopPropagation implicitly
    this.stopPropagation();
  },

  halt: function halt(immediate) {
    if (immediate) {
      this.stopImmediatePropagation();
    } else {
      this.stopPropagation();
    }
    this.preventDefault();
  }
};

exports["default"] = EventBaseObject;
module.exports = exports["default"];
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventObject.js":[function(require,module,exports){
/**
 * @ignore
 * event object for dom
 * @author yiminghe@gmail.com
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _EventBaseObject = require('./EventBaseObject');

var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var TRUE = true;
var FALSE = false;
var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

function isNullOrUndefined(w) {
  return w === null || w === undefined;
}

var eventNormalizers = [{
  reg: /^key/,
  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
  fix: function fix(event, nativeEvent) {
    if (isNullOrUndefined(event.which)) {
      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
    }

    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
    if (event.metaKey === undefined) {
      event.metaKey = event.ctrlKey;
    }
  }
}, {
  reg: /^touch/,
  props: ['touches', 'changedTouches', 'targetTouches']
}, {
  reg: /^hashchange$/,
  props: ['newURL', 'oldURL']
}, {
  reg: /^gesturechange$/i,
  props: ['rotation', 'scale']
}, {
  reg: /^(mousewheel|DOMMouseScroll)$/,
  props: [],
  fix: function fix(event, nativeEvent) {
    var deltaX = undefined;
    var deltaY = undefined;
    var delta = undefined;
    var wheelDelta = nativeEvent.wheelDelta;
    var axis = nativeEvent.axis;
    var wheelDeltaY = nativeEvent.wheelDeltaY;
    var wheelDeltaX = nativeEvent.wheelDeltaX;
    var detail = nativeEvent.detail;

    // ie/webkit
    if (wheelDelta) {
      delta = wheelDelta / 120;
    }

    // gecko
    if (detail) {
      // press control e.detail == 1 else e.detail == 3
      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
    }

    // Gecko
    if (axis !== undefined) {
      if (axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = 0 - delta;
      } else if (axis === event.VERTICAL_AXIS) {
        deltaX = 0;
        deltaY = delta;
      }
    }

    // Webkit
    if (wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120;
    }
    if (wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120;
    }

    // 默认 deltaY (ie)
    if (!deltaX && !deltaY) {
      deltaY = delta;
    }

    if (deltaX !== undefined) {
      /**
       * deltaX of mousewheel event
       * @property deltaX
       * @member Event.DomEvent.Object
       */
      event.deltaX = deltaX;
    }

    if (deltaY !== undefined) {
      /**
       * deltaY of mousewheel event
       * @property deltaY
       * @member Event.DomEvent.Object
       */
      event.deltaY = deltaY;
    }

    if (delta !== undefined) {
      /**
       * delta of mousewheel event
       * @property delta
       * @member Event.DomEvent.Object
       */
      event.delta = delta;
    }
  }
}, {
  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
  fix: function fix(event, nativeEvent) {
    var eventDoc = undefined;
    var doc = undefined;
    var body = undefined;
    var target = event.target;
    var button = nativeEvent.button;

    // Calculate pageX/Y if missing and clientX/Y available
    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
      eventDoc = target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // which for click: 1 === left; 2 === middle; 3 === right
    // do not use button
    if (!event.which && button !== undefined) {
      if (button & 1) {
        event.which = 1;
      } else if (button & 2) {
        event.which = 3;
      } else if (button & 4) {
        event.which = 2;
      } else {
        event.which = 0;
      }
    }

    // add relatedTarget, if necessary
    if (!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
    }

    return event;
  }
}];

function retTrue() {
  return TRUE;
}

function retFalse() {
  return FALSE;
}

function DomEventObject(nativeEvent) {
  var type = nativeEvent.type;

  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

  _EventBaseObject2['default'].call(this);

  this.nativeEvent = nativeEvent;

  // in case dom event has been mark as default prevented by lower dom node
  var isDefaultPrevented = retFalse;
  if ('defaultPrevented' in nativeEvent) {
    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
  } else if ('getPreventDefault' in nativeEvent) {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
  } else if ('returnValue' in nativeEvent) {
    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
  }

  this.isDefaultPrevented = isDefaultPrevented;

  var fixFns = [];
  var fixFn = undefined;
  var l = undefined;
  var prop = undefined;
  var props = commonProps.concat();

  eventNormalizers.forEach(function (normalizer) {
    if (type.match(normalizer.reg)) {
      props = props.concat(normalizer.props);
      if (normalizer.fix) {
        fixFns.push(normalizer.fix);
      }
    }
  });

  l = props.length;

  // clone properties of the original event object
  while (l) {
    prop = props[--l];
    this[prop] = nativeEvent[prop];
  }

  // fix target property, if necessary
  if (!this.target && isNative) {
    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
  }

  // check if target is a text node (safari)
  if (this.target && this.target.nodeType === 3) {
    this.target = this.target.parentNode;
  }

  l = fixFns.length;

  while (l) {
    fixFn = fixFns[--l];
    fixFn(this, nativeEvent);
  }

  this.timeStamp = nativeEvent.timeStamp || Date.now();
}

var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
  constructor: DomEventObject,

  preventDefault: function preventDefault() {
    var e = this.nativeEvent;

    // if preventDefault exists run it on the original event
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      // otherwise set the returnValue property of the original event to FALSE (IE)
      e.returnValue = FALSE;
    }

    EventBaseObjectProto.preventDefault.call(this);
  },

  stopPropagation: function stopPropagation() {
    var e = this.nativeEvent;

    // if stopPropagation exists run it on the original event
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      // otherwise set the cancelBubble property of the original event to TRUE (IE)
      e.cancelBubble = TRUE;
    }

    EventBaseObjectProto.stopPropagation.call(this);
  }
});

exports['default'] = DomEventObject;
module.exports = exports['default'];
},{"./EventBaseObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventBaseObject.js","object-assign":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/object-assign/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListener;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _EventObject = require('./EventObject');

var _EventObject2 = _interopRequireDefault(_EventObject);

function addEventListener(target, eventType, callback) {
  function wrapCallback(e) {
    var ne = new _EventObject2['default'](e);
    callback.call(target, ne);
  }

  if (target.addEventListener) {
    target.addEventListener(eventType, wrapCallback, false);
    return {
      remove: function remove() {
        target.removeEventListener(eventType, wrapCallback, false);
      }
    };
  } else if (target.attachEvent) {
    target.attachEvent('on' + eventType, wrapCallback);
    return {
      remove: function remove() {
        target.detachEvent('on' + eventType, wrapCallback);
      }
    };
  }
}

module.exports = exports['default'];
},{"./EventObject":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/rc-util/node_modules/add-dom-event-listener/lib/EventObject.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/node_modules/warning/browser.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/process/browser.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/BaseTileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

var BaseTileLayer = (function (_MapLayer) {
  _inherits(BaseTileLayer, _MapLayer);

  function BaseTileLayer() {
    _classCallCheck(this, BaseTileLayer);

    _get(Object.getPrototypeOf(BaseTileLayer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BaseTileLayer, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props;
      var opacity = _props.opacity;
      var zIndex = _props.zIndex;

      if (opacity && opacity !== prevProps.opacity) {
        this.leafletElement.setOpacity(opacity);
      }
      if (zIndex && zIndex !== prevProps.zIndex) {
        this.leafletElement.setZIndex(zIndex);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }], [{
    key: 'propTypes',
    value: {
      opacity: _react.PropTypes.number,
      zIndex: _react.PropTypes.number
    },
    enumerable: true
  }]);

  return BaseTileLayer;
})(_MapLayer3['default']);

exports['default'] = BaseTileLayer;
module.exports = exports['default'];
},{"./MapLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapLayer.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/CanvasTileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _leaflet = require('leaflet');

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

var CanvasTileLayer = (function (_BaseTileLayer) {
  _inherits(CanvasTileLayer, _BaseTileLayer);

  function CanvasTileLayer() {
    _classCallCheck(this, CanvasTileLayer);

    _get(Object.getPrototypeOf(CanvasTileLayer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CanvasTileLayer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(CanvasTileLayer.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;

      var props = _objectWithoutProperties(_props, ['map']);

      this.leafletElement = _leaflet.tileLayer.canvas(props);
    }
  }]);

  return CanvasTileLayer;
})(_BaseTileLayer3['default']);

exports['default'] = CanvasTileLayer;
module.exports = exports['default'];
},{"./BaseTileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/BaseTileLayer.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Circle.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesLatlng = require('./types/latlng');

var _typesLatlng2 = _interopRequireDefault(_typesLatlng);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var Circle = (function (_Path) {
  _inherits(Circle, _Path);

  function Circle() {
    _classCallCheck(this, Circle);

    _get(Object.getPrototypeOf(Circle.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Circle, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Circle.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var center = _props.center;
      var map = _props.map;
      var radius = _props.radius;

      var props = _objectWithoutProperties(_props, ['center', 'map', 'radius']);

      this.leafletElement = (0, _leaflet.circle)(center, radius, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.center !== prevProps.center) {
        this.leafletElement.setLatLng(this.props.center);
      }
      if (this.props.radius !== prevProps.radius) {
        this.leafletElement.setRadius(this.props.radius);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      center: _typesLatlng2['default'].isRequired,
      radius: _react.PropTypes.number.isRequired
    },
    enumerable: true
  }]);

  return Circle;
})(_Path3['default']);

exports['default'] = Circle;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/CircleMarker.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesLatlng = require('./types/latlng');

var _typesLatlng2 = _interopRequireDefault(_typesLatlng);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var CircleMarker = (function (_Path) {
  _inherits(CircleMarker, _Path);

  function CircleMarker() {
    _classCallCheck(this, CircleMarker);

    _get(Object.getPrototypeOf(CircleMarker.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CircleMarker, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(CircleMarker.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var center = _props.center;
      var map = _props.map;

      var props = _objectWithoutProperties(_props, ['center', 'map']);

      this.leafletElement = (0, _leaflet.circleMarker)(center, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.center !== prevProps.center) {
        this.leafletElement.setLatLng(this.props.center);
      }
      if (this.props.radius !== prevProps.radius) {
        this.leafletElement.setRadius(this.props.radius);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      center: _typesLatlng2['default'].isRequired,
      radius: _react.PropTypes.number
    },
    enumerable: true
  }]);

  return CircleMarker;
})(_Path3['default']);

exports['default'] = CircleMarker;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/FeatureGroup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var FeatureGroup = (function (_Path) {
  _inherits(FeatureGroup, _Path);

  function FeatureGroup() {
    _classCallCheck(this, FeatureGroup);

    _get(Object.getPrototypeOf(FeatureGroup.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(FeatureGroup, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _props = this.props;
      var layers = _props.layers;
      var map = _props.map;

      var props = _objectWithoutProperties(_props, ['layers', 'map']);

      this.leafletElement = (0, _leaflet.featureGroup)(layers);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      layers: _react.PropTypes.array.isRequired
    },
    enumerable: true
  }]);

  return FeatureGroup;
})(_Path3['default']);

exports['default'] = FeatureGroup;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/GeoJson.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var GeoJson = (function (_Path) {
  _inherits(GeoJson, _Path);

  function GeoJson() {
    _classCallCheck(this, GeoJson);

    _get(Object.getPrototypeOf(GeoJson.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(GeoJson, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(GeoJson.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var data = _props.data;
      var map = _props.map;

      var props = _objectWithoutProperties(_props, ['data', 'map']);

      this.leafletElement = (0, _leaflet.geoJson)(data, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      data: _react.PropTypes.object.isRequired
    },
    enumerable: true
  }]);

  return GeoJson;
})(_Path3['default']);

exports['default'] = GeoJson;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/ImageOverlay.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesBounds = require('./types/bounds');

var _typesBounds2 = _interopRequireDefault(_typesBounds);

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

var ImageOverlay = (function (_MapLayer) {
  _inherits(ImageOverlay, _MapLayer);

  function ImageOverlay() {
    _classCallCheck(this, ImageOverlay);

    _get(Object.getPrototypeOf(ImageOverlay.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ImageOverlay, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(ImageOverlay.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var bounds = _props.bounds;
      var map = _props.map;
      var url = _props.url;

      var props = _objectWithoutProperties(_props, ['bounds', 'map', 'url']);

      this.leafletElement = (0, _leaflet.imageOverlay)(url, bounds, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.url !== prevProps.url) {
        this.leafletElement.setUrl(this.props.url);
      }
      if (this.props.opacity !== prevProps.opacity) {
        this.leafletElement.setOpacity(this.props.opacity);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }], [{
    key: 'propTypes',
    value: {
      attribution: _react.PropTypes.string,
      bounds: _typesBounds2['default'].isRequired,
      map: _react.PropTypes.instanceOf(_leaflet.Map),
      opacity: _react.PropTypes.number,
      url: _react.PropTypes.string.isRequired
    },
    enumerable: true
  }]);

  return ImageOverlay;
})(_MapLayer3['default']);

exports['default'] = ImageOverlay;
module.exports = exports['default'];
},{"./MapLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapLayer.js","./types/bounds":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/bounds.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/LayerGroup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _leaflet = require('leaflet');

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

var LayerGroup = (function (_MapLayer) {
  _inherits(LayerGroup, _MapLayer);

  function LayerGroup() {
    _classCallCheck(this, LayerGroup);

    _get(Object.getPrototypeOf(LayerGroup.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(LayerGroup, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(LayerGroup.prototype), 'componentWillMount', this).call(this);
      this.leafletElement = (0, _leaflet.layerGroup)();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this = this;

      var children = _react2['default'].Children.map(this.props.children, function (child) {
        return child ? _react2['default'].cloneElement(child, {
          layerGroup: _this.leafletElement,
          map: _this.props.map
        }) : null;
      });

      return _react2['default'].createElement(
        'div',
        { style: { display: 'none' } },
        children
      );
    }
  }], [{
    key: 'propTypes',
    value: {
      children: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.node), _react.PropTypes.node]),
      map: _react.PropTypes.instanceOf(_leaflet.Map)
    },
    enumerable: true
  }]);

  return LayerGroup;
})(_MapLayer3['default']);

exports['default'] = LayerGroup;
module.exports = exports['default'];
},{"./MapLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapLayer.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Map.js":[function(require,module,exports){
/* eslint-disable react/no-did-mount-set-state */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodashLangIsArray = require('lodash/lang/isArray');

var _lodashLangIsArray2 = _interopRequireDefault(_lodashLangIsArray);

var _lodashLangIsUndefined = require('lodash/lang/isUndefined');

var _lodashLangIsUndefined2 = _interopRequireDefault(_lodashLangIsUndefined);

var _lodashUtilityUniqueId = require('lodash/utility/uniqueId');

var _lodashUtilityUniqueId2 = _interopRequireDefault(_lodashUtilityUniqueId);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

var _typesBounds = require('./types/bounds');

var _typesBounds2 = _interopRequireDefault(_typesBounds);

var _typesLatlng = require('./types/latlng');

var _typesLatlng2 = _interopRequireDefault(_typesLatlng);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

var normalizeCenter = function normalizeCenter(pos) {
  return (0, _lodashLangIsArray2['default'])(pos) ? pos : [pos.lat, pos.lng || pos.lon];
};

var Map = (function (_MapComponent) {
  _inherits(Map, _MapComponent);

  _createClass(Map, null, [{
    key: 'propTypes',
    value: {
      bounds: _typesBounds2['default'],
      center: _typesLatlng2['default'],
      children: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.node), _react.PropTypes.node]),
      className: _react.PropTypes.string,
      id: _react.PropTypes.string,
      maxBounds: _typesBounds2['default'],
      maxZoom: _react.PropTypes.number,
      minZoom: _react.PropTypes.number,
      style: _react.PropTypes.object,
      zoom: _react.PropTypes.number
    },
    enumerable: true
  }]);

  function Map(props) {
    _classCallCheck(this, Map);

    _get(Object.getPrototypeOf(Map.prototype), 'constructor', this).call(this, props);
    this.state = {
      id: props.id || (0, _lodashUtilityUniqueId2['default'])('map')
    };
  }

  _createClass(Map, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.leafletElement = _leaflet2['default'].map(this.state.id, this.props);
      _get(Object.getPrototypeOf(Map.prototype), 'componentDidMount', this).call(this);
      this.setState({ map: this.leafletElement });
      if (!(0, _lodashLangIsUndefined2['default'])(this.props.bounds)) {
        this.leafletElement.fitBounds(this.props.bounds);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props;
      var bounds = _props.bounds;
      var center = _props.center;
      var maxBounds = _props.maxBounds;
      var zoom = _props.zoom;

      if (center && this.shouldUpdateCenter(center, prevProps.center)) {
        this.leafletElement.setView(center, zoom, { animate: false });
      } else if (zoom && zoom !== prevProps.zoom) {
        this.leafletElement.setZoom(zoom);
      }
      if (maxBounds && this.shouldUpdateBounds(maxBounds, prevProps.maxBounds)) {
        this.leafletElement.setMaxBounds(maxBounds);
      }
      if (bounds && this.shouldUpdateBounds(bounds, prevProps.bounds)) {
        this.leafletElement.fitBounds(bounds);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(Object.getPrototypeOf(Map.prototype), 'componentWillUnmount', this).call(this);
      this.leafletElement.remove();
    }
  }, {
    key: 'shouldUpdateCenter',
    value: function shouldUpdateCenter(next, prev) {
      if (!prev) return true;
      next = normalizeCenter(next);
      prev = normalizeCenter(prev);
      return next[0] !== prev[0] || next[1] !== prev[1];
    }
  }, {
    key: 'shouldUpdateBounds',
    value: function shouldUpdateBounds(next, prev) {
      if (!prev) return true;
      next = _leaflet2['default'].latLngBounds(next);
      prev = _leaflet2['default'].latLngBounds(prev);
      return !next.equals(prev);
    }
  }, {
    key: 'render',
    value: function render() {
      var map = this.leafletElement;
      var children = map ? _react2['default'].Children.map(this.props.children, function (child) {
        return child ? _react2['default'].cloneElement(child, { map: map }) : null;
      }) : null;

      return _react2['default'].createElement(
        'div',
        {
          className: this.props.className,
          id: this.state.id,
          style: this.props.style },
        children
      );
    }
  }]);

  return Map;
})(_MapComponent3['default']);

exports['default'] = Map;
module.exports = exports['default'];
},{"./MapComponent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapComponent.js","./types/bounds":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/bounds.js","./types/latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","lodash/lang/isArray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isArray.js","lodash/lang/isUndefined":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isUndefined.js","lodash/utility/uniqueId":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/utility/uniqueId.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapComponent.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodashLangClone = require('lodash/lang/clone');

var _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);

var _lodashCollectionForEach = require('lodash/collection/forEach');

var _lodashCollectionForEach2 = _interopRequireDefault(_lodashCollectionForEach);

var _lodashCollectionReduce = require('lodash/collection/reduce');

var _lodashCollectionReduce2 = _interopRequireDefault(_lodashCollectionReduce);

var _lodashObjectKeys = require('lodash/object/keys');

var _lodashObjectKeys2 = _interopRequireDefault(_lodashObjectKeys);

var _react = require('react');

var EVENTS_RE = /on(?:Leaflet)?(.+)/i;

var MapComponent = (function (_Component) {
  _inherits(MapComponent, _Component);

  function MapComponent() {
    _classCallCheck(this, MapComponent);

    _get(Object.getPrototypeOf(MapComponent.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(MapComponent, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this._leafletEvents = this.extractLeafletEvents(this.props);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.bindLeafletEvents(this._leafletEvents);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var next = this.extractLeafletEvents(nextProps);
      this._leafletEvents = this.bindLeafletEvents(next, this._leafletEvents);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var el = this.leafletElement;
      if (!el) return;

      (0, _lodashCollectionForEach2['default'])(this._leafletEvents, function (cb, ev) {
        el.off(ev, cb);
      });
    }
  }, {
    key: 'getLeafletElement',
    value: function getLeafletElement() {
      return this.leafletElement;
    }
  }, {
    key: 'extractLeafletEvents',
    value: function extractLeafletEvents(props) {
      return (0, _lodashCollectionReduce2['default'])((0, _lodashObjectKeys2['default'])(props), function (res, ev) {
        if (EVENTS_RE.test(ev)) {
          var key = ev.replace(EVENTS_RE, function (match, p) {
            return p.toLowerCase();
          });
          res[key] = props[ev];
        }
        return res;
      }, {});
    }
  }, {
    key: 'bindLeafletEvents',
    value: function bindLeafletEvents() {
      var next = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var prev = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var el = this.leafletElement;
      if (!el) return;

      var diff = (0, _lodashLangClone2['default'])(prev);
      (0, _lodashCollectionForEach2['default'])(prev, function (cb, ev) {
        if (!next[ev] || cb !== next[ev]) {
          delete diff[ev];
          el.off(ev, cb);
        }
      });

      (0, _lodashCollectionForEach2['default'])(next, function (cb, ev) {
        if (!prev[ev] || cb !== prev[ev]) {
          diff[ev] = cb;
          el.on(ev, cb);
        }
      });

      return diff;
    }
  }, {
    key: 'fireLeafletEvent',
    value: function fireLeafletEvent(type, data) {
      var el = this.leafletElement;
      if (el) el.fire(type, data);
    }
  }]);

  return MapComponent;
})(_react.Component);

exports['default'] = MapComponent;
module.exports = exports['default'];
},{"lodash/collection/forEach":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/collection/forEach.js","lodash/collection/reduce":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/collection/reduce.js","lodash/lang/clone":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/clone.js","lodash/object/keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/keys.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodashObjectAssign = require('lodash/object/assign');

var _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

var MapLayer = (function (_MapComponent) {
  _inherits(MapLayer, _MapComponent);

  function MapLayer() {
    _classCallCheck(this, MapLayer);

    _get(Object.getPrototypeOf(MapLayer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(MapLayer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(Object.getPrototypeOf(MapLayer.prototype), 'componentDidMount', this).call(this);
      (this.props.layerGroup || this.props.map).addLayer(this.leafletElement);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(Object.getPrototypeOf(MapLayer.prototype), 'componentWillUnmount', this).call(this);
      (this.props.layerGroup || this.props.map).removeLayer(this.leafletElement);
    }
  }, {
    key: 'getClonedChildrenWithMap',
    value: function getClonedChildrenWithMap(extra) {
      var _props = this.props;
      var children = _props.children;
      var map = _props.map;

      var props = (0, _lodashObjectAssign2['default'])({ map: map }, extra);

      return _react2['default'].Children.map(children, function (child) {
        return child ? _react2['default'].cloneElement(child, props) : null;
      });
    }
  }]);

  return MapLayer;
})(_MapComponent3['default']);

exports['default'] = MapLayer;
module.exports = exports['default'];
},{"./MapComponent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapComponent.js","lodash/object/assign":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/assign.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Marker.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesLatlng = require('./types/latlng');

var _typesLatlng2 = _interopRequireDefault(_typesLatlng);

var _PopupContainer2 = require('./PopupContainer');

var _PopupContainer3 = _interopRequireDefault(_PopupContainer2);

var Marker = (function (_PopupContainer) {
  _inherits(Marker, _PopupContainer);

  function Marker() {
    _classCallCheck(this, Marker);

    _get(Object.getPrototypeOf(Marker.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Marker, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Marker.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var position = _props.position;

      var props = _objectWithoutProperties(_props, ['map', 'position']);

      this.leafletElement = (0, _leaflet.marker)(position, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.position !== prevProps.position) {
        this.leafletElement.setLatLng(this.props.position);
      }
      if (this.props.icon !== prevProps.icon) {
        this.leafletElement.setIcon(this.props.icon);
      }
      if (this.props.zIndexOffset !== prevProps.zIndexOffset) {
        this.leafletElement.setZIndexOffset(this.props.zIndexOffset);
      }
      if (this.props.opacity !== prevProps.opacity) {
        this.leafletElement.setOpacity(this.props.opacity);
      }
    }
  }], [{
    key: 'propTypes',
    value: {
      icon: _react.PropTypes.instanceOf(_leaflet.Icon),
      opacity: _react.PropTypes.number,
      position: _typesLatlng2['default'].isRequired,
      zIndexOffset: _react.PropTypes.number
    },
    enumerable: true
  }]);

  return Marker;
})(_PopupContainer3['default']);

exports['default'] = Marker;
module.exports = exports['default'];
},{"./PopupContainer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/PopupContainer.js","./types/latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MultiPolygon.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesLatlngList = require('./types/latlngList');

var _typesLatlngList2 = _interopRequireDefault(_typesLatlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var MultiPolygon = (function (_Path) {
  _inherits(MultiPolygon, _Path);

  function MultiPolygon() {
    _classCallCheck(this, MultiPolygon);

    _get(Object.getPrototypeOf(MultiPolygon.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(MultiPolygon, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(MultiPolygon.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var polygons = _props.polygons;

      var props = _objectWithoutProperties(_props, ['map', 'polygons']);

      this.leafletElement = (0, _leaflet.multiPolygon)(polygons, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.polygons !== prevProps.polygons) {
        this.leafletElement.setLatLngs(this.props.polygons);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      polygons: _react.PropTypes.arrayOf(_typesLatlngList2['default']).isRequired
    },
    enumerable: true
  }]);

  return MultiPolygon;
})(_Path3['default']);

exports['default'] = MultiPolygon;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MultiPolyline.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesLatlngList = require('./types/latlngList');

var _typesLatlngList2 = _interopRequireDefault(_typesLatlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var MultiPolyline = (function (_Path) {
  _inherits(MultiPolyline, _Path);

  function MultiPolyline() {
    _classCallCheck(this, MultiPolyline);

    _get(Object.getPrototypeOf(MultiPolyline.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(MultiPolyline, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(MultiPolyline.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var polylines = _props.polylines;

      var props = _objectWithoutProperties(_props, ['map', 'polylines']);

      this.leafletElement = (0, _leaflet.multiPolyline)(polylines, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.polylines !== prevProps.polylines) {
        this.leafletElement.setLatLngs(this.props.polylines);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      polylines: _react.PropTypes.arrayOf(_typesLatlngList2['default']).isRequired
    },
    enumerable: true
  }]);

  return MultiPolyline;
})(_Path3['default']);

exports['default'] = MultiPolyline;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodashLangIsEqual = require('lodash/lang/isEqual');

var _lodashLangIsEqual2 = _interopRequireDefault(_lodashLangIsEqual);

var _lodashObjectPick = require('lodash/object/pick');

var _lodashObjectPick2 = _interopRequireDefault(_lodashObjectPick);

var _PopupContainer2 = require('./PopupContainer');

var _PopupContainer3 = _interopRequireDefault(_PopupContainer2);

var OPTIONS = ['stroke', 'color', 'weight', 'opacity', 'fill', 'fillColor', 'fillOpacity', 'fillRule', 'dashArray', 'lineCap', 'lineJoin', 'clickable', 'pointerEvents', 'className'];

var Path = (function (_PopupContainer) {
  _inherits(Path, _PopupContainer);

  function Path() {
    _classCallCheck(this, Path);

    _get(Object.getPrototypeOf(Path.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Path, [{
    key: 'getPathOptions',
    value: function getPathOptions(props) {
      return (0, _lodashObjectPick2['default'])(props, OPTIONS);
    }
  }, {
    key: 'setStyle',
    value: function setStyle() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      this.leafletElement.setStyle(options);
    }
  }, {
    key: 'setStyleIfChanged',
    value: function setStyleIfChanged(fromProps, toProps) {
      var nextStyle = this.getPathOptions(toProps);
      if (!(0, _lodashLangIsEqual2['default'])(nextStyle, this.getPathOptions(fromProps))) {
        this.setStyle(nextStyle);
      }
    }
  }]);

  return Path;
})(_PopupContainer3['default']);

exports['default'] = Path;
module.exports = exports['default'];
},{"./PopupContainer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/PopupContainer.js","lodash/lang/isEqual":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/lang/isEqual.js","lodash/object/pick":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/lodash/object/pick.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Polygon.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _typesLatlngList = require('./types/latlngList');

var _typesLatlngList2 = _interopRequireDefault(_typesLatlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var Polygon = (function (_Path) {
  _inherits(Polygon, _Path);

  function Polygon() {
    _classCallCheck(this, Polygon);

    _get(Object.getPrototypeOf(Polygon.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Polygon, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Polygon.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var positions = _props.positions;

      var props = _objectWithoutProperties(_props, ['map', 'positions']);

      this.leafletElement = (0, _leaflet.polygon)(positions, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.positions !== prevProps.positions) {
        this.leafletElement.setLatLngs(this.props.positions);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      positions: _react.PropTypes.oneOfType([_typesLatlngList2['default'], _react.PropTypes.arrayOf(_typesLatlngList2['default'])]).isRequired
    },
    enumerable: true
  }]);

  return Polygon;
})(_Path3['default']);

exports['default'] = Polygon;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Polyline.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _leaflet = require('leaflet');

var _typesLatlngList = require('./types/latlngList');

var _typesLatlngList2 = _interopRequireDefault(_typesLatlngList);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var Polyline = (function (_Path) {
  _inherits(Polyline, _Path);

  function Polyline() {
    _classCallCheck(this, Polyline);

    _get(Object.getPrototypeOf(Polyline.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Polyline, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Polyline.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var positions = _props.positions;

      var props = _objectWithoutProperties(_props, ['map', 'positions']);

      this.leafletElement = (0, _leaflet.polyline)(positions, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.positions !== prevProps.positions) {
        this.leafletElement.setLatLngs(this.props.positions);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      positions: _typesLatlngList2['default'].isRequired
    },
    enumerable: true
  }]);

  return Polyline;
})(_Path3['default']);

exports['default'] = Polyline;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/latlngList":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Popup.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _reactDom = require('react-dom');

var _leaflet = require('leaflet');

var _typesLatlng = require('./types/latlng');

var _typesLatlng2 = _interopRequireDefault(_typesLatlng);

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

var Popup = (function (_MapComponent) {
  _inherits(Popup, _MapComponent);

  function Popup() {
    _classCallCheck(this, Popup);

    _get(Object.getPrototypeOf(Popup.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Popup, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Popup.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var children = _props.children;
      var map = _props.map;

      var props = _objectWithoutProperties(_props, ['children', 'map']);

      this.leafletElement = (0, _leaflet.popup)(props);
      this.leafletElement.on('open', this.renderPopupContent.bind(this));
      this.leafletElement.on('close', this.removePopupContent.bind(this));
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _props2 = this.props;
      var map = _props2.map;
      var popupContainer = _props2.popupContainer;
      var position = _props2.position;

      var el = this.leafletElement;

      if (popupContainer) {
        // Attach to container component
        popupContainer.bindPopup(el);
      } else {
        // Attach to a Map
        if (position) {
          el.setLatLng(position);
        }
        el.openOn(map);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var position = this.props.position;

      if (position !== prevProps.position) {
        this.leafletElement.setLatLng(position);
      }

      if (this.leafletElement._isOpen) {
        this.renderPopupContent();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(Object.getPrototypeOf(Popup.prototype), 'componentWillUnmount', this).call(this);
      this.removePopupContent();
      this.props.map.removeLayer(this.leafletElement);
    }
  }, {
    key: 'renderPopupContent',
    value: function renderPopupContent() {
      if (this.props.children) {
        (0, _reactDom.render)(_react.Children.only(this.props.children), this.leafletElement._contentNode);

        this.leafletElement._updateLayout();
        this.leafletElement._updatePosition();
        this.leafletElement._adjustPan();
      } else {
        this.removePopupContent();
      }
    }
  }, {
    key: 'removePopupContent',
    value: function removePopupContent() {
      if (this.leafletElement._contentNode) {
        (0, _reactDom.unmountComponentAtNode)(this.leafletElement._contentNode);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }], [{
    key: 'propTypes',
    value: {
      children: _react.PropTypes.node,
      map: _react.PropTypes.instanceOf(_leaflet.Map),
      popupContainer: _react.PropTypes.object,
      position: _typesLatlng2['default']
    },
    enumerable: true
  }]);

  return Popup;
})(_MapComponent3['default']);

exports['default'] = Popup;
module.exports = exports['default'];
},{"./MapComponent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapComponent.js","./types/latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/PopupContainer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

var PopupContainer = (function (_MapLayer) {
  _inherits(PopupContainer, _MapLayer);

  function PopupContainer() {
    _classCallCheck(this, PopupContainer);

    _get(Object.getPrototypeOf(PopupContainer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(PopupContainer, [{
    key: 'render',
    value: function render() {
      var children = this.getClonedChildrenWithMap({
        popupContainer: this.leafletElement
      });
      return _react2['default'].createElement(
        'div',
        { style: { display: 'none' } },
        children
      );
    }
  }]);

  return PopupContainer;
})(_MapLayer3['default']);

exports['default'] = PopupContainer;
module.exports = exports['default'];
},{"./MapLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapLayer.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Rectangle.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _leaflet = require('leaflet');

var _typesBounds = require('./types/bounds');

var _typesBounds2 = _interopRequireDefault(_typesBounds);

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

var Rectangle = (function (_Path) {
  _inherits(Rectangle, _Path);

  function Rectangle() {
    _classCallCheck(this, Rectangle);

    _get(Object.getPrototypeOf(Rectangle.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Rectangle, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(Rectangle.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var bounds = _props.bounds;
      var map = _props.map;

      var props = _objectWithoutProperties(_props, ['bounds', 'map']);

      this.leafletElement = (0, _leaflet.rectangle)(bounds, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.bounds !== prevProps.bounds) {
        this.leafletElement.setBounds(this.props.bounds);
      }
      this.setStyleIfChanged(prevProps, this.props);
    }
  }], [{
    key: 'propTypes',
    value: {
      bounds: _typesBounds2['default'].isRequired
    },
    enumerable: true
  }]);

  return Rectangle;
})(_Path3['default']);

exports['default'] = Rectangle;
module.exports = exports['default'];
},{"./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./types/bounds":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/bounds.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/TileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

var TileLayer = (function (_BaseTileLayer) {
  _inherits(TileLayer, _BaseTileLayer);

  function TileLayer() {
    _classCallCheck(this, TileLayer);

    _get(Object.getPrototypeOf(TileLayer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TileLayer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(TileLayer.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var url = _props.url;

      var props = _objectWithoutProperties(_props, ['map', 'url']);

      this.leafletElement = (0, _leaflet.tileLayer)(url, props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var url = this.props.url;

      if (url && url !== prevProps.url) {
        this.leafletElement.setUrl(url);
      }
    }
  }], [{
    key: 'propTypes',
    value: {
      url: _react.PropTypes.string.isRequired
    },
    enumerable: true
  }]);

  return TileLayer;
})(_BaseTileLayer3['default']);

exports['default'] = TileLayer;
module.exports = exports['default'];
},{"./BaseTileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/BaseTileLayer.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/WMSTileLayer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _leaflet = require('leaflet');

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

var WMSTileLayer = (function (_BaseTileLayer) {
  _inherits(WMSTileLayer, _BaseTileLayer);

  function WMSTileLayer() {
    _classCallCheck(this, WMSTileLayer);

    _get(Object.getPrototypeOf(WMSTileLayer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(WMSTileLayer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      _get(Object.getPrototypeOf(WMSTileLayer.prototype), 'componentWillMount', this).call(this);
      var _props = this.props;
      var map = _props.map;
      var url = _props.url;

      var props = _objectWithoutProperties(_props, ['map', 'url']);

      this.leafletElement = _leaflet.tileLayer.wms(url, props);
    }
  }], [{
    key: 'propTypes',
    value: {
      url: _react.PropTypes.string.isRequired
    },
    enumerable: true
  }]);

  return WMSTileLayer;
})(_BaseTileLayer3['default']);

exports['default'] = WMSTileLayer;
module.exports = exports['default'];
},{"./BaseTileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/BaseTileLayer.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

var _types = require('./types');

var _PropTypes = _interopRequireWildcard(_types);

exports.PropTypes = _PropTypes;

var _BaseTileLayer2 = require('./BaseTileLayer');

var _BaseTileLayer3 = _interopRequireDefault(_BaseTileLayer2);

exports.BaseTileLayer = _BaseTileLayer3['default'];

var _CanvasTileLayer2 = require('./CanvasTileLayer');

var _CanvasTileLayer3 = _interopRequireDefault(_CanvasTileLayer2);

exports.CanvasTileLayer = _CanvasTileLayer3['default'];

var _Circle2 = require('./Circle');

var _Circle3 = _interopRequireDefault(_Circle2);

exports.Circle = _Circle3['default'];

var _CircleMarker2 = require('./CircleMarker');

var _CircleMarker3 = _interopRequireDefault(_CircleMarker2);

exports.CircleMarker = _CircleMarker3['default'];

var _FeatureGroup2 = require('./FeatureGroup');

var _FeatureGroup3 = _interopRequireDefault(_FeatureGroup2);

exports.FeatureGroup = _FeatureGroup3['default'];

var _GeoJson2 = require('./GeoJson');

var _GeoJson3 = _interopRequireDefault(_GeoJson2);

exports.GeoJson = _GeoJson3['default'];

var _ImageOverlay2 = require('./ImageOverlay');

var _ImageOverlay3 = _interopRequireDefault(_ImageOverlay2);

exports.ImageOverlay = _ImageOverlay3['default'];

var _LayerGroup2 = require('./LayerGroup');

var _LayerGroup3 = _interopRequireDefault(_LayerGroup2);

exports.LayerGroup = _LayerGroup3['default'];

var _Map2 = require('./Map');

var _Map3 = _interopRequireDefault(_Map2);

exports.Map = _Map3['default'];

var _MapComponent2 = require('./MapComponent');

var _MapComponent3 = _interopRequireDefault(_MapComponent2);

exports.MapComponent = _MapComponent3['default'];

var _MapLayer2 = require('./MapLayer');

var _MapLayer3 = _interopRequireDefault(_MapLayer2);

exports.MapLayer = _MapLayer3['default'];

var _Marker2 = require('./Marker');

var _Marker3 = _interopRequireDefault(_Marker2);

exports.Marker = _Marker3['default'];

var _MultiPolygon2 = require('./MultiPolygon');

var _MultiPolygon3 = _interopRequireDefault(_MultiPolygon2);

exports.MultiPolygon = _MultiPolygon3['default'];

var _MultiPolyline2 = require('./MultiPolyline');

var _MultiPolyline3 = _interopRequireDefault(_MultiPolyline2);

exports.MultiPolyline = _MultiPolyline3['default'];

var _Path2 = require('./Path');

var _Path3 = _interopRequireDefault(_Path2);

exports.Path = _Path3['default'];

var _Polygon2 = require('./Polygon');

var _Polygon3 = _interopRequireDefault(_Polygon2);

exports.Polygon = _Polygon3['default'];

var _Polyline2 = require('./Polyline');

var _Polyline3 = _interopRequireDefault(_Polyline2);

exports.Polyline = _Polyline3['default'];

var _Popup2 = require('./Popup');

var _Popup3 = _interopRequireDefault(_Popup2);

exports.Popup = _Popup3['default'];

var _PopupContainer2 = require('./PopupContainer');

var _PopupContainer3 = _interopRequireDefault(_PopupContainer2);

exports.PopupContainer = _PopupContainer3['default'];

var _Rectangle2 = require('./Rectangle');

var _Rectangle3 = _interopRequireDefault(_Rectangle2);

exports.Rectangle = _Rectangle3['default'];

var _TileLayer2 = require('./TileLayer');

var _TileLayer3 = _interopRequireDefault(_TileLayer2);

exports.TileLayer = _TileLayer3['default'];

var _WMSTileLayer2 = require('./WMSTileLayer');

var _WMSTileLayer3 = _interopRequireDefault(_WMSTileLayer2);

exports.WMSTileLayer = _WMSTileLayer3['default'];
var setIconDefaultImagePath = function setIconDefaultImagePath(path) {
  _leaflet2['default'].Icon.Default.imagePath = path;
};

exports.setIconDefaultImagePath = setIconDefaultImagePath;
setIconDefaultImagePath('//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/images');
},{"./BaseTileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/BaseTileLayer.js","./CanvasTileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/CanvasTileLayer.js","./Circle":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Circle.js","./CircleMarker":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/CircleMarker.js","./FeatureGroup":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/FeatureGroup.js","./GeoJson":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/GeoJson.js","./ImageOverlay":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/ImageOverlay.js","./LayerGroup":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/LayerGroup.js","./Map":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Map.js","./MapComponent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapComponent.js","./MapLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MapLayer.js","./Marker":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Marker.js","./MultiPolygon":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MultiPolygon.js","./MultiPolyline":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/MultiPolyline.js","./Path":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Path.js","./Polygon":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Polygon.js","./Polyline":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Polyline.js","./Popup":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Popup.js","./PopupContainer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/PopupContainer.js","./Rectangle":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/Rectangle.js","./TileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/TileLayer.js","./WMSTileLayer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/WMSTileLayer.js","./types":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/index.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/bounds.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

var _latlngList = require('./latlngList');

var _latlngList2 = _interopRequireDefault(_latlngList);

exports['default'] = _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.instanceOf(_leaflet2['default'].LatLngBounds), _latlngList2['default']]);
module.exports = exports['default'];
},{"./latlngList":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _bounds2 = require('./bounds');

var _bounds3 = _interopRequireDefault(_bounds2);

exports.bounds = _bounds3['default'];

var _latlng2 = require('./latlng');

var _latlng3 = _interopRequireDefault(_latlng2);

exports.latlng = _latlng3['default'];

var _latlngList2 = require('./latlngList');

var _latlngList3 = _interopRequireDefault(_latlngList2);

exports.latlngList = _latlngList3['default'];
},{"./bounds":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/bounds.js","./latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","./latlngList":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _react = require('react');

exports['default'] = _react.PropTypes.oneOfType([
// [Number, Number]
_react.PropTypes.arrayOf(_react.PropTypes.number),
// {lat: Number, lng: Number}
_react.PropTypes.shape({
  lat: _react.PropTypes.number,
  lng: _react.PropTypes.number
}),
// {lat: Number, lon: Number}
_react.PropTypes.shape({
  lat: _react.PropTypes.number,
  lon: _react.PropTypes.number
})]);
module.exports = exports['default'];
},{"react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlngList.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _latlng = require('./latlng');

var _latlng2 = _interopRequireDefault(_latlng);

exports['default'] = _react.PropTypes.arrayOf(_latlng2['default']);
module.exports = exports['default'];
},{"./latlng":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/types/latlng.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/components/Modal.js":[function(require,module,exports){
(function (process){
var React = require('react');
var ReactDOM = require('react-dom');
var ExecutionEnvironment = require('exenv');
var ModalPortal = React.createFactory(require('./ModalPortal'));
var ariaAppHider = require('../helpers/ariaAppHider');
var elementClass = require('element-class');
var renderSubtreeIntoContainer = require("react-dom").unstable_renderSubtreeIntoContainer;

var SafeHTMLElement = ExecutionEnvironment.canUseDOM ? window.HTMLElement : {};

var Modal = module.exports = React.createClass({

  displayName: 'Modal',
  statics: {
    setAppElement: ariaAppHider.setElement,
    injectCSS: function() {
      "production" !== process.env.NODE_ENV
        && console.warn('React-Modal: injectCSS has been deprecated ' +
                        'and no longer has any effect. It will be removed in a later version');
    }
  },

  propTypes: {
    isOpen: React.PropTypes.bool.isRequired,
    style: React.PropTypes.shape({
      content: React.PropTypes.object,
      overlay: React.PropTypes.object
    }),
    appElement: React.PropTypes.instanceOf(SafeHTMLElement),
    onRequestClose: React.PropTypes.func,
    closeTimeoutMS: React.PropTypes.number,
    ariaHideApp: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      isOpen: false,
      ariaHideApp: true,
      closeTimeoutMS: 0
    };
  },

  componentDidMount: function() {
    this.node = document.createElement('div');
    this.node.className = 'ReactModalPortal';
    document.body.appendChild(this.node);
    this.renderPortal(this.props);
  },

  componentWillReceiveProps: function(newProps) {
    this.renderPortal(newProps);
  },

  componentWillUnmount: function() {
    ReactDOM.unmountComponentAtNode(this.node);
    document.body.removeChild(this.node);
  },

  renderPortal: function(props) {
    if (props.isOpen) {
      elementClass(document.body).add('ReactModal__Body--open');
    } else {
      elementClass(document.body).remove('ReactModal__Body--open');
    }

    if (props.ariaHideApp) {
      ariaAppHider.toggle(props.isOpen, props.appElement);
    }
    sanitizeProps(props);
    this.portal = renderSubtreeIntoContainer(this, ModalPortal(props), this.node);
  },

  render: function () {
    return React.DOM.noscript();
  }
});

function sanitizeProps(props) {
  delete props.ref;
}

}).call(this,require('_process'))

},{"../helpers/ariaAppHider":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/ariaAppHider.js","./ModalPortal":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/components/ModalPortal.js","_process":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/process/browser.js","element-class":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/element-class/index.js","exenv":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/exenv/index.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/components/ModalPortal.js":[function(require,module,exports){
var React = require('react');
var div = React.DOM.div;
var focusManager = require('../helpers/focusManager');
var scopeTab = require('../helpers/scopeTab');
var Assign = require('lodash.assign');


// so that our CSS is statically analyzable
var CLASS_NAMES = {
  overlay: {
    base: 'ReactModal__Overlay',
    afterOpen: 'ReactModal__Overlay--after-open',
    beforeClose: 'ReactModal__Overlay--before-close'
  },
  content: {
    base: 'ReactModal__Content',
    afterOpen: 'ReactModal__Content--after-open',
    beforeClose: 'ReactModal__Content--before-close'
  }
};

var defaultStyles = {
  overlay: {
    position        : 'fixed',
    top             : 0,
    left            : 0,
    right           : 0,
    bottom          : 0,
    backgroundColor : 'rgba(255, 255, 255, 0.75)'
  },
  content: {
    position                : 'absolute',
    top                     : '40px',
    left                    : '40px',
    right                   : '40px',
    bottom                  : '40px',
    border                  : '1px solid #ccc',
    background              : '#fff',
    overflow                : 'auto',
    WebkitOverflowScrolling : 'touch',
    borderRadius            : '4px',
    outline                 : 'none',
    padding                 : '20px'
  }
};

function stopPropagation(event) {
  event.stopPropagation();
}

var ModalPortal = module.exports = React.createClass({

  displayName: 'ModalPortal',

  getDefaultProps: function() {
    return {
      style: {
        overlay: {},
        content: {}
      }
    };
  },

  getInitialState: function() {
    return {
      afterOpen: false,
      beforeClose: false
    };
  },

  componentDidMount: function() {
    // Focus needs to be set when mounting and already open
    if (this.props.isOpen) {
      this.setFocusAfterRender(true);
      this.open();
    }
  },

  componentWillUnmount: function() {
    clearTimeout(this.closeTimer);
  },

  componentWillReceiveProps: function(newProps) {
    // Focus only needs to be set once when the modal is being opened
    if (!this.props.isOpen && newProps.isOpen) {
      this.setFocusAfterRender(true);
      this.open();
    } else if (this.props.isOpen && !newProps.isOpen) {
      this.close();
    }
  },

  componentDidUpdate: function () {
    if (this.focusAfterRender) {
      this.focusContent();
      this.setFocusAfterRender(false);
    }
  },

  setFocusAfterRender: function (focus) {
    this.focusAfterRender = focus;
  },

  open: function() {
    focusManager.setupScopedFocus(this.node);
    focusManager.markForFocusLater();
    this.setState({isOpen: true}, function() {
      this.setState({afterOpen: true});
    }.bind(this));
  },

  close: function() {
    if (!this.ownerHandlesClose())
      return;
    if (this.props.closeTimeoutMS > 0)
      this.closeWithTimeout();
    else
      this.closeWithoutTimeout();
  },

  focusContent: function() {
    this.refs.content.focus();
  },

  closeWithTimeout: function() {
    this.setState({beforeClose: true}, function() {
      this.closeTimer = setTimeout(this.closeWithoutTimeout, this.props.closeTimeoutMS);
    }.bind(this));
  },

  closeWithoutTimeout: function() {
    this.setState({
      afterOpen: false,
      beforeClose: false
    }, this.afterClose);
  },

  afterClose: function() {
    focusManager.returnFocus();
    focusManager.teardownScopedFocus();
  },

  handleKeyDown: function(event) {
    if (event.keyCode == 9 /*tab*/) scopeTab(this.refs.content, event);
    if (event.keyCode == 27 /*esc*/) this.requestClose();
  },

  handleOverlayClick: function() {
    if (this.ownerHandlesClose())
      this.requestClose();
    else
      this.focusContent();
  },

  requestClose: function() {
    if (this.ownerHandlesClose())
      this.props.onRequestClose();
  },

  ownerHandlesClose: function() {
    return this.props.onRequestClose;
  },

  shouldBeClosed: function() {
    return !this.props.isOpen && !this.state.beforeClose;
  },

  buildClassName: function(which, additional) {
    var className = CLASS_NAMES[which].base;
    if (this.state.afterOpen)
      className += ' '+CLASS_NAMES[which].afterOpen;
    if (this.state.beforeClose)
      className += ' '+CLASS_NAMES[which].beforeClose;
    return additional ? className + ' ' + additional : className;
  },

  render: function() {
    return this.shouldBeClosed() ? div() : (
      div({
        ref: "overlay",
        className: this.buildClassName('overlay', this.props.overlayClassName),
        style: Assign({}, defaultStyles.overlay, this.props.style.overlay || {}),
        onClick: this.handleOverlayClick
      },
        div({
          ref: "content",
          style: Assign({}, defaultStyles.content, this.props.style.content || {}),
          className: this.buildClassName('content', this.props.className),
          tabIndex: "-1",
          onClick: stopPropagation,
          onKeyDown: this.handleKeyDown
        },
          this.props.children
        )
      )
    );
  }
});

},{"../helpers/focusManager":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/focusManager.js","../helpers/scopeTab":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/scopeTab.js","lodash.assign":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/ariaAppHider.js":[function(require,module,exports){
var _element = typeof document !== 'undefined' ? document.body : null;

function setElement(element) {
  if (typeof element === 'string') {
    var el = document.querySelectorAll(element);
    element = 'length' in el ? el[0] : el;
  }
  _element = element || _element;
}

function hide(appElement) {
  validateElement(appElement);
  (appElement || _element).setAttribute('aria-hidden', 'true');
}

function show(appElement) {
  validateElement(appElement);
  (appElement || _element).removeAttribute('aria-hidden');
}

function toggle(shouldHide, appElement) {
  if (shouldHide)
    hide(appElement);
  else
    show(appElement);
}

function validateElement(appElement) {
  if (!appElement && !_element)
    throw new Error('react-modal: You must set an element with `Modal.setAppElement(el)` to make this accessible');
}

function resetForTesting() {
  _element = document.body;
}

exports.toggle = toggle;
exports.setElement = setElement;
exports.show = show;
exports.hide = hide;
exports.resetForTesting = resetForTesting;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/focusManager.js":[function(require,module,exports){
var findTabbable = require('../helpers/tabbable');
var modalElement = null;
var focusLaterElement = null;
var needToFocus = false;

function handleBlur(event) {
  needToFocus = true;
}

function handleFocus(event) {
  if (needToFocus) {
    needToFocus = false;
    if (!modalElement) {
      return;
    }
    // need to see how jQuery shims document.on('focusin') so we don't need the
    // setTimeout, firefox doesn't support focusin, if it did, we could focus
    // the element outside of a setTimeout. Side-effect of this implementation 
    // is that the document.body gets focus, and then we focus our element right 
    // after, seems fine.
    setTimeout(function() {
      if (modalElement.contains(document.activeElement))
        return;
      var el = (findTabbable(modalElement)[0] || modalElement);
      el.focus();
    }, 0);
  }
}

exports.markForFocusLater = function() {
  focusLaterElement = document.activeElement;
};

exports.returnFocus = function() {
  try {
    focusLaterElement.focus();
  }
  catch (e) {
    console.warn('You tried to return focus to '+focusLaterElement+' but it is not in the DOM anymore');
  }
  focusLaterElement = null;
};

exports.setupScopedFocus = function(element) {
  modalElement = element;

  if (window.addEventListener) {
    window.addEventListener('blur', handleBlur, false);
    document.addEventListener('focus', handleFocus, true);
  } else {
    window.attachEvent('onBlur', handleBlur);
    document.attachEvent('onFocus', handleFocus);
  }
};

exports.teardownScopedFocus = function() {
  modalElement = null;

  if (window.addEventListener) {
    window.removeEventListener('blur', handleBlur);
    document.removeEventListener('focus', handleFocus);
  } else {
    window.detachEvent('onBlur', handleBlur);
    document.detachEvent('onFocus', handleFocus);
  }
};



},{"../helpers/tabbable":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/tabbable.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/scopeTab.js":[function(require,module,exports){
var findTabbable = require('../helpers/tabbable');

module.exports = function(node, event) {
  var tabbable = findTabbable(node);
  var finalTabbable = tabbable[event.shiftKey ? 0 : tabbable.length - 1];
  var leavingFinalTabbable = (
    finalTabbable === document.activeElement ||
    // handle immediate shift+tab after opening with mouse
    node === document.activeElement
  );
  if (!leavingFinalTabbable) return;
  event.preventDefault();
  var target = tabbable[event.shiftKey ? tabbable.length - 1 : 0];
  target.focus();
};

},{"../helpers/tabbable":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/tabbable.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/helpers/tabbable.js":[function(require,module,exports){
/*!
 * Adapted from jQuery UI core
 *
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */

function focusable(element, isTabIndexNotNaN) {
  var nodeName = element.nodeName.toLowerCase();
  return (/input|select|textarea|button|object/.test(nodeName) ?
    !element.disabled :
    "a" === nodeName ?
      element.href || isTabIndexNotNaN :
      isTabIndexNotNaN) && visible(element);
}

function hidden(el) {
  return (el.offsetWidth <= 0 && el.offsetHeight <= 0) ||
    el.style.display === 'none';
}

function visible(element) {
  while (element) {
    if (element === document.body) break;
    if (hidden(element)) return false;
    element = element.parentNode;
  }
  return true;
}

function tabbable(element) {
  var tabIndex = element.getAttribute('tabindex');
  if (tabIndex === null) tabIndex = undefined;
  var isTabIndexNaN = isNaN(tabIndex);
  return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
}

function findTabbableDescendants(element) {
  return [].slice.call(element.querySelectorAll('*'), 0).filter(function(el) {
    return tabbable(el);
  });
}

module.exports = findTabbableDescendants;


},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/index.js":[function(require,module,exports){
module.exports = require('./components/Modal');


},{"./components/Modal":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/components/Modal.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/element-class/index.js":[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function indexOf(arr, prop) {
  if (arr.indexOf) return arr.indexOf(prop)
  for (var i = 0, len = arr.length; i < len; i++)
    if (arr[i] === prop) return i
  return -1
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (indexOf(classes, className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = indexOf(classes, className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return indexOf(classes, className) > -1
}

ElementClass.prototype.toggle = function(className) {
  var el = this.el
  if (!el) return
  if (this.has(className)) this.remove(className)
  else this.add(className)
}

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/exenv/index.js":[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/

(function () {
	'use strict';

	var canUseDOM = !!(
		typeof window !== 'undefined' &&
		window.document &&
		window.document.createElement
	);

	var ExecutionEnvironment = {

		canUseDOM: canUseDOM,

		canUseWorkers: typeof Worker !== 'undefined',

		canUseEventListeners:
			canUseDOM && !!(window.addEventListener || window.attachEvent),

		canUseViewport: canUseDOM && !!window.screen

	};

	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		define(function () {
			return ExecutionEnvironment;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = ExecutionEnvironment;
	} else {
		window.ExecutionEnvironment = ExecutionEnvironment;
	}

}());

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/index.js":[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    createAssigner = require('lodash._createassigner'),
    keys = require('lodash.keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"lodash._baseassign":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/index.js","lodash._createassigner":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/index.js","lodash.keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/index.js":[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = require('lodash._basecopy'),
    keys = require('lodash.keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"lodash._basecopy":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/node_modules/lodash._basecopy/index.js","lodash.keys":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._baseassign/node_modules/lodash._basecopy/index.js":[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/index.js":[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var bindCallback = require('lodash._bindcallback'),
    isIterateeCall = require('lodash._isiterateecall'),
    restParam = require('lodash.restparam');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"lodash._bindcallback":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._bindcallback/index.js","lodash._isiterateecall":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._isiterateecall/index.js","lodash.restparam":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash.restparam/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._bindcallback/index.js":[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash._isiterateecall/index.js":[function(require,module,exports){
/**
 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isIterateeCall;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash._createassigner/node_modules/lodash.restparam/index.js":[function(require,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/index.js":[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash._getnative/index.js","lodash.isarguments":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js","lodash.isarray":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarray/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash._getnative/index.js":[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js":[function(require,module,exports){
/**
 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isArguments;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/node_modules/lodash.assign/node_modules/lodash.keys/node_modules/lodash.isarray/index.js":[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/accessor.js":[function(require,module,exports){
var Accessor = {
  IDENTITY_FN: function (input) {
    return input;
  },

  generateAccessor: function (field) {
    return function (object) {
      return object[field];
    };
  },

  generateOptionToStringFor: function (prop) {
    if (typeof prop === 'string') {
      return this.generateAccessor(prop);
    } else if (typeof prop === 'function') {
      return prop;
    } else {
      return this.IDENTITY_FN;
    }
  },

  valueForOption: function (option, object) {
    if (typeof option === 'string') {
      return object[option];
    } else if (typeof option === 'function') {
      return option(object);
    } else {
      return object;
    }
  }
};

module.exports = Accessor;
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/keyevent.js":[function(require,module,exports){
/**
 * PolyFills make me sad
 */
var KeyEvent = KeyEvent || {};
KeyEvent.DOM_VK_UP = KeyEvent.DOM_VK_UP || 38;
KeyEvent.DOM_VK_DOWN = KeyEvent.DOM_VK_DOWN || 40;
KeyEvent.DOM_VK_BACK_SPACE = KeyEvent.DOM_VK_BACK_SPACE || 8;
KeyEvent.DOM_VK_RETURN = KeyEvent.DOM_VK_RETURN || 13;
KeyEvent.DOM_VK_ENTER = KeyEvent.DOM_VK_ENTER || 14;
KeyEvent.DOM_VK_ESCAPE = KeyEvent.DOM_VK_ESCAPE || 27;
KeyEvent.DOM_VK_TAB = KeyEvent.DOM_VK_TAB || 9;

module.exports = KeyEvent;
},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/react-typeahead.js":[function(require,module,exports){
var Typeahead = require('./typeahead');
var Tokenizer = require('./tokenizer');

module.exports = {
  Typeahead: Typeahead,
  Tokenizer: Tokenizer
};
},{"./tokenizer":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/tokenizer/index.js","./typeahead":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/tokenizer/index.js":[function(require,module,exports){
var Accessor = require('../accessor');
var React = require('react');
var Token = require('./token');
var KeyEvent = require('../keyevent');
var Typeahead = require('../typeahead');
var classNames = require('classnames');

function _arraysAreDifferent(array1, array2) {
  if (array1.length != array2.length) {
    return true;
  }
  for (var i = array2.length - 1; i >= 0; i--) {
    if (array2[i] !== array1[i]) {
      return true;
    }
  }
}

/**
 * A typeahead that, when an option is selected, instead of simply filling
 * the text entry widget, prepends a renderable "token", that may be deleted
 * by pressing backspace on the beginning of the line with the keyboard.
 */
var TypeaheadTokenizer = React.createClass({
  displayName: 'TypeaheadTokenizer',

  propTypes: {
    name: React.PropTypes.string,
    options: React.PropTypes.array,
    customClasses: React.PropTypes.object,
    allowCustomValues: React.PropTypes.number,
    defaultSelected: React.PropTypes.array,
    defaultValue: React.PropTypes.string,
    placeholder: React.PropTypes.string,
    disabled: React.PropTypes.bool,
    inputProps: React.PropTypes.object,
    onTokenRemove: React.PropTypes.func,
    onKeyDown: React.PropTypes.func,
    onKeyPress: React.PropTypes.func,
    onKeyUp: React.PropTypes.func,
    onTokenAdd: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    filterOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    displayOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    formInputOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    maxVisible: React.PropTypes.number,
    defaultClassNames: React.PropTypes.bool
  },

  getInitialState: function () {
    return {
      // We need to copy this to avoid incorrect sharing
      // of state across instances (e.g., via getDefaultProps())
      selected: this.props.defaultSelected.slice(0)
    };
  },

  getDefaultProps: function () {
    return {
      options: [],
      defaultSelected: [],
      customClasses: {},
      allowCustomValues: 0,
      defaultValue: "",
      placeholder: "",
      disabled: false,
      inputProps: {},
      defaultClassNames: true,
      filterOption: null,
      displayOption: function (token) {
        return token;
      },
      formInputOption: null,
      onKeyDown: function (event) {},
      onKeyPress: function (event) {},
      onKeyUp: function (event) {},
      onFocus: function (event) {},
      onBlur: function (event) {},
      onTokenAdd: function () {},
      onTokenRemove: function () {}
    };
  },

  componentWillReceiveProps: function (nextProps) {
    // if we get new defaultProps, update selected
    if (_arraysAreDifferent(this.props.defaultSelected, nextProps.defaultSelected)) {
      this.setState({ selected: nextProps.defaultSelected.slice(0) });
    }
  },

  focus: function () {
    this.refs.typeahead.focus();
  },

  getSelectedTokens: function () {
    return this.state.selected;
  },

  // TODO: Support initialized tokens
  //
  _renderTokens: function () {
    var tokenClasses = {};
    tokenClasses[this.props.customClasses.token] = !!this.props.customClasses.token;
    var classList = classNames(tokenClasses);
    var result = this.state.selected.map(function (selected) {
      var displayString = Accessor.valueForOption(this.props.displayOption, selected);
      var value = Accessor.valueForOption(this.props.formInputOption || this.props.displayOption, selected);
      return React.createElement(
        Token,
        { key: displayString, className: classList,
          onRemove: this._removeTokenForValue,
          object: selected,
          value: value,
          name: this.props.name },
        displayString
      );
    }, this);
    return result;
  },

  _getOptionsForTypeahead: function () {
    // return this.props.options without this.selected
    return this.props.options;
  },

  _onKeyDown: function (event) {
    // We only care about intercepting backspaces
    if (event.keyCode === KeyEvent.DOM_VK_BACK_SPACE) {
      return this._handleBackspace(event);
    }
    this.props.onKeyDown(event);
  },

  _handleBackspace: function (event) {
    // No tokens
    if (!this.state.selected.length) {
      return;
    }

    // Remove token ONLY when bksp pressed at beginning of line
    // without a selection
    var entry = this.refs.typeahead.refs.entry;
    if (entry.selectionStart == entry.selectionEnd && entry.selectionStart == 0) {
      this._removeTokenForValue(this.state.selected[this.state.selected.length - 1]);
      event.preventDefault();
    }
  },

  _removeTokenForValue: function (value) {
    var index = this.state.selected.indexOf(value);
    if (index == -1) {
      return;
    }

    this.state.selected.splice(index, 1);
    this.setState({ selected: this.state.selected });
    this.props.onTokenRemove(value);
    return;
  },

  _addTokenForValue: function (value) {
    if (this.state.selected.indexOf(value) != -1) {
      return;
    }
    this.state.selected.push(value);
    this.setState({ selected: this.state.selected });
    this.refs.typeahead.setEntryText("");
    this.props.onTokenAdd(value);
  },

  render: function () {
    var classes = {};
    classes[this.props.customClasses.typeahead] = !!this.props.customClasses.typeahead;
    var classList = classNames(classes);
    var tokenizerClasses = [this.props.defaultClassNames && "typeahead-tokenizer"];
    tokenizerClasses[this.props.className] = !!this.props.className;
    var tokenizerClassList = classNames(tokenizerClasses);

    return React.createElement(
      'div',
      { className: tokenizerClassList },
      this._renderTokens(),
      React.createElement(Typeahead, { ref: 'typeahead',
        className: classList,
        placeholder: this.props.placeholder,
        disabled: this.props.disabled,
        inputProps: this.props.inputProps,
        allowCustomValues: this.props.allowCustomValues,
        customClasses: this.props.customClasses,
        options: this._getOptionsForTypeahead(),
        defaultValue: this.props.defaultValue,
        maxVisible: this.props.maxVisible,
        onOptionSelected: this._addTokenForValue,
        onKeyDown: this._onKeyDown,
        onKeyPress: this.props.onKeyPress,
        onKeyUp: this.props.onKeyUp,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur,
        displayOption: this.props.displayOption,
        defaultClassNames: this.props.defaultClassNames,
        filterOption: this.props.filterOption })
    );
  }
});

module.exports = TypeaheadTokenizer;
},{"../accessor":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/accessor.js","../keyevent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/keyevent.js","../typeahead":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/index.js","./token":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/tokenizer/token.js","classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/tokenizer/token.js":[function(require,module,exports){
var React = require('react');
var classNames = require('classnames');

/**
 * Encapsulates the rendering of an option that has been "selected" in a
 * TypeaheadTokenizer
 */
var Token = React.createClass({
  displayName: 'Token',

  propTypes: {
    className: React.PropTypes.string,
    name: React.PropTypes.string,
    children: React.PropTypes.string,
    object: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object]),
    onRemove: React.PropTypes.func,
    value: React.PropTypes.string
  },

  render: function () {
    var className = classNames(["typeahead-token", this.props.className]);

    return React.createElement(
      'div',
      { className: className },
      this._renderHiddenInput(),
      this.props.children,
      this._renderCloseButton()
    );
  },

  _renderHiddenInput: function () {
    // If no name was set, don't create a hidden input
    if (!this.props.name) {
      return null;
    }

    return React.createElement('input', {
      type: 'hidden',
      name: this.props.name + '[]',
      value: this.props.value || this.props.object
    });
  },

  _renderCloseButton: function () {
    if (!this.props.onRemove) {
      return "";
    }
    return React.createElement(
      'a',
      { className: 'typeahead-token-close', href: '#', onClick: function (event) {
          this.props.onRemove(this.props.object);
          event.preventDefault();
        }.bind(this) },
      '×'
    );
  }
});

module.exports = Token;
},{"classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/index.js":[function(require,module,exports){
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Accessor = require('../accessor');
var React = require('react');
var TypeaheadSelector = require('./selector');
var KeyEvent = require('../keyevent');
var fuzzy = require('fuzzy');
var classNames = require('classnames');

/**
 * A "typeahead", an auto-completing text input
 *
 * Renders an text input that shows options nearby that you can use the
 * keyboard or mouse to select.  Requires CSS for MASSIVE DAMAGE.
 */
var Typeahead = React.createClass({
  displayName: 'Typeahead',

  propTypes: {
    name: React.PropTypes.string,
    customClasses: React.PropTypes.object,
    maxVisible: React.PropTypes.number,
    options: React.PropTypes.array,
    allowCustomValues: React.PropTypes.number,
    defaultValue: React.PropTypes.string,
    value: React.PropTypes.string,
    placeholder: React.PropTypes.string,
    disabled: React.PropTypes.bool,
    textarea: React.PropTypes.bool,
    inputProps: React.PropTypes.object,
    onOptionSelected: React.PropTypes.func,
    onChange: React.PropTypes.func,
    onKeyDown: React.PropTypes.func,
    onKeyPress: React.PropTypes.func,
    onKeyUp: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    filterOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    displayOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    formInputOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
    defaultClassNames: React.PropTypes.bool,
    customListComponent: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.func]),
    showOptionsWhenEmpty: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      options: [],
      customClasses: {},
      allowCustomValues: 0,
      defaultValue: "",
      value: null,
      placeholder: "",
      disabled: false,
      textarea: false,
      inputProps: {},
      onOptionSelected: function (option) {},
      onChange: function (event) {},
      onKeyDown: function (event) {},
      onKeyPress: function (event) {},
      onKeyUp: function (event) {},
      onFocus: function (event) {},
      onBlur: function (event) {},
      filterOption: null,
      defaultClassNames: true,
      customListComponent: TypeaheadSelector,
      showOptionsWhenEmpty: false
    };
  },

  getInitialState: function () {
    return {
      // The currently visible set of options
      visible: this.getOptionsForValue(this.props.defaultValue, this.props.options),

      // This should be called something else, "entryValue"
      entryValue: this.props.value || this.props.defaultValue,

      // A valid typeahead value
      selection: this.props.value,

      // Index of the selection
      selectionIndex: null
    };
  },

  _shouldSkipSearch: function (input) {
    var emptyValue = !input || input.trim().length == 0;
    return !this.props.showOptionsWhenEmpty && emptyValue;
  },

  getOptionsForValue: function (value, options) {
    if (this._shouldSkipSearch(value)) {
      return [];
    }

    var filterOptions = this._generateFilterFunction();
    var result = filterOptions(value, options);
    if (this.props.maxVisible) {
      result = result.slice(0, this.props.maxVisible);
    }
    return result;
  },

  setEntryText: function (value) {
    this.refs.entry.value = value;
    this._onTextEntryUpdated();
  },

  focus: function () {
    this.refs.entry.focus();
  },

  _hasCustomValue: function () {
    if (this.props.allowCustomValues > 0 && this.state.entryValue.length >= this.props.allowCustomValues && this.state.visible.indexOf(this.state.entryValue) < 0) {
      return true;
    }
    return false;
  },

  _getCustomValue: function () {
    if (this._hasCustomValue()) {
      return this.state.entryValue;
    }
    return null;
  },

  _renderIncrementalSearchResults: function () {
    // Nothing has been entered into the textbox
    if (this._shouldSkipSearch(this.state.entryValue)) {
      return "";
    }

    // Something was just selected
    if (this.state.selection) {
      return "";
    }

    return React.createElement(this.props.customListComponent, {
      ref: 'sel', options: this.state.visible,
      onOptionSelected: this._onOptionSelected,
      allowCustomValues: this.props.allowCustomValues,
      customValue: this._getCustomValue(),
      customClasses: this.props.customClasses,
      selectionIndex: this.state.selectionIndex,
      defaultClassNames: this.props.defaultClassNames,
      displayOption: Accessor.generateOptionToStringFor(this.props.displayOption) });
  },

  getSelection: function () {
    var index = this.state.selectionIndex;
    if (this._hasCustomValue()) {
      if (index === 0) {
        return this.state.entryValue;
      } else {
        index--;
      }
    }
    return this.state.visible[index];
  },

  _onOptionSelected: function (option, event) {
    var nEntry = this.refs.entry;
    nEntry.focus();

    var displayOption = Accessor.generateOptionToStringFor(this.props.displayOption);
    var optionString = displayOption(option, 0);

    var formInputOption = Accessor.generateOptionToStringFor(this.props.formInputOption || displayOption);
    var formInputOptionString = formInputOption(option);

    nEntry.value = optionString;
    this.setState({ visible: this.getOptionsForValue(optionString, this.props.options),
      selection: formInputOptionString,
      entryValue: optionString });
    return this.props.onOptionSelected(option, event);
  },

  _onTextEntryUpdated: function () {
    var value = this.refs.entry.value;
    this.setState({ visible: this.getOptionsForValue(value, this.props.options),
      selection: null,
      entryValue: value });
  },

  _onEnter: function (event) {
    var selection = this.getSelection();
    if (!selection) {
      return this.props.onKeyDown(event);
    }
    return this._onOptionSelected(selection, event);
  },

  _onEscape: function () {
    this.setState({
      selectionIndex: null
    });
  },

  _onTab: function (event) {
    var selection = this.getSelection();
    var option = selection ? selection : this.state.visible.length > 0 ? this.state.visible[0] : null;

    if (option === null && this._hasCustomValue()) {
      option = this._getCustomValue();
    }

    if (option !== null) {
      return this._onOptionSelected(option, event);
    }
  },

  eventMap: function (event) {
    var events = {};

    events[KeyEvent.DOM_VK_UP] = this.navUp;
    events[KeyEvent.DOM_VK_DOWN] = this.navDown;
    events[KeyEvent.DOM_VK_RETURN] = events[KeyEvent.DOM_VK_ENTER] = this._onEnter;
    events[KeyEvent.DOM_VK_ESCAPE] = this._onEscape;
    events[KeyEvent.DOM_VK_TAB] = this._onTab;

    return events;
  },

  _nav: function (delta) {
    if (!this._hasHint()) {
      return;
    }
    var newIndex = this.state.selectionIndex === null ? delta == 1 ? 0 : delta : this.state.selectionIndex + delta;
    var length = this.state.visible.length;
    if (this._hasCustomValue()) {
      length += 1;
    }

    if (newIndex < 0) {
      newIndex += length;
    } else if (newIndex >= length) {
      newIndex -= length;
    }

    this.setState({ selectionIndex: newIndex });
  },

  navDown: function () {
    this._nav(1);
  },

  navUp: function () {
    this._nav(-1);
  },

  _onChange: function (event) {
    if (this.props.onChange) {
      this.props.onChange(event);
    }

    this._onTextEntryUpdated();
  },

  _onKeyDown: function (event) {
    // If there are no visible elements, don't perform selector navigation.
    // Just pass this up to the upstream onKeydown handler.
    // Also skip if the user is pressing the shift key, since none of our handlers are looking for shift
    if (!this._hasHint() || event.shiftKey) {
      return this.props.onKeyDown(event);
    }

    var handler = this.eventMap()[event.keyCode];

    if (handler) {
      handler(event);
    } else {
      return this.props.onKeyDown(event);
    }
    // Don't propagate the keystroke back to the DOM/browser
    event.preventDefault();
  },

  componentWillReceiveProps: function (nextProps) {
    this.setState({
      visible: this.getOptionsForValue(this.state.entryValue, nextProps.options)
    });
  },

  render: function () {
    var inputClasses = {};
    inputClasses[this.props.customClasses.input] = !!this.props.customClasses.input;
    var inputClassList = classNames(inputClasses);

    var classes = {
      typeahead: this.props.defaultClassNames
    };
    classes[this.props.className] = !!this.props.className;
    var classList = classNames(classes);

    var InputElement = this.props.textarea ? 'textarea' : 'input';

    return React.createElement(
      'div',
      { className: classList },
      this._renderHiddenInput(),
      React.createElement(InputElement, _extends({ ref: 'entry', type: 'text',
        disabled: this.props.disabled
      }, this.props.inputProps, {
        placeholder: this.props.placeholder,
        className: inputClassList,
        value: this.state.entryValue,
        defaultValue: this.props.defaultValue,
        onChange: this._onChange,
        onKeyDown: this._onKeyDown,
        onKeyPress: this.props.onKeyPress,
        onKeyUp: this.props.onKeyUp,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur
      })),
      this._renderIncrementalSearchResults()
    );
  },

  _renderHiddenInput: function () {
    if (!this.props.name) {
      return null;
    }

    return React.createElement('input', {
      type: 'hidden',
      name: this.props.name,
      value: this.state.selection
    });
  },

  _generateFilterFunction: function () {
    var filterOptionProp = this.props.filterOption;
    if (typeof filterOptionProp === 'function') {
      return function (value, options) {
        return options.filter(function (o) {
          return filterOptionProp(value, o);
        });
      };
    } else {
      var mapper;
      if (typeof filterOptionProp === 'string') {
        mapper = Accessor.generateAccessor(filterOptionProp);
      } else {
        mapper = Accessor.IDENTITY_FN;
      }
      return function (value, options) {
        return fuzzy.filter(value, options, { extract: mapper }).map(function (res) {
          return options[res.index];
        });
      };
    }
  },

  _hasHint: function () {
    return this.state.visible.length > 0 || this._hasCustomValue();
  }
});

module.exports = Typeahead;
},{"../accessor":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/accessor.js","../keyevent":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/keyevent.js","./selector":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/selector.js","classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/classnames/index.js","fuzzy":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/fuzzy/lib/fuzzy.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/option.js":[function(require,module,exports){
var React = require('react');
var classNames = require('classnames');

/**
 * A single option within the TypeaheadSelector
 */
var TypeaheadOption = React.createClass({
  displayName: 'TypeaheadOption',

  propTypes: {
    customClasses: React.PropTypes.object,
    customValue: React.PropTypes.string,
    onClick: React.PropTypes.func,
    children: React.PropTypes.string,
    hover: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      customClasses: {},
      onClick: function (event) {
        event.preventDefault();
      }
    };
  },

  render: function () {
    var classes = {};
    classes[this.props.customClasses.hover || "hover"] = !!this.props.hover;
    classes[this.props.customClasses.listItem] = !!this.props.customClasses.listItem;

    if (this.props.customValue) {
      classes[this.props.customClasses.customAdd] = !!this.props.customClasses.customAdd;
    }

    var classList = classNames(classes);

    return React.createElement(
      'li',
      { className: classList, onClick: this._onClick },
      React.createElement(
        'a',
        { href: 'javascript: void 0;', className: this._getClasses(), ref: 'anchor' },
        this.props.children
      )
    );
  },

  _getClasses: function () {
    var classes = {
      "typeahead-option": true
    };
    classes[this.props.customClasses.listAnchor] = !!this.props.customClasses.listAnchor;

    return classNames(classes);
  },

  _onClick: function (event) {
    event.preventDefault();
    return this.props.onClick(event);
  }
});

module.exports = TypeaheadOption;
},{"classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/selector.js":[function(require,module,exports){
var React = require('react');
var TypeaheadOption = require('./option');
var classNames = require('classnames');

/**
 * Container for the options rendered as part of the autocompletion process
 * of the typeahead
 */
var TypeaheadSelector = React.createClass({
  displayName: 'TypeaheadSelector',

  propTypes: {
    options: React.PropTypes.array,
    allowCustomValues: React.PropTypes.number,
    customClasses: React.PropTypes.object,
    customValue: React.PropTypes.string,
    selectionIndex: React.PropTypes.number,
    onOptionSelected: React.PropTypes.func,
    displayOption: React.PropTypes.func.isRequired,
    defaultClassNames: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      selectionIndex: null,
      customClasses: {},
      allowCustomValues: 0,
      customValue: null,
      onOptionSelected: function (option) {},
      defaultClassNames: true
    };
  },

  render: function () {
    // Don't render if there are no options to display
    if (!this.props.options.length && this.props.allowCustomValues <= 0) {
      return false;
    }

    var classes = {
      "typeahead-selector": this.props.defaultClassNames
    };
    classes[this.props.customClasses.results] = this.props.customClasses.results;
    var classList = classNames(classes);

    // CustomValue should be added to top of results list with different class name
    var customValue = null;
    var customValueOffset = 0;
    if (this.props.customValue !== null) {
      customValueOffset++;
      customValue = React.createElement(
        TypeaheadOption,
        { ref: this.props.customValue, key: this.props.customValue,
          hover: this.props.selectionIndex === 0,
          customClasses: this.props.customClasses,
          customValue: this.props.customValue,
          onClick: this._onClick.bind(this, this.props.customValue) },
        this.props.customValue
      );
    }

    var results = this.props.options.map(function (result, i) {
      var displayString = this.props.displayOption(result, i);
      var uniqueKey = displayString + '_' + i;
      return React.createElement(
        TypeaheadOption,
        { ref: uniqueKey, key: uniqueKey,
          hover: this.props.selectionIndex === i + customValueOffset,
          customClasses: this.props.customClasses,
          onClick: this._onClick.bind(this, result) },
        displayString
      );
    }, this);

    return React.createElement(
      'ul',
      { className: classList },
      customValue,
      results
    );
  },

  _onClick: function (result, event) {
    return this.props.onOptionSelected(result, event);
  }

});

module.exports = TypeaheadSelector;
},{"./option":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/typeahead/option.js","classnames":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/classnames/index.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/classnames/index.js":[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

function classNames() {
	var classes = '';
	var arg;

	for (var i = 0; i < arguments.length; i++) {
		arg = arguments[i];
		if (!arg) {
			continue;
		}

		if ('string' === typeof arg || 'number' === typeof arg) {
			classes += ' ' + arg;
		} else if (Object.prototype.toString.call(arg) === '[object Array]') {
			classes += ' ' + classNames.apply(null, arg);
		} else if ('object' === typeof arg) {
			for (var key in arg) {
				if (!arg.hasOwnProperty(key) || !arg[key]) {
					continue;
				}
				classes += ' ' + key;
			}
		}
	}
	return classes.substr(1);
}

// safely export classNames for node / browserify
if (typeof module !== 'undefined' && module.exports) {
	module.exports = classNames;
}

// safely export classNames for RequireJS
if (typeof define !== 'undefined' && define.amd) {
	define('classnames', [], function() {
		return classNames;
	});
}

},{}],"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/node_modules/fuzzy/lib/fuzzy.js":[function(require,module,exports){
/*
 * Fuzzy
 * https://github.com/myork/fuzzy
 *
 * Copyright (c) 2012 Matt York
 * Licensed under the MIT license.
 */

(function() {

var root = this;

var fuzzy = {};

// Use in node or in browser
if (typeof exports !== 'undefined') {
  module.exports = fuzzy;
} else {
  root.fuzzy = fuzzy;
}

// Return all elements of `array` that have a fuzzy
// match against `pattern`.
fuzzy.simpleFilter = function(pattern, array) {
  return array.filter(function(string) {
    return fuzzy.test(pattern, string);
  });
};

// Does `pattern` fuzzy match `string`?
fuzzy.test = function(pattern, string) {
  return fuzzy.match(pattern, string) !== null;
};

// If `pattern` matches `string`, wrap each matching character
// in `opts.pre` and `opts.post`. If no match, return null
fuzzy.match = function(pattern, string, opts) {
  opts = opts || {};
  var patternIdx = 0
    , result = []
    , len = string.length
    , totalScore = 0
    , currScore = 0
    // prefix
    , pre = opts.pre || ''
    // suffix
    , post = opts.post || ''
    // String to compare against. This might be a lowercase version of the
    // raw string
    , compareString =  opts.caseSensitive && string || string.toLowerCase()
    , ch, compareChar;

  pattern = opts.caseSensitive && pattern || pattern.toLowerCase();

  // For each character in the string, either add it to the result
  // or wrap in template if it's the next string in the pattern
  for(var idx = 0; idx < len; idx++) {
    ch = string[idx];
    if(compareString[idx] === pattern[patternIdx]) {
      ch = pre + ch + post;
      patternIdx += 1;

      // consecutive characters should increase the score more than linearly
      currScore += 1 + currScore;
    } else {
      currScore = 0;
    }
    totalScore += currScore;
    result[result.length] = ch;
  }

  // return rendered string if we have a match for every char
  if(patternIdx === pattern.length) {
    return {rendered: result.join(''), score: totalScore};
  }

  return null;
};

// The normal entry point. Filters `arr` for matches against `pattern`.
// It returns an array with matching values of the type:
//
//     [{
//         string:   '<b>lah' // The rendered string
//       , index:    2        // The index of the element in `arr`
//       , original: 'blah'   // The original element in `arr`
//     }]
//
// `opts` is an optional argument bag. Details:
//
//    opts = {
//        // string to put before a matching character
//        pre:     '<b>'
//
//        // string to put after matching character
//      , post:    '</b>'
//
//        // Optional function. Input is an entry in the given arr`,
//        // output should be the string to test `pattern` against.
//        // In this example, if `arr = [{crying: 'koala'}]` we would return
//        // 'koala'.
//      , extract: function(arg) { return arg.crying; }
//    }
fuzzy.filter = function(pattern, arr, opts) {
  opts = opts || {};
  return arr
    .reduce(function(prev, element, idx, arr) {
      var str = element;
      if(opts.extract) {
        str = opts.extract(element);
      }
      var rendered = fuzzy.match(pattern, str, opts);
      if(rendered != null) {
        prev[prev.length] = {
            string: rendered.rendered
          , score: rendered.score
          , index: idx
          , original: element
        };
      }
      return prev;
    }, [])

    // Sort by score. Browsers are inconsistent wrt stable/unstable
    // sorting, so force stable by using the index in the case of tie.
    // See http://ofb.net/~sethml/is-sort-stable.html
    .sort(function(a,b) {
      var compare = b.score - a.score;
      if(compare) return compare;
      return a.index - b.index;
    });
};


}());


},{}],"/Users/nayers/Documents/Panorama/panorama-holc/src/App.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var React = _interopRequireWildcard(_react);

var _AreaDescriptionsStore = require('./stores/AreaDescriptionsStore');

var _AreaDescriptionsStore2 = _interopRequireDefault(_AreaDescriptionsStore);

var _CityStore = require('./stores/CityStore');

var _CityStore2 = _interopRequireDefault(_CityStore);

var _MapStateStore = require('./stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

var _RasterStore = require('./stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

var _UserLocationStore = require('./stores/UserLocationStore');

var _UserLocationStore2 = _interopRequireDefault(_UserLocationStore);

var _TextsStore = require('./stores/TextsStore');

var _TextsStore2 = _interopRequireDefault(_TextsStore);

var _ADCat = require('./components/ADCat.jsx');

var _ADCat2 = _interopRequireDefault(_ADCat);

var _AreaDescription = require('./components/AreaDescription.jsx');

var _AreaDescription2 = _interopRequireDefault(_AreaDescription);

var _AreaPolygon = require('./components/AreaPolygon.jsx');

var _AreaPolygon2 = _interopRequireDefault(_AreaPolygon);

var _toolkit = require('@panorama/toolkit');

var _CitySnippet = require('./components/CitySnippet.jsx');

var _CitySnippet2 = _interopRequireDefault(_CitySnippet);

var _CityStats = require('./components/CityStats.jsx');

var _CityStats2 = _interopRequireDefault(_CityStats);

var _Donut = require('./components/Donut/Donut.jsx');

var _Donut2 = _interopRequireDefault(_Donut);

var _Downloader = require('./components/Downloader.jsx');

var _Downloader2 = _interopRequireDefault(_Downloader);

var _leaflet = require('leaflet');

var _reactLeaflet = require('react-leaflet');

var _reactModal = require('react-modal');

var _reactModal2 = _interopRequireDefault(_reactModal);

var _rcSlider = require('rc-slider');

var _rcSlider2 = _interopRequireDefault(_rcSlider);

var _StateStats = require('./components/StateStats.jsx');

var _StateStats2 = _interopRequireDefault(_StateStats);

var _reactTypeahead = require('react-typeahead');

var _TypeAheadCitySnippet = require('./components/TypeAheadCitySnippet.jsx');

var _TypeAheadCitySnippet2 = _interopRequireDefault(_TypeAheadCitySnippet);

var _AppActionCreator = require('./utils/AppActionCreator');

var _config = require('../basemaps/cartodb/config.json');

var _config2 = _interopRequireDefault(_config);

var _basemaps = require('../basemaps/cartodb/basemaps.json');

var _basemaps2 = _interopRequireDefault(_basemaps);

var _tileLayers = require('../basemaps/tileLayers.json');

var _tileLayers2 = _interopRequireDefault(_tileLayers);

var _panorama_nav = require('../data/panorama_nav.json');

var _panorama_nav2 = _interopRequireDefault(_panorama_nav);

var _state_abbr = require('../data/state_abbr.json');

var _state_abbr2 = _interopRequireDefault(_state_abbr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import "babel-polyfill";

// stores


// components (views)


// utils


// config


// data


var App = function (_React$Component) {
	_inherits(App, _React$Component);

	function App(props) {
		_classCallCheck(this, App);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(App).call(this, props));

		_this.state = _this.getDefaultState();

		// bind handlers
		var handlers = ['onWindowResize', 'onModalClick', 'toggleBurgessDiagram', 'storeChanged', 'onBurgessChartOff', 'onBurgessChartHover', 'onStateSelected', 'onCitySelected', 'onMapMoved', 'onPanoramaMenuClick', 'onDownloadClicked', 'onCategoryClick', 'neighborhoodHighlighted', 'neighborhoodsUnhighlighted', 'onSliderChange', 'onUserCityResponse', 'onNeighborhoodPolygonClick', 'onAreaChartHover', 'onAreaChartOff', 'onCityMarkerSelected', 'onGradeHover', 'onGradeUnhover', 'onHOLCIDClick'];
		handlers.map(function (handler) {
			_this[handler] = _this[handler].bind(_this);
		});
		return _this;
	}

	/* Lifecycle methods */

	_createClass(App, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			this.computeComponentDimensions();
			_AppActionCreator.AppActions.loadInitialData(this.state, _toolkit.HashManager.getState());

			//try to retrieve the users location
			if (navigator.geolocation) {
				navigator.geolocation.getCurrentPosition(function (position) {
					_AppActionCreator.AppActions.userLocated([position.coords.latitude, position.coords.longitude]);
				}, function (error) {
					console.warn('Geolocation error occurred. Error code: ' + error.code);
				});
			}
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			window.addEventListener('resize', this.onWindowResize);
			_AreaDescriptionsStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_CityStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_MapStateStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_RasterStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_UserLocationStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);
			_TextsStore2.default.addListener(_AppActionCreator.AppActionTypes.storeChanged, this.storeChanged);

			// you have to wait until there's a map to query to get the visible maps
			var waitingId = setInterval(function () {
				if (_RasterStore2.default.hasLoaded()) {
					clearInterval(waitingId);

					// emit mapped moved event to initialize map state
					_AppActionCreator.AppActions.mapInitialized(_this2.refs.the_map.leafletElement);
				}
			}, 100);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {}

		/* setState methods */

	}, {
		key: 'getDefaultState',
		value: function getDefaultState() {
			var hashState = _toolkit.HashManager.getState();

			return {
				selectedCity: hashState.city ? parseInt(hashState.city) : null,
				selectedNeighborhood: hashState.area ? hashState.area : null,
				selectedCategory: hashState.category ? hashState.category : null,
				selectedRingGrade: {
					ringId: null,
					grade: null
				},
				selectedGrade: null,
				raster: {
					opacity: hashState.opacity ? parseFloat(hashState.opacity) : 0.8
				},
				highlightedNeighborhood: null,
				burgessDiagramVisible: false,
				downloadOpen: false,
				map: {
					zoom: hashState.loc && hashState.loc.zoom ? hashState.loc.zoom : 5,
					center: hashState.loc && hashState.loc.center ? [hashState.loc.center[0], hashState.loc.center[1]] : [39.8333333, -98.585522]
				},
				dimensions: {
					left: {
						width: 0,
						height: 0
					},
					upperRight: {
						width: 0,
						height: 0
					}
				}
			};
		}
	}, {
		key: 'storeChanged',
		value: function storeChanged() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			this.setState({
				selectedCity: _CityStore2.default.getId(),
				selectedGrade: _CityStore2.default.getSelectedGrade(),
				selectedNeighborhood: _CityStore2.default.getSelectedHolcId(),
				selectedCategory: _CityStore2.default.getSelectedCategory(),
				selectedRingGrade: _CityStore2.default.getSelectedRingGrade(),
				highlightedNeighborhood: _CityStore2.default.getHighlightedHolcId(),
				map: {
					center: _MapStateStore2.default.getCenter(),
					zoom: _MapStateStore2.default.getZoom()
				}
			}, this.changeHash);
		}
	}, {
		key: 'onMapMoved',
		value: function onMapMoved(event) {
			_AppActionCreator.AppActions.mapMoved(this.refs.the_map.leafletElement);
		}
	}, {
		key: 'onCitySelected',
		value: function onCitySelected(event) {
			_AppActionCreator.AppActions.citySelected(event.target.id, true);
		}
	}, {
		key: 'onCityMarkerSelected',
		value: function onCityMarkerSelected(event) {
			_AppActionCreator.AppActions.citySelected(event.target.options.id, true);
		}
	}, {
		key: 'onNeighborhoodPolygonClick',
		value: function onNeighborhoodPolygonClick(event) {
			var neighborhoodId = event.target.options.neighborhoodId,
			    adId = event.target.options.adId;

			// clicking on a selected neighborhood deselects it
			neighborhoodId = neighborhoodId == this.state.selectedNeighborhood ? null : neighborhoodId;

			_AppActionCreator.AppActions.neighborhoodSelected(neighborhoodId, adId);
		}
	}, {
		key: 'onHOLCIDClick',
		value: function onHOLCIDClick(event) {
			console.log(event);
			_AppActionCreator.AppActions.neighborhoodSelected(event.target.id, this.state.selectedCity);
		}
	}, {
		key: 'neighborhoodHighlighted',
		value: function neighborhoodHighlighted(event) {
			_AppActionCreator.AppActions.neighborhoodHighlighted(event.target.id);
		}
	}, {
		key: 'neighborhoodsUnhighlighted',
		value: function neighborhoodsUnhighlighted() {
			_AppActionCreator.AppActions.neighborhoodHighlighted(null);
		}
	}, {
		key: 'onCategoryClick',
		value: function onCategoryClick(event) {
			_AppActionCreator.AppActions.ADCategorySelected(event.target.id);
		}
	}, {
		key: 'onBurgessChartHover',
		value: function onBurgessChartHover(ringId, grade) {
			_AppActionCreator.AppActions.ringGradeSelected({ ringId: ringId, grade: grade });
		}
	}, {
		key: 'onBurgessChartOff',
		value: function onBurgessChartOff() {
			_AppActionCreator.AppActions.ringGradeSelected({ ringId: -1, grade: null });
		}
	}, {
		key: 'onAreaChartHover',
		value: function onAreaChartHover(grade) {
			_AppActionCreator.AppActions.gradeSelected(grade);
		}
	}, {
		key: 'onAreaChartOff',
		value: function onAreaChartOff() {
			_AppActionCreator.AppActions.gradeSelected(null);
		}
	}, {
		key: 'onLegendSelect',
		value: function onLegendSelect(legendText) {}
	}, {
		key: 'onGradeHover',
		value: function onGradeHover(event) {
			console.log(event);
			_AppActionCreator.AppActions.gradeSelected(event.target.grade);
		}
	}, {
		key: 'onGradeUnhover',
		value: function onGradeUnhover() {
			_AppActionCreator.AppActions.gradeSelected(null);
		}
	}, {
		key: 'categorySelected',
		value: function categorySelected(id) {
			this.setState({
				selectedNeighborhood: null,
				selectedCategory: id
			}, this.changeHash);
		}
	}, {
		key: 'onWindowResize',
		value: function onWindowResize(event) {
			this.computeComponentDimensions();
		}
	}, {
		key: 'onStateSelected',
		value: function onStateSelected(value, index) {
			// for click on state name in sidebar
			value = value.target ? value.target : value;

			this.setState({
				selectedCity: null,
				selectedNeighborhood: null,
				map: {
					zoom: this.refs.the_map.leafletElement.getBoundsZoom(_RasterStore2.default.getMapBoundsForState(value.id)),
					center: _RasterStore2.default.getCenterForState(value.id)
				}
			}, this.changeHash());
		}
	}, {
		key: 'onSliderChange',
		value: function onSliderChange(value) {
			this.setState({
				raster: {
					opacity: value / 100
				}
			}, this.changeHash);
		}
	}, {
		key: 'onDownloadClicked',
		value: function onDownloadClicked() {
			this.setState({
				downloadOpen: !this.state.downloadOpen
			});
		}
	}, {
		key: 'onPanoramaMenuClick',
		value: function onPanoramaMenuClick() {
			this.setState({
				show_panorama_menu: !this.state.show_panorama_menu
			});
		}
	}, {
		key: 'onUserCityResponse',
		value: function onUserCityResponse(event) {
			if (event.target.value == 'yes') {
				_AppActionCreator.AppActions.citySelected(_UserLocationStore2.default.getAdId(), true);
			}
			_AppActionCreator.AppActions.userRespondedToZoomOffer();
		}
	}, {
		key: 'toggleBurgessDiagram',
		value: function toggleBurgessDiagram() {
			this.setState({
				burgessDiagramVisible: !this.state.burgessDiagramVisible
			});
		}
	}, {
		key: 'onModalClick',
		value: function onModalClick(event) {
			console.log(event.target);
			var subject = event.target.id ? event.target.id : null;
			_AppActionCreator.AppActions.onModalClick(subject);
		}

		/* manage hash */

	}, {
		key: 'changeHash',
		value: function changeHash() {
			_toolkit.HashManager.updateHash({
				city: this.state.selectedCity,
				area: this.state.selectedNeighborhood,
				category: this.state.selectedCategory,
				opacity: this.state.raster.opacity,
				loc: {
					zoom: this.state.map.zoom,
					center: this.state.map.center
				}
			});
		}

		/* helper methods */

	}, {
		key: 'computeComponentDimensions',
		value: function computeComponentDimensions() {
			// based off of sizes stored within _variables.scss --
			// if you change them there, change them here.
			var containerPadding = 20,
			    headerHeight = 100,
			    bottomRowHeight = 300,
			    dimensions = {};

			dimensions.search = {
				width: window.innerWidth / 3 - 2 * containerPadding,
				height: window.innerHeight - 2 * containerPadding
			};

			dimensions.areaChart = {
				width: window.innerWidth / 3 - 4 * containerPadding
			};

			dimensions.bottom = {
				height: window.innerHeight - headerHeight - 2 * containerPadding
			};

			this.setState({ dimensions: dimensions });
		}
	}, {
		key: 'searchDisplay',
		value: function searchDisplay() {
			var _this3 = this;

			var citiesOptions = _RasterStore2.default.getCityIdsAndNames(),
			    citiesData = _RasterStore2.default.getAllRasters();
			return citiesOptions.map(function (cityOption) {
				return {
					id: cityOption.id,
					cityName: cityOption.cityName,
					display: React.createElement(_CitySnippet2.default, {
						cityData: citiesData[cityOption.id],
						onCityClick: _this3.props.onCityClick,
						key: 'citySearch' + cityOption.id
					})
				};
			});
		}

		/* render and display methods */

	}, {
		key: 'renderSidebar',
		value: function renderSidebar() {
			var _this4 = this;

			var title = void 0,
			    content = void 0,
			    content2 = void 0,
			    theClass = void 0,
			    ADs = void 0,
			    ADsByCat = void 0;
			// if (AreaDescriptionsStore.data.areaDescriptions && AreaDescriptionsStore.data.areaDescriptions[this.state.selectedCity]) {
			// 	console.log(AreaDescriptionsStore.data.areaDescriptions[this.state.selectedCity].byCategory);
			// }
			if (this.state.selectedCity) {
				if (this.state.selectedNeighborhood) {
					ADs = _AreaDescriptionsStore2.default.getADsForNeighborhood(this.state.selectedCity, this.state.selectedNeighborhood);
				} else if (this.state.selectedCategory) {
					ADsByCat = _AreaDescriptionsStore2.default.getADsForCategory(this.state.selectedCity, this.state.selectedCategory);
				}
			}

			if (this.state.downloadOpen) {
				title = React.createElement(
					'h2',
					null,
					typeof _RasterStore2.default.getSelectedCityMetadata() != 'undefined' ? _RasterStore2.default.getSelectedCityMetadata().name : '',
					React.createElement('div', { className: 'downloadicon', href: '#', onClick: this.onDownloadClicked })
				);
				content = React.createElement(_Downloader2.default, { mapurl: _RasterStore2.default.getMapUrl(), name: _RasterStore2.default.getSelectedCityMetadata().name });
			} else if (this.state.selectedNeighborhood && ADs) {
				theClass = 'area';
				title = React.createElement(
					'h2',
					null,
					React.createElement(
						'span',
						null,
						_CityStore2.default.getName() + ', '
					),
					React.createElement(
						'span',
						{
							onClick: this.onStateSelected,
							id: _CityStore2.default.getState()
						},
						_CityStore2.default.getState()
					),
					React.createElement('div', { className: 'downloadicon', href: '#', onClick: this.onDownloadClicked })
				);
				content = React.createElement(_AreaDescription2.default, {
					areaId: this.state.selectedNeighborhood,
					previousAreaId: _AreaDescriptionsStore2.default.getPreviousHOLCId(this.state.selectedCity, this.state.selectedNeighborhood),
					nextAreaId: _AreaDescriptionsStore2.default.getNextHOLCId(this.state.selectedCity, this.state.selectedNeighborhood),
					areaDescriptions: ADs,
					formId: _CityStore2.default.getFormId(),
					cityId: this.state.selectedCity,
					onCategoryClick: this.onCategoryClick,
					onHOLCIDClick: this.onHOLCIDClick,
					ref: 'areadescription' + this.state.selectedNeighborhood
				});
			} else if (this.state.selectedCategory && ADsByCat) {
				var _state$selectedCatego = this.state.selectedCategory.split('-');

				var _state$selectedCatego2 = _slicedToArray(_state$selectedCatego, 2);

				var catNum = _state$selectedCatego2[0];
				var catLetter = _state$selectedCatego2[1];

				theClass = 'category';
				title = React.createElement(
					'h2',
					null,
					React.createElement(
						'span',
						null,
						_CityStore2.default.getName() + ', '
					),
					React.createElement(
						'span',
						{
							onClick: this.onStateSelected,
							id: _CityStore2.default.getState()
						},
						_CityStore2.default.getState()
					),
					React.createElement('div', { className: 'downloadicon', href: '#', onClick: this.onDownloadClicked })
				);
				content = React.createElement(_ADCat2.default, {
					ADsByCat: ADsByCat,
					formId: _AreaDescriptionsStore2.default.getFormId(this.state.selectedCity),
					title: _AreaDescriptionsStore2.default.getCatTitle(this.state.selectedCity, catNum, catLetter),
					catNum: catNum,
					catLetter: catLetter,
					previousCatIds: _AreaDescriptionsStore2.default.getPreviousCatIds(this.state.selectedCity, catNum, catLetter),
					nextCatIds: _AreaDescriptionsStore2.default.getNextCatIds(this.state.selectedCity, catNum, catLetter),
					cityId: this.state.selectedCity,
					onNeighborhoodClick: this.onHOLCIDClick,
					onCategoryClick: this.onCategoryClick,
					onNeighborhoodHover: this.neighborhoodHighlighted,
					onNeighborhoodOut: this.neighborhoodsUnhighlighted
				});
			} else if (this.state.selectedCity) {
				(function () {
					var visibleMaps = _MapStateStore2.default.getVisibleHOLCMaps();

					theClass = 'city';
					title = React.createElement(
						'h2',
						null,
						React.createElement(
							'span',
							null,
							_CityStore2.default.getName() + ', '
						),
						React.createElement(
							'span',
							{
								onClick: _this4.onStateSelected,
								id: _CityStore2.default.getState()
							},
							_CityStore2.default.getState()
						),
						React.createElement('div', { className: 'downloadicon', href: '#', onClick: _this4.onDownloadClicked })
					);
					content = React.createElement(_CityStats2.default, {
						cityData: _CityStore2.default.getCityData(),
						area: _AreaDescriptionsStore2.default.getArea(_this4.state.selectedCity),
						gradeStats: _CityStore2.default.getGradeStats(),
						ringStats: _CityStore2.default.getRingStats(),
						areaSelected: _this4.onBurgessChartHover,
						areaUnselected: _this4.onBurgessChartOff,
						gradeSelected: _this4.onAreaChartHover,
						gradeUnselected: _this4.onAreaChartOff,
						openBurgess: _this4.onModalClick,
						burgessDiagramVisible: _this4.state.burgessDiagramVisible,
						toggleBurgessDiagram: _this4.toggleBurgessDiagram,
						hasADs: _AreaDescriptionsStore2.default.hasADData(_this4.state.selectedCity)
					});
					if (Object.keys(visibleMaps).length >= 2) {
						content2 = React.createElement(
							'div',
							null,
							React.createElement(
								'h4',
								null,
								'Other Visible Maps'
							),
							Object.keys(visibleMaps).map(function (mapId) {
								if (visibleMaps[mapId].cityId !== _this4.state.selectedCity) {
									return React.createElement(_CitySnippet2.default, {
										cityData: visibleMaps[mapId],
										onCityClick: _this4.onCitySelected,
										key: 'city' + mapId,
										recenter: false
									});
								}
							})
						);
					}
				})();
			} else if (!this.state.selectedCity) {
				(function () {
					theClass = 'state';
					var visibleStates = _MapStateStore2.default.getVisibleHOLCMapsByState();
					if (_MapStateStore2.default.getVisibleHOLCMapsIds().length >= 2) {
						content = Object.keys(visibleStates).map(function (theState) {
							return React.createElement(_StateStats2.default, {
								stateName: _state_abbr2.default[theState],
								cities: visibleStates[theState],
								onCityClick: _this4.onCitySelected,
								key: theState,
								areaChartWidth: _this4.state.dimensions.areaChart.width
							});
						});
					}
				})();
			}

			return React.createElement(
				'div',
				{ className: theClass, key: theClass },
				title,
				content,
				content2
			);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this5 = this;

			//console.log(this.state);
			var modalStyle = {
				overlay: {
					backgroundColor: null
				},
				content: {
					top: null,
					left: null,
					right: null,
					bottom: null,
					border: null,
					background: null,
					borderRadius: null,
					padding: null,
					position: null
				}
			},
			    ADs = _AreaDescriptionsStore2.default.getVisible(),
			    aboveThreshold = _MapStateStore2.default.isAboveZoomThreshold(),
			    outerRadius = _CityStore2.default.getOuterRingRadius();

			var legendData = {
				items: ['A First Grade', 'B Second Grade', 'C Third Grade', 'D Third Grade']
			};
			if (!_MapStateStore2.default.isAboveZoomThreshold()) {
				legendData.items.push('Proportion of Each Grade');
			}

			//setIconDefaultImagePath('./static');

			return React.createElement(
				'div',
				{ className: 'container full-height' },
				React.createElement(_toolkit.Navigation, {
					show_menu: this.state.show_panorama_menu,
					on_hamburger_click: this.onPanoramaMenuClick,
					nav_data: _panorama_nav2.default.filter(function (item, i) {
						return item.url.indexOf('holc') === -1;
					})
				}),
				React.createElement(
					'div',
					{ className: 'row full-height' },
					React.createElement(
						'div',
						{ className: 'columns eight full-height' },
						React.createElement(
							'header',
							{ className: 'row u-full-width' },
							React.createElement(
								'h1',
								null,
								React.createElement(
									'span',
									{ className: 'header-main' },
									'Mapping Inequality'
								),
								React.createElement(
									'span',
									{ className: 'header-sub' },
									'Redlining in New Deal America'
								)
							),
							React.createElement(
								'h4',
								{ onClick: this.onModalClick, id: 'about' },
								'Introduction'
							),
							React.createElement(
								'h4',
								{ onClick: this.onModalClick, id: 'bibliograph' },
								'Bibliographic Notes & Bibliography'
							),
							React.createElement(
								'h4',
								{ onClick: this.onModalClick, id: 'credits' },
								'Credits'
							),
							React.createElement('hr', { className: 'style-eight' })
						),
						React.createElement(
							'div',
							{ className: 'row template-tile leaflet-container main-pane', style: { height: this.state.dimensions.bottom.height + 'px' } },
							React.createElement(
								_reactLeaflet.Map,
								{
									ref: 'the_map',
									center: this.state.map.center,
									zoom: this.state.map.zoom,
									onMoveend: this.onMapMoved,
									className: 'the_map'
								},
								_tileLayers2.default.layers.map(function (item, i) {
									return _this5.state.map.zoom < 10 ? React.createElement(_reactLeaflet.TileLayer, {
										key: 'noLabels',
										url: item.urlNoLabels,
										zIndex: -1
									}) : React.createElement(_reactLeaflet.TileLayer, {
										key: 'labels',
										url: item.urlLabels,
										zIndex: -1
									});
								}),
								_RasterStore2.default.getMapsList().map(function (item, i) {
									var mapBounds = _this5.refs.the_map.leafletElement.getBounds();
									if (mapBounds.intersects(item.bounds)) {
										return React.createElement(_reactLeaflet.TileLayer, {
											key: 'holctiles' + i,
											className: 'tilesForCity' + item.cityId,
											url: item.url,
											minZoom: item.minZoom,
											bounds: item.bounds,
											opacity: _this5.state.raster.opacity,
											zIndex: item.cityId == _this5.state.selectedCity ? 1 : null
										});
									}
								}),
								!aboveThreshold ? _basemaps2.default.layergroup.layers.map(function (item, i) {
									return React.createElement(_toolkit.CartoDBTileLayer, {
										key: 'cartodb-tile-layer-' + i,
										userId: _config2.default.userId,
										sql: item.options.sql,
										cartocss: item.options.cartocss,
										zIndex: 1000
									});
								}) : null,
								aboveThreshold && outerRadius > 0 ? React.createElement(_reactLeaflet.Circle, {
									center: _CityStore2.default.getLoopLatLng(),
									radius: outerRadius / 7,
									fillOpacity: this.state.selectedRingGrade.ringId >= 2 ? 0.75 : 0,
									fillColor: '#000',
									clickable: false,
									className: 'donuthole',
									key: 'donuthole'
								}) : null,
								aboveThreshold && outerRadius > 0 ? [2, 3, 4, 5].map(function (ringNum) {
									return React.createElement(_Donut2.default, {
										center: _CityStore2.default.getLoopLatLng(),
										innerRadius: (ringNum * 2 - 3) / 7 * outerRadius,
										outerRadius: ringNum == 5 ? outerRadius * 100 : (ringNum * 2 - 1) / 7 * outerRadius,
										clickable: false,
										fillOpacity: _this5.state.selectedRingGrade.ringId > 0 && ringNum !== _this5.state.selectedRingGrade.ringId ? 0.75 : 0,
										fillColor: '#000',
										weight: 1,
										className: 'donut',
										key: 'donut' + String(ringNum)
									});
								}) : null,
								aboveThreshold && this.state.selectedRingGrade.ringId > 0 ? React.createElement(
									_reactLeaflet.LayerGroup,
									null,
									React.createElement(_reactLeaflet.GeoJson, {
										data: _CityStore2.default.getInvertedGeoJsonForSelectedRingArea(this.state.selectedRingGrade.ringId, this.state.selectedRingGrade.grade),
										clickable: false,
										key: 'invertedRingStroke',
										fillColor: '#000',
										fillOpacity: 0.6,
										color: '#fff',
										weight: 2,
										opacity: 0.9,
										className: 'invertedRingGradedArea'
									}),
									React.createElement(_reactLeaflet.GeoJson, {
										data: _CityStore2.default.getGeoJsonForSelectedRingArea(this.state.selectedRingGrade.ringId, this.state.selectedRingGrade.grade),
										clickable: false,
										key: 'ringStroke',
										fillOpacity: (1 - this.state.raster.opacity) / 2,
										weight: 2,
										opacity: 0.9,
										className: 'ringGradedArea grade' + this.state.selectedRingGrade.grade
									})
								) : null,
								aboveThreshold && this.state.selectedGrade ? React.createElement(_AreaPolygon2.default, {
									data: _AreaDescriptionsStore2.default.getGeoJsonForGrade(this.state.selectedCity, this.state.selectedGrade),
									key: 'selectedGradedNeighborhoods',
									className: 'selectedGradedNeighborhoods grade' + this.state.selectedGrade
								}) : null,
								aboveThreshold && this.state.highlightedNeighborhood && ADs[this.state.selectedCity] && ADs[this.state.selectedCity][this.state.highlightedNeighborhood] && ADs[this.state.selectedCity][this.state.highlightedNeighborhood].area_geojson_inverted ? React.createElement(_AreaPolygon2.default, {
									data: ADs[this.state.selectedCity][this.state.highlightedNeighborhood].area_geojson_inverted,
									clickable: false,
									className: 'neighborhoodPolygonInverted grade' + ADs[this.state.selectedCity][this.state.highlightedNeighborhood].holc_grade,
									key: 'neighborhoodPolygonInverted' + this.state.highlightedNeighborhood
								}) : null,
								aboveThreshold && this.state.selectedNeighborhood && ADs[this.state.selectedCity] && ADs[this.state.selectedCity][this.state.selectedNeighborhood] && ADs[this.state.selectedCity][this.state.selectedNeighborhood].area_geojson_inverted ? React.createElement(_AreaPolygon2.default, {
									data: ADs[this.state.selectedCity][this.state.selectedNeighborhood].area_geojson_inverted,
									clickable: false,
									className: 'neighborhoodPolygonInverted grade' + ADs[this.state.selectedCity][this.state.selectedNeighborhood].holc_grade,
									key: 'neighborhoodPolygonInverted' + this.state.selectedNeighborhood
								}) : null,
								aboveThreshold ? Object.keys(ADs).map(function (adId) {
									return Object.keys(ADs[adId]).map(function (areaId) {
										return React.createElement(_AreaPolygon2.default, {
											data: ADs[adId][areaId].area_geojson,
											className: 'neighborhoodPolygon grade' + ADs[adId][areaId].holc_grade,
											key: 'neighborhoodPolygon' + areaId,
											onClick: _this5.onNeighborhoodPolygonClick,
											adId: adId,
											neighborhoodId: areaId
											//fillOpacity={ (id == this.state.selectedNeighborhood) ? 1 : 0 }
											, style: {
												opacity: _this5.state.selectedRingGrade.ringId > 0 ? (1 - _this5.state.raster.opacity) / 5 : (1 - _this5.state.raster.opacity) / 2,
												fillOpacity: _this5.state.selectedRingGrade.ringId > 0 ? 0 : (1 - _this5.state.raster.opacity) / 5
											}
										});
									});
								}) : null,
								!aboveThreshold ? _RasterStore2.default.getMapsList().map(function (item, i) {
									return item.radii ? Object.keys(item.radii).map(function (grade) {
										return item.radii[grade].inner == 0 ? React.createElement(_reactLeaflet.Circle, {
											center: [item.centerLat, item.centerLng],
											radius: item.radii[grade].outer,
											id: item.cityId,
											onClick: _this5.onCityMarkerSelected,
											key: 'clickableDonut' + item.cityId + grade,
											className: 'simpleDonut grade_' + grade
										}) : React.createElement(_Donut2.default, {
											center: [item.centerLat, item.centerLng],
											innerRadius: item.radii[grade].inner,
											outerRadius: item.radii[grade].outer,
											id: item.cityId,
											onClick: _this5.onCityMarkerSelected,
											key: 'clickableDonut' + item.cityId + grade,
											className: 'simpleDonut grade_' + grade
										});
									}) : !item.parent_id ? React.createElement(_reactLeaflet.Circle, {
										center: [item.centerLat, item.centerLng],
										radius: 25000,
										id: item.cityId,
										onClick: _this5.onCityMarkerSelected,
										key: 'clickableMap' + item.cityId,
										className: 'cityCircle '
									}) : null;
								}) : null,
								this.state.userLocation ? React.createElement(_reactLeaflet.Marker, { position: this.state.userLocation }) : null,
								React.createElement(_toolkit.Legend, _extends({}, legendData, { onItemSelected: this.onGradeHover }))
							),
							_TextsStore2.default.mainModalIsOpen() ? React.createElement(
								'div',
								{ className: 'longishform' },
								React.createElement(
									'button',
									{ className: 'close', onClick: this.onModalClick },
									React.createElement(
										'span',
										null,
										'×'
									)
								),
								React.createElement('div', { className: 'content', dangerouslySetInnerHTML: _TextsStore2.default.getModalContent() })
							) : null
						)
					),
					React.createElement(
						'div',
						{ className: 'opacitySlider' },
						React.createElement(_rcSlider2.default, {
							vertical: true,
							defaultValue: this.state.raster.opacity * 100,
							onAfterChange: this.onSliderChange
						})
					),
					React.createElement(
						'div',
						{ className: 'columns four full-height' },
						React.createElement(
							'div',
							{ className: 'row template-tile city-selector', style: { height: this.state.dimensions.search.height + 'px', width: this.state.dimensions.search.width + 'px' } },
							React.createElement(_reactTypeahead.Typeahead, {
								options: _RasterStore2.default.getMapsList(),
								placeholder: 'Search by city or state',
								filterOption: 'searchName',
								displayOption: function displayOption(city, i) {
									return city.cityId;
								},
								onOptionSelected: this.onCitySelected,
								customListComponent: _TypeAheadCitySnippet2.default,
								maxVisible: 8
							})
						),
						React.createElement(
							'div',
							{ className: 'row full-height template-tile dataViewer', style: { height: this.state.dimensions.bottom.height + 'px' } },
							this.renderSidebar()
						)
					),
					React.createElement(
						_reactModal2.default,
						{
							isOpen: false
							// isOpen={ TextsStore.mainModalIsOpen() }
							, style: modalStyle
						},
						React.createElement(
							'button',
							{ className: 'close', onClick: this.onModalClick },
							React.createElement(
								'span',
								null,
								'×'
							)
						),
						React.createElement('div', { dangerouslySetInnerHTML: _TextsStore2.default.getModalContent() })
					),
					React.createElement(
						_reactModal2.default,
						{
							isOpen: _UserLocationStore2.default.getOfferZoomTo(),
							style: modalStyle
						},
						React.createElement(
							'p',
							null,
							'Would you like to zoom to ',
							_UserLocationStore2.default.getCity(),
							'?'
						),
						React.createElement(
							'button',
							{ onClick: this.onUserCityResponse, value: 'yes' },
							'Sure'
						),
						React.createElement(
							'button',
							{ onClick: this.onUserCityResponse, value: 'no' },
							'No thanks'
						)
					)
				)
			);
		}
	}]);

	return App;
}(React.Component);

App.defaultProps = {
	somethingRequested: Object.keys(_toolkit.HashManager.getState()).reduce(function (a, b) {
		return typeof a !== 'undefined' && typeof _toolkit.HashManager.getState()[a] !== 'undefined' || typeof b !== 'undefined' && typeof _toolkit.HashManager.getState()[b] !== 'undefined';
	}, '')
};
exports.default = App;

},{"../basemaps/cartodb/basemaps.json":"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/cartodb/basemaps.json","../basemaps/cartodb/config.json":"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/cartodb/config.json","../basemaps/tileLayers.json":"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/tileLayers.json","../data/panorama_nav.json":"/Users/nayers/Documents/Panorama/panorama-holc/data/panorama_nav.json","../data/state_abbr.json":"/Users/nayers/Documents/Panorama/panorama-holc/data/state_abbr.json","./components/ADCat.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/ADCat.jsx","./components/AreaDescription.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/AreaDescription.jsx","./components/AreaPolygon.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/AreaPolygon.jsx","./components/CitySnippet.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/CitySnippet.jsx","./components/CityStats.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/CityStats.jsx","./components/Donut/Donut.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/Donut/Donut.jsx","./components/Downloader.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/Downloader.jsx","./components/StateStats.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/StateStats.jsx","./components/TypeAheadCitySnippet.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/TypeAheadCitySnippet.jsx","./stores/AreaDescriptionsStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/AreaDescriptionsStore.js","./stores/CityStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/CityStore.js","./stores/MapStateStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/MapStateStore.js","./stores/RasterStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/RasterStore.js","./stores/TextsStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/TextsStore.js","./stores/UserLocationStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/UserLocationStore.js","./utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","@panorama/toolkit":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/@panorama/toolkit/dist/components.min.js","leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js","rc-slider":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/rc-slider/lib/index.js","react":"react","react-leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/index.js","react-modal":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-modal/lib/index.js","react-typeahead":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-typeahead/lib/react-typeahead.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/ADCat.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ADCat = function (_React$Component) {
	_inherits(ADCat, _React$Component);

	// property validation

	function ADCat() {
		_classCallCheck(this, ADCat);

		// bind handlers

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ADCat).call(this));

		_this.render19370826_5c = _this.render19370203_5c;
		_this.render19370203_5d = _this.render19370203_5c;
		_this.render19370826_5d = _this.render19370203_5c;
		_this.render19370826_5g = _this.render19370203_5g;
		_this.render19370826_8a = _this.render19370203_8a;
		_this.render19370203_8b = _this.render19370203_8a;
		_this.render19370826_8b = _this.render19370203_8a;
		_this.render19370203_8c = _this.render19370203_8a;
		_this.render19370826_8c = _this.render19370203_8a;
		var handlers = ['render19370826_5c', 'render19370826_5c', 'render19370203_5d', 'render19370826_5d', 'render19370826_5g', 'render19370203_5g', 'render19370203_8a', 'render19370826_8a', 'render19370203_8b', 'render19370826_8b', 'render19370203_8c', 'render19370826_8c'];
		handlers.map(function (handler) {
			_this[handler] = _this[handler].bind(_this);
		});
		return _this;
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(ADCat, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.catNum !== this.props.catNum || nextProps.catLetter !== this.props.catLetter || nextProps.cityId !== this.props.cityId;
		}

		/* alphanum.js (C) Brian Huisman
  * Based on the Alphanum Algorithm by David Koelle
  * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
  *
  * Distributed under same license as original
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or any later version.
  * 
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  * 
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  */

	}, {
		key: 'alphanumCase',
		value: function alphanumCase(a, b) {
			function chunkify(t) {
				var tz = new Array();
				var x = 0,
				    y = -1,
				    n = 0,
				    i,
				    j;
				while (i = (j = t.charAt(x++)).charCodeAt(0)) {
					var m = i == 46 || i >= 48 && i <= 57;
					if (m !== n) {
						tz[++y] = '';
						n = m;
					}
					tz[y] += j;
				}
				return tz;
			}

			var aa = chunkify(a.toLowerCase());
			var bb = chunkify(b.toLowerCase());
			for (var x = 0; aa[x] && bb[x]; x++) {
				if (aa[x] !== bb[x]) {
					var c = Number(aa[x]),
					    d = Number(bb[x]);
					if (c == aa[x] && d == bb[x]) {
						return c - d;
					} else return aa[x] > bb[x] ? 1 : -1;
				}
			}
			return aa.length - bb.length;
		}
	}, {
		key: 'getCategoryString',
		value: function getCategoryString(catNum, catLetter) {
			return catNum + (catLetter ? '-' + catLetter : '');
		}
	}, {
		key: 'renderGrade',
		value: function renderGrade(grade) {
			var _this2 = this;

			var idiosyncraticDisplay = this['render' + this.props.formId + '_' + this.props.catNum + (this.props.catLetter ? this.props.catLetter : '')],
			    categoryData = this.props.ADsByCat;
			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'div',
					{ className: 'grade-header' + grade },
					_react2.default.createElement(
						'h2',
						null,
						grade
					)
				),
				_react2.default.createElement(
					'ul',
					{ className: 'area_description', ref: 'cat' + grade },
					Object.keys(categoryData).sort(this.alphanumCase).map(function (neighborhoodId) {
						if (grade == neighborhoodId.charAt(0)) {
							return _react2.default.createElement(
								'li',
								{
									key: 'cat' + grade + neighborhoodId,
									onClick: _this2.props.onNeighborhoodClick,
									onMouseEnter: _this2.props.onNeighborhoodHover,
									onMouseLeave: _this2.props.onNeighborhoodOut,
									id: neighborhoodId
								},
								_react2.default.createElement(
									'span',
									{ className: 'subcatName', id: neighborhoodId },
									neighborhoodId
								),
								':',
								typeof idiosyncraticDisplay === 'function' ? idiosyncraticDisplay(categoryData[neighborhoodId]) : _this2.renderDatum(categoryData[neighborhoodId])
							);
						}
					})
				)
			);
		}
	}, {
		key: 'renderDatum',
		value: function renderDatum(datum, neighborhoodId) {
			return _react2.default.createElement(
				'span',
				null,
				datum ? _react2.default.createElement(
					'span',
					{ className: 'subcatData' },
					datum
				) : _react2.default.createElement(
					'span',
					{ className: 'empty' },
					'empty'
				)
			);
		}
	}, {
		key: 'render19370203_5c',
		value: function render19370203_5c(data) {
			return _react2.default.createElement(
				'span',
				null,
				this.renderDatum(data[1]),
				'; ',
				this.renderDatum(data[2])
			);
		}
	}, {
		key: 'render19370203_5g',
		value: function render19370203_5g(data) {
			return _react2.default.createElement(
				'span',
				null,
				'Population is increasing ',
				this.renderDatum(data[1]),
				'; decreasing ',
				this.renderDatum(data[2]),
				'; static.'
			);
		}
	}, {
		key: 'render19370203_8a',
		value: function render19370203_8a(data) {
			return _react2.default.createElement(
				'span',
				null,
				this.renderDatum(data),
				'%'
			);
		}
	}, {
		key: 'render',
		value: function render() {

			var previousCat = this.props.previousCatIds,
			    nextCat = this.props.nextCatIds;

			return _react2.default.createElement(
				'div',
				{ className: 'ad-selection' },
				_react2.default.createElement(
					'ul',
					{ className: 'ad_cat' },
					_react2.default.createElement(
						'li',
						null,
						previousCat ? _react2.default.createElement('span', { className: 'left-arrow', onClick: this.props.onCategoryClick, id: this.getCategoryString.apply(this, _toConsumableArray(previousCat)) }) : ''
					),
					_react2.default.createElement(
						'li',
						null,
						previousCat ? _react2.default.createElement(
							'span',
							{ className: 'ad-left', onClick: this.props.onCategoryClick, id: this.getCategoryString.apply(this, _toConsumableArray(previousCat)) },
							previousCat[1] ? previousCat[0] + previousCat[1] : previousCat[0]
						) : ''
					),
					_react2.default.createElement(
						'li',
						null,
						nextCat ? _react2.default.createElement('span', { className: 'right-arrow', onClick: this.props.onCategoryClick, id: this.getCategoryString.apply(this, _toConsumableArray(nextCat)) }) : ''
					),
					_react2.default.createElement(
						'li',
						null,
						nextCat ? _react2.default.createElement(
							'span',
							{ className: 'ad-right', onClick: this.props.onCategoryClick, id: this.getCategoryString.apply(this, _toConsumableArray(nextCat)) },
							nextCat[1] ? nextCat[0] + nextCat[1] : nextCat[0]
						) : ''
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							'h4',
							null,
							this.props.title
						)
					)
				),
				this.renderGrade('A'),
				this.renderGrade('B'),
				this.renderGrade('C'),
				this.renderGrade('D')
			);
		}
	}]);

	return ADCat;
}(_react2.default.Component);

ADCat.propTypes = {};
ADCat.defaultProps = {
	catNum: undefined,
	catLetter: undefined
};
exports.default = ADCat;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/AreaDescription.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AreaDescription = function (_React$Component) {
	_inherits(AreaDescription, _React$Component);

	// property validation

	function AreaDescription() {
		_classCallCheck(this, AreaDescription);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(AreaDescription).call(this));
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(AreaDescription, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.areaId !== this.props.areaId || nextProps.cityId !== this.props.cityId;
		}
	}, {
		key: 'render',
		value: function render() {

			/* if (typeof(this.props.areaData) == 'undefined' || typeof(this.props.areaData.areaDesc) == 'undefined') {
   	return false;
   } */

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'ul',
					{ className: 'ad-selection' },
					this.props.previousAreaId ? _react2.default.createElement(
						'li',
						{ onClick: this.props.onHOLCIDClick, id: this.props.previousAreaId, className: 'ad-left' },
						'<' + this.props.previousAreaId
					) : '',
					this.props.nextAreaId ? _react2.default.createElement(
						'li',
						{ onClick: this.props.onHOLCIDClick, id: this.props.nextAreaId, className: 'ad-right' },
						this.props.nextAreaId + '>'
					) : '',
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							'h4',
							null,
							this.props.areaId
						)
					)
				),
				[19370203, 19370826].indexOf(parseInt(this.props.formId)) >= 0 ? this.renderNSForm8_19370203() : parseInt(this.props.formId) == 19371001 ? this.renderNSForm8_19371001() : null
			);
		}
	}, {
		key: 'renderNSForm8_19370203',
		value: function renderNSForm8_19370203() {
			var AD = this.props.areaDescriptions;

			return _react2.default.createElement(
				'ul',
				{ className: 'area_description NSForm8' },
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'1'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Name of City'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[1] && AD[1][1] ? AD[1][1] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						' Security Grade '
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[1] && AD[1][2] ? AD[1][2] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						' Area No. '
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[1] && AD[1][3] ? AD[1][3] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				this.renderSimpleCategory(2, 'Description of Terrain'),
				this.renderSimpleCategory(3, 'Favorable Influences'),
				this.renderSimpleCategory(4, 'Detrimental Influences'),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'5'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Inhabitants'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(5, 'a', 'Type'),
						this.renderSimpleSubcategory(5, 'b', 'Estimated annual family income'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: '5-c' },
								'c'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: '5-c' },
								'Foreign-born'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['c']['1'] ? AD[5]['c']['1'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								),
								'; ',
								AD[5] && AD[5]['c']['2'] ? AD[5]['c']['2'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: '5-d' },
								'd'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: '5-d' },
								'Negro'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['d']['1'] ? AD[5]['d']['1'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								),
								'; ',
								AD[5] && AD[5]['d']['2'] ? AD[5]['d']['2'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							)
						),
						this.renderSimpleSubcategory(5, 'e', 'Infiltration of'),
						this.renderSimpleSubcategory(5, 'f', 'Relief families'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: '5-g' },
								'g'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: '5-g' },
								'Population is increasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['g']['1'] ? AD[5]['g']['1'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatName' },
								'; decreasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								AD[5] && AD[5]['g']['2'] ? AD[5]['g']['2'] : _react2.default.createElement(
									'span',
									{ className: 'empty' },
									'empty'
								)
							),
							';',
							_react2.default.createElement(
								'span',
								{ className: 'subcatName' },
								'; static'
							)
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'6'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Buildings'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(6, 'a', 'Type or Types'),
						this.renderSimpleSubcategory(6, 'b', 'Type of construction'),
						this.renderSimpleSubcategory(6, 'c', 'Average age'),
						this.renderSimpleSubcategory(6, 'd', 'Repair')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'7'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'History'
					),
					_react2.default.createElement(
						'table',
						null,
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Sales Values'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Year'
								),
								_react2.default.createElement(
									'th',
									null,
									'Range'
								),
								_react2.default.createElement(
									'th',
									null,
									'Predominating'
								),
								_react2.default.createElement(
									'th',
									null,
									'%'
								)
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'1929 level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][1] ? AD[7][1] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][2] ? AD[7][2] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									'100%'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7][5],
									' level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][6] ? AD[7][6] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][7] ? AD[7][7] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][8] ? AD[7][8] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7][12],
									'  level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][13] ? AD[7][13] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][14] ? AD[7][14] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][15] ? AD[7][15] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							)
						)
					),
					_react2.default.createElement(
						'table',
						null,
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Rental Values'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'Year'
								),
								_react2.default.createElement(
									'th',
									null,
									'Range'
								),
								_react2.default.createElement(
									'th',
									null,
									'Predominating'
								),
								_react2.default.createElement(
									'th',
									null,
									'%'
								)
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									'1929 level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][3] ? AD[7][3] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][4] ? AD[7][4] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									'100%'
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7] && AD[7][5] ? AD[7][5] : '',
									' level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][9] ? AD[7][9] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][10] ? AD[7][10] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][11] ? AD[7][11] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									null,
									AD[7][12],
									'  level'
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][16] ? AD[7][16] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][17] ? AD[7][17] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									AD[7] && AD[7][18] ? AD[7][18] : _react2.default.createElement(
										'span',
										{ className: 'empty' },
										'empty'
									)
								)
							)
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'percentage' },
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'Peak Sales values occurred in'
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][19] ? AD[7][19] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							' and were '
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][20] ? AD[7][20] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'% of the 1929 level.'
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'percentage' },
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'Peak rental values occurred in'
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][21] ? AD[7][21] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							' and were '
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatData' },
							AD[7] && AD[7][22] ? AD[7][22] : _react2.default.createElement(
								'span',
								{ className: 'empty' },
								'empty'
							)
						),
						_react2.default.createElement(
							'span',
							{ className: 'subcatName' },
							'% of the 1929 level.'
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'8'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Occupancy'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(8, 'a', 'Land'),
						this.renderSimpleSubcategory(8, 'b', 'Dwelling units'),
						this.renderSimpleSubcategory(8, 'c', 'Home Owners')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'9'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Sales Demand'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(9, 'a', ''),
						this.renderSimpleSubcategory(9, 'b', ''),
						this.renderSimpleSubcategory(9, 'c', 'Activity is')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'10'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Rental Demand'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(10, 'a', ''),
						this.renderSimpleSubcategory(10, 'b', ''),
						this.renderSimpleSubcategory(10, 'c', 'Activity is')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'11'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'New Construction'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(11, 'a', 'Types'),
						this.renderSimpleSubcategory(11, 'b', 'Amount last year')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'12'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Availability of Mortgage Funds'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(12, 'a', 'Home purchase'),
						this.renderSimpleSubcategory(12, 'b', 'Home building')
					)
				),
				this.renderSimpleCategory(13, 'Trend of Desireability Next 10-15 Years'),
				this.renderSimpleCategory(14, 'Clarifying Remarks'),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'15'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Information for this form was obtained from'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[15] && typeof AD[15] == 'string' ? AD[15] : AD[15] && AD[15][1] ? AD[15][1] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				),
				_typeof(AD[15]) === 'object' ? _react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						'Date'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[15] && AD[15][2] ? AD[15][2] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName indent' },
						'193'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[15] && AD[15][3] ? AD[15][3] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				) : ''
			);
		}
	}, {
		key: 'renderNSForm8_19371001',
		value: function renderNSForm8_19371001() {
			var AD = this.props.areaDescriptions;
			return _react2.default.createElement(
				'ul',
				{ className: 'area_description NSForm8' },
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'1'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Area Characteristics'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(1, 'a', 'Description of Terrain'),
						this.renderSimpleSubcategory(1, 'b', 'Favorable Influences'),
						this.renderSimpleSubcategory(1, 'c', 'Detrimental Influences'),
						this.renderSimpleSubcategory(1, 'd', 'Percentage of land improved'),
						this.renderSimpleSubcategory(1, 'e', 'Trend of desireability next 10-15 yrs.')
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'2'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Inhabitants'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(2, 'a', 'Occupation'),
						this.renderSimpleSubcategory(2, 'b', 'Estimated Annual Family Income'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter' },
								'c'
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'Foreign-born families'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								this.renderSimpleData(2, 'c', 1)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'%;'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'c', 2)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'  predominating'
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter' },
								'd'
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'Negro'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								this.renderSimpleData(2, 'd', 1)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'%;'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'd', 2)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'  predominating'
							)
						),
						this.renderSimpleSubcategory(2, 'e', 'Infiltration of'),
						this.renderSimpleSubcategory(2, 'f', 'Relief families'),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'span',
								{ className: 'catLetter' },
								'g'
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'Population is increasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'g', 1)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'; decreasing'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'g', 2)
							),
							_react2.default.createElement(
								'span',
								{ className: 'catName' },
								'; static'
							),
							_react2.default.createElement(
								'span',
								{ className: 'subcatData' },
								' ',
								this.renderSimpleData(2, 'g', 3)
							)
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'3'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Buildings'
					),
					_react2.default.createElement(
						'table',
						null,
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement('th', null),
								_react2.default.createElement(
									'th',
									null,
									'Predominating ',
									this.renderSimpleData(3, null, 1),
									'%'
								),
								_react2.default.createElement(
									'th',
									null,
									'Other Type ',
									this.renderSimpleData(3, null, 2),
									'%'
								),
								_react2.default.createElement(
									'th',
									null,
									'Other Type ',
									this.renderSimpleData(3, null, 3),
									'%'
								)
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'a'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Type'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'a', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'a', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'a', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'b'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Construction'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'b', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'b', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'b', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'c'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Average age'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'c', 1),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Years'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'c', 2),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Years'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'c', 3),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Years'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'd'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Repair'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'd', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'd', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'd', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'e'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Occupancy'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'e', 1),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'e', 2),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'e', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'f'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Home Ownership'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'f', 1),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'f', 2),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'f', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'g'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Constructed past yr.'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'g', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'g', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'g', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'h'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'1929 Price range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'h', 1),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'h', 2),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'h', 3),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'i'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'i', 1),
										' Price range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'i', 2),
									' ',
									this.renderSimpleData(3, 'i', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'i', 4),
									' ',
									this.renderSimpleData(3, 'i', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'i', 6),
									' ',
									this.renderSimpleData(3, 'i', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'j'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'j', 1),
										' Price range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'j', 2),
									' ',
									this.renderSimpleData(3, 'j', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'j', 4),
									' ',
									this.renderSimpleData(3, 'j', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'j', 6),
									' ',
									this.renderSimpleData(3, 'j', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'k'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Sales demand Up to'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'k', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									'Up to ',
									this.renderSimpleData(3, 'k', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'k', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'l'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Activity'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'l', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'l', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'l', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'm'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'1929 Rent range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'm', 1),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'm', 2),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'm', 3),
									' ',
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'n'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'n', 1),
										' Rent range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'n', 2),
									' ',
									this.renderSimpleData(3, 'n', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'n', 4),
									' ',
									this.renderSimpleData(3, 'n', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'n', 6),
									' ',
									this.renderSimpleData(3, 'n', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'o'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										this.renderSimpleData(3, 'o', 1),
										' Rent range'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'o', 2),
									' ',
									this.renderSimpleData(3, 'o', 3),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'100%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'o', 4),
									' ',
									this.renderSimpleData(3, 'o', 5),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'$'
									),
									this.renderSimpleData(3, 'o', 6),
									' ',
									this.renderSimpleData(3, 'o', 7),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'%'
									)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'p'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Rental demand Up to'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'p', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									'Up to ',
									this.renderSimpleData(3, 'p', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'p', 3)
								)
							),
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									null,
									_react2.default.createElement(
										'span',
										{ className: 'catLetter' },
										'q'
									),
									_react2.default.createElement(
										'span',
										{ className: 'catName' },
										'Activity'
									)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'q', 1)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'q', 2)
								),
								_react2.default.createElement(
									'td',
									null,
									this.renderSimpleData(3, 'q', 3)
								)
							)
						)
					)
				),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'4'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Availability of Mortgage Funds'
					),
					_react2.default.createElement(
						'ul',
						null,
						this.renderSimpleSubcategory(4, 'a', 'Home purchase'),
						this.renderSimpleSubcategory(4, 'b', 'Home building')
					)
				),
				this.renderSimpleCategory(5, 'Clarifying Remarks'),
				_react2.default.createElement(
					'li',
					null,
					_react2.default.createElement(
						'span',
						{ className: 'catNum' },
						'6'
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Name and Location'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[6] && AD[6][1] ? AD[6][1] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Security Grade'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[6] && AD[6][2] ? AD[6][2] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Area No.'
					),
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						AD[6] && AD[6][3] ? AD[6][3] : _react2.default.createElement(
							'span',
							{ className: 'empty' },
							'empty'
						)
					)
				)
			);
		}
	}, {
		key: 'renderSimpleCategory',
		value: function renderSimpleCategory(catNum, catName) {
			var AD = this.props.areaDescriptions;

			return _react2.default.createElement(
				'li',
				{ key: 'AD-' + catNum },
				_react2.default.createElement(
					'span',
					{ className: 'catNum catSelectable', onClick: this.props.onCategoryClick, id: catNum },
					catNum
				),
				_react2.default.createElement(
					'span',
					{ className: 'catName catSelectable', onClick: this.props.onCategoryClick, id: catNum },
					catName
				),
				_react2.default.createElement(
					'span',
					{ className: 'catData' },
					AD[catNum] ? AD[catNum] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				)
			);
		}
	}, {
		key: 'renderSimpleSubcategory',
		value: function renderSimpleSubcategory(catNum, catLetter, subcatName) {
			var AD = this.props.areaDescriptions;

			if (_typeof(AD[catNum][catLetter]) == 'object') {
				console.warn(catNum + catLetter + ' is an object when a string was expected');
			}
			return _react2.default.createElement(
				'li',
				null,
				_react2.default.createElement(
					'span',
					{ className: 'catLetter catSelectable', onClick: this.props.onCategoryClick, id: catNum + '-' + catLetter },
					catLetter
				),
				_react2.default.createElement(
					'span',
					{ className: 'subcatName catSelectable', onClick: this.props.onCategoryClick, id: catNum + '-' + catLetter },
					subcatName
				),
				_react2.default.createElement(
					'span',
					{ className: 'subcatData' },
					AD[catNum] && AD[catNum][catLetter] && _typeof(AD[catNum][catLetter]) !== 'object' ? AD[catNum][catLetter] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				)
			);
		}
	}, {
		key: 'renderSimpleData',
		value: function renderSimpleData(catNum) {
			var subcatLetter = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
			var order = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

			var AD = this.props.areaDescriptions;
			if (order == null) {
				return _react2.default.createElement(
					'span',
					null,
					AD[catNum] && AD[catNum][subcatLetter] ? AD[catNum][subcatLetter] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				);
			} else if (subcatLetter == '') {
				return _react2.default.createElement(
					'span',
					null,
					AD[catNum] && AD[catNum][order] ? AD[catNum][order] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				);
			} else {
				return _react2.default.createElement(
					'span',
					null,
					AD[catNum] && AD[catNum][subcatLetter] && AD[catNum][subcatLetter][order] ? AD[catNum][subcatLetter][order] : _react2.default.createElement(
						'span',
						{ className: 'empty' },
						'empty'
					)
				);
			}
		}
	}]);

	return AreaDescription;
}(_react2.default.Component);

AreaDescription.propTypes = {
	areaDescriptions: _react.PropTypes.object
};
AreaDescription.defaultProps = {
	areaDescriptions: {}
};
exports.default = AreaDescription;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/AreaPolygon.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _reactLeaflet = require('react-leaflet');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AreaPolygon = function (_GeoJson) {
	_inherits(AreaPolygon, _GeoJson);

	function AreaPolygon() {
		_classCallCheck(this, AreaPolygon);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(AreaPolygon).apply(this, arguments));
	}

	_createClass(AreaPolygon, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			if (nextProps.data !== this.props.data) {
				this.leafletElement.clearLayers();
			}
			if (nextProps.className !== this.props.className) {
				this.leafletElement.options.className = nextProps.className;
			}

			if (nextProps.fillOpacity !== this.props.fillOpacity) {
				console.log(this.leafletElement);
				this.leafletElement.options.fillOpacity = nextProps.fillOpacity;
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (prevProps.data !== this.props.data) {
				this.leafletElement.addData(this.props.data);
			}
			this.setStyleIfChanged(prevProps.style, this.props.style);
		}
	}]);

	return AreaPolygon;
}(_reactLeaflet.GeoJson);

exports.default = AreaPolygon;


AreaPolygon.propTypes = {
	data: _react.PropTypes.object.isRequired
};

},{"react":"react","react-leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/CitySnippet.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _d = require('d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CitySnippet = function (_React$Component) {
	_inherits(CitySnippet, _React$Component);

	function CitySnippet() {
		_classCallCheck(this, CitySnippet);

		//this.d3Chart = this.d3Chart.bind(this);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CitySnippet).call(this));

		_this.d3PieChart = {
			radius: 30,

			update: function update(node, gradeStats) {
				if (Object.keys(gradeStats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;

				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#f4f570', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#A3A34B', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#f4f570', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var pie = d3.layout.pie().value(function (d) {
					return d.percent;
				}).sort(null);
				var arc = d3.svg.arc().outerRadius(scope.radius - 10).innerRadius(0);
				var percent = d3.format(',%');

				var theChart = d3.select(node).append('svg').attr('width', scope.radius * 2).attr('height', scope.radius * 2).attr('id', 'piechart').append('g').attr('transform', 'translate(' + scope.radius + ',' + scope.radius + ')');

				// theChart
				//   .selectAll('rect')
				//   .data(gradeStats)
				//   .enter().append('rect')
				//   //.attr('class', (d,i,j) => 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1))
				//   .attr('height', scope.HEIGHT)
				//   .attr('width', (d) => d.width)
				//   .attr('opacity', .7)
				//   .attr('y', 0)
				//   .attr('x', (d) => d.x + scope.MARGIN)
				//   .attr('fill', (d) => colorGrade(d.grade));

				theChart.selectAll('path').data(pie(gradeStats)).enter().append('path').attr("d", arc).filter(function (d) {
					return d.data.percent > 0;
				}).attr('fill', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('stroke-width', 0).attr('class', function (d) {
					return 'sliceGrade' + d.data.grade;
				});
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		_this.d3BarChart = {
			// layout constants
			WIDTH: 90,
			HEIGHT: 40,
			MARGIN: 24,

			update: function update(node, gradeStats) {
				var width = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

				if (Object.keys(gradeStats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;

				if (width) {
					//scope.WIDTH = width;
				}

				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#f4f570', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#A3A34B', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#CCCC00', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var percent = d3.format(',%');
				var width = d3.scale.linear().rangeRound([0, scope.WIDTH]);

				var x = 0;
				gradeStats.forEach(function (d, i) {
					gradeStats[i] = { x: x, width: width(d.percent), percent: d.percent, grade: d.grade };
					x += width(d.percent);
				});

				var theChart = d3.select(node).append('svg').attr('width', scope.WIDTH).attr('height', scope.HEIGHT + scope.MARGIN).attr('id', 'barchart').selectAll('g').data(gradeStats).enter().append('g');

				theChart.selectAll('rect').data(gradeStats).enter().append('rect')
				//.attr('class', (d,i,j) => 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1))
				.attr('height', scope.HEIGHT / 4 - 4).attr('width', function (d) {
					return d.width;
				}).attr('opacity', .7).attr('y', function (d, i) {
					return scope.MARGIN + scope.HEIGHT / 4 * i;
				}).attr('x', function (d) {
					return scope.WIDTH - d.width;
				}).attr('fill', function (d) {
					return colorGrade(d.grade);
				});

				// theChart
				//   .selectAll('text')
				//   .data(gradeStats)
				//   .enter().append('text')
				//   .attr('x', (d) => d.x + d.width / 2 + scope.MARGIN)
				//   .attr('y', 11)
				//   .attr('text-anchor', 'middle')
				//   .attr('font-family', 'sans-serif')
				//   .attr('font-size', '10px')
				//   .attr('fill', (d) => (d.grade == 'C') ? 'black' : 'white')
				//   .text((d) => (d.percent > 0.03) ? percent(d.percent) : '');
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		_this.d3Chart = {
			// layout constants
			WIDTH: _this.props && _this.props.areaChartWidth ? _this.props.areaChartWidth : 250,
			HEIGHT: 15,
			MARGIN: 20,

			update: function update(node, gradeStats) {
				var width = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

				if (Object.keys(gradeStats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;

				if (width) {
					//scope.WIDTH = width;
				}

				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#f4f570', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#A3A34B', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#f4f570', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var percent = d3.format(',%');
				var width = d3.scale.linear().rangeRound([0, scope.WIDTH]);

				var x = 0;
				gradeStats.forEach(function (d, i) {
					gradeStats[i] = { x: x, width: width(d.percent), percent: d.percent, grade: d.grade };
					x += width(d.percent);
				});

				var theChart = d3.select(node).append('svg').attr('width', scope.WIDTH + scope.MARGIN).attr('height', scope.HEIGHT).attr('id', 'barchart').selectAll('g').data(gradeStats).enter().append('g');

				theChart.selectAll('rect').data(gradeStats).enter().append('rect')
				//.attr('class', (d,i,j) => 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1))
				.attr('height', scope.HEIGHT).attr('width', function (d) {
					return d.width;
				}).attr('opacity', .7).attr('y', 0).attr('x', function (d) {
					return d.x + scope.MARGIN;
				}).attr('fill', function (d) {
					return colorGrade(d.grade);
				});

				theChart.selectAll('text').data(gradeStats).enter().append('text').attr('x', function (d) {
					return d.x + d.width / 2 + scope.MARGIN;
				}).attr('y', 11).attr('text-anchor', 'middle').attr('font-family', 'sans-serif').attr('font-size', '10px').attr('fill', function (d) {
					return d.grade == 'C' ? 'black' : 'white';
				}).text(function (d) {
					return d.percent > 0.03 ? percent(d.percent) : '';
				});
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		return _this;
	}
	// property validation


	_createClass(CitySnippet, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.cityData.city !== this.props.cityData.city;
		}
	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.cityData.hasPolygons) {
				//this.d3Chart.update(this.refs.barchart, this.parsePercents(), this.props.areaChartWidth);
				//this.d3PieChart.update(this.refs.piechart, this.parsePercents());
				this.d3BarChart.update(this.refs.barchart, this.parsePercents());
			}
		}
	}, {
		key: 'parsePercents',
		value: function parsePercents() {

			return this.props.cityData.hasPolygons ? [{ 'grade': 'A', 'percent': this.props.cityData.area.a / this.props.cityData.area.total }, { 'grade': 'B', 'percent': this.props.cityData.area.b / this.props.cityData.area.total }, { 'grade': 'C', 'percent': this.props.cityData.area.c / this.props.cityData.area.total }, { 'grade': 'D', 'percent': this.props.cityData.area.d / this.props.cityData.area.total }] : false;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'city-snippet',
					onClick: this.props.onCityClick,
					id: this.props.cityData.cityId
				},
				this.props.cityData.hasADs ? _react2.default.createElement(
					'h4',
					null,
					'area descriptions available'
				) : '',
				this.props.cityData.hasPolygons ? _react2.default.createElement('div', { className: 'barchart', ref: 'barchart' }) : null,
				_react2.default.createElement(
					'h3',
					null,
					this.props.cityData.city + (this.props.displayState ? ', ' + this.props.cityData.state : '')
				),
				_react2.default.createElement(
					'div',
					{ className: 'populationStats' },
					_react2.default.createElement(
						'span',
						{ className: 'catName' },
						'Population (1940):'
					),
					' ',
					_react2.default.createElement(
						'span',
						{ className: 'subcatData' },
						this.props.cityData.population_1940.toLocaleString()
					)
				),
				this.render_population_details()
			);
		}
	}, {
		key: 'render_population_details',
		value: function render_population_details() {
			var CD = this.props.cityData,
			    aggregated_pop = CD.white_pop_1940 + CD.black_pop_1940 + CD.asian_pacific_islander_1940 + CD.american_indian_eskimo_1940;
			if (aggregated_pop == 0) {
				return false;
			} else {
				var proportions = [{
					'label': 'white',
					'proportion': CD.white_pop_1940 / aggregated_pop
				}, {
					'label': 'African American',
					'proportion': CD.black_pop_1940 / aggregated_pop
				}, {
					'label': 'Asian American',
					'proportion': CD.asian_pacific_islander_1940 / aggregated_pop
				}, {
					'label': 'Native American',
					'proportion': CD.american_indian_eskimo_1940 / aggregated_pop
				}];
				proportions.sort(function (a, b) {
					return a.proportion < b.proportion;
				});
				return _react2.default.createElement(
					'ul',
					null,
					proportions.map(function (pop) {
						if (Math.round(pop.proportion * 100) !== 0) {
							return _react2.default.createElement(
								'li',
								{ key: 'pop1940' + pop.label.replace(/ /g, '') },
								Math.round(pop.proportion * 100) + '% ' + pop.label
							);
						}
					})
				);
			}
		}
	}]);

	return CitySnippet;
}(_react2.default.Component);

CitySnippet.propTypes = {
	cityData: _react.PropTypes.object
};
exports.default = CitySnippet;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","d3":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/d3/d3.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/CityStats.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _d = require('d3');

var d3 = _interopRequireWildcard(_d);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CityStats = function (_React$Component) {
	_inherits(CityStats, _React$Component);

	// property validation

	function CityStats(props) {
		_classCallCheck(this, CityStats);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CityStats).call(this, props));

		_this.d3SlopeChart = {
			width: 400,
			height: 125,
			gutterPercent: 40,
			gutterLabel: 50,
			margin: 20,

			update: function update(node, slopeChartData) {
				if (isNaN(slopeChartData[0].v30)) {
					this.destroy();
					return;
				}

				var scope = this;

				var max = d3.max(slopeChartData, function (d) {
					return d.v30 > d.v40 ? d.v30 : d.v40;
				}),
				    min = d3.min(slopeChartData, function (d) {
					return d.v30 < 0.01 && d.v40 < 0.01 ? 100 : d.v30 < d.v40 ? d.v30 : d.v40;
				});

				var scale = d3.scale.linear().domain([min, max]).range([scope.height - scope.margin, scope.margin]);

				var percent = d3.format(',%');

				var slopeChart = d3.select(node).append('svg').attr('width', scope.width).attr('height', scope.height).selectAll('g').data(slopeChartData).enter().append('g');

				slopeChart.selectAll('line').data(slopeChartData).enter().append('line').filter(function (d) {
					return d.v30 > 0.01 || d.v40 > 0.01;
				}).attr('y1', function (d, i) {
					return scale(d.v30);
				}).attr('y2', function (d, i) {
					return scale(d.v40);
				}).attr('x1', scope.gutterPercent + scope.gutterLabel).attr('x2', scope.width - (scope.gutterPercent + scope.gutterLabel)).attr('stroke', 'green');

				var labels30 = slopeChart.selectAll('text.labels30').data(slopeChartData).enter().append('text').filter(function (d) {
					return d.v30 > 0.01 || d.v40 > 0.01;
				}).attr('x', scope.gutterPercent + scope.gutterLabel).attr('y', function (d) {
					return scale(d.v30);
				}).style("text-anchor", "end").classed('labels30', true).text(function (d) {
					return percent(d.v30);
				});

				var labels40 = slopeChart.selectAll('text.labels40').data(slopeChartData).enter().append('text').filter(function (d) {
					return d.v30 > 0.01 || d.v40 > 0.01;
				}).attr('x', scope.width - (scope.gutterPercent + scope.gutterLabel)).attr('y', function (d) {
					return scale(d.v40);
				}).style("text-anchor", "start").classed('labels40', true).text(function (d) {
					return percent(d.v40);
				});

				var labels = slopeChart.selectAll('text.labels').data(slopeChartData).enter().append('text').filter(function (d) {
					return d.v30 > 0.01 || d.v40 > 0.01;
				}).attr('x', scope.width - scope.gutterLabel).attr('y', function (d) {
					return scale(d.v40);
				}).style("text-anchor", "start").classed('labels', true).text(function (d) {
					return d.label;
				});
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		_this.d3NestedPieChart = {
			// layout constants
			HEADER: 25,
			WIDTH: 250,
			DIAMETER: 250, // of the donut
			STATSHEIGHT: 18,
			DONUTWIDTH: 35,
			MARGIN: 10,

			update: function update(node, ringstats, gradeStats) {
				if (Object.keys(ringstats).length === 0) {
					this.destroy();
					return;
				}

				var scope = this;
				var color = function color(i) {
					return ['#418e41', '#4a4ae4', '#ffdf00', '#eb3f3f'][i];
				};
				var colorBorder = function colorBorder(i) {
					return ['#418e41', '#4a4ae4', '#ffdf00', '#eb3f3f'][i];
				};
				var colorGrade = function colorGrade(grade) {
					var gradeColors = { 'A': '#418e41', 'B': '#4a4ae4', 'C': '#ffdf00', 'D': '#eb3f3f' };
					return gradeColors[grade];
				};

				var pie = d3.layout.pie().value(function (d) {
					return d.percent;
				}).sort(null);
				var arc = d3.svg.arc().innerRadius(function (d) {
					return (d.data.ringId - 1.5) * scope.DONUTWIDTH;
				}).outerRadius(function (d) {
					return (d.data.ringId - 0.5) * scope.DONUTWIDTH;
				});
				var arcBorder = d3.svg.arc().innerRadius(function (d) {
					return (d.data.ringId - 0.5) * scope.DONUTWIDTH;
				}).outerRadius(function (d) {
					return (d.data.ringId - 0.5) * scope.DONUTWIDTH;
				});
				var percent = d3.format(',%');

				// <g> for each ring
				var ringNodes = d3.select(node).append('svg').attr('width', scope.WIDTH).attr('height', scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER).attr('id', 'piechart').selectAll('g').data(ringstats).enter().append('g');
				//.attr('transform', 'translate(' + (scope.WIDTH / 2) + ',' + (scope.HEIGHT / 2 + 50) + ')');

				// path for each pie piece
				var burgess = ringNodes.selectAll('path').data(function (d) {
					return pie(d.percents);
				}).enter().append('path').filter(function (d) {
					return d.data.percent > 0;
				}).attr('transform', 'translate(' + scope.WIDTH / 2 + ',' + (scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')').attr('d', arc).attr('fill', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('fill-opacity', function (d) {
					return d.data.opacity;
				}).attr('stroke', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('stroke-width', 0).attr('data-opacity', function (d) {
					return d.data.opacity;
				}).attr('class', function (d) {
					return 'sliceGrade' + d.data.grade;
				}).on('mouseover', function (d) {
					d3.select(this).transition().duration(2000).attr('fill-opacity', 1);
					d3.select('#ring' + d.data.ringId + 'grade' + d.data.grade).attr('opacity', 1);
					d3.selectAll('.areaBar').transition().duration(2000).attr('height', scope.STATSHEIGHT * 0.5).attr('y', scope.HEADER + scope.MARGIN + scope.STATSHEIGHT * 0.25).attr('opacity', .25);
					d3.selectAll('.barGrade' + d.data.grade).filter('.ring' + d.data.ringId).attr('height', scope.STATSHEIGHT).attr('y', scope.HEADER + scope.MARGIN).transition().duration(2000).attr('opacity', 1);
					d3.selectAll('.barGradePercent' + d.data.grade).filter('.ring' + d.data.ringId).transition().duration(500).attr('opacity', 1);
					d3.selectAll('.overallPercent').transition().attr('opacity', 0);
					scope.onHover(d.data.ringId, d.data.grade);
				}).on('mouseout', function (d) {
					scope.onHoverOut();
					d3.select(this).transition().attr('fill-opacity', function (d) {
						return d.data.opacity;
					});
					d3.select('#ring' + d.data.ringId + 'grade' + d.data.grade).attr('opacity', 0);
					d3.selectAll('.areaBar').transition().duration(2000).attr('height', scope.STATSHEIGHT).attr('y', scope.HEADER + scope.MARGIN).attr('opacity', .7);
					d3.selectAll('.areaBarPercent').transition().attr('opacity', 0);
					d3.selectAll('.overallPercent').transition().attr('opacity', 1);
				});

				// add thin stroke line for each slice of pies
				ringNodes.selectAll('path.border').data(function (d) {
					return pie(d.percents);
				}).enter().append('path').classed('border', true).attr('transform', 'translate(' + scope.WIDTH / 2 + ',' + (scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')').attr('d', arcBorder).attr('fill', function (d, i) {
					return color(i);
				}).attr('stroke', function (d, i) {
					return colorBorder(i);
				}).attr('stroke-width', 0.25).attr('stroke-opacity', 0.7);

				// a tranparent border around each slice
				// it's made opaque for highlighting and thus needs
				// to be added after the slice and the border
				ringNodes.selectAll('paths.sliceBorder').data(function (d) {
					return pie(d.percents);
				}).enter().append('path').filter(function (d) {
					return d.data.percent > 0;
				}).attr('transform', 'translate(' + scope.WIDTH / 2 + ',' + (scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')').attr('d', arc).attr('fill-opacity', 0).attr('stroke', function (d, i) {
					return colorGrade(d.data.grade);
				}).attr('stroke-width', 0).attr('pointer-events', 'none').attr('class', function (d) {
					return 'sliceBorder grade' + d.data.grade;
				});

				// add text for each slice of pie
				ringNodes.selectAll('text.burgessSlicePercent').data(function (d) {
					return pie(d.percents);
				}).enter().append('text').filter(function (d) {
					return d.data.percent > 0;
				}).attr('transform', function (d) {
					return 'translate(' + (arc.centroid(d)[0] + scope.WIDTH / 2) + ',' + (arc.centroid(d)[1] + scope.HEADER * 2 + scope.MARGIN * 5 + scope.STATSHEIGHT + scope.DIAMETER / 2) + ')';
				}).attr('text-anchor', 'middle').style('font', '11px Arial').attr('dy', 5.5).attr('opacity', 0).attr('id', function (d) {
					return 'ring' + d.data.ringId + 'grade' + d.data.grade;
				}).attr('class', function (d) {
					return 'burgessSlicePercent grade' + d.data.grade;
				}).attr('fill', function (d) {
					return d.data.grade == 'C' ? 'black' : 'white';
				}).attr('pointer-events', 'none').text(function (d) {
					return percent(d.value);
				});

				ringNodes.selectAll('rect').data(ringstats).enter().append('rect').attr('class', function (d, i, j) {
					return 'areaBar barGrade' + d.percents[j].grade + ' ring' + (i + 1);
				}).attr('height', scope.STATSHEIGHT).attr('width', function (d, i, j) {
					return Math.round(d.percents[j].overallPercent * scope.WIDTH);
				}).attr('opacity', .7).attr('y', scope.HEADER + scope.MARGIN).attr('x', function (d, i, j) {
					var x = 0;
					for (var j0 = 0; j0 <= 3; j0++) {
						for (var i0 = 0; i0 <= 3; i0++) {
							if (ringstats[j0].percents[i0].grade < d.percents[j].grade || ringstats[j0].percents[i0].grade == d.percents[j].grade && ringstats[j0].percents[i0].ringId < d.percents[j].ringId) {
								x += Math.round(ringstats[j0].percents[i0].overallPercent * scope.WIDTH);
							}
						}
					}
					return x;
				}).attr('fill', function (d, i, j) {
					return color(j);
				}).on('mouseover', function (d, i, j) {
					var grade = ['A', 'B', 'C', 'D'][j];
					d3.selectAll('.areaBar').transition().duration(1000).attr('opacity', .4);
					d3.selectAll('rect.barGrade' + grade).transition().duration(1000).attr('opacity', 1);
					d3.selectAll('.sliceBorder').filter('.grade' + grade).transition().duration(1000).attr('stroke-width', 5);
					d3.selectAll('.burgessSlicePercent').filter('.grade' + grade).filter(function (d) {
						return d.data.percent > .06;
					}).transition().attr('fill', 'black').attr('opacity', 1);
					scope.onGradeHover(grade);
				}).on('mouseout', function (d, i, j) {
					var grade = ['A', 'B', 'C', 'D'][j];
					d3.selectAll('.areaBar').transition().attr('opacity', .7);
					d3.selectAll('.sliceBorder').transition().attr('stroke-width', 0);
					d3.selectAll('.burgessSlicePercent').transition().attr('opacity', 0).attr('fill', function (d) {
						return d.data.grade == 'C' ? 'black' : 'white';
					});
					scope.onGradeHoverOut();
				});

				// percents for each of these slices in the area chart
				ringNodes.selectAll('text.slicePercent').data(ringstats).enter().append('text').attr('x', function (d, i, j) {
					var x = 0;
					for (var j0 = 0; j0 <= 3; j0++) {
						for (var i0 = 0; i0 <= 3; i0++) {
							if (ringstats[j0].percents[i0].grade < d.percents[j].grade || ringstats[j0].percents[i0].grade == d.percents[j].grade && ringstats[j0].percents[i0].ringId < d.percents[j].ringId) {
								x += Math.round(ringstats[j0].percents[i0].overallPercent * scope.WIDTH);
							}
						}
					}
					x += Math.round(d.percents[j].overallPercent * scope.WIDTH / 2);
					return x;
				}).attr('y', scope.HEADER + scope.MARGIN + 13).attr('class', function (d, i, j) {
					return 'areaBarPercent barGradePercent' + d.percents[j].grade + ' ring' + (i + 1);
				}).attr('pointer-events', 'none').attr('text-anchor', 'middle').attr('font-family', 'sans-serif').attr('font-size', '10px').attr('fill', function (d, i, j) {
					return d.percents[j].grade == 'C' ? 'black' : 'white';
				}).attr('opacity', 0).text(function (d, i, j) {
					return percent(d.percents[j].overallPercent);
				});

				ringNodes.selectAll('text.overallPercent').data(gradeStats).enter().append('text').attr('x', function (d, i) {
					var x = d.percent * scope.WIDTH / 2;
					for (var i0 = 0; i0 < i; i0++) {
						x += gradeStats[i0].percent * scope.WIDTH;
					}
					return x;
				}).attr('y', scope.HEADER + scope.MARGIN + 13).attr('pointer-events', 'none').attr('text-anchor', 'middle').attr('font-family', 'sans-serif').attr('font-size', '10px').attr('fill', function (d) {
					return d.grade == 'C' ? 'black' : 'white';
				}).classed('overallPercent', true).text(function (d) {
					return percent(d.percent);
				});

				ringNodes.append('text').attr('x', scope.WIDTH / 2).attr('y', scope.HEADER).attr('text-anchor', 'middle').text('Grading in Terms of Area');

				ringNodes.append('text').attr('x', scope.WIDTH / 2).attr('y', scope.HEADER + scope.MARGIN * 4 + scope.STATSHEIGHT).attr('text-anchor', 'middle').text('Grading & Density Outward');

				ringNodes.append('text').attr('x', scope.WIDTH / 2).attr('y', scope.HEADER * 2 + scope.MARGIN * 4 + scope.STATSHEIGHT).attr('text-anchor', 'middle').text('from City Center');

				d3.xml('static/burgess.svg').get(function (error, xml) {
					if (error) throw error;

					var burgessDiagram = ringNodes.node().appendChild(xml.documentElement);

					var innerSVG = ringNodes.select("svg");

					innerSVG.attr('x', -5).attr('y', 102);

					innerSVG.transition().duration(10000).attr('opacity', .35);
				});
			},

			onHover: function onHover() {
				// bound in componentDidMount to the areaSelected method of App (passed in as a props)
			},

			onHoverOut: function onHoverOut() {
				// bound in componentDidMount to the areaUnselected metthod of App
			},

			onGradeHover: function onGradeHover() {
				// bound in componentDidMount to the gradeSelected method of App (passed in as a props)
			},

			onGradeHoverOut: function onGradeHoverOut() {
				// bound in componentDidMount to the gradeUnselected metthod of App
			},

			destroy: function destroy(node) {
				d3.select(node).html('');
			}
		};
		return _this;
	}

	// (instead of ES5-style getDefaultProps)


	_createClass(CityStats, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps, nextState) {
			// don't know why this is necessary, but the component is updating on mouseover--this prevents that.
			return nextProps.burgessDiagramVisible !== this.props.burgessDiagramVisible || nextProps.ringStats !== this.props.ringStats;
		}
	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.d3NestedPieChart.onHover = this.props.areaSelected.bind(this);
			this.d3NestedPieChart.onHoverOut = this.props.areaUnselected.bind(this);
			this.d3NestedPieChart.onGradeHover = this.props.gradeSelected.bind(this);
			this.d3NestedPieChart.onGradeHoverOut = this.props.gradeUnselected.bind(this);
			if (this.props.ringStats) {
				this.d3NestedPieChart.update(this.refs.content, this.props.ringStats, this.props.gradeStats);
				//this.d3SlopeChart.update(this.refs.slopeChart, this.getSlopeChartData());
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			this.d3NestedPieChart.destroy(this.refs.content);
			//this.d3NestedPieChart.destroy(this.refs.slopeChart);
			this.d3NestedPieChart.onHover = this.props.areaSelected.bind(this);
			this.d3NestedPieChart.onHoverOut = this.props.areaUnselected.bind(this);
			if (this.props.ringStats) {
				this.d3NestedPieChart.update(this.refs.content, this.props.ringStats, this.props.gradeStats);
				this.d3SlopeChart.update(this.refs.slopeChart, this.getSlopeChartData());
			}
		}
	}, {
		key: 'areaHover',
		value: function areaHover(selectedRingId, selectedGrade) {
			_AppActionCreator.AppActions.ringAreaSelected(selectedRingId, selectedGrade);
		}
	}, {
		key: 'getPopLabel',
		value: function getPopLabel(key) {
			var labels = {
				white: 'white',
				black: 'African American',
				asianAmerican: 'Asian American',
				nativeAmerican: 'Native American'
			};

			return labels[key];
		}
	}, {
		key: 'getSlopeChartData',
		value: function getSlopeChartData() {
			var CD = this.props.cityData,
			    aggregated_pop_1930 = CD.white_pop_1930 + CD.black_pop_1930 + CD.asian_pacific_ilslander_1930 + CD.american_indian_eskimo_1930,
			    aggregated_pop_1940 = CD.white_pop_1940 + CD.black_pop_1940 + CD.asian_pacific_ilslander_1940 + CD.american_indian_eskimo_1940,
			    popStats = {
				1930: {
					total: this.props.cityData.population_1930 && this.props.cityData.population_1930 !== 0 ? this.props.cityData.population_1930 : null,
					white: CD.white_pop_1930 / aggregated_pop_1930,
					black: CD.black_pop_1930 / aggregated_pop_1930,
					asianAmerican: CD.asian_pacific_ilslander_1930 / aggregated_pop_1930,
					nativeAmerican: CD.american_indian_eskimo_1930 / aggregated_pop_1930
				},
				1940: {
					total: this.props.cityData.population_1940 && this.props.cityData.population_1940 !== 0 ? this.props.cityData.population_1940 : null,
					white: CD.white_pop_1940 / aggregated_pop_1940,
					black: CD.black_pop_1940 / aggregated_pop_1940,
					asianAmerican: CD.asian_pacific_ilslander_1940 / aggregated_pop_1940,
					nativeAmerican: CD.american_indian_eskimo_1940 / aggregated_pop_1940
				}
			},
			    slopeChartData = [{ label: 'white', v30: popStats[1930].white, v40: popStats[1940].white }, { label: 'black', v30: popStats[1930].black, v40: popStats[1940].black }, { label: 'asianAmerican', v30: popStats[1930].asianAmerican, v40: popStats[1940].asianAmerican }, { label: 'nativeAmerican', v30: popStats[1930].nativeAmerican, v40: popStats[1940].nativeAmerican }
			// data: [
			// 	[popStats[1930].white, popStats[1930].black, popStats[1930].asianAmerican, popStats[1930].nativeAmerican],
			// 	[popStats[1940].white, popStats[1940].black, popStats[1940].asianAmerican, popStats[1940].nativeAmerican],
			// ],
			// label: [['white', 'African American', 'Asian American', 'Native American']]

			];

			return slopeChartData;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var burgessClassName = this.props.burgessDiagramVisible ? '' : 'hidden',
			    population1930 = this.props.cityData.population_1930 && this.props.cityData.population_1930 !== 0 ? this.props.cityData.population_1930.toLocaleString() : null,
			    population1940 = this.props.cityData.population_1940 && this.props.cityData.population_1940 !== 0 ? this.props.cityData.population_1940.toLocaleString() : null,
			    area = this.props.area ? Math.round(this.props.area * 100) / 100 + 'sq mi' : '';

			var CD = this.props.cityData,
			    aggregated_pop_1930 = CD.white_pop_1930 + CD.black_pop_1930 + CD.asian_pacific_ilslander_1930 + CD.american_indian_eskimo_1930,
			    aggregated_pop_1940 = CD.white_pop_1940 + CD.black_pop_1940 + CD.asian_pacific_ilslander_1940 + CD.american_indian_eskimo_1940,
			    popStats = {
				1930: {
					//total: (this.props.cityData.population_1930 && this.props.cityData.population_1930 !== 0) ? this.props.cityData.population_1930 : null,
					white: CD.white_pop_1930 / aggregated_pop_1930,
					black: CD.black_pop_1930 / aggregated_pop_1930,
					asianAmerican: CD.asian_pacific_ilslander_1930 / aggregated_pop_1930,
					nativeAmerican: CD.american_indian_eskimo_1930 / aggregated_pop_1930
				},
				1940: {
					//total: (this.props.cityData.population_1940 && this.props.cityData.population_1940 !== 0) ? this.props.cityData.population_1940 : null,
					white: CD.white_pop_1940 / aggregated_pop_1940,
					black: CD.black_pop_1940 / aggregated_pop_1940,
					asianAmerican: CD.asian_pacific_ilslander_1940 / aggregated_pop_1940,
					nativeAmerican: CD.american_indian_eskimo_1940 / aggregated_pop_1940
				}
			},
			    slopeChartData = {
				data: [[popStats[1930].white, popStats[1930].black, popStats[1930].asianAmerican, popStats[1930].nativeAmerican], [popStats[1940].white, popStats[1940].black, popStats[1940].asianAmerican, popStats[1940].nativeAmerican]],
				label: [['white', 'African American', 'Asian American', 'Native American']]
			};

			var orderedKeys = Object.keys(popStats[1940]).sort(function (a, b) {
				return popStats[1940][a] < popStats[1940][b];
			});

			return _react2.default.createElement(
				'div',
				{ className: 'cityStats' },
				this.props.hasADs ? _react2.default.createElement(
					'div',
					{ className: 'adInstructions' },
					'click on neighborhoods on the map to read their area description'
				) : _react2.default.createElement(
					'div',
					{ className: 'adInstructions' },
					'area descriptions aren\'t available for this city, but will be soon'
				),
				_react2.default.createElement(
					'table',
					{ className: 'population-stats' },
					_react2.default.createElement(
						'tbody',
						null,
						_react2.default.createElement(
							'tr',
							null,
							_react2.default.createElement('th', null),
							_react2.default.createElement(
								'th',
								null,
								'1930'
							),
							_react2.default.createElement(
								'th',
								null,
								'1940'
							)
						),
						_react2.default.createElement(
							'tr',
							null,
							_react2.default.createElement(
								'td',
								null,
								'Population'
							),
							_react2.default.createElement(
								'td',
								{ className: 'total', key: 'total1930' },
								population1930
							),
							_react2.default.createElement(
								'td',
								{ className: 'total', key: 'total1940' },
								population1940
							)
						),
						orderedKeys.map(function (popkey) {
							return popStats[1930][popkey] > 0.01 || popStats[1930][popkey] > 0.01 ? _react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'td',
									{ key: popkey + 'label' },
									_this2.getPopLabel(popkey)
								),
								_react2.default.createElement(
									'td',
									{ key: popkey + '1930' },
									Math.round(popStats[1930][popkey] * 1000) / 10 + '%'
								),
								_react2.default.createElement(
									'td',
									{ key: popkey + '1940' },
									Math.round(popStats[1940][popkey] * 1000) / 10 + '%'
								)
							) : null;
						})
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'nestedpiechart' },
					_react2.default.createElement(
						'button',
						{
							className: 'intro-button'

						},
						_react2.default.createElement('span', { className: 'icon info', id: 'burgess', onClick: this.props.openBurgess })
					),
					this.props.ringStats ? _react2.default.createElement('div', { className: 'content', ref: 'content' }) : _react2.default.createElement(
						'p',
						null,
						'Area descriptions are not yet available but will be eventually.'
					),
					_react2.default.createElement('img', { src: 'static/burgess.png', className: burgessClassName, ref: 'burgessDiagram', id: 'burgessDiagram' })
				)
			);
		}
	}, {
		key: 'render_population_1930',
		value: function render_population_1930() {
			var CD = this.props.cityData,
			    aggregated_pop = CD.white_pop_1930 + CD.black_pop_1930 + CD.asian_pacific_ilslander_1930 + CD.american_indian_eskimo_1930;
			if (aggregated_pop == 0) {
				return false;
			} else {
				var proportions = [{
					'label': 'white',
					'proportion': CD.white_pop_1930 / aggregated_pop
				}, {
					'label': 'African American',
					'proportion': CD.black_pop_1930 / aggregated_pop
				}, {
					'label': 'Asian American',
					'proportion': CD.asian_pacific_ilslander_1930 / aggregated_pop
				}, {
					'label': 'Native American',
					'proportion': CD.american_indian_eskimo_1930 / aggregated_pop
				}];
				proportions.sort(function (a, b) {
					return a.proportion < b.proportion;
				});
				return _react2.default.createElement(
					'ul',
					null,
					proportions.map(function (pop) {
						if (Math.round(pop.proportion * 100) !== 0) {
							return _react2.default.createElement(
								'li',
								{ key: 'pop1930' + pop.label.replace(/ /g, '') },
								Math.round(pop.proportion * 10) * 10 + '% ' + pop.label
							);
						}
					})
				);
			}
		}
	}, {
		key: 'render_population_1940',
		value: function render_population_1940() {
			var CD = this.props.cityData,
			    aggregated_pop = CD.white_pop_1940 + CD.black_pop_1940 + CD.asian_pacific_ilslander_1940 + CD.american_indian_eskimo_1940;
			if (aggregated_pop == 0) {
				return false;
			} else {
				var proportions = [{
					'label': 'white',
					'proportion': CD.white_pop_1940 / aggregated_pop
				}, {
					'label': 'African American',
					'proportion': CD.black_pop_1940 / aggregated_pop
				}, {
					'label': 'Asian American',
					'proportion': CD.asian_pacific_ilslander_1940 / aggregated_pop
				}, {
					'label': 'Native American',
					'proportion': CD.american_indian_eskimo_1940 / aggregated_pop
				}];
				proportions.sort(function (a, b) {
					return a.proportion < b.proportion;
				});
				return _react2.default.createElement(
					'ul',
					null,
					proportions.map(function (pop) {
						if (Math.round(pop.proportion * 100) !== 0) {
							return _react2.default.createElement(
								'li',
								{ key: 'pop1940' + pop.label.replace(/ /g, '') },
								Math.round(pop.proportion * 10) * 10 + '% ' + pop.label
							);
						}
					})
				);
			}
		}
	}]);

	return CityStats;
}(_react2.default.Component);

CityStats.propTypes = {
	ringStats: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.bool]),
	gradeStats: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.bool]),
	areaSelected: _react.PropTypes.func,
	areaUnselected: _react.PropTypes.func,
	gradeSelected: _react.PropTypes.func,
	gradeUnselected: _react.PropTypes.func,
	toggleBurgessDiagram: _react.PropTypes.func,
	burgessDiagramVisible: _react.PropTypes.bool,
	cityData: _react.PropTypes.object
};
CityStats.defaultProps = {
	name: '',
	ringStats: {
		1: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 },
		2: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 },
		3: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 },
		4: { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'density': 0 }
	},
	gradeStats: {
		'A': { 'area': 0, 'percent': 0 },
		'B': { 'area': 0, 'percent': 0 },
		'C': { 'area': 0, 'percent': 0 },
		'D': { 'area': 0, 'percent': 0 }
	}
};
exports.default = CityStats;
;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","d3":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/d3/d3.js","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/Donut/Donut.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactLeaflet = require('react-leaflet');

var _LDonut = require('./L.Donut.js');

var _LDonut2 = _interopRequireDefault(_LDonut);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Donut = function (_Path) {
	_inherits(Donut, _Path);

	// Radii are in meters

	function Donut() {
		_classCallCheck(this, Donut);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(Donut).call(this));
	}

	_createClass(Donut, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			var _props = this.props;
			var center = _props.center;
			var outerRadius = _props.outerRadius;
			var innerRadius = _props.innerRadius;

			var props = _objectWithoutProperties(_props, ['center', 'outerRadius', 'innerRadius']);

			_get(Object.getPrototypeOf(Donut.prototype), 'componentWillMount', this).call(this);
			this.leafletElement = new _LDonut2.default(center, outerRadius, innerRadius, props);
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (this.props.center !== prevProps.center) {
				this.leafletElement.setLatLng(this.props.center);
			}

			if (this.props.outerRadius !== prevProps.outerRadius || this.props.innerRadius !== prevProps.innerRadius) {
				this.leafletElement.setRadius(this.props.outerRadius, this.props.innerRadius);
			}

			this.setStyleIfChanged(prevProps, this.props);
		}
	}]);

	return Donut;
}(_reactLeaflet.Path);

Donut.propTypes = {
	center: _reactLeaflet.PropTypes.latlng.isRequired,
	outerRadius: _react.PropTypes.number.isRequired,
	innerRadius: _react.PropTypes.number.isRequired
};
Donut.defaultProps = {};
exports.default = Donut;

},{"./L.Donut.js":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/Donut/L.Donut.js","react":"react","react-leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/react-leaflet/lib/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/Donut/L.Donut.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _leaflet = require('leaflet');

var L = _interopRequireWildcard(_leaflet);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Donut = function (L) {

	return L.Circle.extend({

		initialize: function initialize(latlng, outerRadius, innerRadius, options) {
			L.Path.prototype.initialize.call(this, options);

			this._latlng = L.latLng(latlng);
			this._mOuterRadius = outerRadius;
			this._mInnerRadius = this._validateInnerRadius(outerRadius, innerRadius);
		},

		setRadius: function setRadius(outerRadius, innerRadius) {
			this._mOuterRadius = outerRadius;
			this._mInnerRadius = this._validateInnerRadius(outerRadius, innerRadius);
			return this.redraw();
		},

		projectLatlngs: function projectLatlngs() {
			var lngRadius = this._getLngRadius(),
			    latlng = this._latlng,
			    outerPointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius[0]]),
			    innerPointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius[1]]);

			this._point = this._map.latLngToLayerPoint(latlng);
			this._outerRadius = Math.max(this._point.x - outerPointLeft.x, 1);
			this._innerRadius = Math.max(this._point.x - innerPointLeft.x, 1);
		},

		getBounds: function getBounds() {
			var lngRadius = this._getLngRadius()[0],
			    latRadius = this._getLatRadius()[0],
			    latlng = this._latlng;

			return new L.LatLngBounds([latlng.lat - latRadius, latlng.lng - lngRadius], [latlng.lat + latRadius, latlng.lng + lngRadius]);
		},

		getRadius: function getRadius() {
			return [this._mOuterRadius, this._mInnerRadius];
		},

		_getLatRadius: function _getLatRadius() {
			return [this._mOuterRadius / 40075017 * 360, this._mInnerRadius / 40075017 * 360];
		},

		_getLngRadius: function _getLngRadius() {
			var radii = this._getLatRadius();

			return [radii[0] / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat), radii[1] / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat)];
		},

		_checkIfEmpty: function _checkIfEmpty() {
			if (!this._map) {
				return false;
			}

			var vp = this._map._pathViewport,
			    outerRadius = this._outerRadius,
			    p = this._point;

			return p.x - outerRadius > vp.max.x || p.y - outerRadius > vp.max.y || p.x + outerRadius < vp.min.x || p.y + outerRadius < vp.min.y;
		},

		_validateInnerRadius: function _validateInnerRadius(outer, inner) {
			if (inner >= outer) return outer - 1;
			return inner;
		},

		getArc: function getArc(pt, outerRadius, innerRadius) {
			var x2 = pt.x - 0.01;
			var y1 = pt.y - outerRadius;
			var y2 = pt.y - innerRadius;

			return ['M', pt.x, y1, 'A', outerRadius, outerRadius, 0, 1, 1, x2, y1, 'M', x2, y2, 'A', innerRadius, innerRadius, 0, 1, 0, pt.x, y2, 'Z'].join(' ');
		},

		getPathString: function getPathString() {
			var p = this._point,
			    outerRadius = this._outerRadius,
			    innerRadius = this._innerRadius;

			if (this._checkIfEmpty()) {
				return '';
			}

			if (L.Browser.svg) {
				return this.getArc(p, outerRadius, innerRadius);
			} else {
				// TODO: VML Donut path
				p._round();
				r = Math.round(r);
				return 'AL ' + p.x + ',' + p.y + ' ' + outerRadius + ',' + outerRadius + ' 0,' + 65535 * 360;
			}
		}
	});
}(L);

exports.default = Donut;

},{"leaflet":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/leaflet/dist/leaflet-src.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/Downloader.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Downloader = function (_React$Component) {
	_inherits(Downloader, _React$Component);

	function Downloader() {
		_classCallCheck(this, Downloader);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(Downloader).call(this));
	}
	// property validation


	_createClass(Downloader, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'download_menu' },
				_react2.default.createElement(
					'ul',
					null,
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							'h3',
							null,
							_react2.default.createElement(
								'a',
								{ href: this.props.mapurl, download: this.props.name + 'HOLCMap.jpg' },
								'Download HOLC map'
							)
						),
						_react2.default.createElement('img', { src: this.props.mapThumbnail })
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							'h3',
							null,
							_react2.default.createElement(
								'a',
								{ href: this.props.mapurl, download: this.props.name + 'HOLCMap.jpg' },
								'Download HOLC area description'
							)
						),
						_react2.default.createElement('img', { src: this.props.mapThumbnail })
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							'h3',
							null,
							_react2.default.createElement(
								'a',
								{ href: this.props.mapurl, download: this.props.name + 'HOLCMap.jpg' },
								'Download HOLC georeferenced map'
							)
						),
						_react2.default.createElement('img', { src: this.props.mapThumbnail })
					)
				)
			);
		}
	}]);

	return Downloader;
}(_react2.default.Component);

Downloader.propTypes = {
	mapurl: _react.PropTypes.string,
	name: _react.PropTypes.string
};
exports.default = Downloader;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/StateStats.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CitySnippet = require('./CitySnippet.jsx');

var _CitySnippet2 = _interopRequireDefault(_CitySnippet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StateStats = function (_React$Component) {
	_inherits(StateStats, _React$Component);

	function StateStats() {
		_classCallCheck(this, StateStats);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(StateStats).call(this));
	}
	// property validation


	_createClass(StateStats, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'h2',
					null,
					this.props.stateName
				),
				this.props.cities.map(function (cityData) {
					return _react2.default.createElement(_CitySnippet2.default, {
						cityData: cityData,
						onCityClick: _this2.props.onCityClick,
						key: 'city' + cityData.cityId,
						areaChartWidth: _this2.props.areaChartWidth
					});
				})
			);
		}
	}]);

	return StateStats;
}(_react2.default.Component);

StateStats.propTypes = {
	stateName: _react.PropTypes.string
};
exports.default = StateStats;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","./CitySnippet.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/CitySnippet.jsx","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/components/TypeAheadCitySnippet.jsx":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CitySnippet = require('./CitySnippet.jsx');

var _CitySnippet2 = _interopRequireDefault(_CitySnippet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TypeAheadCitySnippet = function (_React$Component) {
	_inherits(TypeAheadCitySnippet, _React$Component);

	function TypeAheadCitySnippet() {
		_classCallCheck(this, TypeAheadCitySnippet);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(TypeAheadCitySnippet).call(this));
	}

	_createClass(TypeAheadCitySnippet, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				'div',
				null,
				this.props.options.map(function (cityData) {
					return _react2.default.createElement(_CitySnippet2.default, { cityData: cityData, onCityClick: _this2.props.onOptionSelected, displayState: true, key: 'city' + cityData.cityId });
				})
			);
		}
	}]);

	return TypeAheadCitySnippet;
}(_react2.default.Component);

exports.default = TypeAheadCitySnippet;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","./CitySnippet.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/components/CitySnippet.jsx","react":"react"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/main.jsx":[function(require,module,exports){
'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _App = require('./App.jsx');

var _App2 = _interopRequireDefault(_App);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//process.env.NODE_ENV = 'development';
//import Perf from 'react-addons-perf';
//window.Perf = Perf;

//Perf.start();

_reactDom2.default.render(_react2.default.createElement(_App2.default, null), document.getElementById('app-container'));
//Perf.stop();
//Perf.printWasted();

},{"./App.jsx":"/Users/nayers/Documents/Panorama/panorama-holc/src/App.jsx","react":"react","react-dom":"react-dom"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/AreaDescriptionsStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

var _formsMetadata = require('../../data/formsMetadata.json');

var _formsMetadata2 = _interopRequireDefault(_formsMetadata);

var _MapStateStore = require('../stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AreaDescriptionsStore = {

	data: {
		adIds: [],
		areaDescriptions: {}
	},

	dataLoader: _CartoDBLoader2.default,

	loadData: function loadData(adIds) {
		var _this = this;

		this.data.adIds = adIds.map(function (adId) {
			return parseInt(adId);
		});

		// create queries for those that aren't already in memory
		var queries = [];
		adIds.forEach(function (adId) {
			if (!_this.data.areaDescriptions[adId]) {
				queries.push({
					query: 'SELECT holc_ads.city_id as ad_id, form_id, holc_id, holc_grade, polygon_id, cat_id, sub_cat_id, _order as order, data, ST_asgeojson (holc_polygons.the_geom, 4) as the_geojson, st_xmin(st_envelope(digitalscholarshiplab.holc_polygons.the_geom)) as bbxmin, st_ymin(st_envelope(digitalscholarshiplab.holc_polygons.the_geom)) as bbymin, st_xmax(st_envelope(digitalscholarshiplab.holc_polygons.the_geom)) as bbxmax, st_ymax(st_envelope(digitalscholarshiplab.holc_polygons.the_geom)) as bbymax,st_area(holc_polygons.the_geom::geography)/1000000 * 0.386102 as sqmi FROM holc_ad_data right join holc_polygons on holc_ad_data.polygon_id = holc_polygons.neighborhood_id join holc_ads on holc_ads.city_id = holc_polygons.ad_id where holc_ads.city_id = ' + adId + ' order by holc_id, cat_id, sub_cat_id, _order',
					format: 'JSON'
				});
			}
		});

		this.dataLoader.query(queries).then(function (responses) {
			responses.forEach(function (response) {
				if (response.length > 0) {
					(function () {
						var adId = response[0].ad_id;
						_this.data.areaDescriptions[adId] = {
							formId: response[0].form_id,
							byNeighborhood: _this.parseAreaDescriptions(response)
						};
						_this.data.areaDescriptions[adId].byCategory = _this.parseADsByCat(_this.data.areaDescriptions[adId].byNeighborhood);
						_this.data.areaDescriptions[adId].area = Object.keys(_this.data.areaDescriptions[adId].byNeighborhood).map(function (HOLCId, i) {
							return _this.data.areaDescriptions[adId].byNeighborhood[HOLCId].sqmi;
						}).reduce(function (a, b) {
							return a + b;
						}, 0);
					})();
				}
			});

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('AreaDescriptionsStore received error:', error);
			throw error;
		});
	},

	parseAreaDescriptions: function parseAreaDescriptions(rawAdData) {
		var adData = {};

		for (var row in rawAdData) {
			var d = rawAdData[row];

			// define id if undefined
			if (typeof adData[d.holc_id] == 'undefined') {
				adData[d.holc_id] = {};
			}
			// assign properties   
			adData[d.holc_id].area_geojson = !adData[d.holc_id].area_geojson ? JSON.parse(d.the_geojson) : adData[d.holc_id].area_geojson;
			adData[d.holc_id].area_geojson_inverted = !adData[d.holc_id].area_geojson_inverted ? this.parseInvertedGeoJson(JSON.parse(d.the_geojson)) : adData[d.holc_id].area_geojson_inverted;
			adData[d.holc_id].boundingBox = [[d.bbxmin, d.bbymin], [d.bbxmax, d.bbymax]];
			//adData[d.holc_id].name = d.name;
			adData[d.holc_id].holc_grade = d.holc_grade;
			adData[d.holc_id].sqmi = d.sqmi;

			// define area description if undefined
			if (typeof adData[d.holc_id].areaDesc == 'undefined') {
				adData[d.holc_id].areaDesc = {};
			}

			// define category id for area description if undefined
			if (d.cat_id && d.sub_cat_id === '' && d.order === null) {
				adData[d.holc_id].areaDesc[d.cat_id] = d.data;
			} else if (d.cat_id && typeof adData[d.holc_id].areaDesc[d.cat_id] === 'undefined') {
				adData[d.holc_id].areaDesc[d.cat_id] = {};
			}
			// check for subcategories
			if (d.sub_cat_id) {
				// create sub-object if we have a subcategory...
				if (typeof adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id] == 'undefined') {
					//console.log(d, adData[d.holc_id]);
					adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id] = {};

					// look for order
					if (d.order) {
						adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id][d.order] = d.data;
					} else {
						adData[d.holc_id].areaDesc[d.cat_id][d.sub_cat_id] = d.data;
					}
				}
			}

			// look for order
			else if (d.order) {
					adData[d.holc_id].areaDesc[d.cat_id][d.order] = rawAdData[row].data;
				}

			if (Object.keys(adData[d.holc_id].areaDesc).length === 0) {
				adData[d.holc_id].areaDesc = false;
			}
		} // end if

		return adData;
	},

	parseADsByCat: function parseADsByCat(ADs) {
		var ADsByCat = {};
		Object.keys(ADs).forEach(function (neighborhoodId) {
			Object.keys(ADs[neighborhoodId].areaDesc).forEach(function (cat) {
				// initialize if necessary
				ADsByCat[cat] = ADsByCat[cat] || {};
				if (typeof ADs[neighborhoodId].areaDesc[cat] == 'string') {
					ADsByCat[cat][neighborhoodId] = ADs[neighborhoodId].areaDesc[cat];
				} else if (_typeof(ADs[neighborhoodId].areaDesc[cat]) == 'object') {
					Object.keys(ADs[neighborhoodId].areaDesc[cat]).forEach(function (subcat) {
						ADsByCat[cat][subcat] = ADsByCat[cat][subcat] || {};
						ADsByCat[cat][subcat][neighborhoodId] = ADs[neighborhoodId].areaDesc[cat][subcat];
					});
				}
			});
		});

		return ADsByCat;
	},

	parseInvertedGeoJson: function parseInvertedGeoJson(geojson) {
		//Create a new set of latlngs, adding our world-sized ring first
		var NWHemisphere = [[0, 0], [0, 90], [-180, 90], [-180, 0], [0, 0]],
		    newLatLngs = [NWHemisphere],
		    holes = [];

		geojson.coordinates.forEach(function (polygon, i) {
			polygon.forEach(function (polygonpieces, i2) {
				if (i2 == 0) {
					newLatLngs.push(polygonpieces);
				} else {
					holes.push(polygonpieces);
				}
			});
		});
		geojson.coordinates = holes.length > 0 ? [newLatLngs.concat(holes)] : [newLatLngs];
		return geojson;
	},

	getAreaDescriptions: function getAreaDescriptions() {
		return this.data.areaDescriptions;
	},

	getADs: function getADs(adId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].byNeighborhood : false;
	},

	getGeoJsonForGrade: function getGeoJsonForGrade(adId, grade) {
		var _this2 = this;

		var polygons = [[[0, 0], [0, 90], [-180, 90], [-180, 0], [0, 0]]],
		    holes = [];
		Object.keys(this.data.areaDescriptions[adId].byNeighborhood).forEach(function (id, i) {
			if (_this2.data.areaDescriptions[adId].byNeighborhood[id].holc_grade == grade) {
				_this2.data.areaDescriptions[adId].byNeighborhood[id].area_geojson.coordinates[0].forEach(function (coords, i2) {
					if (i2 == 0) {
						polygons.push(coords);
					} else {
						holes.push(coords);
					}
				});
			}
		});

		polygons = holes.length > 0 ? [polygons.concat(holes)] : [polygons];

		var geojson = {
			'type': 'Feature',
			'geometry': {
				'type': 'MultiPolygon',
				'coordinates': polygons
			},
			'properties': {}
		};

		return geojson;
	},

	getADsForNeighborhood: function getADsForNeighborhood(adId, holcId) {
		return this.data.areaDescriptions[adId] && this.data.areaDescriptions[adId].byNeighborhood[holcId] ? this.data.areaDescriptions[adId].byNeighborhood[holcId].areaDesc : false;
	},

	getADsForCategory: function getADsForCategory(adId, category) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var _category$split = category.split('-');

		var _category$split2 = _slicedToArray(_category$split, 2);

		var catNum = _category$split2[0];
		var catLetter = _category$split2[1];


		if (!catNum) {
			return this.data.areaDescriptions[adId].byCategory;
		}

		if (!catLetter && this.data.areaDescriptions[adId].byCategory[catNum]) {
			return this.data.areaDescriptions[adId].byCategory[catNum];
		} else if (catLetter && this.data.areaDescriptions[adId].byCategory[catNum] && this.data.areaDescriptions[adId].byCategory[catNum][catLetter]) {
			return this.data.areaDescriptions[adId].byCategory[catNum][catLetter];
		}

		return null;
	},

	getVisible: function getVisible() {
		var _this3 = this;

		var ADs = {};
		this.data.adIds.forEach(function (adId) {
			if (_this3.data.areaDescriptions[adId]) {
				ADs[adId] = _this3.data.areaDescriptions[adId].byNeighborhood;
			}
		});
		return ADs;
	},

	getVisibleMapIds: function getVisibleMapIds() {
		return this.data.adIds;
	},

	getArea: function getArea(adId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].area : null;
	},

	getPreviousHOLCId: function getPreviousHOLCId(adId, HOLCId) {
		var formIds = Object.keys(this.data.areaDescriptions[adId].byNeighborhood).sort(this.alphanumCase);
		return formIds[formIds.indexOf(HOLCId) - 1];
	},

	getNextHOLCId: function getNextHOLCId(adId, HOLCId) {
		var formIds = Object.keys(this.data.areaDescriptions[adId].byNeighborhood).sort(this.alphanumCase);
		return formIds[formIds.indexOf(HOLCId) + 1];
	},

	getFormId: function getFormId(adId) {
		return this.data.areaDescriptions[adId] ? this.data.areaDescriptions[adId].formId : null;
	},

	getPreviousCatIds: function getPreviousCatIds(adId, catNum, catLetter) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var formId = this.data.areaDescriptions[adId].formId;
		for (var checkCatNum = !catLetter ? parseInt(catNum) - 1 : parseInt(catNum); checkCatNum >= 1; checkCatNum--) {
			for (var checkCatLetter = !catLetter || catLetter == 'a' ? 'z' : String.fromCharCode(catLetter.charCodeAt() - 1); checkCatLetter >= 'a'; checkCatLetter = String.fromCharCode(checkCatLetter.charCodeAt() - 1), catLetter = undefined) {
				if (typeof _formsMetadata2.default[formId][checkCatNum] === 'string') {
					return [checkCatNum, undefined];
				} else if (_formsMetadata2.default[formId][checkCatNum] && _formsMetadata2.default[formId][checkCatNum].subcats && typeof _formsMetadata2.default[formId][checkCatNum].subcats[checkCatLetter] === 'string') {
					return [checkCatNum, checkCatLetter];
				}
			}
		}

		return false;
	},

	getNextCatIds: function getNextCatIds(adId, catNum, catLetter) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var formId = this.data.areaDescriptions[adId].formId;
		for (var checkCatNum = !catLetter ? parseInt(catNum) + 1 : parseInt(catNum); checkCatNum < 30; checkCatNum++) {
			for (var checkCatLetter = !catLetter || catLetter == 'z' ? 'a' : String.fromCharCode(catLetter.charCodeAt() + 1); checkCatLetter <= 'z'; checkCatLetter = String.fromCharCode(checkCatLetter.charCodeAt() + 1), catLetter = undefined) {
				if (typeof _formsMetadata2.default[formId][checkCatNum] === 'string') {
					return [checkCatNum, undefined];
				} else if (_formsMetadata2.default[formId][checkCatNum] && _formsMetadata2.default[formId][checkCatNum].subcats && typeof _formsMetadata2.default[formId][checkCatNum].subcats[checkCatLetter] === 'string') {
					return [checkCatNum, checkCatLetter];
				}
			}
		}

		return false;
	},

	getCatTitle: function getCatTitle(adId, cat, subcat) {
		if (!this.data.areaDescriptions[adId]) {
			return null;
		}

		var formId = this.data.areaDescriptions[adId].formId;
		if (!subcat) {
			return cat + ' ' + _formsMetadata2.default[formId][cat];
		} else if (subcat) {
			return cat + subcat + ' ' + _formsMetadata2.default[formId][cat].header + (_formsMetadata2.default[formId][cat].subcats[subcat] !== '' ? ': ' + _formsMetadata2.default[formId][cat].subcats[subcat] : '');
		} else {
			return null;
		}
	},

	hasADData: function hasADData(adId) {
		return this.data.areaDescriptions[adId];
	},

	/* alphanum.js (C) Brian Huisman
 * Based on the Alphanum Algorithm by David Koelle
 * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
 *
 * Distributed under same license as original
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
	alphanumCase: function alphanumCase(a, b) {
		function chunkify(t) {
			var tz = new Array();
			var x = 0,
			    y = -1,
			    n = 0,
			    i,
			    j;
			while (i = (j = t.charAt(x++)).charCodeAt(0)) {
				var m = i == 46 || i >= 48 && i <= 57;
				if (m !== n) {
					tz[++y] = '';
					n = m;
				}
				tz[y] += j;
			}
			return tz;
		}

		var aa = a.neighborhoodId ? chunkify(a.neighborhoodId.toLowerCase()) : chunkify(a.toLowerCase());
		var bb = b.neighborhoodId ? chunkify(b.neighborhoodId.toLowerCase()) : chunkify(b.toLowerCase());
		for (var x = 0; aa[x] && bb[x]; x++) {
			if (aa[x] !== bb[x]) {
				var c = Number(aa[x]),
				    d = Number(bb[x]);
				if (c == aa[x] && d == bb[x]) {
					return c - d;
				} else return aa[x] > bb[x] ? 1 : -1;
			}
		}
		return aa.length - bb.length;
	}

};

// Mixin EventEmitter functionality
Object.assign(AreaDescriptionsStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
_AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.loadInitialData:
			_AppDispatcher2.default.waitFor([_MapStateStore2.default.dispatchToken]);
			if (action.state.selectedCity && _MapStateStore2.default.isAboveZoomThreshold()) {
				AreaDescriptionsStore.loadData([action.state.selectedCity]);
			}
			break;

		case _AppActionCreator.AppActionTypes.mapMoved:
			_AppDispatcher2.default.waitFor([_MapStateStore2.default.dispatchToken]);

			var visibleHOLCMapsIds = _MapStateStore2.default.getVisibleHOLCMapsIds();

			if (visibleHOLCMapsIds && _MapStateStore2.default.isAboveZoomThreshold()) {
				AreaDescriptionsStore.loadData(visibleHOLCMapsIds);
			}
			break;
	}

	return true;
});

exports.default = AreaDescriptionsStore;

},{"../../data/formsMetadata.json":"/Users/nayers/Documents/Panorama/panorama-holc/data/formsMetadata.json","../stores/MapStateStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/MapStateStore.js","../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/CartoDBLoader.js","events":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/CityStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _CityStore;

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

var _formsMetadata = require('../../data/formsMetadata.json');

var _formsMetadata2 = _interopRequireDefault(_formsMetadata);

var _MapStateStore = require('../stores/MapStateStore');

var _MapStateStore2 = _interopRequireDefault(_MapStateStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* City Store is responsible for maintaining most of the important state
variables: e.g. selected city, neighborhood, category, ring, grade, etc. */
var CityStore = (_CityStore = {

	data: {
		id: null,
		name: null,
		state: null,
		year: null,
		selectedRingGrade: {
			ringId: -1,
			grade: null
		},
		selectedHolcId: null,
		selectedCategory: null,
		selectedGrade: null,
		highlightedHolcId: null,
		areas: {},
		ringAreasGeometry: [], // not the rings themselves but the intersection of rings and areas
		loopLatLng: [],
		// the distance in meters between the loop center and the outermost point
		outerRingRadius: null,
		cityData: {},

		/** Percentages of each ring for each grade, with 
   * density recording the amount of neighborhood area 
   * in the ring.
   * {
   *   1: {
   *     'A': float,
   *     'B': float,
   *     'C': float,
   *     'D': float,
   *     'density': float,
   *   },
   *   2: { ... },
   *   ...
   }
   * }
   */
		ringStats: [],
		gradeStats: [],

		ADsByCat: {},
		polygonBoundingBox: null,
		polygonsCenter: null,
		gradedArea: null,
		gradedAreaOfRings: {},
		gradedAreaByGrade: {},
		users: {
			latLng: null,
			adId: null,
			city: null,
			neighborhood: null,
			offerZoomTo: false
		},
		selectedByUser: false,
		hasLoaded: false
	},

	// TODO: Make a generic DataLoader class to define an interface,
	// and let CartoDBLoader extend and implement that?
	// Basic idea is that anything with a query method that returns a Promise
	// that resolves with an array of response data or rejects with an error
	// can be used here.
	dataLoader: _CartoDBLoader2.default,

	loadData: function loadData(cityId, selectedByUser) {
		var _this = this;

		if (cityId == null) {
			this.data.id = null;
			this.data.selectedNeighborhood = null;
			this.data.selectedCategory = null;
			this.emit(_AppActionCreator.AppActionTypes.storeChanged);
			return;
		}

		if (cityId == this.data.id) {
			// already loaded;
			this.emit(_AppActionCreator.AppActionTypes.storeChanged);
			return;
		}

		this.dataLoader.query([{
			query: 'SELECT * from holc_ads where city_id = ' + cityId,
			format: 'JSON'
		},
		// get ring polygons
		{
			query: 'WITH the_hull as (select ST_Collect(digitalscholarshiplab.holc_polygons.the_geom_webmercator) as hull, ad_id FROM digitalscholarshiplab.holc_polygons where ad_id = ' + cityId + ' GROUP BY ad_id), maxdist as (SELECT st_distance_sphere(st_transform(st_endpoint(st_longestline(st_transform(ST_SetSRID(ST_MakePoint(looplng,looplat),4326),3857), hull)), 4326), ST_SetSRID(ST_MakePoint(looplng,looplat), 4326)) as outerringradius, st_length(st_longestline(st_transform(ST_SetSRID(ST_Point(looplng,looplat),4326),3857), hull)) / 3.5 as distintv, ST_Transform(ST_SetSRID(ST_MakePoint(looplng,looplat),4326),3857)::geometry as the_point from the_hull join holc_ads on the_hull.ad_id = holc_ads.city_id and holc_ads.city_id = ' + cityId + ' Order by distintv DESC Limit 1 ), city_buffers as (SELECT ST_Transform((ST_Buffer(the_point,distintv * 3.5,\'quad_segs=32\')::geometry),3857) as buffer4, ST_Transform((ST_Buffer(the_point,distintv * 2.5,\'quad_segs=32\')::geometry),3857) as buffer3, ST_Transform((ST_Buffer(the_point,distintv * 1.5,\'quad_segs=32\')::geometry),3857) as buffer2, ST_Transform((ST_Buffer(the_point,distintv * 0.5,\'quad_segs=32\')::geometry),3857) as buffer1 FROM maxdist), city_rings as (SELECT ST_Difference(buffer4, buffer3) as the_geom_webmercator, 4 as ring_id, st_area(ST_Difference(buffer4, buffer3)) as ring_area from city_buffers union all select ST_Difference(buffer3, buffer2) as the_geom_webmercator, 3 as ring_id, st_area(ST_Difference(buffer3, buffer2)) as ring_area from city_buffers union all select ST_Difference(buffer2, buffer1) as the_geom_webmercator, 2 as ring_id, st_area(ST_Difference(buffer2, buffer1)) as ring_area from city_buffers union all select buffer1 as the_webmercator, 1 as ring_id, st_area(buffer1) as ring_area from city_buffers ), combined_grades as (SELECT holc_grade, ST_union(the_geom_webmercator) as the_geom_webmercator FROM digitalscholarshiplab.holc_polygons where ad_id = ' + cityId + ' group by holc_grade) SELECT holc_grade as grade, ring_id as ring, ST_AsGeoJSON(ST_Transform(ST_Intersection(city_rings.the_geom_webmercator, combined_grades.the_geom_webmercator),4326), 4) as the_geojson, ST_AsGeoJSON(ST_Transform(ST_Difference(city_rings.the_geom_webmercator, combined_grades.the_geom_webmercator),4326), 4) as inverted_geojson, st_area(ST_Intersection(city_rings.the_geom_webmercator, combined_grades.the_geom_webmercator)) as area, ST_Area(city_rings.the_geom_webmercator) as ring_area, outerringradius FROM city_rings, combined_grades, maxdist',
			format: 'JSON'
		}, {
			query: 'Select st_x(st_centroid(ST_SetSRID(st_extent(the_geom),4326))) as centerLng, st_y(st_centroid(ST_SetSRID(st_extent(the_geom),4326))) as centerLat, st_xmin(ST_SetSRID(st_extent(the_geom),4326)) as minlng, st_ymin(ST_SetSRID(st_extent(the_geom),4326)) as minlat, st_xmax(ST_SetSRID(st_extent(the_geom),4326)) as maxlng, st_ymax(ST_SetSRID(st_extent(the_geom),4326)) as maxlat from digitalscholarshiplab.holc_polygons where ad_id = ' + cityId,
			format: 'JSON'
		}]).then(function (response) {
			_this.data.id = parseInt(cityId);
			_this.data.selectedByUser = selectedByUser;

			var cityData = response[0][0];
			_this.data.name = cityData.city;
			_this.data.state = cityData.state;
			_this.data.year = cityData.year;
			_this.data.form_id = cityData.form_id;
			_this.data.cityData = cityData;

			var ringData = response[1];
			_this.data.gradedArea = _this.calculatedGradedArea(ringData);
			_this.data.gradedAreaOfRings = _this.calculateGradedAreaOfRings(ringData);
			_this.data.gradedAreaByGrade = _this.calculateGradedAreaByGrade(ringData);
			_this.data.ringAreasGeometry = _this.parseRingAreaGeometry(ringData);
			_this.data.ringStats = _this.parseRingStats(_this.data.ringAreasGeometry);
			_this.data.outerRingRadius = response[1][0] ? response[1][0].outerringradius : false;
			_this.data.loopLatLng = cityData ? [cityData.looplat, cityData.looplng] : false;
			_this.data.gradeStats = _this.parseGradeStats(_this.data.ringAreasGeometry);

			var polygonLatLngs = response[2][0];
			if (polygonLatLngs.minlat) {
				_this.data.polygonBoundingBox = [[polygonLatLngs.minlat, polygonLatLngs.minlng], [polygonLatLngs.maxlat, polygonLatLngs.maxlng]];
				_this.data.polygonsCenter = [polygonLatLngs.centerlat, polygonLatLngs.centerlng];
			} else {
				_this.data.polygonBoundingBox = null;
				_this.data.polygonsCenter = null;
			}

			_this.data.hasLoaded = true;

			// console.log('CityStore finished loading');
			// console.log(this.data);

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('CityStore received error:', error);
			throw error;
		});
	},

	getCityFromPoint: function getCityFromPoint(point) {
		var _this2 = this;

		var adId = void 0;
		this.dataLoader.query([{
			query: 'SELECT ad_id, city, ST_distance(ST_setsrid(ST_MakePoint(holc_maps.looplng, holc_maps.looplat),4326), ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326)) as distance, st_xmin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmin, st_xmax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmax, st_ymin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymin, st_ymax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymax from holc_maps join holc_maps_ads_join on holc_maps.map_id = holc_maps_ads_join.map_id join holc_ads on holc_ads.city_id = holc_maps_ads_join.ad_id order by distance limit 1',
			format: 'JSON'
		}]).then(function (response) {
			_this2.data.users.city = response[0][0].city;
			_this2.data.users.adId = response[0][0].ad_id;

			_this2.emit(_AppActionCreator.AppActionTypes.userLocated);
		}, function (error) {
			// TODO: handle this.
			console.log('Location received error:', error);
			throw error;
		});
	},

	/* setter functions for state variable */

	setHighlightedHolcId: function setHighlightedHolcId(holcId) {
		this.data.highlightedHolcId = holcId;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedCategory: function setSelectedCategory(id) {
		this.data.selectedCategory = id;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedHolcId: function setSelectedHolcId(holcId) {
		this.data.selectedHolcId = holcId;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedGrade: function setSelectedGrade(grade) {
		this.data.selectedGrade = grade;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setSelectedRingGrade: function setSelectedRingGrade(selectedRingGrade) {
		this.data.selectedRingGrade = selectedRingGrade;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	/* getter functions */

	getHighlightedHolcId: function getHighlightedHolcId() {
		return this.data.highlightedHolcId;
	},

	getId: function getId() {
		return this.data.id;
	},

	getSelectedCategory: function getSelectedCategory() {
		return this.data.selectedCategory;
	},

	getSelectedHolcId: function getSelectedHolcId() {
		return this.data.selectedHolcId;
	},

	getSelectedGrade: function getSelectedGrade() {
		return this.data.selectedGrade;
	},

	getSelectedRingGrade: function getSelectedRingGrade() {
		return this.data.selectedRingGrade;
	},

	getName: function getName() {
		return this.data.name;
	},

	getState: function getState() {
		return this.data.state;
	},

	getFormId: function getFormId() {
		return this.data.form_id;
	},

	getRingStats: function getRingStats() {
		return this.data.ringStats;
	},

	getRingAreasGeometry: function getRingAreasGeometry() {
		return this.data.ringAreasGeometry;
	},

	getGradeStats: function getGradeStats() {
		return this.data.gradeStats;
	},

	getCityData: function getCityData() {
		return this.data.cityData;
	}

}, _defineProperty(_CityStore, 'getSelectedGrade', function getSelectedGrade() {
	return this.data.selectedGrade;
}), _defineProperty(_CityStore, 'getGeoJsonForSelectedRingArea', function getGeoJsonForSelectedRingArea(ring, grade) {
	return this.data.ringAreasGeometry[ring][grade].the_geojson;
}), _defineProperty(_CityStore, 'getInvertedGeoJsonForSelectedRingArea', function getInvertedGeoJsonForSelectedRingArea(ring, grade) {
	return this.data.ringAreasGeometry[ring][grade].inverted_geojson;
}), _defineProperty(_CityStore, 'getOuterRingRadius', function getOuterRingRadius() {
	return this.data.outerRingRadius;
}), _defineProperty(_CityStore, 'getLoopLatLng', function getLoopLatLng() {
	return this.data.loopLatLng;
}), _defineProperty(_CityStore, 'getPolygonsBounds', function getPolygonsBounds() {
	return this.data.polygonBoundingBox;
}), _defineProperty(_CityStore, 'getPolygonsCenter', function getPolygonsCenter() {
	return this.data.polygonsCenter;
}), _defineProperty(_CityStore, 'getSelectedByUser', function getSelectedByUser() {
	return this.data.selectedByUser;
}), _defineProperty(_CityStore, 'getUsersCity', function getUsersCity() {
	return this.data.users.city;
}), _defineProperty(_CityStore, 'getUsersAdId', function getUsersAdId() {
	return this.data.users.adId;
}), _defineProperty(_CityStore, 'getUsersNeighborhood', function getUsersNeighborhood() {
	return this.data.users.neighborhood;
}), _defineProperty(_CityStore, 'getADsByCat', function getADsByCat(cat, subcat) {
	if (!cat) {
		return this.data.ADsByCat;
	}

	if (!subcat && this.data.ADsByCat[cat]) {
		return this.data.ADsByCat[cat];
	} else if (subcat && this.data.ADsByCat[cat] && this.data.ADsByCat[cat][subcat]) {
		return this.data.ADsByCat[cat][subcat];
	}

	return false;
}), _defineProperty(_CityStore, 'getCategoryString', function getCategoryString(catNum, catLetter) {
	return catNum + (catLetter ? '-' + catLetter : '');
}), _defineProperty(_CityStore, 'getCatTitle', function getCatTitle(cat, subcat) {
	var formId = this.getFormId();
	if (!subcat) {
		return cat + ' ' + _formsMetadata2.default[formId][cat];
	} else if (subcat) {
		return cat + subcat + ' ' + _formsMetadata2.default[formId][cat].header + (_formsMetadata2.default[formId][cat].subcats[subcat] !== '' ? ': ' + _formsMetadata2.default[formId][cat].subcats[subcat] : '');
	} else {
		return false;
	}
}), _defineProperty(_CityStore, 'queryCategory', function queryCategory(catNum, catLetter) {
	var _this3 = this;

	if (Object.keys(this.data.areaDescriptions).length === 0) {
		return [];
	}

	var arr = []; // array to store results

	Object.keys(this.data.areaDescriptions).map(function (neighborhoodId, i) {
		if (_this3.data.areaDescriptions[neighborhoodId].areaDesc.hasOwnProperty(catNum) && typeof catLetter == 'undefined') {
			arr.push({ neighborhoodId: neighborhoodId, answer: _this3.data.areaDescriptions[neighborhoodId].areaDesc[catNum].a });
		} else if (_this3.data.areaDescriptions[neighborhoodId].areaDesc.hasOwnProperty(catNum) && _this3.data.areaDescriptions[neighborhoodId].areaDesc[catNum].hasOwnProperty(catLetter)) {
			arr.push({ neighborhoodId: neighborhoodId, answer: _this3.data.areaDescriptions[neighborhoodId].areaDesc[catNum][catLetter].a });
		} else {
			arr.push({ neighborhoodId: neighborhoodId, answer: null });
		}
	});

	arr.sort(this.alphanumCase);

	return arr;
}), _defineProperty(_CityStore, 'calculatedGradedArea', function calculatedGradedArea(geometries) {
	var gradedTotalArea = 0;
	geometries.forEach(function (d) {
		gradedTotalArea += d.area;
	});

	return gradedTotalArea;
}), _defineProperty(_CityStore, 'calculateGradedAreaOfRings', function calculateGradedAreaOfRings(geometries) {
	var gradedAreaOfRings = { 1: 0, 2: 0, 3: 0, 4: 0 };
	geometries.forEach(function (d) {
		gradedAreaOfRings[d.ring] += d.area;
	});

	return gradedAreaOfRings;
}), _defineProperty(_CityStore, 'calculateGradedAreaByGrade', function calculateGradedAreaByGrade(geometries) {
	var gradedAreaByGrade = { 'A': 0, 'B': 0, 'C': 0, 'D': 0 };
	geometries.forEach(function (d) {
		gradedAreaByGrade[d.grade] += d.area;
	});

	return gradedAreaByGrade;
}), _defineProperty(_CityStore, 'parseRingAreaGeometry', function parseRingAreaGeometry(geometries) {
	var _this4 = this;

	if (geometries.length == 0) {
		return false;
	}

	var ringAreasGeometry = {
		1: { 'A': {}, 'B': {}, 'C': {}, 'D': {} },
		2: { 'A': {}, 'B': {}, 'C': {}, 'D': {} },
		3: { 'A': {}, 'B': {}, 'C': {}, 'D': {} },
		4: { 'A': {}, 'B': {}, 'C': {}, 'D': {} }
	};

	geometries.forEach(function (d) {
		ringAreasGeometry[d.ring].density = _this4.data.gradedAreaOfRings[d.ring] / d.ring_area;
		ringAreasGeometry[d.ring][d.grade] = {
			'the_geojson': JSON.parse(d.the_geojson),
			'inverted_geojson': JSON.parse(d.inverted_geojson),
			'percent': d.area / _this4.data.gradedAreaOfRings[d.ring],
			'overallPercent': d.area / _this4.data.gradedArea
		};
	});

	return ringAreasGeometry;
}), _defineProperty(_CityStore, 'parseRingStats', function parseRingStats(ringStats) {
	if (!ringStats || ringStats.length == 0) {
		return false;
	}

	/* let ringCumulative = {
 		1: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0},
 		2: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0},
 		3: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0},
 		4: {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'total': 0}
 	},
 	areaOfRings = {},
 	totalGradedArea = 0, 
 	ringStats = { 1 : {}, 2: {}, 3: {}, 4: {} };
 ringAreaGeometry.forEach((ring) => {
 	ringCumulative[ring.ring_id][ring.holc_grade] += ring.area;
 	ringCumulative[ring.ring_id].total += ring.area;
 	areaOfRings[ring.ring_id] = ring.ring_area;
 	totalGradedArea += ring.area;
 });
 console.log(totalGradedArea);
 Object.keys(ringCumulative).map((ring_id) => {
 	Object.keys(ringCumulative[ring_id]).map((grade) => {
 		ringStats[ring_id][grade] = (ringStats[ring_id][grade]) ? ringStats[ring_id][grade] : {};
 		ringStats[ring_id][grade].percent = ringCumulative[ring_id][grade] / ringCumulative[ring_id].total;
 		ringStats[ring_id].density = ringCumulative[ring_id].total / areaOfRings[ring_id];
 		ringStats[ring_id][grade].overallPercent = ringCumulative[ring_id][grade] / totalGradedArea;
 	});
 }); */

	//format for D3
	var formattedStats = [];
	for (var ringId = 1; ringId <= 4; ringId++) {
		formattedStats.push({
			percents: [{ percent: ringStats[ringId].A.percent, overallPercent: ringStats[ringId].A.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'A' }, { percent: ringStats[ringId].B.percent, overallPercent: ringStats[ringId].B.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'B' }, { percent: ringStats[ringId].C.percent, overallPercent: ringStats[ringId].C.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'C' }, { percent: ringStats[ringId].D.percent, overallPercent: ringStats[ringId].D.overallPercent, ringId: ringId, opacity: ringStats[ringId].density, grade: 'D' }] });
	}

	return formattedStats;
}), _defineProperty(_CityStore, 'hasLoaded', function hasLoaded() {
	return this.data.hasLoaded;
}), _defineProperty(_CityStore, 'parseGradeStats', function parseGradeStats(ringAreasGeometry) {
	var _this5 = this;

	var grades = ['A', 'B', 'C', 'D'];

	//format for D3
	return grades.map(function (grade) {
		return {
			grade: grade,
			percent: _this5.data.gradedAreaByGrade[grade] / _this5.data.gradedArea
		};
	});
}), _defineProperty(_CityStore, 'parseInvertedGeoJson', function parseInvertedGeoJson(geojson) {
	//Create a new set of latlngs, adding our world-sized ring first
	var NWHemisphere = [[0, 0], [0, 90], [-180, 90], [-180, 0], [0, 0]],
	    newLatLngs = [NWHemisphere],
	    holes = [];

	geojson.coordinates.forEach(function (polygon, i) {
		polygon.forEach(function (polygonpieces, i2) {
			if (i2 == 0) {
				newLatLngs.push(polygonpieces);
			} else {
				holes.push(polygonpieces);
			}
		});
	});
	geojson.coordinates = holes.length > 0 ? [newLatLngs.concat(holes)] : [newLatLngs];
	return geojson;
}), _defineProperty(_CityStore, 'alphanumCase', function alphanumCase(a, b) {
	function chunkify(t) {
		var tz = new Array();
		var x = 0,
		    y = -1,
		    n = 0,
		    i,
		    j;
		while (i = (j = t.charAt(x++)).charCodeAt(0)) {
			var m = i == 46 || i >= 48 && i <= 57;
			if (m !== n) {
				tz[++y] = '';
				n = m;
			}
			tz[y] += j;
		}
		return tz;
	}

	var aa = a.neighborhoodId ? chunkify(a.neighborhoodId.toLowerCase()) : chunkify(a.toLowerCase());
	var bb = b.neighborhoodId ? chunkify(b.neighborhoodId.toLowerCase()) : chunkify(b.toLowerCase());
	for (var x = 0; aa[x] && bb[x]; x++) {
		if (aa[x] !== bb[x]) {
			var c = Number(aa[x]),
			    d = Number(bb[x]);
			if (c == aa[x] && d == bb[x]) {
				return c - d;
			} else return aa[x] > bb[x] ? 1 : -1;
		}
	}
	return aa.length - bb.length;
}), _CityStore);

// Mixin EventEmitter functionality
Object.assign(CityStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
CityStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.ADCategorySelected:
			CityStore.setSelectedCategory(action.value);
			CityStore.setSelectedHolcId(null);
			break;

		case _AppActionCreator.AppActionTypes.loadInitialData:
			if (action.state.selectedCity) {
				CityStore.loadData(action.state.selectedCity, true);
			}
			if (action.state.selectedNeighborhood) {
				CityStore.setSelectedHolcId(action.state.selectedNeighborhood);
			}
			if (action.state.selectedCategory) {
				CityStore.setSelectedCategory(action.state.selectedCategory);
			}
			break;

		case _AppActionCreator.AppActionTypes.citySelected:
			CityStore.loadData(action.value, action.selectedByUser);
			CityStore.setSelectedHolcId(null);
			CityStore.setSelectedCategory(null);
			break;

		case _AppActionCreator.AppActionTypes.gradeSelected:
			CityStore.setSelectedGrade(action.value);
			break;

		case _AppActionCreator.AppActionTypes.neighborhoodHighlighted:
			CityStore.setHighlightedHolcId(action.holcId);
			break;

		case _AppActionCreator.AppActionTypes.neighborhoodSelected:
			CityStore.setSelectedCategory(null);
			CityStore.setSelectedHolcId(action.holcId);
			if (action.adId !== CityStore.getId()) {
				CityStore.loadData(action.adId, false);
			}
			break;

		case _AppActionCreator.AppActionTypes.ringGradeSelected:
			CityStore.setSelectedRingGrade(action.value);
			break;

		case _AppActionCreator.AppActionTypes.mapMoved:
			_AppDispatcher2.default.waitFor([_MapStateStore2.default.dispatchToken]);

			var visibleAdIds = _MapStateStore2.default.getVisibleAdIds();
			// unload city if nothing's visible
			if (visibleAdIds.length == 0) {
				CityStore.loadData(null);
			}
			// load a city if there's only one visible and it's different
			else if (visibleAdIds.length == 1 && visibleAdIds[0] !== CityStore.getId()) {
					CityStore.loadData(visibleAdIds[0], { zoomTo: false });
				}
				// unload the city if there are more than one but it's not among them
				else if (visibleAdIds.length > 1 && visibleAdIds.indexOf(CityStore.getId()) == -1) {
						CityStore.loadData(null);
					}
					// unload city if more than one are visible and it's below the zoom threshold
					else if (visibleAdIds.length > 1 && !_MapStateStore2.default.isAboveZoomThreshold()) {
							CityStore.loadData(null);
						}
			break;
	}

	return true;
});

exports.default = CityStore;

},{"../../data/formsMetadata.json":"/Users/nayers/Documents/Panorama/panorama-holc/data/formsMetadata.json","../stores/MapStateStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/MapStateStore.js","../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/CartoDBLoader.js","events":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/MapStateStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CityStore = require('../stores/CityStore');

var _CityStore2 = _interopRequireDefault(_CityStore);

var _RasterStore = require('../stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MapStateStore = {

	data: {
		theMap: null,
		center: [39.8333333, -98.585522],
		zoom: 5,
		bounds: null,
		visibleHOLCMaps: {},
		visibleHOLCMapsIds: [],
		visibleAdIds: [],
		adZoomThreshold: 9
	},

	loadData: function loadData(theMap, rasters) {
		var theBounds = theMap.getBounds();
		var visibleHOLCMaps = {},
		    visibleHOLCMapsIds = [],
		    visibleHOLCMapsByState = {},
		    visibleAdIds = [];

		Object.keys(rasters).forEach(function (id) {
			if (theBounds.intersects(rasters[id].bounds) && !rasters[id].parent_id) {
				visibleHOLCMaps[id] = rasters[id];
				visibleHOLCMapsIds.push(parseInt(id));
				if (visibleAdIds.indexOf(rasters[id].ad_id) == -1) {
					visibleAdIds.push(parseInt(rasters[id].ad_id));
				}
			}
		});

		// organize by state
		visibleHOLCMapsIds.forEach(function (id) {
			visibleHOLCMapsByState[visibleHOLCMaps[id].state] = visibleHOLCMapsByState[visibleHOLCMaps[id].state] ? visibleHOLCMapsByState[visibleHOLCMaps[id].state] : [];
			visibleHOLCMapsByState[visibleHOLCMaps[id].state].push(visibleHOLCMaps[id]);
		});
		// alphabetize
		Object.keys(visibleHOLCMapsByState).forEach(function (the_state) {
			visibleHOLCMapsByState[the_state].sort(function (a, b) {
				return a.city > b.city;
			});
		});

		this.data.theMap = theMap;
		this.data.center = [theMap.getCenter().lat, theMap.getCenter().lng];
		this.data.zoom = theMap.getZoom();
		this.data.bounds = theBounds;
		this.data.visibleHOLCMaps = visibleHOLCMaps;
		this.data.visibleHOLCMapsIds = visibleHOLCMapsIds;
		this.data.visibleHOLCMapsByState = visibleHOLCMapsByState;
		this.data.visibleAdIds = visibleAdIds;

		// console.log('MapStateStore finished loading');

		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	setView: function setView(zoom, center) {
		this.data.zoom = zoom;
		this.data.center = center;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	getTheMap: function getTheMap() {
		return this.data.theMap;
	},

	getCenter: function getCenter() {
		return this.data.center;
	},

	getZoom: function getZoom() {
		return this.data.zoom;
	},

	getVisibleHOLCMaps: function getVisibleHOLCMaps() {
		return this.data.visibleHOLCMaps;
	},

	getVisibleHOLCMapsIds: function getVisibleHOLCMapsIds() {
		return this.data.visibleHOLCMapsIds;
	},

	getVisibleHOLCMapsByState: function getVisibleHOLCMapsByState() {
		return this.data.visibleHOLCMapsByState;
	},


	getVisibleAdIds: function getVisibleAdIds() {
		return this.data.visibleAdIds;
	},

	isAboveZoomThreshold: function isAboveZoomThreshold() {
		return this.data.zoom >= this.data.adZoomThreshold;
	}
};

// Mixin EventEmitter functionality
Object.assign(MapStateStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
MapStateStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.loadInitialData:
			// you have to wait for RasterStore and, if a city is requested in the hash, CityStore to finish their initial load
			var waitingInitialLoad = setInterval(function () {
				if (_RasterStore2.default.hasLoaded() && (!action.state.selectedCity || _CityStore2.default.hasLoaded())) {
					clearInterval(waitingInitialLoad);

					var zoom = void 0,
					    center = void 0;

					if (action.hashState.loc) {
						zoom = action.hashState.loc.zoom;
						center = action.hashState.loc.center;
					} else if (_CityStore2.default.getId()) {
						zoom = 12;
						center = _CityStore2.default.getPolygonsCenter() ? _CityStore2.default.getPolygonsCenter() : _RasterStore2.default.getCenter();
					} else {
						zoom = action.state.map.zoom;
						center = action.state.map.center;
					}

					MapStateStore.setView(zoom, center);
				}
			}, 100);
			break;

		case _AppActionCreator.AppActionTypes.mapInitialized:
			MapStateStore.loadData(action.theMap, action.rasters);

			// if a city has been selected (though the hash), set the new bounds
			if (_CityStore2.default.getId()) {
				var bounds = _CityStore2.default.getPolygonsBounds() ? _CityStore2.default.getPolygonsBounds() : _RasterStore2.default.getMapBounds(),
				    newZoom = action.theMap.getBoundsZoom(bounds),
				    newCenter = _CityStore2.default.getPolygonsCenter() ? _CityStore2.default.getPolygonsCenter() : _RasterStore2.default.getCenter();
				//MapStateStore.setView(newZoom, newCenter);
			}
			break;

		case _AppActionCreator.AppActionTypes.mapMoved:
			MapStateStore.loadData(action.theMap, action.rasters);
			break;

		case _AppActionCreator.AppActionTypes.citySelected:
			// you have to wait for CityStore and RasterStore to finish their initial load
			_AppDispatcher2.default.waitFor([_RasterStore2.default.dispatchToken]);

			var waitingId = setInterval(function () {
				if (action.value == _CityStore2.default.getId()) {
					clearInterval(waitingId);

					if (action.selectedByUser && MapStateStore.getTheMap() !== null) {
						var _bounds = _CityStore2.default.getPolygonsBounds() ? _CityStore2.default.getPolygonsBounds() : _RasterStore2.default.getMapBounds(),
						    _newZoom = MapStateStore.getTheMap().getBoundsZoom(_bounds),
						    _newCenter = _CityStore2.default.getPolygonsCenter() ? _CityStore2.default.getPolygonsCenter() : _RasterStore2.default.getCenter();
						MapStateStore.setView(_newZoom, _newCenter);
					}
				}
			}, 100);
	}
	return true;
});

exports.default = MapStateStore;

},{"../stores/CityStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/CityStore.js","../stores/RasterStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/RasterStore.js","../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js","events":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/RasterStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

var _state_abbr = require('../../data/state_abbr.json');

var _state_abbr2 = _interopRequireDefault(_state_abbr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RasterStore = {

	data: {
		/**
   * Metadata about the maps
   * by year (third order), city (second order), and state, first order
   * {
   *   stateX: {
   *     cityX: {
   *       yearx: {
   *         url: 'str',
   *         bounds: 'latlngbounds',
   *         minZoom: int,
   *         maxtZoom: int
   *       },
   *       yearY: { ... }
   *     },
   *     cityY: { ... },
   *     name: 'str',
   *     description: 'str',
   *     units: 'str'
   *   },
   *   stateY: { ... },
   *   ...
   * }
   */
		maps: {},
		citiesWithPolygons: {},
		cityIdsWithADs: [],

		selectedCity: null,
		selectedState: null,
		loaded: false

	},

	// TODO: Make a generic DataLoader class to define an interface,
	// and let CartoDBLoader extend and implement that?
	// Basic idea is that anything with a query method that returns a Promise
	// that resolves with an array of response data or rejects with an error
	// can be used here.
	dataLoader: _CartoDBLoader2.default,

	loadInitialData: function loadInitialData(state) {
		var _this = this;

		this.dataLoader.query([{
			query: 'SELECT population_1940, population_1930, american_indian_eskimo_1930, american_indian_eskimo_1940, asian_pacific_ilslander_1930 as asian_pacific_islander_1930, asian_pacific_ilslander_1940 as asian_pacific_islander_1940, black_pop_1930, black_pop_1940, white_pop_1930, white_pop_1940, ad_id, holc_maps.*, st_xmin(holc_maps.the_geom) as minLng, st_xmax(holc_maps.the_geom) as maxLng, st_ymin(holc_maps.the_geom) as minLat, st_ymax(holc_maps.the_geom) as maxLat, st_x(st_centroid(holc_maps.the_geom)) as centerLng, st_y(st_centroid(holc_maps.the_geom)) as centerLat FROM holc_maps join holc_maps_ads_join hmaj on hmaj.map_id = holc_maps.map_id join holc_ads on holc_ads.city_id = hmaj.ad_id order by parent_id desc',
			format: 'JSON'
		}, {
			query: 'SELECT distinct(holc_ads.city_id), state, city FROM holc_ad_data join digitalscholarshiplab.holc_polygons on polygon_id = holc_polygons.neighborhood_id join holc_ads on holc_polygons.ad_id = holc_ads.city_id order by state, city',
			format: 'JSON'
		}, {
			query: "SELECT ad_id, sum(st_area(the_geom_webmercator)) / 1609.34^2 as total_area, sum(CASE WHEN holc_grade = 'A' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_a, sum(CASE WHEN holc_grade = 'B' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_b, sum(CASE WHEN holc_grade = 'C' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_c, sum(CASE WHEN holc_grade = 'D' THEN st_area(the_geom_webmercator) ELSE 0 END) / 1609.34^2 as area_d FROM digitalscholarshiplab.holc_polygons group by ad_id order by ad_id desc",
			format: 'JSON'
		}]).then(function (response) {
			_this.data.maps = _this.parseMapData(response[0], response[2], response[1]);
			_this.data.cityIdsWithADs = response[1].map(function (row) {
				return row.id;
			});

			_this.data.selectedCity = state.selectedCity;
			_this.data.selectedState = state.selectedState;

			_this.data.loaded = true;

			// console.log('RasterStore finished loading');

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('RasterStore received error:', error);
			throw error;
		});
	},

	/**
  * The selected city for the whole application to display.
  */
	setSelectedCity: function setSelectedCity(cityId) {
		this.data.selectedCity = cityId;
	},

	setSelectedState: function setSelectedState(state) {
		if (typeof state !== 'undefined' && state !== this.data.selectedState) {
			this.data.selectedCity = undefined;
			this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}
	},

	getAllRasters: function getAllRasters() {
		return this.data.maps;
	},

	getSelectedCity: function getSelectedCity() {
		return this.data.selectedCity;
	},

	getAllCitiesWithPolygons: function getAllCitiesWithPolygons() {
		return this.data.citiesWithPolygons;
	},

	// returns everything or a specified attribute
	getSelectedCityMetadata: function getSelectedCityMetadata() {
		var key = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

		if (!this.getSelectedCity()) {
			return null;
		}
		return key ? this.data.maps[this.getSelectedCity()][key] : this.data.maps[this.getSelectedCity()];
	},

	getCityMetadata: function getCityMetadata(city_id) {
		var key = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		return this.data.maps[city_id] ? key && this.data.maps[city_id][key] ? this.data.maps[city_id][key] : this.data.maps[city_id] : null;
	},

	getMapBounds: function getMapBounds() {
		return [[this.getSelectedCityMetadata('minLat'), this.getSelectedCityMetadata('minLng')], [this.getSelectedCityMetadata('maxLat'), this.getSelectedCityMetadata('maxLng')]];
	},

	getMapBoundsByAdId: function getMapBoundsByAdId(adId) {
		return [[this.data.maps[adId].minLat, this.data.maps[adId].minLng], [this.data.maps[adId].maxLat, this.data.maps[adId].maxLng]];
	},

	getCityNames: function getCityNames() {
		var _this2 = this;

		return Object.keys(this.data.maps).map(function (id) {
			return _this2.data.maps[id].city + ', ' + _state_abbr2.default[_this2.data.maps[id].state];
		});
	},

	getCityIdsWithNames: function getCityIdsWithNames() {
		var _this3 = this;

		var idsAndNames = {};

		Object.keys(this.data.maps).forEach(function (id) {
			idsAndNames[id] = _this3.data.maps[id].city + ', ' + _state_abbr2.default[_this3.data.maps[id].state];
		});

		return idsAndNames;
	},

	getCityIdsAndNames: function getCityIdsAndNames() {
		var _this4 = this;

		return Object.keys(this.data.maps).map(function (id) {
			return {
				id: parseInt(id),
				cityName: _this4.data.maps[id].city + ', ' + _state_abbr2.default[_this4.data.maps[id].state]
			};
		});
	},

	getCenter: function getCenter() {
		return [this.getSelectedCityMetadata('centerLat'), this.getSelectedCityMetadata('centerLng')];
	},

	getCenterOld: function getCenterOld() {
		var bounds = this.getMapBounds();
		return [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
	},

	getMapBoundsForState: function getMapBoundsForState(state) {
		var minLat = 90,
		    minLng = 0,
		    maxLat = 0,
		    maxLng = -180;
		var citiesForState = this.getCitiesForState(state);

		citiesForState.forEach(function (cityData) {
			minLat = cityData.minLat && cityData.minLat < minLat ? cityData.minLat : minLat;
			maxLat = cityData.maxLat && cityData.maxLat > maxLat ? cityData.maxLat : maxLat;
			minLng = cityData.minLng && cityData.minLng < minLng ? cityData.minLng : minLng;
			maxLng = cityData.maxLng && cityData.maxLng > maxLng ? cityData.maxLng : maxLng;
		});

		return [[minLat, minLng], [maxLat, maxLng]];
	},

	getCenterForState: function getCenterForState(state) {
		var bounds = this.getMapBoundsForState(state);
		return [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
	},

	getCitiesForState: function getCitiesForState(state) {
		return this.getCitiesList().filter(function (cityData) {
			return cityData.state == state;
		});
	},

	getMapUrl: function getMapUrl() {
		return this.getSelectedCityMetadata('mapurl');
	},

	getMapThumbnail: function getMapThumbnail() {
		return this.getSelectedCityMetadata('mapThumbnail');
	},

	// return a flat list of the HOLC maps for rendering
	getCitiesList: function getCitiesList() {
		var cities = this.combineCitiesLists();
		return Object.keys(cities).map(function (cityId) {
			return cities[cityId];
		});
	},

	getStatesObject: function getStatesObject() {
		var _this5 = this;

		var statesObject = {};
		Object.keys(this.data.maps).map(function (cityId) {
			statesObject[_this5.data.maps[cityId].state] = {
				id: _this5.data.maps[cityId].state,
				name: _state_abbr2.default[_this5.data.maps[cityId].state],
				citiesIds: _this5.getCitiesForState(_this5.data.maps[cityId].state).map(function (cityData) {
					return cityData.id;
				})
			};
		});
		return statesObject;
	},

	getStatesList: function getStatesList() {
		var states = this.getStatesObject();
		return Object.keys(states).map(function (stateAbbr) {
			return states[stateAbbr];
		});
	},

	getStatesWithFirstCities: function getStatesWithFirstCities() {
		var _this6 = this;

		var states = [],
		    cities = this.combineCitiesLists(),
		    stateInList = function stateInList(state) {
			var inList = false;
			states.map(function (cityData) {
				if (cityData.state == state) {
					inList = true;
				}
			});
			return inList;
		};

		Object.keys(cities).map(function (cityId) {
			if (!stateInList(_this6.data.maps[cityId].state)) {
				states.push(Object.assign({}, _this6.data.maps[cityId]));
			}
		});

		states.map(function (cityData) {
			cityData.name = _state_abbr2.default[cityData.state];
		});

		return states;
	},

	getFirstCityOfState: function getFirstCityOfState(state) {
		var statesWithFirstCities = this.getStatesWithFirstCities();
		for (var i in statesWithFirstCities) {
			if (statesWithFirstCities[i].state == state) {
				return statesWithFirstCities[i];
			}
		}
	},

	hasLoaded: function hasLoaded() {
		return this.data.loaded;
	},

	selectedHasPolygons: function selectedHasPolygons() {
		return this.data.maps[this.data.selectedCity] ? this.data.maps[this.data.selectedCity].hasPolygons : false;
	},

	calculateSimpleRingsRadii: function calculateSimpleRingsRadii(areaData) {
		var furthestRadius = 25000,
		    fullArea = Math.PI * furthestRadius * furthestRadius,
		    outerRadius = void 0,
		    innerRadius = 0,
		    donutArea = void 0,
		    gradeArea = void 0,
		    radii = {};

		['d', 'c', 'b', 'a'].forEach(function (grade) {
			var donutholeArea = Math.PI * innerRadius * innerRadius,
			    gradeArea = fullArea * (areaData[grade] / areaData.total),
			    outerRadius = Math.round(Math.sqrt((gradeArea + donutholeArea) / Math.PI));
			radii[grade] = {
				'inner': innerRadius,
				'outer': outerRadius
			};
			innerRadius = outerRadius;
		});

		return radii;
	},

	getSelectedMaps: function getSelectedMaps(requestedMapIds) {
		var selectedAd = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

		var selectedMaps = [];
		var allMaps = this.getMapsList();

		allMaps.forEach(function (map) {
			if (requestedMapIds.indexOf(map.ad_id) !== -1 && map.ad_id !== selectedAd) {
				selectedMaps.push(map);
			}
		});

		allMaps.forEach(function (map) {
			if (requestedMapIds.indexOf(map.ad_id) !== -1 && map.ad_id == selectedAd) {
				selectedMaps.push(map);
			}
		});

		return selectedMaps;
	},

	// return a flat list of the HOLC maps for rendering
	getMapsList: function getMapsList() {
		var _this7 = this;

		return Object.keys(this.data.maps).map(function (cityId) {
			return _this7.data.maps[cityId];
		});
	},

	parseMapData: function parseMapData(citiesData, citiesWithPolygonsData, citiesWithADs) {
		var _this8 = this;

		var maps = {};

		citiesData.forEach(function (mapData) {
			maps[mapData.map_id] = {
				cityId: mapData.ad_id,
				id: mapData.ad_id,
				ad_id: parseInt(mapData.ad_id),
				parent_id: mapData.parent_id,
				city: mapData.name,
				state: mapData.state,
				searchName: mapData.parent_id ? '' : mapData.name + ', ' + _state_abbr2.default[mapData.state],
				name: mapData.name, // + ", " + mapData.state,
				minZoom: mapData.minzoom,
				maxZoom: mapData.maxzoom,
				bounds: [[mapData.minlat, mapData.minlng], [mapData.maxlat, mapData.maxlng]],
				minLat: mapData.minlat,
				maxLat: mapData.maxlat,
				minLng: mapData.minlng,
				maxLng: mapData.maxlng,
				centerLat: mapData.centerlat,
				centerLng: mapData.centerlng,
				population_1930: mapData.population_1930,
				population_1940: mapData.population_1940,
				american_indian_eskimo_1930: mapData.american_indian_eskimo_1930,
				american_indian_eskimo_1940: mapData.american_indian_eskimo_1940,
				asian_pacific_islander_1930: mapData.asian_pacific_islander_1930,
				asian_pacific_islander_1940: mapData.asian_pacific_islander_1940,
				black_pop_1930: mapData.black_pop_1930,
				black_pop_1940: mapData.black_pop_1940,
				white_pop_1930: mapData.white_pop_1930,
				white_pop_1940: mapData.white_pop_1940,
				hasPolygons: false,
				hasADs: false,
				url: 'http://holc.s3-website-us-east-1.amazonaws.com/tiles/' + mapData.state + '/' + mapData.file_name.replace(/\s+/g, '') + '/' + mapData.year + '/{z}/{x}/{y}.png',
				mapurl: 'http://holc.s3-website-us-east-1.amazonaws.com/tiles/' + mapData.state + '/' + mapData.file_name.replace(/\s+/g, '') + '/' + mapData.year + '/holc-scan.jpg',
				mapThumbnail: 'http://holc.s3-website-us-east-1.amazonaws.com/tiles/' + mapData.state + '/' + mapData.file_name.replace(/\s+/g, '') + '/' + mapData.year + '/thumbnail.jpg'
			};
		});

		citiesWithPolygonsData.forEach(function (areaData) {
			if (maps[areaData.ad_id]) {
				maps[areaData.ad_id].hasPolygons = true, maps[areaData.ad_id].area = {
					'total': areaData.total_area,
					'a': areaData.area_a,
					'b': areaData.area_b,
					'c': areaData.area_c,
					'd': areaData.area_d
				}, maps[areaData.ad_id].radii = _this8.calculateSimpleRingsRadii(maps[areaData.ad_id].area);
			}
		});

		citiesWithADs.forEach(function (areaData) {
			if (maps[areaData.id]) {
				maps[areaData.id].hasADs = true;
			}
		});

		return maps;
	},

	parseCitiesWithPolygonsData: function parseCitiesWithPolygonsData(data) {
		var _this9 = this;

		var cities = {};

		data.forEach(function (citiesData) {
			cities[citiesData.id] = {
				adId: citiesData.id,
				id: citiesData.id,
				city: citiesData.city,
				state: citiesData.state,
				name: citiesData.city + (_this9.data.cityIdsWithADs.indexOf(citiesData.id) != -1 ? ' **' : ' *'), // ", " + stateAbbrs[citiesData.state] +
				minLat: citiesData.minlat,
				maxLat: citiesData.maxlat,
				minLng: citiesData.minlng,
				maxLng: citiesData.maxlng,
				centerLat: citiesData.centerlat,
				centerLng: citiesData.centerlng,
				hasPolygons: true,
				hasADs: _this9.data.cityIdsWithADs.indexOf(citiesData.id) != -1
			};
		});

		return cities;
	},

	combineCitiesLists: function combineCitiesLists() {
		var _this10 = this;

		var combinedList = {};
		Object.keys(this.data.maps).map(function (id, i) {
			combinedList[id] = _this10.data.citiesWithPolygons[id] ? _this10.data.citiesWithPolygons[id] : _this10.data.maps[id];
		});

		return combinedList;
	}

};

// Mixin EventEmitter functionality
Object.assign(RasterStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
RasterStore.dispatchToken = _AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.loadInitialData:
			RasterStore.loadInitialData(action.state);
			if (action.state.selectedCity) {
				RasterStore.setSelectedCity(action.state.selectedCity);
			}
			break;

		case _AppActionCreator.AppActionTypes.citySelected:
			RasterStore.setSelectedCity(action.value);
			break;
	}

	return true;
});

exports.default = RasterStore;

},{"../../data/state_abbr.json":"/Users/nayers/Documents/Panorama/panorama-holc/data/state_abbr.json","../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/CartoDBLoader.js","events":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/TextsStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextsStore = {

	data: {
		modal: {
			open: false,
			subject: null
		},
		about: ["<h2>Introduction</h2>", "<p><cite>Mapping Inequality</cite> updates the study of New Deal America, the federal government, housing, and inequality for the twenty-first century. It offers unprecedented online access to the national collection of \"	security maps\" and area descriptions produced between 1935 and 1940 by one of the New Deal's most important agencies, the Home Owners' Loan Corporation or HOLC (pronounced \"holk\"). </p>", "<p>HOLC recruited mortgage lenders, developers, and real estate appraisers in nearly 250 cities to create maps that color-coded credit worthiness and risk on neighborhood and metropolitan levels. These maps and their accompanying documentation helped set the rules for nearly a century of real estate practice. They have also served as critical evidence in countless urban studies in the fields of history, sociology, economics, and law.  Indeed, more than a half-century of research has shown housing to be for the twentieth century what slavery was to the antebellum period, namely the broad foundation of both American prosperity and racial inequality.  Through offering a digital library of the state's role in housing development, Mapping Inequality illustrates vividly the interplay between racism, administrative culture, economics, and the built environment.</p>", "<p><cite>Mapping Inequality</cite> introduces viewers to the records of the Home Owners Loan Corporation with accessibility and on a scale that is unprecedented. Visitors can browse over two-hundred interactive maps and get a view of Depression-era America as developers, realtors, tax assessors, and surveyors saw it&#8212;a set of interlocking color-lines, racial groups, and environmental risks.  They can also use the maps and area descriptions to draw connections between past state actions (and inactions) and contemporary American problems.</p>", "<h3>Archiving Inequality for the Digital Age</h3>", "<p>Like so many other government agencies during the New Deal, HOLC and its parent bureau, the Federal Home Loan Bank Board, shaped Americans' lives and livelihoods profoundly during and after the Great Depression of the 1930s. Both proved critical to protecting and expanding home ownership, to standardizing lending practices, and to encouraging residential and commercial real estate investment in a flagging economy.  Across the middle third of the twentieth century, arguably the most prosperous decades in American history, these agencies worked with public and private sector partners to create millions of jobs and help millions of Americans buy or keep their homes. At the very same time, federal housing programs helped codify and expand practices of racial and class segregation.  They ensured, moreover, that rampant real estate speculation and environmental degradation would accompany America's remarkable economic recovery and growth.</p>", "<p><cite>Mapping Inequality</cite> brings one of the country's most important archives to the public.  HOLC's documents contain a wealth of information about how government officials, lenders, and real estate interests surveyed and ensured the economic health of American cities.  And with the help of ongoing research, we continue to learn at what cost such measures were realized.</p>", "<p>Over the last thirty years especially, scholars have characterized HOLC's property assessment and risk management practices, as well as those of the Federal Housing Administration, Veterans Administration, and US. Housing Authority, as some of the most important factors in preserving racial segregation, intergenerational poverty, and the continued wealth gap between white Americans and most other groups in the U.S.  Many of these agencies operated under the influence of powerful real estate lobbies or wrote their policies steeped in what were, at the time, widespread assumptions about the profitability of racial segregation and the residential incompatibility of certain racial and ethnic groups.  Through HOLC, in particular, real estate appraisers used the apparent racial and cultural value of a community to determine its economic value.  <cite>Mapping Inequality</cite> offers a window into the New Deal era housing policies that helped set the course for contemporary America. This project provides visitors with a new view, and perhaps even a new language, for describing the relationship between wealth and poverty in America.</p>"],
		bibliograph: ["<h2>Bibliographic Note</h2>", "<p>The Home Owners Loan Corporation (HOLC) has long been seen as both a savior to the housing sector and a force for racial segregation.  As the economic collapse of the 1930s recedes beyond living memory, historians have focused more on the segregationist nature of housing policy—how racism helped save the American economy.  The legislation creating HOLC came out of the first 100 days of the Roosevelt administration and provided billions of dollars for the rescue of banks, thrifts, and distressed homeowners.  New Deal legislation was highly popular in the midst of an economic crisis—the Democratically-controlled House of Representatives passed the bill 383-4.</p>", "<p>HOLC helped restructure the American mortgage lending market by creating and standardizing several of its elements.  HOLC incorporated appraisal of home value into its lending processes, a practice only in its infancy at the time.  HOLC supported the training of home appraisers and employed hundreds of appraisers throughout the 1930s, working in concert with the nation’s realtors to inaugurate and advance real estate appraisal as a profession.  HOLC’s department of Research and Statistics drew upon its network of realtors, developers, lenders, and appraisers to create a neighborhood-by-neighborhood assessment of more than 200 cities in the country.  These assessments included demographic data, economic reports, and the color-coded Security Maps later deemed infamous as instruments of “redlining.”</p>", "<p>The mainstream white press—major daily newspapers and periodicals—greeted the agency and its programs with approval.  They explained the program and forecast upturns in the real estate and construction sectors, as the program enjoyed popular support.  In Chicago, seventeen thousand people stood in line at HOLC’s office the first day it opened in August of 1933 to inquire or apply for aid.  The corporation’s main lending phase ended after three years and the corporation receded from mainstream public view.  HOLC slowly reduced its operations during the 1940s to manage the loans and homes it acquired in its key phase of activity.</p>", "<p>African Americans lambasted HOLC staffing decisions and infrastructure that favored white homeowners and businesses at the expense of blacks.  However, discussion in black newspapers, such as the <cite>Chicago Defender</cite>, prompted only modest response by policy and media elites.  The Roosevelt administration rebuffed NAACP concerns about restrictive covenants, even when HOLC redlining was exposed in 1938.  Black housing officials often worked incrementally on a host of issues, including ending white terrorism and getting new black housing built, even if that meant operating within the segregationist strictures of federal policy.  Racial segregation in housing was not formally deemed illegal until the Fair Housing Act of 1968.</p>", "<p>Scholars viewed HOLC favorably, shaped by economist C. Lowell Harriss’ <cite>History and Policies of the Home Owners’ Loan Corporation</cite>, published in 1951 as the federal government unwound the agency.  HOLC had refinanced a million homes and returned a profit of $14 million to the U.S. Treasury.  It was a successful business venture for an agency created as emergency relief that helped stabilize and even resurrect a moribund mortgage market and stagnant home building sector.</p>", "<p>In the 1980s discovery of the HOLC security maps changed the way historians thought about HOLC and New Deal housing policy.  Housing activists in the 1960s and 1970s had criticized and protested discrimination in real estate lending and buying, coining the term “redlining” to illustrate the geographic dimensions of housing discrimination.  Historian Kenneth Jackson found the maps in the National Archives, stating in his award-winning book <cite>Crabgrass Frontier</cite> that HOLC “devised a rating system that undervalued neighborhoods that were dense, mixed, or aging,” and rather than creating racial discrimination, “applied [existing] notions of ethnic and racial worth to real-estate appraising on an unprecedented scale.”  Federal housing policy simply blocked African Americans from accessing real estate capital, leading to the creation of segregated mass suburbia and, neighborhood by neighborhood, opened residents to opportunity and wealth accumulation or closed citizens off from the American dream.  Following Jackson’s work, historian Thomas Sugrue wrote of the legacy of federal housing policy in Detroit: “geography is destiny.”  Outside of history, scholars and journalists, including sociologist Douglas Massey and writer Ta-Nehisi Coates, point to HOLC redlining as a key factor in racial disparities in wealth and opportunity that continue to the present day.</p>", "<p>When historians incorporated new data technology in their research, they began to draw new conclusions about HOLC’s legacy.  Mapping with geographic information systems (GIS) and quantitative statistical methods from the social sciences, scholars including Amy Hillier and James Greer have countered Jackson’s initial assessment.  Some African Americans did gain access to HOLC financing, and a neighborhood rating was neither a blanket guarantee nor proscription for New Deal aid—“C” and “D”-rated neighborhoods often received more mortgages than nearby “A” neighborhoods.  The ability to work with digital data and to transmit information over the web has opened many new avenues for scholarly inquiry, including assessing the importance of restrictive covenants and asking research questions about the whole program, rather than just individual cities.  Managing massive amounts of real estate and demographic data has been a herculean task up until recently but is now possible with mapping, visualization, and statistical tools.</p>", "<p><cite>Mapping Inequality</cite> opens the HOLC files at the National Archives to scholars, students, and residents and policy leaders in local communities.  This site makes the well-known security maps of HOLC available in digital form, as well as the data and textual assessments of the area descriptions that were created to go with the maps.  By bringing study of HOLC into the digital realm, <cite>Mapping Inequality</cite> embraces a big data approach that can simultaneously give a national view of the program or a neighborhood-level assessment of the 1930s real estate rescue.  Project researchers are providing access to some of the digital tools and interactive resources they are using in their own research, in the hope that the public will be able to understand the effects of federal housing policy and local implementation in their own communities.</p>", "<h2>Bibliography</h2>", "<h3>Textbooks and Manuals on Home Appraisal and Valuation</h3>", "<ul>", "<li><cite>FHA Underwriting Manual</cite> (Washington, DC: Federal Housing Administration, 1936)</li>", "<li>Frederick Babcock, <cite>The Valuation of Real Estate</cite> (McGraw Hill Book Co.: New York, 1932).</li>", "<li>Richard Ely and George Wehrwein, <cite>Land Economics</cite> (Madison, WI: University of Wisconsin Press, rev. 1964).</li>", "<li>Ernest Fisher, <cite>Principles of Real Estate Practice</cite> (New York: The MacMillan Co., 1924).</li>", "<li>Richard Hurd, <cite>Principles of City Land Values </cite>(New York: The Record and Guide, 1924).</li>", "</ul>", "<h3>Contemporaneous Studies of HOLC and Racial Segregation</h3>", "<ul>", "<li>Charles Abrams, <cite>Forbidden Neighbors: A Study of Prejudice in Housing </cite>(New York: Harper &amp; Brothers, 1955).</li>", "<li>C. Lowell Harriss, <cite>History and Policies of the Home Owners&rsquo; Loan Corporation</cite> (Washington, D.C., National Bureau of Economic Research, 1951).</li>", "<li>Robert C. Weaver, <cite>The Negro Ghetto </cite>(New York: Harcourt, Brace, 1948).</li>", "</ul>", "<h3>Historical Studies of HOLC, Segregation, and Home Finance</h3>", "<ul>", "<li>David M. P. Freund, <cite>Colored Property: State Policy and White Racial Politics in Suburban America</cite> (Chicago: University of Chicago Press, 2007).</li>", "<li>Margaret Garb, <cite>City of American Dreams: A History of Home Ownership and Housing Reform in Chicago, 1871-1919</cite>.&nbsp; (Chicago: University of Chicago Press, 2005).</li>", "<li>Amy E. Hillier, &ldquo;Redlining and the Home Owners&rsquo; Loan Corporation,&rdquo; <cite>Journal of Urban History</cite> 29, no. 4 (May 2003): 394-420.</li>", "<li>Amy E. Hillier, &ldquo;Residential Security Maps and Neighborhood Appraisals: The Home Owners&rsquo; Loan Corporation and the Case of Philadelphia,&rdquo; <cite>Social Science History</cite> 29, no. 2 (Summer 2005): XXXX</li>", "<li>Amy E. Hillier, &ldquo;Searching for Red Lines: Spatial Analysis of Lending Patterns in Philadelphia, 1940-1960,&rdquo; <cite>Pennsylvania History</cite> 72, no. 1 (Winter 2005): XXX</li>", "<li>Arnold R. Hirsch, &ldquo;Containment on the Home Front: Race and Federal Housing Policy from the New Deal to the Cold War,&rdquo; <cite>Journal of Urban History</cite> 26, no. 2 (January 2000): 158-189</li>", "<li>Kenneth T. Jackson, &ldquo;Race Ethnicity, and Real Estate Appraisal: The Home Owners Loan Corporation and the Federal Housing Administration,&rdquo; <cite>Journal of Urban History</cite> 6, no. 4 (August, 1980): 419-452.</li>", "<li>Kenneth T. Jackson, <cite>Crabgrass Frontier: The Suburbanization of the United States</cite> (Oxford: Oxford University Press, 1985).</li>", "<li>Jennifer S. Light, &ldquo;Nationality and Neighborhood Risk at the Origins of FHA Underwriting,&rdquo; <cite>Journal of Urban History</cite> 36 (5): 634-671.</li>", "<li>Louis Lee Woods II, &ldquo;The Federal Home Loan Bank Board, Redlining, and the National Proliferation of Racial Lending Discrimination, 1921-1950,&rdquo; <cite>Journal of Urban History</cite>; Volume 38, Issue 6 (November 2012): 1036-1059.</li>", "</ul>", "<h3>Historical Community Studies Featuring Analysis of HOLC</h3>", "<ul>", "<li>Wendell Pritchett, <cite>Brownsville, Brooklyn: Blacks, Jews, and the Changing Face of the Ghetto </cite>(Chicago: University of Chicago Press, 2002).</li>", "<li>Beryl Satter, <cite>Family Properties: Race, Real Estate, and the Exploitation of Black Urban America</cite> (Metropolitan Books, 2009).</li>", "<li>Robert O. Self, <cite>American Babylon, Race and the Struggle for Postwar Oakland</cite> (Princeton: Princeton University Press, 2003).</li>", "<li>Thomas J. Sugrue, <cite>Origins of the Urban Crisis: Race and Inequality in Postwar Detroit</cite> (Princeton: Princeton University Press, 1996).</li>", "<li>Craig Steven Wilder, <cite>Covenant With Color: Race and Social Power in Brooklyn</cite> (New York: Columbia University Press, 2001).</li>", "</ul>", "<h3>Sociological Studies of Racial Discrimination and Segregation</h3>", "<ul>", "<li>Rose Helper, <cite>Racial Policies and Practices of Real Estate Brokers</cite>. (Minneapolis: University of Minnesota Press, 1969).</li>", "<li>Douglas S. Massey and Nancy A. Denton, <cite>American Apartheid: Segregation and the Making of the Underclass</cite> (Cambridge: Harvard University Press, 1993).</li>", "</ul>"],
		"burgess": ["<p><strong>Borrowed and modified from the 1920s-era \"concentric zones theory\" of Ernest W. Burgess, this diagram offers a view of how redlining concentrated populations, and did so along a generally consistent pattern.</strong></p>", "<p>According to Burgess, every city developed as a series of concentric circles.  Downtown business districts would be followed by factory zones.  Factory zones would transition to slums, followed then by progressively more affluent housing for working people and the investor class, before then reaching the final zone, from whence commuters came into the city. As the historian Elaine Lewinnek points out, \"Burgess adapted a half-century of Chicago maps and codified them in a model of abstraction and urban theory that has been called&#8212;with some hyperbole&#8212;'the most famous diagram in social science.'\"</p>", "<p>In Burgess's model, each ring had cultural and economic features&#8212;features that he explicitly associated with ethnic and racial populations. Poor whites and black migrants occupied central slum districts rife with vice dens and run down rooming houses and immigrant colonies.  Second-generation European immigrants and factory and a shop workers, \"skilled and thrifty,\" lived on the outer edge of the slums and on the inner edge of the ring of well-kept apartment houses and \"workingmen's homes.\" Beyond them was the \"Promised Land\" of residential hotels and single-family homes.  In contrast to the swarthy, congested slums, these were \"bright light areas\" safely protected by restrictive covenants and high price points.</p>", "<p>Burgess's model, in addition to reflecting the homes of real estate investor communities, served as an extension of wider segregationist thinking driving both sociology as a discipline and administrative practice during the progressive era.  Obsession with cities as \"organisms\" of society, they believed in what the sociologist Louis Wirth benignly described as the \"eugenics of the city.\"</p>", "<p>Many of the HOLC maps reflected both the categorical impulse and spatial organization of Burgess model with D and C neighborhoods more likely to be located around central business districts and A and B neighborhoods in increasingly suburban peripheries. The diagram visualizes the relative distribution of HOLC grades in relation to the center of the city. The opacity of the rings reflects the relative density of zoned areas on the map. Hovering over the rings will highlight areas for that grade.</p>", "<p>In Burgess's model, each ring had cultural and economic features&#8212;features that he explicitly associated with ethnic and racial populations. Poor whites and black migrants occupied central slum districts rife with vice dens and run down rooming houses and immigrant colonies.  Second-generation European immigrants and factory and a shop workers, \"skilled and thrifty,\" lived on the outer edge of the slums and on the inner edge of the ring of well-kept apartment houses and \"workingmen's homes.\" Beyond them was the \"Promised Land\" of residential hotels and single-family homes.  In contrast to the swarthy, congested slums, these were \"bright light areas\" safely protected by restrictive covenants and high price points.</p>", "<p>Burgess's model, in addition to reflecting the homes of real estate investor communities, served as an extension of wider segregationist thinking driving both sociology as a discipline and administrative practice during the progressive era.  Obsession with cities as \"organisms\" of society, they believed in what the sociologist Louis Wirth benignly described as the \"eugenics of the city.\"</p>", "<p>Many of the HOLC maps reflected both the categorical impulse and spatial organization of Burgess model with D and C neighborhoods more likely to be located around central business districts and A and B neighborhoods in increasingly suburban peripheries. The diagram visualizes the relative distribution of HOLC grades in relation to the center of the city. The opacity of the rings reflects the relative density of zoned areas on the map. Hovering over the rings will highlight areas for that grade.</p>"]
	},

	setShow: function setShow(subject) {
		this.data.modal = {
			open: subject !== null,
			subject: subject
		};
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	getModalContent: function getModalContent() {
		return this.data.modal.open ? this.parseModalCopy(this.data[this.data.modal.subject]) : null;
	},

	mainModalIsOpen: function mainModalIsOpen() {
		return this.data.modal.open;
	},

	parseModalCopy: function parseModalCopy(rawContent) {
		var modalCopy = '';

		try {
			modalCopy = rawContent.join('\n');
		} catch (error) {
			console.warn('Error parsing modal copy: ');
			modalCopy = 'Error parsing modal copy.';
		}

		// React requires this format to render a string as HTML,
		// via dangerouslySetInnerHTML.
		return {
			__html: modalCopy
		};
	}
};

// Mixin EventEmitter functionality
Object.assign(TextsStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
_AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.onModalClick:
			TextsStore.setShow(action.subject);
			break;

	}
	return true;
});

exports.default = TextsStore;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js","events":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/UserLocationStore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('events');

var _AppDispatcher = require('../utils/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _AppActionCreator = require('../utils/AppActionCreator');

var _CartoDBLoader = require('../utils/CartoDBLoader');

var _CartoDBLoader2 = _interopRequireDefault(_CartoDBLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UserLocationStore = {

	data: {
		latLng: null,
		adId: null,
		city: null,
		neighborhood: null,
		offerZoomTo: false
	},

	dataLoader: _CartoDBLoader2.default,

	loadData: function loadData(point) {
		var _this = this;

		this.data.latLng = point;

		this.dataLoader.query([{
			query: 'SELECT ad_id, city, ST_distance(ST_setsrid(ST_MakePoint(holc_maps.looplng, holc_maps.looplat),4326), ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326)) as distance, st_xmin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmin, st_xmax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbxmax, st_ymin( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymin, st_ymax( st_envelope(st_collect(ST_setsrid(ST_MakePoint(' + point[1] + ', ' + point[0] + '),4326), holc_maps.the_geom))) as bbymax from holc_maps join holc_maps_ads_join on holc_maps.map_id = holc_maps_ads_join.map_id join holc_ads on holc_ads.id = holc_maps_ads_join.ad_id order by distance limit 1',
			format: 'JSON'
		}]).then(function (response) {
			_this.data.city = response[0][0].city;
			_this.data.adId = response[0][0].ad_id;
			_this.data.offerZoomTo = true;

			_this.emit(_AppActionCreator.AppActionTypes.storeChanged);
		}, function (error) {
			// TODO: handle this.
			console.log('Location received error:', error);
			throw error;
		});
	},

	setOfferZoomTo: function setOfferZoomTo(trueOrFalse) {
		this.data.offerZoomTo = trueOrFalse;
		this.emit(_AppActionCreator.AppActionTypes.storeChanged);
	},

	getPoint: function getPoint() {
		return this.data.latLng;
	},

	getAdId: function getAdId() {
		return this.data.adId;
	},

	getCity: function getCity() {
		return this.data.city;
	},

	getNeighborhood: function getNeighborhood() {
		return this.data.neighborhood;
	},

	getOfferZoomTo: function getOfferZoomTo() {
		return this.data.offerZoomTo;
	}
};

// Mixin EventEmitter functionality
Object.assign(UserLocationStore, _events.EventEmitter.prototype);

// Register callback to handle all updates
_AppDispatcher2.default.register(function (action) {

	switch (action.type) {

		case _AppActionCreator.AppActionTypes.userLocated:
			if (action.point) {
				UserLocationStore.loadData(action.point);
			}
			break;

		case _AppActionCreator.AppActionTypes.userRespondedToZoomOffer:
			UserLocationStore.setOfferZoomTo(false);
			break;

	}
	return true;
});

exports.default = UserLocationStore;

},{"../utils/AppActionCreator":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js","../utils/AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js","../utils/CartoDBLoader":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/CartoDBLoader.js","events":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/browserify/node_modules/events/events.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppActionCreator.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AppActions = exports.AppActionTypes = undefined;

var _AppDispatcher = require('./AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _RasterStore = require('../stores/RasterStore');

var _RasterStore2 = _interopRequireDefault(_RasterStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AppActionTypes = exports.AppActionTypes = {

	// Note: stores emit this type of event.
	// Though it is not actually an Action type;
	// it's enumerated here for ease of access.
	storeChanged: 'storeChanged',

	ADCategorySelected: 'ADCategorySelected',
	loadInitialData: 'loadInitialData',
	initialDataLoaded: 'initialDataLoaded',
	getInitialData: 'getInitialData',
	citySelected: 'citySelected',
	gradeSelected: 'gradeSelected',
	neighborhoodHighlighted: 'neighborhoodHighlighted',
	neighborhoodSelected: 'neighborhoodSelected',
	ringGradeSelected: 'ringGradeSelected',
	mapInitialized: 'mapInitialized',
	mapMoved: 'mapMoved',
	userLocated: 'userLocated',
	userRespondedToZoomOffer: 'userRespondedToZoomOffer',
	onModalClick: 'onModalClick'

};

var AppActions = exports.AppActions = {

	ADCategorySelected: function ADCategorySelected(value) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.ADCategorySelected,
			value: value
		});
	},

	/**
  * Load data needed by the application on init.
  */
	loadInitialData: function loadInitialData(state, hashState) {
		//console.log(`[1a] A '${ AppActionTypes.loadInitialData }' event is broadcast globally from AppActionCreator.loadInitialData().`);
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.loadInitialData,
			state: state,
			hashState: hashState
		});
	},

	initialDataLoaded: function initialDataLoaded(state) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.initialDataLoaded,
			state: state
		});
	},

	citySelected: function citySelected(city) {
		var selectedByUser = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.citySelected,
			value: city,
			selectedByUser: true
		});
	},

	gradeSelected: function gradeSelected(grade) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.gradeSelected,
			value: grade
		});
	},

	neighborhoodHighlighted: function neighborhoodHighlighted(holcId, adId) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.neighborhoodHighlighted,
			holcId: holcId
		});
	},

	neighborhoodSelected: function neighborhoodSelected(holcId, adId) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.neighborhoodSelected,
			holcId: holcId,
			adId: adId
		});
	},

	stateSelected: function stateSelected(state) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.stateSelected,
			value: state
		});
	},

	ringGradeSelected: function ringGradeSelected(selectedRingGrade) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.ringGradeSelected,
			value: selectedRingGrade
		});
	},

	// mapMoved: (visibleAdIds, belowAdThreshold = false) => {
	// 	AppDispatcher.dispatch({
	// 		type: AppActionTypes.mapMoved,
	// 		value: visibleAdIds,
	// 		belowAdThreshold: belowAdThreshold
	// 	})
	// },

	onModalClick: function onModalClick(subject) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.onModalClick,
			subject: subject
		});
	},

	userLocated: function userLocated(point) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.userLocated,
			point: point
		});
	},

	userRespondedToZoomOffer: function userRespondedToZoomOffer() {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.userRespondedToZoomOffer
		});
	},

	mapInitialized: function mapInitialized(theMap) {
		_AppDispatcher2.default.dispatch({
			type: AppActionTypes.mapInitialized,
			theMap: theMap,
			rasters: _RasterStore2.default.getAllRasters()
		});
	},

	mapMoved: function mapMoved(theMap) {
		// this has fired repeatedly when it should fire only once.
		// I think this might be related to re-rendering happening
		// during leaflet animation.
		if (!_AppDispatcher2.default.isDispatching()) {
			_AppDispatcher2.default.dispatch({
				type: AppActionTypes.mapMoved,
				theMap: theMap,
				rasters: _RasterStore2.default.getAllRasters()
			});
		}
	}
};

},{"../stores/RasterStore":"/Users/nayers/Documents/Panorama/panorama-holc/src/stores/RasterStore.js","./AppDispatcher":"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/AppDispatcher.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flux = require('flux');

exports.default = new _flux.Dispatcher();

},{"flux":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/flux/index.js"}],"/Users/nayers/Documents/Panorama/panorama-holc/src/utils/CartoDBLoader.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _queueAsync = require('queue-async');

var _queueAsync2 = _interopRequireDefault(_queueAsync);

var _config = require('../../basemaps/cartodb/config.json');

var _config2 = _interopRequireDefault(_config);

var _cartodbClient = require('cartodb-client');

var _cartodbClient2 = _interopRequireDefault(_cartodbClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cartoDBClient = new _cartodbClient2.default(_config2.default.userId); /*
                                                                           * TODO: Move this into @panorama/toolkit.
                                                                           * 
                                                                           * Consider pulling cartodb-client into this and packaging the whole thing as a component,
                                                                           * leaving `query` as the only public method.
                                                                           * 
                                                                           * Also, note this is pretty similar to https://www.npmjs.com/package/cartodb already >.<
                                                                           */

var CartoDBLoader = {

	/** Use `queue-async` to defer() up an array of queries,
  * and return a Promise that is resolved when all requests have completed.
  * Accepts a list of objects formatted as { query, format }.
  */
	query: function query(queryConfigs) {
		var _this = this;

		return new Promise(function (resolve, reject) {

			// Run up to 3 requests in parallel
			var queue = (0, _queueAsync2.default)(3);
			queryConfigs.forEach(function (queryConfig) {
				queue.defer(_this.request, queryConfig);
			});

			queue.awaitAll(function (error) {
				for (var _len = arguments.length, responses = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					responses[_key - 1] = arguments[_key];
				}

				if (error) {
					reject(error);
				} else {
					resolve.apply(undefined, responses);
				}
			});
		});
	},

	request: function request(queryConfig, callback) {

		cartoDBClient.sqlRequest(queryConfig.query, function (err, response) {
			if (!err) {
				var innerResponse = void 0;
				switch (queryConfig.format.toLowerCase()) {
					case 'geojson':
						innerResponse = response.features;
						break;
					default:
						innerResponse = response.rows;
						break;
				}
				callback(null, innerResponse);
			} else {
				callback(err);
			}
		}, {
			'format': queryConfig.format,
			'dangerouslyExposedAPIKey': _config2.default.apiKey
		});
	}

};

exports.default = CartoDBLoader;

},{"../../basemaps/cartodb/config.json":"/Users/nayers/Documents/Panorama/panorama-holc/basemaps/cartodb/config.json","cartodb-client":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/cartodb-client/index.js","queue-async":"/Users/nayers/Documents/Panorama/panorama-holc/node_modules/queue-async/build/queue.js"}]},{},["/Users/nayers/Documents/Panorama/panorama-holc/src/main.jsx"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJiYXNlbWFwcy9jYXJ0b2RiL2Jhc2VtYXBzLmpzb24iLCJiYXNlbWFwcy9jYXJ0b2RiL2NvbmZpZy5qc29uIiwiYmFzZW1hcHMvdGlsZUxheWVycy5qc29uIiwiZGF0YS9mb3Jtc01ldGFkYXRhLmpzb24iLCJkYXRhL3Bhbm9yYW1hX25hdi5qc29uIiwiZGF0YS9zdGF0ZV9hYmJyLmpzb24iLCJub2RlX21vZHVsZXMvQHBhbm9yYW1hL3Rvb2xraXQvZGlzdC9jb21wb25lbnRzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXJ0b2RiLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYXJ0b2RiLWNsaWVudC9zcmMvY2FydG9kYi1jbGllbnQuanMiLCJub2RlX21vZHVsZXMvZDMvZDMuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9pbnRyby5qcy9pbnRyby5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2FycmF5L2xhc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2NvbGxlY3Rpb24vZm9yRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29sbGVjdGlvbi9yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2Z1bmN0aW9uL3Jlc3RQYXJhbS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYXJyYXlDb3B5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9hcnJheUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYXNzaWduV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUNhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VDb3B5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VGb3JJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUZvck93bi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUlzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUlzTWF0Y2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VNYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VTbGljZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iaW5kQ2FsbGJhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2J1ZmZlckNsb25lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvY3JlYXRlQmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2NyZWF0ZUJhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2NyZWF0ZUZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2NyZWF0ZVJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvZ2V0TGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaW5pdENsb25lQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pbml0Q2xvbmVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaXNLZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvcGlja0J5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL3BpY2tCeUNhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9zaGltS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvdG9PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL3RvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc05hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNVbmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9vYmplY3Qva2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9vYmplY3QvcGFpcnMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL29iamVjdC9waWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91dGlsaXR5L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91dGlsaXR5L3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91dGlsaXR5L3VuaXF1ZUlkLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcXVldWUtYXN5bmMvYnVpbGQvcXVldWUuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL2xpYi9IYW5kbGUuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL2xpYi9NYXJrcy5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbGliL1NsaWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbGliL1N0ZXBzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9saWIvVHJhY2suanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL2xpYi9Ub29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL2xpYi9wbGFjZW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9saWIvTGF6eVJlbmRlckJveC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbGliL1BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbGliL1RyaWdnZXIuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbGliL0FsaWduLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbGliL2lzV2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvYWRqdXN0Rm9yVmlld3BvcnQuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbGlnbi9ub2RlX21vZHVsZXMvZG9tLWFsaWduL2xpYi9nZXRBbGlnbk9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbm9kZV9tb2R1bGVzL3JjLWFsaWduL25vZGVfbW9kdWxlcy9kb20tYWxpZ24vbGliL2dldEVsRnV0dXJlUG9zLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvZ2V0T2Zmc2V0UGFyZW50LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvZ2V0UmVnaW9uLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYWxpZ24vbm9kZV9tb2R1bGVzL2RvbS1hbGlnbi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbGlnbi9ub2RlX21vZHVsZXMvZG9tLWFsaWduL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbm9kZV9tb2R1bGVzL3JjLWFuaW1hdGUvbGliL0FuaW1hdGUuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL2xpYi9BbmltYXRlQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL2xpYi9DaGlsZHJlblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYW5pbWF0ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYW5pbWF0ZS9ub2RlX21vZHVsZXMvY3NzLWFuaW1hdGlvbi9saWIvRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy10b29sdGlwL25vZGVfbW9kdWxlcy9yYy10cmlnZ2VyL25vZGVfbW9kdWxlcy9yYy1hbmltYXRlL25vZGVfbW9kdWxlcy9jc3MtYW5pbWF0aW9uL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXRvb2x0aXAvbm9kZV9tb2R1bGVzL3JjLXRyaWdnZXIvbm9kZV9tb2R1bGVzL3JjLWFuaW1hdGUvbm9kZV9tb2R1bGVzL2Nzcy1hbmltYXRpb24vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1jbGFzc2VzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdG9vbHRpcC9ub2RlX21vZHVsZXMvcmMtdHJpZ2dlci9ub2RlX21vZHVsZXMvcmMtYW5pbWF0ZS9ub2RlX21vZHVsZXMvY3NzLWFuaW1hdGlvbi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWNsYXNzZXMvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvcmMtdXRpbC9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL2xpYi9Eb20vY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL2xpYi9jcmVhdGVDaGFpbmVkRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL25vZGVfbW9kdWxlcy9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudEJhc2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmMtc2xpZGVyL25vZGVfbW9kdWxlcy9yYy11dGlsL25vZGVfbW9kdWxlcy9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yYy1zbGlkZXIvbm9kZV9tb2R1bGVzL3JjLXV0aWwvbm9kZV9tb2R1bGVzL2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JjLXNsaWRlci9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL0Jhc2VUaWxlTGF5ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvQ2FudmFzVGlsZUxheWVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL0NpcmNsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9DaXJjbGVNYXJrZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvRmVhdHVyZUdyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL0dlb0pzb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvSW1hZ2VPdmVybGF5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL0xheWVyR3JvdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvTWFwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL01hcENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXBMYXllci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXJrZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvTXVsdGlQb2x5Z29uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL011bHRpUG9seWxpbmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9Qb2x5Z29uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1BvbHlsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1BvcHVwQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL1JlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9UaWxlTGF5ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvV01TVGlsZUxheWVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL3R5cGVzL2JvdW5kcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi90eXBlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi90eXBlcy9sYXRsbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC9saWIvdHlwZXMvbGF0bG5nTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvY29tcG9uZW50cy9Nb2RhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvY29tcG9uZW50cy9Nb2RhbFBvcnRhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9hcmlhQXBwSGlkZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvZm9jdXNNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL3Njb3BlVGFiLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL3RhYmJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvZWxlbWVudC1jbGFzcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvZXhlbnYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2Vjb3B5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL25vZGVfbW9kdWxlcy9sb2Rhc2guX2JpbmRjYWxsYmFjay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9jcmVhdGVhc3NpZ25lci9ub2RlX21vZHVsZXMvbG9kYXNoLl9pc2l0ZXJhdGVlY2FsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9jcmVhdGVhc3NpZ25lci9ub2RlX21vZHVsZXMvbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5rZXlzL25vZGVfbW9kdWxlcy9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9saWIvYWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtdHlwZWFoZWFkL2xpYi9rZXlldmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL3JlYWN0LXR5cGVhaGVhZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL3Rva2VuaXplci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL3Rva2VuaXplci90b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL3R5cGVhaGVhZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC10eXBlYWhlYWQvbGliL3R5cGVhaGVhZC9vcHRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtdHlwZWFoZWFkL2xpYi90eXBlYWhlYWQvc2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtdHlwZWFoZWFkL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXR5cGVhaGVhZC9ub2RlX21vZHVsZXMvZnV6enkvbGliL2Z1enp5LmpzIiwic3JjL0FwcC5qc3giLCJzcmMvY29tcG9uZW50cy9BRENhdC5qc3giLCJzcmMvY29tcG9uZW50cy9BcmVhRGVzY3JpcHRpb24uanN4Iiwic3JjL2NvbXBvbmVudHMvQXJlYVBvbHlnb24uanN4Iiwic3JjL2NvbXBvbmVudHMvQ2l0eVNuaXBwZXQuanN4Iiwic3JjL2NvbXBvbmVudHMvQ2l0eVN0YXRzLmpzeCIsInNyYy9jb21wb25lbnRzL0RvbnV0L0RvbnV0LmpzeCIsInNyYy9jb21wb25lbnRzL0RvbnV0L0wuRG9udXQuanMiLCJzcmMvY29tcG9uZW50cy9Eb3dubG9hZGVyLmpzeCIsInNyYy9jb21wb25lbnRzL1N0YXRlU3RhdHMuanN4Iiwic3JjL2NvbXBvbmVudHMvVHlwZUFoZWFkQ2l0eVNuaXBwZXQuanN4Iiwic3JjL21haW4uanN4Iiwic3JjL3N0b3Jlcy9BcmVhRGVzY3JpcHRpb25zU3RvcmUuanMiLCJzcmMvc3RvcmVzL0NpdHlTdG9yZS5qcyIsInNyYy9zdG9yZXMvTWFwU3RhdGVTdG9yZS5qcyIsInNyYy9zdG9yZXMvUmFzdGVyU3RvcmUuanMiLCJzcmMvc3RvcmVzL1RleHRzU3RvcmUuanMiLCJzcmMvc3RvcmVzL1VzZXJMb2NhdGlvblN0b3JlLmpzIiwic3JjL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3IuanMiLCJzcmMvdXRpbHMvQXBwRGlzcGF0Y2hlci5qcyIsInNyYy91dGlscy9DYXJ0b0RCTG9hZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1eENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QU4sQ0FBWSxNQUFLLE9BQUwsRUFBYyxXQUExQixFQURxQztJQUFqQixDQUFyQixDQUp1Qzs7QUFRdkMsU0FBTSxRQUFOLENBQWUsVUFBQyxLQUFELEVBQXlCO3NDQUFkOztLQUFjOztBQUN2QyxRQUFJLEtBQUosRUFBVztBQUNWLFlBQU8sS0FBUCxFQURVO0tBQVgsTUFFTztBQUNOLDhCQUFXLFNBQVgsRUFETTtLQUZQO0lBRGMsQ0FBZixDQVJ1QztHQUFyQixDQUFuQixDQUY4QjtFQUF4Qjs7QUFzQlAsVUFBUyxpQkFBVSxXQUFWLEVBQXVCLFFBQXZCLEVBQWlDOztBQUV6QyxnQkFBYyxVQUFkLENBQXlCLFlBQVksS0FBWixFQUFtQixVQUFTLEdBQVQsRUFBYyxRQUFkLEVBQXdCO0FBQ25FLE9BQUksQ0FBQyxHQUFELEVBQU07QUFDVCxRQUFJLHNCQUFKLENBRFM7QUFFVCxZQUFRLFlBQVksTUFBWixDQUFtQixXQUFuQixFQUFSO0FBQ0MsVUFBSyxTQUFMO0FBQ0Msc0JBQWdCLFNBQVMsUUFBVCxDQURqQjtBQUVDLFlBRkQ7QUFERDtBQUtFLHNCQUFnQixTQUFTLElBQVQsQ0FEakI7QUFFQyxZQUZEO0FBSkQsS0FGUztBQVVULGFBQVMsSUFBVCxFQUFlLGFBQWYsRUFWUztJQUFWLE1BV087QUFDTixhQUFTLEdBQVQsRUFETTtJQVhQO0dBRDJDLEVBZXpDO0FBQ0YsYUFBVSxZQUFZLE1BQVo7QUFDViwrQkFBNEIsaUJBQU8sTUFBUDtHQWpCN0IsRUFGeUM7RUFBakM7O0NBNUJKOztrQkFzRFMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHM9e1wibmFtZVwiOlwiUGFub3JhbWFCYXNlbWFwXCIsXCJ2ZXJzaW9uXCI6XCIwLjAuMVwiLFwibGF5ZXJncm91cFwiOntcInZlcnNpb25cIjpcIjEuMy4wXCIsXCJsYXllcnNcIjpbe1widHlwZVwiOlwibWFwbmlrXCIsXCJvcHRpb25zXCI6e1wic3FsXCI6XCJTRUxFQ1QgY2FydG9kYl9pZCwgY2l0eSwgU1RfVHJhbnNmb3JtKFNUX1NldFNSSUQoc3RfbWFrZXBvaW50KGxvb3BsbmcsbG9vcGxhdCksNDMyNiksIDM4NTcpIGFzIHRoZV9nZW9tX3dlYm1lcmNhdG9yIEZST00gaG9sY19hZHNcXG5cIixcImNhcnRvY3NzXCI6XCIjaG9sY19hZHM6OmxhYmVscyB7XFxuICB0ZXh0LW5hbWU6IFtjaXR5XTtcXG4gIHRleHQtZmFjZS1uYW1lOiAnRGVqYVZ1IFNhbnMgQm9vayc7XFxuICB0ZXh0LXNpemU6IDEwO1xcbiAgdGV4dC1sYWJlbC1wb3NpdGlvbi10b2xlcmFuY2U6IDA7XFxuICB0ZXh0LWZpbGw6ICMwRjNCODI7XFxuICB0ZXh0LWhhbG8tZmlsbDogI0ZGRjtcXG4gIHRleHQtaGFsby1yYWRpdXM6IDE7XFxuICB0ZXh0LWR5OiAtMTA7XFxuICB0ZXh0LWFsbG93LW92ZXJsYXA6IGZhbHNlO1xcbiAgdGV4dC1wbGFjZW1lbnQ6IHBvaW50O1xcbiAgdGV4dC1wbGFjZW1lbnQtdHlwZTogZHVtbXk7XFxufVwiLFwiY2FydG9jc3NfdmVyc2lvblwiOlwiMi4xLjFcIn19XSxcIm1pbnpvb21cIjoyLFwibWF4em9vbVwiOjl9fVxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG5cdFwidXNlcklkXCI6IFwiZGlnaXRhbHNjaG9sYXJzaGlwbGFiXCIsXHJcblx0XCJhcGlLZXlcIjogXCJcIlxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJsYXllcnNcIjogW1xuXHRcdHtcblx0XHRcdFwidXJsTm9MYWJlbHNcIjogXCJodHRwOi8ve3N9LmJhc2VtYXBzLmNhcnRvY2RuLmNvbS9saWdodF9ub2xhYmVscy97en0ve3h9L3t5fS5wbmdcIixcblx0XHRcdFwidXJsTGFiZWxzXCI6IFwiaHR0cDovL3tzfS5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfYWxsL3t6fS97eH0ve3l9LnBuZ1wiXG5cdFx0fVxuXHRdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiMTkzNzAyMDNcIjoge1xuXHRcdFwiMVwiOiBbXG5cdFx0XHRcIk5hbWUgb2YgQ2l0eVwiLFxuXHRcdFx0XCJTZWN1cml0eSBHcmFkZVwiLFxuXHRcdFx0XCJBcmVhIE5vXCJcblx0XHRdLFxuXHRcdFwiMlwiOiBcIkRlc2NyaXB0aW9uIG9mIFRlcnJhaW5cIixcblx0XHRcIjNcIjogXCJGYXZvcmFibGUgSW5mbHVlbmNlc1wiLFxuXHRcdFwiNFwiOiBcIkRldHJpbWVudGFsIEluZmx1ZW5jZXNcIixcblx0XHRcIjVcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJJbmhhYml0YW50c1wiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiVHlwZVwiLFxuXHRcdFx0XHRcImJcIjogXCJFc3RpbWF0ZWQgYW5udWFsIGZhbWlseSBpbmNvbWVcIixcblx0XHRcdFx0XCJjXCI6IFwiRm9yZWlnbi1ib3JuXCIsXG5cdFx0XHRcdFwiZFwiOiBcIk5lZ3JvXCIsXG5cdFx0XHRcdFwiZVwiOiBcIkluZmlsdHJhdGlvbiBvZlwiLFxuXHRcdFx0XHRcImZcIjogXCJSZWxpZWYgZmFtaWxpZXNcIixcblx0XHRcdFx0XCJnXCI6IFwiUG9wdWxhdGlvbiBpc1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjZcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJCdWlsZGluZ3NcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIlR5cGUgb3IgVHlwZXNcIixcblx0XHRcdFx0XCJiXCI6IFwiVHlwZSBvZiBDb25zdHJ1Y3Rpb25cIixcblx0XHRcdFx0XCJjXCI6IFwiQXZlcmFnZSBhZ2VcIixcblx0XHRcdFx0XCJkXCI6IFwiUmVwYWlyXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiOFwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIk9jY3VwYW5jeVwiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiTGFuZFwiLFxuXHRcdFx0XHRcImJcIjogXCJEd2VsbGluZyB1bml0c1wiLFxuXHRcdFx0XHRcImNcIjogXCJIb21lIE93bmVyc1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjlcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJTYWxlcyBEZW1hbmRcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIlwiLFxuXHRcdFx0XHRcImJcIjogXCJcIixcblx0XHRcdFx0XCJjXCI6IFwiQWN0aXZpdHkgaXNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIxMFwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIlJlbnRhbCBEZW1hbmRcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIlwiLFxuXHRcdFx0XHRcImJcIjogXCJcIixcblx0XHRcdFx0XCJjXCI6IFwiQWN0aXZpdHkgaXNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIxMVwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIk5ldyBDb25zdHJ1Y3Rpb25cIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIlR5cGVzXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkFtb3VudCBsYXN0IHllYXJcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIxMlwiOiB7XG5cdFx0XHRcImhlYWRlclwiOiBcIkF2YWlsYWJpbGl0eSBvZiBNb3J0Z2FnZSBGdW5kc1wiLFxuXHRcdFx0XCJzdWJjYXRzXCI6IHtcblx0XHRcdFx0XCJhXCI6IFwiSG9tZSBwdXJjaGFzZVwiLFxuXHRcdFx0XHRcImJcIjogXCJIb21lIGJ1aWxkaW5nXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTNcIjogXCJUcmVuZCBvZiBEZXNpcmVhYmlsaXR5IE5leHQgMTAtMTUgWWVhcnNcIixcblx0XHRcIjE0XCI6IFwiQ2xhcmlmeWluZyBSZW1hcmtzXCIsXG5cdFx0XCIxNVwiOiBcIkluZm9ybWF0aW9uIGZvciB0aGlzIGZvcm0gd2FzIG9idGFpbmVkIGZyb21cIlxuXHR9LFxuXHRcIjE5MzcwODI2XCI6IHtcblx0XHRcIjFcIjogW1xuXHRcdFx0XCJOYW1lIG9mIENpdHlcIixcblx0XHRcdFwiU2VjdXJpdHkgR3JhZGVcIixcblx0XHRcdFwiQXJlYSBOb1wiXG5cdFx0XSxcblx0XHRcIjJcIjogXCJEZXNjcmlwdGlvbiBvZiBUZXJyYWluXCIsXG5cdFx0XCIzXCI6IFwiRmF2b3JhYmxlIEluZmx1ZW5jZXNcIixcblx0XHRcIjRcIjogXCJEZXRyaW1lbnRhbCBJbmZsdWVuY2VzXCIsXG5cdFx0XCI1XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiSW5oYWJpdGFudHNcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIlR5cGVcIixcblx0XHRcdFx0XCJiXCI6IFwiRXN0aW1hdGVkIGFubnVhbCBmYW1pbHkgaW5jb21lXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkZvcmVpZ24tYm9yblwiLFxuXHRcdFx0XHRcImRcIjogXCJOZWdyb1wiLFxuXHRcdFx0XHRcImVcIjogXCJJbmZpbHRyYXRpb24gb2ZcIixcblx0XHRcdFx0XCJmXCI6IFwiUmVsaWVmIGZhbWlsaWVzXCIsXG5cdFx0XHRcdFwiZ1wiOiBcIlBvcHVsYXRpb24gaXNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI2XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiQnVpbGRpbmdzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJUeXBlIG9yIFR5cGVzXCIsXG5cdFx0XHRcdFwiYlwiOiBcIlR5cGUgb2YgQ29uc3RydWN0aW9uXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkF2ZXJhZ2UgYWdlXCIsXG5cdFx0XHRcdFwiZFwiOiBcIlJlcGFpclwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjhcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJPY2N1cGFuY3lcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIkxhbmRcIixcblx0XHRcdFx0XCJiXCI6IFwiRHdlbGxpbmcgdW5pdHNcIixcblx0XHRcdFx0XCJjXCI6IFwiSG9tZSBPd25lcnNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI5XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiU2FsZXMgRGVtYW5kXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJcIixcblx0XHRcdFx0XCJiXCI6IFwiXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkFjdGl2aXR5IGlzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTBcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJSZW50YWwgRGVtYW5kXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJcIixcblx0XHRcdFx0XCJiXCI6IFwiXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkFjdGl2aXR5IGlzXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTFcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJOZXcgQ29uc3RydWN0aW9uXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJUeXBlc1wiLFxuXHRcdFx0XHRcImJcIjogXCJBbW91bnQgbGFzdCB5ZWFyXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiMTJcIjoge1xuXHRcdFx0XCJoZWFkZXJcIjogXCJBdmFpbGFiaWxpdHkgb2YgTW9ydGdhZ2UgRnVuZHNcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIkhvbWUgcHVyY2hhc2VcIixcblx0XHRcdFx0XCJiXCI6IFwiSG9tZSBidWlsZGluZ1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjEzXCI6IFwiVHJlbmQgb2YgRGVzaXJlYWJpbGl0eSBOZXh0IDEwLTE1IFllYXJzXCIsXG5cdFx0XCIxNFwiOiBcIkNsYXJpZnlpbmcgUmVtYXJrc1wiLFxuXHRcdFwiMTVcIjogXCJJbmZvcm1hdGlvbiBmb3IgdGhpcyBmb3JtIHdhcyBvYnRhaW5lZCBmcm9tXCJcblx0fSxcblx0XCIxOTM3MTAwMVwiOiB7XG5cdFx0XCIxXCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiQXJlYSBDaGFyYWN0ZXJpc3RpY3NcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIkRlc2NyaXB0aW9uIG9mIFRlcnJhaW5cIixcblx0XHRcdFx0XCJiXCI6IFwiRmF2b3JhYmxlIEluZmx1ZW5jZXNcIixcblx0XHRcdFx0XCJjXCI6IFwiRGV0cmltZW50YWwgSW5mbHVlbmNlc1wiLFxuXHRcdFx0XHRcImRcIjogXCJQZXJjZW50YWdlIG9mIGxhbmQgaW1wcm92ZWRcIixcblx0XHRcdFx0XCJlXCI6IFwiVHJlbmQgb2YgZGVzaXJlYWJpbGl0eSBuZXh0IDEwLTE1IHlycy5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIyXCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiSW5oYWJpdGFudHNcIixcblx0XHRcdFwic3ViY2F0c1wiOiB7XG5cdFx0XHRcdFwiYVwiOiBcIk9jY3VwYXRpb25cIixcblx0XHRcdFx0XCJiXCI6IFwiRXN0aW1hdGVkIEFubnVhbCBGYW1pbHkgSW5jb21lXCIsXG5cdFx0XHRcdFwiY1wiOiBcIkZvcmVpZ24tYm9ybiBmYW1pbGllc1wiLFxuXHRcdFx0XHRcImRcIjogXCJOZWdyb1wiLFxuXHRcdFx0XHRcImVcIjogXCJJbmZpbHRyYXRpb24gb2ZcIixcblx0XHRcdFx0XCJmXCI6IFwiUmVsaWVmIGZhbWlsaWVzXCIsXG5cdFx0XHRcdFwiZ1wiOiBcIlBvcHVsYXRpb24gaXNcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI0XCI6IHtcblx0XHRcdFwiaGVhZGVyXCI6IFwiQXZhaWxhYmlsaXR5IG9mIE1vcnRnYWdlIEZ1bmRzXCIsXG5cdFx0XHRcInN1YmNhdHNcIjoge1xuXHRcdFx0XHRcImFcIjogXCJIb21lIHB1cmNoYXNlXCIsXG5cdFx0XHRcdFwiYlwiOiBcIkhvbWUgYnVpbGRpbmdcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI1XCI6IFwiQ2xhcmlmeWluZyBSZW1hcmtzXCIsXG5cdFx0XCI2XCI6IFtcblx0XHRcdFwiTmFtZSBhbmQgTG9jYXRpb25cIixcblx0XHRcdFwiU2VjdXJpdHkgR3JhZGVcIixcblx0XHRcdFwiQXJlYSBOby5cIlxuXHRcdF0sXG5cdH1cblxufSIsIm1vZHVsZS5leHBvcnRzPVtcblx0e1xuXHRcdFwidGl0bGVcIiAgICAgICAgIDogXCJUaGUgRm9yY2VkIE1pZ3JhdGlvbiBvZiBFbnNsYXZlZCBQZW9wbGVcIixcblx0XHRcInVybFwiICAgICAgICAgICA6IFwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvZm9yY2VkbWlncmF0aW9uL1wiLFxuXHRcdFwic2NyZWVuc2hvdFwiICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9zdGF0aWMvaW1hZ2VzL2ZvcmNlZC1taWdyYXRpb24taW1nLnBuZ1wiLFxuXHRcdFwic3RhcnRfeWVhclwiICAgIDogMTgxMCxcblx0XHRcImVuZF95ZWFyXCIgICAgICA6IDE4NjAsXG5cdFx0XCJ0YWdzXCIgICAgICAgICAgOiBbXVxuXHR9LFxuXHR7XG5cdFx0XCJ0aXRsZVwiICAgICAgICAgOiBcIlRoZSBPdmVybGFuZCBUcmFpbHNcIixcblx0XHRcInVybFwiICAgICAgICAgICA6IFwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvb3ZlcmxhbmR0cmFpbHMvXCIsXG5cdFx0XCJzY3JlZW5zaG90XCIgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL3N0YXRpYy9pbWFnZXMvb3ZlcmxhbmQtaW1nLnBuZ1wiLFxuXHRcdFwic3RhcnRfeWVhclwiICAgIDogMTg0MCxcblx0XHRcImVuZF95ZWFyXCIgICAgICA6IDE4NjAsXG5cdFx0XCJ0YWdzXCIgICAgICAgICAgOiBbXVxuXHR9LFxuXHR7XG5cdFx0XCJ0aXRsZVwiICAgICAgICAgOiBcIkZvcmVpZ24tQm9ybiBQb3B1bGF0aW9uXCIsXG5cdFx0XCJ1cmxcIiAgICAgICAgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL2ZvcmVpZ25ib3JuL1wiLFxuXHRcdFwic2NyZWVuc2hvdFwiICAgIDogXCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9zdGF0aWMvaW1hZ2VzL2ZvcmVpZ24tYm9ybi1pbWcucG5nXCIsXG5cdFx0XCJzdGFydF95ZWFyXCIgICAgOiAxODUwLFxuXHRcdFwiZW5kX3llYXJcIiAgICAgIDogMjAxMCxcblx0XHRcInRhZ3NcIiAgICAgICAgICA6IFtdXG5cdH0sXG5cdHtcblx0XHRcInRpdGxlXCIgICAgICAgICA6IFwiQ2FuYWxzXCIsXG5cdFx0XCJ1cmxcIiAgICAgICAgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL2NhbmFscy9cIixcblx0XHRcInNjcmVlbnNob3RcIiAgICA6IFwiaHR0cDovL2RzbC5yaWNobW9uZC5lZHUvcGFub3JhbWEvc3RhdGljL2ltYWdlcy9jYW5hbC1pbWcucG5nXCIsXG5cdFx0XCJzdGFydF95ZWFyXCIgICAgOiAxODAwLFxuXHRcdFwiZW5kX3llYXJcIiAgICAgIDogMTg2MCxcblx0XHRcInRhZ3NcIiAgICAgICAgICA6IFtdXG5cdH0sXG5cdHtcblx0XHRcInRpdGxlXCIgICAgICAgICA6IFwiTWFwcGluZyBJbmVxdWFsaXR5XCIsXG5cdFx0XCJ1cmxcIiAgICAgICAgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL2hvbGMvXCIsXG5cdFx0XCJzY3JlZW5zaG90XCIgICAgOiBcImh0dHA6Ly9kc2wucmljaG1vbmQuZWR1L3Bhbm9yYW1hL3N0YXRpYy9pbWFnZXMvaG9sYy1pbWcucG5nXCIsXG5cdFx0XCJzdGFydF95ZWFyXCIgICAgOiAxODAwLFxuXHRcdFwiZW5kX3llYXJcIiAgICAgIDogMTg2MCxcblx0XHRcInRhZ3NcIiAgICAgICAgICA6IFtdXG5cdH1cbl0iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJBTFwiOiBcIkFsYWJhbWFcIixcbiAgICBcIkFLXCI6IFwiQWxhc2thXCIsXG4gICAgXCJBU1wiOiBcIkFtZXJpY2FuIFNhbW9hXCIsXG4gICAgXCJBWlwiOiBcIkFyaXpvbmFcIixcbiAgICBcIkFSXCI6IFwiQXJrYW5zYXNcIixcbiAgICBcIkNBXCI6IFwiQ2FsaWZvcm5pYVwiLFxuICAgIFwiQ09cIjogXCJDb2xvcmFkb1wiLFxuICAgIFwiQ1RcIjogXCJDb25uZWN0aWN1dFwiLFxuICAgIFwiREVcIjogXCJEZWxhd2FyZVwiLFxuICAgIFwiRENcIjogXCJEaXN0cmljdCBPZiBDb2x1bWJpYVwiLFxuICAgIFwiRk1cIjogXCJGZWRlcmF0ZWQgU3RhdGVzIE9mIE1pY3JvbmVzaWFcIixcbiAgICBcIkZMXCI6IFwiRmxvcmlkYVwiLFxuICAgIFwiR0FcIjogXCJHZW9yZ2lhXCIsXG4gICAgXCJHVVwiOiBcIkd1YW1cIixcbiAgICBcIkhJXCI6IFwiSGF3YWlpXCIsXG4gICAgXCJJRFwiOiBcIklkYWhvXCIsXG4gICAgXCJJTFwiOiBcIklsbGlub2lzXCIsXG4gICAgXCJJTlwiOiBcIkluZGlhbmFcIixcbiAgICBcIklBXCI6IFwiSW93YVwiLFxuICAgIFwiS1NcIjogXCJLYW5zYXNcIixcbiAgICBcIktZXCI6IFwiS2VudHVja3lcIixcbiAgICBcIkxBXCI6IFwiTG91aXNpYW5hXCIsXG4gICAgXCJNRVwiOiBcIk1haW5lXCIsXG4gICAgXCJNSFwiOiBcIk1hcnNoYWxsIElzbGFuZHNcIixcbiAgICBcIk1EXCI6IFwiTWFyeWxhbmRcIixcbiAgICBcIk1BXCI6IFwiTWFzc2FjaHVzZXR0c1wiLFxuICAgIFwiTUlcIjogXCJNaWNoaWdhblwiLFxuICAgIFwiTU5cIjogXCJNaW5uZXNvdGFcIixcbiAgICBcIk1TXCI6IFwiTWlzc2lzc2lwcGlcIixcbiAgICBcIk1PXCI6IFwiTWlzc291cmlcIixcbiAgICBcIk1UXCI6IFwiTW9udGFuYVwiLFxuICAgIFwiTkVcIjogXCJOZWJyYXNrYVwiLFxuICAgIFwiTlZcIjogXCJOZXZhZGFcIixcbiAgICBcIk5IXCI6IFwiTmV3IEhhbXBzaGlyZVwiLFxuICAgIFwiTkpcIjogXCJOZXcgSmVyc2V5XCIsXG4gICAgXCJOTVwiOiBcIk5ldyBNZXhpY29cIixcbiAgICBcIk5ZXCI6IFwiTmV3IFlvcmtcIixcbiAgICBcIk5DXCI6IFwiTm9ydGggQ2Fyb2xpbmFcIixcbiAgICBcIk5EXCI6IFwiTm9ydGggRGFrb3RhXCIsXG4gICAgXCJNUFwiOiBcIk5vcnRoZXJuIE1hcmlhbmEgSXNsYW5kc1wiLFxuICAgIFwiT0hcIjogXCJPaGlvXCIsXG4gICAgXCJPS1wiOiBcIk9rbGFob21hXCIsXG4gICAgXCJPUlwiOiBcIk9yZWdvblwiLFxuICAgIFwiUFdcIjogXCJQYWxhdVwiLFxuICAgIFwiUEFcIjogXCJQZW5uc3lsdmFuaWFcIixcbiAgICBcIlBSXCI6IFwiUHVlcnRvIFJpY29cIixcbiAgICBcIlJJXCI6IFwiUmhvZGUgSXNsYW5kXCIsXG4gICAgXCJTQ1wiOiBcIlNvdXRoIENhcm9saW5hXCIsXG4gICAgXCJTRFwiOiBcIlNvdXRoIERha290YVwiLFxuICAgIFwiVE5cIjogXCJUZW5uZXNzZWVcIixcbiAgICBcIlRYXCI6IFwiVGV4YXNcIixcbiAgICBcIlVUXCI6IFwiVXRhaFwiLFxuICAgIFwiVlRcIjogXCJWZXJtb250XCIsXG4gICAgXCJWSVwiOiBcIlZpcmdpbiBJc2xhbmRzXCIsXG4gICAgXCJWQVwiOiBcIlZpcmdpbmlhXCIsXG4gICAgXCJXQVwiOiBcIldhc2hpbmd0b25cIixcbiAgICBcIldWXCI6IFwiV2VzdCBWaXJnaW5pYVwiLFxuICAgIFwiV0lcIjogXCJXaXNjb25zaW5cIixcbiAgICBcIldZXCI6IFwiV3lvbWluZ1wiXG59IiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwicmVhY3RcIikscmVxdWlyZShcImQzXCIpLHJlcXVpcmUoXCJsZWFmbGV0XCIpLHJlcXVpcmUoXCJyZWFjdC1sZWFmbGV0XCIpLHJlcXVpcmUoXCJyZWFjdC1kb21cIikscmVxdWlyZShcImNhcnRvZGItY2xpZW50XCIpLHJlcXVpcmUoXCJpbnRyby5qc1wiKSxyZXF1aXJlKFwicXVldWUtYXN5bmNcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wicmVhY3RcIixcImQzXCIsXCJsZWFmbGV0XCIsXCJyZWFjdC1sZWFmbGV0XCIsXCJyZWFjdC1kb21cIixcImNhcnRvZGItY2xpZW50XCIsXCJpbnRyby5qc1wiLFwicXVldWUtYXN5bmNcIl0sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0c1tcIkBwYW5vcmFtYS90b29sa2l0XCJdPWUocmVxdWlyZShcInJlYWN0XCIpLHJlcXVpcmUoXCJkM1wiKSxyZXF1aXJlKFwibGVhZmxldFwiKSxyZXF1aXJlKFwicmVhY3QtbGVhZmxldFwiKSxyZXF1aXJlKFwicmVhY3QtZG9tXCIpLHJlcXVpcmUoXCJjYXJ0b2RiLWNsaWVudFwiKSxyZXF1aXJlKFwiaW50cm8uanNcIikscmVxdWlyZShcInF1ZXVlLWFzeW5jXCIpKTp0W1wiQHBhbm9yYW1hL3Rvb2xraXRcIl09ZSh0LlJlYWN0LHQuZDMsdC5sZWFmbGV0LHRbXCJyZWFjdC1sZWFmbGV0XCJdLHRbXCJyZWFjdC1kb21cIl0sdFtcImNhcnRvZGItY2xpZW50XCJdLHRbXCJpbnRyby5qc1wiXSx0W1wicXVldWUtYXN5bmNcIl0pfSh0aGlzLGZ1bmN0aW9uKHQsZSxuLG8saSxzLGEsdSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciBvPW5bcl09e2V4cG9ydHM6e30saWQ6cixsb2FkZWQ6ITF9O3JldHVybiB0W3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLGUpLG8ubG9hZGVkPSEwLG8uZXhwb3J0c312YXIgbj17fTtyZXR1cm4gZS5tPXQsZS5jPW4sZS5wPVwiXCIsZSgwKX0oZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkpc3dpdGNoKHR5cGVvZiB0W2VdKXtjYXNlXCJmdW5jdGlvblwiOmJyZWFrO2Nhc2VcIm9iamVjdFwiOnRbZV09ZnVuY3Rpb24oZSl7dmFyIG49ZS5zbGljZSgxKSxyPXRbZVswXV07cmV0dXJuIGZ1bmN0aW9uKHQsZSxvKXtyLmFwcGx5KHRoaXMsW3QsZSxvXS5jb25jYXQobikpfX0odFtlXSk7YnJlYWs7ZGVmYXVsdDp0W2VdPXRbdFtlXV19cmV0dXJuIHR9KFtmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89big0NSksaT1yKG8pLHM9big3MiksYT1yKHMpLHU9big3MyksbD1yKHUpLGM9big3NCkscD1yKGMpLGY9big0NiksaD1yKGYpLGQ9big4MSkseT1yKGQpLHY9big3NSksbT1yKHYpLGc9big3NikseD1yKGcpLGI9big3OCksaz1yKGIpLF89big3OSksUD1yKF8pLFQ9big4MCksTz1yKFQpLHc9big4NCksTT1yKHcpLEU9big4NSksQz1yKEUpLFM9big4Nyksaj1yKFMpLEE9big4OSksTD1yKEEpLEk9big5MCksUj1yKEkpLEQ9bigzMSksTj1uKDkyKSxGPXIoTiksSD1uKDk3KSxVPXIoSCkscT1uKDkzKSxXPXIocSksQj1uKDgzKSx6PXIoQiksSz1uKDk1KSxHPXIoSyk7ZVtcImRlZmF1bHRcIl09e0FyZWFDaGFydDppW1wiZGVmYXVsdFwiXSxDYXJ0b0RCTG9hZGVyOmFbXCJkZWZhdWx0XCJdLENhcnRvREJUaWxlTGF5ZXI6bFtcImRlZmF1bHRcIl0sQ2hhcnRTbGlkZXI6cFtcImRlZmF1bHRcIl0sRGlzY3JldGVCYXJDaGFydDpoW1wiZGVmYXVsdFwiXSxEb251dDp5W1wiZGVmYXVsdFwiXSxIYXNoTWFuYWdlcjptW1wiZGVmYXVsdFwiXSxIb3Jpem9udGFsRGlzY3JldGVCYXJDaGFydDp4W1wiZGVmYXVsdFwiXSxJbnRyb01hbmFnZXI6a1tcImRlZmF1bHRcIl0sSXRlbVNlbGVjdG9yOlBbXCJkZWZhdWx0XCJdLExlYWZsZXRDaG9yb3BsZXRoOk9bXCJkZWZhdWx0XCJdLExlZ2VuZDpNW1wiZGVmYXVsdFwiXSxMaW5lQ2hhcnQ6Q1tcImRlZmF1bHRcIl0sTWFwQ2hvcm9wbGV0aDpqW1wiZGVmYXVsdFwiXSxOYXZpZ2F0aW9uOkxbXCJkZWZhdWx0XCJdLE9mZnNldEFyZWFDaGFydDpSW1wiZGVmYXVsdFwiXSxQYW5vcmFtYURpc3BhdGNoZXI6RC5QYW5vcmFtYURpc3BhdGNoZXIsUGFub3JhbWFFdmVudFR5cGVzOkQuUGFub3JhbWFFdmVudFR5cGVzLFB1bmNoY2FyZDpGW1wiZGVmYXVsdFwiXSxUaW1lQmFzZWRNYXJrZXJzOlVbXCJkZWZhdWx0XCJdLFRvb2x0aXA6eltcImRlZmF1bHRcIl0sU2NhdHRlclBsb3Q6V1tcImRlZmF1bHRcIl0sVGV4dHVyYWxMaXN0OkdbXCJkZWZhdWx0XCJdfSx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntcImRlZmF1bHRcIjp0fX0sZS5fX2VzTW9kdWxlPSEwfSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2VbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0sZS5fX2VzTW9kdWxlPSEwfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMDIpW1wiZGVmYXVsdFwiXTtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIG89ZVtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCkscih0LG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxlLl9fZXNNb2R1bGU9ITB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDEwMylbXCJkZWZhdWx0XCJdO2VbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIG89ITA7bzspe3ZhciBpPXQscz1lLGE9bjtvPSExLG51bGw9PT1pJiYoaT1GdW5jdGlvbi5wcm90b3R5cGUpO3ZhciB1PXIoaSxzKTtpZih2b2lkIDAhPT11KXtpZihcInZhbHVlXCJpbiB1KXJldHVybiB1LnZhbHVlO3ZhciBsPXUuZ2V0O2lmKHZvaWQgMD09PWwpcmV0dXJuO3JldHVybiBsLmNhbGwoYSl9dmFyIGM9T2JqZWN0LmdldFByb3RvdHlwZU9mKGkpO2lmKG51bGw9PT1jKXJldHVybjt0PWMsZT1zLG49YSxvPSEwLHU9Yz12b2lkIDB9fSxlLl9fZXNNb2R1bGU9ITB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDEwMSlbXCJkZWZhdWx0XCJdLG89bigxMDUpW1wiZGVmYXVsdFwiXTtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1yKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYobz9vKHQsZSk6dC5fX3Byb3RvX189ZSl9LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj10LmV4cG9ydHM9e3ZlcnNpb246XCIxLjIuNlwifTtcIm51bWJlclwiPT10eXBlb2YgX19lJiYoX19lPW4pfSxmdW5jdGlvbih0LGUpe3ZhciBuPU9iamVjdDt0LmV4cG9ydHM9e2NyZWF0ZTpuLmNyZWF0ZSxnZXRQcm90bzpuLmdldFByb3RvdHlwZU9mLGlzRW51bTp7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxnZXREZXNjOm4uZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLHNldERlc2M6bi5kZWZpbmVQcm9wZXJ0eSxzZXREZXNjczpuLmRlZmluZVByb3BlcnRpZXMsZ2V0S2V5czpuLmtleXMsZ2V0TmFtZXM6bi5nZXRPd25Qcm9wZXJ0eU5hbWVzLGdldFN5bWJvbHM6bi5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsZWFjaDpbXS5mb3JFYWNofX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTMyKShcIndrc1wiKSxvPW4oMTM4KSxpPW4oMTIpLlN5bWJvbDt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHJbdF18fChyW3RdPWkmJmlbdF18fChpfHxvKShcIlN5bWJvbC5cIit0KSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigyMylbXCJkZWZhdWx0XCJdO2VbXCJkZWZhdWx0XCJdPXJ8fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPWFyZ3VtZW50c1tlXTtmb3IodmFyIHIgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmKHRbcl09bltyXSl9cmV0dXJuIHR9LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlKXt2YXIgbj10LmV4cG9ydHM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XCJudW1iZXJcIj09dHlwZW9mIF9fZyYmKF9fZz1uKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMylbXCJkZWZhdWx0XCJdLG89bigyKVtcImRlZmF1bHRcIl0saT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKDcpLGE9aShzKSx1PW4oOTgpLGw9aSh1KSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtvKHRoaXMsdCksdGhpcy5fcHJvcHM9ZSx0aGlzLnJvb3Q9bnVsbCx0aGlzLm1vdW50ZWQ9ITEsdGhpcy5heGVzPVtdLHRoaXMudG9vbHRpcD1udWxsLHRoaXMuZGlzcGF0Y2g9YVtcImRlZmF1bHRcIl0uZGlzcGF0Y2goXCJtb3VudGVkXCIsXCJ1cGRhdGVkXCIsXCJtb3VzZU92ZXJcIixcIm1vdXNlT3V0XCIsXCJtb3VzZU1vdmVcIixcImNsaWNrXCIpfXJldHVybiByKHQsW3trZXk6XCJ3aWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJvbk1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMubW91bnRlZHx8KHRoaXMuYWRkRXZlbnRzKCksdGhpcy5yb290PWFbXCJkZWZhdWx0XCJdLnNlbGVjdCh0aGlzLnNlbGVjdG9yKSx0aGlzLnN2Zz10aGlzLnJvb3QuYXBwZW5kKFwic3ZnXCIpLmNsYXNzZWQoXCJpbnRlcmFjdGl2ZVwiLHRoaXMucHJvcHMuaW50ZXJhY3RpdmUpLHRoaXMucHJvcHMuaW50ZXJhY3RpdmUmJnRoaXMucHJvcHMudG9vbHRpcCYmdGhpcy5zdmcub24oXCJtb3VzZW1vdmVcIix0aGlzLmRpc3BhdGNoLm1vdXNlTW92ZSksdGhpcy5iYXNlPXRoaXMuc3ZnLmFwcGVuZChcImdcIiksdGhpcy51cGRhdGVEaW1lbnNpb25zKCksdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUub25Nb3VudCh0LmJhc2UpfSksdGhpcy50b29sdGlwUmVmJiYodGhpcy50b29sdGlwPW5ldyBsW1wiZGVmYXVsdFwiXSh0aGlzLnRvb2x0aXBSZWYsdGhpcy5wcm9wcy50b29sdGlwT3B0aW9uc3x8e30pLHRoaXMudG9vbHRpcC5yZWxhdGl2ZUNvbnRhaW5lcj10aGlzLnN2ZyksdGhpcy5tb3VudGVkPSEwLHRoaXMuZGlzcGF0Y2gubW91bnRlZCgpKX19LHtrZXk6XCJvblVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5tb3VudGVkJiYodGhpcy51cGRhdGVEaW1lbnNpb25zKCksdGhpcy5fcmVuZGVyKCksdGhpcy5kaXNwYXRjaC51cGRhdGVkKCkpfX0se2tleTpcIm9uVW5Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQub25Vbk1vdW50KCl9KSx0aGlzLmF4ZXMubGVuZ3RoPTAsdGhpcy5yZW1vdmVFdmVudHMoKSx0aGlzLnN2Zy5vbihcIm1vdmVcIixudWxsKSx0aGlzLnN2Zy5yZW1vdmUoKSx0aGlzLnJvb3Q9dGhpcy5zdmc9bnVsbCx0aGlzLm1vdW50ZWQ9ITEsdGhpcy5wcm9wcz1udWxsfX0se2tleTpcImFkZEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kaXNwYXRjaC5vbihcIm1vdW50ZWRcIix0aGlzLm9uTW91bnRlZEhhbmRsZXIuYmluZCh0aGlzKSksdGhpcy5kaXNwYXRjaC5vbihcInVwZGF0ZWRcIix0aGlzLm9uVXBkYXRlZEhhbmRsZXIuYmluZCh0aGlzKSksdGhpcy5kaXNwYXRjaC5vbihcIm1vdXNlT3ZlclwiLHRoaXMub25Nb3VzZU92ZXJIYW5kbGVyLmJpbmQodGhpcykpLHRoaXMuZGlzcGF0Y2gub24oXCJtb3VzZU91dFwiLHRoaXMub25Nb3VzZU91dEhhbmRsZXIuYmluZCh0aGlzKSksdGhpcy5kaXNwYXRjaC5vbihcImNsaWNrXCIsdGhpcy5vbkNsaWNrSGFuZGxlci5iaW5kKHRoaXMpKSx0aGlzLmRpc3BhdGNoLm9uKFwibW91c2VNb3ZlXCIsdGhpcy5vbk1vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKSl9fSx7a2V5OlwicmVtb3ZlRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoLm9uKFwibW91bnRlZFwiLG51bGwpLHRoaXMuZGlzcGF0Y2gub24oXCJ1cGRhdGVkXCIsbnVsbCksdGhpcy5kaXNwYXRjaC5vbihcIm1vdXNlT3ZlclwiLG51bGwpLHRoaXMuZGlzcGF0Y2gub24oXCJtb3VzZU91dFwiLG51bGwpLHRoaXMuZGlzcGF0Y2gub24oXCJtb3VzZU1vdmVcIixudWxsKSx0aGlzLmRpc3BhdGNoLm9uKFwiY2xpY2tcIixudWxsKX19LHtrZXk6XCJvbk1vdW50ZWRIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnByb3BzLm9uTW91bnRIYW5kbGVyJiZ0aGlzLnByb3BzLm9uTW91bnRIYW5kbGVyKCl9fSx7a2V5Olwib25VcGRhdGVkSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5wcm9wcy5vblVwZGF0ZWRIYW5kbGVyJiZ0aGlzLnByb3BzLm9uVXBkYXRlZEhhbmRsZXIoKX19LHtrZXk6XCJvbk1vdXNlT3ZlckhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnRvb2x0aXAmJnRoaXMudG9vbHRpcC5zaG93KGFbXCJkZWZhdWx0XCJdLmV2ZW50LHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMucHJvcHMub25Nb3VzZU92ZXJIYW5kbGVyJiZ0aGlzLnByb3BzLm9uTW91c2VPdmVySGFuZGxlcih0KX19LHtrZXk6XCJvbk1vdXNlT3V0SGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMudG9vbHRpcCYmdGhpcy50b29sdGlwLmhpZGUoKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnByb3BzLm9uTW91c2VPdXRIYW5kbGVyJiZ0aGlzLnByb3BzLm9uTW91c2VPdXRIYW5kbGVyKHQpfX0se2tleTpcIm9uTW91c2VNb3ZlSGFuZGxlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50b29sdGlwJiZ0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24oYVtcImRlZmF1bHRcIl0uZXZlbnQpfX0se2tleTpcIm9uQ2xpY2tIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5wcm9wcy5vbkNsaWNrSGFuZGxlciYmdGhpcy5wcm9wcy5vbkNsaWNrSGFuZGxlcih0KX19LHtrZXk6XCJzZXRBeGlzXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJBeGlzXCI9PT10LnRvU3RyaW5nKCkmJnRoaXMuYXhlcy5wdXNoKHQpfX0se2tleTpcInVwZGF0ZUF4aXNcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dGhpcy5heGVzW3RdLnVwZGF0ZShlLG4pfX0se2tleTpcIl9yZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMuZGF0YSYmKHRoaXMucHJlUmVuZGVyKCksdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQucmVuZGVyKCl9KSx0aGlzLnJlbmRlcigpLHRoaXMucG9zdFJlbmRlcigpKX19LHtrZXk6XCJwcmVSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcInJlbmRlciBmdW5jdGlvbiBzaG91bGQgYmUgaW1wbGVtZW50ZWRcIil9fSx7a2V5OlwicG9zdFJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInVwZGF0ZURpbWVuc2lvbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS53aWR0aCxyPWUuaGVpZ2h0LG89ZS5tYXJnaW47KHRoaXMud2lkdGghPT1ufHx0aGlzLmhlaWdodCE9PXIpJiYodGhpcy53aWR0aD1uLW8ubGVmdC1vLnJpZ2h0LHRoaXMuaGVpZ2h0PXItby50b3Atby5ib3R0b20sdGhpcy5zdmcuYXR0cihcIndpZHRoXCIsbikuYXR0cihcImhlaWdodFwiLHIpLHRoaXMuYmFzZS5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrby5sZWZ0K1wiLFwiK28udG9wK1wiKVwiKSx0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLndpZHRoPXQud2lkdGgsZS5oZWlnaHQ9dC5oZWlnaHR9KSl9fSx7a2V5Olwic2VsZWN0b3JcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2VsZWN0b3J9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9zZWxlY3Rvcj10fX0se2tleTpcInByb3BzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb3BzfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fcHJvcHM9dH19LHtrZXk6XCJ0b29sdGlwUmVmXCIsc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3Rvb2x0aXBSZWY9dH0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXBSZWZ9fV0pLHR9KCk7ZVtcImRlZmF1bHRcIl09Yyx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oNiksbD1hKHUpLGM9bigzMik7bigxNjMpO3ZhciBwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpfXJldHVybiBvKGUsdCksaShlLFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighdGhpcy5jaGFydENvbnN0cnVjdG9yKXRocm93IG5ldyBFcnJvcihcIk5lZWQgdG8gc2V0IGNoYXJ0Q29uc3RydWN0b3JcIik7dGhpcy5jaGFydD1uZXcgdGhpcy5jaGFydENvbnN0cnVjdG9yKHRoaXMucHJvcHMpLHRoaXMuY2hhcnQud2lsbE1vdW50KCl9fSx7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2hhcnQuc2VsZWN0b3I9dGhpcy5yZWZzLmNoYXJ0LHRoaXMuY2hhcnQudG9vbHRpcFJlZj10aGlzLnJlZnMudG9vbHRpcCx0aGlzLmNoYXJ0LnByb3BzPXRoaXMucHJvcHMsdGhpcy5jaGFydC5vbk1vdW50KCl9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNoYXJ0LnByb3BzPXRoaXMucHJvcHMsdGhpcy5jaGFydC5vblVwZGF0ZSgpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNoYXJ0Lm9uVW5Nb3VudCgpLHRoaXMuY2hhcnQ9bnVsbH19LHtrZXk6XCJnZXRDbGFzc05hbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNsYXNzTmFtZT9cIiBcIit0aGlzLnByb3BzLmNsYXNzTmFtZTpcIlwifX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicGFub3JhbWFcIit0aGlzLmdldENsYXNzTmFtZSgpfSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3JlZjpcImNoYXJ0XCIsY2xhc3NOYW1lOlwicGFub3JhbWEtLWNoYXJ0LWNvbnRhaW5lclwifSx0aGlzLnByb3BzLnRvb2x0aXAmJmxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOlwidG9vbHRpcFwiLGNsYXNzTmFtZTpcInBhbm9yYW1hLS10b29sdGlwXCJ9KSkpfX1dLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6Yy5EZWZhdWx0VHlwZXMsZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOmMuRGVmYXVsdFByb3BzLGVudW1lcmFibGU6ITB9XSksZX0odS5Db21wb25lbnQpO2VbXCJkZWZhdWx0XCJdPXAsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyNSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKCFyKHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhbiBvYmplY3QhXCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9e319LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigzKVtcImRlZmF1bHRcIl0sbz1uKDIpW1wiZGVmYXVsdFwiXSxpPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPW4oNyksYT1pKHMpLHU9bigzMiksbD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxuKXtvKHRoaXMsdCksdGhpcy5fb3B0aW9ucz1lLHRoaXMuYXhpcz1hW1wiZGVmYXVsdFwiXS5zdmcuYXhpcygpLnNjYWxlKG4pLHRoaXMuZWxlbWVudD1udWxsfXJldHVybiByKHQsW3trZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMub3B0aW9ucz1lLHRoaXMuYXhpcy5zY2FsZSh0KSx0aGlzLnNldEF4aXNNZXRob2RzKCl9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZWxlbWVudD10LmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsdGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIiksdGhpcy5zZXRBeGlzTWV0aG9kcygpLHRoaXMuYXhpc0xhYmVsKCl9fSx7a2V5Olwib25VcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJvblVuTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZWxlbWVudCYmdGhpcy5lbGVtZW50LnJlbW92ZSgpLHRoaXMuX29wdGlvbnM9bnVsbCx0aGlzLmVsZW1lbnQ9bnVsbCx0aGlzLmF4aXM9bnVsbH19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2V0UG9zaXRpb24oKSx0aGlzLmVsZW1lbnQuY2FsbCh0aGlzLmF4aXMpLHRoaXMucmVuZGVyVGlja0V4dHJhcygpLHRoaXMucmVuZGVyTGFiZWxFeHRyYXMoKX19LHtrZXk6XCJyZW5kZXJUaWNrRXh0cmFzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVsZW1lbnQuc2VsZWN0QWxsKFwidGV4dFwiKTt0aGlzLm9wdGlvbnMuYXR0ciYmdC5hdHRyKHRoaXMub3B0aW9ucy5hdHRyKSx0aGlzLm9wdGlvbnMuc3R5bGUmJnQuc3R5bGUodGhpcy5vcHRpb25zLnN0eWxlKX19LHtrZXk6XCJyZW5kZXJMYWJlbEV4dHJhc1wiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5sYWJlbCYmdGhpcy5vcHRpb25zLmxhYmVsKXt2YXIgdD10aGlzLm9wdGlvbnMubGFiZWw7dC5hdHRyJiZ0aGlzLmxhYmVsLmF0dHIodC5hdHRyKSx0LnN0eWxlJiZ0aGlzLmxhYmVsLnN0eWxlKHQuc3R5bGUpfX19LHtrZXk6XCJzZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5vcHRpb25zLnBvc2l0aW9uO2lmKHQpc3dpdGNoKHQpe2Nhc2VcImJvdHRvbVwiOnRoaXMuZWxlbWVudC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoMCxcIit0aGlzLmhlaWdodCtcIilcIik7YnJlYWs7Y2FzZVwicmlnaHRcIjp0aGlzLmVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlKFwiK3RoaXMud2lkdGgrXCIsMClcIil9fX0se2tleTpcInNldEF4aXNNZXRob2RzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3UuYXhpc01ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihlKXt0Lm9wdGlvbnMuaGFzT3duUHJvcGVydHkoZSkmJnQuYXhpc1tlXSh0Lm9wdGlvbnNbZV0pfSl9fSx7a2V5OlwiYXhpc0xhYmVsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMubGFiZWwmJih0aGlzLmxhYmVsPXRoaXMuZWxlbWVudC5hcHBlbmQoXCJ0ZXh0XCIpLnRleHQodGhpcy5vcHRpb25zLmxhYmVsLnRleHQpKX19LHtrZXk6XCJ0b1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzXCJ9fSx7a2V5Olwib3B0aW9uc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcHRpb25zfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fb3B0aW9ucz10fX0se2tleTpcIndpZHRoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dpZHRofSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fd2lkdGg9dH19LHtrZXk6XCJoZWlnaHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGVpZ2h0fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5faGVpZ2h0PXR9fV0pLHR9KCk7ZVtcImRlZmF1bHRcIl09bCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDM0KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2lmKHIodCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gdC5jYWxsKGUsbil9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24obixyKXtyZXR1cm4gdC5jYWxsKGUsbixyKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQuY2FsbChlLG4scixvKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEyKSxvPW4oOCksaT1uKDE5KSxzPVwicHJvdG90eXBlXCIsYT1mdW5jdGlvbih0LGUsbil7dmFyIHUsbCxjLHA9dCZhLkYsZj10JmEuRyxoPXQmYS5TLGQ9dCZhLlAseT10JmEuQix2PXQmYS5XLG09Zj9vOm9bZV18fChvW2VdPXt9KSxnPWY/cjpoP3JbZV06KHJbZV18fHt9KVtzXTtmJiYobj1lKTtmb3IodSBpbiBuKWw9IXAmJmcmJnUgaW4gZyxsJiZ1IGluIG18fChjPWw/Z1t1XTpuW3VdLG1bdV09ZiYmXCJmdW5jdGlvblwiIT10eXBlb2YgZ1t1XT9uW3VdOnkmJmw/aShjLHIpOnYmJmdbdV09PWM/ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiB0P25ldyB0KGUpOnQoZSl9O3JldHVybiBlW3NdPXRbc10sZX0oYyk6ZCYmXCJmdW5jdGlvblwiPT10eXBlb2YgYz9pKEZ1bmN0aW9uLmNhbGwsYyk6YyxkJiYoKG1bc118fChtW3NdPXt9KSlbdV09YykpfTthLkY9MSxhLkc9MixhLlM9NCxhLlA9OCxhLkI9MTYsYS5XPTMyLHQuZXhwb3J0cz1hfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDExMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSl7dmFyIG49e30udG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBuLmNhbGwodCkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdD9udWxsIT09dDpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0fX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIG51bGwhPXQmJmkobyh0KSl9dmFyIG89bigxNzQpLGk9bigyNyk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmdD4tMSYmdCUxPT0wJiZyPj10fXZhciByPTkwMDcxOTkyNTQ3NDA5OTE7dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4hIXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big2Myksbz1uKDI3KSxpPW4oMjgpLHM9XCJbb2JqZWN0IEFycmF5XVwiLGE9T2JqZWN0LnByb3RvdHlwZSx1PWEudG9TdHJpbmcsbD1yKEFycmF5LFwiaXNBcnJheVwiKSxjPWx8fGZ1bmN0aW9uKHQpe3JldHVybiBpKHQpJiZvKHQubGVuZ3RoKSYmdS5jYWxsKHQpPT1zfTt0LmV4cG9ydHM9Y30sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMjMpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDcwKSxpPXtMZWdlbmQ6e3NlbGVjdGVkOlwiTGVnZW5kOnNlbGVjdGVkXCJ9LEl0ZW1TZWxlY3Rvcjp7c2VsZWN0ZWQ6XCJJdGVtU2VsZWN0b3I6c2VsZWN0ZWRcIn0sQ2hhcnRTbGlkZXI6e3NlbGVjdGVkOlwiQ2hhcnRTbGlkZXI6c2VsZWN0ZWRcIn19O2UuUGFub3JhbWFFdmVudFR5cGVzPWk7dmFyIHM9e0xlZ2VuZDp7c2VsZWN0ZWQ6ZnVuY3Rpb24odCxlKXtzLmVtaXQoaS5MZWdlbmQuc2VsZWN0ZWQsdCxlKX19LEl0ZW1TZWxlY3Rvcjp7c2VsZWN0ZWQ6ZnVuY3Rpb24odCxlKXtzLmVtaXQoaS5JdGVtU2VsZWN0b3Iuc2VsZWN0ZWQsdCxlKX19LENoYXJ0U2xpZGVyOntzZWxlY3RlZDpmdW5jdGlvbih0KXtzLmVtaXQoaS5DaGFydFNsaWRlci5zZWxlY3RlZCx0KX19fTtlLlBhbm9yYW1hRGlzcGF0Y2hlcj1zLHIocyxvLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89big2KSxpPW4oNykscz1yKGkpLGE9e3dpZHRoOm8uUHJvcFR5cGVzLm51bWJlcixoZWlnaHQ6by5Qcm9wVHlwZXMubnVtYmVyLG1hcmdpbjpvLlByb3BUeXBlcy5zaGFwZSh7dG9wOm8uUHJvcFR5cGVzLm51bWJlcixyaWdodDpvLlByb3BUeXBlcy5udW1iZXIsYm90dG9tOm8uUHJvcFR5cGVzLm51bWJlcixsZWZ0Om8uUHJvcFR5cGVzLm51bWJlcn0pLHhBY2Nlc3NvcjpvLlByb3BUeXBlcy5mdW5jLHlBY2Nlc3NvcjpvLlByb3BUeXBlcy5mdW5jLHNlbGVjdGlvbkFjY2Vzc29yOm8uUHJvcFR5cGVzLmZ1bmMseFNjYWxlOm8uUHJvcFR5cGVzLmZ1bmMseVNjYWxlOm8uUHJvcFR5cGVzLmZ1bmMseGF4aXM6by5Qcm9wVHlwZXMub2JqZWN0LHlheGlzOm8uUHJvcFR5cGVzLm9iamVjdCxpbnRlcmFjdGl2ZTpvLlByb3BUeXBlcy5ib29sLHRvb2x0aXA6by5Qcm9wVHlwZXMuYm9vbH07ZS5EZWZhdWx0VHlwZXM9YTt2YXIgdT17d2lkdGg6OTYwLGhlaWdodDo1MDAsbWFyZ2luOnt0b3A6MjAscmlnaHQ6MzAsYm90dG9tOjIwLGxlZnQ6MzB9LHNlbGVjdGlvbkFjY2Vzc29yOmZ1bmN0aW9uKHQpe3JldHVybiB0LmtleX0seEFjY2Vzc29yOmZ1bmN0aW9uKHQpe3JldHVybiB0LmtleX0seUFjY2Vzc29yOmZ1bmN0aW9uKHQpe3JldHVybiB0LnZhbHVlfSx4U2NhbGU6c1tcImRlZmF1bHRcIl0uc2NhbGUubGluZWFyKCkseVNjYWxlOnNbXCJkZWZhdWx0XCJdLnNjYWxlLmxpbmVhcigpLGludGVyYWN0aXZlOiEwLHRvb2x0aXA6ITF9O2UuRGVmYXVsdFByb3BzPXU7dmFyIGw9W1wib3JpZW50XCIsXCJ0aWNrc1wiLFwidGlja1ZhbHVlc1wiLFwidGlja1NpemVcIixcImlubmVyVGlja1NpemVcIixcIm91dGVyVGlja1NpemVcIixcInRpY2tQYWRkaW5nXCIsXCJ0aWNrRm9ybWF0XCJdO2UuYXhpc01ldGhvZHM9bDt2YXIgYz17Y2xvc2VEZWxheToxMDAsYWxpZ246XCJ0b3AgY2VudGVyXCIsb2Zmc2V0OlswLC0xMF19O2UudG9vbHRpcERlZmF1bHRPcHRpb25zPWN9LGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24odCxlKXt2YXIgbj17fTtmb3IodmFyIHIgaW4gdCllLmluZGV4T2Yocik+PTB8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYobltyXT10W3JdKTtyZXR1cm4gbn0sZS5fX2VzTW9kdWxlPSEwfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIGZ1bmN0aW9uIVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDI0KSxvPW4oMTApKFwidG9TdHJpbmdUYWdcIiksaT1cIkFyZ3VtZW50c1wiPT1yKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlLG4scztyZXR1cm4gdm9pZCAwPT09dD9cIlVuZGVmaW5lZFwiOm51bGw9PT10P1wiTnVsbFwiOlwic3RyaW5nXCI9PXR5cGVvZihuPShlPU9iamVjdCh0KSlbb10pP246aT9yKGUpOlwiT2JqZWN0XCI9PShzPXIoZSkpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNhbGxlZT9cIkFyZ3VtZW50c1wiOnN9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih2b2lkIDA9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz0hbigzOCkoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaChlKXtyZXR1cm4hMH19fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big5KSxvPW4oNTQpO3QuZXhwb3J0cz1uKDM3KT9mdW5jdGlvbih0LGUsbil7cmV0dXJuIHIuc2V0RGVzYyh0LGUsbygxLG4pKX06ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0W2VdPW4sdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDkpLnNldERlc2Msbz1uKDQ5KSxpPW4oMTApKFwidG9TdHJpbmdUYWdcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt0JiYhbyh0PW4/dDp0LnByb3RvdHlwZSxpKSYmcih0LGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMzUpKCEwKTtuKDUxKShTdHJpbmcsXCJTdHJpbmdcIixmdW5jdGlvbih0KXt0aGlzLl90PVN0cmluZyh0KSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLl90LG49dGhpcy5faTtyZXR1cm4gbj49ZS5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD1yKGUsbiksdGhpcy5faSs9dC5sZW5ndGgse3ZhbHVlOnQsZG9uZTohMX0pfSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDE0MSk7dmFyIHI9bigxNik7ci5Ob2RlTGlzdD1yLkhUTUxDb2xsZWN0aW9uPXIuQXJyYXl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe3JldHVybiB0PVwibnVtYmVyXCI9PXR5cGVvZiB0fHxyLnRlc3QodCk/K3Q6LTEsZT1udWxsPT1lP286ZSx0Pi0xJiZ0JTE9PTAmJmU+dH12YXIgcj0vXlxcZCskLyxvPTkwMDcxOTkyNTQ3NDA5OTE7dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBpKHQpJiZvKHQpJiZhLmNhbGwodCxcImNhbGxlZVwiKSYmIXUuY2FsbCh0LFwiY2FsbGVlXCIpfXZhciBvPW4oMjYpLGk9bigyOCkscz1PYmplY3QucHJvdG90eXBlLGE9cy5oYXNPd25Qcm9wZXJ0eSx1PXMucHJvcGVydHlJc0VudW1lcmFibGU7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMTEpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oNyksYz11KGwpLHA9big2KSxmPW4oMTQpLGg9dShmKSxkPW4oNzEpLHk9dShkKTtuKDE0OCk7dmFyIHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5jaGFydENvbnN0cnVjdG9yPXlbXCJkZWZhdWx0XCJdfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTphKHt9LGhbXCJkZWZhdWx0XCJdLnByb3BUeXBlcyx7ZmlsbENvbG9yOnAuUHJvcFR5cGVzLm9uZU9mVHlwZShbcC5Qcm9wVHlwZXMuc3RyaW5nLHAuUHJvcFR5cGVzLm51bWJlcl0pLGZpbGxPcGFjaXR5OnAuUHJvcFR5cGVzLm51bWJlcixpbnRlcnBvbGF0ZTpwLlByb3BUeXBlcy5zdHJpbmd9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxoW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse3hTY2FsZTpjW1wiZGVmYXVsdFwiXS5zY2FsZS5vcmRpbmFsKCksY2xhc3NOYW1lOlwiYXJlYS1jaGFydFwiLGludGVycG9sYXRlOlwiYmFzaXNcIix4YXhpczp7Y2xhc3NOYW1lOlwieCBheGlzXCIsb3JpZW50OlwiYm90dG9tXCIscG9zaXRpb246XCJib3R0b21cIixhdHRyOntkeDpcIjBcIixkeTpcIjAuNWVtXCJ9LHN0eWxlOntcInRleHQtYW5jaG9yXCI6XCJtaWRkbGVcIn19LHlheGlzOntjbGFzc05hbWU6XCJ5IGF4aXNcIixvcmllbnQ6XCJsZWZ0XCJ9fSksZW51bWVyYWJsZTohMH1dKSxlfShoW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09dix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMTEpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oNiksYz1uKDcpLHA9dShjKSxmPW4oMTQpLGg9dShmKSxkPW4oNDcpLHk9dShkKTtuKDE1MCk7dmFyIHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5jaGFydENvbnN0cnVjdG9yPXlbXCJkZWZhdWx0XCJdfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTphKHt9LGhbXCJkZWZhdWx0XCJdLnByb3BUeXBlcyx7YmFyU3BhY2luZzpsLlByb3BUeXBlcy5udW1iZXJ9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxoW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse2JhclNwYWNpbmc6LjEseFNjYWxlOnBbXCJkZWZhdWx0XCJdLnNjYWxlLm9yZGluYWwoKSxjbGFzc05hbWU6XCJiYXItY2hhcnQgdmVydGljYWxcIix4YXhpczp7Y2xhc3NOYW1lOlwieCBheGlzXCIsb3JpZW50OlwiYm90dG9tXCIscG9zaXRpb246XCJib3R0b21cIixhdHRyOntkeDpcIjBcIixkeTpcIjAuNWVtXCJ9LHN0eWxlOntcInRleHQtYW5jaG9yXCI6XCJtaWRkbGVcIn19LHlheGlzOntjbGFzc05hbWU6XCJ5IGF4aXNcIixvcmllbnQ6XCJsZWZ0XCJ9fSksZW51bWVyYWJsZTohMH1dKSxlfShoW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09dix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oMTMpLGw9YSh1KSxjPW4oNykscD1hKGMpLGY9bigxOCksaD1hKGYpLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcIndpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy54YXhpcyYmdGhpcy5zZXRBeGlzKG5ldyBoW1wiZGVmYXVsdFwiXSh0aGlzLnByb3BzLnhheGlzLHRoaXMucHJvcHMueFNjYWxlKSksdGhpcy5wcm9wcy55YXhpcyYmdGhpcy5zZXRBeGlzKG5ldyBoW1wiZGVmYXVsdFwiXSh0aGlzLnByb3BzLnlheGlzLHRoaXMucHJvcHMueVNjYWxlKSl9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcIm9uTW91bnRcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5fcmVuZGVyKCl9fSx7a2V5OlwicHJlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC54QWNjZXNzb3Iscj10LnlBY2Nlc3NvcixvPXQueFNjYWxlLGk9dC55U2NhbGU7by5yYW5nZVJvdW5kQmFuZHMoWzAsdGhpcy53aWR0aF0sdGhpcy5iYXJTcGFjaW5nKSxvLmRvbWFpbihlLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0KX0pKSxpLnJhbmdlKFt0aGlzLmhlaWdodCwwXSksaS5kb21haW4oWzAscFtcImRlZmF1bHRcIl0ubWF4KGUsZnVuY3Rpb24odCl7cmV0dXJuIHIodCl9KV0pLHRoaXMudXBkYXRlQXhpcygwLG8sdGhpcy5wcm9wcy54YXhpcyksdGhpcy51cGRhdGVBeGlzKDEsaSx0aGlzLnByb3BzLnlheGlzKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5kYXRhLHI9ZS54QWNjZXNzb3Isbz1lLnlBY2Nlc3NvcixpPWUueFNjYWxlLHM9ZS55U2NhbGUsYT10aGlzLmJhc2Uuc2VsZWN0QWxsKFwiLmJhclwiKS5kYXRhKG4pO2EuZXhpdCgpLnJlbW92ZSgpLGEuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLFwiYmFyXCIpLGEuYXR0cihcInhcIixmdW5jdGlvbih0KXtyZXR1cm4gaShyKHQpKX0pLmF0dHIoXCJ5XCIsZnVuY3Rpb24odCl7cmV0dXJuIHMobyh0KSl9KS5hdHRyKFwid2lkdGhcIixpLnJhbmdlQmFuZCgpKS5hdHRyKFwiaGVpZ2h0XCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQuaGVpZ2h0LXMobyhlKSl9KX19LHtrZXk6XCJwb3N0UmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5zZWxlY3RlZCxuPXQuc2VsZWN0aW9uQWNjZXNzb3Iscj10LmludGVyYWN0aXZlLG89dGhpcy5iYXNlLnNlbGVjdEFsbChcIi5iYXJcIik7ciYmby5vbihcImNsaWNrXCIsdGhpcy5kaXNwYXRjaC5jbGljaykub24oXCJtb3VzZW92ZXJcIix0aGlzLmRpc3BhdGNoLm1vdXNlT3Zlcikub24oXCJtb3VzZW91dFwiLHRoaXMuZGlzcGF0Y2gubW91c2VPdXQpLGUmJm8uY2xhc3NlZChcInNlbGVjdGVkXCIsZnVuY3Rpb24odCl7cmV0dXJuIG4odCk9PT1lfSl9fSx7a2V5OlwiYmFyU3BhY2luZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmJhclNwYWNpbmd8fC4xfX1dKSxlfShsW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09ZCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlW1wiZGVmYXVsdFwiXT10LGV9LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlKXt2YXIgbj17fS5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5jYWxsKHQsZSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyNCk7dC5leHBvcnRzPU9iamVjdChcInpcIikucHJvcGVydHlJc0VudW1lcmFibGUoMCk/T2JqZWN0OmZ1bmN0aW9uKHQpe3JldHVyblwiU3RyaW5nXCI9PXIodCk/dC5zcGxpdChcIlwiKTpPYmplY3QodCl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big1Miksbz1uKDIwKSxpPW4oNTUpLHM9bigzOSksYT1uKDQ5KSx1PW4oMTYpLGw9bigxMjQpLGM9big0MCkscD1uKDkpLmdldFByb3RvLGY9bigxMCkoXCJpdGVyYXRvclwiKSxoPSEoW10ua2V5cyYmXCJuZXh0XCJpbltdLmtleXMoKSksZD1cIkBAaXRlcmF0b3JcIix5PVwia2V5c1wiLHY9XCJ2YWx1ZXNcIixtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixnLHgsYixrKXtsKG4sZSxnKTt2YXIgXyxQLFQ9ZnVuY3Rpb24odCl7aWYoIWgmJnQgaW4gRSlyZXR1cm4gRVt0XTtzd2l0Y2godCl7Y2FzZSB5OnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbih0aGlzLHQpfTtjYXNlIHY6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuKHRoaXMsdCl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbih0aGlzLHQpfX0sTz1lK1wiIEl0ZXJhdG9yXCIsdz14PT12LE09ITEsRT10LnByb3RvdHlwZSxDPUVbZl18fEVbZF18fHgmJkVbeF0sUz1DfHxUKHgpO2lmKEMpe3ZhciBqPXAoUy5jYWxsKG5ldyB0KSk7YyhqLE8sITApLCFyJiZhKEUsZCkmJnMoaixmLG0pLHcmJkMubmFtZSE9PXYmJihNPSEwLFM9ZnVuY3Rpb24oKXtyZXR1cm4gQy5jYWxsKHRoaXMpfSl9aWYociYmIWt8fCFoJiYhTSYmRVtmXXx8cyhFLGYsUyksdVtlXT1TLHVbT109bSx4KWlmKF89e3ZhbHVlczp3P1M6VCh2KSxrZXlzOmI/UzpUKHkpLGVudHJpZXM6dz9UKFwiZW50cmllc1wiKTpTfSxrKWZvcihQIGluIF8pUCBpbiBFfHxpKEUsUCxfW1BdKTtlbHNlIG8oby5QK28uRiooaHx8TSksZSxfKTtyZXR1cm4gX319LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPSEwfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyMCksbz1uKDgpLGk9bigzOCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49KG8uT2JqZWN0fHx7fSlbdF18fE9iamVjdFt0XSxzPXt9O3NbdF09ZShuKSxyKHIuUytyLkYqaShmdW5jdGlvbigpe24oMSl9KSxcIk9iamVjdFwiLHMpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPW4oMzkpfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big5KS5nZXREZXNjLG89bigyNSksaT1uKDE1KSxzPWZ1bmN0aW9uKHQsZSl7aWYoaSh0KSwhbyhlKSYmbnVsbCE9PWUpdGhyb3cgVHlwZUVycm9yKGUrXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpfTt0LmV4cG9ydHM9e3NldDpPYmplY3Quc2V0UHJvdG90eXBlT2Z8fChcIl9fcHJvdG9fX1wiaW57fT9mdW5jdGlvbih0LGUsbyl7dHJ5e289bigxOSkoRnVuY3Rpb24uY2FsbCxyKE9iamVjdC5wcm90b3R5cGUsXCJfX3Byb3RvX19cIikuc2V0LDIpLG8odCxbXSksZT0hKHQgaW5zdGFuY2VvZiBBcnJheSl9Y2F0Y2goaSl7ZT0hMH1yZXR1cm4gZnVuY3Rpb24odCxuKXtyZXR1cm4gcyh0LG4pLGU/dC5fX3Byb3RvX189bjpvKHQsbiksdH19KHt9LCExKTp2b2lkIDApLGNoZWNrOnN9fSxmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGguY2VpbCxyPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpc05hTih0PSt0KT8wOih0PjA/cjpuKSh0KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDUwKSxvPW4oMzYpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gcihvKHQpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDM2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdChyKHQpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDM1KSxvPW4oMTApKFwiaXRlcmF0b3JcIiksaT1uKDE2KTt0LmV4cG9ydHM9big4KS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT10P3Rbb118fHRbXCJAQGl0ZXJhdG9yXCJdfHxpW3IodCldOnZvaWQgMH19LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihyKTtyZXR1cm4gZT1vKHZvaWQgMD09PWU/dC5sZW5ndGgtMTorZXx8MCwwKSxmdW5jdGlvbigpe2Zvcih2YXIgbj1hcmd1bWVudHMscj0tMSxpPW8obi5sZW5ndGgtZSwwKSxzPUFycmF5KGkpOysrcjxpOylzW3JdPW5bZStyXTtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiB0LmNhbGwodGhpcyxzKTtjYXNlIDE6cmV0dXJuIHQuY2FsbCh0aGlzLG5bMF0scyk7Y2FzZSAyOnJldHVybiB0LmNhbGwodGhpcyxuWzBdLG5bMV0scyl9dmFyIGE9QXJyYXkoZSsxKTtmb3Iocj0tMTsrK3I8ZTspYVtyXT1uW3JdO3JldHVybiBhW2VdPXMsdC5hcHBseSh0aGlzLGEpfX12YXIgcj1cIkV4cGVjdGVkIGEgZnVuY3Rpb25cIixvPU1hdGgubWF4O3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm4gbztpZih2b2lkIDA9PT1lKXJldHVybiB0O3N3aXRjaChuKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB0LmNhbGwoZSxuKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQuY2FsbChlLG4scixvKX07Y2FzZSA0OnJldHVybiBmdW5jdGlvbihuLHIsbyxpKXtyZXR1cm4gdC5jYWxsKGUsbixyLG8saSl9O2Nhc2UgNTpyZXR1cm4gZnVuY3Rpb24obixyLG8saSxzKXtyZXR1cm4gdC5jYWxsKGUsbixyLG8saSxzKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX12YXIgbz1uKDE4Mik7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dmFyIG49bnVsbD09dD92b2lkIDA6dFtlXTtyZXR1cm4gbyhuKT9uOnZvaWQgMH12YXIgbz1uKDE4MCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBvKHQpP3Q6T2JqZWN0KHQpfXZhciBvPW4oMTcpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNjUpLG89bigxNjYpLGk9bigxNzIpLHM9aShmdW5jdGlvbih0LGUsbil7cmV0dXJuIG4/cih0LGUsbik6byh0LGUpfSk7dC5leHBvcnRzPXN9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDYzKSxvPW4oMjYpLGk9bigxNykscz1uKDE3OCksYT1yKE9iamVjdCxcImtleXNcIiksdT1hP2Z1bmN0aW9uKHQpe3ZhciBlPW51bGw9PXQ/dm9pZCAwOnQuY29uc3RydWN0b3I7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZS5wcm90b3R5cGU9PT10fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZvKHQpP3ModCk6aSh0KT9hKHQpOltdfTpzO3QuZXhwb3J0cz11fSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtpZihudWxsPT10KXJldHVybltdO3UodCl8fCh0PU9iamVjdCh0KSk7dmFyIGU9dC5sZW5ndGg7ZT1lJiZhKGUpJiYoaSh0KXx8byh0KSkmJmV8fDA7Zm9yKHZhciBuPXQuY29uc3RydWN0b3Iscj0tMSxsPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJm4ucHJvdG90eXBlPT09dCxwPUFycmF5KGUpLGY9ZT4wOysrcjxlOylwW3JdPXIrXCJcIjtmb3IodmFyIGggaW4gdClmJiZzKGgsZSl8fFwiY29uc3RydWN0b3JcIj09aCYmKGx8fCFjLmNhbGwodCxoKSl8fHAucHVzaChoKTtyZXR1cm4gcH12YXIgbz1uKDQ0KSxpPW4oMjkpLHM9big0MyksYT1uKDI3KSx1PW4oMTcpLGw9T2JqZWN0LnByb3RvdHlwZSxjPWwuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe3ZhciBuPXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0Ly50ZXN0KG4pPyF0LmRpc2FibGVkOlwiYVwiPT09bj90LmhyZWZ8fGU6ZSkmJm8odCl9ZnVuY3Rpb24gcih0KXtyZXR1cm4gdC5vZmZzZXRXaWR0aDw9MCYmdC5vZmZzZXRIZWlnaHQ8PTB8fFwibm9uZVwiPT09dC5zdHlsZS5kaXNwbGF5fWZ1bmN0aW9uIG8odCl7Zm9yKDt0JiZ0IT09ZG9jdW1lbnQuYm9keTspe2lmKHIodCkpcmV0dXJuITE7dD10LnBhcmVudE5vZGV9cmV0dXJuITB9ZnVuY3Rpb24gaSh0KXt2YXIgZT10LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpO251bGw9PT1lJiYoZT12b2lkIDApO3ZhciByPWlzTmFOKGUpO3JldHVybihyfHxlPj0wKSYmbih0LCFyKX1mdW5jdGlvbiBzKHQpe3JldHVybltdLnNsaWNlLmNhbGwodC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSwwKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIGkodCl9KX10LmV4cG9ydHM9c30sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP3ZvaWQgMDplW3RdfX1mdW5jdGlvbiBvKHQpe3JldHVybiBudWxsIT10JiZzKGcodCkpfWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gdD1cIm51bWJlclwiPT10eXBlb2YgdHx8aC50ZXN0KHQpPyt0Oi0xLGU9bnVsbD09ZT9tOmUsdD4tMSYmdCUxPT0wJiZlPnR9ZnVuY3Rpb24gcyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmdD4tMSYmdCUxPT0wJiZtPj10fWZ1bmN0aW9uIGEodCl7Zm9yKHZhciBlPWwodCksbj1lLmxlbmd0aCxyPW4mJnQubGVuZ3RoLG89ISFyJiZzKHIpJiYoZih0KXx8cCh0KSksYT0tMSx1PVtdOysrYTxuOyl7dmFyIGM9ZVthXTsobyYmaShjLHIpfHx5LmNhbGwodCxjKSkmJnUucHVzaChjKX1yZXR1cm4gdX1mdW5jdGlvbiB1KHQpe3ZhciBlPXR5cGVvZiB0O3JldHVybiEhdCYmKFwib2JqZWN0XCI9PWV8fFwiZnVuY3Rpb25cIj09ZSl9ZnVuY3Rpb24gbCh0KXtpZihudWxsPT10KXJldHVybltdO3UodCl8fCh0PU9iamVjdCh0KSk7dmFyIGU9dC5sZW5ndGg7ZT1lJiZzKGUpJiYoZih0KXx8cCh0KSkmJmV8fDA7Zm9yKHZhciBuPXQuY29uc3RydWN0b3Iscj0tMSxvPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJm4ucHJvdG90eXBlPT09dCxhPUFycmF5KGUpLGw9ZT4wOysrcjxlOylhW3JdPXIrXCJcIjtmb3IodmFyIGMgaW4gdClsJiZpKGMsZSl8fFwiY29uc3RydWN0b3JcIj09YyYmKG98fCF5LmNhbGwodCxjKSl8fGEucHVzaChjKTtyZXR1cm4gYX12YXIgYz1uKDE5OCkscD1uKDE5OSksZj1uKDIwMCksaD0vXlxcZCskLyxkPU9iamVjdC5wcm90b3R5cGUseT1kLmhhc093blByb3BlcnR5LHY9YyhPYmplY3QsXCJrZXlzXCIpLG09OTAwNzE5OTI1NDc0MDk5MSxnPXIoXCJsZW5ndGhcIikseD12P2Z1bmN0aW9uKHQpe3ZhciBlPW51bGw9PXQ/dm9pZCAwOnQuY29uc3RydWN0b3I7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZS5wcm90b3R5cGU9PT10fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZvKHQpP2EodCk6dSh0KT92KHQpOltdfTphO3QuZXhwb3J0cz14fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzfHx7fSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9ZnVuY3Rpb24gcih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIG8odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9ZnVuY3Rpb24gaSh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXR9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdm9pZCAwPT09dH10LmV4cG9ydHM9bixuLkV2ZW50RW1pdHRlcj1uLG4ucHJvdG90eXBlLl9ldmVudHM9dm9pZCAwLG4ucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnM9dm9pZCAwLG4uZGVmYXVsdE1heExpc3RlbmVycz0xMCxuLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnM9ZnVuY3Rpb24odCl7aWYoIW8odCl8fDA+dHx8aXNOYU4odCkpdGhyb3cgVHlwZUVycm9yKFwibiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO3JldHVybiB0aGlzLl9tYXhMaXN0ZW5lcnM9dCx0aGlzfSxuLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe3ZhciBlLG4sbyxhLHUsbDtpZih0aGlzLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9e30pLFwiZXJyb3JcIj09PXQmJighdGhpcy5fZXZlbnRzLmVycm9yfHxpKHRoaXMuX2V2ZW50cy5lcnJvcikmJiF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSl7aWYoZT1hcmd1bWVudHNbMV0sZSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGU7dGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpfWlmKG49dGhpcy5fZXZlbnRzW3RdLHMobikpcmV0dXJuITE7aWYocihuKSlzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAxOm4uY2FsbCh0aGlzKTticmVhaztjYXNlIDI6bi5jYWxsKHRoaXMsYXJndW1lbnRzWzFdKTticmVhaztjYXNlIDM6bi5jYWxsKHRoaXMsYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7YnJlYWs7ZGVmYXVsdDphPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxuLmFwcGx5KHRoaXMsYSl9ZWxzZSBpZihpKG4pKWZvcihhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxsPW4uc2xpY2UoKSxvPWwubGVuZ3RoLHU9MDtvPnU7dSsrKWxbdV0uYXBwbHkodGhpcyxhKTtyZXR1cm4hMH0sbi5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24odCxlKXt2YXIgbztpZighcihlKSl0aHJvdyBUeXBlRXJyb3IoXCJsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7cmV0dXJuIHRoaXMuX2V2ZW50c3x8KHRoaXMuX2V2ZW50cz17fSksdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyJiZ0aGlzLmVtaXQoXCJuZXdMaXN0ZW5lclwiLHQscihlLmxpc3RlbmVyKT9lLmxpc3RlbmVyOmUpLHRoaXMuX2V2ZW50c1t0XT9pKHRoaXMuX2V2ZW50c1t0XSk/dGhpcy5fZXZlbnRzW3RdLnB1c2goZSk6dGhpcy5fZXZlbnRzW3RdPVt0aGlzLl9ldmVudHNbdF0sZV06dGhpcy5fZXZlbnRzW3RdPWUsaSh0aGlzLl9ldmVudHNbdF0pJiYhdGhpcy5fZXZlbnRzW3RdLndhcm5lZCYmKG89cyh0aGlzLl9tYXhMaXN0ZW5lcnMpP24uZGVmYXVsdE1heExpc3RlbmVyczp0aGlzLl9tYXhMaXN0ZW5lcnMsbyYmbz4wJiZ0aGlzLl9ldmVudHNbdF0ubGVuZ3RoPm8mJih0aGlzLl9ldmVudHNbdF0ud2FybmVkPSEwLGNvbnNvbGUuZXJyb3IoXCIobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LlwiLHRoaXMuX2V2ZW50c1t0XS5sZW5ndGgpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUudHJhY2UmJmNvbnNvbGUudHJhY2UoKSkpLHRoaXN9LG4ucHJvdG90eXBlLm9uPW4ucHJvdG90eXBlLmFkZExpc3RlbmVyLG4ucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5yZW1vdmVMaXN0ZW5lcih0LG4pLG98fChvPSEwLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1pZighcihlKSl0aHJvdyBUeXBlRXJyb3IoXCJsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7dmFyIG89ITE7cmV0dXJuIG4ubGlzdGVuZXI9ZSx0aGlzLm9uKHQsbiksdGhpc30sbi5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24odCxlKXt2YXIgbixvLHMsYTtpZighcihlKSl0aHJvdyBUeXBlRXJyb3IoXCJsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7aWYoIXRoaXMuX2V2ZW50c3x8IXRoaXMuX2V2ZW50c1t0XSlyZXR1cm4gdGhpcztpZihuPXRoaXMuX2V2ZW50c1t0XSxzPW4ubGVuZ3RoLG89LTEsbj09PWV8fHIobi5saXN0ZW5lcikmJm4ubGlzdGVuZXI9PT1lKWRlbGV0ZSB0aGlzLl9ldmVudHNbdF0sdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyJiZ0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLHQsZSk7ZWxzZSBpZihpKG4pKXtmb3IoYT1zO2EtLSA+MDspaWYoblthXT09PWV8fG5bYV0ubGlzdGVuZXImJm5bYV0ubGlzdGVuZXI9PT1lKXtvPWE7YnJlYWt9aWYoMD5vKXJldHVybiB0aGlzOzE9PT1uLmxlbmd0aD8obi5sZW5ndGg9MCxkZWxldGUgdGhpcy5fZXZlbnRzW3RdKTpuLnNwbGljZShvLDEpLHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lciYmdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIix0LGUpfXJldHVybiB0aGlzfSxuLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24odCl7dmFyIGUsbjtpZighdGhpcy5fZXZlbnRzKXJldHVybiB0aGlzO2lmKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpcmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMuX2V2ZW50cz17fTp0aGlzLl9ldmVudHNbdF0mJmRlbGV0ZSB0aGlzLl9ldmVudHNbdF0sdGhpcztpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGUgaW4gdGhpcy5fZXZlbnRzKVwicmVtb3ZlTGlzdGVuZXJcIiE9PWUmJnRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGUpO3JldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcInJlbW92ZUxpc3RlbmVyXCIpLHRoaXMuX2V2ZW50cz17fSx0aGlzfWlmKG49dGhpcy5fZXZlbnRzW3RdLHIobikpdGhpcy5yZW1vdmVMaXN0ZW5lcih0LG4pO2Vsc2UgaWYobilmb3IoO24ubGVuZ3RoOyl0aGlzLnJlbW92ZUxpc3RlbmVyKHQsbltuLmxlbmd0aC0xXSk7cmV0dXJuIGRlbGV0ZSB0aGlzLl9ldmVudHNbdF0sdGhpc30sbi5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzW3RdP3IodGhpcy5fZXZlbnRzW3RdKT9bdGhpcy5fZXZlbnRzW3RdXTp0aGlzLl9ldmVudHNbdF0uc2xpY2UoKTpbXX0sbi5wcm90b3R5cGUubGlzdGVuZXJDb3VudD1mdW5jdGlvbih0KXtpZih0aGlzLl9ldmVudHMpe3ZhciBlPXRoaXMuX2V2ZW50c1t0XTtpZihyKGUpKXJldHVybiAxO2lmKGUpcmV0dXJuIGUubGVuZ3RofXJldHVybiAwfSxuLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5saXN0ZW5lckNvdW50KGUpfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9bigxMyksbD1hKHUpLGM9big3KSxwPWEoYyksZj1uKDE4KSxoPWEoZiksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5Olwid2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC54QWNjZXNzb3Isbj10LnlBY2Nlc3NvcixyPXQueFNjYWxlLG89dC55U2NhbGUsaT10LmludGVycG9sYXRlO3RoaXMucHJvcHMueGF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy54YXhpcyx0aGlzLnByb3BzLnhTY2FsZSkpLHRoaXMucHJvcHMueWF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy55YXhpcyx0aGlzLnByb3BzLnlTY2FsZSkpLHRoaXMucG9pbnRzPVtdLHRoaXMuYXJlYUdlbmVyYXRvcj1wW1wiZGVmYXVsdFwiXS5zdmcuYXJlYSgpLmludGVycG9sYXRlKGkpLngoZnVuY3Rpb24odCl7cmV0dXJuIHIoZSh0KSl9KS55MChmdW5jdGlvbih0KXtyZXR1cm4gbygwKX0pLnkxKGZ1bmN0aW9uKHQpe3JldHVybiBvKG4odCkpfSl9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwib25Nb3VudFwiLHRoaXMpLmNhbGwodGhpcyksdGhpcy5iYXNlTGF5ZXI9dGhpcy5iYXNlLmFwcGVuZChcImdcIikuY2xhc3NlZChcImFyZWEtbGF5ZXJcIiwhMCksdGhpcy5fcmVuZGVyKCl9fSx7a2V5OlwiZ2V0Q2xvc2VzdERhdGFJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLnBvaW50cy5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGU9dGhpcy5wcm9wcztlLmRhdGEsZS54QWNjZXNzb3I7cmV0dXJuIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5kPU1hdGguYWJzKGUueC10KX0pLHRoaXMucG9pbnRzLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gcFtcImRlZmF1bHRcIl0uYXNjZW5kaW5nKHQuZCxlLmQpfSksdGhpcy5wb2ludHNbMF0uaX19LHtrZXk6XCJvbk1vdXNlTW92ZUhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuaG92ZXImJnRoaXMudG9vbHRpcCl7dmFyIHQ9cFtcImRlZmF1bHRcIl0ubW91c2UodGhpcy5iYXNlTGF5ZXIubm9kZSgpKSxlPSh0aGlzLnByb3BzLnhTY2FsZS5pbnZlcnQodFswXSksdGhpcy5nZXRDbG9zZXN0RGF0YUluZGV4KHRbMF0pKTt0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24ocFtcImRlZmF1bHRcIl0uZXZlbnQpLG51bGwhPT1lJiZ0aGlzLnRvb2x0aXAuc2V0Q29udGVudCh0aGlzLnByb3BzLmRhdGFbMF1bZV0pfX19LHtrZXk6XCJwcmVSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5kYXRhLHI9ZS54U2NhbGUsbz1lLnlTY2FsZSxpPWUuaW50ZXJwb2xhdGUscz1lLnhBY2Nlc3NvcixhPWUueUFjY2Vzc29yO3IucmFuZ2UoWzAsdGhpcy53aWR0aF0pLG8ucmFuZ2UoW3RoaXMuaGVpZ2h0LDBdKSxcbnRoaXMudXBkYXRlQXhpcygwLHIsdGhpcy5wcm9wcy54YXhpcyksdGhpcy51cGRhdGVBeGlzKDEsbyx0aGlzLnByb3BzLnlheGlzKSx0aGlzLmFyZWFHZW5lcmF0b3IuaW50ZXJwb2xhdGUoaSkueChmdW5jdGlvbih0KXtyZXR1cm4gcihzKHQpKX0pLnkwKGZ1bmN0aW9uKHQpe3JldHVybiBvKDApfSkueTEoZnVuY3Rpb24odCl7cmV0dXJuIG8oYSh0KSl9KSx0aGlzLnBvaW50cz1bXSxuLmxlbmd0aCYmblswXS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7dmFyIG89cihzKGUpKTt0LnBvaW50cy5wdXNoKHt4Om8saTpufSl9KX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5kYXRhLHI9KGUueEFjY2Vzc29yLGUueUFjY2Vzc29yLGUueFNjYWxlLGUueVNjYWxlLGUuZmlsbENvbG9yKSxvPWUuZmlsbE9wYWNpdHksaT10aGlzLmJhc2VMYXllci5zZWxlY3RBbGwoXCJwYXRoLmFyZWFcIikuZGF0YShuKTtpLmV4aXQoKS5yZW1vdmUoKSxpLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIixcImFyZWFcIiksaS5hdHRyKFwiZFwiLGZ1bmN0aW9uKGUpe3JldHVybiB0LmFyZWFHZW5lcmF0b3IoZSl9KS5zdHlsZShcImZpbGxcIixyKS5zdHlsZShcIm9wYWNpdHlcIixvKX19LHtrZXk6XCJwb3N0UmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BzLmludGVyYWN0aXZlJiZ0aGlzLmJhc2VMYXllci5zZWxlY3RBbGwoXCJwYXRoLmFyZWFcIikub24oXCJtb3VzZW92ZXJcIix0aGlzLm9uT3Zlci5iaW5kKHRoaXMpKS5vbihcIm1vdXNlb3V0XCIsdGhpcy5vbk91dC5iaW5kKHRoaXMpKX19LHtrZXk6XCJvbk92ZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaG92ZXI9ITAsdGhpcy50b29sdGlwJiZ0aGlzLnRvb2x0aXAuc2hvdygpfX0se2tleTpcIm9uT3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhvdmVyPSExLHRoaXMudG9vbHRpcCYmdGhpcy50b29sdGlwLmhpZGUoKX19XSksZX0obFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIG5ldyBvKGZ1bmN0aW9uKGUsbil7dmFyIG89KDAsYVtcImRlZmF1bHRcIl0pKDMpO3QuZm9yRWFjaChmdW5jdGlvbih0KXtvLmRlZmVyKHIsdCl9KSxvLmF3YWl0QWxsKGZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLG89QXJyYXkocj4xP3ItMTowKSxpPTE7cj5pO2krKylvW2ktMV09YXJndW1lbnRzW2ldO3Q/bih0KTplLmFwcGx5KHZvaWQgMCxvKX0pfSl9ZnVuY3Rpb24gcih0LG4pe2kuc3FsUmVxdWVzdCh0LnF1ZXJ5LGZ1bmN0aW9uKGUscil7aWYoZSluKGUpO2Vsc2V7dmFyIG89dm9pZCAwO3N3aXRjaCh0LmZvcm1hdC50b0xvd2VyQ2FzZSgpKXtjYXNlXCJnZW9qc29uXCI6bz1yLmZlYXR1cmVzO2JyZWFrO2RlZmF1bHQ6bz1yLnJvd3N9bihudWxsLG8pfX0se2Zvcm1hdDp0LmZvcm1hdCxkYW5nZXJvdXNseUV4cG9zZWRBUElLZXk6ZX0pfXZhciBpPW5ldyBsW1wiZGVmYXVsdFwiXSh0KTtyZXR1cm57cXVlcnk6bn19dmFyIG89bigxMDYpW1wiZGVmYXVsdFwiXSxpPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGVbXCJkZWZhdWx0XCJdPXI7dmFyIHM9bigyMDMpLGE9aShzKSx1PW4oMjAxKSxsPWkodSk7dC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9big2KSx1PW4oMjEpLGw9bigyMiksYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZihyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb21wb25lbnRXaWxsTW91bnRcIix0aGlzKS5jYWxsKHRoaXMpLCFjYXJ0b2RiKXRocm93IG5ldyBFcnJvcignQ2FydG9EQlRpbGVMYXllciByZXF1aXJlcyBgY2FydG9kYmAuIGBjYXJ0b2RiYCBpcyBub3QgY3VycmVudGx5IGF2YWlsYWJsZSBhcyBhbiBucG0gcGFja2FnZSBhbmQgdGhlcmVmb3JlIG11c3QgYmUgbG9hZGVkIGFzIGEgZ2xvYmFsLCBlLmcuIHZpYSBhIENETiBzY3JpcHQgaW4geW91ciBpbmRleC5odG1sLCBzdWNoIGFzIDxzY3JpcHQgc3JjPVwiaHR0cDovL2xpYnMuY2FydG9jZG4uY29tL2NhcnRvZGIuanMvdjMvMy4xNS9jYXJ0b2RiLmNvcmUuanNcIj4nKTt0aGlzLmxlYWZsZXRFbGVtZW50PSgwLHUudGlsZUxheWVyKShcIlwiLHRoaXMucHJvcHMpLHRoaXMuX2dldENhcnRvREJUaWxlc1RlbXBsYXRlcyhmdW5jdGlvbih0LGUpe3Q/Y29uc29sZS5lcnJvcih0KTp0aGlzLmxlYWZsZXRFbGVtZW50LnNldFVybChlLnRpbGVzWzBdKX0uYmluZCh0aGlzKSl9fSx7a2V5OlwiX2dldENhcnRvREJUaWxlc1RlbXBsYXRlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2NhcnRvZGIuVGlsZXMuZ2V0VGlsZXMoe3R5cGU6XCJjYXJ0b2RiXCIsdXNlcl9uYW1lOnRoaXMucHJvcHMudXNlcklkLHN1YmxheWVyczpbe3NxbDp0aGlzLnByb3BzLnNxbCxjYXJ0b2Nzczp0aGlzLnByb3BzLmNhcnRvY3NzfV19LGZ1bmN0aW9uKGUsbil7IWV8fG4/KG58fChuPVwiRW1wdHkgcmVzcG9uc2UuXCIpLHQobixlKSk6dChudWxsLGUpfSl9fV0sW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7dXNlcklkOmEuUHJvcFR5cGVzLnN0cmluZyxzcWw6YS5Qcm9wVHlwZXMuc3RyaW5nLGNhcnRvY3NzOmEuUHJvcFR5cGVzLnN0cmluZ30sZW51bWVyYWJsZTohMH1dKSxlfShsLkJhc2VUaWxlTGF5ZXIpO2VbXCJkZWZhdWx0XCJdPWMsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPW4oMzApLHA9YShjKSxmPW4oNyksaD1hKGYpO24oMTQ5KTt2YXIgZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e3dpZHRoOnUuUHJvcFR5cGVzLm51bWJlcixoZWlnaHQ6dS5Qcm9wVHlwZXMubnVtYmVyLHNjYWxlOnUuUHJvcFR5cGVzLmZ1bmMsb3JpZW50OnUuUHJvcFR5cGVzLnN0cmluZyxtYXJnaW46dS5Qcm9wVHlwZXMuc2hhcGUoe3RvcDp1LlByb3BUeXBlcy5udW1iZXIscmlnaHQ6dS5Qcm9wVHlwZXMubnVtYmVyLGJvdHRvbTp1LlByb3BUeXBlcy5udW1iZXIsbGVmdDp1LlByb3BUeXBlcy5udW1iZXJ9KSxjaGlsZHJlbjpsW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubm9kZSxzZWxlY3RlZFZhbHVlOnUuUHJvcFR5cGVzLm51bWJlcixvbkNsaWNrT3JNb3ZlOnUuUHJvcFR5cGVzLmZ1bmN9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7c2NhbGU6aFtcImRlZmF1bHRcIl0uc2NhbGUubGluZWFyKCkuY2xhbXAoITApLG9yaWVudDpcImJvdHRvbVwiLG1hcmdpbjp7dG9wOjIwLHJpZ2h0OjMwLGJvdHRvbToyMCxsZWZ0OjMwfSxvbkNsaWNrT3JNb3ZlOm51bGx9LGVudW1lcmFibGU6ITB9XSksaShlLFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3kuY3JlYXRlKHRoaXMucmVmcy5heGlzLHRoaXMucHJvcHMuc2NhbGUsdGhpcy5wcm9wcy5vcmllbnQsdGhpcy5wcm9wcy5tYXJnaW4sdGhpcy5wcm9wcy5vbkNsaWNrT3JNb3ZlKTt0cnl7dGhpcy5jb250YWluZXJOb2RlPXBbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpfWNhdGNoKHQpe310aGlzLmZvcmNlVXBkYXRlKCl9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt5LnVwZGF0ZSh0aGlzLnJlZnMuYXhpcyx0aGlzLnByb3BzLnNjYWxlLHRoaXMucHJvcHMub3JpZW50LHRoaXMucHJvcHMubWFyZ2luLHRoaXMucHJvcHMuc2VsZWN0ZWRWYWx1ZSx0aGlzLnByb3BzLm9uQ2xpY2tPck1vdmUpO3RyeXt0aGlzLmNvbnRhaW5lck5vZGU9cFtcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyl9Y2F0Y2godCl7fX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7eS5kZXN0cm95KHRoaXMucmVmcy5heGlzKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXUuQ2hpbGRyZW4uY291bnQodGhpcy5wcm9wcy5jaGlsZHJlbik7cmV0dXJuIHQ+MSYmY29uc29sZS53YXJuKFwiQ2hhcnRTbGlkZXIgaXMgZGVzaWduZWQgdG8gd3JhcCBvbmx5IG9uZSBjaGlsZCBjb21wb25lbnQsIGJ1dCBpdCBmb3VuZCBcIit0K1wiIGNoaWxkcmVuLlwiKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbm9yYW1hIGNoYXJ0LXNsaWRlclwifSxsW1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5jaGlsZHJlbix7d2lkdGg6dGhpcy5jb250YWluZXJOb2RlP3RoaXMuY29udGFpbmVyTm9kZS5vZmZzZXRXaWR0aDp0aGlzLnByb3BzLndpZHRoLGhlaWdodDp0aGlzLnByb3BzLmhlaWdodH0pLGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwidG9wLXJ1bGVcIixzdHlsZTp7bWFyZ2luTGVmdDp0aGlzLnByb3BzLm1hcmdpbi5sZWZ0K1wicHhcIixtYXJnaW5SaWdodDp0aGlzLnByb3BzLm1hcmdpbi5yaWdodCtcInB4XCIsd2lkdGg6XCJjYWxjKDEwMCUgLSBcIisodGhpcy5wcm9wcy5tYXJnaW4ubGVmdCt0aGlzLnByb3BzLm1hcmdpbi5yaWdodCkrXCJweClcIn19KSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcImQzLWNoYXJ0LXNsaWRlclwiLHJlZjpcImF4aXNcIn0pKX19XSksZX0obFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtlW1wiZGVmYXVsdFwiXT1kO3ZhciB5PXtjcmVhdGU6ZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLm9uQnJ1c2hNb3ZlZD10aGlzLm9uQnJ1c2hNb3ZlZC5iaW5kKHRoaXMpLHRoaXMubm9kZT10O3ZhciBpPTEzO3RoaXMuYXhpc1ByaW1hcnk9aFtcImRlZmF1bHRcIl0uc3ZnLmF4aXMoKS5vcmllbnQobikudGlja3MoNSkudGlja0Zvcm1hdChTdHJpbmcpLnRpY2tTaXplKGkpLHRoaXMuYXhpc1NlY29uZGFyeT1oW1wiZGVmYXVsdFwiXS5zdmcuYXhpcygpLm9yaWVudChuKS50aWNrcygxMCkudGlja0Zvcm1hdChmdW5jdGlvbih0KXtyZXR1cm5cIlwifSkudGlja1NpemUoaS0zKSx0aGlzLmF4aXNUZXJ0aWFyeT1oW1wiZGVmYXVsdFwiXS5zdmcuYXhpcygpLm9yaWVudChuKS50aWNrcyg0MCkudGlja0Zvcm1hdChmdW5jdGlvbih0KXtyZXR1cm5cIlwifSkudGlja1NpemUoaS02KSx0aGlzLmJydXNoPWhbXCJkZWZhdWx0XCJdLnN2Zy5icnVzaCgpLm9uKFwiYnJ1c2hcIix0aGlzLm9uQnJ1c2hNb3ZlZCk7dmFyIHM9aFtcImRlZmF1bHRcIl0uc2VsZWN0KHQpLmFwcGVuZChcInN2Z1wiKTtzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJheGlzIHRlcnRpYXJ5XCIpLHMuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcImF4aXMgc2Vjb25kYXJ5XCIpLHMuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcImF4aXMgcHJpbWFyeVwiKSx0aGlzLmhhbmRsZT1zLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJoYW5kbGVcIik7dmFyIGE9dC5vZmZzZXRIZWlnaHQtci5ib3R0b20raSszLHU9dGhpcy5oYW5kbGUuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcImhhbmRsZS1lbGVtZW50c1wiKTt1LmFwcGVuZChcImxpbmVcIikuYXR0cih7eDE6MCx4MjowLHkxOjAseTI6YX0pO3ZhciBsPTEwO3UuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLFwiTSAzMCAwIEwgNzAgMCBDIDg1IDAgOTMuMjkxNzk2MDY3NTAwNjMgMTMuNDE2NDA3ODY0OTk4NzM5IDg2LjU4MzU5MjEzNTAwMTI1IDI2LjgzMjgxNTcyOTk5NzQ3OCBMIDYzLjQxNjQwNzg2NDk5ODczIDczLjE2NzE4NDI3MDAwMjUyIEMgNTYuNzA4MjAzOTMyNDk5MzY2IDg2LjU4MzU5MjEzNTAwMTI1IDQzLjI5MTc5NjA2NzUwMDYzIDg2LjU4MzU5MjEzNTAwMTI1IDM2LjU4MzU5MjEzNTAwMTI2IDczLjE2NzE4NDI3MDAwMjUyIEwgMTMuNDE2NDA3ODY0OTk4NzM5IDI2LjgzMjgxNTcyOTk5NzQ3OCBDIDYuNzA4MjAzOTMyNDk5MzY5IDEzLjQxNjQwNzg2NDk5ODczOSAxNSAwIDMwIDAgWiBcIikuYXR0cihcInRyYW5zZm9ybVwiLFwic2NhbGUoXCIrbC8xMDArXCIpIHRyYW5zbGF0ZSgtNTAsIDApXCIpLHUuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLFwiTSAzMCAwIEwgNzAgMCBDIDg1IDAgOTMuMjkxNzk2MDY3NTAwNjMgMTMuNDE2NDA3ODY0OTk4NzM5IDg2LjU4MzU5MjEzNTAwMTI1IDI2LjgzMjgxNTcyOTk5NzQ3OCBMIDYzLjQxNjQwNzg2NDk5ODczIDczLjE2NzE4NDI3MDAwMjUyIEMgNTYuNzA4MjAzOTMyNDk5MzY2IDg2LjU4MzU5MjEzNTAwMTI1IDQzLjI5MTc5NjA2NzUwMDYzIDg2LjU4MzU5MjEzNTAwMTI1IDM2LjU4MzU5MjEzNTAwMTI2IDczLjE2NzE4NDI3MDAwMjUyIEwgMTMuNDE2NDA3ODY0OTk4NzM5IDI2LjgzMjgxNTcyOTk5NzQ3OCBDIDYuNzA4MjAzOTMyNDk5MzY5IDEzLjQxNjQwNzg2NDk5ODczOSAxNSAwIDMwIDAgWiBcIikuYXR0cihcInRyYW5zZm9ybVwiLFwicm90YXRlKDE4MCkgc2NhbGUoXCIrbC8xMDArXCIpIHRyYW5zbGF0ZSgtNTAsIFwiKy0oMTAwL2wqYSkrXCIpXCIpLHRoaXMudXBkYXRlKHQsZSxuLHIpfSx1cGRhdGU6ZnVuY3Rpb24odCxlLG4scixvLGkpe3RoaXMubm9kZT10LHRoaXMub25DbGlja09yTW92ZT1pLGUucmFuZ2UoWzAsdC5vZmZzZXRXaWR0aC1yLmxlZnQtci5yaWdodF0pLHRoaXMuYXhpc1ByaW1hcnkuc2NhbGUoZSksdGhpcy5heGlzU2Vjb25kYXJ5LnNjYWxlKGUpLHRoaXMuYXhpc1RlcnRpYXJ5LnNjYWxlKGUpLHRoaXMuYnJ1c2gueChlKTt2YXIgcz1cInRyYW5zbGF0ZShcIityLmxlZnQrXCIsIFwiKyh0Lm9mZnNldEhlaWdodC1yLmJvdHRvbSkrXCIpXCIsYT1oW1wiZGVmYXVsdFwiXS5zZWxlY3QodCkuc2VsZWN0KFwic3ZnXCIpO2EuYXR0cihcIndpZHRoXCIsXCIxMDAlXCIpLmF0dHIoXCJoZWlnaHRcIixcIjEwMCVcIiksYS5zZWxlY3QoXCIuYXhpcy5wcmltYXJ5XCIpLmNhbGwodGhpcy5heGlzUHJpbWFyeSkuYXR0cihcInRyYW5zZm9ybVwiLHMpLnNlbGVjdEFsbChcInRleHRcIikuYXR0cihcInlcIixNYXRoLmZsb29yKDIvMypyLmJvdHRvbSkpLGEuc2VsZWN0KFwiLmF4aXMuc2Vjb25kYXJ5XCIpLmNhbGwodGhpcy5heGlzU2Vjb25kYXJ5KS5hdHRyKFwidHJhbnNmb3JtXCIscyksYS5zZWxlY3QoXCIuYXhpcy50ZXJ0aWFyeVwiKS5jYWxsKHRoaXMuYXhpc1RlcnRpYXJ5KS5hdHRyKFwidHJhbnNmb3JtXCIscyksdGhpcy5oYW5kbGUuY2FsbCh0aGlzLmJydXNoKS5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrci5sZWZ0K1wiLCAwKVwiKS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5vbihcIm1vdXNlZG93bi5icnVzaFwiLHRoaXMub25CcnVzaE1vdmVkKS5vbihcInRvdWNoc3RhcnQuYnJ1c2hcIix0aGlzLm9uQnJ1c2hNb3ZlZCksdGhpcy5oYW5kbGUuc2VsZWN0QWxsKFwiLmJhY2tncm91bmRcIikuYXR0cihcImhlaWdodFwiLFwiMTAwJVwiKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgbyYmdGhpcy5vblNlbGVjdGVkVmFsdWVDaGFuZ2VkKG8pfSxkZXN0cm95OmZ1bmN0aW9uKHQpe2hbXCJkZWZhdWx0XCJdLnNlbGVjdCh0KS5odG1sKFwiXCIpLHRoaXMubm9kZT1udWxsLHRoaXMuYXhpc1ByaW1hcnk9bnVsbCx0aGlzLmF4aXNTZWNvbmRhcnk9bnVsbCx0aGlzLmF4aXNUZXJ0aWFyeT1udWxsLHRoaXMuYnJ1c2g9bnVsbCx0aGlzLmhhbmRsZT1udWxsfSxvbkJydXNoTW92ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJydXNoLngoKSxlPXQuZG9tYWluKCksbj1oW1wiZGVmYXVsdFwiXS5tb3VzZShoW1wiZGVmYXVsdFwiXS5zZWxlY3QodGhpcy5ub2RlKS5zZWxlY3QoXCIuYXhpc1wiKVswXVswXSlbMF0scj10LmludmVydChuKTtyPU1hdGgucm91bmQoTWF0aC5tYXgoZVswXSxNYXRoLm1pbihlWzFdLHIpKSksdGhpcy5vbkNsaWNrT3JNb3ZlJiZ0aGlzLm9uQ2xpY2tPck1vdmUocil9LG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZWQ6ZnVuY3Rpb24odCl7dGhpcy5oYW5kbGUuY2FsbCh0aGlzLmJydXNoLmV4dGVudChbdCx0KzJdKSk7dmFyIGU9dGhpcy5icnVzaC54KCkodCk7dGhpcy5oYW5kbGUuc2VsZWN0KFwiLmhhbmRsZS1lbGVtZW50c1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIrZStcIiwgMClcIil9fTt0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDIzKVtcImRlZmF1bHRcIl0sbz1uKDEwNClbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oNzApLHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlPXIoe30saCx0KTtmb3IodmFyIG4gaW4gZSludWxsPT1lW25dP2RlbGV0ZSBlW25dOm49PT1wJiYoZVtuXT1sKGVbcF0pKTt2YXIgaT1cIiNcIitvKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdCtcIj1cIitlW3RdfSkuam9pbihcIiZcIik7ZG9jdW1lbnQubG9jYXRpb24uaGFzaCE9PWkmJmRvY3VtZW50LmxvY2F0aW9uLnJlcGxhY2UoaSl9ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg8PTB8fHZvaWQgMD09PWFyZ3VtZW50c1swXT9udWxsOmFyZ3VtZW50c1swXTtyZXR1cm4gdD9oW3RdOnIoe30saCl9ZnVuY3Rpb24gbih0LGUpe2g9dCxlfHxmLmVtaXQoYyxyKHt9LGgpKX1mdW5jdGlvbiBzKCl7bihhKHdpbmRvdy5sb2NhdGlvbi5oYXNoKSl9ZnVuY3Rpb24gYSh0KXt2YXIgZT10LnJlcGxhY2UoL14jXFwvP3xcXC8kL2csXCJcIikuc3BsaXQoXCImXCIpLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiBlPWUuc3BsaXQoXCI9XCIpLGVbMF09PT1wJiYoZVsxXT11KGVbMV0pKSx0W2VbMF1dPWVbMV0sdH0se30pO3JldHVybiBlfWZ1bmN0aW9uIHUodCl7aWYodD10LnNwbGl0KFwiL1wiKSwzPT10Lmxlbmd0aCl7dmFyIGU9cGFyc2VJbnQodFswXSwxMCksbj1wYXJzZUZsb2F0KHRbMV0pLHI9cGFyc2VGbG9hdCh0WzJdKTtyZXR1cm4gaXNOYU4oZSl8fGlzTmFOKG4pfHxpc05hTihyKT8hMTp7Y2VudGVyOltuLHJdLHpvb206ZX19cmV0dXJuITF9ZnVuY3Rpb24gbCh0KXt2YXIgZT12b2lkIDAsbj12b2lkIDAscj10Lnpvb20sbz1NYXRoLm1heCgwLE1hdGguY2VpbChNYXRoLmxvZyhyKS9NYXRoLkxOMikpO3JldHVybiBBcnJheS5pc0FycmF5KHQuY2VudGVyKT8oZT10LmNlbnRlclswXSxuPXQuY2VudGVyWzFdKTooZT10LmNlbnRlci5sYXQsbj10LmNlbnRlci5sbmcpLFtyLGUudG9GaXhlZChvKSxuLnRvRml4ZWQobyldLmpvaW4oXCIvXCIpfXZhciBjPVwiaGFzaENoYW5nZWRcIixwPVwibG9jXCIsZj17fSxoPXt9O3JldHVybiByKGYsaS5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIixzKSxuKGEod2luZG93LmxvY2F0aW9uLmhhc2gpLCEwKSxmLkVWRU5UX0hBU0hfQ0hBTkdFRD1jLGYuTUFQX1NUQVRFX0tFWT1wLGYudXBkYXRlSGFzaD10LGYuZ2V0U3RhdGU9ZSxmfSgpO2VbXCJkZWZhdWx0XCJdPXMsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDcpLGM9dShsKSxwPW4oNDYpLGY9dShwKSxoPW4oNzcpLGQ9dShoKSx5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj1kW1wiZGVmYXVsdFwiXX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMpLGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTphKHt9LGZbXCJkZWZhdWx0XCJdLmRlZmF1bHRQcm9wcyx7eFNjYWxlOmNbXCJkZWZhdWx0XCJdLnNjYWxlLmxpbmVhcigpLHlTY2FsZTpjW1wiZGVmYXVsdFwiXS5zY2FsZS5vcmRpbmFsKCl9KSxlbnVtZXJhYmxlOiEwfV0pLGV9KGZbXCJkZWZhdWx0XCJdKTtlW1wiZGVmYXVsdFwiXT15LHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9big3KSxsPWEodSksYz1uKDQ3KSxwPWEoYyksZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5OlwicHJlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC54QWNjZXNzb3Iscj10LnlBY2Nlc3NvcixvPXQueFNjYWxlLGk9dC55U2NhbGU7aS5yYW5nZVJvdW5kQmFuZHMoWzAsdGhpcy5oZWlnaHRdLHRoaXMuYmFyU3BhY2luZyksaS5kb21haW4oZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHIodCl9KSksby5yYW5nZShbMCx0aGlzLndpZHRoXSksby5kb21haW4oWzAsbFtcImRlZmF1bHRcIl0ubWF4KGUsZnVuY3Rpb24odCl7cmV0dXJuIG4odCl9KV0pLHRoaXMudXBkYXRlQXhpcygwLG8sdGhpcy5wcm9wcy54YXhpcyksdGhpcy51cGRhdGVBeGlzKDEsaSx0aGlzLnByb3BzLnlheGlzKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsZT10LmRhdGEsbj10LnhBY2Nlc3NvcixyPXQueUFjY2Vzc29yLG89dC54U2NhbGUsaT10LnlTY2FsZSxzPXRoaXMuYmFzZS5zZWxlY3RBbGwoXCIuYmFyXCIpLmRhdGEoZSk7cy5leGl0KCkucmVtb3ZlKCkscy5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsXCJiYXJcIikscy5hdHRyKFwieFwiLFwiMFwiKS5hdHRyKFwieVwiLGZ1bmN0aW9uKHQpe3JldHVybiBpKHIodCkpfSkuYXR0cihcIndpZHRoXCIsZnVuY3Rpb24odCl7cmV0dXJuIG8obih0KSl9KS5hdHRyKFwiaGVpZ2h0XCIsaS5yYW5nZUJhbmQoKSl9fV0pLGV9KHBbXCJkZWZhdWx0XCJdKTtlW1wiZGVmYXVsdFwiXT1mLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigyMylbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9bigyMDIpLGM9big2KSxwPXUoYyk7bigxNTEpO3ZhciBmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMub25JbnRyb0V4aXQ9dGhpcy5vbkludHJvRXhpdC5iaW5kKHRoaXMpLHRoaXMuaW5pdEludHJvKCl9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOntvcGVuOmMuUHJvcFR5cGVzLmJvb2wsc3RlcDpjLlByb3BUeXBlcy5vbmVPZlR5cGUoW2MuUHJvcFR5cGVzLm51bWJlcixjLlByb3BUeXBlcy5zdHJpbmddKSxzdGVwczpjLlByb3BUeXBlcy5hcnJheU9mKGMuUHJvcFR5cGVzLnNoYXBlKHtlbGVtZW50OmMuUHJvcFR5cGVzLnN0cmluZyxpbnRybzpjLlByb3BUeXBlcy5zdHJpbmcscG9zaXRpb246ZnVuY3Rpb24odCxlLG4pe3JldHVybi90b3B8cmlnaHR8Ym90dG9tfGxlZnQvLnRlc3QodFtlXSk/dm9pZCAwOm5ldyBFcnJvcihcImBwb3NpdGlvbmAgbXVzdCBiZSBvbmUgb2YgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBvciAnbGVmdCcuXCIpfX0pKS5pc1JlcXVpcmVkLGNvbmZpZzpjLlByb3BUeXBlcy5vYmplY3Qsb25FeGl0OmMuUHJvcFR5cGVzLmZ1bmN9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7b3BlbjohMSxzdGVwOjAsc3RlcHM6W10sY29uZmlnOntzaG93U3RlcE51bWJlcnM6ITEsc2tpcExhYmVsOlwiw5dcIixuZXh0TGFiZWw6XCLin6lcIixwcmV2TGFiZWw6XCLin6hcIixkb25lTGFiZWw6XCLDl1wifSxvbkV4aXQ6bnVsbH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJpbml0SW50cm9cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW50cm89KDAsbC5pbnRyb0pzKShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKSksdGhpcy5pbnRyby5vbmV4aXQodGhpcy5vbkludHJvRXhpdCksdGhpcy5pbnRyby5vbmNvbXBsZXRlKHRoaXMub25JbnRyb0V4aXQpLHRoaXMuaW50cm9Jc09wZW49ITF9fSx7a2V5Olwib25JbnRyb0V4aXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW50cm9Jc09wZW49ITEsdGhpcy5wcm9wcy5vbkV4aXQmJnRoaXMucHJvcHMub25FeGl0KCl9fSx7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5wcm9wcy5vcGVuKXtpZih0aGlzLmludHJvSXNPcGVuKXJldHVybjtpZih0aGlzLmludHJvLl9pbnRyb0l0ZW1zKXRoaXMucHJvcHMuc3RlcCYmMSE9PXRoaXMucHJvcHMuc3RlcD90aGlzLmludHJvLmdvVG9TdGVwKHRoaXMucHJvcHMuc3RlcC0xKS5zdGFydCgpOnRoaXMuaW50cm8uc3RhcnQoKTtlbHNle3ZhciB0PXtzdGVwczp0aGlzLnByb3BzLnN0ZXBzfTt0PWEodCx0aGlzLnByb3BzLmNvbmZpZyksdGhpcy5pbnRyby5zZXRPcHRpb25zKHQpLHRoaXMuaW50cm8uZ29Ub1N0ZXAodGhpcy5wcm9wcy5zdGVwKS5zdGFydCgpfXRoaXMuaW50cm9Jc09wZW49ITB9ZWxzZSB0aGlzLmludHJvLmV4aXQoKX19LHtrZXk6XCJnZXREZWZhdWx0U3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybnt9fX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHBbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicGFub3JhbWEgaW50cm8tbWFuYWdlclwifSl9fV0pLGV9KHBbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7ZVtcImRlZmF1bHRcIl09Zix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oNiksbD1hKHUpLGM9bigzMSk7bigxNTIpO3ZhciBwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMub25JdGVtQ2xpY2s9dGhpcy5vbkl0ZW1DbGljay5iaW5kKHRoaXMpLHRoaXMub25BcnJvd01vdXNlRG93bj10aGlzLm9uQXJyb3dNb3VzZURvd24uYmluZCh0aGlzKSx0aGlzLm9uQXJyb3dNb3VzZVVwPXRoaXMub25BcnJvd01vdXNlVXAuYmluZCh0aGlzKSx0aGlzLmFuaW1hdGVTY3JvbGxQb3NpdGlvbj10aGlzLmFuaW1hdGVTY3JvbGxQb3NpdGlvbi5iaW5kKHRoaXMpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7dGl0bGU6dS5Qcm9wVHlwZXMuc3RyaW5nLGl0ZW1zOnUuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsc2VsZWN0ZWRJbmRleDp1LlByb3BUeXBlcy5vbmVPZlR5cGUoW3UuUHJvcFR5cGVzLnN0cmluZyx1LlByb3BUeXBlcy5udW1iZXJdKSxzZWxlY3RlZEl0ZW06dS5Qcm9wVHlwZXMub2JqZWN0LG9uSXRlbVNlbGVjdGVkOnUuUHJvcFR5cGVzLmZ1bmN9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7dGl0bGU6XCJcIixpdGVtczpbXSxzZWxlY3RlZEluZGV4OlwiXCIsc2VsZWN0ZWRJdGVtOm51bGwsb25JdGVtU2VsZWN0ZWQ6bnVsbH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY3JvbGxUb1NlbGVjdGVkSXRlbSgpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNjcm9sbFRvU2VsZWN0ZWRJdGVtKCl9fSx7a2V5Olwib25JdGVtQ2xpY2tcIix2YWx1ZTpmdW5jdGlvbih0KXt0LmN1cnJlbnRUYXJnZXQmJnQuY3VycmVudFRhcmdldC5kYXRhc2V0JiYodGhpcy5wcm9wcy5vbkl0ZW1TZWxlY3RlZCYmdGhpcy5wcm9wcy5vbkl0ZW1TZWxlY3RlZCh0aGlzLnByb3BzLml0ZW1zW3QuY3VycmVudFRhcmdldC5kYXRhc2V0LmluZGV4XSx0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pbmRleCksYy5QYW5vcmFtYURpc3BhdGNoZXIuSXRlbVNlbGVjdG9yLnNlbGVjdGVkKHRoaXMucHJvcHMuaXRlbXNbdC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaW5kZXhdLHQuY3VycmVudFRhcmdldC5kYXRhc2V0LmluZGV4KSl9fSx7a2V5Olwib25BcnJvd01vdXNlRG93blwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXZvaWQgMDtpZih0LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJ1cC1hcnJvd1wiKT9lPS0xOnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImRvd24tYXJyb3dcIikmJihlPTEpLGUpe3ZhciBuPXRoaXMucmVmc1tcIml0ZW0tbGlzdFwiXSxyPTE2LG89MCxpPW4ucXVlcnlTZWxlY3RvcihcImxpXCIpLHM9d2luZG93LmdldENvbXB1dGVkU3R5bGUoaSksYT1pLm9mZnNldEhlaWdodCsocz9wYXJzZUZsb2F0KHNbXCJtYXJnaW4tYm90dG9tXCJdLnJlcGxhY2UoXCJweFwiLFwiXCIpKTowKTt0aGlzLmFycm93TW91c2VVcD0hMTt2YXIgdT1mdW5jdGlvbigpe28tLTw9MSYmKHRoaXMuc2Nyb2xsVG9Qb3NpdGlvbihuLnNjcm9sbFRvcCtlKmEpLG89cj1NYXRoLm1heCgxLE1hdGguZmxvb3IoLjc1KnIpKSksdGhpcy5hcnJvd01vdXNlVXB8fHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodSl9LmJpbmQodGhpcyk7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh1KX19fSx7a2V5Olwib25BcnJvd01vdXNlVXBcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmFycm93TW91c2VVcD0hMH19LHtrZXk6XCJzY3JvbGxUb1Bvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIHRoaXMudGFyZ2V0U2Nyb2xsUG9zaXRpb24/KHRoaXMudGFyZ2V0U2Nyb2xsUG9zaXRpb249dCx0aGlzLmFuaW1hdGVTY3JvbGxQb3NpdGlvbigpKTp0aGlzLnRhcmdldFNjcm9sbFBvc2l0aW9uPXR9fSx7a2V5Olwic2Nyb2xsVG9TZWxlY3RlZEl0ZW1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucmVmc1tcIml0ZW0tbGlzdFwiXSxlPXQucXVlcnlTZWxlY3RvcihcIi5zZWxlY3RlZFwiKTtlJiZ0aGlzLnNjcm9sbFRvUG9zaXRpb24oZS5vZmZzZXRUb3AtdC5vZmZzZXRIZWlnaHQpfX0se2tleTpcImFuaW1hdGVTY3JvbGxQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yZWZzW1wiaXRlbS1saXN0XCJdLGU9dm9pZCAwO1widW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLnNjcm9sbFBvc2l0aW9uJiYodGhpcy5zY3JvbGxQb3NpdGlvbj10LnNjcm9sbFRvcCksZT10aGlzLnRhcmdldFNjcm9sbFBvc2l0aW9uLXRoaXMuc2Nyb2xsUG9zaXRpb24sTWF0aC5hYnMoZSk+MT8odGhpcy5zY3JvbGxQb3NpdGlvbis9LjI1KmUsdC5zY3JvbGxUb3A9dGhpcy5zY3JvbGxQb3NpdGlvbix3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZVNjcm9sbFBvc2l0aW9uKSk6KHQuc2Nyb2xsVG9wPXRoaXMudGFyZ2V0U2Nyb2xsUG9zaXRpb24sdGhpcy50YXJnZXRTY3JvbGxQb3NpdGlvbj12b2lkIDAsdGhpcy5zY3JvbGxQb3NpdGlvbj12b2lkIDApfX0se2tleTpcImdldERlZmF1bHRTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJue319fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dm9pZCAwO3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbm9yYW1hIGl0ZW0tc2VsZWN0b3JcIn0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImgzXCIsbnVsbCx0aGlzLnByb3BzLnRpdGxlKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInNjcm9sbC1hcnJvdyB1cC1hcnJvd1wiLG9uTW91c2VEb3duOnRoaXMub25BcnJvd01vdXNlRG93bixvbk1vdXNlVXA6dGhpcy5vbkFycm93TW91c2VVcH0pLGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLHtyZWY6XCJpdGVtLWxpc3RcIn0sdGhpcy5wcm9wcy5pdGVtcy5tYXAoZnVuY3Rpb24obixyKXtyZXR1cm4gZT10LnByb3BzLnNlbGVjdGVkSXRlbS5pZD09bi5pZHx8dC5wcm9wcy5zZWxlY3RlZEl0ZW09PT1ufHx0LnByb3BzLnNlbGVjdGVkSW5kZXg9PT1yLGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaVwiLHtjbGFzc05hbWU6XCJpdGVtXCIrKGU/XCIgc2VsZWN0ZWRcIjpcIlwiKSsobi5jbGFzc05hbWU/XCIgXCIrbi5jbGFzc05hbWU6XCJcIiksXCJkYXRhLWluZGV4XCI6cixrZXk6cixvbkNsaWNrOnQub25JdGVtQ2xpY2t9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxuLm5hbWUpKX0pKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInNjcm9sbC1hcnJvdyBkb3duLWFycm93XCIsb25Nb3VzZURvd246dGhpcy5vbkFycm93TW91c2VEb3duLG9uTW91c2VVcDp0aGlzLm9uQXJyb3dNb3VzZVVwfSkpfX1dKSxlfShsW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO2VbXCJkZWZhdWx0XCJdPXAsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDMzKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDYpLGM9KHUobCksbigyMikpLHA9bigyMSksZj1uKDE4MSksaD11KGYpLGQ9bigxNykseT0odShkKSxuKDI5KSksdj0odSh5KSxuKDY1KSksbT0odSh2KSxbXCJzdHJva2VcIixcImNvbG9yXCIsXCJ3ZWlnaHRcIixcIm9wYWNpdHlcIixcImZpbGxcIixcImZpbGxDb2xvclwiLFwiZmlsbE9wYWNpdHlcIixcImZpbGxSdWxlXCIsXCJkYXNoQXJyYXlcIixcImxpbmVDYXBcIixcImxpbmVKb2luXCIsXCJjbGlja2FibGVcIixcInBvaW50ZXJFdmVudHNcIixcImNsYXNzTmFtZVwiXSk7bigxNTMpO3ZhciBnPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMpLHRoaXMubW91c2VUaW1lcj1udWxsLHRoaXMuY3VycmVudElkPW51bGwsdGhpcy5oYXNUb29sdGlwPSExLHRoaXMuc3RhdGU9e3Nob3dUb29sdGlwOiExLHRvb2x0aXBQb3NpdGlvbjpudWxsLHRvb2x0aXBDb250ZW50OlwiXCJ9fXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJQcm9wVHlwZXNcIix2YWx1ZTp7c3R5bGVyOmwuUHJvcFR5cGVzLmZ1bmMsb25FYWNoRmVhdHVyZTpsLlByb3BUeXBlcy5mdW5jLHNldFRvb2x0aXBDb250ZW50OmwuUHJvcFR5cGVzLmZ1bmMsc2VsZWN0ZWRTdHlsZTpsLlByb3BUeXBlcy5vYmplY3Qsb25GZWF0dXJlQ2xpY2s6bC5Qcm9wVHlwZXMuZnVuY30sZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOntzZWxlY3RlZFN0eWxlOnt9fSxlbnVtZXJhYmxlOiEwfV0pLGkoZSxbe2tleTpcInNob3VsZENvbXBvbmVudFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiEwfX0se2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29tcG9uZW50V2lsbE1vdW50XCIsdGhpcykuY2FsbCh0aGlzKTt2YXIgdD10aGlzLnByb3BzLmRhdGEsbj10aGlzLnNldEdlb0pTT05PcHRpb25zKCk7dGhpcy5zZXRUb29sdGlwRmxhZygpLHRoaXMubGVhZmxldEVsZW1lbnQ9KDAscC5nZW9Kc29uKSh0LG4pfX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLm1hcDt0aGlzLmxlYWZsZXRFbGVtZW50LmFkZFRvKHQpLHRoaXMuaGFzVG9vbHRpcCYmdC5vbihcIm1vdXNlbW92ZVwiLHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb3BzLmRhdGE7dC5kYXRhIT09ZSYmdGhpcy5sZWFmbGV0RWxlbWVudC5hZGREYXRhKGUpfX0se2tleTpcInNldEdlb0pTT05PcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hKHRoaXMucHJvcHMsW10pO3JldHVybntzdHlsZTp0LnN0eWxlfHxudWxsLG9uRWFjaEZlYXR1cmU6dC5vbkVhY2hGZWF0dXJlfHx0aGlzLm9uRWFjaEZlYXR1cmUuYmluZCh0aGlzKSxmaWx0ZXI6dC5maWx0ZXJ8fG51bGwscG9pbnRUb0xheWVyOnQucG9pbnRUb0xheWVyfHxudWxsLGNvb3Jkc1RvTGF0TG5nOnQuY29vcmRzVG9MYXRMbmd8fG51bGx9fX0se2tleTpcInNldFRvb2x0aXBGbGFnXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5wcm9wcy5jaGlsZHJlbjtsLkNoaWxkcmVuLmZvckVhY2goZSxmdW5jdGlvbihlKXtlLnR5cGUmJmUudHlwZS5uYW1lJiZcIlRvb2x0aXBcIj09PWUudHlwZS5uYW1lJiYodC5oYXNUb29sdGlwPSEwKX0pfX0se2tleTpcImdldFBhdGhPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuKDAsaFtcImRlZmF1bHRcIl0pKHQsbSl9fSx7a2V5OlwiZ2V0VG9vbHRpcENvbnRlbnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnByb3BzLnNldFRvb2x0aXBDb250ZW50P3RoaXMucHJvcHMuc2V0VG9vbHRpcENvbnRlbnQodCk6XCJcIn19LHtrZXk6XCJvbk1vdXNlT3ZlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuY3VycmVudElkIT09dC50YXJnZXQpe2lmKHQudGFyZ2V0LnNldFN0eWxlKHRoaXMucHJvcHMuc2VsZWN0ZWRTdHlsZSksdGhpcy5jdXJyZW50SWQhPT10LnRhcmdldCl7dGhpcy5jdXJyZW50SWQ9dC50YXJnZXQ7dmFyIGU9dGhpcy5nZXRUb29sdGlwQ29udGVudCh0LnRhcmdldC5mZWF0dXJlKTt0aGlzLnNldFN0YXRlKHtzaG93VG9vbHRpcDohMCx0b29sdGlwUG9zaXRpb246dC5sYXRsbmcsdG9vbHRpcENvbnRlbnQ6ZX0pfUwuQnJvd3Nlci5pZXx8TC5Ccm93c2VyLm9wZXJhfHx0LnRhcmdldC5icmluZ1RvRnJvbnQoKX19fSx7a2V5Olwib25Nb3VzZU91dFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5sZWFmbGV0RWxlbWVudC5yZXNldFN0eWxlKHQudGFyZ2V0KSx0aGlzLmN1cnJlbnRJZD1udWxsLGNsZWFyVGltZW91dCh0aGlzLm1vdXNlVGltZXIpLHRoaXMubW91c2VUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnVsbD09PWUuY3VycmVudElkJiYoZS5jdXJyZW50SWQ9bnVsbCxlLnNldFN0YXRlKHtzaG93VG9vbHRpcDohMX0pKX0sMjAwKX19LHtrZXk6XCJvbk1vdXNlTW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuY3VycmVudElkJiYocC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24odCksdGhpcy5zZXRTdGF0ZSh7dG9vbHRpcFBvc2l0aW9uOnQubGF0bG5nfSkpfX0se2tleTpcIm9uQ2xpY2tcIix2YWx1ZTpmdW5jdGlvbih0KXtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnByb3BzLm9uRmVhdHVyZUNsaWNrJiZ0aGlzLnByb3BzLm9uRmVhdHVyZUNsaWNrKHQudGFyZ2V0LHRoaXMucHJvcHMubWFwKX19LHtrZXk6XCJvbkVhY2hGZWF0dXJlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmhhc1Rvb2x0aXAmJmUub24oe21vdXNlb3Zlcjp0aGlzLm9uTW91c2VPdmVyLmJpbmQodGhpcyksbW91c2VvdXQ6dGhpcy5vbk1vdXNlT3V0LmJpbmQodGhpcyl9KSxlLm9uKFwiY2xpY2tcIix0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW5kZXJDaGlsZHJlbldpdGhQcm9wcyh7dG9vbHRpcENvbnRhaW5lcjp0aGlzLmxlYWZsZXRFbGVtZW50LHBvcHVwQ29udGFpbmVyOnRoaXMubGVhZmxldEVsZW1lbnQscG9zaXRpb246dGhpcy5zdGF0ZS50b29sdGlwUG9zaXRpb24saXNPcGVuOnRoaXMuc3RhdGUuc2hvd1Rvb2x0aXAsY29udGVudDp0aGlzLnN0YXRlLnRvb2x0aXBDb250ZW50fSl9fV0pLGV9KGMuTWFwTGF5ZXIpO2VbXCJkZWZhdWx0XCJdPWcsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDMzKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDYpLGM9KHUobCksbigyMikpLHA9KG4oMjEpLG4oODIpKSxmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7Y2VudGVyOmMuUHJvcFR5cGVzLmxhdGxuZy5pc1JlcXVpcmVkLG91dGVyUmFkaXVzOmwuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLGlubmVyUmFkaXVzOmwuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkfSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6e30sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsbj10LmNlbnRlcixvPXQub3V0ZXJSYWRpdXMsaT10LmlubmVyUmFkaXVzLHM9YSh0LFtcImNlbnRlclwiLFwib3V0ZXJSYWRpdXNcIixcImlubmVyUmFkaXVzXCJdKTtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb21wb25lbnRXaWxsTW91bnRcIix0aGlzKS5jYWxsKHRoaXMpLHRoaXMubGVhZmxldEVsZW1lbnQ9bmV3IHAuTGVhZmxldERvbnV0KG4sbyxpLHRoaXMuZ2V0UGF0aE9wdGlvbnMocykpfX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMucHJvcHMuY2VudGVyIT09dC5jZW50ZXImJnRoaXMubGVhZmxldEVsZW1lbnQuc2V0TGF0TG5nKHRoaXMucHJvcHMuY2VudGVyKSwodGhpcy5wcm9wcy5vdXRlclJhZGl1cyE9PXQub3V0ZXJSYWRpdXN8fHRoaXMucHJvcHMuaW5uZXJSYWRpdXMhPT10LmlubmVyUmFkaXVzKSYmdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRSYWRpdXModGhpcy5wcm9wcy5vdXRlclJhZGl1cyx0aGlzLnByb3BzLmlubmVyUmFkaXVzKSx0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHQsdGhpcy5wcm9wcyl9fV0pLGV9KGMuUGF0aCk7ZVtcImRlZmF1bHRcIl09Zix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgbz1uKDQ4KVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9bigyMSkscz1vKGkpLGE9ZnVuY3Rpb24odCl7cmV0dXJuIHQuQ2lyY2xlLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbihlLG4scixvKXt0LlBhdGgucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLG8pLHRoaXMuX2xhdGxuZz10LmxhdExuZyhlKSx0aGlzLl9tT3V0ZXJSYWRpdXM9bix0aGlzLl9tSW5uZXJSYWRpdXM9dGhpcy5fdmFsaWRhdGVJbm5lclJhZGl1cyhuLHIpfSxzZXRSYWRpdXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbU91dGVyUmFkaXVzPXQsdGhpcy5fbUlubmVyUmFkaXVzPXRoaXMuX3ZhbGlkYXRlSW5uZXJSYWRpdXModCxlKSx0aGlzLnJlZHJhdygpfSxwcm9qZWN0TGF0bG5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2dldExuZ1JhZGl1cygpLGU9dGhpcy5fbGF0bG5nLG49dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbZS5sYXQsZS5sbmctdFswXV0pLHI9dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbZS5sYXQsZS5sbmctdFsxXV0pO3RoaXMuX3BvaW50PXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoZSksdGhpcy5fb3V0ZXJSYWRpdXM9TWF0aC5tYXgodGhpcy5fcG9pbnQueC1uLngsMSksdGhpcy5faW5uZXJSYWRpdXM9TWF0aC5tYXgodGhpcy5fcG9pbnQueC1yLngsMSl9LGdldEJvdW5kczpmdW5jdGlvbigpe3ZhciBlPXRoaXMuX2dldExuZ1JhZGl1cygpWzBdLG49dGhpcy5fZ2V0TGF0UmFkaXVzKClbMF0scj10aGlzLl9sYXRsbmc7cmV0dXJuIG5ldyB0LkxhdExuZ0JvdW5kcyhbci5sYXQtbixyLmxuZy1lXSxbci5sYXQrbixyLmxuZytlXSl9LGdldFJhZGl1czpmdW5jdGlvbigpe3JldHVyblt0aGlzLl9tT3V0ZXJSYWRpdXMsdGhpcy5fbUlubmVyUmFkaXVzXX0sX2dldExhdFJhZGl1czpmdW5jdGlvbigpe3JldHVyblt0aGlzLl9tT3V0ZXJSYWRpdXMvNDAwNzUwMTcqMzYwLHRoaXMuX21Jbm5lclJhZGl1cy80MDA3NTAxNyozNjBdfSxfZ2V0TG5nUmFkaXVzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fZ2V0TGF0UmFkaXVzKCk7cmV0dXJuW2VbMF0vTWF0aC5jb3ModC5MYXRMbmcuREVHX1RPX1JBRCp0aGlzLl9sYXRsbmcubGF0KSxlWzFdL01hdGguY29zKHQuTGF0TG5nLkRFR19UT19SQUQqdGhpcy5fbGF0bG5nLmxhdCldfSxfY2hlY2tJZkVtcHR5OmZ1bmN0aW9uKCl7aWYoIXRoaXMuX21hcClyZXR1cm4hMTt2YXIgdD10aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCxlPXRoaXMuX291dGVyUmFkaXVzLG49dGhpcy5fcG9pbnQ7cmV0dXJuIG4ueC1lPnQubWF4Lnh8fG4ueS1lPnQubWF4Lnl8fG4ueCtlPHQubWluLnh8fG4ueStlPHQubWluLnl9LF92YWxpZGF0ZUlubmVyUmFkaXVzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+PXQ/dC0xOmV9LGdldEFyYzpmdW5jdGlvbih0LGUsbil7dmFyIHI9dC54LS4wMSxvPXQueS1lLGk9dC55LW47cmV0dXJuW1wiTVwiLHQueCxvLFwiQVwiLGUsZSwwLDEsMSxyLG8sXCJNXCIscixpLFwiQVwiLG4sbiwwLDEsMCx0LngsaSxcIlpcIl0uam9pbihcIiBcIil9LGdldFBhdGhTdHJpbmc6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9wb2ludCxuPXRoaXMuX291dGVyUmFkaXVzLG89dGhpcy5faW5uZXJSYWRpdXM7cmV0dXJuIHRoaXMuX2NoZWNrSWZFbXB0eSgpP1wiXCI6dC5Ccm93c2VyLnN2Zz90aGlzLmdldEFyYyhlLG4sbyk6KGUuX3JvdW5kKCkscj1NYXRoLnJvdW5kKHIpLFwiQUwgXCIrZS54K1wiLFwiK2UueStcIiBcIituK1wiLFwiK24rXCIgMCwyMzU5MjYwMFwiKX19KX0ocyk7ZS5MZWFmbGV0RG9udXQ9YX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigzMylbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9big2KSxjPW4oMjIpLHA9bigyMSksZj1uKDY1KSxoPXUoZiksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb21wb25lbnRXaWxsTW91bnRcIix0aGlzKS5jYWxsKHRoaXMpO3ZhciB0PXRoaXMucHJvcHMsbj0odC5jaGlsZHJlbix0Lm1hcCxhKHQsW1wiY2hpbGRyZW5cIixcIm1hcFwiXSkpLG89KDAsaFtcImRlZmF1bHRcIl0pKHt9LG4pO28uY2xhc3NOYW1lPW8uY2xhc3NOYW1lP28uY2xhc3NOYW1lK1wiIHBhbm9yYW1hLWxlYWZsZXQtdGlwXCI6XCJwYW5vcmFtYS1sZWFmbGV0LXRpcFwiLG8uY2xvc2VCdXR0b249ITEsby5vZmZzZXQ9by5vZmZzZXR8fFswLC0zXSx0aGlzLmxlYWZsZXRFbGVtZW50PSgwLHAucG9wdXApKG8pfX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9wcyxuPWUubWFwLHI9ZS5wb3NpdGlvbixvPWUuaXNPcGVuLGk9ZS5jb250ZW50O3IhPT10LnBvc2l0aW9uJiZ0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZyhyKSxpIT09dC5jb250ZW50JiZ0aGlzLmxlYWZsZXRFbGVtZW50LnNldENvbnRlbnQoaSksbyE9PXQuaXNPcGVuJiYobz8odGhpcy5sZWFmbGV0RWxlbWVudC5vcGVuT24obiksdGhpcy5yZW5kZXJQb3B1cENvbnRlbnQoKSk6KG4uY2xvc2VQb3B1cCgpLHRoaXMucmVtb3ZlUG9wdXBDb250ZW50KCkpKX19XSxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOntjaGlsZHJlbjpsLlByb3BUeXBlcy5ub2RlLG1hcDpsLlByb3BUeXBlcy5pbnN0YW5jZU9mKHAuTWFwKSx0b29sdGlwQ29udGFpbmVyOmwuUHJvcFR5cGVzLm9iamVjdCxwb3NpdGlvbjpjLlByb3BUeXBlcy5sYXRsbmd9LGVudW1lcmFibGU6ITB9XSksZX0oYy5Qb3B1cCk7ZVtcImRlZmF1bHRcIl09ZCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oNiksbD1hKHUpLGM9bigzMSk7bigxNTQpO3ZhciBwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMub25JdGVtQ2xpY2s9dGhpcy5vbkl0ZW1DbGljay5iaW5kKHRoaXMpLHRoaXMub25JdGVtRW50ZXI9dGhpcy5vbkl0ZW1FbnRlci5iaW5kKHRoaXMpLHRoaXMub25JdGVtTGVhdmU9dGhpcy5vbkl0ZW1MZWF2ZS5iaW5kKHRoaXMpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7aXRlbXM6dS5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxzZWxlY3RlZEl0ZW06dS5Qcm9wVHlwZXMuc3RyaW5nLG9uSXRlbVNlbGVjdGVkOnUuUHJvcFR5cGVzLmZ1bmN9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7aXRlbXM6W10sc2VsZWN0ZWRJdGVtOlwiXCIsb25JdGVtU2VsZWN0ZWQ6bnVsbH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwib25JdGVtQ2xpY2tcIix2YWx1ZTpmdW5jdGlvbih0KXt0LmN1cnJlbnRUYXJnZXQmJnQuY3VycmVudFRhcmdldC5kYXRhc2V0JiYodGhpcy5wcm9wcy5vbkl0ZW1TZWxlY3RlZCYmdGhpcy5wcm9wcy5vbkl0ZW1TZWxlY3RlZCh0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pdGVtLHRoaXMucHJvcHMuaXRlbXMuaW5kZXhPZih0LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pdGVtKSksYy5QYW5vcmFtYURpc3BhdGNoZXIuTGVnZW5kLnNlbGVjdGVkKHQuY3VycmVudFRhcmdldC5kYXRhc2V0Lml0ZW0sdGhpcy5wcm9wcy5pdGVtcy5pbmRleE9mKHQuY3VycmVudFRhcmdldC5kYXRhc2V0Lml0ZW0pKSl9fSx7a2V5Olwib25JdGVtRW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt9fSx7a2V5Olwib25JdGVtTGVhdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbm9yYW1hIGxlZ2VuZFwifSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidWxcIixudWxsLHRoaXMucHJvcHMuaXRlbXMubWFwKGZ1bmN0aW9uKGUsbil7dmFyIHI9dC5wcm9wcy5zZWxlY3RlZEl0ZW09PT1lfHx0LnByb3BzLnNlbGVjdGVkSXRlbT09bjtyZXR1cm4gbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIse2NsYXNzTmFtZTpcIml0ZW1cIisocj9cIiBzZWxlY3RlZFwiOlwiXCIpLFwiZGF0YS1pdGVtXCI6ZSxrZXk6ZSxvbkNsaWNrOnQub25JdGVtQ2xpY2ssb25Nb3VzZUVudGVyOnQub25JdGVtRW50ZXIsb25Nb3VzZUxlYXZlOnQub25JdGVtTGVhdmV9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCx0LmNhcGl0YWxpemUoZSkpKX0pKSl9fSx7a2V5OlwiY2FwaXRhbGl6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9fV0pLGV9KGxbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7ZVtcImRlZmF1bHRcIl09cCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMTEpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oNyksYz0odShsKSxuKDYpKSxwPW4oMTQpLGY9dShwKSxoPW4oODYpLGQ9dShoKTtuKDE1NSk7dmFyIHk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5jaGFydENvbnN0cnVjdG9yPWRbXCJkZWZhdWx0XCJdfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTphKHt9LGZbXCJkZWZhdWx0XCJdLnByb3BUeXBlcyx7c3Ryb2tlQ29sb3I6Yy5Qcm9wVHlwZXMub25lT2ZUeXBlKFtjLlByb3BUeXBlcy5zdHJpbmcsYy5Qcm9wVHlwZXMubnVtYmVyXSksc3Ryb2tlT3BhY2l0eTpjLlByb3BUeXBlcy5udW1iZXIsaXNJbnRlcnBvbGF0ZWQ6Yy5Qcm9wVHlwZXMuYm9vbCxpbnRlcnBvbGF0ZTpjLlByb3BUeXBlcy5zdHJpbmd9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse2NsYXNzTmFtZTpcImxpbmUtY2hhcnRcIixpc0ludGVycG9sYXRlZDohMSxpbnRlcnBvbGF0ZTpcImJhc2lzXCIseGF4aXM6e2NsYXNzTmFtZTpcInggYXhpc1wiLG9yaWVudDpcImJvdHRvbVwiLHBvc2l0aW9uOlwiYm90dG9tXCIsYXR0cjp7ZHg6XCIwXCIsZHk6XCIwLjVlbVwifSxzdHlsZTp7XCJ0ZXh0LWFuY2hvclwiOlwibWlkZGxlXCJ9fSx5YXhpczp7Y2xhc3NOYW1lOlwieSBheGlzXCIsb3JpZW50OlwibGVmdFwifX0pLGVudW1lcmFibGU6ITB9XSksZX0oZltcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXksdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDEzKSxsPWEodSksYz1uKDcpLHA9YShjKSxmPW4oMTgpLGg9YShmKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oZSx0KSxpKGUsW3trZXk6XCJ3aWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMueGF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy54YXhpcyx0aGlzLnByb3BzLnhTY2FsZSkpLHRoaXMucHJvcHMueWF4aXMmJnRoaXMuc2V0QXhpcyhuZXcgaFtcImRlZmF1bHRcIl0odGhpcy5wcm9wcy55YXhpcyx0aGlzLnByb3BzLnlTY2FsZSkpLHRoaXMubGluZUdlbmVyYXRvcj1wW1wiZGVmYXVsdFwiXS5zdmcubGluZSgpfX0se2tleTpcIm9uTW91bnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJvbk1vdW50XCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMubGluZUxheWVyPXRoaXMuYmFzZS5hcHBlbmQoXCJnXCIpLmNsYXNzZWQoXCJsaW5lLWxheWVyXCIsITApLHRoaXMuX3JlbmRlcigpfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPSh0LmRhdGEsdC54QWNjZXNzb3IpLG49dC55QWNjZXNzb3Iscj10LnhTY2FsZSxvPXQueVNjYWxlLGk9dC5pc0ludGVycG9sYXRlZCxzPXQuaW50ZXJwb2xhdGU7ci5yYW5nZShbMCx0aGlzLndpZHRoXSksby5yYW5nZShbdGhpcy5oZWlnaHQsMF0pLHRoaXMudXBkYXRlQXhpcygwLHIsdGhpcy5wcm9wcy54YXhpcyksdGhpcy51cGRhdGVBeGlzKDEsbyx0aGlzLnByb3BzLnlheGlzKTt2YXIgYT1pP3M6XCJsaW5lYXJcIjt0aGlzLmxpbmVHZW5lcmF0b3IuaW50ZXJwb2xhdGUoYSkueChmdW5jdGlvbih0KXtyZXR1cm4gcihlKHQpKX0pLnkoZnVuY3Rpb24odCl7cmV0dXJuIG8obih0KSl9KX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5kYXRhLHI9KGUueEFjY2Vzc29yLGUueUFjY2Vzc29yLGUueFNjYWxlLGUueVNjYWxlLGUuc3Ryb2tlQ29sb3IpLG89ZS5zdHJva2VPcGFjaXR5LGk9dGhpcy5saW5lTGF5ZXIuc2VsZWN0QWxsKFwicGF0aC5saW5lXCIpLmRhdGEobik7aS5leGl0KCkucmVtb3ZlKCksaS5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsXCJsaW5lXCIpLGkuYXR0cihcImRcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5saW5lR2VuZXJhdG9yKGUpfSkuc3R5bGUoe3N0cm9rZTpyLHN0cm9rZU9wYWNpdHk6b30pfX0se2tleTpcInBvc3RSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319XSksZX0obFtcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDcpLGM9KHUobCksbig2KSkscD1uKDE0KSxmPXUocCksaD1uKDg4KSxkPXUoaCk7bigxNTYpO3ZhciB5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj1kW1wiZGVmYXVsdFwiXX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMse3Byb2plY3Rpb246Yy5Qcm9wVHlwZXMuc3RyaW5nLG1hcFNjYWxlOmMuUHJvcFR5cGVzLm9uZU9mVHlwZShbYy5Qcm9wVHlwZXMubnVtYmVyLGMuUHJvcFR5cGVzLnN0cmluZ10pLHNlbGVjdGVkOmMuUHJvcFR5cGVzLmFueSxzZWxlY3RlZEFjY2Vzc29yOmMuUHJvcFR5cGVzLmZ1bmMsaG92ZXJTdHlsZTpjLlByb3BUeXBlcy5vYmplY3R9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse3Byb2plY3Rpb246XCJhbGJlcnNVc2FcIixjbGFzc05hbWU6XCJtYXAgY2hvcm9wbGV0aFwiLG1hcFNjYWxlOjUwMH0pLGVudW1lcmFibGU6ITB9XSksZX0oZltcImRlZmF1bHRcIl0pO2VbXCJkZWZhdWx0XCJdPXksdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEwNylbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGw9bigxMyksYz11KGwpLHA9big3KSxmPXUocCksaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBvKGUsdCksaShlLFt7a2V5Olwid2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcIm9uTW91bnRcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5fcGF0aD1mW1wiZGVmYXVsdFwiXS5nZW8ucGF0aCgpLHRoaXMuX3Byb2plY3Rpb249ZltcImRlZmF1bHRcIl0uZ2VvW3RoaXMucHJvcHMucHJvamVjdGlvbl0oKSx0aGlzLl9yZW5kZXIoKSx0aGlzLl9zZWxlY3RlZD1udWxsLHRoaXMuX2hvdmVyRWxlbWVudD1udWxsfX0se2tleTpcInByZVJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy51cGRhdGVQcm9qZWN0aW9uKCl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC5zdHlsZXIscj10LmludGVyYWN0aXZlLG89dC5zZWxlY3RlZCxpPXQuc2VsZWN0ZWRBY2Nlc3NvcjtpZihlJiZlLmZlYXR1cmVzKXt2YXIgcz10aGlzLGE9dGhpcy5iYXNlLnNlbGVjdEFsbChcInBhdGhcIikuZGF0YShlLmZlYXR1cmVzKTthLmV4aXQoKS5yZW1vdmUoKSxhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIixcImdlb21ldHJ5XCIpLmF0dHIoXCJkXCIsdGhpcy5fcGF0aCksYS5lYWNoKGZ1bmN0aW9uKHQpe2ZbXCJkZWZhdWx0XCJdLnNlbGVjdCh0aGlzKS5zdHlsZShuKHQpKX0pLHImJihmW1wiZGVmYXVsdFwiXS5zZWxlY3RBbGwoXCIuaG92ZXItZHVwZVwiKS5yZW1vdmUoKSxcbnRoaXMuX2hvdmVyRWxlbWVudD1udWxsLGEub24oXCJjbGlja1wiLG51bGwpLm9uKFwibW91c2VvdmVyXCIsbnVsbCkub24oXCJtb3VzZW91dFwiLG51bGwpLm9uKFwiY2xpY2tcIix0aGlzLmRpc3BhdGNoLmNsaWNrKS5vbihcIm1vdXNlZW50ZXJcIixmdW5jdGlvbih0KXtpKHQpIT09byYmKHMuX2hvdmVyRWxlbWVudD1zLmJyaW5nVG9Ub3AodGhpcyxcImhvdmVyLWR1cGUgc2VsLVwiK2kodCkscy5wcm9wcy5ob3ZlclN0eWxlfHxudWxsKSxzLmRpc3BhdGNoLm1vdXNlT3Zlcih0KSl9KS5vbihcIm1vdXNlbGVhdmVcIixmdW5jdGlvbih0KXtzLl9ob3ZlckVsZW1lbnQmJnMuX2hvdmVyRWxlbWVudC5yZW1vdmUoKSxzLl9ob3ZlckVsZW1lbnQ9bnVsbCxzLmRpc3BhdGNoLm1vdXNlT3V0KHQpfSkpLG8mJm8hPT10aGlzLl9zZWxlY3RlZCYmKHRoaXMuX3NlbGVjdGVkPW8sZltcImRlZmF1bHRcIl0uc2VsZWN0QWxsKFwiLnNlbGVjdGVkLWR1cGVcIikucmVtb3ZlKCksYS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIGkodCk9PT1vfSkuZWFjaChmdW5jdGlvbigpe3MuYnJpbmdUb1RvcCh0aGlzLFwic2VsZWN0ZWQtZHVwZVwiKX0pKX19fSx7a2V5OlwicG9zdFJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImJyaW5nVG9Ub3BcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHI9ZltcImRlZmF1bHRcIl0uc2VsZWN0KHQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0LmNsb25lTm9kZSghMCksdC5uZXh0U2libGluZykpLmNsYXNzZWQoZSwhMCk7cmV0dXJuIG4mJnIuc3R5bGUobikscn19LHtrZXk6XCJ1cGRhdGVQcm9qZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC5tYXBTY2FsZSxyPXQucHJvamVjdGlvbixvPW4saT1bdGhpcy53aWR0aC8yLHRoaXMuaGVpZ2h0LzJdO2lmKFwiYXV0b1wiPT09bil7dmFyIHM9dGhpcy5maXRNYXAoZSksdT1hKHMsMik7bz11WzBdLGk9dVsxXX10aGlzLl9wcm9qZWN0aW9uPWZbXCJkZWZhdWx0XCJdLmdlb1tyXSgpLnNjYWxlKG8pLnRyYW5zbGF0ZShpKSx0aGlzLl9wYXRoLnByb2plY3Rpb24odGhpcy5fcHJvamVjdGlvbil9fSx7a2V5OlwiZml0TWFwXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9wcy5wcm9qZWN0aW9uLG49ZltcImRlZmF1bHRcIl0uZ2VvW2VdKCkuc2NhbGUoMSkudHJhbnNsYXRlKFswLDBdKSxyPWZbXCJkZWZhdWx0XCJdLmdlby5wYXRoKCkucHJvamVjdGlvbihuKSxvPXIuYm91bmRzKHQpLGk9Ljk1L01hdGgubWF4KChvWzFdWzBdLW9bMF1bMF0pL3RoaXMud2lkdGgsKG9bMV1bMV0tb1swXVsxXSkvdGhpcy5oZWlnaHQpLHM9Wyh0aGlzLndpZHRoLWkqKG9bMV1bMF0rb1swXVswXSkpLzIsKHRoaXMuaGVpZ2h0LWkqKG9bMV1bMV0rb1swXVsxXSkpLzJdO3JldHVybltpLHNdfX1dKSxlfShjW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09aCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oNiksbD1hKHUpLGM9bigxODgpLHA9YShjKTtuKDE1Nyk7dmFyIGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCl9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOntuYXZfZGF0YTp1LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLHNob3dfbWVudTp1LlByb3BUeXBlcy5ib29sLG9uX2hhbWJ1cmdlcl9jbGljazp1LlByb3BUeXBlcy5mdW5jLHN0eWxlOnUuUHJvcFR5cGVzLm9iamVjdCx0aXRsZTp1LlByb3BUeXBlcy5zdHJpbmcsaG9tZV91cmw6dS5Qcm9wVHlwZXMuc3RyaW5nLGxpbmtzOnUuUHJvcFR5cGVzLmFycmF5LGxpbmtfc2VwYXJhdG9yOnUuUHJvcFR5cGVzLnN0cmluZ30sZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOnt0aXRsZTpcIkFtZXJpY2FuIFBhbm9yYW1hXCIsaG9tZV91cmw6XCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYVwiLGxpbmtzOltdLGxpbmtfc2VwYXJhdG9yOlwiIFwiLG5hdl9kYXRhOnt9LHNob3dfbWVudTohMSxvbl9oYW1idXJnZXJfY2xpY2s6bnVsbCxzdHlsZTp7b3ZlcmxheTp7cG9zaXRpb246XCJmaXhlZFwiLHRvcDowLGxlZnQ6MCxiYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDAsMCwwLDAuNSlcIn0sY29udGVudDp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDowLGxlZnQ6MCxib3R0b206XCJhdXRvXCIscmlnaHQ6XCJhdXRvXCIsYm9yZGVyOjAsYmFja2dyb3VuZDpcInJnYmEoMCwwLDAsMC41KVwiLG92ZXJmbG93OlwiYXV0b1wiLFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOlwidG91Y2hcIixib3JkZXJSYWRpdXM6XCI0cHhcIixvdXRsaW5lOlwibm9uZVwiLHBhZGRpbmc6MH19fSxlbnVtZXJhYmxlOiEwfV0pLGkoZSxbe2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wdXRlRGltZW5zaW9uc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuKHdpbmRvdy5pbm5lcldpZHRoLTQwKnRoaXMucHJvcHMubmF2X2RhdGEubGVuZ3RoKS90aGlzLnByb3BzLm5hdl9kYXRhLmxlbmd0aH19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixudWxsLGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7aWQ6XCJoYW1idXJnZXJcIn0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6XCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9zdGF0aWMvaW1hZ2VzL21lbnUuc3ZnXCIsb25DbGljazp0aGlzLnByb3BzLm9uX2hhbWJ1cmdlcl9jbGlja30pKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHBbXCJkZWZhdWx0XCJdLHtpc09wZW46dGhpcy5wcm9wcy5zaG93X21lbnUsb25SZXF1ZXN0Q2xvc2U6dGhpcy5wcm9wcy5vbl9oYW1idXJnZXJfY2xpY2ssY2xhc3NOYW1lOlwibmF2X2hlYWRlclwiLHN0eWxlOnRoaXMucHJvcHMuc3R5bGV9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7aWQ6XCJuYXZfaGVhZGVyXCJ9LGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7aWQ6XCJuYXZidXJnZXJcIn0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6XCJodHRwOi8vZHNsLnJpY2htb25kLmVkdS9wYW5vcmFtYS9zdGF0aWMvaW1hZ2VzL21lbnUtY2xvc2Uuc3ZnXCIsb25DbGljazp0aGlzLnByb3BzLm9uX2hhbWJ1cmdlcl9jbGlja30pKSx0aGlzLnByb3BzLnRpdGxlJiZ0aGlzLnByb3BzLmhvbWVfdXJsP2xbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJoMVwiLG51bGwsbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImFcIix7aHJlZjp0aGlzLnByb3BzLmhvbWVfdXJsfSx0aGlzLnByb3BzLnRpdGxlKSk6XCJcIixsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiaDJcIixudWxsLHRoaXMucHJvcHMubGlua3MubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJhXCIse2hyZWY6ZS51cmwsa2V5OlwicGFuX25hdl9saW5rc19cIitufSxuPHQucHJvcHMubGlua3MubGVuZ3RoLTE/ZS5uYW1lK3QucHJvcHMubGlua19zZXBhcmF0b3I6ZS5uYW1lKX0pKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2lkOlwibWFwc1wifSx0aGlzLnByb3BzLm5hdl9kYXRhLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBhbl9uYXZfaXRlbVwiLGtleTpcInBhbl9uYXZfaXRlbV9cIituLHN0eWxlOnt3aWR0aDp0LmNvbXB1dGVEaW1lbnNpb25zKCkrXCJweFwifX0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImFcIix7aHJlZjplLnVybH0sbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6ZS5zY3JlZW5zaG90LHN0eWxlOnt3aWR0aDp0LmNvbXB1dGVEaW1lbnNpb25zKCkrXCJweFwifX0pKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYnJcIixudWxsKSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiaDRcIixudWxsLGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJhXCIse2hyZWY6ZS51cmx9LGUudGl0bGUpKSl9KSkpKSl9fV0pLGV9KGxbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7ZVtcImRlZmF1bHRcIl09Zix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMTEpW1wiZGVmYXVsdFwiXSx1PW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPW4oNiksYz0odShsKSxuKDcpKSxwPSh1KGMpLG4oMTQpKSxmPXUocCksaD1uKDQ1KSxkPSh1KGgpLG4oOTEpKSx5PXUoZCk7bigxNTgpO3ZhciB2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj15W1wiZGVmYXVsdFwiXSx0aGlzLmNoYXJ0SWRBY2Nlc3Nvcj10LmNoYXJ0SWRBY2Nlc3Nvcn1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxmW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMse2FyZWFDaGFydERhdGE6bC5Qcm9wVHlwZXMuYXJyYXksY2hhcnRTcGFjaW5nOmwuUHJvcFR5cGVzLm51bWJlcixjb2xvclBhbGV0dGU6bC5Qcm9wVHlwZXMuYXJyYXksc2VsZWN0ZWRDaGFydElkOmwuUHJvcFR5cGVzLm9uZU9mVHlwZShbbC5Qcm9wVHlwZXMuc3RyaW5nLGwuUHJvcFR5cGVzLm51bWJlcl0pLGNoYXJ0SWRBY2Nlc3NvcjpsLlByb3BUeXBlcy5mdW5jLG1ldGFkYXRhQWNjZXNzb3I6bC5Qcm9wVHlwZXMuZnVuYyxpbnRlcnBvbGF0ZTpsLlByb3BUeXBlcy5zdHJpbmcsY2lyY2xlUmFkaXVzOmwuUHJvcFR5cGVzLm51bWJlcn0pLGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTphKHt9LGZbXCJkZWZhdWx0XCJdLmRlZmF1bHRQcm9wcyx7Y2xhc3NOYW1lOlwib2Zmc2V0LWFyZWEtY2hhcnRcIixhcmVhQ2hhcnREYXRhOltdLGNoYXJ0U3BhY2luZzo0LGNvbG9yUGFsZXR0ZTpudWxsLHNlbGVjdGVkQ2hhcnRJZDpudWxsLGNoYXJ0SWRBY2Nlc3NvcjpudWxsLG1ldGFkYXRhQWNjZXNzb3I6bnVsbCxpbnRlcnBvbGF0ZTpcImJhc2lzXCIsY2lyY2xlUmFkaXVzOjJ9KSxlbnVtZXJhYmxlOiEwfV0pLGV9KGZbXCJkZWZhdWx0XCJdKTtlW1wiZGVmYXVsdFwiXT12LHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9bigxMyksbD1hKHUpLGM9big3KSxwPWEoYyksZj1uKDE4KSxoPShhKGYpLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oZSx0KSxpKGUsW3trZXk6XCJ3aWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsZT10LnhBY2Nlc3NvcixuPXQueUFjY2Vzc29yLHI9dC54U2NhbGUsbz10LnlTY2FsZSxpPXQuaW50ZXJwb2xhdGU7dGhpcy5hcmVhR2VuZXJhdG9yPXBbXCJkZWZhdWx0XCJdLnN2Zy5hcmVhKCkuaW50ZXJwb2xhdGUoaSkueChmdW5jdGlvbih0KXtyZXR1cm4gcihlKHQpKX0pLnkwKGZ1bmN0aW9uKHQpe3JldHVybiBvKDApfSkueTEoZnVuY3Rpb24odCl7cmV0dXJuIG8obih0KSl9KX19LHtrZXk6XCJvbk1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJvbk1vdW50XCIsdGhpcykuY2FsbCh0aGlzKSx0aGlzLmxpbmVMYXllcj10aGlzLmJhc2UuYXBwZW5kKFwiZ1wiKS5jbGFzc2VkKFwib2Zmc2V0LWFyZWEtbGluZXNcIiwhMCksdGhpcy5fcmVuZGVyKCl9fSx7a2V5OlwicHJlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC54U2NhbGUsbj10LnlTY2FsZSxyPSh0LnhBY2Nlc3Nvcix0LnlBY2Nlc3Nvcix0LmFyZWFDaGFydENvbmZpZyksbz10LmludGVycG9sYXRlLGk9dGhpcy5oZWlnaHQtdGhpcy5wcm9wcy5hcmVhQ2hhcnREYXRhLmxlbmd0aCp0aGlzLnByb3BzLmNoYXJ0U3BhY2luZztlLnJhbmdlKFswLHRoaXMud2lkdGhdKSxuLnJhbmdlKFtpLDBdKSx0aGlzLmFyZWFHZW5lcmF0b3I9cFtcImRlZmF1bHRcIl0uc3ZnLmFyZWEoKS5pbnRlcnBvbGF0ZShvKS54KGZ1bmN0aW9uKHQpe3JldHVybiBlKHIueEFjY2Vzc29yKHQpKX0pLnkwKGZ1bmN0aW9uKHQpe3JldHVybiBuKDApfSkueTEoZnVuY3Rpb24odCl7cmV0dXJuIG4oci55QWNjZXNzb3IodCkpfSl9fSx7a2V5OlwiYXJlYU9mZnNldFRyYW5zbGF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9wcy5jaGFydFNwYWNpbmc7cmV0dXJuXCJ0cmFuc2xhdGUoMCxcIitlKnQrXCIpXCJ9fSx7a2V5OlwibGluZU9mZnNldFRyYW5zbGF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9wcyxuPWUuZGF0YSxyPWUuY2hhcnRTcGFjaW5nLG89ZS55U2NhbGUsaT0obygwKSxuLmxlbmd0aC10KSxzPS1yKmk7cmV0dXJuXCJ0cmFuc2xhdGUoMCxcIitzK1wiKVwifX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMucHJvcHMsbj1lLmRhdGEscj1lLnhBY2Nlc3NvcixvPShlLnlBY2Nlc3NvcixlLnhTY2FsZSksaT1lLnlTY2FsZSxzPShlLmZpbGxDb2xvcixlLmZpbGxPcGFjaXR5LGUuYXJlYUNoYXJ0RGF0YSksYT1lLmNvbG9yUGFsZXR0ZSx1PWUubWV0YWRhdGFBY2Nlc3NvcixsPWUuY2hhcnRJZEFjY2Vzc29yLGM9ZS5zZWxlY3RlZENoYXJ0SWQscD1lLmNpcmNsZVJhZGl1cyxmPShlLmludGVyYWN0aXZlLHRoaXMuYmFzZS5zZWxlY3RBbGwoXCJnLmFyZWEtY29udGFpbmVyXCIpLmRhdGEocykpO2YuZXhpdCgpLnJlbW92ZSgpLGYuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLFwiYXJlYS1jb250YWluZXJcIikuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIixcImFyZWFcIiksZi5hdHRyKFwidHJhbnNmb3JtXCIsZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5hcmVhT2Zmc2V0VHJhbnNsYXRpb24obil9KS5jbGFzc2VkKFwic2VsZWN0ZWRcIixmdW5jdGlvbih0KXtyZXR1cm4gbCh0KT09PWM/ITA6ITF9KS5zZWxlY3RBbGwoXCJwYXRoXCIpLmF0dHIoXCJkXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXJlYUdlbmVyYXRvcihlKX0pLmF0dHIoXCJmaWxsXCIsZnVuY3Rpb24odCxlLG4pe3JldHVybiBhW24lYS5sZW5ndGhdfSk7dmFyIGg9aSgwKSt0aGlzLnByb3BzLmFyZWFDaGFydERhdGEubGVuZ3RoKnRoaXMucHJvcHMuY2hhcnRTcGFjaW5nLGQ9by5kb21haW4oKTt0aGlzLmxpbmVMYXllci5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoMCwgXCIraCtcIilcIik7dmFyIHk9dGhpcy5saW5lTGF5ZXIuc2VsZWN0QWxsKFwiZy5saW5lLWdyb3VwXCIpLmRhdGEobik7eS5leGl0KCkucmVtb3ZlKCkseS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJsaW5lLWdyb3VwXCIpLmFwcGVuZChcImxpbmVcIikuYXR0cihcImNsYXNzXCIsXCJsaWZlc3BhblwiKSx5LmF0dHIoXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbihlLG4pe3JldHVybiB0LmxpbmVPZmZzZXRUcmFuc2xhdGlvbihuKX0pLmNsYXNzZWQoXCJzZWxlY3RlZFwiLGZ1bmN0aW9uKHQpe3JldHVybiBsKHQpPT1jPyEwOiExfSkuc2VsZWN0QWxsKFwibGluZVwiKS5hdHRyKFwieDFcIixmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLm1heChyKHQsMCksZFswXSkpfSkuYXR0cihcIngyXCIsZnVuY3Rpb24odCl7cmV0dXJuIG8oTWF0aC5taW4ocih0LDEpLGRbMV0pKX0pLmF0dHIoXCJ5MVwiLDApLmF0dHIoXCJ5MlwiLDApLnN0eWxlKFwic3Ryb2tlXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gYVtlJWEubGVuZ3RoXX0pO3ZhciB2PXkuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLmRhdGEoZnVuY3Rpb24odCl7cmV0dXJuIHUodCl9KTt2LmV4aXQoKS5yZW1vdmUoKSx2LmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpLHYuYXR0cihcImN4XCIsZnVuY3Rpb24odCl7cmV0dXJuIG8oTWF0aC5tYXgodCxkWzBdKSl9KS5hdHRyKFwiY3lcIiwwKS5hdHRyKFwiclwiLHApLnN0eWxlKFwiZmlsbFwiLGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gYVtuJWEubGVuZ3RoXX0pfX0se2tleTpcInBvc3RSZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319XSksZX0obFtcImRlZmF1bHRcIl0pKTtlW1wiZGVmYXVsdFwiXT1oLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNClbXCJkZWZhdWx0XCJdLG89big1KVtcImRlZmF1bHRcIl0saT1uKDMpW1wiZGVmYXVsdFwiXSxzPW4oMilbXCJkZWZhdWx0XCJdLGE9bigxMSlbXCJkZWZhdWx0XCJdLHU9bigxKVtcImRlZmF1bHRcIl0sbD1uKDQ4KVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGM9big2KSxwPXUoYyksZj1uKDcpLGg9bChmKTtuKDE1OSk7dmFyIGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCl9cmV0dXJuIG8oZSx0KSxpKGUsbnVsbCxbe2tleTpcInByb3BUeXBlc1wiLHZhbHVlOntkYXRhOmMuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsb25JdGVtQ2xpY2s6Yy5Qcm9wVHlwZXMuZnVuYyxsb2FkaW5nOmMuUHJvcFR5cGVzLmJvb2wsbm9EYXRhQXZhaWxhYmxlTXNnOmMuUHJvcFR5cGVzLnN0cmluZyxwdW5jaGNhcmRPcHRpb25zOmMuUHJvcFR5cGVzLm9iamVjdCxzZWxlY3RBY2Nlc3NvcjpjLlByb3BUeXBlcy5mdW5jLHRleHRWYWx1ZUZvcm1hdHRlcjpjLlByb3BUeXBlcy5mdW5jLGhlYWRlck1hcmdpbjpjLlByb3BUeXBlcy5udW1iZXJ9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7ZGF0YTpbXSxvbkl0ZW1DbGljazpudWxsLGxvYWRpbmc6ITAsbm9EYXRhQXZhaWxhYmxlTXNnOlwiTm8gY29tbW9kaXRpZXMgZGF0YSBhdmFpbGFibGUgZm9yIHRoaXMgY2FuYWwgaW4gdGhlIHNlbGVjdGVkIHllYXIuXCIscmFkaXVzRXh0ZW50OlsyLDEwXSx0ZXh0VmFsdWVGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGhlYWRlck1hcmdpbjowfSxlbnVtZXJhYmxlOiEwfV0pLGkoZSxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnJlbmRlclZpc3VhbGl6YXRpb24oKX19LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3kuZGVzdHJveSh0aGlzLnJlZnMuY29udGVudCksdGhpcy5yZW5kZXJWaXN1YWxpemF0aW9uKCl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3kuZGVzdHJveSh0aGlzLnJlZnMuY29udGVudCl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gcFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJwYW5vcmFtYSBwdW5jaGNhcmRcIn0sdGhpcy5yZW5kZXJQbGFjZWhvbGRlcigpLHBbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiY29udGVudFwiLHJlZjpcImNvbnRlbnRcIixzdHlsZTp7bWFyZ2luVG9wOnRoaXMucHJvcHMuaGVhZGVyTWFyZ2luK1wicHhcIn19KSl9fSx7a2V5OlwicmVuZGVyVmlzdWFsaXphdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7IXRoaXMuaXNFbXB0eSh0aGlzLnByb3BzLmRhdGEpJiZ0aGlzLnJlZnMuY29udGVudCYmeS51cGRhdGUodGhpcy5yZWZzLmNvbnRlbnQsYSh7fSx0aGlzLnByb3BzKSl9fSx7a2V5OlwicmVuZGVyUGxhY2Vob2xkZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsZT10LmxvYWRpbmcsbj10Lm5vRGF0YUF2YWlsYWJsZU1zZztyZXR1cm4gZT9wW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInBsYWNlaG9sZGVyXCIscmVmOlwicGxhY2Vob2xkZXJcIn0scFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImg0XCIsbnVsbCxcIkxvYWRpbmcuLi5cIikpOiF0aGlzLnByb3BzLmxvYWRpbmcmJnRoaXMuaXNFbXB0eSh0aGlzLnByb3BzLmRhdGEpP3BbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicGxhY2Vob2xkZXJcIixyZWY6XCJwbGFjZWhvbGRlclwifSxwW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiaDRcIixudWxsLG4pKTpudWxsfX0se2tleTpcImlzRW1wdHlcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg8MX19XSksZX0ocFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtlW1wiZGVmYXVsdFwiXT1kO3ZhciB5PXtfc2V0VGV4dFZhbHVlRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxzZXRUZXh0VmFsdWVGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7dGhpcy5fc2V0VGV4dFZhbHVlRm9ybWF0dGVyPXR9LFJPV19IRUlHSFQ6MjUsQ09NTU9ESVRZX1RFWFRfT0ZGU0VUX1k6NSx1cGRhdGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ZS5jb2xvclNjYWxlLG89ZS52YWx1ZUFjY2Vzc29yLGk9ZS5vbkl0ZW1DbGljayxzPWUudGV4dFZhbHVlRm9ybWF0dGVyLGE9ZS5zZWxlY3RlZCx1PWUuc2VsZWN0QWNjZXNzb3I7XCJmdW5jdGlvblwiPT10eXBlb2YgcyYmdGhpcy5zZXRUZXh0VmFsdWVGb3JtYXR0ZXIocyk7dmFyIGw9ZS5yYWRpdXNFeHRlbnRbMV0sYz10aGlzLHA9aC5zY2FsZS5zcXJ0KCkucmFuZ2UoZS5yYWRpdXNFeHRlbnQpLmRvbWFpbihbMSxlLnJhZGl1c01heFZhbHVlXSksZj1wLmRvbWFpbigpLGQ9ZlswXStNYXRoLnNxcnQoLjI1KSooZlsxXS1mWzBdKSx5PWguc2VsZWN0KHQpLnNlbGVjdEFsbChcImRpdlwiKS5kYXRhKGUuZGF0YSkuZW50ZXIoKS5hcHBlbmQoXCJkaXZcIikuYXR0cihcInN0eWxlXCIsZnVuY3Rpb24odCl7cmV0dXJuXCJjb2xvcjogXCIrcihlLmNvbG9yQWNjZXNzb3IodCkpK1wiO1wifSkuYXR0cihcImNsYXNzXCIsXCJjYXRlZ29yeVwiKTt5LmFwcGVuZChcImg0XCIpLnRleHQoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLHk9eS5hcHBlbmQoXCJzdmdcIikuYXR0cihcImhlaWdodFwiLGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbW1vZGl0aWVzLmxlbmd0aCpjLlJPV19IRUlHSFR9KS5zdHlsZShcInN0cm9rZVwiLGZ1bmN0aW9uKHQpe3JldHVybiByKGUuY29sb3JBY2Nlc3Nvcih0KSl9KS5zdHlsZShcImZpbGxcIixmdW5jdGlvbih0KXtyZXR1cm4gcihlLmNvbG9yQWNjZXNzb3IodCkpfSksdGhpcy5jYXRlZ29yeU5vZGVXaWR0aD0oeS5ub2RlKCkub2Zmc2V0V2lkdGh8fHkubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKS0yLjUqdGhpcy5ST1dfSEVJR0hUO3ZhciB2PXkuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbW1vZGl0aWVzfSkuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO3YuY2xhc3NlZChcInNlbGVjdGVkXCIsZnVuY3Rpb24odCl7cmV0dXJuIHUodCk9PT1hfSksdi5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcInJcIixmdW5jdGlvbih0KXt2YXIgZT1vKHQpO3JldHVybiBlP3AoZSk6ZH0pLnN0eWxlKFwiZmlsbFwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKHQpP251bGw6XCJub25lXCJ9KS5zdHlsZShcInN0cm9rZVwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKHQpP1wibm9uZVwiOm51bGx9KS5zdHlsZShcInN0cm9rZS13aWR0aFwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKHQpP251bGw6Mn0pLHYuYXBwZW5kKFwidGV4dFwiKS50ZXh0KGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KS5zdHlsZShcInN0cm9rZVwiLFwibm9uZVwiKS5hdHRyKFwieFwiLDIqYy5ST1dfSEVJR0hUKS5hdHRyKFwieVwiLGMuQ09NTU9ESVRZX1RFWFRfT0ZGU0VUX1kpLmNhbGwodGhpcy53cmFwLHRoaXMuY2F0ZWdvcnlOb2RlV2lkdGgpO3ZhciBtPXZvaWQgMDt5LmVhY2goZnVuY3Rpb24odCxlKXtoLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJnXCIpLmVhY2goZnVuY3Rpb24odCxlKXtlfHwobT0wKTt2YXIgbj1oLnNlbGVjdCh0aGlzKTtuLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIisuNSpjLlJPV19IRUlHSFQrXCIsIFwiKyhlKy41K20pKmMuUk9XX0hFSUdIVCtcIilcIiksbSs9bi5zZWxlY3RBbGwoXCJ0c3BhblwiKS5zaXplKCktMX0pO3ZhciBuPWguc2VsZWN0KHRoaXMpO24uYXR0cihcImhlaWdodFwiLHBhcnNlRmxvYXQobi5hdHRyKFwiaGVpZ2h0XCIpKSttKmMuUk9XX0hFSUdIVCl9KSx2LmFwcGVuZChcInJlY3RcIikuYXR0cihcInhcIiwtbCkuYXR0cihcInlcIiwtbCkuYXR0cihcIndpZHRoXCIsdGhpcy5jYXRlZ29yeU5vZGVXaWR0aCsyLjUqdGhpcy5ST1dfSEVJR0hUKS5hdHRyKFwiaGVpZ2h0XCIsdGhpcy5ST1dfSEVJR0hUKS5vbihcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKHQsZSl7Yy5vbkl0ZW1Nb3VzZU92ZXIodGhpcyx0LGUpfSkub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKHQsZSl7Yy5vbkl0ZW1Nb3VzZU91dCh0aGlzLHQsZSl9KS5vbihcImNsaWNrXCIsZnVuY3Rpb24odCxlKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiZpLmNhbGwobix0LGUpfSl9LG9uSXRlbU1vdXNlT3ZlcjpmdW5jdGlvbih0LGUsbil7dmFyIHI9aC5zZWxlY3QodC5wYXJlbnROb2RlKTtyLnNlbGVjdChcInRleHRcIikudGV4dCgoZS5wcmV0dHlWYWx1ZXx8dGhpcy5fc2V0VGV4dFZhbHVlRm9ybWF0dGVyKGUudmFsdWUpKSsoZS51bml0cz9cIiBcIitlLnVuaXRzOlwiXCIpKS5zdHlsZShcImZvbnQtd2VpZ2h0XCIsNDAwKX0sb25JdGVtTW91c2VPdXQ6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWguc2VsZWN0KHQucGFyZW50Tm9kZSk7ci5zZWxlY3QoXCJ0ZXh0XCIpLnRleHQoZS5uYW1lKS5zdHlsZShcImZvbnQtd2VpZ2h0XCIsbnVsbCkuY2FsbCh0aGlzLndyYXAsdGhpcy5jYXRlZ29yeU5vZGVXaWR0aCl9LGRlc3Ryb3k6ZnVuY3Rpb24odCl7aC5zZWxlY3QodCkuaHRtbChcIlwiKX0sd3JhcDpmdW5jdGlvbih0LGUpe3QuZWFjaChmdW5jdGlvbigpe3ZhciB0PVtcIi9cIixcIiZcIl0sbj1oLnNlbGVjdCh0aGlzKSxyPW4udGV4dCgpLG89dm9pZCAwO3QuZm9yRWFjaChmdW5jdGlvbih0KXtyPXIucmVwbGFjZSh0LHQrXCIgXCIpfSk7Zm9yKHZhciBpPXIuc3BsaXQoL1xccysvKS5yZXZlcnNlKCkscz12b2lkIDAsYT1bXSx1PTAsbD0xLjEsYz1uLmF0dHIoXCJ4XCIpLHA9bi5hdHRyKFwieVwiKSxmPXBhcnNlRmxvYXQobi5hdHRyKFwiZHlcIil8fDApLGQ9bi50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsYykuYXR0cihcInlcIixwKS5hdHRyKFwiZHlcIixmK1wiZW1cIik7cz1pLnBvcCgpOylhLnB1c2gocyksZC50ZXh0KGEuam9pbihcIiBcIikpLGQubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpPmUmJihhLnBvcCgpLG89YS5qb2luKFwiIFwiKSx0LmZvckVhY2goZnVuY3Rpb24odCl7bz1vLnJlcGxhY2UodCtcIiBcIix0KX0pLGQudGV4dChvKSxhPVtzXSxkPW4uYXBwZW5kKFwidHNwYW5cIikuYXR0cihcInhcIixjKS5hdHRyKFwieVwiLHApLmF0dHIoXCJkeVwiLCsrdSpsK2YrXCJlbVwiKS50ZXh0KHMpKX0pfX07dC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDExKVtcImRlZmF1bHRcIl0sdT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1uKDcpLGM9dShsKSxwPW4oNiksZj1uKDE0KSxoPXUoZiksZD1uKDk0KSx5PXUoZCk7bigxNjApO3ZhciB2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuY2hhcnRDb25zdHJ1Y3Rvcj15W1wiZGVmYXVsdFwiXX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6YSh7fSxoW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXMse2RvdFJhZGl1c1NjYWxlOnAuUHJvcFR5cGVzLmZ1bmMsZG90UmFkaXVzOnAuUHJvcFR5cGVzLm51bWJlcixkb3RSYWRpdXNBY2Nlc3NvcjpwLlByb3BUeXBlcy5mdW5jLGRvdENvbG9yU2NhbGU6cC5Qcm9wVHlwZXMuZnVuYyxkb3RDb2xvckFjY2Vzc29yOnAuUHJvcFR5cGVzLmZ1bmN9KSxlbnVtZXJhYmxlOiEwfSx7a2V5OlwiZGVmYXVsdFByb3BzXCIsdmFsdWU6YSh7fSxoW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMse3hTY2FsZTpjW1wiZGVmYXVsdFwiXS5zY2FsZS5saW5lYXIoKSx5U2NhbGU6Y1tcImRlZmF1bHRcIl0uc2NhbGUubGluZWFyKCksY2xhc3NOYW1lOlwic2NhdHRlcnBsb3RcIixkb3RSYWRpdXM6Myx4YXhpczp7Y2xhc3NOYW1lOlwieCBheGlzXCIsb3JpZW50OlwiYm90dG9tXCIscG9zaXRpb246XCJib3R0b21cIixhdHRyOntkeDpcIjBcIixkeTpcIjAuNWVtXCJ9LHN0eWxlOntcInRleHQtYW5jaG9yXCI6XCJtaWRkbGVcIn19LHlheGlzOntjbGFzc05hbWU6XCJ5IGF4aXNcIixvcmllbnQ6XCJsZWZ0XCJ9fSksZW51bWVyYWJsZTohMH1dKSxlfShoW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09dix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oMTMpLGw9YSh1KSxjPW4oNykscD1hKGMpLGY9bigxOCksaD1hKGYpLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhlLHQpLGkoZSxbe2tleTpcIndpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy54YXhpcyYmdGhpcy5zZXRBeGlzKG5ldyBoW1wiZGVmYXVsdFwiXSh0aGlzLnByb3BzLnhheGlzLHRoaXMucHJvcHMueFNjYWxlKSksdGhpcy5wcm9wcy55YXhpcyYmdGhpcy5zZXRBeGlzKG5ldyBoW1wiZGVmYXVsdFwiXSh0aGlzLnByb3BzLnlheGlzLHRoaXMucHJvcHMueVNjYWxlKSl9fSx7a2V5Olwib25Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcIm9uTW91bnRcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5fcmVuZGVyKCl9fSx7a2V5OlwicHJlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLGU9dC5kYXRhLG49dC54QWNjZXNzb3Iscj10LnlBY2Nlc3NvcixvPXQueFNjYWxlLGk9dC55U2NhbGUscz10LmRvdFJhZGl1c1NjYWxlLGE9dC5kb3RSYWRpdXNBY2Nlc3NvcjtvLnJhbmdlKFswLHRoaXMud2lkdGhdKSxvLmRvbWFpbihwW1wiZGVmYXVsdFwiXS5leHRlbnQoZSxmdW5jdGlvbih0KXtyZXR1cm4gbih0KX0pKS5uaWNlKCksaS5yYW5nZShbdGhpcy5oZWlnaHQsMF0pLGkuZG9tYWluKHBbXCJkZWZhdWx0XCJdLmV4dGVudChlLGZ1bmN0aW9uKHQpe3JldHVybiByKHQpfSkpLm5pY2UoKSxzJiZhJiZzLmRvbWFpbihwW1wiZGVmYXVsdFwiXS5leHRlbnQoZSxmdW5jdGlvbih0KXtyZXR1cm4gYSh0KX0pKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsZT10LmRhdGEsbj10LnhBY2Nlc3NvcixyPXQueUFjY2Vzc29yLG89dC54U2NhbGUsaT10LnlTY2FsZSxzPXQuZG90UmFkaXVzLGE9dC5kb3RSYWRpdXNTY2FsZSx1PXQuZG90UmFkaXVzQWNjZXNzb3IsbD10LmRvdENvbG9yU2NhbGUsYz10LmRvdENvbG9yQWNjZXNzb3IscD10aGlzLmJhc2Uuc2VsZWN0QWxsKFwiLmRvdFwiKS5kYXRhKGUpO3AuZXhpdCgpLnJlbW92ZSgpLHAuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImNsYXNzXCIsXCJkb3RcIikscC5hdHRyKFwiclwiLGZ1bmN0aW9uKHQpe3JldHVybiBhfHx1P2EodSh0KSk6c30pLmF0dHIoXCJjeFwiLGZ1bmN0aW9uKHQpe3JldHVybiBvKG4odCkpfSkuYXR0cihcImN5XCIsZnVuY3Rpb24odCl7cmV0dXJuIGkocih0KSl9KS5zdHlsZShcImZpbGxcIixmdW5jdGlvbih0KXtyZXR1cm4gbCYmYz9sKGModCkpOlwibGltZVwifSl9fSx7a2V5OlwicG9zdFJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcyxlPXQuc2VsZWN0ZWQsbj10LnNlbGVjdGlvbkFjY2Vzc29yLHI9dC5pbnRlcmFjdGl2ZSxvPXRoaXMuYmFzZS5zZWxlY3RBbGwoXCIuZG90XCIpO3ImJm8ub24oXCJjbGlja1wiLHRoaXMuZGlzcGF0Y2guY2xpY2spLm9uKFwibW91c2VvdmVyXCIsdGhpcy5kaXNwYXRjaC5tb3VzZU92ZXIpLm9uKFwibW91c2VvdXRcIix0aGlzLmRpc3BhdGNoLm1vdXNlT3V0KSxlJiZvLmNsYXNzZWQoXCJzZWxlY3RlZFwiLGZ1bmN0aW9uKHQpe3JldHVybiBuKHQpPT09ZX0pfX1dKSxlfShsW1wiZGVmYXVsdFwiXSk7ZVtcImRlZmF1bHRcIl09ZCx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpW1wiZGVmYXVsdFwiXSxvPW4oNSlbXCJkZWZhdWx0XCJdLGk9bigzKVtcImRlZmF1bHRcIl0scz1uKDIpW1wiZGVmYXVsdFwiXSxhPW4oMSlbXCJkZWZhdWx0XCJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PW4oNiksbD1hKHUpLGM9bigzMCkscD1hKGMpLGY9big5NiksaD1hKGYpO24oMTYxKTt2YXIgZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ModGhpcyxlKSxyKE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJjb25zdHJ1Y3RvclwiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLnNlbGVjdGVkS2V5PW51bGwsdGhpcy5jdXJyZW50S2V5PW51bGwsdGhpcy5oYW5kbGVTY3JvbGw9dGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKSx0aGlzLm9uQ2xpY2tIYW5kbGVyPXRoaXMub25DbGlja0hhbmRsZXIuYmluZCh0aGlzKX1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e2l0ZW1zOnUuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsa2V5QWNjZXNzb3I6dS5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLHJlbmRlckl0ZW06dS5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLG9uSXRlbUNsaWNrZWQ6dS5Qcm9wVHlwZXMuZnVuYyxzZWxlY3RlZDp1LlByb3BUeXBlcy5zdHJpbmcsaGVpZ2h0OnUuUHJvcFR5cGVzLmFueSxpc0l0ZW1EaXJ0eTp1LlByb3BUeXBlcy5mdW5jLG9uU3RvcnlTY3JvbGw6dS5Qcm9wVHlwZXMuZnVuYyxzZW5zaXRpdml0eTp1LlByb3BUeXBlcy5udW1iZXJ9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7c2VsZWN0ZWQ6bnVsbCxoZWlnaHQ6NDAwLHNlbnNpdGl2aXR5OjMwfSxlbnVtZXJhYmxlOiEwfV0pLGkoZSxbe2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmxpc3RDb250YWluZXI9cFtcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcy5yZWZzLmxpc3QpLHRoaXMubGlzdENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5oYW5kbGVTY3JvbGwsITEpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmxpc3RDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuaGFuZGxlU2Nyb2xsKX19LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMuc2VsZWN0ZWQ7dGhpcy5idWlsZEl0ZW1DYWNoZSgpLHRoaXMuYW5jaG9ycy5sZW5ndGgmJnQhPT10aGlzLnNlbGVjdGVkS2V5JiYodGhpcy5zZWxlY3RlZEtleT10LHRoaXMuc2V0U2Nyb2xsUG9zaXRpb24oKSl9fSx7a2V5OlwiYnVpbGRJdGVtQ2FjaGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5hbmNob3JzPVtdLHRoaXMuYW5jaG9yTWFwPXt9O3ZhciBlPXRoaXMubGlzdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnRleHR1cmFsLWxpc3QtLWl0ZW1cIik7W10uZm9yRWFjaC5jYWxsKGUsZnVuY3Rpb24oZSl7dmFyIG49e3Q6ZS5vZmZzZXRUb3Asa2V5OmUuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKX07dC5hbmNob3JNYXBbbi5rZXldPWUsdC5hbmNob3JzLnB1c2gobil9KX19LHtrZXk6XCJzZXRTY3JvbGxQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5zZWxlY3RlZEtleSYmdGhpcy5saXN0Q29udGFpbmVyKXt2YXIgdD10aGlzLnNlbGVjdGVkS2V5IGluIHRoaXMuYW5jaG9yTWFwP3RoaXMuYW5jaG9yTWFwW3RoaXMuc2VsZWN0ZWRLZXldLm9mZnNldFRvcDpudWxsO3QmJih0aGlzLmxpc3RDb250YWluZXIuc2Nyb2xsVG9wPXQpfX19LHtrZXk6XCJoYW5kbGVTY3JvbGxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLnByb3BzLG49ZS5vblN0b3J5U2Nyb2xsLHI9ZS5zZW5zaXRpdml0eSxvPXRoaXMubGlzdENvbnRhaW5lci5zY3JvbGxUb3AsaT10aGlzLmN1cnJlbnRLZXkscz10aGlzLmxpc3RDb250YWluZXIuc2Nyb2xsSGVpZ2h0LGE9dGhpcy5saXN0Q29udGFpbmVyLmNsaWVudEhlaWdodCx1PXZvaWQgMDt0aGlzLmFuY2hvcnMmJigwPj1vP3RoaXMuY3VycmVudEtleT10aGlzLmFuY2hvcnNbMF0ua2V5OnMtbz09PWE/dGhpcy5jdXJyZW50S2V5PXRoaXMuYW5jaG9yc1t0aGlzLmFuY2hvcnMubGVuZ3RoLTFdLmtleTp0aGlzLmFuY2hvcnMuZm9yRWFjaChmdW5jdGlvbihlKXt1PW8tZS50LHI+dSYmdT4tciYmdC5jdXJyZW50S2V5IT09ZS5rZXkmJih0LmN1cnJlbnRLZXk9ZS5rZXkpfSksaSE9PXRoaXMuY3VycmVudEtleSYmXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmbih0aGlzLmN1cnJlbnRLZXkpKX19LHtrZXk6XCJnZXRDbG9zZXN0SXRlbU5vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IoO3QmJnQhPT1kb2N1bWVudDt0PXQucGFyZW50Tm9kZSlpZih0LmNsYXNzTGlzdC5jb250YWlucyhcInRleHR1cmFsLWxpc3QtLWl0ZW1cIikpcmV0dXJuIHQ7cmV0dXJuITF9fSx7a2V5OlwiZ2V0RGF0YUl0ZW1Gb3JLZXlcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy5wcm9wcyxyPW4uaXRlbXMsbz1uLmtleUFjY2Vzc29yLGk9ci5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIGUuY29lcmNlS2V5KG8obikpPT09dH0pO3JldHVybiBpLmxlbmd0aD9pOm51bGx9fSx7a2V5Olwib25DbGlja0hhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb3BzLm9uSXRlbUNsaWNrZWQsbj10LnRhcmdldHx8bnVsbDtpZihuKXt2YXIgcj1uLmNsYXNzTGlzdC5jb250YWlucyhcInRleHR1cmFsLWxpc3QtLWl0ZW1cIik/bjp0aGlzLmdldENsb3Nlc3RJdGVtTm9kZShuKTtpZihyKXt2YXIgbz1yLmdldEF0dHJpYnV0ZShcImRhdGEtaWRcIik7aWYobyl7dmFyIGk9dGhpcy5nZXREYXRhSXRlbUZvcktleShvKTtpLmxlbmd0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZShpKX19fX19LHtrZXk6XCJyZW5kZXJJdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMucHJvcHMsbj1lLnJlbmRlckl0ZW0scj1lLml0ZW1zLG89ZS5rZXlBY2Nlc3NvcixpPWUuaXNJdGVtRGlydHkscz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBvPyEwOiExLGE9XCJmdW5jdGlvblwiPT10eXBlb2YgaT8hMDohMTtyZXR1cm4gci5tYXAoZnVuY3Rpb24oZSxyKXt2YXIgdT1hP2koZSk6ITAsYz1zP28oZSk6cjtyZXR1cm4gbFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChoW1wiZGVmYXVsdFwiXSx7a2V5OmMscmVuZGVySXRlbTpuLGluZGV4OnIsaWRlbnRpZmllcjp0LmNvZXJjZUtleShjKSxkaXJ0eTp1fSl9KX19LHtrZXk6XCJjb2VyY2VLZXlcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm5cIlwiK3R9fSx7a2V5OlwiaXNOdW1lcmljXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIWlzTmFOKHQpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wcy5oZWlnaHQsZT10aGlzLmlzTnVtZXJpYyh0KT97bWF4SGVpZ2h0OnR9Om51bGw7cmV0dXJuIGxbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicGFub3JhbWEgdGV4dHVyYWwtbGlzdFwifSxsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3JlZjpcImxpc3RcIixjbGFzc05hbWU6XCJ0ZXh0dXJhbC1saXN0LS1pbm5lclwiLHN0eWxlOmUsb25DbGljazp0aGlzLm9uQ2xpY2tIYW5kbGVyfSx0aGlzLnJlbmRlckl0ZW1zKCkpKX19XSksZX0odS5Db21wb25lbnQpO2VbXCJkZWZhdWx0XCJdPWQsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9YSh1KSxjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cyh0aGlzLGUpLHIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcImNvbnN0cnVjdG9yXCIsdGhpcykuY2FsbCh0aGlzLHQpfXJldHVybiBvKGUsdCksaShlLG51bGwsW3trZXk6XCJwcm9wVHlwZXNcIix2YWx1ZTp7cmVuZGVySXRlbTp1LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsaW5kZXg6dS5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsZGlydHk6dS5Qcm9wVHlwZXMuYm9vbCxpZGVudGlmaWVyOnUuUHJvcFR5cGVzLnN0cmluZ30sZW51bWVyYWJsZTohMH0se2tleTpcImRlZmF1bHRQcm9wc1wiLHZhbHVlOntkaXJ0eTohMH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJzaG91bGRDb21wb25lbnRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0LmRpcnR5fX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvcHMsZT10LnJlbmRlckl0ZW0sbj10LmluZGV4LHI9dC5pZGVudGlmaWVyO3JldHVybiBsW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInRleHR1cmFsLWxpc3QtLWl0ZW1cIixcImRhdGEtaWRcIjpyfSxlKG4pKX19XSksZX0odS5Db21wb25lbnQpO2VbXCJkZWZhdWx0XCJdPWMsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0KVtcImRlZmF1bHRcIl0sbz1uKDUpW1wiZGVmYXVsdFwiXSxpPW4oMylbXCJkZWZhdWx0XCJdLHM9bigyKVtcImRlZmF1bHRcIl0sYT1uKDEpW1wiZGVmYXVsdFwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1uKDYpLGw9bigyMiksYz1uKDcpLHA9YShjKTtuKDE2Mik7dmFyIGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSkscihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwiY29uc3RydWN0b3JcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5tYXA9bnVsbH1yZXR1cm4gbyhlLHQpLGkoZSxudWxsLFt7a2V5OlwicHJvcFR5cGVzXCIsdmFsdWU6e2ZlYXR1cmVzOnUuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLGN1cnJlbnREYXRlOnUuUHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSl9LGVudW1lcmFibGU6ITB9LHtrZXk6XCJkZWZhdWx0UHJvcHNcIix2YWx1ZTp7ZmVhdHVyZXM6e30sY3VycmVudERhdGU6bnVsbH0sZW51bWVyYWJsZTohMH1dKSxpKGUsW3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5tYXJrZXJzPVtdLHRoaXMubWFwPXRoaXMucHJvcHMubWFwLHRoaXMuX2VsPUwuRG9tVXRpbC5jcmVhdGUoXCJkaXZcIixcInBhbm9yYW1hIHRpbWUtYmFzZWQtbWFya2Vycy1sYXllciBsZWFmbGV0LXpvb20taGlkZSBsZWFmbGV0LWQzLW92ZXJsYXlcIiksdGhpcy5tYXAuZ2V0UGFuZXMoKS5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9lbCksdGhpcy5zdmc9cFtcImRlZmF1bHRcIl0uc2VsZWN0KHRoaXMuX2VsKS5hcHBlbmQoXCJzdmdcIiksdGhpcy5jb250YWluZXI9dGhpcy5zdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIixcInBhbm9yYW1hIHRpbWUtYmFzZWQtbWFya2Vycy1jb250YWluZXJcIiksdGhpcy5zZXRPdmVybGF5UG9zaXRpb24oKSx0aGlzLm1hcC5vbihcInZpZXdyZXNldFwiLHRoaXMuX3Jlc2V0LHRoaXMpLHRoaXMuZGlydHkmJnRoaXMuZHJhdyh0aGlzLnByb3BzLmZlYXR1cmVzKX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5tYXAuZ2V0UGFuZXMoKS5vdmVybGF5UGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9lbCksdGhpcy5tYXAub2ZmKFwidmlld3Jlc2V0XCIsdGhpcy5fcmVzZXQsdGhpcyksdGhpcy5tYXJrZXJzPVtdLHRoaXMubGluZT1udWxsfX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnByb3BzLmZlYXR1cmVzJiZ0aGlzLnByb3BzLmZlYXR1cmVzLmZlYXR1cmVzLmxlbmd0aCYmIXRoaXMubG9hZGVkJiZ0aGlzLmRyYXcodGhpcy5wcm9wcy5mZWF0dXJlcyksdGhpcy5wcm9wcy5jdXJyZW50RGF0ZSE9PXRoaXMuY3VycmVudERhdGUmJih0aGlzLmN1cnJlbnREYXRlPXRoaXMucHJvcHMuY3VycmVudERhdGUsdGhpcy5maWx0ZXIoKSksc2V0VGltZW91dChmdW5jdGlvbigpe3QubWFwLmdldFBhbmVzKCkub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodC5fZWwpfSwxKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiExfX0se2tleTpcInNldE92ZXJsYXlQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tYXAuZ2V0Qm91bmRzKCksZT10aGlzLm1hcC5sYXRMbmdUb0xheWVyUG9pbnQodC5nZXROb3J0aFdlc3QoKSk7dGhpcy5tYXAubGF0TG5nVG9MYXllclBvaW50KHQuZ2V0U291dGhFYXN0KCkpO3RoaXMuc3ZnJiYocFtcImRlZmF1bHRcIl0uc2VsZWN0KHRoaXMuX2VsKS5zdHlsZShcIndpZHRoXCIsdGhpcy5tYXAuZ2V0U2l6ZSgpLngrXCJweFwiKS5zdHlsZShcImhlaWdodFwiLHRoaXMubWFwLmdldFNpemUoKS55K1wicHhcIikuc3R5bGUoXCJtYXJnaW4tbGVmdFwiLFwiMHB4XCIpLnN0eWxlKFwibWFyZ2luLXRvcFwiLFwiMHB4XCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIistZS54K1wiLFwiKy1lLnkrXCIpXCIpLHRoaXMuc3ZnLnN0eWxlKFwid2lkdGhcIix0aGlzLm1hcC5nZXRTaXplKCkueCtcInB4XCIpLnN0eWxlKFwiaGVpZ2h0XCIsdGhpcy5tYXAuZ2V0U2l6ZSgpLnkrXCJweFwiKSl9fSx7a2V5OlwiX3Jlc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNldE92ZXJsYXlQb3NpdGlvbigpLHRoaXMuZmlsdGVyKCksdGhpcy5wb3NpdGlvbigpfX0se2tleTpcImZpbHRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5tYXApe3ZhciB0PXRoaXMucHJvcHMuY3VycmVudERhdGV8fG51bGwsZT10aGlzLm1hcC5nZXRab29tKCksbj0hMTt0aGlzLm1hcmtlcnMuZm9yRWFjaChmdW5jdGlvbihyKXtyLnNob3c9XCJub25lXCIsdCYmZT49ci56b29tU3RhcnQmJmU8PXIuem9vbUVuZCYmKHIuc3RhcnQ/IXIuZW5kJiZ0Pj1yLnN0YXJ0PyhyLnNob3c9XCJibG9ja1wiLG49ITApOnQ+PXIuc3RhcnQmJnQ8PXIuZW5kJiYoci5zaG93PVwiYmxvY2tcIixuPSEwKTooci5zaG93PVwiYmxvY2tcIixuPSEwKSksci5lbG0uc3R5bGUoXCJkaXNwbGF5XCIsci5zaG93KX0pLG4mJnRoaXMucG9zaXRpb24oKX19fSx7a2V5OlwicG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMubWFya2VycyYmdGhpcy5tYXApe3ZhciB0PXRoaXM7dGhpcy5tYXJrZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoXCJub25lXCIhPT1lLnNob3cpe3ZhciBuO1wiaWNvblwiPT09ZS5tYXJrZXJUeXBlPyhuPXQubWFwLmxhdExuZ1RvTGF5ZXJQb2ludChlLmNvb3JkcyksZS5lbG0uYXR0cihcImN4XCIsbi54K1wicHhcIikuYXR0cihcImN5XCIsbi55K1wicHhcIikpOlwibGFiZWxcIj09PWUubWFya2VyVHlwZT8obj10Lm1hcC5sYXRMbmdUb0xheWVyUG9pbnQoZS5jb29yZHMpLGUuZWxtLmF0dHIoXCJ4XCIsbi54K1wicHhcIikuYXR0cihcInlcIixuLnkrXCJweFwiKSk6XCJsaW5lXCI9PT1lLm1hcmtlclR5cGUmJmUuZWxtLmF0dHIoXCJkXCIsdC5saW5lKGUuY29vcmRzKSl9fSl9fX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7cmV0dXJuIGkuY29udGFpbmVyLmFwcGVuZChcImNpcmNsZVwiKS5hdHRyKFwiY2xhc3NcIixcInRpbWUtYmFzZWQtXCIrW2UubWFwdHlwZSxlLnR5cGVdLmpvaW4oXCIgXCIpKS5hdHRyKFwiY3hcIix0LngrXCJweFwiKS5hdHRyKFwiY3lcIix0LnkrXCJweFwiKS5hdHRyKFwiclwiLDMpfWZ1bmN0aW9uIG4odCxlKXt2YXIgbj1cImxlZnRcIj09PWUuanVzdGlmeT9cInN0YXJ0XCI6XCJlbmRcIjtyZXR1cm4gaS5jb250YWluZXIuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIixcIndpdGgtb3V0bGluZXMgdGltZS1iYXNlZC1cIitbZS5tYXB0eXBlLGUudHlwZV0uam9pbihcIiBcIikpLmF0dHIoXCJ4XCIsdC54K1wicHhcIikuYXR0cihcInlcIix0LnkrXCJweFwiKS5hdHRyKFwidGV4dC1hbmNob3JcIixuKS50ZXh0KGUubG9jYXRpb24pfWZ1bmN0aW9uIHIodCxlKXtyZXR1cm4gaS5jb250YWluZXIuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIixcInRpbWUtYmFzZWQtXCIrW2UubWFwdHlwZSxlLnR5cGVdLmpvaW4oXCIgXCIpKS5hdHRyKFwiZFwiLGkubGluZSh0KSl9ZnVuY3Rpb24gbyhvKXt0LmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIHMsYSx1LGw9dC5wcm9wZXJ0aWVzLGM9dC5nZW9tZXRyeS50eXBlO2wubWFwdHlwZT09PW8mJihcImljb25cIj09PWwubWFwdHlwZT8ocz10Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLnJldmVyc2UoKSx1PWkubWFwLmxhdExuZ1RvTGF5ZXJQb2ludChzKSxhPWUodSxsKSk6XCJsYWJlbFwiPT09bC5tYXB0eXBlPyhzPXQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucmV2ZXJzZSgpLHU9aS5tYXAubGF0TG5nVG9MYXllclBvaW50KHMpLGE9bih1LGwpKTpcImxpbmVcIj09PWwubWFwdHlwZSYmKHM9dC5nZW9tZXRyeS5jb29yZGluYXRlcyxzLmZvckVhY2goZnVuY3Rpb24odCl7dC5yZXZlcnNlKCl9KSxhPXIocyxsKSksYT9pLm1hcmtlcnMucHVzaCh7ZWxtOmEsY29vcmRzOnMsZ2VvbWV0cnlUeXBlOmMsbWFya2VyVHlwZTpsLm1hcHR5cGV8fFwiXCIsc3RhcnQ6bC5zdGFydF95ZWFyP25ldyBEYXRlKGwuc3RhcnRfeWVhcik6bnVsbCxlbmQ6bC5lbmRfeWVhcj9uZXcgRGF0ZShsLmVuZF95ZWFyKTpudWxsLHpvb21TdGFydDpsLnN0YXJ0em9vbT8rbC5zdGFydHpvb206aS5tYXAubWluWm9vbSx6b29tRW5kOmwuZW5kem9vbT8rbC5lbmR6b29tOmkubWFwLm1heFpvb219KTpjb25zb2xlLmVycm9yKFwiVW5rbm93biBmZWF0dXJlOiBcIix0KSl9KX1pZih0JiYhdGhpcy5sb2FkZWQpe2lmKHRoaXMubG9hZGVkPSEwLCF0aGlzLm1hcClyZXR1cm4gdm9pZCh0aGlzLmRpcnR5PSEwKTt0aGlzLmRpcnR5PSExO3ZhciBpPXRoaXM7aWYodGhpcy5tYXJrZXJzLmxlbmd0aClyZXR1cm4gcG9zaXRpb24oKTt0aGlzLmxpbmU9cFtcImRlZmF1bHRcIl0uc3ZnLmxpbmUoKS54KGZ1bmN0aW9uKHQpe3JldHVybiBpLm1hcC5sYXRMbmdUb0xheWVyUG9pbnQodCkueH0pLnkoZnVuY3Rpb24odCl7cmV0dXJuIGkubWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0KS55fSkuaW50ZXJwb2xhdGUoXCJsaW5lYXJcIiksdGhpcy5tYXJrZXJzPVtdLG8oXCJsYWJlbFwiKSxvKFwibGluZVwiKSxvKFwiaWNvblwiKSx0aGlzLmZpbHRlcigpfX19XSksZX0obC5NYXBMYXllcik7ZVtcImRlZmF1bHRcIl09Zix0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDMpW1wiZGVmYXVsdFwiXSxvPW4oMilbXCJkZWZhdWx0XCJdLGk9bigxMSlbXCJkZWZhdWx0XCJdLHM9bigxKVtcImRlZmF1bHRcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9big3KSx1PXMoYSksbD1uKDMyKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLG4pe28odGhpcyx0KSx0aGlzLl9vcHRpb25zPWkoe30sbC50b29sdGlwRGVmYXVsdE9wdGlvbnMsbiksdGhpcy5fZWxlbWVudD11W1wiZGVmYXVsdFwiXS5zZWxlY3QoZSksdGhpcy5jbG9zZVRpbWVyPW51bGx9cmV0dXJuIHIodCxbe2tleTpcInVuTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX29wdGlvbnM9e30sdGhpcy5fZWxlbWVudD1udWxsLHRoaXMuX3JlbGF0aXZlQ29udGFpbmVyPW51bGwsdGhpcy5jbG9zZVRpbWVyJiYoY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lciksdGhpcy5jbG9zZVRpbWVyPW51bGwpfX0se2tleTpcInNldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodGhpcy5pc1Nob3dpbmcpe3ZhciBlPXRoaXMuY2FsY1Bvc2l0aW9uKHQpO3RoaXMuZWxlbWVudC5zdHlsZShcImxlZnRcIixlWzBdK1wicHhcIikuc3R5bGUoXCJ0b3BcIixlWzFdK1wicHhcIil9fX0se2tleTpcImNhbGNQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucyxuPWUub2Zmc2V0LHI9ZS5hbGlnbixvPXIuc3BsaXQoXCIgXCIpLGk9dGhpcy5lbGVtZW50Lm5vZGUoKS5vZmZzZXRXaWR0aCxzPXRoaXMuZWxlbWVudC5ub2RlKCkub2Zmc2V0SGVpZ2h0LGE9dGhpcy5yZWxhdGl2ZUNvbnRhaW5lcnx8dC50YXJnZXR8fHQuc3JjRWxlbWVudCx1PWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbD10LmNsaWVudFgtdS5sZWZ0LGM9dC5jbGllbnRZLXUudG9wO3N3aXRjaChvWzBdKXtjYXNlXCJ0b3BcIjpjLT1zLW5bMV07YnJlYWs7Y2FzZVwiYm90dG9tXCI6ZGVmYXVsdDpjLT1uWzFdfXN3aXRjaChvWzFdKXtjYXNlXCJjZW50ZXJcIjpsLT1pLzIrblswXTticmVhaztjYXNlXCJyaWdodFwiOmwtPWkrblswXTticmVhaztjYXNlXCJsZWZ0XCI6ZGVmYXVsdDpsKz1uWzBdfXJldHVybltsLGNdfX0se2tleTpcInNldENvbnRlbnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMub25TZXRUb29sdGlwQ29udGVudD90aGlzLm9wdGlvbnMub25TZXRUb29sdGlwQ29udGVudCh0aGlzLmVsZW1lbnQsdCk6dGhpcy5lbGVtZW50LnRleHQoXCJcIiksdGhpc319LHtrZXk6XCJzaG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5pc1Nob3dpbmc/dm9pZCAwOih0aGlzLmlzU2hvd2luZz0hMCx0aGlzLmVsZW1lbnQuY2xhc3NlZChcImFjdGl2ZVwiLCEwKSx0JiZ0aGlzLnNldFBvc2l0aW9uKHQpLGUmJnRoaXMuc2V0Q29udGVudChlKSx0aGlzKX19LHtrZXk6XCJoaWRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0aGlzLmlzU2hvd2luZylyZXR1cm4gdGhpcy5jbG9zZVRpbWVyJiYoY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lciksdGhpcy5jbG9zZVRpbWVyPW51bGwpLHRoaXMuaXNTaG93aW5nPSExLHR8fHRoaXMub3B0aW9ucy5jbG9zZURlbGF5PDE/dGhpcy5zZXRBY3RpdmVUb0ZhbHNlKCk6dGhpcy5jbG9zZVRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmlzU2hvd2luZ3x8ZS5zZXRBY3RpdmVUb0ZhbHNlKCl9LHRoaXMub3B0aW9ucy5jbG9zZURlbGF5KSx0aGlzfX0se2tleTpcInNldEFjdGl2ZVRvRmFsc2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2xvc2VUaW1lcj1udWxsLHRoaXMuZWxlbWVudC5jbGFzc2VkKFwiYWN0aXZlXCIsITEpfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cIlRvb2x0aXBcIn19LHtrZXk6XCJlbGVtZW50XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VsZW1lbnR9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9lbGVtZW50PXVbXCJkZWZhdWx0XCJdLnNlbGVjdCh0KX19LHtrZXk6XCJvcHRpb25zXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX29wdGlvbnN9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9vcHRpb25zPWkoe30sdGhpcy5vcHRpb25zLHtvYmo6dH0pfX0se2tleTpcInJlbGF0aXZlQ29udGFpbmVyXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbGF0aXZlQ29udGFpbmVyfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fcmVsYXRpdmVDb250YWluZXI9dC5ub2RlP3Qubm9kZSgpOnR9fV0pLHR9KCk7ZVtcImRlZmF1bHRcIl09Yyx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTA4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigxMDkpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDExMSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTEyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigxMTMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDExNCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTE1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigxMTYpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big5OSlbXCJkZWZhdWx0XCJdLG89bigxMDApW1wiZGVmYXVsdFwiXTtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgbj1bXSxvPSEwLGk9ITEscz12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PXIodCk7IShvPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtvPSEwKTt9Y2F0Y2gobCl7aT0hMCxzPWx9ZmluYWxseXt0cnl7IW8mJnVbXCJyZXR1cm5cIl0mJnVbXCJyZXR1cm5cIl0oKX1maW5hbGx5e2lmKGkpdGhyb3cgc319cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKGUsbil7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZTtpZihvKE9iamVjdChlKSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksZS5fX2VzTW9kdWxlPSEwfSxmdW5jdGlvbih0LGUsbil7big0Miksbig0MSksdC5leHBvcnRzPW4oMTM5KX0sZnVuY3Rpb24odCxlLG4pe24oNDIpLG4oNDEpLHQuZXhwb3J0cz1uKDE0MCl9LGZ1bmN0aW9uKHQsZSxuKXtuKDE0MiksdC5leHBvcnRzPW4oOCkuT2JqZWN0LmFzc2lnbn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuY3JlYXRlKHQsZSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big5KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3JldHVybiByLnNldERlc2ModCxlLG4pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOSk7bigxNDMpLHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiByLmdldERlc2ModCxlKX19LGZ1bmN0aW9uKHQsZSxuKXtuKDE0NCksdC5leHBvcnRzPW4oOCkuT2JqZWN0LmtleXN9LGZ1bmN0aW9uKHQsZSxuKXtuKDE0NSksdC5leHBvcnRzPW4oOCkuT2JqZWN0LnNldFByb3RvdHlwZU9mfSxmdW5jdGlvbih0LGUsbil7bigxNDYpLG4oNDEpLG4oNDIpLG4oMTQ3KSx0LmV4cG9ydHM9big4KS5Qcm9taXNlfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbigpe319LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDI1KSxvPW4oMTIpLmRvY3VtZW50LGk9cihvKSYmcihvLmNyZWF0ZUVsZW1lbnQpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaT9vLmNyZWF0ZUVsZW1lbnQodCk6e319fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxOSksbz1uKDEyMyksaT1uKDEyMikscz1uKDE1KSxhPW4oMTM3KSx1PW4oNjApO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixsKXt2YXIgYyxwLGYsaD11KHQpLGQ9cihuLGwsZT8yOjEpLHk9MDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBoKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBpdGVyYWJsZSFcIik7aWYoaShoKSlmb3IoYz1hKHQubGVuZ3RoKTtjPnk7eSsrKWU/ZChzKHA9dFt5XSlbMF0scFsxXSk6ZCh0W3ldKTtlbHNlIGZvcihmPWguY2FsbCh0KTshKHA9Zi5uZXh0KCkpLmRvbmU7KW8oZixkLHAudmFsdWUsZSl9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPW4oMTIpLmRvY3VtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj12b2lkIDA9PT1uO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiByP3QoKTp0LmNhbGwobik7Y2FzZSAxOnJldHVybiByP3QoZVswXSk6dC5jYWxsKG4sZVswXSk7Y2FzZSAyOnJldHVybiByP3QoZVswXSxlWzFdKTp0LmNhbGwobixlWzBdLGVbMV0pO2Nhc2UgMzpyZXR1cm4gcj90KGVbMF0sZVsxXSxlWzJdKTp0LmNhbGwobixlWzBdLGVbMV0sZVsyXSk7Y2FzZSA0OnJldHVybiByP3QoZVswXSxlWzFdLGVbMl0sZVszXSk6dC5jYWxsKG4sZVswXSxlWzFdLGVbMl0sZVszXSl9cmV0dXJuIHQuYXBwbHkobixlKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE2KSxvPW4oMTApKFwiaXRlcmF0b3JcIiksaT1BcnJheS5wcm90b3R5cGU7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10JiYoci5BcnJheT09PXR8fGlbb109PT10KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE1KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4sbyl7dHJ5e3JldHVybiBvP2UocihuKVswXSxuWzFdKTplKG4pfWNhdGNoKGkpe3ZhciBzPXRbXCJyZXR1cm5cIl07dGhyb3cgdm9pZCAwIT09cyYmcihzLmNhbGwodCkpLGl9fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oOSksbz1uKDU0KSxpPW4oNDApLHM9e307bigzOSkocyxuKDEwKShcIml0ZXJhdG9yXCIpLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSx0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlPXIuY3JlYXRlKHMse25leHQ6bygxLG4pfSksaSh0LGUrXCIgSXRlcmF0b3JcIil9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMCkoXCJpdGVyYXRvclwiKSxvPSExO3RyeXt2YXIgaT1bN11bcl0oKTtpW1wicmV0dXJuXCJdPWZ1bmN0aW9uKCl7bz0hMH0sQXJyYXkuZnJvbShpLGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoKHMpe310LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZighZSYmIW8pcmV0dXJuITE7dmFyIG49ITE7dHJ5e3ZhciBpPVs3XSxzPWlbcl0oKTtzLm5leHQ9ZnVuY3Rpb24oKXtuPSEwfSxpW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHN9LHQoaSl9Y2F0Y2goYSl7fXJldHVybiBufX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57dmFsdWU6ZSxkb25lOiEhdH19fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxpLHM9bigxMiksYT1uKDEzNikuc2V0LHU9cy5NdXRhdGlvbk9ic2VydmVyfHxzLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsbD1zLnByb2Nlc3MsYz1zLlByb21pc2UscD1cInByb2Nlc3NcIj09bigyNCkobCksZj1mdW5jdGlvbigpe1xudmFyIHQsZSxuO2ZvcihwJiYodD1sLmRvbWFpbikmJihsLmRvbWFpbj1udWxsLHQuZXhpdCgpKTtyOyllPXIuZG9tYWluLG49ci5mbixlJiZlLmVudGVyKCksbigpLGUmJmUuZXhpdCgpLHI9ci5uZXh0O289dm9pZCAwLHQmJnQuZW50ZXIoKX07aWYocClpPWZ1bmN0aW9uKCl7bC5uZXh0VGljayhmKX07ZWxzZSBpZih1KXt2YXIgaD0xLGQ9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7bmV3IHUoZikub2JzZXJ2ZShkLHtjaGFyYWN0ZXJEYXRhOiEwfSksaT1mdW5jdGlvbigpe2QuZGF0YT1oPS1ofX1lbHNlIGk9YyYmYy5yZXNvbHZlP2Z1bmN0aW9uKCl7Yy5yZXNvbHZlKCkudGhlbihmKX06ZnVuY3Rpb24oKXthLmNhbGwocyxmKX07dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXtmbjp0LG5leHQ6dm9pZCAwLGRvbWFpbjpwJiZsLmRvbWFpbn07byYmKG8ubmV4dD1lKSxyfHwocj1lLGkoKSksbz1lfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOSksbz1uKDU5KSxpPW4oNTApO3QuZXhwb3J0cz1uKDM4KShmdW5jdGlvbigpe3ZhciB0PU9iamVjdC5hc3NpZ24sZT17fSxuPXt9LHI9U3ltYm9sKCksbz1cImFiY2RlZmdoaWprbG1ub3BxcnN0XCI7cmV0dXJuIGVbcl09NyxvLnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24odCl7blt0XT10fSksNyE9dCh7fSxlKVtyXXx8T2JqZWN0LmtleXModCh7fSxuKSkuam9pbihcIlwiKSE9b30pP2Z1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW8odCkscz1hcmd1bWVudHMsYT1zLmxlbmd0aCx1PTEsbD1yLmdldEtleXMsYz1yLmdldFN5bWJvbHMscD1yLmlzRW51bTthPnU7KWZvcih2YXIgZixoPWkoc1t1KytdKSxkPWM/bChoKS5jb25jYXQoYyhoKSk6bChoKSx5PWQubGVuZ3RoLHY9MDt5PnY7KXAuY2FsbChoLGY9ZFt2KytdKSYmKG5bZl09aFtmXSk7cmV0dXJuIG59Ok9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDU1KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSlyKHQsbixlW25dKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPU9iamVjdC5pc3x8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MCE9PXR8fDEvdD09PTEvZTp0IT10JiZlIT1lfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oOCksbz1uKDkpLGk9bigzNykscz1uKDEwKShcInNwZWNpZXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXJbdF07aSYmZSYmIWVbc10mJm8uc2V0RGVzYyhlLHMse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEyKSxvPVwiX19jb3JlLWpzX3NoYXJlZF9fXCIsaT1yW29dfHwocltvXT17fSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpW3RdfHwoaVt0XT17fSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNSksbz1uKDM0KSxpPW4oMTApKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgbixzPXIodCkuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PXN8fHZvaWQgMD09KG49cihzKVtpXSk/ZTpvKG4pfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IFR5cGVFcnJvcihuK1wiOiB1c2UgdGhlICduZXcnIG9wZXJhdG9yIVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDU3KSxvPW4oMzYpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXt2YXIgaSxzLGE9U3RyaW5nKG8oZSkpLHU9cihuKSxsPWEubGVuZ3RoO3JldHVybiAwPnV8fHU+PWw/dD9cIlwiOnZvaWQgMDooaT1hLmNoYXJDb2RlQXQodSksNTUyOTY+aXx8aT41NjMxOXx8dSsxPT09bHx8KHM9YS5jaGFyQ29kZUF0KHUrMSkpPDU2MzIwfHxzPjU3MzQzP3Q/YS5jaGFyQXQodSk6aTp0P2Euc2xpY2UodSx1KzIpOihpLTU1Mjk2PDwxMCkrKHMtNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxpLHM9bigxOSksYT1uKDEyMSksdT1uKDEyMCksbD1uKDExOCksYz1uKDEyKSxwPWMucHJvY2VzcyxmPWMuc2V0SW1tZWRpYXRlLGg9Yy5jbGVhckltbWVkaWF0ZSxkPWMuTWVzc2FnZUNoYW5uZWwseT0wLHY9e30sbT1cIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGc9ZnVuY3Rpb24oKXt2YXIgdD0rdGhpcztpZih2Lmhhc093blByb3BlcnR5KHQpKXt2YXIgZT12W3RdO2RlbGV0ZSB2W3RdLGUoKX19LHg9ZnVuY3Rpb24odCl7Zy5jYWxsKHQuZGF0YSl9O2YmJmh8fChmPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTE7YXJndW1lbnRzLmxlbmd0aD5uOyllLnB1c2goYXJndW1lbnRzW24rK10pO3JldHVybiB2WysreV09ZnVuY3Rpb24oKXthKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpGdW5jdGlvbih0KSxlKX0scih5KSx5fSxoPWZ1bmN0aW9uKHQpe2RlbGV0ZSB2W3RdfSxcInByb2Nlc3NcIj09bigyNCkocCk/cj1mdW5jdGlvbih0KXtwLm5leHRUaWNrKHMoZyx0LDEpKX06ZD8obz1uZXcgZCxpPW8ucG9ydDIsby5wb3J0MS5vbm1lc3NhZ2U9eCxyPXMoaS5wb3N0TWVzc2FnZSxpLDEpKTpjLmFkZEV2ZW50TGlzdGVuZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIHBvc3RNZXNzYWdlJiYhYy5pbXBvcnRTY3JpcHRzPyhyPWZ1bmN0aW9uKHQpe2MucG9zdE1lc3NhZ2UodCtcIlwiLFwiKlwiKX0sYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHgsITEpKTpyPW0gaW4gbChcInNjcmlwdFwiKT9mdW5jdGlvbih0KXt1LmFwcGVuZENoaWxkKGwoXCJzY3JpcHRcIikpW21dPWZ1bmN0aW9uKCl7dS5yZW1vdmVDaGlsZCh0aGlzKSxnLmNhbGwodCl9fTpmdW5jdGlvbih0KXtzZXRUaW1lb3V0KHMoZyx0LDEpLDApfSksdC5leHBvcnRzPXtzZXQ6ZixjbGVhcjpofX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTcpLG89TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/byhyKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih0LGUpe3ZhciBuPTAscj1NYXRoLnJhbmRvbSgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIi5jb25jYXQodm9pZCAwPT09dD9cIlwiOnQsXCIpX1wiLCgrK24rcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE1KSxvPW4oNjApO3QuZXhwb3J0cz1uKDgpLmdldEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe3ZhciBlPW8odCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgaXRlcmFibGUhXCIpO3JldHVybiByKGUuY2FsbCh0KSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigzNSksbz1uKDEwKShcIml0ZXJhdG9yXCIpLGk9bigxNik7dC5leHBvcnRzPW4oOCkuaXNJdGVyYWJsZT1mdW5jdGlvbih0KXt2YXIgZT1PYmplY3QodCk7cmV0dXJuIHZvaWQgMCE9PWVbb118fFwiQEBpdGVyYXRvclwiaW4gZXx8aS5oYXNPd25Qcm9wZXJ0eShyKGUpKX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDExNyksbz1uKDEyNiksaT1uKDE2KSxzPW4oNTgpO3QuZXhwb3J0cz1uKDUxKShBcnJheSxcIkFycmF5XCIsZnVuY3Rpb24odCxlKXt0aGlzLl90PXModCksdGhpcy5faT0wLHRoaXMuX2s9ZX0sZnVuY3Rpb24oKXt2YXIgdD10aGlzLl90LGU9dGhpcy5fayxuPXRoaXMuX2krKztyZXR1cm4hdHx8bj49dC5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLG8oMSkpOlwia2V5c1wiPT1lP28oMCxuKTpcInZhbHVlc1wiPT1lP28oMCx0W25dKTpvKDAsW24sdFtuXV0pfSxcInZhbHVlc1wiKSxpLkFyZ3VtZW50cz1pLkFycmF5LHIoXCJrZXlzXCIpLHIoXCJ2YWx1ZXNcIikscihcImVudHJpZXNcIil9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDIwKTtyKHIuUytyLkYsXCJPYmplY3RcIix7YXNzaWduOm4oMTI4KX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1OCk7big1MykoXCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXtyZXR1cm4gdChyKGUpLG4pfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1OSk7big1MykoXCJrZXlzXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0KHIoZSkpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyMCk7cihyLlMsXCJPYmplY3RcIix7c2V0UHJvdG90eXBlT2Y6big1Nikuc2V0fSl9LGZ1bmN0aW9uKHQsZSl7fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsbz1uKDkpLGk9big1Mikscz1uKDEyKSxhPW4oMTkpLHU9bigzNSksbD1uKDIwKSxjPW4oMjUpLHA9bigxNSksZj1uKDM0KSxoPW4oMTM0KSxkPW4oMTE5KSx5PW4oNTYpLnNldCx2PW4oMTMwKSxtPW4oMTApKFwic3BlY2llc1wiKSxnPW4oMTMzKSx4PW4oMTI3KSxiPVwiUHJvbWlzZVwiLGs9cy5wcm9jZXNzLF89XCJwcm9jZXNzXCI9PXUoayksUD1zW2JdLFQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFAoZnVuY3Rpb24oKXt9KTtyZXR1cm4gdCYmKGUuY29uc3RydWN0b3I9T2JqZWN0KSxQLnJlc29sdmUoZSk9PT1lfSxPPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbj1uZXcgUChlKTtyZXR1cm4geShuLHQucHJvdG90eXBlKSxufXZhciBlPSExO3RyeXtpZihlPVAmJlAucmVzb2x2ZSYmVCgpLHkodCxQKSx0LnByb3RvdHlwZT1vLmNyZWF0ZShQLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnR9fSksdC5yZXNvbHZlKDUpLnRoZW4oZnVuY3Rpb24oKXt9KWluc3RhbmNlb2YgdHx8KGU9ITEpLGUmJm4oMzcpKXt2YXIgcj0hMTtQLnJlc29sdmUoby5zZXREZXNjKHt9LFwidGhlblwiLHtnZXQ6ZnVuY3Rpb24oKXtyPSEwfX0pKSxlPXJ9fWNhdGNoKGkpe2U9ITF9cmV0dXJuIGV9KCksdz1mdW5jdGlvbih0LGUpe3JldHVybiBpJiZ0PT09UCYmZT09PXI/ITA6dih0LGUpfSxNPWZ1bmN0aW9uKHQpe3ZhciBlPXAodClbbV07cmV0dXJuIHZvaWQgMCE9ZT9lOnR9LEU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGModCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mKGU9dC50aGVuKT9lOiExfSxDPWZ1bmN0aW9uKHQpe3ZhciBlLG47dGhpcy5wcm9taXNlPW5ldyB0KGZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ZXx8dm9pZCAwIT09bil0aHJvdyBUeXBlRXJyb3IoXCJCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvclwiKTtlPXQsbj1yfSksdGhpcy5yZXNvbHZlPWYoZSksdGhpcy5yZWplY3Q9ZihuKX0sUz1mdW5jdGlvbih0KXt0cnl7dCgpfWNhdGNoKGUpe3JldHVybntlcnJvcjplfX19LGo9ZnVuY3Rpb24odCxlKXtpZighdC5uKXt0Lm49ITA7dmFyIG49dC5jO3goZnVuY3Rpb24oKXtmb3IodmFyIHI9dC52LG89MT09dC5zLGk9MCxhPWZ1bmN0aW9uKGUpe3ZhciBuLGkscz1vP2Uub2s6ZS5mYWlsLGE9ZS5yZXNvbHZlLHU9ZS5yZWplY3Q7dHJ5e3M/KG98fCh0Lmg9ITApLG49cz09PSEwP3I6cyhyKSxuPT09ZS5wcm9taXNlP3UoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk6KGk9RShuKSk/aS5jYWxsKG4sYSx1KTphKG4pKTp1KHIpfWNhdGNoKGwpe3UobCl9fTtuLmxlbmd0aD5pOylhKG5baSsrXSk7bi5sZW5ndGg9MCx0Lm49ITEsZSYmc2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBlLG4sbz10LnA7QShvKSYmKF8/ay5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIscixvKTooZT1zLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9lKHtwcm9taXNlOm8scmVhc29uOnJ9KToobj1zLmNvbnNvbGUpJiZuLmVycm9yJiZuLmVycm9yKFwiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uXCIscikpLHQuYT12b2lkIDB9LDEpfSl9fSxBPWZ1bmN0aW9uKHQpe3ZhciBlLG49dC5fZCxyPW4uYXx8bi5jLG89MDtpZihuLmgpcmV0dXJuITE7Zm9yKDtyLmxlbmd0aD5vOylpZihlPXJbbysrXSxlLmZhaWx8fCFBKGUucHJvbWlzZSkpcmV0dXJuITE7cmV0dXJuITB9LEw9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztlLmR8fChlLmQ9ITAsZT1lLnJ8fGUsZS52PXQsZS5zPTIsZS5hPWUuYy5zbGljZSgpLGooZSwhMCkpfSxJPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcztpZighbi5kKXtuLmQ9ITAsbj1uLnJ8fG47dHJ5e2lmKG4ucD09PXQpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7KGU9RSh0KSk/eChmdW5jdGlvbigpe3ZhciByPXtyOm4sZDohMX07dHJ5e2UuY2FsbCh0LGEoSSxyLDEpLGEoTCxyLDEpKX1jYXRjaChvKXtMLmNhbGwocixvKX19KToobi52PXQsbi5zPTEsaihuLCExKSl9Y2F0Y2gocil7TC5jYWxsKHtyOm4sZDohMX0scil9fX07T3x8KFA9ZnVuY3Rpb24odCl7Zih0KTt2YXIgZT10aGlzLl9kPXtwOmgodGhpcyxQLGIpLGM6W10sYTp2b2lkIDAsczowLGQ6ITEsdjp2b2lkIDAsaDohMSxuOiExfTt0cnl7dChhKEksZSwxKSxhKEwsZSwxKSl9Y2F0Y2gobil7TC5jYWxsKGUsbil9fSxuKDEyOSkoUC5wcm90b3R5cGUse3RoZW46ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQyhnKHRoaXMsUCkpLHI9bi5wcm9taXNlLG89dGhpcy5fZDtyZXR1cm4gbi5vaz1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6ITAsbi5mYWlsPVwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUsby5jLnB1c2gobiksby5hJiZvLmEucHVzaChuKSxvLnMmJmoobywhMSkscn0sXCJjYXRjaFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLHQpfX0pKSxsKGwuRytsLlcrbC5GKiFPLHtQcm9taXNlOlB9KSxuKDQwKShQLGIpLG4oMTMxKShiKSxyPW4oOClbYl0sbChsLlMrbC5GKiFPLGIse3JlamVjdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQyh0aGlzKSxuPWUucmVqZWN0O3JldHVybiBuKHQpLGUucHJvbWlzZX19KSxsKGwuUytsLkYqKCFPfHxUKCEwKSksYix7cmVzb2x2ZTpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgUCYmdyh0LmNvbnN0cnVjdG9yLHRoaXMpKXJldHVybiB0O3ZhciBlPW5ldyBDKHRoaXMpLG49ZS5yZXNvbHZlO3JldHVybiBuKHQpLGUucHJvbWlzZX19KSxsKGwuUytsLkYqIShPJiZuKDEyNSkoZnVuY3Rpb24odCl7UC5hbGwodClbXCJjYXRjaFwiXShmdW5jdGlvbigpe30pfSkpLGIse2FsbDpmdW5jdGlvbih0KXt2YXIgZT1NKHRoaXMpLG49bmV3IEMoZSkscj1uLnJlc29sdmUsaT1uLnJlamVjdCxzPVtdLGE9UyhmdW5jdGlvbigpe2QodCwhMSxzLnB1c2gscyk7dmFyIG49cy5sZW5ndGgsYT1BcnJheShuKTtuP28uZWFjaC5jYWxsKHMsZnVuY3Rpb24odCxvKXt2YXIgcz0hMTtlLnJlc29sdmUodCkudGhlbihmdW5jdGlvbih0KXtzfHwocz0hMCxhW29dPXQsLS1ufHxyKGEpKX0saSl9KTpyKGEpfSk7cmV0dXJuIGEmJmkoYS5lcnJvciksbi5wcm9taXNlfSxyYWNlOmZ1bmN0aW9uKHQpe3ZhciBlPU0odGhpcyksbj1uZXcgQyhlKSxyPW4ucmVqZWN0LG89UyhmdW5jdGlvbigpe2QodCwhMSxmdW5jdGlvbih0KXtlLnJlc29sdmUodCkudGhlbihuLnJlc29sdmUscil9KX0pO3JldHVybiBvJiZyKG8uZXJyb3IpLG4ucHJvbWlzZX19KX0sZnVuY3Rpb24odCxlKXt9LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LDE0OCwxNDgsMTQ4LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2Zvcih2YXIgbj0tMSxyPWUubGVuZ3RoLG89dC5sZW5ndGg7KytuPHI7KXRbbytuXT1lW25dO3JldHVybiB0fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7Zm9yKHZhciByPS0xLGk9byhlKSxzPWkubGVuZ3RoOysrcjxzOyl7dmFyIGE9aVtyXSx1PXRbYV0sbD1uKHUsZVthXSxhLHQsZSk7KGw9PT1sP2w9PT11OnUhPT11KSYmKHZvaWQgMCE9PXV8fGEgaW4gdCl8fCh0W2FdPWwpfXJldHVybiB0fXZhciBvPW4oNjYpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3JldHVybiBudWxsPT1lP3Q6byhlLGkoZSksdCl9dmFyIG89bigxNjcpLGk9big2Nik7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUsbil7bnx8KG49e30pO2Zvcih2YXIgcj0tMSxvPWUubGVuZ3RoOysrcjxvOyl7dmFyIGk9ZVtyXTtuW2ldPXRbaV19cmV0dXJuIG59dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuLGwpe2x8fChsPVtdKTtmb3IodmFyIGM9LTEscD10Lmxlbmd0aDsrK2M8cDspe3ZhciBmPXRbY107dShmKSYmYShmKSYmKG58fHMoZil8fGkoZikpP2U/cihmLGUsbixsKTpvKGwsZik6bnx8KGxbbC5sZW5ndGhdPWYpfXJldHVybiBsfXZhciBvPW4oMTY0KSxpPW4oNDQpLHM9bigyOSksYT1uKDI2KSx1PW4oMjgpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNzMpLG89cigpO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3JldHVybiBvKHQsZSxpKX12YXIgbz1uKDE2OSksaT1uKDY3KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT92b2lkIDA6ZVt0XX19dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBzKGZ1bmN0aW9uKGUsbil7dmFyIHI9LTEscz1udWxsPT1lPzA6bi5sZW5ndGgsYT1zPjI/bltzLTJdOnZvaWQgMCx1PXM+Mj9uWzJdOnZvaWQgMCxsPXM+MT9uW3MtMV06dm9pZCAwO2ZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhPyhhPW8oYSxsLDUpLHMtPTIpOihhPVwiZnVuY3Rpb25cIj09dHlwZW9mIGw/bDp2b2lkIDAscy09YT8xOjApLHUmJmkoblswXSxuWzFdLHUpJiYoYT0zPnM/dm9pZCAwOmEscz0xKTsrK3I8czspe3ZhciBjPW5bcl07YyYmdChlLGMsYSl9cmV0dXJuIGV9KX12YXIgbz1uKDYyKSxpPW4oMTc1KSxzPW4oNjEpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe2Zvcih2YXIgaT1vKGUpLHM9cihlKSxhPXMubGVuZ3RoLHU9dD9hOi0xO3Q/dS0tOisrdTxhOyl7dmFyIGw9c1t1XTtpZihuKGlbbF0sbCxpKT09PSExKWJyZWFrfXJldHVybiBlfX12YXIgbz1uKDY0KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTcxKSxvPXIoXCJsZW5ndGhcIik7dC5leHBvcnRzPW99LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuKXtpZighcyhuKSlyZXR1cm4hMTt2YXIgcj10eXBlb2YgZTtpZihcIm51bWJlclwiPT1yP28obikmJmkoZSxuLmxlbmd0aCk6XCJzdHJpbmdcIj09ciYmZSBpbiBuKXt2YXIgYT1uW2VdO3JldHVybiB0PT09dD90PT09YTphIT09YX1yZXR1cm4hMX12YXIgbz1uKDI2KSxpPW4oNDMpLHM9bigxNyk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dD1vKHQpO2Zvcih2YXIgbj0tMSxyPWUubGVuZ3RoLGk9e307KytuPHI7KXt2YXIgcz1lW25dO3MgaW4gdCYmKGlbc109dFtzXSl9cmV0dXJuIGl9dmFyIG89big2NCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dmFyIG49e307cmV0dXJuIG8odCxmdW5jdGlvbih0LHIsbyl7ZSh0LHIsbykmJihuW3JdPXQpfSksbn12YXIgbz1uKDE3MCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe2Zvcih2YXIgZT11KHQpLG49ZS5sZW5ndGgscj1uJiZ0Lmxlbmd0aCxsPSEhciYmYShyKSYmKGkodCl8fG8odCkpLHA9LTEsZj1bXTsrK3A8bjspe3ZhciBoPWVbcF07KGwmJnMoaCxyKXx8Yy5jYWxsKHQsaCkpJiZmLnB1c2goaCl9cmV0dXJuIGZ9dmFyIG89big0NCksaT1uKDI5KSxzPW4oNDMpLGE9bigyNyksdT1uKDY3KSxsPU9iamVjdC5wcm90b3R5cGUsYz1sLmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbyh0KSYmYS5jYWxsKHQpPT1pfXZhciBvPW4oMTcpLGk9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiLHM9T2JqZWN0LnByb3RvdHlwZSxhPXMudG9TdHJpbmc7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBudWxsPT10PyExOm8odCk/Yy50ZXN0KHUuY2FsbCh0KSk6aSh0KSYmcy50ZXN0KHQpfXZhciBvPW4oMTc5KSxpPW4oMjgpLHM9L15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLyxhPU9iamVjdC5wcm90b3R5cGUsdT1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsbD1hLmhhc093blByb3BlcnR5LGM9UmVnRXhwKFwiXlwiK3UuY2FsbChsKS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLFwiJDEuKj9cIikrXCIkXCIpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNjgpLG89big2MiksaT1uKDE3Nikscz1uKDE3NyksYT1uKDYxKSx1PWEoZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09dD97fTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlWzBdP3ModCxvKGVbMF0sZVsxXSwzKSk6aSh0LHIoZSkpfSk7dC5leHBvcnRzPXV9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdH10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7ZGVsZXRlIHQucmVmfXZhciBvPW4oNiksaT1uKDMwKSxzPW4oMTkwKSxhPW8uY3JlYXRlRmFjdG9yeShuKDE4NCkpLHU9bigxODUpLGw9bigxODkpLGM9bigzMCkudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIscD1zLmNhblVzZURPTT93aW5kb3cuSFRNTEVsZW1lbnQ6e307dC5leHBvcnRzPW8uY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOlwiTW9kYWxcIixzdGF0aWNzOntzZXRBcHBFbGVtZW50OnUuc2V0RWxlbWVudCxpbmplY3RDU1M6ZnVuY3Rpb24oKXt9fSxwcm9wVHlwZXM6e2lzT3BlbjpvLlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsc3R5bGU6by5Qcm9wVHlwZXMuc2hhcGUoe2NvbnRlbnQ6by5Qcm9wVHlwZXMub2JqZWN0LG92ZXJsYXk6by5Qcm9wVHlwZXMub2JqZWN0fSksYXBwRWxlbWVudDpvLlByb3BUeXBlcy5pbnN0YW5jZU9mKHApLG9uUmVxdWVzdENsb3NlOm8uUHJvcFR5cGVzLmZ1bmMsY2xvc2VUaW1lb3V0TVM6by5Qcm9wVHlwZXMubnVtYmVyLGFyaWFIaWRlQXBwOm8uUHJvcFR5cGVzLmJvb2x9LGdldERlZmF1bHRQcm9wczpmdW5jdGlvbigpe3JldHVybntpc09wZW46ITEsYXJpYUhpZGVBcHA6ITAsY2xvc2VUaW1lb3V0TVM6MH19LGNvbXBvbmVudERpZE1vdW50OmZ1bmN0aW9uKCl7dGhpcy5ub2RlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5ub2RlLmNsYXNzTmFtZT1cIlJlYWN0TW9kYWxQb3J0YWxcIixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubm9kZSksdGhpcy5yZW5kZXJQb3J0YWwodGhpcy5wcm9wcyl9LGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ZnVuY3Rpb24odCl7dGhpcy5yZW5kZXJQb3J0YWwodCl9LGNvbXBvbmVudFdpbGxVbm1vdW50OmZ1bmN0aW9uKCl7aS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMubm9kZSksZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpfSxyZW5kZXJQb3J0YWw6ZnVuY3Rpb24odCl7dC5pc09wZW4/bChkb2N1bWVudC5ib2R5KS5hZGQoXCJSZWFjdE1vZGFsX19Cb2R5LS1vcGVuXCIpOmwoZG9jdW1lbnQuYm9keSkucmVtb3ZlKFwiUmVhY3RNb2RhbF9fQm9keS0tb3BlblwiKSx0LmFyaWFIaWRlQXBwJiZ1LnRvZ2dsZSh0LmlzT3Blbix0LmFwcEVsZW1lbnQpLHIodCksdGhpcy5wb3J0YWw9Yyh0aGlzLGEodCksdGhpcy5ub2RlKX0scmVuZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIG8uRE9NLm5vc2NyaXB0KCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCl9dmFyIG89big2KSxpPW8uRE9NLmRpdixzPW4oMTg2KSxhPW4oMTg3KSx1PW4oMTkxKSxsPXtvdmVybGF5OntiYXNlOlwiUmVhY3RNb2RhbF9fT3ZlcmxheVwiLGFmdGVyT3BlbjpcIlJlYWN0TW9kYWxfX092ZXJsYXktLWFmdGVyLW9wZW5cIixiZWZvcmVDbG9zZTpcIlJlYWN0TW9kYWxfX092ZXJsYXktLWJlZm9yZS1jbG9zZVwifSxjb250ZW50OntiYXNlOlwiUmVhY3RNb2RhbF9fQ29udGVudFwiLGFmdGVyT3BlbjpcIlJlYWN0TW9kYWxfX0NvbnRlbnQtLWFmdGVyLW9wZW5cIixiZWZvcmVDbG9zZTpcIlJlYWN0TW9kYWxfX0NvbnRlbnQtLWJlZm9yZS1jbG9zZVwifX0sYz17b3ZlcmxheTp7cG9zaXRpb246XCJmaXhlZFwiLHRvcDowLGxlZnQ6MCxyaWdodDowLGJvdHRvbTowLGJhY2tncm91bmRDb2xvcjpcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSlcIn0sY29udGVudDp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjQwcHhcIixsZWZ0OlwiNDBweFwiLHJpZ2h0OlwiNDBweFwiLGJvdHRvbTpcIjQwcHhcIixib3JkZXI6XCIxcHggc29saWQgI2NjY1wiLGJhY2tncm91bmQ6XCIjZmZmXCIsb3ZlcmZsb3c6XCJhdXRvXCIsV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6XCJ0b3VjaFwiLGJvcmRlclJhZGl1czpcIjRweFwiLG91dGxpbmU6XCJub25lXCIscGFkZGluZzpcIjIwcHhcIn19O3QuZXhwb3J0cz1vLmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTpcIk1vZGFsUG9ydGFsXCIsZ2V0RGVmYXVsdFByb3BzOmZ1bmN0aW9uKCl7cmV0dXJue3N0eWxlOntvdmVybGF5Ont9LGNvbnRlbnQ6e319fX0sZ2V0SW5pdGlhbFN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJue2FmdGVyT3BlbjohMSxiZWZvcmVDbG9zZTohMX19LGNvbXBvbmVudERpZE1vdW50OmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy5pc09wZW4mJih0aGlzLnNldEZvY3VzQWZ0ZXJSZW5kZXIoITApLHRoaXMub3BlbigpKX0sY29tcG9uZW50V2lsbFVubW91bnQ6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKX0sY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczpmdW5jdGlvbih0KXshdGhpcy5wcm9wcy5pc09wZW4mJnQuaXNPcGVuPyh0aGlzLnNldEZvY3VzQWZ0ZXJSZW5kZXIoITApLHRoaXMub3BlbigpKTp0aGlzLnByb3BzLmlzT3BlbiYmIXQuaXNPcGVuJiZ0aGlzLmNsb3NlKCl9LGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpe3RoaXMuZm9jdXNBZnRlclJlbmRlciYmKHRoaXMuZm9jdXNDb250ZW50KCksdGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKCExKSl9LHNldEZvY3VzQWZ0ZXJSZW5kZXI6ZnVuY3Rpb24odCl7dGhpcy5mb2N1c0FmdGVyUmVuZGVyPXR9LG9wZW46ZnVuY3Rpb24oKXtzLnNldHVwU2NvcGVkRm9jdXModGhpcy5ub2RlKSxzLm1hcmtGb3JGb2N1c0xhdGVyKCksdGhpcy5zZXRTdGF0ZSh7aXNPcGVuOiEwfSxmdW5jdGlvbigpe3RoaXMuc2V0U3RhdGUoe2FmdGVyT3BlbjohMH0pfS5iaW5kKHRoaXMpKX0sY2xvc2U6ZnVuY3Rpb24oKXt0aGlzLm93bmVySGFuZGxlc0Nsb3NlKCkmJih0aGlzLnByb3BzLmNsb3NlVGltZW91dE1TPjA/dGhpcy5jbG9zZVdpdGhUaW1lb3V0KCk6dGhpcy5jbG9zZVdpdGhvdXRUaW1lb3V0KCkpfSxmb2N1c0NvbnRlbnQ6ZnVuY3Rpb24oKXt0aGlzLnJlZnMuY29udGVudC5mb2N1cygpfSxjbG9zZVdpdGhUaW1lb3V0OmZ1bmN0aW9uKCl7dGhpcy5zZXRTdGF0ZSh7YmVmb3JlQ2xvc2U6ITB9LGZ1bmN0aW9uKCl7dGhpcy5jbG9zZVRpbWVyPXNldFRpbWVvdXQodGhpcy5jbG9zZVdpdGhvdXRUaW1lb3V0LHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMpfS5iaW5kKHRoaXMpKX0sY2xvc2VXaXRob3V0VGltZW91dDpmdW5jdGlvbigpe3RoaXMuc2V0U3RhdGUoe2FmdGVyT3BlbjohMSxiZWZvcmVDbG9zZTohMX0sdGhpcy5hZnRlckNsb3NlKX0sYWZ0ZXJDbG9zZTpmdW5jdGlvbigpe3MucmV0dXJuRm9jdXMoKSxzLnRlYXJkb3duU2NvcGVkRm9jdXMoKX0saGFuZGxlS2V5RG93bjpmdW5jdGlvbih0KXs5PT10LmtleUNvZGUmJmEodGhpcy5yZWZzLmNvbnRlbnQsdCksMjc9PXQua2V5Q29kZSYmdGhpcy5yZXF1ZXN0Q2xvc2UoKX0saGFuZGxlT3ZlcmxheUNsaWNrOmZ1bmN0aW9uKCl7dGhpcy5vd25lckhhbmRsZXNDbG9zZSgpP3RoaXMucmVxdWVzdENsb3NlKCk6dGhpcy5mb2N1c0NvbnRlbnQoKX0scmVxdWVzdENsb3NlOmZ1bmN0aW9uKCl7dGhpcy5vd25lckhhbmRsZXNDbG9zZSgpJiZ0aGlzLnByb3BzLm9uUmVxdWVzdENsb3NlKCl9LG93bmVySGFuZGxlc0Nsb3NlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2V9LHNob3VsZEJlQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMucHJvcHMuaXNPcGVuJiYhdGhpcy5zdGF0ZS5iZWZvcmVDbG9zZX0sYnVpbGRDbGFzc05hbWU6ZnVuY3Rpb24odCxlKXt2YXIgbj1sW3RdLmJhc2U7cmV0dXJuIHRoaXMuc3RhdGUuYWZ0ZXJPcGVuJiYobis9XCIgXCIrbFt0XS5hZnRlck9wZW4pLHRoaXMuc3RhdGUuYmVmb3JlQ2xvc2UmJihuKz1cIiBcIitsW3RdLmJlZm9yZUNsb3NlKSxlP24rXCIgXCIrZTpufSxyZW5kZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaG91bGRCZUNsb3NlZCgpP2koKTppKHtyZWY6XCJvdmVybGF5XCIsY2xhc3NOYW1lOnRoaXMuYnVpbGRDbGFzc05hbWUoXCJvdmVybGF5XCIsdGhpcy5wcm9wcy5vdmVybGF5Q2xhc3NOYW1lKSxzdHlsZTp1KHt9LGMub3ZlcmxheSx0aGlzLnByb3BzLnN0eWxlLm92ZXJsYXl8fHt9KSxvbkNsaWNrOnRoaXMuaGFuZGxlT3ZlcmxheUNsaWNrfSxpKHtyZWY6XCJjb250ZW50XCIsc3R5bGU6dSh7fSxjLmNvbnRlbnQsdGhpcy5wcm9wcy5zdHlsZS5jb250ZW50fHx7fSksY2xhc3NOYW1lOnRoaXMuYnVpbGRDbGFzc05hbWUoXCJjb250ZW50XCIsdGhpcy5wcm9wcy5jbGFzc05hbWUpLHRhYkluZGV4OlwiLTFcIixvbkNsaWNrOnIsb25LZXlEb3duOnRoaXMuaGFuZGxlS2V5RG93bn0sdGhpcy5wcm9wcy5jaGlsZHJlbikpfX0pfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe3ZhciBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCk7dD1cImxlbmd0aFwiaW4gZT9lWzBdOmV9dT10fHx1fWZ1bmN0aW9uIHIodCl7cyh0KSwodHx8dSkuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIil9ZnVuY3Rpb24gbyh0KXtzKHQpLCh0fHx1KS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKX1mdW5jdGlvbiBpKHQsZSl7dD9yKGUpOm8oZSl9ZnVuY3Rpb24gcyh0KXtpZighdCYmIXUpdGhyb3cgbmV3IEVycm9yKFwicmVhY3QtbW9kYWw6IFlvdSBtdXN0IHNldCBhbiBlbGVtZW50IHdpdGggYE1vZGFsLnNldEFwcEVsZW1lbnQoZWwpYCB0byBtYWtlIHRoaXMgYWNjZXNzaWJsZVwiKX1mdW5jdGlvbiBhKCl7dT1kb2N1bWVudC5ib2R5fXZhciB1PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudD9kb2N1bWVudC5ib2R5Om51bGw7ZS50b2dnbGU9aSxlLnNldEVsZW1lbnQ9bixlLnNob3c9byxlLmhpZGU9cixlLnJlc2V0Rm9yVGVzdGluZz1hfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt1PSEwfWZ1bmN0aW9uIG8odCl7aWYodSl7aWYodT0hMSwhcylyZXR1cm47c2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFzLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKXt2YXIgdD1pKHMpWzBdfHxzO3QuZm9jdXMoKX19LDApfX12YXIgaT1uKDY4KSxzPW51bGwsYT1udWxsLHU9ITE7ZS5tYXJrRm9yRm9jdXNMYXRlcj1mdW5jdGlvbigpe2E9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudH0sZS5yZXR1cm5Gb2N1cz1mdW5jdGlvbigpe3RyeXthLmZvY3VzKCl9Y2F0Y2godCl7Y29uc29sZS53YXJuKFwiWW91IHRyaWVkIHRvIHJldHVybiBmb2N1cyB0byBcIithK1wiIGJ1dCBpdCBpcyBub3QgaW4gdGhlIERPTSBhbnltb3JlXCIpfWE9bnVsbH0sZS5zZXR1cFNjb3BlZEZvY3VzPWZ1bmN0aW9uKHQpe3M9dCx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcj8od2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsciwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsbywhMCkpOih3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbkJsdXJcIixyKSxkb2N1bWVudC5hdHRhY2hFdmVudChcIm9uRm9jdXNcIixvKSl9LGUudGVhcmRvd25TY29wZWRGb2N1cz1mdW5jdGlvbigpe3M9bnVsbCx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcj8od2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsciksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsbykpOih3aW5kb3cuZGV0YWNoRXZlbnQoXCJvbkJsdXJcIixyKSxkb2N1bWVudC5kZXRhY2hFdmVudChcIm9uRm9jdXNcIixvKSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big2OCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49cih0KSxvPW5bZS5zaGlmdEtleT8wOm4ubGVuZ3RoLTFdLGk9bz09PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnR8fHQ9PT1kb2N1bWVudC5hY3RpdmVFbGVtZW50O2lmKGkpe2UucHJldmVudERlZmF1bHQoKTt2YXIgcz1uW2Uuc2hpZnRLZXk/bi5sZW5ndGgtMTowXTtzLmZvY3VzKCl9fX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDE4Myl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2lmKHQuaW5kZXhPZilyZXR1cm4gdC5pbmRleE9mKGUpO2Zvcih2YXIgbj0wLHI9dC5sZW5ndGg7cj5uO24rKylpZih0W25dPT09ZSlyZXR1cm4gbjtyZXR1cm4tMX1mdW5jdGlvbiByKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHIpKXJldHVybiBuZXcgcih0KTt0fHwodD17fSksdC5ub2RlVHlwZSYmKHQ9e2VsOnR9KSx0aGlzLm9wdHM9dCx0aGlzLmVsPXQuZWx8fGRvY3VtZW50LmJvZHksXCJvYmplY3RcIiE9dHlwZW9mIHRoaXMuZWwmJih0aGlzLmVsPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5lbCkpfXQuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHIodCl9LHIucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmVsO2lmKGUpe2lmKFwiXCI9PT1lLmNsYXNzTmFtZSlyZXR1cm4gZS5jbGFzc05hbWU9dDt2YXIgcj1lLmNsYXNzTmFtZS5zcGxpdChcIiBcIik7cmV0dXJuIG4ocix0KT4tMT9yOihyLnB1c2godCksZS5jbGFzc05hbWU9ci5qb2luKFwiIFwiKSxyKX19LHIucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmVsO2lmKGUmJlwiXCIhPT1lLmNsYXNzTmFtZSl7dmFyIHI9ZS5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLG89bihyLHQpO3JldHVybiBvPi0xJiZyLnNwbGljZShvLDEpLGUuY2xhc3NOYW1lPXIuam9pbihcIiBcIikscn19LHIucHJvdG90eXBlLmhhcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmVsO2lmKGUpe3ZhciByPWUuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtyZXR1cm4gbihyLHQpPi0xfX0sci5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWw7ZSYmKHRoaXMuaGFzKHQpP3RoaXMucmVtb3ZlKHQpOnRoaXMuYWRkKHQpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcjshZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgbz0hKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3d8fCF3aW5kb3cuZG9jdW1lbnR8fCF3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCksaT17Y2FuVXNlRE9NOm8sY2FuVXNlV29ya2VyczpcInVuZGVmaW5lZFwiIT10eXBlb2YgV29ya2VyLGNhblVzZUV2ZW50TGlzdGVuZXJzOm8mJiEoIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyJiYhd2luZG93LmF0dGFjaEV2ZW50KSxjYW5Vc2VWaWV3cG9ydDpvJiYhIXdpbmRvdy5zY3JlZW59O3I9ZnVuY3Rpb24oKXtyZXR1cm4gaX0uY2FsbChlLG4sZSx0KSwhKHZvaWQgMCE9PXImJih0LmV4cG9ydHM9cikpfSgpfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7Zm9yKHZhciByPS0xLG89cyhlKSxpPW8ubGVuZ3RoOysrcjxpOyl7dmFyIGE9b1tyXSx1PXRbYV0sbD1uKHUsZVthXSxhLHQsZSk7KGw9PT1sP2w9PT11OnUhPT11KSYmKHZvaWQgMCE9PXV8fGEgaW4gdCl8fCh0W2FdPWwpfXJldHVybiB0fXZhciBvPW4oMTkyKSxpPW4oMTk0KSxzPW4oNjkpLGE9aShmdW5jdGlvbih0LGUsbil7cmV0dXJuIG4/cih0LGUsbik6byh0LGUpfSk7dC5leHBvcnRzPWF9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIG51bGw9PWU/dDpvKGUsaShlKSx0KX12YXIgbz1uKDE5MyksaT1uKDY5KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSxuKXtufHwobj17fSk7Zm9yKHZhciByPS0xLG89ZS5sZW5ndGg7KytyPG87KXt2YXIgaT1lW3JdO25baV09dFtpXX1yZXR1cm4gbn10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIHMoZnVuY3Rpb24oZSxuKXt2YXIgcj0tMSxzPW51bGw9PWU/MDpuLmxlbmd0aCxhPXM+Mj9uW3MtMl06dm9pZCAwLHU9cz4yP25bMl06dm9pZCAwLGw9cz4xP25bcy0xXTp2b2lkIDA7Zm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGE/KGE9byhhLGwsNSkscy09Mik6KGE9XCJmdW5jdGlvblwiPT10eXBlb2YgbD9sOnZvaWQgMCxzLT1hPzE6MCksdSYmaShuWzBdLG5bMV0sdSkmJihhPTM+cz92b2lkIDA6YSxzPTEpOysrcjxzOyl7dmFyIGM9bltyXTtjJiZ0KGUsYyxhKX1yZXR1cm4gZX0pfXZhciBvPW4oMTk1KSxpPW4oMTk2KSxzPW4oMTk3KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiByO2lmKHZvaWQgMD09PWUpcmV0dXJuIHQ7c3dpdGNoKG4pe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHQuY2FsbChlLG4pfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKG4scixvKXtyZXR1cm4gdC5jYWxsKGUsbixyLG8pfTtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKG4scixvLGkpe3JldHVybiB0LmNhbGwoZSxuLHIsbyxpKX07Y2FzZSA1OnJldHVybiBmdW5jdGlvbihuLHIsbyxpLHMpe3JldHVybiB0LmNhbGwoZSxuLHIsbyxpLHMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHIodCl7cmV0dXJuIHR9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/dm9pZCAwOmVbdF19fWZ1bmN0aW9uIHIodCl7cmV0dXJuIG51bGwhPXQmJnMoYyh0KSl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiB0PVwibnVtYmVyXCI9PXR5cGVvZiB0fHx1LnRlc3QodCk/K3Q6LTEsZT1udWxsPT1lP2w6ZSx0Pi0xJiZ0JTE9PTAmJmU+dH1mdW5jdGlvbiBpKHQsZSxuKXtpZighYShuKSlyZXR1cm4hMTt2YXIgaT10eXBlb2YgZTtpZihcIm51bWJlclwiPT1pP3IobikmJm8oZSxuLmxlbmd0aCk6XCJzdHJpbmdcIj09aSYmZSBpbiBuKXt2YXIgcz1uW2VdO3JldHVybiB0PT09dD90PT09czpzIT09c31yZXR1cm4hMX1mdW5jdGlvbiBzKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZ0Pi0xJiZ0JTE9PTAmJmw+PXR9ZnVuY3Rpb24gYSh0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfXZhciB1PS9eXFxkKyQvLGw9OTAwNzE5OTI1NDc0MDk5MSxjPW4oXCJsZW5ndGhcIik7dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihyKTtyZXR1cm4gZT1vKHZvaWQgMD09PWU/dC5sZW5ndGgtMTorZXx8MCwwKSxmdW5jdGlvbigpe2Zvcih2YXIgbj1hcmd1bWVudHMscj0tMSxpPW8obi5sZW5ndGgtZSwwKSxzPUFycmF5KGkpOysrcjxpOylzW3JdPW5bZStyXTtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiB0LmNhbGwodGhpcyxzKTtjYXNlIDE6cmV0dXJuIHQuY2FsbCh0aGlzLG5bMF0scyk7Y2FzZSAyOnJldHVybiB0LmNhbGwodGhpcyxuWzBdLG5bMV0scyl9dmFyIGE9QXJyYXkoZSsxKTtmb3Iocj0tMTsrK3I8ZTspYVtyXT1uW3JdO3JldHVybiBhW2VdPXMsdC5hcHBseSh0aGlzLGEpfX12YXIgcj1cIkV4cGVjdGVkIGEgZnVuY3Rpb25cIixvPU1hdGgubWF4O3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT10eXBlb2YgdH1mdW5jdGlvbiByKHQsZSl7dmFyIG49bnVsbD09dD92b2lkIDA6dFtlXTtyZXR1cm4gcyhuKT9uOnZvaWQgMH1mdW5jdGlvbiBvKHQpe3JldHVybiBpKHQpJiZmLmNhbGwodCk9PWF9ZnVuY3Rpb24gaSh0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfWZ1bmN0aW9uIHModCl7cmV0dXJuIG51bGw9PXQ/ITE6byh0KT9oLnRlc3QoYy5jYWxsKHQpKTpuKHQpJiZ1LnRlc3QodCl9dmFyIGE9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiLHU9L15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLyxsPU9iamVjdC5wcm90b3R5cGUsYz1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcscD1sLmhhc093blByb3BlcnR5LGY9bC50b1N0cmluZyxoPVJlZ0V4cChcIl5cIitjLmNhbGwocCkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZyxcIiQxLio/XCIpK1wiJFwiKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiEhdCYmXCJvYmplY3RcIj09dHlwZW9mIHR9ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/dm9pZCAwOmVbdF19fWZ1bmN0aW9uIG8odCl7cmV0dXJuIG51bGwhPXQmJmkocCh0KSl9ZnVuY3Rpb24gaSh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmdD4tMSYmdCUxPT0wJiZjPj10fWZ1bmN0aW9uIHModCl7cmV0dXJuIG4odCkmJm8odCkmJnUuY2FsbCh0LFwiY2FsbGVlXCIpJiYhbC5jYWxsKHQsXCJjYWxsZWVcIil9dmFyIGE9T2JqZWN0LnByb3RvdHlwZSx1PWEuaGFzT3duUHJvcGVydHksbD1hLnByb3BlcnR5SXNFbnVtZXJhYmxlLGM9OTAwNzE5OTI1NDc0MDk5MSxwPXIoXCJsZW5ndGhcIik7dC5leHBvcnRzPXN9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4hIXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fWZ1bmN0aW9uIHIodCxlKXt2YXIgbj1udWxsPT10P3ZvaWQgMDp0W2VdO3JldHVybiBhKG4pP246dm9pZCAwfWZ1bmN0aW9uIG8odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJnQ+LTEmJnQlMT09MCYmbT49dH1mdW5jdGlvbiBpKHQpe3JldHVybiBzKHQpJiZkLmNhbGwodCk9PWx9ZnVuY3Rpb24gcyh0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfWZ1bmN0aW9uIGEodCl7cmV0dXJuIG51bGw9PXQ/ITE6aSh0KT95LnRlc3QoZi5jYWxsKHQpKTpuKHQpJiZjLnRlc3QodCl9dmFyIHU9XCJbb2JqZWN0IEFycmF5XVwiLGw9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiLGM9L15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLyxwPU9iamVjdC5wcm90b3R5cGUsZj1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsaD1wLmhhc093blByb3BlcnR5LGQ9cC50b1N0cmluZyx5PVJlZ0V4cChcIl5cIitmLmNhbGwoaCkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZyxcIiQxLio/XCIpK1wiJFwiKSx2PXIoQXJyYXksXCJpc0FycmF5XCIpLG09OTAwNzE5OTI1NDc0MDk5MSxnPXZ8fGZ1bmN0aW9uKHQpe3JldHVybiBuKHQpJiZvKHQubGVuZ3RoKSYmZC5jYWxsKHQpPT11fTt0LmV4cG9ydHM9Z30sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9c30sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9YX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9dX1dKSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHMubWluLmpzLm1hcCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvY2FydG9kYi1jbGllbnRcIik7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIENhcnRvREJDbGllbnQoYWNjb3VudE5hbWUsb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICBvcHRpb25zLmFwaXJvb3QgICAgID0gb3B0aW9ucy5hcGlyb290ICAgICAgfHwgXCJodHRwOi8ve2FjY291bnROYW1lfS5jYXJ0b2RiLmNvbS9hcGkvdjIvXCI7XG4gICAgb3B0aW9ucy5mb3JtYXQgICAgICA9IG9wdGlvbnMuZm9ybWF0ICAgICAgIHx8IFwiR2VvSlNPTlwiO1xuICAgIG9wdGlvbnMuYWNjb3VudE5hbWUgPSBvcHRpb25zLmFjY291bnROYW1lICB8fCBhY2NvdW50TmFtZTtcblxuICAgIC8vXG4gICAgLy8gUmVxdWVzdCByZW1vdGUgZGF0YVxuICAgIC8vXG4gICAgZnVuY3Rpb24gcmVxdWVzdCh1cmksIGNhbGxiYWNrKSB7XG5cbiAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHZhciB4bWxIdHRwID0gbnVsbDtcblxuICAgICAgICB4bWxIdHRwID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCh4bWxIdHRwLnJlYWR5U3RhdGV8MCkgPT09IDQpIHtcbiAgICAgICAgICAgIGlmICgoeG1sSHR0cC5zdGF0dXN8MCkgPT09IDIwMCApIHtcblxuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB4bWxIdHRwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHhtbEh0dHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4bWxIdHRwLm9wZW4oIFwiR0VUXCIsIHVyaSwgdHJ1ZSApO1xuICAgICAgICByZXR1cm4geG1sSHR0cC5zZW5kKCBudWxsICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBCdWlsZCBhIHN0cmluZyBmcm9tIGEgdGVtcGxhdGUgYW5kIGRhdGFcbiAgICAvL1xuICAgIGZ1bmN0aW9uIGJ1aWxkVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpIHtcbiAgICAgIHZhciBvdXRTdHJpbmcgPSB0ZW1wbGF0ZTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgb3V0U3RyaW5nID0gb3V0U3RyaW5nLnNwbGl0KFwie1wiICsgaSArIFwifVwiKS5qb2luKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRTdHJpbmc7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXF1ZXN0IGZyb20gdGhlIENhcnRvRGIgU1FMIGVuZHBvaW50XG4gICAgLy9cbiAgICBmdW5jdGlvbiBzcWxSZXF1ZXN0KHNxbCwgY2FsbGJhY2ssIF9vcHRpb25zKSB7XG5cbiAgICAgIF9vcHRpb25zID0gX29wdGlvbnMgfHwge307XG5cbiAgICAgIC8vXG4gICAgICAvLyBPdmVycmlkZSBkZWZhdWx0c1xuICAgICAgLy9cbiAgICAgIGlmIChPYmplY3Qua2V5cyhfb3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gX29wdGlvbnMpIHtcblxuICAgICAgICAgIGlmIChfb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXG4gICAgICAgICAgICBvcHRpb25zW2ldID0gX29wdGlvbnNbaV07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXJsID0gYnVpbGRUZW1wbGF0ZShbXG4gICAgICAgIGJ1aWxkVGVtcGxhdGUob3B0aW9ucy5hcGlyb290LCBvcHRpb25zKSxcbiAgICAgICAgXCJzcWxcIixcbiAgICAgICAgXCI/Zm9ybWF0PVwiICsgb3B0aW9ucy5mb3JtYXQsXG4gICAgICAgIFwiJnE9XCIgKyBzcWxcbiAgICAgIF0uam9pbihcIlwiKSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmRhbmdlcm91c2x5RXhwb3NlZEFQSUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFeHBvc2luZyBBUEkga2V5IGluIFVSTCEgRG8gbm90IHB1c2ggdGhpcyB0byBwcm9kdWN0aW9uLlwiKTtcbiAgICAgICAgdXJsICs9IChcIiZhcGlfa2V5PVwiICsgb3B0aW9ucy5kYW5nZXJvdXNseUV4cG9zZWRBUElLZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdCh1cmwsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBQcm9taXNlIHJlcXVlc3RcbiAgICBmdW5jdGlvbiByZXF1ZXN0UHJvbWlzZShwYXJhbXMpIHtcbiAgICAgIHZhciBvcHRzID0gbm9ybWFsaXplT3B0aW9ucyhwYXJhbXMub3B0aW9ucyk7XG5cbiAgICAgIHZhciB1cmwgPSAocGFyYW1zLnNxbCkgPyBidWlsZFRlbXBsYXRlKFtcbiAgICAgICAgICAgICAgICAgIGJ1aWxkVGVtcGxhdGUob3B0cy5hcGlyb290LCBvcHRzKSxcbiAgICAgICAgICAgICAgICAgIFwic3FsXCIsXG4gICAgICAgICAgICAgICAgICBcIj9mb3JtYXQ9XCIgKyBvcHRzLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIFwiJnE9XCIgKyBwYXJhbXMuc3FsXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpLCBvcHRzKSA6IHBhcmFtcy51cmw7XG5cbiAgICAgIHZhciBrZXkgPSBwYXJhbXMua2V5O1xuXG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgIC8vIERvIHRoZSB1c3VhbCBYSFIgc3R1ZmZcbiAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCk7XG5cbiAgICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNhbGxlZCBldmVuIG9uIDQwNCBldGNcbiAgICAgICAgICAgIC8vIHNvIGNoZWNrIHRoZSBzdGF0dXNcbiAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3BvbnNlIHRleHRcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHJlcS5yZXNwb25zZSB8fCByZXEucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICAgIGlkOiBrZXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlamVjdCB3aXRoIHRoZSBzdGF0dXMgdGV4dFxuICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIGhvcGVmdWxseSBiZSBhIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBFcnJvcihyZXEuc3RhdHVzVGV4dCksXG4gICAgICAgICAgICAgICAgaWQ6IGtleVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSGFuZGxlIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IEVycm9yKFwiTmV0d29yayBFcnJvclwiKSxcbiAgICAgICAgICAgICAgaWQ6IGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXEuc2VuZCgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgIHBheWxvYWQ6IEVycm9yKFwiWE1MSHR0cFJlcXVlc3Qgbm90IHN1cHBvcnRlZFwiKSxcbiAgICAgICAgICAgIGlkOiBrZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cblxuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhfb3B0aW9ucykge1xuICAgICAgX29wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHJzcCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gKF9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpID8gX29wdGlvbnNba2V5XSA6IG9wdGlvbnNba2V5XTtcbiAgICAgICAgcnNwW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzcDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFB1YmxpYyBpbnRlcmZhY2VcbiAgICAvL1xuICAgIHRoYXQuc3FsUmVxdWVzdCA9IHNxbFJlcXVlc3Q7XG4gICAgdGhhdC5yZXF1ZXN0UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlO1xuICAgIHRoYXQucmVxdWVzdFByb21pc2VQYXJhbGxlbCA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHF1ZXVlLm1hcChmdW5jdGlvbihxKXtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdFByb21pc2UocSkudGhlbihmdW5jdGlvbihyc3ApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlOiByc3AsXG4gICAgICAgICAgICAgIGtleTogcnNwLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9O1xuXG4gICAgdGhhdC5yZXF1ZXN0UHJvbWlzZUpTT04gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0UHJvbWlzZShwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocnNwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzcG9uc2U6IEpTT04ucGFyc2UocnNwLnBheWxvYWQpLFxuICAgICAgICAgIGtleTogcnNwLmlkXG4gICAgICAgIH07XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGF0LnJlcXVlc3RQcm9taXNlUGFyYWxsZWxKU09OID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgcXVldWUubWFwKHRoYXQucmVxdWVzdFByb21pc2VKU09OKVxuICAgICAgKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhhdDtcblxuICB9XG5cblxuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENhcnRvREJDbGllbnQ7XG4gIH1cblxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGFuIEFNRCBtb2R1bGVcbiAgLy9cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRlZmluZShDYXJ0b0RCQ2xpZW50KTtcbiAgfVxuXG4gIC8vXG4gIC8vIElmIGp1c3QgZXhwb3J0cyBhbmQgaXQncyBhbiBvYmplY3RcbiAgLy9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBleHBvcnRzLkNhcnRvREJDbGllbnQgPSBDYXJ0b0RCQ2xpZW50O1xuICB9XG5cbiAgLy9cbiAgLy8gSWYgbm9uZSBvZiB0aG9zZSwgYWRkIGl0IHRvIFdpbmRvdyAoYXMgbG9uZyBhcyB0aGVyZSBpcyBub3RoaW5nIG5hbWVkIHNhbWVzaWVzKVxuICAvL1xuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoIXdpbmRvdy5TVE1OKSB7XG4gICAgICB3aW5kb3cuU1RNTiA9IHt9O1xuICAgIH1cbiAgICB3aW5kb3cuU1RNTi5DYXJ0b0RCQ2xpZW50ID0gQ2FydG9EQkNsaWVudDtcbiAgfVxuXG59KCkpOyIsIiFmdW5jdGlvbigpIHtcbiAgdmFyIGQzID0ge1xuICAgIHZlcnNpb246IFwiMy41LjE2XCJcbiAgfTtcbiAgdmFyIGQzX2FycmF5U2xpY2UgPSBbXS5zbGljZSwgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgcmV0dXJuIGQzX2FycmF5U2xpY2UuY2FsbChsaXN0KTtcbiAgfTtcbiAgdmFyIGQzX2RvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgZnVuY3Rpb24gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUuZG9jdW1lbnQgfHwgbm9kZSkuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3dpbmRvdyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgbm9kZS5kb2N1bWVudCAmJiBub2RlIHx8IG5vZGUuZGVmYXVsdFZpZXcpO1xuICB9XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBkM19hcnJheShkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcylbMF0ubm9kZVR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciBpID0gbGlzdC5sZW5ndGgsIGFycmF5ID0gbmV3IEFycmF5KGkpO1xuICAgICAgICB3aGlsZSAoaS0tKSBhcnJheVtpXSA9IGxpc3RbaV07XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICghRGF0ZS5ub3cpIERhdGUubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICB9O1xuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgZDNfZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKS5zdHlsZS5zZXRQcm9wZXJ0eShcIm9wYWNpdHlcIiwgMCwgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHZhciBkM19lbGVtZW50X3Byb3RvdHlwZSA9IHRoaXMuRWxlbWVudC5wcm90b3R5cGUsIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlLCBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsIGQzX3N0eWxlX3Byb3RvdHlwZSA9IHRoaXMuQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUsIGQzX3N0eWxlX3NldFByb3BlcnR5ID0gZDNfc3R5bGVfcHJvdG90eXBlLnNldFByb3BlcnR5O1xuICAgICAgZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24oc3BhY2UsIGxvY2FsLCB2YWx1ZSkge1xuICAgICAgICBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgc3BhY2UsIGxvY2FsLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIGQzX3N0eWxlX3Byb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgICBkM19zdHlsZV9zZXRQcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlICsgXCJcIiwgcHJpb3JpdHkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZDMuYXNjZW5kaW5nID0gZDNfYXNjZW5kaW5nO1xuICBmdW5jdGlvbiBkM19hc2NlbmRpbmcoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbiAgfVxuICBkMy5kZXNjZW5kaW5nID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbiAgfTtcbiAgZDMubWluID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIGQzLm1heCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID4gYSkgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBkMy5leHRlbnQgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGIsIGM7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGMgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIGEgPSBiO1xuICAgICAgICBpZiAoYyA8IGIpIGMgPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsgYSwgYyBdO1xuICB9O1xuICBmdW5jdGlvbiBkM19udW1iZXIoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbnVtZXJpYyh4KSB7XG4gICAgcmV0dXJuICFpc05hTih4KTtcbiAgfVxuICBkMy5zdW0gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBzID0gMCwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9ICthcnJheVtpXSkpIHMgKz0gYTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSArZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSBzICs9IGE7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuICBkMy5tZWFuID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMSwgaiA9IG47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfVxuICAgIGlmIChqKSByZXR1cm4gcyAvIGo7XG4gIH07XG4gIGQzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBwKSB7XG4gICAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsIGggPSBNYXRoLmZsb29yKEgpLCB2ID0gK3ZhbHVlc1toIC0gMV0sIGUgPSBIIC0gaDtcbiAgICByZXR1cm4gZSA/IHYgKyBlICogKHZhbHVlc1toXSAtIHYpIDogdjtcbiAgfTtcbiAgZDMubWVkaWFuID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgbnVtYmVycyA9IFtdLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkgbnVtYmVycy5wdXNoKGEpO1xuICAgIH1cbiAgICBpZiAobnVtYmVycy5sZW5ndGgpIHJldHVybiBkMy5xdWFudGlsZShudW1iZXJzLnNvcnQoZDNfYXNjZW5kaW5nKSwgLjUpO1xuICB9O1xuICBkMy52YXJpYW5jZSA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGgsIG0gPSAwLCBhLCBkLCBzID0gMCwgaSA9IC0xLCBqID0gMDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaiA+IDEpIHJldHVybiBzIC8gKGogLSAxKTtcbiAgfTtcbiAgZDMuZGV2aWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBkMy52YXJpYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfYmlzZWN0b3IoY29tcGFyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBsbyA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxOyBlbHNlIGhpID0gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICAgIH0sXG4gICAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgbG8gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkOyBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfYmlzZWN0ID0gZDNfYmlzZWN0b3IoZDNfYXNjZW5kaW5nKTtcbiAgZDMuYmlzZWN0TGVmdCA9IGQzX2Jpc2VjdC5sZWZ0O1xuICBkMy5iaXNlY3QgPSBkMy5iaXNlY3RSaWdodCA9IGQzX2Jpc2VjdC5yaWdodDtcbiAgZDMuYmlzZWN0b3IgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGQzX2Jpc2VjdG9yKGYubGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZCwgeCkge1xuICAgICAgcmV0dXJuIGQzX2FzY2VuZGluZyhmKGQpLCB4KTtcbiAgICB9IDogZik7XG4gIH07XG4gIGQzLnNodWZmbGUgPSBmdW5jdGlvbihhcnJheSwgaTAsIGkxKSB7XG4gICAgaWYgKChtID0gYXJndW1lbnRzLmxlbmd0aCkgPCAzKSB7XG4gICAgICBpMSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChtIDwgMikgaTAgPSAwO1xuICAgIH1cbiAgICB2YXIgbSA9IGkxIC0gaTAsIHQsIGk7XG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgIHQgPSBhcnJheVttICsgaTBdLCBhcnJheVttICsgaTBdID0gYXJyYXlbaSArIGkwXSwgYXJyYXlbaSArIGkwXSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcbiAgZDMucGVybXV0ZSA9IGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgdmFyIGkgPSBpbmRleGVzLmxlbmd0aCwgcGVybXV0ZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgICByZXR1cm4gcGVybXV0ZXM7XG4gIH07XG4gIGQzLnBhaXJzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwMCwgcDEgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gICAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IFsgcDAgPSBwMSwgcDEgPSBhcnJheVsrK2ldIF07XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuICBkMy50cmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpIHJldHVybiBbXTtcbiAgICBmb3IgKHZhciBpID0gLTEsIG0gPSBkMy5taW4obWF0cml4LCBkM190cmFuc3Bvc2VMZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07ICkge1xuICAgICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47ICkge1xuICAgICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3Bvc2U7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zcG9zZUxlbmd0aChkKSB7XG4gICAgcmV0dXJuIGQubGVuZ3RoO1xuICB9XG4gIGQzLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy50cmFuc3Bvc2UoYXJndW1lbnRzKTtcbiAgfTtcbiAgZDMua2V5cyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG4gIGQzLnZhbHVlcyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcbiAgZDMuZW50cmllcyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkgZW50cmllcy5wdXNoKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IG1hcFtrZXldXG4gICAgfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH07XG4gIGQzLm1lcmdlID0gZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLCBtLCBpID0gLTEsIGogPSAwLCBtZXJnZWQsIGFycmF5O1xuICAgIHdoaWxlICgrK2kgPCBuKSBqICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gICAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgICBtID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH07XG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgZDMucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgc3RlcCA9IDE7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoXCJpbmZpbml0ZSByYW5nZVwiKTtcbiAgICB2YXIgcmFuZ2UgPSBbXSwgayA9IGQzX3JhbmdlX2ludGVnZXJTY2FsZShhYnMoc3RlcCkpLCBpID0gLTEsIGo7XG4gICAgc3RhcnQgKj0gaywgc3RvcCAqPSBrLCBzdGVwICo9IGs7XG4gICAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqIC8gayk7IGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaiAvIGspO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfcmFuZ2VfaW50ZWdlclNjYWxlKHgpIHtcbiAgICB2YXIgayA9IDE7XG4gICAgd2hpbGUgKHggKiBrICUgMSkgayAqPSAxMDtcbiAgICByZXR1cm4gaztcbiAgfVxuICBmdW5jdGlvbiBkM19jbGFzcyhjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwga2V5LCB7XG4gICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZDMubWFwID0gZnVuY3Rpb24ob2JqZWN0LCBmKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBkM19NYXAoKTtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgZDNfTWFwKSB7XG4gICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGgsIG87XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTsgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmLmNhbGwob2JqZWN0LCBvID0gb2JqZWN0W2ldLCBpKSwgbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX01hcCgpIHtcbiAgICB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHZhciBkM19tYXBfcHJvdG8gPSBcIl9fcHJvdG9fX1wiLCBkM19tYXBfemVybyA9IFwiXFx4MDBcIjtcbiAgZDNfY2xhc3MoZDNfTWFwLCB7XG4gICAgaGFzOiBkM19tYXBfaGFzLFxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5KV07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkpXSA9IHZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBkM19tYXBfcmVtb3ZlLFxuICAgIGtleXM6IGQzX21hcF9rZXlzLFxuICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSB2YWx1ZXMucHVzaCh0aGlzLl9ba2V5XSk7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG4gICAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZW50cmllcy5wdXNoKHtcbiAgICAgICAga2V5OiBkM19tYXBfdW5lc2NhcGUoa2V5KSxcbiAgICAgICAgdmFsdWU6IHRoaXMuX1trZXldXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgIH0sXG4gICAgc2l6ZTogZDNfbWFwX3NpemUsXG4gICAgZW1wdHk6IGQzX21hcF9lbXB0eSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBmLmNhbGwodGhpcywgZDNfbWFwX3VuZXNjYXBlKGtleSksIHRoaXMuX1trZXldKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBkM19tYXBfZXNjYXBlKGtleSkge1xuICAgIHJldHVybiAoa2V5ICs9IFwiXCIpID09PSBkM19tYXBfcHJvdG8gfHwga2V5WzBdID09PSBkM19tYXBfemVybyA/IGQzX21hcF96ZXJvICsga2V5IDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF91bmVzY2FwZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSArPSBcIlwiKVswXSA9PT0gZDNfbWFwX3plcm8gPyBrZXkuc2xpY2UoMSkgOiBrZXk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2hhcyhrZXkpIHtcbiAgICByZXR1cm4gZDNfbWFwX2VzY2FwZShrZXkpIGluIHRoaXMuXztcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfcmVtb3ZlKGtleSkge1xuICAgIHJldHVybiAoa2V5ID0gZDNfbWFwX2VzY2FwZShrZXkpKSBpbiB0aGlzLl8gJiYgZGVsZXRlIHRoaXMuX1trZXldO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9rZXlzKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykga2V5cy5wdXNoKGQzX21hcF91bmVzY2FwZShrZXkpKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfc2l6ZSgpIHtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9lbXB0eSgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZDMubmVzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXN0ID0ge30sIGtleXMgPSBbXSwgc29ydEtleXMgPSBbXSwgc29ydFZhbHVlcywgcm9sbHVwO1xuICAgIGZ1bmN0aW9uIG1hcChtYXBUeXBlLCBhcnJheSwgZGVwdGgpIHtcbiAgICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHJvbGx1cCA/IHJvbGx1cC5jYWxsKG5lc3QsIGFycmF5KSA6IHNvcnRWYWx1ZXMgPyBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpIDogYXJyYXk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBrZXkgPSBrZXlzW2RlcHRoKytdLCBrZXlWYWx1ZSwgb2JqZWN0LCBzZXR0ZXIsIHZhbHVlc0J5S2V5ID0gbmV3IGQzX01hcCgpLCB2YWx1ZXM7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KG9iamVjdCA9IGFycmF5W2ldKSkpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlc0J5S2V5LnNldChrZXlWYWx1ZSwgWyBvYmplY3QgXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXBUeXBlKSB7XG4gICAgICAgIG9iamVjdCA9IG1hcFR5cGUoKTtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24oa2V5VmFsdWUsIHZhbHVlcykge1xuICAgICAgICAgIG9iamVjdC5zZXQoa2V5VmFsdWUsIG1hcChtYXBUeXBlLCB2YWx1ZXMsIGRlcHRoKSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24oa2V5VmFsdWUsIHZhbHVlcykge1xuICAgICAgICAgIG9iamVjdFtrZXlWYWx1ZV0gPSBtYXAobWFwVHlwZSwgdmFsdWVzLCBkZXB0aCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZXNCeUtleS5mb3JFYWNoKHNldHRlcik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRyaWVzKG1hcCwgZGVwdGgpIHtcbiAgICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcbiAgICAgIHZhciBhcnJheSA9IFtdLCBzb3J0S2V5ID0gc29ydEtleXNbZGVwdGgrK107XG4gICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbihrZXksIGtleU1hcCkge1xuICAgICAgICBhcnJheS5wdXNoKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZXM6IGVudHJpZXMoa2V5TWFwLCBkZXB0aClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3J0S2V5ID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7XG4gICAgICB9KSA6IGFycmF5O1xuICAgIH1cbiAgICBuZXN0Lm1hcCA9IGZ1bmN0aW9uKGFycmF5LCBtYXBUeXBlKSB7XG4gICAgICByZXR1cm4gbWFwKG1hcFR5cGUsIGFycmF5LCAwKTtcbiAgICB9O1xuICAgIG5lc3QuZW50cmllcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICByZXR1cm4gZW50cmllcyhtYXAoZDMubWFwLCBhcnJheSwgMCksIDApO1xuICAgIH07XG4gICAgbmVzdC5rZXkgPSBmdW5jdGlvbihkKSB7XG4gICAgICBrZXlzLnB1c2goZCk7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Quc29ydEtleXMgPSBmdW5jdGlvbihvcmRlcikge1xuICAgICAgc29ydEtleXNba2V5cy5sZW5ndGggLSAxXSA9IG9yZGVyO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihvcmRlcikge1xuICAgICAgc29ydFZhbHVlcyA9IG9yZGVyO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnJvbGx1cCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJvbGx1cCA9IGY7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIHJldHVybiBuZXN0O1xuICB9O1xuICBkMy5zZXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBzZXQgPSBuZXcgZDNfU2V0KCk7XG4gICAgaWYgKGFycmF5KSBmb3IgKHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aDsgaSA8IG47ICsraSkgc2V0LmFkZChhcnJheVtpXSk7XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfU2V0KCkge1xuICAgIHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZDNfY2xhc3MoZDNfU2V0LCB7XG4gICAgaGFzOiBkM19tYXBfaGFzLFxuICAgIGFkZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkgKz0gXCJcIildID0gdHJ1ZTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSxcbiAgICByZW1vdmU6IGQzX21hcF9yZW1vdmUsXG4gICAgdmFsdWVzOiBkM19tYXBfa2V5cyxcbiAgICBzaXplOiBkM19tYXBfc2l6ZSxcbiAgICBlbXB0eTogZDNfbWFwX2VtcHR5LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGYuY2FsbCh0aGlzLCBkM19tYXBfdW5lc2NhcGUoa2V5KSk7XG4gICAgfVxuICB9KTtcbiAgZDMuYmVoYXZpb3IgPSB7fTtcbiAgZnVuY3Rpb24gZDNfaWRlbnRpdHkoZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIGQzLnJlYmluZCA9IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0aG9kO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0YXJnZXRbbWV0aG9kID0gYXJndW1lbnRzW2ldXSA9IGQzX3JlYmluZCh0YXJnZXQsIHNvdXJjZSwgc291cmNlW21ldGhvZF0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JlYmluZCh0YXJnZXQsIHNvdXJjZSwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gbWV0aG9kLmFwcGx5KHNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gc291cmNlID8gdGFyZ2V0IDogdmFsdWU7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM192ZW5kb3JTeW1ib2wob2JqZWN0LCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gb2JqZWN0KSByZXR1cm4gbmFtZTtcbiAgICBuYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBkM192ZW5kb3JQcmVmaXhlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBwcmVmaXhOYW1lID0gZDNfdmVuZG9yUHJlZml4ZXNbaV0gKyBuYW1lO1xuICAgICAgaWYgKHByZWZpeE5hbWUgaW4gb2JqZWN0KSByZXR1cm4gcHJlZml4TmFtZTtcbiAgICB9XG4gIH1cbiAgdmFyIGQzX3ZlbmRvclByZWZpeGVzID0gWyBcIndlYmtpdFwiLCBcIm1zXCIsIFwibW96XCIsIFwiTW96XCIsIFwib1wiLCBcIk9cIiBdO1xuICBmdW5jdGlvbiBkM19ub29wKCkge31cbiAgZDMuZGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2goKSwgaSA9IC0xLCBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgZGlzcGF0Y2hbYXJndW1lbnRzW2ldXSA9IGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2g7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Rpc3BhdGNoKCkge31cbiAgZDNfZGlzcGF0Y2gucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IHR5cGUuaW5kZXhPZihcIi5cIiksIG5hbWUgPSBcIlwiO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIG5hbWUgPSB0eXBlLnNsaWNlKGkgKyAxKTtcbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpO1xuICAgIH1cbiAgICBpZiAodHlwZSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdGhpc1t0eXBlXS5vbihuYW1lKSA6IHRoaXNbdHlwZV0ub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkgZm9yICh0eXBlIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHRoaXNbdHlwZV0ub24obmFtZSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IFtdLCBsaXN0ZW5lckJ5TmFtZSA9IG5ldyBkM19NYXAoKTtcbiAgICBmdW5jdGlvbiBldmVudCgpIHtcbiAgICAgIHZhciB6ID0gbGlzdGVuZXJzLCBpID0gLTEsIG4gPSB6Lmxlbmd0aCwgbDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAobCA9IHpbaV0ub24pIGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaDtcbiAgICB9XG4gICAgZXZlbnQub24gPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGwgPSBsaXN0ZW5lckJ5TmFtZS5nZXQobmFtZSksIGk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBsICYmIGwub247XG4gICAgICBpZiAobCkge1xuICAgICAgICBsLm9uID0gbnVsbDtcbiAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKDAsIGkgPSBsaXN0ZW5lcnMuaW5kZXhPZihsKSkuY29uY2F0KGxpc3RlbmVycy5zbGljZShpICsgMSkpO1xuICAgICAgICBsaXN0ZW5lckJ5TmFtZS5yZW1vdmUobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAobGlzdGVuZXIpIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyQnlOYW1lLnNldChuYW1lLCB7XG4gICAgICAgIG9uOiBsaXN0ZW5lclxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoO1xuICAgIH07XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGQzLmV2ZW50ID0gbnVsbDtcbiAgZnVuY3Rpb24gZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2V2ZW50U291cmNlKCkge1xuICAgIHZhciBlID0gZDMuZXZlbnQsIHM7XG4gICAgd2hpbGUgKHMgPSBlLnNvdXJjZUV2ZW50KSBlID0gcztcbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBkM19ldmVudERpc3BhdGNoKHRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaCA9IG5ldyBkM19kaXNwYXRjaCgpLCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gICAgZGlzcGF0Y2gub2YgPSBmdW5jdGlvbih0aGl6LCBhcmd1bWVudHopIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBlMCA9IGUxLnNvdXJjZUV2ZW50ID0gZDMuZXZlbnQ7XG4gICAgICAgICAgZTEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIGQzLmV2ZW50ID0gZTE7XG4gICAgICAgICAgZGlzcGF0Y2hbZTEudHlwZV0uYXBwbHkodGhpeiwgYXJndW1lbnR6KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkMy5ldmVudCA9IGUwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9XG4gIGQzLnJlcXVvdGUgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShkM19yZXF1b3RlX3JlLCBcIlxcXFwkJlwiKTtcbiAgfTtcbiAgdmFyIGQzX3JlcXVvdGVfcmUgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG4gIHZhciBkM19zdWJjbGFzcyA9IHt9Ll9fcHJvdG9fXyA/IGZ1bmN0aW9uKG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgfSA6IGZ1bmN0aW9uKG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvdG90eXBlKSBvYmplY3RbcHJvcGVydHldID0gcHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uKGdyb3Vwcykge1xuICAgIGQzX3N1YmNsYXNzKGdyb3VwcywgZDNfc2VsZWN0aW9uUHJvdG90eXBlKTtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIHZhciBkM19zZWxlY3QgPSBmdW5jdGlvbihzLCBuKSB7XG4gICAgcmV0dXJuIG4ucXVlcnlTZWxlY3RvcihzKTtcbiAgfSwgZDNfc2VsZWN0QWxsID0gZnVuY3Rpb24ocywgbikge1xuICAgIHJldHVybiBuLnF1ZXJ5U2VsZWN0b3JBbGwocyk7XG4gIH0sIGQzX3NlbGVjdE1hdGNoZXMgPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgdmFyIGQzX3NlbGVjdE1hdGNoZXIgPSBuLm1hdGNoZXMgfHwgbltkM192ZW5kb3JTeW1ib2wobiwgXCJtYXRjaGVzU2VsZWN0b3JcIildO1xuICAgIGQzX3NlbGVjdE1hdGNoZXMgPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlci5jYWxsKG4sIHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXMobiwgcyk7XG4gIH07XG4gIGlmICh0eXBlb2YgU2l6emxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkM19zZWxlY3QgPSBmdW5jdGlvbihzLCBuKSB7XG4gICAgICByZXR1cm4gU2l6emxlKHMsIG4pWzBdIHx8IG51bGw7XG4gICAgfTtcbiAgICBkM19zZWxlY3RBbGwgPSBTaXp6bGU7XG4gICAgZDNfc2VsZWN0TWF0Y2hlcyA9IFNpenpsZS5tYXRjaGVzU2VsZWN0b3I7XG4gIH1cbiAgZDMuc2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNlbGVjdChkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICB9O1xuICB2YXIgZDNfc2VsZWN0aW9uUHJvdG90eXBlID0gZDMuc2VsZWN0aW9uLnByb3RvdHlwZSA9IFtdO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCBncm91cCwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICAgICAgICBpZiAoc3Vibm9kZSAmJiBcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0KHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gZDNfYXJyYXkoc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpO1xuICAgICAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0b3IgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RBbGwoc2VsZWN0b3IsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX25zWGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgdmFyIGQzX25zUHJlZml4ID0ge1xuICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHhodG1sOiBkM19uc1hodG1sLFxuICAgIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxuICB9O1xuICBkMy5ucyA9IHtcbiAgICBwcmVmaXg6IGQzX25zUHJlZml4LFxuICAgIHF1YWxpZnk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiOlwiKSwgcHJlZml4ID0gbmFtZTtcbiAgICAgIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiBkM19uc1ByZWZpeC5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge1xuICAgICAgICBzcGFjZTogZDNfbnNQcmVmaXhbcHJlZml4XSxcbiAgICAgICAgbG9jYWw6IG5hbWVcbiAgICAgIH0gOiBuYW1lO1xuICAgIH1cbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZS5sb2NhbCA/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCkgOiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9hdHRyKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKTtcbiAgICBmdW5jdGlvbiBhdHRyTnVsbCgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyTnVsbE5TKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckNvbnN0YW50KCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyQ29uc3RhbnROUygpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpOyBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgeCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbmFtZS5sb2NhbCA/IGF0dHJOdWxsTlMgOiBhdHRyTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uIDogbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2NvbGxhcHNlKHMpIHtcbiAgICByZXR1cm4gcy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNsYXNzZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCksIG4gPSAobmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpKS5sZW5ndGgsIGkgPSAtMTtcbiAgICAgICAgaWYgKHZhbHVlID0gbm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCF2YWx1ZS5jb250YWlucyhuYW1lW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWVbaV0pLnRlc3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fY2xhc3NlZCh2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XnxcXFxccyspXCIgKyBkMy5yZXF1b3RlKG5hbWUpICsgXCIoPzpcXFxccyt8JClcIiwgXCJnXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpLm1hcChkM19zZWxlY3Rpb25fY2xhc3NlZE5hbWUpO1xuICAgIHZhciBuID0gbmFtZS5sZW5ndGg7XG4gICAgZnVuY3Rpb24gY2xhc3NlZENvbnN0YW50KCkge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBuYW1lW2ldKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSAtMSwgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoKytpIDwgbikgbmFtZVtpXSh0aGlzLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xhc3NlZEZ1bmN0aW9uIDogY2xhc3NlZENvbnN0YW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZShuYW1lKSB7XG4gICAgdmFyIHJlID0gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmIChjID0gbm9kZS5jbGFzc0xpc3QpIHJldHVybiB2YWx1ZSA/IGMuYWRkKG5hbWUpIDogYy5yZW1vdmUobmFtZSk7XG4gICAgICB2YXIgYyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoIXJlLnRlc3QoYykpIG5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZDNfY29sbGFwc2UoYyArIFwiIFwiICsgbmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjLnJlcGxhY2UocmUsIFwiIFwiKSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHByaW9yaXR5IGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fc3R5bGUocHJpb3JpdHksIG5hbWVbcHJpb3JpdHldLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMikge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgICAgICByZXR1cm4gZDNfd2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIHByaW9yaXR5ID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICBmdW5jdGlvbiBzdHlsZU51bGwoKSB7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZUNvbnN0YW50KCkge1xuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTsgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHgsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBzdHlsZU51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlRnVuY3Rpb24gOiBzdHlsZUNvbnN0YW50O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHJldHVybiB0aGlzLm5vZGUoKVtuYW1lXTtcbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9wcm9wZXJ0eSh2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU51bGwoKSB7XG4gICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudCgpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdOyBlbHNlIHRoaXNbbmFtZV0gPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHByb3BlcnR5TnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gcHJvcGVydHlGdW5jdGlvbiA6IHByb3BlcnR5Q29uc3RhbnQ7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gICAgfSA6IHZhbHVlID09IG51bGwgPyBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9KSA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gICAgfSA6IHZhbHVlID09IG51bGwgPyBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH0pIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChuYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICAgIHJldHVybiBuYW1lc3BhY2UgPT09IGQzX25zWGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gZDNfbnNYaHRtbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCBuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTlMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogKG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpKS5sb2NhbCA/IGNyZWF0ZU5TIDogY3JlYXRlO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSk7XG4gICAgYmVmb3JlID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKGJlZm9yZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gICAgfSk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvblJlbW92ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvblJlbW92ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIGdyb3VwLCBub2RlO1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBuZXcgQXJyYXkobiA9IChncm91cCA9IHRoaXNbMF0pLmxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdmFsdWVbaV0gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpbmQoZ3JvdXAsIGdyb3VwRGF0YSkge1xuICAgICAgdmFyIGksIG4gPSBncm91cC5sZW5ndGgsIG0gPSBncm91cERhdGEubGVuZ3RoLCBuMCA9IE1hdGgubWluKG4sIG0pLCB1cGRhdGVOb2RlcyA9IG5ldyBBcnJheShtKSwgZW50ZXJOb2RlcyA9IG5ldyBBcnJheShtKSwgZXhpdE5vZGVzID0gbmV3IEFycmF5KG4pLCBub2RlLCBub2RlRGF0YTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIG5vZGVCeUtleVZhbHVlID0gbmV3IGQzX01hcCgpLCBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkobiksIGtleVZhbHVlO1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjsgKSB7XG4gICAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpKSkge1xuICAgICAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbTsgKSB7XG4gICAgICAgICAgaWYgKCEobm9kZSA9IG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZSA9IGtleS5jYWxsKGdyb3VwRGF0YSwgbm9kZURhdGEgPSBncm91cERhdGFbaV0sIGkpKSkpIHtcbiAgICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5fX2RhdGFfXyA9IG5vZGVEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuOyApIHtcbiAgICAgICAgICBpZiAoaSBpbiBrZXlWYWx1ZXMgJiYgbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlc1tpXSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG4wOyApIHtcbiAgICAgICAgICBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgICAgbm9kZURhdGEgPSBncm91cERhdGFbaV07XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShub2RlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoO2kgPCBtOyArK2kpIHtcbiAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKGdyb3VwRGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7aSA8IG47ICsraSkge1xuICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbnRlck5vZGVzLnVwZGF0ZSA9IHVwZGF0ZU5vZGVzO1xuICAgICAgZW50ZXJOb2Rlcy5wYXJlbnROb2RlID0gdXBkYXRlTm9kZXMucGFyZW50Tm9kZSA9IGV4aXROb2Rlcy5wYXJlbnROb2RlID0gZ3JvdXAucGFyZW50Tm9kZTtcbiAgICAgIGVudGVyLnB1c2goZW50ZXJOb2Rlcyk7XG4gICAgICB1cGRhdGUucHVzaCh1cGRhdGVOb2Rlcyk7XG4gICAgICBleGl0LnB1c2goZXhpdE5vZGVzKTtcbiAgICB9XG4gICAgdmFyIGVudGVyID0gZDNfc2VsZWN0aW9uX2VudGVyKFtdKSwgdXBkYXRlID0gZDNfc2VsZWN0aW9uKFtdKSwgZXhpdCA9IGQzX3NlbGVjdGlvbihbXSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBiaW5kKGdyb3VwID0gdGhpc1tpXSwgdmFsdWUuY2FsbChncm91cCwgZ3JvdXAucGFyZW50Tm9kZS5fX2RhdGFfXywgaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBiaW5kKGdyb3VwID0gdGhpc1tpXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUuZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnRlcjtcbiAgICB9O1xuICAgIHVwZGF0ZS5leGl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhpdDtcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9kYXRhTm9kZShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fZGF0YV9fOiBkYXRhXG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZGF0dW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKSA6IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSAoZ3JvdXAgPSB0aGlzW2pdKS5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIGZpbHRlci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9maWx0ZXIoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlcyh0aGlzLCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgIGNvbXBhcmF0b3IgPSBkM19zZWxlY3Rpb25fc29ydENvbXBhcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB0aGlzW2pdLnNvcnQoY29tcGFyYXRvcik7XG4gICAgcmV0dXJuIHRoaXMub3JkZXIoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yKGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIGNvbXBhcmF0b3IgPSBkM19hc2NlbmRpbmc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJhdG9yKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VhY2goZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrKG5vZGUsIGksIGopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IGQzX2FycmF5KGFyZ3VtZW50cyk7XG4gICAgY2FsbGJhY2suYXBwbHkoYXJnc1swXSA9IHRoaXMsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMubm9kZSgpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICArK247XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lbnRlcihzZWxlY3Rpb24pIHtcbiAgICBkM19zdWJjbGFzcyhzZWxlY3Rpb24sIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICB2YXIgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlID0gW107XG4gIGQzLnNlbGVjdGlvbi5lbnRlciA9IGQzX3NlbGVjdGlvbl9lbnRlcjtcbiAgZDMuc2VsZWN0aW9uLmVudGVyLnByb3RvdHlwZSA9IGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmFwcGVuZCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQ7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLm5vZGUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmNhbGwgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgdXBncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgdXBncm91cCA9IChncm91cCA9IHRoaXNbal0pLnVwZGF0ZTtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IGdyb3VwLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaCh1cGdyb3VwW2ldID0gc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwoZ3JvdXAucGFyZW50Tm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICAgIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBiZWZvcmUgPSBkM19zZWxlY3Rpb25fZW50ZXJJbnNlcnRCZWZvcmUodGhpcyk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLCBuYW1lLCBiZWZvcmUpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXJJbnNlcnRCZWZvcmUoZW50ZXIpIHtcbiAgICB2YXIgaTAsIGowO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpLCBqKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBlbnRlcltqXS51cGRhdGUsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7XG4gICAgICBpZiAoaiAhPSBqMCkgajAgPSBqLCBpMCA9IDA7XG4gICAgICBpZiAoaSA+PSBpMCkgaTAgPSBpICsgMTtcbiAgICAgIHdoaWxlICghKG5vZGUgPSBncm91cFtpMF0pICYmICsraTAgPCBuKSA7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICB9XG4gIGQzLnNlbGVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cCA9IFsgZDNfc2VsZWN0KG5vZGUsIGQzX2RvY3VtZW50KSBdO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSBbIG5vZGUgXTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oWyBncm91cCBdKTtcbiAgfTtcbiAgZDMuc2VsZWN0QWxsID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZ3JvdXAgPSBkM19hcnJheShkM19zZWxlY3RBbGwobm9kZXMsIGQzX2RvY3VtZW50KSk7XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9IGQzX2FycmF5KG5vZGVzKTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgbGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjYXB0dXJlIGluIHR5cGUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24oY2FwdHVyZSwgdHlwZVtjYXB0dXJlXSwgbGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDIpIHJldHVybiAobiA9IHRoaXMubm9kZSgpW1wiX19vblwiICsgdHlwZV0pICYmIG4uXztcbiAgICAgIGNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG5hbWUgPSBcIl9fb25cIiArIHR5cGUsIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXI7XG4gICAgaWYgKGkgPiAwKSB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB2YXIgZmlsdGVyID0gZDNfc2VsZWN0aW9uX29uRmlsdGVycy5nZXQodHlwZSk7XG4gICAgaWYgKGZpbHRlcikgdHlwZSA9IGZpbHRlciwgd3JhcCA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcjtcbiAgICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsLCBsLiQpO1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25BZGQoKSB7XG4gICAgICB2YXIgbCA9IHdyYXAobGlzdGVuZXIsIGQzX2FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgb25SZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzW25hbWVdID0gbCwgbC4kID0gY2FwdHVyZSk7XG4gICAgICBsLl8gPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5fX29uKFteLl0rKVwiICsgZDMucmVxdW90ZSh0eXBlKSArIFwiJFwiKSwgbWF0Y2g7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKG1hdGNoID0gbmFtZS5tYXRjaChyZSkpIHtcbiAgICAgICAgICB2YXIgbCA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG1hdGNoWzFdLCBsLCBsLiQpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpID8gbGlzdGVuZXIgPyBvbkFkZCA6IG9uUmVtb3ZlIDogbGlzdGVuZXIgPyBkM19ub29wIDogcmVtb3ZlQWxsO1xuICB9XG4gIHZhciBkM19zZWxlY3Rpb25fb25GaWx0ZXJzID0gZDMubWFwKHtcbiAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICB9KTtcbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChcIm9uXCIgKyBrIGluIGQzX2RvY3VtZW50KSBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLnJlbW92ZShrKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBvID0gZDMuZXZlbnQ7XG4gICAgICBkMy5ldmVudCA9IGU7XG4gICAgICBhcmd1bWVudHpbMF0gPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnR6KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbkZpbHRlcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgdmFyIGwgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAoIXJlbGF0ZWQgfHwgcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0YXJnZXQpICYgOCkpIHtcbiAgICAgICAgbC5jYWxsKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZXZlbnRfZHJhZ1NlbGVjdCwgZDNfZXZlbnRfZHJhZ0lkID0gMDtcbiAgZnVuY3Rpb24gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKG5vZGUpIHtcbiAgICB2YXIgbmFtZSA9IFwiLmRyYWdzdXBwcmVzcy1cIiArICsrZDNfZXZlbnRfZHJhZ0lkLCBjbGljayA9IFwiY2xpY2tcIiArIG5hbWUsIHcgPSBkMy5zZWxlY3QoZDNfd2luZG93KG5vZGUpKS5vbihcInRvdWNobW92ZVwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCkub24oXCJkcmFnc3RhcnRcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpLm9uKFwic2VsZWN0c3RhcnRcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpO1xuICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0ID09IG51bGwpIHtcbiAgICAgIGQzX2V2ZW50X2RyYWdTZWxlY3QgPSBcIm9uc2VsZWN0c3RhcnRcIiBpbiBub2RlID8gZmFsc2UgOiBkM192ZW5kb3JTeW1ib2wobm9kZS5zdHlsZSwgXCJ1c2VyU2VsZWN0XCIpO1xuICAgIH1cbiAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCkge1xuICAgICAgdmFyIHN0eWxlID0gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpLnN0eWxlLCBzZWxlY3QgPSBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XTtcbiAgICAgIHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihzdXBwcmVzc0NsaWNrKSB7XG4gICAgICB3Lm9uKG5hbWUsIG51bGwpO1xuICAgICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QpIHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdID0gc2VsZWN0O1xuICAgICAgaWYgKHN1cHByZXNzQ2xpY2spIHtcbiAgICAgICAgdmFyIG9mZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHcub24oY2xpY2ssIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICB3Lm9uKGNsaWNrLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBzZXRUaW1lb3V0KG9mZiwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkMy5tb3VzZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgZDNfZXZlbnRTb3VyY2UoKSk7XG4gIH07XG4gIHZhciBkM19tb3VzZV9idWc0NDA4MyA9IHRoaXMubmF2aWdhdG9yICYmIC9XZWJLaXQvLnRlc3QodGhpcy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IC0xIDogMDtcbiAgZnVuY3Rpb24gZDNfbW91c2VQb2ludChjb250YWluZXIsIGUpIHtcbiAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykgZSA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdmFyIHN2ZyA9IGNvbnRhaW5lci5vd25lclNWR0VsZW1lbnQgfHwgY29udGFpbmVyO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgaWYgKGQzX21vdXNlX2J1ZzQ0MDgzIDwgMCkge1xuICAgICAgICB2YXIgd2luZG93ID0gZDNfd2luZG93KGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh3aW5kb3cuc2Nyb2xsWCB8fCB3aW5kb3cuc2Nyb2xsWSkge1xuICAgICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCJcbiAgICAgICAgICB9LCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgICB2YXIgY3RtID0gc3ZnWzBdWzBdLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgIGQzX21vdXNlX2J1ZzQ0MDgzID0gIShjdG0uZiB8fCBjdG0uZSk7XG4gICAgICAgICAgc3ZnLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZDNfbW91c2VfYnVnNDQwODMpIHBvaW50LnggPSBlLnBhZ2VYLCBwb2ludC55ID0gZS5wYWdlWTsgZWxzZSBwb2ludC54ID0gZS5jbGllbnRYLCBcbiAgICAgIHBvaW50LnkgPSBlLmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShjb250YWluZXIuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbIHBvaW50LngsIHBvaW50LnkgXTtcbiAgICB9XG4gICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFsgZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcCBdO1xuICB9XG4gIGQzLnRvdWNoID0gZnVuY3Rpb24oY29udGFpbmVyLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IGQzX2V2ZW50U291cmNlKCkuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKHRvdWNoZXMpIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcy5sZW5ndGgsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gZDNfbW91c2VQb2ludChjb250YWluZXIsIHRvdWNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGQzLmJlaGF2aW9yLmRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKGRyYWcsIFwiZHJhZ1wiLCBcImRyYWdzdGFydFwiLCBcImRyYWdlbmRcIiksIG9yaWdpbiA9IG51bGwsIG1vdXNlZG93biA9IGRyYWdzdGFydChkM19ub29wLCBkMy5tb3VzZSwgZDNfd2luZG93LCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIiksIHRvdWNoc3RhcnQgPSBkcmFnc3RhcnQoZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQsIGQzLnRvdWNoLCBkM19pZGVudGl0eSwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiKTtcbiAgICBmdW5jdGlvbiBkcmFnKCkge1xuICAgICAgdGhpcy5vbihcIm1vdXNlZG93bi5kcmFnXCIsIG1vdXNlZG93bikub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYWdzdGFydChpZCwgcG9zaXRpb24sIHN1YmplY3QsIG1vdmUsIGVuZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHRhcmdldCA9IGQzLmV2ZW50LnRhcmdldC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBkMy5ldmVudC50YXJnZXQsIHBhcmVudCA9IHRoYXQucGFyZW50Tm9kZSwgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBkcmFnZ2VkID0gMCwgZHJhZ0lkID0gaWQoKSwgZHJhZ05hbWUgPSBcIi5kcmFnXCIgKyAoZHJhZ0lkID09IG51bGwgPyBcIlwiIDogXCItXCIgKyBkcmFnSWQpLCBkcmFnT2Zmc2V0LCBkcmFnU3ViamVjdCA9IGQzLnNlbGVjdChzdWJqZWN0KHRhcmdldCkpLm9uKG1vdmUgKyBkcmFnTmFtZSwgbW92ZWQpLm9uKGVuZCArIGRyYWdOYW1lLCBlbmRlZCksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRhcmdldCksIHBvc2l0aW9uMCA9IHBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBvcmlnaW4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gWyBkcmFnT2Zmc2V0LnggLSBwb3NpdGlvbjBbMF0sIGRyYWdPZmZzZXQueSAtIHBvc2l0aW9uMFsxXSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBbIDAsIDAgXTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogXCJkcmFnc3RhcnRcIlxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uMSA9IHBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKSwgZHgsIGR5O1xuICAgICAgICAgIGlmICghcG9zaXRpb24xKSByZXR1cm47XG4gICAgICAgICAgZHggPSBwb3NpdGlvbjFbMF0gLSBwb3NpdGlvbjBbMF07XG4gICAgICAgICAgZHkgPSBwb3NpdGlvbjFbMV0gLSBwb3NpdGlvbjBbMV07XG4gICAgICAgICAgZHJhZ2dlZCB8PSBkeCB8IGR5O1xuICAgICAgICAgIHBvc2l0aW9uMCA9IHBvc2l0aW9uMTtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBcImRyYWdcIixcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uMVswXSArIGRyYWdPZmZzZXRbMF0sXG4gICAgICAgICAgICB5OiBwb3NpdGlvbjFbMV0gKyBkcmFnT2Zmc2V0WzFdLFxuICAgICAgICAgICAgZHg6IGR4LFxuICAgICAgICAgICAgZHk6IGR5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCkpIHJldHVybjtcbiAgICAgICAgICBkcmFnU3ViamVjdC5vbihtb3ZlICsgZHJhZ05hbWUsIG51bGwpLm9uKGVuZCArIGRyYWdOYW1lLCBudWxsKTtcbiAgICAgICAgICBkcmFnUmVzdG9yZShkcmFnZ2VkKTtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBcImRyYWdlbmRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBkcmFnLm9yaWdpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWdpbjtcbiAgICAgIG9yaWdpbiA9IHg7XG4gICAgICByZXR1cm4gZHJhZztcbiAgICB9O1xuICAgIHJldHVybiBkMy5yZWJpbmQoZHJhZywgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2JlaGF2aW9yX2RyYWdUb3VjaElkKCkge1xuICAgIHJldHVybiBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICB9XG4gIGQzLnRvdWNoZXMgPSBmdW5jdGlvbihjb250YWluZXIsIHRvdWNoZXMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHRvdWNoZXMgPSBkM19ldmVudFNvdXJjZSgpLnRvdWNoZXM7XG4gICAgcmV0dXJuIHRvdWNoZXMgPyBkM19hcnJheSh0b3VjaGVzKS5tYXAoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHZhciBwb2ludCA9IGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCB0b3VjaCk7XG4gICAgICBwb2ludC5pZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9KSA6IFtdO1xuICB9O1xuICB2YXIgzrUgPSAxZS02LCDOtTIgPSDOtSAqIM61LCDPgCA9IE1hdGguUEksIM+EID0gMiAqIM+ALCDPhM61ID0gz4QgLSDOtSwgaGFsZs+AID0gz4AgLyAyLCBkM19yYWRpYW5zID0gz4AgLyAxODAsIGQzX2RlZ3JlZXMgPSAxODAgLyDPgDtcbiAgZnVuY3Rpb24gZDNfc2duKHgpIHtcbiAgICByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY3Jvc3MyZChhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pIC0gKGJbMV0gLSBhWzFdKSAqIChjWzBdIC0gYVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYWNvcyh4KSB7XG4gICAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IM+AIDogTWF0aC5hY29zKHgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2FzaW4oeCkge1xuICAgIHJldHVybiB4ID4gMSA/IGhhbGbPgCA6IHggPCAtMSA/IC1oYWxmz4AgOiBNYXRoLmFzaW4oeCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2luaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY29zaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGFuaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfaGF2ZXJzaW4oeCkge1xuICAgIHJldHVybiAoeCA9IE1hdGguc2luKHggLyAyKSkgKiB4O1xuICB9XG4gIHZhciDPgSA9IE1hdGguU1FSVDIsIM+BMiA9IDIsIM+BNCA9IDQ7XG4gIGQzLmludGVycG9sYXRlWm9vbSA9IGZ1bmN0aW9uKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSwgZHggPSB1eDEgLSB1eDAsIGR5ID0gdXkxIC0gdXkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCBpLCBTO1xuICAgIGlmIChkMiA8IM61Mikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gz4E7XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gWyB1eDAgKyB0ICogZHgsIHV5MCArIHQgKiBkeSwgdzAgKiBNYXRoLmV4cCjPgSAqIHQgKiBTKSBdO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSwgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyDPgTQgKiBkMikgLyAoMiAqIHcwICogz4EyICogZDEpLCBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIM+BNCAqIGQyKSAvICgyICogdzEgKiDPgTIgKiBkMSksIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSwgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIM+BO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUywgY29zaHIwID0gZDNfY29zaChyMCksIHUgPSB3MCAvICjPgTIgKiBkMSkgKiAoY29zaHIwICogZDNfdGFuaCjPgSAqIHMgKyByMCkgLSBkM19zaW5oKHIwKSk7XG4gICAgICAgIHJldHVybiBbIHV4MCArIHUgKiBkeCwgdXkwICsgdSAqIGR5LCB3MCAqIGNvc2hyMCAvIGQzX2Nvc2goz4EgKiBzICsgcjApIF07XG4gICAgICB9O1xuICAgIH1cbiAgICBpLmR1cmF0aW9uID0gUyAqIDFlMztcbiAgICByZXR1cm4gaTtcbiAgfTtcbiAgZDMuYmVoYXZpb3Iuem9vbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2aWV3ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBrOiAxXG4gICAgfSwgdHJhbnNsYXRlMCwgY2VudGVyMCwgY2VudGVyLCBzaXplID0gWyA5NjAsIDUwMCBdLCBzY2FsZUV4dGVudCA9IGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSwgZHVyYXRpb24gPSAyNTAsIHpvb21pbmcgPSAwLCBtb3VzZWRvd24gPSBcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlbW92ZSA9IFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2V1cCA9IFwibW91c2V1cC56b29tXCIsIG1vdXNld2hlZWxUaW1lciwgdG91Y2hzdGFydCA9IFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNodGltZSwgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKHpvb20sIFwiem9vbXN0YXJ0XCIsIFwiem9vbVwiLCBcInpvb21lbmRcIiksIHgwLCB4MSwgeTAsIHkxO1xuICAgIGlmICghZDNfYmVoYXZpb3Jfem9vbVdoZWVsKSB7XG4gICAgICBkM19iZWhhdmlvcl96b29tV2hlZWwgPSBcIm9ud2hlZWxcIiBpbiBkM19kb2N1bWVudCA/IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC1kMy5ldmVudC5kZWx0YVkgKiAoZDMuZXZlbnQuZGVsdGFNb2RlID8gMTIwIDogMSk7XG4gICAgICB9LCBcIndoZWVsXCIpIDogXCJvbm1vdXNld2hlZWxcIiBpbiBkM19kb2N1bWVudCA/IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGQzLmV2ZW50LndoZWVsRGVsdGE7XG4gICAgICB9LCBcIm1vdXNld2hlZWxcIikgOiAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAtZDMuZXZlbnQuZGV0YWlsO1xuICAgICAgfSwgXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tKGcpIHtcbiAgICAgIGcub24obW91c2Vkb3duLCBtb3VzZWRvd25lZCkub24oZDNfYmVoYXZpb3Jfem9vbVdoZWVsICsgXCIuem9vbVwiLCBtb3VzZXdoZWVsZWQpLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKS5vbih0b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0ZWQpO1xuICAgIH1cbiAgICB6b29tLmV2ZW50ID0gZnVuY3Rpb24oZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlzcGF0Y2ggPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpLCB2aWV3MSA9IHZpZXc7XG4gICAgICAgIGlmIChkM190cmFuc2l0aW9uSW5oZXJpdElkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5lYWNoKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzLl9fY2hhcnRfXyB8fCB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIGs6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSkudHdlZW4oXCJ6b29tOnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZHggPSBzaXplWzBdLCBkeSA9IHNpemVbMV0sIGN4ID0gY2VudGVyMCA/IGNlbnRlcjBbMF0gOiBkeCAvIDIsIGN5ID0gY2VudGVyMCA/IGNlbnRlcjBbMV0gOiBkeSAvIDIsIGkgPSBkMy5pbnRlcnBvbGF0ZVpvb20oWyAoY3ggLSB2aWV3LngpIC8gdmlldy5rLCAoY3kgLSB2aWV3LnkpIC8gdmlldy5rLCBkeCAvIHZpZXcuayBdLCBbIChjeCAtIHZpZXcxLngpIC8gdmlldzEuaywgKGN5IC0gdmlldzEueSkgLyB2aWV3MS5rLCBkeCAvIHZpZXcxLmsgXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICB2YXIgbCA9IGkodCksIGsgPSBkeCAvIGxbMl07XG4gICAgICAgICAgICAgIHRoaXMuX19jaGFydF9fID0gdmlldyA9IHtcbiAgICAgICAgICAgICAgICB4OiBjeCAtIGxbMF0gKiBrLFxuICAgICAgICAgICAgICAgIHk6IGN5IC0gbFsxXSAqIGssXG4gICAgICAgICAgICAgICAgazoga1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5lYWNoKFwiaW50ZXJydXB0Lnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pLmVhY2goXCJlbmQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSB2aWV3O1xuICAgICAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgem9vbS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHZpZXcueCwgdmlldy55IF07XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiArX1swXSxcbiAgICAgICAgeTogK19bMV0sXG4gICAgICAgIGs6IHZpZXcua1xuICAgICAgfTtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZpZXcuaztcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IHZpZXcueCxcbiAgICAgICAgeTogdmlldy55LFxuICAgICAgICBrOiBudWxsXG4gICAgICB9O1xuICAgICAgc2NhbGVUbygrXyk7XG4gICAgICByZXNjYWxlKCk7XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZUV4dGVudDtcbiAgICAgIHNjYWxlRXh0ZW50ID0gXyA9PSBudWxsID8gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5IDogWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZW50ZXI7XG4gICAgICBjZW50ZXIgPSBfICYmIFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXyAmJiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHVyYXRpb247XG4gICAgICBkdXJhdGlvbiA9ICtfO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgxID0gejtcbiAgICAgIHgwID0gei5jb3B5KCk7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBrOiAxXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gejtcbiAgICAgIHkwID0gei5jb3B5KCk7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBrOiAxXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsb2NhdGlvbihwKSB7XG4gICAgICByZXR1cm4gWyAocFswXSAtIHZpZXcueCkgLyB2aWV3LmssIChwWzFdIC0gdmlldy55KSAvIHZpZXcuayBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludChsKSB7XG4gICAgICByZXR1cm4gWyBsWzBdICogdmlldy5rICsgdmlldy54LCBsWzFdICogdmlldy5rICsgdmlldy55IF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8ocykge1xuICAgICAgdmlldy5rID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVRvKHAsIGwpIHtcbiAgICAgIGwgPSBwb2ludChsKTtcbiAgICAgIHZpZXcueCArPSBwWzBdIC0gbFswXTtcbiAgICAgIHZpZXcueSArPSBwWzFdIC0gbFsxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbVRvKHRoYXQsIHAsIGwsIGspIHtcbiAgICAgIHRoYXQuX19jaGFydF9fID0ge1xuICAgICAgICB4OiB2aWV3LngsXG4gICAgICAgIHk6IHZpZXcueSxcbiAgICAgICAgazogdmlldy5rXG4gICAgICB9O1xuICAgICAgc2NhbGVUbyhNYXRoLnBvdygyLCBrKSk7XG4gICAgICB0cmFuc2xhdGVUbyhjZW50ZXIwID0gcCwgbCk7XG4gICAgICB0aGF0ID0gZDMuc2VsZWN0KHRoYXQpO1xuICAgICAgaWYgKGR1cmF0aW9uID4gMCkgdGhhdCA9IHRoYXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgIHRoYXQuY2FsbCh6b29tLmV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIGlmICh4MSkgeDEuZG9tYWluKHgwLnJhbmdlKCkubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IC0gdmlldy54KSAvIHZpZXcuaztcbiAgICAgIH0pLm1hcCh4MC5pbnZlcnQpKTtcbiAgICAgIGlmICh5MSkgeTEuZG9tYWluKHkwLnJhbmdlKCkubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuICh5IC0gdmlldy55KSAvIHZpZXcuaztcbiAgICAgIH0pLm1hcCh5MC5pbnZlcnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICghem9vbWluZysrKSBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbXN0YXJ0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tZWQoZGlzcGF0Y2gpIHtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tXCIsXG4gICAgICAgIHNjYWxlOiB2aWV3LmssXG4gICAgICAgIHRyYW5zbGF0ZTogWyB2aWV3LngsIHZpZXcueSBdXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbWVuZGVkKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoIS0tem9vbWluZykgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21lbmRcIlxuICAgICAgfSksIGNlbnRlcjAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcywgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBkcmFnZ2VkID0gMCwgc3ViamVjdCA9IGQzLnNlbGVjdChkM193aW5kb3codGhhdCkpLm9uKG1vdXNlbW92ZSwgbW92ZWQpLm9uKG1vdXNldXAsIGVuZGVkKSwgbG9jYXRpb24wID0gbG9jYXRpb24oZDMubW91c2UodGhhdCkpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0aGF0KTtcbiAgICAgIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGF0KTtcbiAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICBkcmFnZ2VkID0gMTtcbiAgICAgICAgdHJhbnNsYXRlVG8oZDMubW91c2UodGhhdCksIGxvY2F0aW9uMCk7XG4gICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgc3ViamVjdC5vbihtb3VzZW1vdmUsIG51bGwpLm9uKG1vdXNldXAsIG51bGwpO1xuICAgICAgICBkcmFnUmVzdG9yZShkcmFnZ2VkKTtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGxvY2F0aW9uczAgPSB7fSwgZGlzdGFuY2UwID0gMCwgc2NhbGUwLCB6b29tTmFtZSA9IFwiLnpvb20tXCIgKyBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyLCB0b3VjaG1vdmUgPSBcInRvdWNobW92ZVwiICsgem9vbU5hbWUsIHRvdWNoZW5kID0gXCJ0b3VjaGVuZFwiICsgem9vbU5hbWUsIHRhcmdldHMgPSBbXSwgc3ViamVjdCA9IGQzLnNlbGVjdCh0aGF0KSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGhhdCk7XG4gICAgICBzdGFydGVkKCk7XG4gICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBzdWJqZWN0Lm9uKG1vdXNlZG93biwgbnVsbCkub24odG91Y2hzdGFydCwgc3RhcnRlZCk7XG4gICAgICBmdW5jdGlvbiByZWxvY2F0ZSgpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBkMy50b3VjaGVzKHRoYXQpO1xuICAgICAgICBzY2FsZTAgPSB2aWV3Lms7XG4gICAgICAgIHRvdWNoZXMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgaWYgKHQuaWRlbnRpZmllciBpbiBsb2NhdGlvbnMwKSBsb2NhdGlvbnMwW3QuaWRlbnRpZmllcl0gPSBsb2NhdGlvbih0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b3VjaGVzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RhcnRlZCgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGQzLmV2ZW50LnRhcmdldDtcbiAgICAgICAgZDMuc2VsZWN0KHRhcmdldCkub24odG91Y2htb3ZlLCBtb3ZlZCkub24odG91Y2hlbmQsIGVuZGVkKTtcbiAgICAgICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hhbmdlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBsb2NhdGlvbnMwW2NoYW5nZWRbaV0uaWRlbnRpZmllcl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3VjaGVzID0gcmVsb2NhdGUoKSwgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKG5vdyAtIHRvdWNodGltZSA8IDUwMCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0b3VjaGVzWzBdO1xuICAgICAgICAgICAgem9vbVRvKHRoYXQsIHAsIGxvY2F0aW9uczBbcC5pZGVudGlmaWVyXSwgTWF0aC5mbG9vcihNYXRoLmxvZyh2aWV3LmspIC8gTWF0aC5MTjIpICsgMSk7XG4gICAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdWNodGltZSA9IG5vdztcbiAgICAgICAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgcCA9IHRvdWNoZXNbMF0sIHEgPSB0b3VjaGVzWzFdLCBkeCA9IHBbMF0gLSBxWzBdLCBkeSA9IHBbMV0gLSBxWzFdO1xuICAgICAgICAgIGRpc3RhbmNlMCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBkMy50b3VjaGVzKHRoYXQpLCBwMCwgbDAsIHAxLCBsMTtcbiAgICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoYXQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbjsgKytpLCBsMSA9IG51bGwpIHtcbiAgICAgICAgICBwMSA9IHRvdWNoZXNbaV07XG4gICAgICAgICAgaWYgKGwxID0gbG9jYXRpb25zMFtwMS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgaWYgKGwwKSBicmVhaztcbiAgICAgICAgICAgIHAwID0gcDEsIGwwID0gbDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsMSkge1xuICAgICAgICAgIHZhciBkaXN0YW5jZTEgPSAoZGlzdGFuY2UxID0gcDFbMF0gLSBwMFswXSkgKiBkaXN0YW5jZTEgKyAoZGlzdGFuY2UxID0gcDFbMV0gLSBwMFsxXSkgKiBkaXN0YW5jZTEsIHNjYWxlMSA9IGRpc3RhbmNlMCAmJiBNYXRoLnNxcnQoZGlzdGFuY2UxIC8gZGlzdGFuY2UwKTtcbiAgICAgICAgICBwMCA9IFsgKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMiBdO1xuICAgICAgICAgIGwwID0gWyAobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyIF07XG4gICAgICAgICAgc2NhbGVUbyhzY2FsZTEgKiBzY2FsZTApO1xuICAgICAgICB9XG4gICAgICAgIHRvdWNodGltZSA9IG51bGw7XG4gICAgICAgIHRyYW5zbGF0ZVRvKHAwLCBsMCk7XG4gICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoYW5nZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9jYXRpb25zMFtjaGFuZ2VkW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpZGVudGlmaWVyIGluIGxvY2F0aW9uczApIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIHJlbG9jYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQzLnNlbGVjdEFsbCh0YXJnZXRzKS5vbih6b29tTmFtZSwgbnVsbCk7XG4gICAgICAgIHN1YmplY3Qub24obW91c2Vkb3duLCBtb3VzZWRvd25lZCkub24odG91Y2hzdGFydCwgdG91Y2hzdGFydGVkKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoKTtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW91c2V3aGVlbGVkKCkge1xuICAgICAgdmFyIGRpc3BhdGNoID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChtb3VzZXdoZWVsVGltZXIpIGNsZWFyVGltZW91dChtb3VzZXdoZWVsVGltZXIpOyBlbHNlIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGlzKSwgXG4gICAgICB0cmFuc2xhdGUwID0gbG9jYXRpb24oY2VudGVyMCA9IGNlbnRlciB8fCBkMy5tb3VzZSh0aGlzKSksIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIG1vdXNld2hlZWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vdXNld2hlZWxUaW1lciA9IG51bGw7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9LCA1MCk7XG4gICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzY2FsZVRvKE1hdGgucG93KDIsIGQzX2JlaGF2aW9yX3pvb21EZWx0YSgpICogLjAwMikgKiB2aWV3LmspO1xuICAgICAgdHJhbnNsYXRlVG8oY2VudGVyMCwgdHJhbnNsYXRlMCk7XG4gICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkYmxjbGlja2VkKCkge1xuICAgICAgdmFyIHAgPSBkMy5tb3VzZSh0aGlzKSwgayA9IE1hdGgubG9nKHZpZXcuaykgLyBNYXRoLkxOMjtcbiAgICAgIHpvb21Ubyh0aGlzLCBwLCBsb2NhdGlvbihwKSwgZDMuZXZlbnQuc2hpZnRLZXkgPyBNYXRoLmNlaWwoaykgLSAxIDogTWF0aC5mbG9vcihrKSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZDMucmViaW5kKHpvb20sIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICB2YXIgZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5ID0gWyAwLCBJbmZpbml0eSBdLCBkM19iZWhhdmlvcl96b29tRGVsdGEsIGQzX2JlaGF2aW9yX3pvb21XaGVlbDtcbiAgZDMuY29sb3IgPSBkM19jb2xvcjtcbiAgZnVuY3Rpb24gZDNfY29sb3IoKSB7fVxuICBkM19jb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gIH07XG4gIGQzLmhzbCA9IGQzX2hzbDtcbiAgZnVuY3Rpb24gZDNfaHNsKGgsIHMsIGwpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2hzbCA/IHZvaWQgKHRoaXMuaCA9ICtoLCB0aGlzLnMgPSArcywgdGhpcy5sID0gK2wpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBoIGluc3RhbmNlb2YgZDNfaHNsID8gbmV3IGQzX2hzbChoLmgsIGgucywgaC5sKSA6IGQzX3JnYl9wYXJzZShcIlwiICsgaCwgZDNfcmdiX2hzbCwgZDNfaHNsKSA6IG5ldyBkM19oc2woaCwgcywgbCk7XG4gIH1cbiAgdmFyIGQzX2hzbFByb3RvdHlwZSA9IGQzX2hzbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfaHNsUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sIC8gayk7XG4gIH07XG4gIGQzX2hzbFByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfaHNsKHRoaXMuaCwgdGhpcy5zLCBrICogdGhpcy5sKTtcbiAgfTtcbiAgZDNfaHNsUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19oc2xfcmdiKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwpO1xuICB9O1xuICBmdW5jdGlvbiBkM19oc2xfcmdiKGgsIHMsIGwpIHtcbiAgICB2YXIgbTEsIG0yO1xuICAgIGggPSBpc05hTihoKSA/IDAgOiAoaCAlPSAzNjApIDwgMCA/IGggKyAzNjAgOiBoO1xuICAgIHMgPSBpc05hTihzKSA/IDAgOiBzIDwgMCA/IDAgOiBzID4gMSA/IDEgOiBzO1xuICAgIGwgPSBsIDwgMCA/IDAgOiBsID4gMSA/IDEgOiBsO1xuICAgIG0yID0gbCA8PSAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgZnVuY3Rpb24gdihoKSB7XG4gICAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7IGVsc2UgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIGlmIChoIDwgNjApIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggLyA2MDtcbiAgICAgIGlmIChoIDwgMTgwKSByZXR1cm4gbTI7XG4gICAgICBpZiAoaCA8IDI0MCkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjA7XG4gICAgICByZXR1cm4gbTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZ2KGgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYoaCkgKiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGQzX3JnYih2dihoICsgMTIwKSwgdnYoaCksIHZ2KGggLSAxMjApKTtcbiAgfVxuICBkMy5oY2wgPSBkM19oY2w7XG4gIGZ1bmN0aW9uIGQzX2hjbChoLCBjLCBsKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19oY2wgPyB2b2lkICh0aGlzLmggPSAraCwgdGhpcy5jID0gK2MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gaCBpbnN0YW5jZW9mIGQzX2hjbCA/IG5ldyBkM19oY2woaC5oLCBoLmMsIGgubCkgOiBoIGluc3RhbmNlb2YgZDNfbGFiID8gZDNfbGFiX2hjbChoLmwsIGguYSwgaC5iKSA6IGQzX2xhYl9oY2woKGggPSBkM19yZ2JfbGFiKChoID0gZDMucmdiKGgpKS5yLCBoLmcsIGguYikpLmwsIGguYSwgaC5iKSA6IG5ldyBkM19oY2woaCwgYywgbCk7XG4gIH1cbiAgdmFyIGQzX2hjbFByb3RvdHlwZSA9IGQzX2hjbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfaGNsUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpKTtcbiAgfTtcbiAgZDNfaGNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2hjbCh0aGlzLmgsIHRoaXMuYywgTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xuICB9O1xuICBkM19oY2xQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2hjbF9sYWIodGhpcy5oLCB0aGlzLmMsIHRoaXMubCkucmdiKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2hjbF9sYWIoaCwgYywgbCkge1xuICAgIGlmIChpc05hTihoKSkgaCA9IDA7XG4gICAgaWYgKGlzTmFOKGMpKSBjID0gMDtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihsLCBNYXRoLmNvcyhoICo9IGQzX3JhZGlhbnMpICogYywgTWF0aC5zaW4oaCkgKiBjKTtcbiAgfVxuICBkMy5sYWIgPSBkM19sYWI7XG4gIGZ1bmN0aW9uIGQzX2xhYihsLCBhLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19sYWIgPyB2b2lkICh0aGlzLmwgPSArbCwgdGhpcy5hID0gK2EsIHRoaXMuYiA9ICtiKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gbCBpbnN0YW5jZW9mIGQzX2xhYiA/IG5ldyBkM19sYWIobC5sLCBsLmEsIGwuYikgOiBsIGluc3RhbmNlb2YgZDNfaGNsID8gZDNfaGNsX2xhYihsLmgsIGwuYywgbC5sKSA6IGQzX3JnYl9sYWIoKGwgPSBkM19yZ2IobCkpLnIsIGwuZywgbC5iKSA6IG5ldyBkM19sYWIobCwgYSwgYik7XG4gIH1cbiAgdmFyIGQzX2xhYl9LID0gMTg7XG4gIHZhciBkM19sYWJfWCA9IC45NTA0NywgZDNfbGFiX1kgPSAxLCBkM19sYWJfWiA9IDEuMDg4ODM7XG4gIHZhciBkM19sYWJQcm90b3R5cGUgPSBkM19sYWIucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2xhYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGQzX2xhYlByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIoTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZDNfbGFiUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19sYWJfcmdiKHRoaXMubCwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYWJfcmdiKGwsIGEsIGIpIHtcbiAgICB2YXIgeSA9IChsICsgMTYpIC8gMTE2LCB4ID0geSArIGEgLyA1MDAsIHogPSB5IC0gYiAvIDIwMDtcbiAgICB4ID0gZDNfbGFiX3h5eih4KSAqIGQzX2xhYl9YO1xuICAgIHkgPSBkM19sYWJfeHl6KHkpICogZDNfbGFiX1k7XG4gICAgeiA9IGQzX2xhYl94eXooeikgKiBkM19sYWJfWjtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihkM194eXpfcmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gLjQ5ODUzMTQgKiB6KSwgZDNfeHl6X3JnYigtLjk2OTI2NiAqIHggKyAxLjg3NjAxMDggKiB5ICsgLjA0MTU1NiAqIHopLCBkM194eXpfcmdiKC4wNTU2NDM0ICogeCAtIC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYWJfaGNsKGwsIGEsIGIpIHtcbiAgICByZXR1cm4gbCA+IDAgPyBuZXcgZDNfaGNsKE1hdGguYXRhbjIoYiwgYSkgKiBkM19kZWdyZWVzLCBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksIGwpIDogbmV3IGQzX2hjbChOYU4sIE5hTiwgbCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGFiX3h5eih4KSB7XG4gICAgcmV0dXJuIHggPiAuMjA2ODkzMDM0ID8geCAqIHggKiB4IDogKHggLSA0IC8gMjkpIC8gNy43ODcwMzc7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeHl6X2xhYih4KSB7XG4gICAgcmV0dXJuIHggPiAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcwMzcgKiB4ICsgNCAvIDI5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3h5el9yZ2Iocikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDI1NSAqIChyIDw9IC4wMDMwNCA/IDEyLjkyICogciA6IDEuMDU1ICogTWF0aC5wb3cociwgMSAvIDIuNCkgLSAuMDU1KSk7XG4gIH1cbiAgZDMucmdiID0gZDNfcmdiO1xuICBmdW5jdGlvbiBkM19yZ2IociwgZywgYikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfcmdiID8gdm9pZCAodGhpcy5yID0gfn5yLCB0aGlzLmcgPSB+fmcsIHRoaXMuYiA9IH5+YikgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHIgaW5zdGFuY2VvZiBkM19yZ2IgPyBuZXcgZDNfcmdiKHIuciwgci5nLCByLmIpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyByLCBkM19yZ2IsIGQzX2hzbF9yZ2IpIDogbmV3IGQzX3JnYihyLCBnLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IGQzX3JnYih2YWx1ZSA+PiAxNiwgdmFsdWUgPj4gOCAmIDI1NSwgdmFsdWUgJiAyNTUpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYlN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBkM19yZ2JOdW1iZXIodmFsdWUpICsgXCJcIjtcbiAgfVxuICB2YXIgZDNfcmdiUHJvdG90eXBlID0gZDNfcmdiLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19yZ2JQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iLCBpID0gMzA7XG4gICAgaWYgKCFyICYmICFnICYmICFiKSByZXR1cm4gbmV3IGQzX3JnYihpLCBpLCBpKTtcbiAgICBpZiAociAmJiByIDwgaSkgciA9IGk7XG4gICAgaWYgKGcgJiYgZyA8IGkpIGcgPSBpO1xuICAgIGlmIChiICYmIGIgPCBpKSBiID0gaTtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihNYXRoLm1pbigyNTUsIHIgLyBrKSwgTWF0aC5taW4oMjU1LCBnIC8gayksIE1hdGgubWluKDI1NSwgYiAvIGspKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoayAqIHRoaXMuciwgayAqIHRoaXMuZywgayAqIHRoaXMuYik7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfcmdiX2hzbCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgZDNfcmdiX2hleCh0aGlzLnIpICsgZDNfcmdiX2hleCh0aGlzLmcpICsgZDNfcmdiX2hleCh0aGlzLmIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19yZ2JfaGV4KHYpIHtcbiAgICByZXR1cm4gdiA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCB2KS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIHYpLnRvU3RyaW5nKDE2KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfcGFyc2UoZm9ybWF0LCByZ2IsIGhzbCkge1xuICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwLCBtMSwgbTIsIGNvbG9yO1xuICAgIG0xID0gLyhbYS16XSspXFwoKC4qKVxcKS8uZXhlYyhmb3JtYXQgPSBmb3JtYXQudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKG0xKSB7XG4gICAgICBtMiA9IG0xWzJdLnNwbGl0KFwiLFwiKTtcbiAgICAgIHN3aXRjaCAobTFbMV0pIHtcbiAgICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaHNsKHBhcnNlRmxvYXQobTJbMF0pLCBwYXJzZUZsb2F0KG0yWzFdKSAvIDEwMCwgcGFyc2VGbG9hdChtMlsyXSkgLyAxMDApO1xuICAgICAgICB9XG5cbiAgICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcmdiKGQzX3JnYl9wYXJzZU51bWJlcihtMlswXSksIGQzX3JnYl9wYXJzZU51bWJlcihtMlsxXSksIGQzX3JnYl9wYXJzZU51bWJlcihtMlsyXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2xvciA9IGQzX3JnYl9uYW1lcy5nZXQoZm9ybWF0KSkge1xuICAgICAgcmV0dXJuIHJnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdC5jaGFyQXQoMCkgPT09IFwiI1wiICYmICFpc05hTihjb2xvciA9IHBhcnNlSW50KGZvcm1hdC5zbGljZSgxKSwgMTYpKSkge1xuICAgICAgaWYgKGZvcm1hdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgciA9IChjb2xvciAmIDM4NDApID4+IDQ7XG4gICAgICAgIHIgPSByID4+IDQgfCByO1xuICAgICAgICBnID0gY29sb3IgJiAyNDA7XG4gICAgICAgIGcgPSBnID4+IDQgfCBnO1xuICAgICAgICBiID0gY29sb3IgJiAxNTtcbiAgICAgICAgYiA9IGIgPDwgNCB8IGI7XG4gICAgICB9IGVsc2UgaWYgKGZvcm1hdC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgciA9IChjb2xvciAmIDE2NzExNjgwKSA+PiAxNjtcbiAgICAgICAgZyA9IChjb2xvciAmIDY1MjgwKSA+PiA4O1xuICAgICAgICBiID0gY29sb3IgJiAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2IociwgZywgYik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX2hzbChyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIgLz0gMjU1LCBnIC89IDI1NSwgYiAvPSAyNTUpLCBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgZCA9IG1heCAtIG1pbiwgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBpZiAoZCkge1xuICAgICAgcyA9IGwgPCAuNSA/IGQgLyAobWF4ICsgbWluKSA6IGQgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICBpZiAociA9PSBtYXgpIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgZWxzZSBpZiAoZyA9PSBtYXgpIGggPSAoYiAtIHIpIC8gZCArIDI7IGVsc2UgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgIGggKj0gNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBOYU47XG4gICAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBkM19oc2woaCwgcywgbCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX2xhYihyLCBnLCBiKSB7XG4gICAgciA9IGQzX3JnYl94eXoocik7XG4gICAgZyA9IGQzX3JnYl94eXooZyk7XG4gICAgYiA9IGQzX3JnYl94eXooYik7XG4gICAgdmFyIHggPSBkM194eXpfbGFiKCguNDEyNDU2NCAqIHIgKyAuMzU3NTc2MSAqIGcgKyAuMTgwNDM3NSAqIGIpIC8gZDNfbGFiX1gpLCB5ID0gZDNfeHl6X2xhYigoLjIxMjY3MjkgKiByICsgLjcxNTE1MjIgKiBnICsgLjA3MjE3NSAqIGIpIC8gZDNfbGFiX1kpLCB6ID0gZDNfeHl6X2xhYigoLjAxOTMzMzkgKiByICsgLjExOTE5MiAqIGcgKyAuOTUwMzA0MSAqIGIpIC8gZDNfbGFiX1opO1xuICAgIHJldHVybiBkM19sYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfeHl6KHIpIHtcbiAgICByZXR1cm4gKHIgLz0gMjU1KSA8PSAuMDQwNDUgPyByIC8gMTIuOTIgOiBNYXRoLnBvdygociArIC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3BhcnNlTnVtYmVyKGMpIHtcbiAgICB2YXIgZiA9IHBhcnNlRmxvYXQoYyk7XG4gICAgcmV0dXJuIGMuY2hhckF0KGMubGVuZ3RoIC0gMSkgPT09IFwiJVwiID8gTWF0aC5yb3VuZChmICogMi41NSkgOiBmO1xuICB9XG4gIHZhciBkM19yZ2JfbmFtZXMgPSBkMy5tYXAoe1xuICAgIGFsaWNlYmx1ZTogMTU3OTIzODMsXG4gICAgYW50aXF1ZXdoaXRlOiAxNjQ0NDM3NSxcbiAgICBhcXVhOiA2NTUzNSxcbiAgICBhcXVhbWFyaW5lOiA4Mzg4NTY0LFxuICAgIGF6dXJlOiAxNTc5NDE3NSxcbiAgICBiZWlnZTogMTYxMTkyNjAsXG4gICAgYmlzcXVlOiAxNjc3MDI0NCxcbiAgICBibGFjazogMCxcbiAgICBibGFuY2hlZGFsbW9uZDogMTY3NzIwNDUsXG4gICAgYmx1ZTogMjU1LFxuICAgIGJsdWV2aW9sZXQ6IDkwNTUyMDIsXG4gICAgYnJvd246IDEwODI0MjM0LFxuICAgIGJ1cmx5d29vZDogMTQ1OTYyMzEsXG4gICAgY2FkZXRibHVlOiA2MjY2NTI4LFxuICAgIGNoYXJ0cmV1c2U6IDgzODgzNTIsXG4gICAgY2hvY29sYXRlOiAxMzc4OTQ3MCxcbiAgICBjb3JhbDogMTY3NDQyNzIsXG4gICAgY29ybmZsb3dlcmJsdWU6IDY1OTE5ODEsXG4gICAgY29ybnNpbGs6IDE2Nzc1Mzg4LFxuICAgIGNyaW1zb246IDE0NDIzMTAwLFxuICAgIGN5YW46IDY1NTM1LFxuICAgIGRhcmtibHVlOiAxMzksXG4gICAgZGFya2N5YW46IDM1NzIzLFxuICAgIGRhcmtnb2xkZW5yb2Q6IDEyMDkyOTM5LFxuICAgIGRhcmtncmF5OiAxMTExOTAxNyxcbiAgICBkYXJrZ3JlZW46IDI1NjAwLFxuICAgIGRhcmtncmV5OiAxMTExOTAxNyxcbiAgICBkYXJra2hha2k6IDEyNDMzMjU5LFxuICAgIGRhcmttYWdlbnRhOiA5MTA5NjQzLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiA1NTk3OTk5LFxuICAgIGRhcmtvcmFuZ2U6IDE2NzQ3NTIwLFxuICAgIGRhcmtvcmNoaWQ6IDEwMDQwMDEyLFxuICAgIGRhcmtyZWQ6IDkxMDk1MDQsXG4gICAgZGFya3NhbG1vbjogMTUzMDg0MTAsXG4gICAgZGFya3NlYWdyZWVuOiA5NDE5OTE5LFxuICAgIGRhcmtzbGF0ZWJsdWU6IDQ3MzQzNDcsXG4gICAgZGFya3NsYXRlZ3JheTogMzEwMDQ5NSxcbiAgICBkYXJrc2xhdGVncmV5OiAzMTAwNDk1LFxuICAgIGRhcmt0dXJxdW9pc2U6IDUyOTQ1LFxuICAgIGRhcmt2aW9sZXQ6IDk2OTk1MzksXG4gICAgZGVlcHBpbms6IDE2NzE2OTQ3LFxuICAgIGRlZXBza3libHVlOiA0OTE1MSxcbiAgICBkaW1ncmF5OiA2OTA4MjY1LFxuICAgIGRpbWdyZXk6IDY5MDgyNjUsXG4gICAgZG9kZ2VyYmx1ZTogMjAwMzE5OSxcbiAgICBmaXJlYnJpY2s6IDExNjc0MTQ2LFxuICAgIGZsb3JhbHdoaXRlOiAxNjc3NTkyMCxcbiAgICBmb3Jlc3RncmVlbjogMjI2Mzg0MixcbiAgICBmdWNoc2lhOiAxNjcxMTkzNSxcbiAgICBnYWluc2Jvcm86IDE0NDc0NDYwLFxuICAgIGdob3N0d2hpdGU6IDE2MzE2NjcxLFxuICAgIGdvbGQ6IDE2NzY2NzIwLFxuICAgIGdvbGRlbnJvZDogMTQzMjkxMjAsXG4gICAgZ3JheTogODQyMTUwNCxcbiAgICBncmVlbjogMzI3NjgsXG4gICAgZ3JlZW55ZWxsb3c6IDExNDAzMDU1LFxuICAgIGdyZXk6IDg0MjE1MDQsXG4gICAgaG9uZXlkZXc6IDE1Nzk0MTYwLFxuICAgIGhvdHBpbms6IDE2NzM4NzQwLFxuICAgIGluZGlhbnJlZDogMTM0NTg1MjQsXG4gICAgaW5kaWdvOiA0OTE1MzMwLFxuICAgIGl2b3J5OiAxNjc3NzIwMCxcbiAgICBraGFraTogMTU3ODc2NjAsXG4gICAgbGF2ZW5kZXI6IDE1MTMyNDEwLFxuICAgIGxhdmVuZGVyYmx1c2g6IDE2NzczMzY1LFxuICAgIGxhd25ncmVlbjogODE5MDk3NixcbiAgICBsZW1vbmNoaWZmb246IDE2Nzc1ODg1LFxuICAgIGxpZ2h0Ymx1ZTogMTEzOTMyNTQsXG4gICAgbGlnaHRjb3JhbDogMTU3NjE1MzYsXG4gICAgbGlnaHRjeWFuOiAxNDc0NTU5OSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogMTY0NDgyMTAsXG4gICAgbGlnaHRncmF5OiAxMzg4MjMyMyxcbiAgICBsaWdodGdyZWVuOiA5NDk4MjU2LFxuICAgIGxpZ2h0Z3JleTogMTM4ODIzMjMsXG4gICAgbGlnaHRwaW5rOiAxNjc1ODQ2NSxcbiAgICBsaWdodHNhbG1vbjogMTY3NTI3NjIsXG4gICAgbGlnaHRzZWFncmVlbjogMjE0Mjg5MCxcbiAgICBsaWdodHNreWJsdWU6IDg5MDAzNDYsXG4gICAgbGlnaHRzbGF0ZWdyYXk6IDc4MzM3NTMsXG4gICAgbGlnaHRzbGF0ZWdyZXk6IDc4MzM3NTMsXG4gICAgbGlnaHRzdGVlbGJsdWU6IDExNTg0NzM0LFxuICAgIGxpZ2h0eWVsbG93OiAxNjc3NzE4NCxcbiAgICBsaW1lOiA2NTI4MCxcbiAgICBsaW1lZ3JlZW46IDMzMjkzMzAsXG4gICAgbGluZW46IDE2NDQ1NjcwLFxuICAgIG1hZ2VudGE6IDE2NzExOTM1LFxuICAgIG1hcm9vbjogODM4ODYwOCxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiA2NzM3MzIyLFxuICAgIG1lZGl1bWJsdWU6IDIwNSxcbiAgICBtZWRpdW1vcmNoaWQ6IDEyMjExNjY3LFxuICAgIG1lZGl1bXB1cnBsZTogOTY2MjY4MyxcbiAgICBtZWRpdW1zZWFncmVlbjogMzk3ODA5NyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IDgwODc3OTAsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IDY0MTU0LFxuICAgIG1lZGl1bXR1cnF1b2lzZTogNDc3MjMwMCxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IDEzMDQ3MTczLFxuICAgIG1pZG5pZ2h0Ymx1ZTogMTY0NDkxMixcbiAgICBtaW50Y3JlYW06IDE2MTIxODUwLFxuICAgIG1pc3R5cm9zZTogMTY3NzAyNzMsXG4gICAgbW9jY2FzaW46IDE2NzcwMjI5LFxuICAgIG5hdmFqb3doaXRlOiAxNjc2ODY4NSxcbiAgICBuYXZ5OiAxMjgsXG4gICAgb2xkbGFjZTogMTY2NDM1NTgsXG4gICAgb2xpdmU6IDg0MjEzNzYsXG4gICAgb2xpdmVkcmFiOiA3MDQ4NzM5LFxuICAgIG9yYW5nZTogMTY3NTM5MjAsXG4gICAgb3JhbmdlcmVkOiAxNjcyOTM0NCxcbiAgICBvcmNoaWQ6IDE0MzE1NzM0LFxuICAgIHBhbGVnb2xkZW5yb2Q6IDE1NjU3MTMwLFxuICAgIHBhbGVncmVlbjogMTAwMjU4ODAsXG4gICAgcGFsZXR1cnF1b2lzZTogMTE1Mjk5NjYsXG4gICAgcGFsZXZpb2xldHJlZDogMTQzODEyMDMsXG4gICAgcGFwYXlhd2hpcDogMTY3NzMwNzcsXG4gICAgcGVhY2hwdWZmOiAxNjc2NzY3MyxcbiAgICBwZXJ1OiAxMzQ2ODk5MSxcbiAgICBwaW5rOiAxNjc2MTAzNSxcbiAgICBwbHVtOiAxNDUyNDYzNyxcbiAgICBwb3dkZXJibHVlOiAxMTU5MTkxMCxcbiAgICBwdXJwbGU6IDgzODg3MzYsXG4gICAgcmViZWNjYXB1cnBsZTogNjY5Nzg4MSxcbiAgICByZWQ6IDE2NzExNjgwLFxuICAgIHJvc3licm93bjogMTIzNTc1MTksXG4gICAgcm95YWxibHVlOiA0Mjg2OTQ1LFxuICAgIHNhZGRsZWJyb3duOiA5MTI3MTg3LFxuICAgIHNhbG1vbjogMTY0MTY4ODIsXG4gICAgc2FuZHlicm93bjogMTYwMzI4NjQsXG4gICAgc2VhZ3JlZW46IDMwNTAzMjcsXG4gICAgc2Vhc2hlbGw6IDE2Nzc0NjM4LFxuICAgIHNpZW5uYTogMTA1MDY3OTcsXG4gICAgc2lsdmVyOiAxMjYzMjI1NixcbiAgICBza3libHVlOiA4OTAwMzMxLFxuICAgIHNsYXRlYmx1ZTogNjk3MDA2MSxcbiAgICBzbGF0ZWdyYXk6IDczNzI5NDQsXG4gICAgc2xhdGVncmV5OiA3MzcyOTQ0LFxuICAgIHNub3c6IDE2Nzc1OTMwLFxuICAgIHNwcmluZ2dyZWVuOiA2NTQwNyxcbiAgICBzdGVlbGJsdWU6IDQ2MjA5ODAsXG4gICAgdGFuOiAxMzgwODc4MCxcbiAgICB0ZWFsOiAzMjg5NixcbiAgICB0aGlzdGxlOiAxNDIwNDg4OCxcbiAgICB0b21hdG86IDE2NzM3MDk1LFxuICAgIHR1cnF1b2lzZTogNDI1MTg1NixcbiAgICB2aW9sZXQ6IDE1NjMxMDg2LFxuICAgIHdoZWF0OiAxNjExMzMzMSxcbiAgICB3aGl0ZTogMTY3NzcyMTUsXG4gICAgd2hpdGVzbW9rZTogMTYxMTkyODUsXG4gICAgeWVsbG93OiAxNjc3Njk2MCxcbiAgICB5ZWxsb3dncmVlbjogMTAxNDUwNzRcbiAgfSk7XG4gIGQzX3JnYl9uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBkM19yZ2JfbmFtZXMuc2V0KGtleSwgZDNfcmdiTnVtYmVyKHZhbHVlKSk7XG4gIH0pO1xuICBmdW5jdGlvbiBkM19mdW5jdG9yKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiA/IHYgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gIH1cbiAgZDMuZnVuY3RvciA9IGQzX2Z1bmN0b3I7XG4gIGQzLnhociA9IGQzX3hoclR5cGUoZDNfaWRlbnRpdHkpO1xuICBmdW5jdGlvbiBkM194aHJUeXBlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgbWltZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbWltZVR5cGUgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBtaW1lVHlwZSwgXG4gICAgICBtaW1lVHlwZSA9IG51bGw7XG4gICAgICByZXR1cm4gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJlc3BvbnNlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHIodXJsLCBtaW1lVHlwZSwgcmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IHt9LCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKFwiYmVmb3Jlc2VuZFwiLCBcInByb2dyZXNzXCIsIFwibG9hZFwiLCBcImVycm9yXCIpLCBoZWFkZXJzID0ge30sIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgcmVzcG9uc2VUeXBlID0gbnVsbDtcbiAgICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdCAmJiAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdCkgJiYgL14oaHR0cChzKT86KT9cXC9cXC8vLnRlc3QodXJsKSkgcmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIFwib25sb2FkXCIgaW4gcmVxdWVzdCA/IHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZCA6IHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXF1ZXN0LnJlYWR5U3RhdGUgPiAzICYmIHJlc3BvbmQoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXMsIHJlc3VsdDtcbiAgICAgIGlmICghc3RhdHVzICYmIGQzX3hockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2UuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGlzcGF0Y2guZXJyb3IuY2FsbCh4aHIsIGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaC5sb2FkLmNhbGwoeGhyLCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2guZXJyb3IuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIG8gPSBkMy5ldmVudDtcbiAgICAgIGQzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNwYXRjaC5wcm9ncmVzcy5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkMy5ldmVudCA9IG87XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuaGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIG5hbWUgPSAobmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBoZWFkZXJzW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIGRlbGV0ZSBoZWFkZXJzW25hbWVdOyBlbHNlIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZSArIFwiXCI7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLm1pbWVUeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1pbWVUeXBlO1xuICAgICAgbWltZVR5cGUgPSB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJlc3BvbnNlVHlwZTtcbiAgICAgIHJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5yZXNwb25zZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXNwb25zZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIFsgXCJnZXRcIiwgXCJwb3N0XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgeGhyW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zZW5kLmFwcGx5KHhociwgWyBtZXRob2QgXS5jb25jYXQoZDNfYXJyYXkoYXJndW1lbnRzKSkpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB4aHIuc2VuZCA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgaWYgKG1pbWVUeXBlICE9IG51bGwgJiYgIShcImFjY2VwdFwiIGluIGhlYWRlcnMpKSBoZWFkZXJzW1wiYWNjZXB0XCJdID0gbWltZVR5cGUgKyBcIiwqLypcIjtcbiAgICAgIGlmIChyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIpIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgaWYgKG1pbWVUeXBlICE9IG51bGwgJiYgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKSByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUobWltZVR5cGUpO1xuICAgICAgaWYgKHJlc3BvbnNlVHlwZSAhPSBudWxsKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB4aHIub24oXCJlcnJvclwiLCBjYWxsYmFjaykub24oXCJsb2FkXCIsIGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICAgIGRpc3BhdGNoLmJlZm9yZXNlbmQuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgcmVxdWVzdC5zZW5kKGRhdGEgPT0gbnVsbCA/IG51bGwgOiBkYXRhKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBkMy5yZWJpbmQoeGhyLCBkaXNwYXRjaCwgXCJvblwiKTtcbiAgICByZXR1cm4gY2FsbGJhY2sgPT0gbnVsbCA/IHhociA6IHhoci5nZXQoZDNfeGhyX2ZpeENhbGxiYWNrKGNhbGxiYWNrKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeGhyX2ZpeENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmxlbmd0aCA9PT0gMSA/IGZ1bmN0aW9uKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgICBjYWxsYmFjayhlcnJvciA9PSBudWxsID8gcmVxdWVzdCA6IG51bGwpO1xuICAgIH0gOiBjYWxsYmFjaztcbiAgfVxuICBmdW5jdGlvbiBkM194aHJIYXNSZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSBcInRleHRcIiA/IHJlcXVlc3QucmVzcG9uc2UgOiByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgfVxuICBkMy5kc3YgPSBmdW5jdGlvbihkZWxpbWl0ZXIsIG1pbWVUeXBlKSB7XG4gICAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cCgnW1wiJyArIGRlbGltaXRlciArIFwiXFxuXVwiKSwgZGVsaW1pdGVyQ29kZSA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuICAgIGZ1bmN0aW9uIGRzdih1cmwsIHJvdywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgY2FsbGJhY2sgPSByb3csIHJvdyA9IG51bGw7XG4gICAgICB2YXIgeGhyID0gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJvdyA9PSBudWxsID8gcmVzcG9uc2UgOiB0eXBlZFJlc3BvbnNlKHJvdyksIGNhbGxiYWNrKTtcbiAgICAgIHhoci5yb3cgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8geGhyLnJlc3BvbnNlKChyb3cgPSBfKSA9PSBudWxsID8gcmVzcG9uc2UgOiB0eXBlZFJlc3BvbnNlKF8pKSA6IHJvdztcbiAgICAgIH07XG4gICAgICByZXR1cm4geGhyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZHN2LnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZWRSZXNwb25zZShmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gZHN2LnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0LCBmKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRzdi5wYXJzZSA9IGZ1bmN0aW9uKHRleHQsIGYpIHtcbiAgICAgIHZhciBvO1xuICAgICAgcmV0dXJuIGRzdi5wYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgIGlmIChvKSByZXR1cm4gbyhyb3csIGkgLSAxKTtcbiAgICAgICAgdmFyIGEgPSBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIHJvdy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbiAgICAgICAgbyA9IGYgPyBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgICByZXR1cm4gZihhKHJvdyksIGkpO1xuICAgICAgICB9IDogYTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZHN2LnBhcnNlUm93cyA9IGZ1bmN0aW9uKHRleHQsIGYpIHtcbiAgICAgIHZhciBFT0wgPSB7fSwgRU9GID0ge30sIHJvd3MgPSBbXSwgTiA9IHRleHQubGVuZ3RoLCBJID0gMCwgbiA9IDAsIHQsIGVvbDtcbiAgICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgICBpZiAoSSA+PSBOKSByZXR1cm4gRU9GO1xuICAgICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcbiAgICAgICAgdmFyIGogPSBJO1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSAzNCkge1xuICAgICAgICAgIHZhciBpID0gajtcbiAgICAgICAgICB3aGlsZSAoaSsrIDwgTikge1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gMzQpIHtcbiAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMSkgIT09IDM0KSBicmVhaztcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBJID0gaSArIDI7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDIpID09PSAxMCkgKytJO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpKS5yZXBsYWNlKC9cIlwiL2csICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KEkrKyksIGsgPSAxO1xuICAgICAgICAgIGlmIChjID09PSAxMCkgZW9sID0gdHJ1ZTsgZWxzZSBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSAxMCkgKytJLCArK2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChjICE9PSBkZWxpbWl0ZXJDb2RlKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBJIC0gayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2Uoaik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSB7XG4gICAgICAgICAgYS5wdXNoKHQpO1xuICAgICAgICAgIHQgPSB0b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmICYmIChhID0gZihhLCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgcm93cy5wdXNoKGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICBkc3YuZm9ybWF0ID0gZnVuY3Rpb24ocm93cykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93c1swXSkpIHJldHVybiBkc3YuZm9ybWF0Um93cyhyb3dzKTtcbiAgICAgIHZhciBmaWVsZFNldCA9IG5ldyBkM19TZXQoKSwgZmllbGRzID0gW107XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGZvciAodmFyIGZpZWxkIGluIHJvdykge1xuICAgICAgICAgIGlmICghZmllbGRTZXQuaGFzKGZpZWxkKSkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGRTZXQuYWRkKGZpZWxkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbIGZpZWxkcy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKSBdLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2ZpZWxkXSk7XG4gICAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgIH0pKS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgZHN2LmZvcm1hdFJvd3MgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodGV4dCkge1xuICAgICAgcmV0dXJuIHJlRm9ybWF0LnRlc3QodGV4dCkgPyAnXCInICsgdGV4dC5yZXBsYWNlKC9cXFwiL2csICdcIlwiJykgKyAnXCInIDogdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGRzdjtcbiAgfTtcbiAgZDMuY3N2ID0gZDMuZHN2KFwiLFwiLCBcInRleHQvY3N2XCIpO1xuICBkMy50c3YgPSBkMy5kc3YoXCJcdFwiLCBcInRleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXNcIik7XG4gIHZhciBkM190aW1lcl9xdWV1ZUhlYWQsIGQzX3RpbWVyX3F1ZXVlVGFpbCwgZDNfdGltZXJfaW50ZXJ2YWwsIGQzX3RpbWVyX3RpbWVvdXQsIGQzX3RpbWVyX2ZyYW1lID0gdGhpc1tkM192ZW5kb3JTeW1ib2wodGhpcywgXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMTcpO1xuICB9O1xuICBkMy50aW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIGQzX3RpbWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGhlbikge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDIpIGRlbGF5ID0gMDtcbiAgICBpZiAobiA8IDMpIHRoZW4gPSBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lID0gdGhlbiArIGRlbGF5LCB0aW1lciA9IHtcbiAgICAgIGM6IGNhbGxiYWNrLFxuICAgICAgdDogdGltZSxcbiAgICAgIG46IG51bGxcbiAgICB9O1xuICAgIGlmIChkM190aW1lcl9xdWV1ZVRhaWwpIGQzX3RpbWVyX3F1ZXVlVGFpbC5uID0gdGltZXI7IGVsc2UgZDNfdGltZXJfcXVldWVIZWFkID0gdGltZXI7XG4gICAgZDNfdGltZXJfcXVldWVUYWlsID0gdGltZXI7XG4gICAgaWYgKCFkM190aW1lcl9pbnRlcnZhbCkge1xuICAgICAgZDNfdGltZXJfdGltZW91dCA9IGNsZWFyVGltZW91dChkM190aW1lcl90aW1lb3V0KTtcbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMTtcbiAgICAgIGQzX3RpbWVyX2ZyYW1lKGQzX3RpbWVyX3N0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZXJfc3RlcCgpIHtcbiAgICB2YXIgbm93ID0gZDNfdGltZXJfbWFyaygpLCBkZWxheSA9IGQzX3RpbWVyX3N3ZWVwKCkgLSBub3c7XG4gICAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICAgIGlmIChpc0Zpbml0ZShkZWxheSkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGQzX3RpbWVyX3RpbWVvdXQpO1xuICAgICAgICBkM190aW1lcl90aW1lb3V0ID0gc2V0VGltZW91dChkM190aW1lcl9zdGVwLCBkZWxheSk7XG4gICAgICB9XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMTtcbiAgICAgIGQzX3RpbWVyX2ZyYW1lKGQzX3RpbWVyX3N0ZXApO1xuICAgIH1cbiAgfVxuICBkMy50aW1lci5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGQzX3RpbWVyX21hcmsoKTtcbiAgICBkM190aW1lcl9zd2VlcCgpO1xuICB9O1xuICBmdW5jdGlvbiBkM190aW1lcl9tYXJrKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpLCB0aW1lciA9IGQzX3RpbWVyX3F1ZXVlSGVhZDtcbiAgICB3aGlsZSAodGltZXIpIHtcbiAgICAgIGlmIChub3cgPj0gdGltZXIudCAmJiB0aW1lci5jKG5vdyAtIHRpbWVyLnQpKSB0aW1lci5jID0gbnVsbDtcbiAgICAgIHRpbWVyID0gdGltZXIubjtcbiAgICB9XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lcl9zd2VlcCgpIHtcbiAgICB2YXIgdDAsIHQxID0gZDNfdGltZXJfcXVldWVIZWFkLCB0aW1lID0gSW5maW5pdHk7XG4gICAgd2hpbGUgKHQxKSB7XG4gICAgICBpZiAodDEuYykge1xuICAgICAgICBpZiAodDEudCA8IHRpbWUpIHRpbWUgPSB0MS50O1xuICAgICAgICB0MSA9ICh0MCA9IHQxKS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdDEgPSB0MCA/IHQwLm4gPSB0MS5uIDogZDNfdGltZXJfcXVldWVIZWFkID0gdDEubjtcbiAgICAgIH1cbiAgICB9XG4gICAgZDNfdGltZXJfcXVldWVUYWlsID0gdDA7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZm9ybWF0X3ByZWNpc2lvbih4LCBwKSB7XG4gICAgcmV0dXJuIHAgLSAoeCA/IE1hdGguY2VpbChNYXRoLmxvZyh4KSAvIE1hdGguTE4xMCkgOiAxKTtcbiAgfVxuICBkMy5yb3VuZCA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgICByZXR1cm4gbiA/IE1hdGgucm91bmQoeCAqIChuID0gTWF0aC5wb3coMTAsIG4pKSkgLyBuIDogTWF0aC5yb3VuZCh4KTtcbiAgfTtcbiAgdmFyIGQzX2Zvcm1hdFByZWZpeGVzID0gWyBcInlcIiwgXCJ6XCIsIFwiYVwiLCBcImZcIiwgXCJwXCIsIFwiblwiLCBcIsK1XCIsIFwibVwiLCBcIlwiLCBcImtcIiwgXCJNXCIsIFwiR1wiLCBcIlRcIiwgXCJQXCIsIFwiRVwiLCBcIlpcIiwgXCJZXCIgXS5tYXAoZDNfZm9ybWF0UHJlZml4KTtcbiAgZDMuZm9ybWF0UHJlZml4ID0gZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlICo9IC0xO1xuICAgICAgaWYgKHByZWNpc2lvbikgdmFsdWUgPSBkMy5yb3VuZCh2YWx1ZSwgZDNfZm9ybWF0X3ByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKSk7XG4gICAgICBpID0gMSArIE1hdGguZmxvb3IoMWUtMTIgKyBNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTApO1xuICAgICAgaSA9IE1hdGgubWF4KC0yNCwgTWF0aC5taW4oMjQsIE1hdGguZmxvb3IoKGkgLSAxKSAvIDMpICogMykpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfZm9ybWF0UHJlZml4ZXNbOCArIGkgLyAzXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZm9ybWF0UHJlZml4KGQsIGkpIHtcbiAgICB2YXIgayA9IE1hdGgucG93KDEwLCBhYnMoOCAtIGkpICogMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlOiBpID4gOCA/IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgLyBrO1xuICAgICAgfSA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgKiBrO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbDogZFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbG9jYWxlX251bWJlckZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCwgbG9jYWxlX3Rob3VzYW5kcyA9IGxvY2FsZS50aG91c2FuZHMsIGxvY2FsZV9ncm91cGluZyA9IGxvY2FsZS5ncm91cGluZywgbG9jYWxlX2N1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LCBmb3JtYXRHcm91cCA9IGxvY2FsZV9ncm91cGluZyAmJiBsb2NhbGVfdGhvdXNhbmRzID8gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCwgdCA9IFtdLCBqID0gMCwgZyA9IGxvY2FsZV9ncm91cGluZ1swXSwgbGVuZ3RoID0gMDtcbiAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgICAgZyA9IGxvY2FsZV9ncm91cGluZ1tqID0gKGogKyAxKSAlIGxvY2FsZV9ncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4obG9jYWxlX3Rob3VzYW5kcyk7XG4gICAgfSA6IGQzX2lkZW50aXR5O1xuICAgIHJldHVybiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBtYXRjaCA9IGQzX2Zvcm1hdF9yZS5leGVjKHNwZWNpZmllciksIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIiwgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIiwgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLCBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLCB6ZmlsbCA9IG1hdGNoWzVdLCB3aWR0aCA9ICttYXRjaFs2XSwgY29tbWEgPSBtYXRjaFs3XSwgcHJlY2lzaW9uID0gbWF0Y2hbOF0sIHR5cGUgPSBtYXRjaFs5XSwgc2NhbGUgPSAxLCBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiLCBpbnRlZ2VyID0gZmFsc2UsIGV4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcmVjaXNpb24pIHByZWNpc2lvbiA9ICtwcmVjaXNpb24uc3Vic3RyaW5nKDEpO1xuICAgICAgaWYgKHpmaWxsIHx8IGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikge1xuICAgICAgICB6ZmlsbCA9IGZpbGwgPSBcIjBcIjtcbiAgICAgICAgYWxpZ24gPSBcIj1cIjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgIGNvbW1hID0gdHJ1ZTtcbiAgICAgICAgdHlwZSA9IFwiZ1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICBzdWZmaXggPSBcIiVcIjtcbiAgICAgICAgdHlwZSA9IFwiZlwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICBzdWZmaXggPSBcIiVcIjtcbiAgICAgICAgdHlwZSA9IFwiclwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICBjYXNlIFwieFwiOlxuICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgIGlmIChzeW1ib2wgPT09IFwiI1wiKSBwcmVmaXggPSBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIGV4cG9uZW50ID0gZmFsc2U7XG5cbiAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICBpbnRlZ2VyID0gdHJ1ZTtcbiAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICBzY2FsZSA9IC0xO1xuICAgICAgICB0eXBlID0gXCJyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN5bWJvbCA9PT0gXCIkXCIpIHByZWZpeCA9IGxvY2FsZV9jdXJyZW5jeVswXSwgc3VmZml4ID0gbG9jYWxlX2N1cnJlbmN5WzFdO1xuICAgICAgaWYgKHR5cGUgPT0gXCJyXCIgJiYgIXByZWNpc2lvbikgdHlwZSA9IFwiZ1wiO1xuICAgICAgaWYgKHByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiZ1wiKSBwcmVjaXNpb24gPSBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSk7IGVsc2UgaWYgKHR5cGUgPT0gXCJlXCIgfHwgdHlwZSA9PSBcImZcIikgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGQzX2Zvcm1hdF90eXBlcy5nZXQodHlwZSkgfHwgZDNfZm9ybWF0X3R5cGVEZWZhdWx0O1xuICAgICAgdmFyIHpjb21tYSA9IHpmaWxsICYmIGNvbW1hO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBmdWxsU3VmZml4ID0gc3VmZml4O1xuICAgICAgICBpZiAoaW50ZWdlciAmJiB2YWx1ZSAlIDEpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/ICh2YWx1ZSA9IC12YWx1ZSwgXCItXCIpIDogc2lnbiA9PT0gXCItXCIgPyBcIlwiIDogc2lnbjtcbiAgICAgICAgaWYgKHNjYWxlIDwgMCkge1xuICAgICAgICAgIHZhciB1bml0ID0gZDMuZm9ybWF0UHJlZml4KHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICAgIHZhbHVlID0gdW5pdC5zY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgZnVsbFN1ZmZpeCA9IHVuaXQuc3ltYm9sICsgc3VmZml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICo9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgdmFyIGkgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi5cIiksIGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgIHZhciBqID0gZXhwb25lbnQgPyB2YWx1ZS5sYXN0SW5kZXhPZihcImVcIikgOiAtMTtcbiAgICAgICAgICBpZiAoaiA8IDApIGJlZm9yZSA9IHZhbHVlLCBhZnRlciA9IFwiXCI7IGVsc2UgYmVmb3JlID0gdmFsdWUuc3Vic3RyaW5nKDAsIGopLCBhZnRlciA9IHZhbHVlLnN1YnN0cmluZyhqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgICAgYWZ0ZXIgPSBsb2NhbGVfZGVjaW1hbCArIHZhbHVlLnN1YnN0cmluZyhpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6ZmlsbCAmJiBjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAoYmVmb3JlLCBJbmZpbml0eSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgYmVmb3JlLmxlbmd0aCArIGFmdGVyLmxlbmd0aCArICh6Y29tbWEgPyAwIDogbmVnYXRpdmUubGVuZ3RoKSwgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KGxlbmd0aCA9IHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG4gICAgICAgIGlmICh6Y29tbWEpIGJlZm9yZSA9IGZvcm1hdEdyb3VwKHBhZGRpbmcgKyBiZWZvcmUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSBhZnRlci5sZW5ndGggOiBJbmZpbml0eSk7XG4gICAgICAgIG5lZ2F0aXZlICs9IHByZWZpeDtcbiAgICAgICAgdmFsdWUgPSBiZWZvcmUgKyBhZnRlcjtcbiAgICAgICAgcmV0dXJuIChhbGlnbiA9PT0gXCI8XCIgPyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZyA6IGFsaWduID09PSBcIj5cIiA/IHBhZGRpbmcgKyBuZWdhdGl2ZSArIHZhbHVlIDogYWxpZ24gPT09IFwiXlwiID8gcGFkZGluZy5zdWJzdHJpbmcoMCwgbGVuZ3RoID4+PSAxKSArIG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nLnN1YnN0cmluZyhsZW5ndGgpIDogbmVnYXRpdmUgKyAoemNvbW1hID8gdmFsdWUgOiBwYWRkaW5nICsgdmFsdWUpKSArIGZ1bGxTdWZmaXg7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Zvcm1hdF9yZSA9IC8oPzooW157XSk/KFs8Pj1eXSkpPyhbK1xcLSBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLi0/XFxkKyk/KFthLXolXSk/L2k7XG4gIHZhciBkM19mb3JtYXRfdHlwZXMgPSBkMy5tYXAoe1xuICAgIGI6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDIpO1xuICAgIH0sXG4gICAgYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZyg4KTtcbiAgICB9LFxuICAgIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KTtcbiAgICB9LFxuICAgIFg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgZzogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b0V4cG9uZW50aWFsKHApO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChwKTtcbiAgICB9LFxuICAgIHI6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiAoeCA9IGQzLnJvdW5kKHgsIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCwgcCkpKS50b0ZpeGVkKE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBkM19mb3JtYXRfcHJlY2lzaW9uKHggKiAoMSArIDFlLTE1KSwgcCkpKSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZDNfZm9ybWF0X3R5cGVEZWZhdWx0KHgpIHtcbiAgICByZXR1cm4geCArIFwiXCI7XG4gIH1cbiAgdmFyIGQzX3RpbWUgPSBkMy50aW1lID0ge30sIGQzX2RhdGUgPSBEYXRlO1xuICBmdW5jdGlvbiBkM19kYXRlX3V0YygpIHtcbiAgICB0aGlzLl8gPSBuZXcgRGF0ZShhcmd1bWVudHMubGVuZ3RoID4gMSA/IERhdGUuVVRDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF0pO1xuICB9XG4gIGQzX2RhdGVfdXRjLnByb3RvdHlwZSA9IHtcbiAgICBnZXREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRGF0ZSgpO1xuICAgIH0sXG4gICAgZ2V0RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRGF5KCk7XG4gICAgfSxcbiAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgfSxcbiAgICBnZXRIb3VyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0hvdXJzKCk7XG4gICAgfSxcbiAgICBnZXRNaWxsaXNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB9LFxuICAgIGdldE1pbnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNaW51dGVzKCk7XG4gICAgfSxcbiAgICBnZXRNb250aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01vbnRoKCk7XG4gICAgfSxcbiAgICBnZXRTZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDU2Vjb25kcygpO1xuICAgIH0sXG4gICAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFRpbWUoKTtcbiAgICB9LFxuICAgIGdldFRpbWV6b25lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLnZhbHVlT2YoKTtcbiAgICB9LFxuICAgIHNldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRGF0ZS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXREYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRGF5LmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEZ1bGxZZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEhvdXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0hvdXJzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1pbGxpc2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNaWxsaXNlY29uZHMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TWludXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNaW51dGVzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1vbnRoOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01vbnRoLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldFNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDU2Vjb25kcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFRpbWUuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX3RpbWVfcHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGQzX3RpbWVfaW50ZXJ2YWwobG9jYWwsIHN0ZXAsIG51bWJlcikge1xuICAgIGZ1bmN0aW9uIHJvdW5kKGRhdGUpIHtcbiAgICAgIHZhciBkMCA9IGxvY2FsKGRhdGUpLCBkMSA9IG9mZnNldChkMCwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VpbChkYXRlKSB7XG4gICAgICBzdGVwKGRhdGUgPSBsb2NhbChuZXcgZDNfZGF0ZShkYXRlIC0gMSkpLCAxKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvZmZzZXQoZGF0ZSwgaykge1xuICAgICAgc3RlcChkYXRlID0gbmV3IGQzX2RhdGUoK2RhdGUpLCBrKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZSh0MCwgdDEsIGR0KSB7XG4gICAgICB2YXIgdGltZSA9IGNlaWwodDApLCB0aW1lcyA9IFtdO1xuICAgICAgaWYgKGR0ID4gMSkge1xuICAgICAgICB3aGlsZSAodGltZSA8IHQxKSB7XG4gICAgICAgICAgaWYgKCEobnVtYmVyKHRpbWUpICUgZHQpKSB0aW1lcy5wdXNoKG5ldyBEYXRlKCt0aW1lKSk7XG4gICAgICAgICAgc3RlcCh0aW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHRpbWUgPCB0MSkgdGltZXMucHVzaChuZXcgRGF0ZSgrdGltZSkpLCBzdGVwKHRpbWUsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZV91dGModDAsIHQxLCBkdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGVfdXRjKCk7XG4gICAgICAgIHV0Yy5fID0gdDA7XG4gICAgICAgIHJldHVybiByYW5nZSh1dGMsIHQxLCBkdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9jYWwuZmxvb3IgPSBsb2NhbDtcbiAgICBsb2NhbC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvY2FsLmNlaWwgPSBjZWlsO1xuICAgIGxvY2FsLm9mZnNldCA9IG9mZnNldDtcbiAgICBsb2NhbC5yYW5nZSA9IHJhbmdlO1xuICAgIHZhciB1dGMgPSBsb2NhbC51dGMgPSBkM190aW1lX2ludGVydmFsX3V0Yyhsb2NhbCk7XG4gICAgdXRjLmZsb29yID0gdXRjO1xuICAgIHV0Yy5yb3VuZCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKHJvdW5kKTtcbiAgICB1dGMuY2VpbCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKGNlaWwpO1xuICAgIHV0Yy5vZmZzZXQgPSBkM190aW1lX2ludGVydmFsX3V0YyhvZmZzZXQpO1xuICAgIHV0Yy5yYW5nZSA9IHJhbmdlX3V0YztcbiAgICByZXR1cm4gbG9jYWw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9pbnRlcnZhbF91dGMobWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUsIGspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlX3V0YygpO1xuICAgICAgICB1dGMuXyA9IGRhdGU7XG4gICAgICAgIHJldHVybiBtZXRob2QodXRjLCBrKS5fO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkM190aW1lLnllYXIgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG4gIGQzX3RpbWUueWVhcnMgPSBkM190aW1lLnllYXIucmFuZ2U7XG4gIGQzX3RpbWUueWVhcnMudXRjID0gZDNfdGltZS55ZWFyLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5kYXkgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZGF5ID0gbmV3IGQzX2RhdGUoMmUzLCAwKTtcbiAgICBkYXkuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICByZXR1cm4gZGF5O1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbiAgfSk7XG4gIGQzX3RpbWUuZGF5cyA9IGQzX3RpbWUuZGF5LnJhbmdlO1xuICBkM190aW1lLmRheXMudXRjID0gZDNfdGltZS5kYXkudXRjLnJhbmdlO1xuICBkM190aW1lLmRheU9mWWVhciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgeWVhciA9IGQzX3RpbWUueWVhcihkYXRlKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZSAtIHllYXIgLSAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0geWVhci5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNSk7XG4gIH07XG4gIFsgXCJzdW5kYXlcIiwgXCJtb25kYXlcIiwgXCJ0dWVzZGF5XCIsIFwid2VkbmVzZGF5XCIsIFwidGh1cnNkYXlcIiwgXCJmcmlkYXlcIiwgXCJzYXR1cmRheVwiIF0uZm9yRWFjaChmdW5jdGlvbihkYXksIGkpIHtcbiAgICBpID0gNyAtIGk7XG4gICAgdmFyIGludGVydmFsID0gZDNfdGltZVtkYXldID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICAoZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpKS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyBpKSAlIDcpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZGF5ID0gZDNfdGltZS55ZWFyKGRhdGUpLmdldERheSgpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGQzX3RpbWUuZGF5T2ZZZWFyKGRhdGUpICsgKGRheSArIGkpICUgNykgLyA3KSAtIChkYXkgIT09IGkpO1xuICAgIH0pO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJzXCJdID0gaW50ZXJ2YWwucmFuZ2U7XG4gICAgZDNfdGltZVtkYXkgKyBcInNcIl0udXRjID0gaW50ZXJ2YWwudXRjLnJhbmdlO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJPZlllYXJcIl0gPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZGF5ID0gZDNfdGltZS55ZWFyKGRhdGUpLmdldERheSgpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGQzX3RpbWUuZGF5T2ZZZWFyKGRhdGUpICsgKGRheSArIGkpICUgNykgLyA3KTtcbiAgICB9O1xuICB9KTtcbiAgZDNfdGltZS53ZWVrID0gZDNfdGltZS5zdW5kYXk7XG4gIGQzX3RpbWUud2Vla3MgPSBkM190aW1lLnN1bmRheS5yYW5nZTtcbiAgZDNfdGltZS53ZWVrcy51dGMgPSBkM190aW1lLnN1bmRheS51dGMucmFuZ2U7XG4gIGQzX3RpbWUud2Vla09mWWVhciA9IGQzX3RpbWUuc3VuZGF5T2ZZZWFyO1xuICBmdW5jdGlvbiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLCBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLCBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLCBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLCBsb2NhbGVfZGF5cyA9IGxvY2FsZS5kYXlzLCBsb2NhbGVfc2hvcnREYXlzID0gbG9jYWxlLnNob3J0RGF5cywgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcbiAgICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdCh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIG4gPSB0ZW1wbGF0ZS5sZW5ndGg7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gW10sIGkgPSAtMSwgaiA9IDAsIGMsIHAsIGY7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaCh0ZW1wbGF0ZS5zbGljZShqLCBpKSk7XG4gICAgICAgICAgICBpZiAoKHAgPSBkM190aW1lX2Zvcm1hdFBhZHNbYyA9IHRlbXBsYXRlLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHRlbXBsYXRlLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGYgPSBkM190aW1lX2Zvcm1hdHNbY10pIGMgPSBmKGRhdGUsIHAgPT0gbnVsbCA/IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIiA6IHApO1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmluZy5wdXNoKHRlbXBsYXRlLnNsaWNlKGosIGkpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBkID0ge1xuICAgICAgICAgIHk6IDE5MDAsXG4gICAgICAgICAgbTogMCxcbiAgICAgICAgICBkOiAxLFxuICAgICAgICAgIEg6IDAsXG4gICAgICAgICAgTTogMCxcbiAgICAgICAgICBTOiAwLFxuICAgICAgICAgIEw6IDAsXG4gICAgICAgICAgWjogbnVsbFxuICAgICAgICB9LCBpID0gZDNfdGltZV9wYXJzZShkLCB0ZW1wbGF0ZSwgc3RyaW5nLCAwKTtcbiAgICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuICAgICAgICB2YXIgbG9jYWxaID0gZC5aICE9IG51bGwgJiYgZDNfZGF0ZSAhPT0gZDNfZGF0ZV91dGMsIGRhdGUgPSBuZXcgKGxvY2FsWiA/IGQzX2RhdGVfdXRjIDogZDNfZGF0ZSkoKTtcbiAgICAgICAgaWYgKFwialwiIGluIGQpIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBkLmopOyBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCAxKTtcbiAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSwgMCwgXCJXXCIgaW4gZCA/IChkLncgKyA2KSAlIDcgKyBkLlcgKiA3IC0gKGRhdGUuZ2V0RGF5KCkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpO1xuICAgICAgICB9IGVsc2UgZGF0ZS5zZXRGdWxsWWVhcihkLnksIGQubSwgZC5kKTtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhkLkggKyAoZC5aIC8gMTAwIHwgMCksIGQuTSArIGQuWiAlIDEwMCwgZC5TLCBkLkwpO1xuICAgICAgICByZXR1cm4gbG9jYWxaID8gZGF0ZS5fIDogZGF0ZTtcbiAgICAgIH07XG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2UoZGF0ZSwgdGVtcGxhdGUsIHN0cmluZywgaikge1xuICAgICAgdmFyIGMsIHAsIHQsIGkgPSAwLCBuID0gdGVtcGxhdGUubGVuZ3RoLCBtID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICAgIGMgPSB0ZW1wbGF0ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICAgIHQgPSB0ZW1wbGF0ZS5jaGFyQXQoaSsrKTtcbiAgICAgICAgICBwID0gZDNfdGltZV9wYXJzZXJzW3QgaW4gZDNfdGltZV9mb3JtYXRQYWRzID8gdGVtcGxhdGUuY2hhckF0KGkrKykgOiB0XTtcbiAgICAgICAgICBpZiAoIXAgfHwgKGogPSBwKGRhdGUsIHN0cmluZywgaikpIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGo7XG4gICAgfVxuICAgIGQzX3RpbWVfZm9ybWF0LnV0YyA9IGZ1bmN0aW9uKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgbG9jYWwgPSBkM190aW1lX2Zvcm1hdCh0ZW1wbGF0ZSk7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGUoKTtcbiAgICAgICAgICB1dGMuXyA9IGRhdGU7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsKHV0Yyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgICB2YXIgZGF0ZSA9IGxvY2FsLnBhcnNlKHN0cmluZyk7XG4gICAgICAgICAgcmV0dXJuIGRhdGUgJiYgZGF0ZS5fO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9ybWF0LnRvU3RyaW5nID0gbG9jYWwudG9TdHJpbmc7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG4gICAgZDNfdGltZV9mb3JtYXQubXVsdGkgPSBkM190aW1lX2Zvcm1hdC51dGMubXVsdGkgPSBkM190aW1lX2Zvcm1hdE11bHRpO1xuICAgIHZhciBkM190aW1lX3BlcmlvZExvb2t1cCA9IGQzLm1hcCgpLCBkM190aW1lX2RheVJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfZGF5cyksIGQzX3RpbWVfZGF5TG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX2RheXMpLCBkM190aW1lX2RheUFiYnJldlJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfc2hvcnREYXlzKSwgZDNfdGltZV9kYXlBYmJyZXZMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfc2hvcnREYXlzKSwgZDNfdGltZV9tb250aFJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfbW9udGhzKSwgZDNfdGltZV9tb250aExvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLCBkM190aW1lX21vbnRoQWJicmV2UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksIGQzX3RpbWVfbW9udGhBYmJyZXZMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuICAgIGxvY2FsZV9wZXJpb2RzLmZvckVhY2goZnVuY3Rpb24ocCwgaSkge1xuICAgICAgZDNfdGltZV9wZXJpb2RMb29rdXAuc2V0KHAudG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgfSk7XG4gICAgdmFyIGQzX3RpbWVfZm9ybWF0cyA9IHtcbiAgICAgIGE6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydERheXNbZC5nZXREYXkoKV07XG4gICAgICB9LFxuICAgICAgQTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX2RheXNbZC5nZXREYXkoKV07XG4gICAgICB9LFxuICAgICAgYjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgICB9LFxuICAgICAgQjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgICAgfSxcbiAgICAgIGM6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV9kYXRlVGltZSksXG4gICAgICBkOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgZTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIEg6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgSTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIGo6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKDEgKyBkM190aW1lLmRheU9mWWVhcihkKSwgcCwgMyk7XG4gICAgICB9LFxuICAgICAgTDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gICAgICB9LFxuICAgICAgUzogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIFU6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQzX3RpbWUuc3VuZGF5T2ZZZWFyKGQpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkLmdldERheSgpO1xuICAgICAgfSxcbiAgICAgIFc6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQzX3RpbWUubW9uZGF5T2ZZZWFyKGQpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICB4OiBkM190aW1lX2Zvcm1hdChsb2NhbGVfZGF0ZSksXG4gICAgICBYOiBkM190aW1lX2Zvcm1hdChsb2NhbGVfdGltZSksXG4gICAgICB5OiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIFk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDFlNCwgcCwgNCk7XG4gICAgICB9LFxuICAgICAgWjogZDNfdGltZV96b25lLFxuICAgICAgXCIlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCIlXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZDNfdGltZV9wYXJzZXJzID0ge1xuICAgICAgYTogZDNfdGltZV9wYXJzZVdlZWtkYXlBYmJyZXYsXG4gICAgICBBOiBkM190aW1lX3BhcnNlV2Vla2RheSxcbiAgICAgIGI6IGQzX3RpbWVfcGFyc2VNb250aEFiYnJldixcbiAgICAgIEI6IGQzX3RpbWVfcGFyc2VNb250aCxcbiAgICAgIGM6IGQzX3RpbWVfcGFyc2VMb2NhbGVGdWxsLFxuICAgICAgZDogZDNfdGltZV9wYXJzZURheSxcbiAgICAgIGU6IGQzX3RpbWVfcGFyc2VEYXksXG4gICAgICBIOiBkM190aW1lX3BhcnNlSG91cjI0LFxuICAgICAgSTogZDNfdGltZV9wYXJzZUhvdXIyNCxcbiAgICAgIGo6IGQzX3RpbWVfcGFyc2VEYXlPZlllYXIsXG4gICAgICBMOiBkM190aW1lX3BhcnNlTWlsbGlzZWNvbmRzLFxuICAgICAgbTogZDNfdGltZV9wYXJzZU1vbnRoTnVtYmVyLFxuICAgICAgTTogZDNfdGltZV9wYXJzZU1pbnV0ZXMsXG4gICAgICBwOiBkM190aW1lX3BhcnNlQW1QbSxcbiAgICAgIFM6IGQzX3RpbWVfcGFyc2VTZWNvbmRzLFxuICAgICAgVTogZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgICB3OiBkM190aW1lX3BhcnNlV2Vla2RheU51bWJlcixcbiAgICAgIFc6IGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgeDogZDNfdGltZV9wYXJzZUxvY2FsZURhdGUsXG4gICAgICBYOiBkM190aW1lX3BhcnNlTG9jYWxlVGltZSxcbiAgICAgIHk6IGQzX3RpbWVfcGFyc2VZZWFyLFxuICAgICAgWTogZDNfdGltZV9wYXJzZUZ1bGxZZWFyLFxuICAgICAgWjogZDNfdGltZV9wYXJzZVpvbmUsXG4gICAgICBcIiVcIjogZDNfdGltZV9wYXJzZUxpdGVyYWxQZXJjZW50XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla2RheUFiYnJldihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfZGF5QWJicmV2UmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9kYXlBYmJyZXZSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLncgPSBkM190aW1lX2RheUFiYnJldkxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla2RheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfZGF5UmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9kYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLncgPSBkM190aW1lX2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGhBYmJyZXYoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX21vbnRoQWJicmV2UmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9tb250aEFiYnJldlJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUubSA9IGQzX3RpbWVfbW9udGhBYmJyZXZMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1vbnRoKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9tb250aFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLm0gPSBkM190aW1lX21vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVGdWxsKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLmMudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZURhdGUoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMueC50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlVGltZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy5YLnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VBbVBtKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBkM190aW1lX3BlcmlvZExvb2t1cC5nZXQoc3RyaW5nLnNsaWNlKGksIGkgKz0gMikudG9Mb3dlckNhc2UoKSk7XG4gICAgICByZXR1cm4gbiA9PSBudWxsID8gLTEgOiAoZGF0ZS5wID0gbiwgaSk7XG4gICAgfVxuICAgIHJldHVybiBkM190aW1lX2Zvcm1hdDtcbiAgfVxuICB2YXIgZDNfdGltZV9mb3JtYXRQYWRzID0ge1xuICAgIFwiLVwiOiBcIlwiLFxuICAgIF86IFwiIFwiLFxuICAgIFwiMFwiOiBcIjBcIlxuICB9LCBkM190aW1lX251bWJlclJlID0gL15cXHMqXFxkKy8sIGQzX3RpbWVfcGVyY2VudFJlID0gL14lLztcbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRQYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIiwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0UmUobmFtZXMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChkMy5yZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgICB2YXIgbWFwID0gbmV3IGQzX01hcCgpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQobmFtZXNbaV0udG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla2RheU51bWJlcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla051bWJlclN1bmRheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUZ1bGxZZWFyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VZZWFyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLnkgPSBkM190aW1lX2V4cGFuZFllYXIoK25bMF0pLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVpvbmUoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIC9eWystXVxcZHs0fSQvLnRlc3Qoc3RyaW5nID0gc3RyaW5nLnNsaWNlKGksIGkgKyA1KSkgPyAoZGF0ZS5aID0gLXN0cmluZywgXG4gICAgaSArIDUpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9leHBhbmRZZWFyKGQpIHtcbiAgICByZXR1cm4gZCArIChkID4gNjggPyAxOTAwIDogMmUzKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGhOdW1iZXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZURheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRGF5T2ZZZWFyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLmogPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VIb3VyMjQoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1pbnV0ZXMoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVNlY29uZHMoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1pbGxpc2Vjb25kcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3pvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpLCB6cyA9IHogPiAwID8gXCItXCIgOiBcIitcIiwgemggPSBhYnMoeikgLyA2MCB8IDAsIHptID0gYWJzKHopICUgNjA7XG4gICAgcmV0dXJuIHpzICsgZDNfdGltZV9mb3JtYXRQYWQoemgsIFwiMFwiLCAyKSArIGQzX3RpbWVfZm9ybWF0UGFkKHptLCBcIjBcIiwgMik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxpdGVyYWxQZXJjZW50KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfcGVyY2VudFJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX3BlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRNdWx0aShmb3JtYXRzKSB7XG4gICAgdmFyIG4gPSBmb3JtYXRzLmxlbmd0aCwgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBuKSBmb3JtYXRzW2ldWzBdID0gdGhpcyhmb3JtYXRzW2ldWzBdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGkgPSAwLCBmID0gZm9ybWF0c1tpXTtcbiAgICAgIHdoaWxlICghZlsxXShkYXRlKSkgZiA9IGZvcm1hdHNbKytpXTtcbiAgICAgIHJldHVybiBmWzBdKGRhdGUpO1xuICAgIH07XG4gIH1cbiAgZDMubG9jYWxlID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlckZvcm1hdDogZDNfbG9jYWxlX251bWJlckZvcm1hdChsb2NhbGUpLFxuICAgICAgdGltZUZvcm1hdDogZDNfbG9jYWxlX3RpbWVGb3JtYXQobG9jYWxlKVxuICAgIH07XG4gIH07XG4gIHZhciBkM19sb2NhbGVfZW5VUyA9IGQzLmxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWyAzIF0sXG4gICAgY3VycmVuY3k6IFsgXCIkXCIsIFwiXCIgXSxcbiAgICBkYXRlVGltZTogXCIlYSAlYiAlZSAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJW0vJWQvJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogWyBcIkFNXCIsIFwiUE1cIiBdLFxuICAgIGRheXM6IFsgXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiIF0sXG4gICAgc2hvcnREYXlzOiBbIFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIgXSxcbiAgICBtb250aHM6IFsgXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiIF0sXG4gICAgc2hvcnRNb250aHM6IFsgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIiBdXG4gIH0pO1xuICBkMy5mb3JtYXQgPSBkM19sb2NhbGVfZW5VUy5udW1iZXJGb3JtYXQ7XG4gIGQzLmdlbyA9IHt9O1xuICBmdW5jdGlvbiBkM19hZGRlcigpIHt9XG4gIGQzX2FkZGVyLnByb3RvdHlwZSA9IHtcbiAgICBzOiAwLFxuICAgIHQ6IDAsXG4gICAgYWRkOiBmdW5jdGlvbih5KSB7XG4gICAgICBkM19hZGRlclN1bSh5LCB0aGlzLnQsIGQzX2FkZGVyVGVtcCk7XG4gICAgICBkM19hZGRlclN1bShkM19hZGRlclRlbXAucywgdGhpcy5zLCB0aGlzKTtcbiAgICAgIGlmICh0aGlzLnMpIHRoaXMudCArPSBkM19hZGRlclRlbXAudDsgZWxzZSB0aGlzLnMgPSBkM19hZGRlclRlbXAudDtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucyA9IHRoaXMudCA9IDA7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfYWRkZXJUZW1wID0gbmV3IGQzX2FkZGVyKCk7XG4gIGZ1bmN0aW9uIGQzX2FkZGVyU3VtKGEsIGIsIG8pIHtcbiAgICB2YXIgeCA9IG8ucyA9IGEgKyBiLCBidiA9IHggLSBhLCBhdiA9IHggLSBidjtcbiAgICBvLnQgPSBhIC0gYXYgKyAoYiAtIGJ2KTtcbiAgfVxuICBkMy5nZW8uc3RyZWFtID0gZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgIGlmIChvYmplY3QgJiYgZDNfZ2VvX3N0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgICBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX2dlb19zdHJlYW1HZW9tZXRyeShvYmplY3QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19zdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoZ2VvbWV0cnkgJiYgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICB2YXIgZDNfZ2VvX3N0cmVhbU9iamVjdFR5cGUgPSB7XG4gICAgRmVhdHVyZTogZnVuY3Rpb24oZmVhdHVyZSwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5VHlwZSA9IHtcbiAgICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyLnNwaGVyZSgpO1xuICAgIH0sXG4gICAgUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICAgIGxpc3RlbmVyLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICAgIH0sXG4gICAgTXVsdGlQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgb2JqZWN0ID0gY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICAgIH0sXG4gICAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBsaXN0ZW5lciwgMCk7XG4gICAgfSxcbiAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lciwgMCk7XG4gICAgfSxcbiAgICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19zdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBsaXN0ZW5lciwgY2xvc2VkKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcbiAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICB3aGlsZSAoKytpIDwgbikgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lci5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLCAxKTtcbiAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gIH1cbiAgZDMuZ2VvLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBkM19nZW9fYXJlYVN1bSA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19hcmVhKTtcbiAgICByZXR1cm4gZDNfZ2VvX2FyZWFTdW07XG4gIH07XG4gIHZhciBkM19nZW9fYXJlYVN1bSwgZDNfZ2VvX2FyZWFSaW5nU3VtID0gbmV3IGQzX2FkZGVyKCk7XG4gIHZhciBkM19nZW9fYXJlYSA9IHtcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2FyZWFTdW0gKz0gNCAqIM+AO1xuICAgIH0sXG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19hcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX2FyZWFSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmVhID0gMiAqIGQzX2dlb19hcmVhUmluZ1N1bTtcbiAgICAgIGQzX2dlb19hcmVhU3VtICs9IGFyZWEgPCAwID8gNCAqIM+AICsgYXJlYSA6IGFyZWE7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQgPSBkM19nZW9fYXJlYS5saW5lRW5kID0gZDNfZ2VvX2FyZWEucG9pbnQgPSBkM19ub29wO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2FyZWFSaW5nU3RhcnQoKSB7XG4gICAgdmFyIM67MDAsIM+GMDAsIM67MCwgY29zz4YwLCBzaW7PhjA7XG4gICAgZDNfZ2VvX2FyZWEucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIGQzX2dlb19hcmVhLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgzrswID0gKM67MDAgPSDOuykgKiBkM19yYWRpYW5zLCBjb3PPhjAgPSBNYXRoLmNvcyjPhiA9ICjPhjAwID0gz4YpICogZDNfcmFkaWFucyAvIDIgKyDPgCAvIDQpLCBcbiAgICAgIHNpbs+GMCA9IE1hdGguc2luKM+GKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICDPhiA9IM+GICogZDNfcmFkaWFucyAvIDIgKyDPgCAvIDQ7XG4gICAgICB2YXIgZM67ID0gzrsgLSDOuzAsIHNkzrsgPSBkzrsgPj0gMCA/IDEgOiAtMSwgYWTOuyA9IHNkzrsgKiBkzrssIGNvc8+GID0gTWF0aC5jb3Moz4YpLCBzaW7PhiA9IE1hdGguc2luKM+GKSwgayA9IHNpbs+GMCAqIHNpbs+GLCB1ID0gY29zz4YwICogY29zz4YgKyBrICogTWF0aC5jb3MoYWTOuyksIHYgPSBrICogc2TOuyAqIE1hdGguc2luKGFkzrspO1xuICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLmFkZChNYXRoLmF0YW4yKHYsIHUpKTtcbiAgICAgIM67MCA9IM67LCBjb3PPhjAgPSBjb3PPhiwgc2luz4YwID0gc2luz4Y7XG4gICAgfVxuICAgIGQzX2dlb19hcmVhLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCjOuzAwLCDPhjAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gICAgdmFyIM67ID0gc3BoZXJpY2FsWzBdLCDPhiA9IHNwaGVyaWNhbFsxXSwgY29zz4YgPSBNYXRoLmNvcyjPhik7XG4gICAgcmV0dXJuIFsgY29zz4YgKiBNYXRoLmNvcyjOuyksIGNvc8+GICogTWF0aC5zaW4ozrspLCBNYXRoLnNpbijPhikgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gICAgcmV0dXJuIFsgYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5BZGQoYSwgYikge1xuICAgIGFbMF0gKz0gYlswXTtcbiAgICBhWzFdICs9IGJbMV07XG4gICAgYVsyXSArPSBiWzJdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgICByZXR1cm4gWyB2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShkKSB7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgICBkWzBdIC89IGw7XG4gICAgZFsxXSAvPSBsO1xuICAgIGRbMl0gLz0gbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICAgIHJldHVybiBbIE1hdGguYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBkM19hc2luKGNhcnRlc2lhblsyXSkgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3BoZXJpY2FsRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgzrUgJiYgYWJzKGFbMV0gLSBiWzFdKSA8IM61O1xuICB9XG4gIGQzLmdlby5ib3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgzrswLCDPhjAsIM67MSwgz4YxLCDOu18sIM67X18sIM+GX18sIHAwLCBkzrtTdW0sIHJhbmdlcywgcmFuZ2U7XG4gICAgdmFyIGJvdW5kID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgYm91bmQucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICAgIGJvdW5kLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgYm91bmQubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgIGTOu1N1bSA9IDA7XG4gICAgICAgIGQzX2dlb19hcmVhLnBvbHlnb25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkM19nZW9fYXJlYS5wb2x5Z29uRW5kKCk7XG4gICAgICAgIGJvdW5kLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGJvdW5kLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgYm91bmQubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIGlmIChkM19nZW9fYXJlYVJpbmdTdW0gPCAwKSDOuzAgPSAtKM67MSA9IDE4MCksIM+GMCA9IC0oz4YxID0gOTApOyBlbHNlIGlmIChkzrtTdW0gPiDOtSkgz4YxID0gOTA7IGVsc2UgaWYgKGTOu1N1bSA8IC3OtSkgz4YwID0gLTkwO1xuICAgICAgICByYW5nZVswXSA9IM67MCwgcmFuZ2VbMV0gPSDOuzE7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCjOuywgz4YpIHtcbiAgICAgIHJhbmdlcy5wdXNoKHJhbmdlID0gWyDOuzAgPSDOuywgzrsxID0gzrsgXSk7XG4gICAgICBpZiAoz4YgPCDPhjApIM+GMCA9IM+GO1xuICAgICAgaWYgKM+GID4gz4YxKSDPhjEgPSDPhjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVBvaW50KM67LCDPhikge1xuICAgICAgdmFyIHAgPSBkM19nZW9fY2FydGVzaWFuKFsgzrsgKiBkM19yYWRpYW5zLCDPhiAqIGQzX3JhZGlhbnMgXSk7XG4gICAgICBpZiAocDApIHtcbiAgICAgICAgdmFyIG5vcm1hbCA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhwMCwgcCksIGVxdWF0b3JpYWwgPSBbIG5vcm1hbFsxXSwgLW5vcm1hbFswXSwgMCBdLCBpbmZsZWN0aW9uID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGVxdWF0b3JpYWwsIG5vcm1hbCk7XG4gICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoaW5mbGVjdGlvbik7XG4gICAgICAgIGluZmxlY3Rpb24gPSBkM19nZW9fc3BoZXJpY2FsKGluZmxlY3Rpb24pO1xuICAgICAgICB2YXIgZM67ID0gzrsgLSDOu18sIHMgPSBkzrsgPiAwID8gMSA6IC0xLCDOu2kgPSBpbmZsZWN0aW9uWzBdICogZDNfZGVncmVlcyAqIHMsIGFudGltZXJpZGlhbiA9IGFicyhkzrspID4gMTgwO1xuICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gKHMgKiDOu18gPCDOu2kgJiYgzrtpIDwgcyAqIM67KSkge1xuICAgICAgICAgIHZhciDPhmkgPSBpbmZsZWN0aW9uWzFdICogZDNfZGVncmVlcztcbiAgICAgICAgICBpZiAoz4ZpID4gz4YxKSDPhjEgPSDPhmk7XG4gICAgICAgIH0gZWxzZSBpZiAozrtpID0gKM67aSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzICogzrtfIDwgzrtpICYmIM67aSA8IHMgKiDOuykpIHtcbiAgICAgICAgICB2YXIgz4ZpID0gLWluZmxlY3Rpb25bMV0gKiBkM19kZWdyZWVzO1xuICAgICAgICAgIGlmICjPhmkgPCDPhjApIM+GMCA9IM+GaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoz4YgPCDPhjApIM+GMCA9IM+GO1xuICAgICAgICAgIGlmICjPhiA+IM+GMSkgz4YxID0gz4Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGltZXJpZGlhbikge1xuICAgICAgICAgIGlmICjOuyA8IM67Xykge1xuICAgICAgICAgICAgaWYgKGFuZ2xlKM67MCwgzrspID4gYW5nbGUozrswLCDOuzEpKSDOuzEgPSDOuztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFuZ2xlKM67LCDOuzEpID4gYW5nbGUozrswLCDOuzEpKSDOuzAgPSDOuztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKM67MSA+PSDOuzApIHtcbiAgICAgICAgICAgIGlmICjOuyA8IM67MCkgzrswID0gzrs7XG4gICAgICAgICAgICBpZiAozrsgPiDOuzEpIM67MSA9IM67O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAozrsgPiDOu18pIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ2xlKM67MCwgzrspID4gYW5nbGUozrswLCDOuzEpKSDOuzEgPSDOuztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChhbmdsZSjOuywgzrsxKSA+IGFuZ2xlKM67MCwgzrsxKSkgzrswID0gzrs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludCjOuywgz4YpO1xuICAgICAgfVxuICAgICAgcDAgPSBwLCDOu18gPSDOuztcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgYm91bmQucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICByYW5nZVswXSA9IM67MCwgcmFuZ2VbMV0gPSDOuzE7XG4gICAgICBib3VuZC5wb2ludCA9IHBvaW50O1xuICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nUG9pbnQozrssIM+GKSB7XG4gICAgICBpZiAocDApIHtcbiAgICAgICAgdmFyIGTOuyA9IM67IC0gzrtfO1xuICAgICAgICBkzrtTdW0gKz0gYWJzKGTOuykgPiAxODAgPyBkzrsgKyAoZM67ID4gMCA/IDM2MCA6IC0zNjApIDogZM67O1xuICAgICAgfSBlbHNlIM67X18gPSDOuywgz4ZfXyA9IM+GO1xuICAgICAgZDNfZ2VvX2FyZWEucG9pbnQozrssIM+GKTtcbiAgICAgIGxpbmVQb2ludCjOuywgz4YpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHJpbmdQb2ludCjOu19fLCDPhl9fKTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVFbmQoKTtcbiAgICAgIGlmIChhYnMoZM67U3VtKSA+IM61KSDOuzAgPSAtKM67MSA9IDE4MCk7XG4gICAgICByYW5nZVswXSA9IM67MCwgcmFuZ2VbMV0gPSDOuzE7XG4gICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFuZ2xlKM67MCwgzrsxKSB7XG4gICAgICByZXR1cm4gKM67MSAtPSDOuzApIDwgMCA/IM67MSArIDM2MCA6IM67MTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhhLCBiKSB7XG4gICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpdGhpblJhbmdlKHgsIHJhbmdlKSB7XG4gICAgICByZXR1cm4gcmFuZ2VbMF0gPD0gcmFuZ2VbMV0gPyByYW5nZVswXSA8PSB4ICYmIHggPD0gcmFuZ2VbMV0gOiB4IDwgcmFuZ2VbMF0gfHwgcmFuZ2VbMV0gPCB4O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgz4YxID0gzrsxID0gLSjOuzAgPSDPhjAgPSBJbmZpbml0eSk7XG4gICAgICByYW5nZXMgPSBbXTtcbiAgICAgIGQzLmdlby5zdHJlYW0oZmVhdHVyZSwgYm91bmQpO1xuICAgICAgdmFyIG4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBhID0gcmFuZ2VzWzBdLCBiLCBtZXJnZWQgPSBbIGEgXTsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGIgPSByYW5nZXNbaV07XG4gICAgICAgICAgaWYgKHdpdGhpblJhbmdlKGJbMF0sIGEpIHx8IHdpdGhpblJhbmdlKGJbMV0sIGEpKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVsxXSA9IGJbMV07XG4gICAgICAgICAgICBpZiAoYW5nbGUoYlswXSwgYVsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVswXSA9IGJbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlc3QgPSAtSW5maW5pdHksIGTOuztcbiAgICAgICAgZm9yICh2YXIgbiA9IG1lcmdlZC5sZW5ndGggLSAxLCBpID0gMCwgYSA9IG1lcmdlZFtuXSwgYjsgaSA8PSBuOyBhID0gYiwgKytpKSB7XG4gICAgICAgICAgYiA9IG1lcmdlZFtpXTtcbiAgICAgICAgICBpZiAoKGTOuyA9IGFuZ2xlKGFbMV0sIGJbMF0pKSA+IGJlc3QpIGJlc3QgPSBkzrssIM67MCA9IGJbMF0sIM67MSA9IGFbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJhbmdlcyA9IHJhbmdlID0gbnVsbDtcbiAgICAgIHJldHVybiDOuzAgPT09IEluZmluaXR5IHx8IM+GMCA9PT0gSW5maW5pdHkgPyBbIFsgTmFOLCBOYU4gXSwgWyBOYU4sIE5hTiBdIF0gOiBbIFsgzrswLCDPhjAgXSwgWyDOuzEsIM+GMSBdIF07XG4gICAgfTtcbiAgfSgpO1xuICBkMy5nZW8uY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBkM19nZW9fY2VudHJvaWRXMCA9IGQzX2dlb19jZW50cm9pZFcxID0gZDNfZ2VvX2NlbnRyb2lkWDAgPSBkM19nZW9fY2VudHJvaWRZMCA9IGQzX2dlb19jZW50cm9pZFowID0gZDNfZ2VvX2NlbnRyb2lkWDEgPSBkM19nZW9fY2VudHJvaWRZMSA9IGQzX2dlb19jZW50cm9pZFoxID0gZDNfZ2VvX2NlbnRyb2lkWDIgPSBkM19nZW9fY2VudHJvaWRZMiA9IGQzX2dlb19jZW50cm9pZFoyID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2NlbnRyb2lkKTtcbiAgICB2YXIgeCA9IGQzX2dlb19jZW50cm9pZFgyLCB5ID0gZDNfZ2VvX2NlbnRyb2lkWTIsIHogPSBkM19nZW9fY2VudHJvaWRaMiwgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICBpZiAobSA8IM61Mikge1xuICAgICAgeCA9IGQzX2dlb19jZW50cm9pZFgxLCB5ID0gZDNfZ2VvX2NlbnRyb2lkWTEsIHogPSBkM19nZW9fY2VudHJvaWRaMTtcbiAgICAgIGlmIChkM19nZW9fY2VudHJvaWRXMSA8IM61KSB4ID0gZDNfZ2VvX2NlbnRyb2lkWDAsIHkgPSBkM19nZW9fY2VudHJvaWRZMCwgeiA9IGQzX2dlb19jZW50cm9pZFowO1xuICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICAgIGlmIChtIDwgzrUyKSByZXR1cm4gWyBOYU4sIE5hTiBdO1xuICAgIH1cbiAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHksIHgpICogZDNfZGVncmVlcywgZDNfYXNpbih6IC8gTWF0aC5zcXJ0KG0pKSAqIGQzX2RlZ3JlZXMgXTtcbiAgfTtcbiAgdmFyIGQzX2dlb19jZW50cm9pZFcwLCBkM19nZW9fY2VudHJvaWRXMSwgZDNfZ2VvX2NlbnRyb2lkWDAsIGQzX2dlb19jZW50cm9pZFkwLCBkM19nZW9fY2VudHJvaWRaMCwgZDNfZ2VvX2NlbnRyb2lkWDEsIGQzX2dlb19jZW50cm9pZFkxLCBkM19nZW9fY2VudHJvaWRaMSwgZDNfZ2VvX2NlbnRyb2lkWDIsIGQzX2dlb19jZW50cm9pZFkyLCBkM19nZW9fY2VudHJvaWRaMjtcbiAgdmFyIGQzX2dlb19jZW50cm9pZCA9IHtcbiAgICBzcGhlcmU6IGQzX25vb3AsXG4gICAgcG9pbnQ6IGQzX2dlb19jZW50cm9pZFBvaW50LFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX2NlbnRyb2lkTGluZVN0YXJ0LFxuICAgIGxpbmVFbmQ6IGQzX2dlb19jZW50cm9pZExpbmVFbmQsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRQb2ludCjOuywgz4YpIHtcbiAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKGNvc8+GICogTWF0aC5jb3MozrspLCBjb3PPhiAqIE1hdGguc2luKM67KSwgTWF0aC5zaW4oz4YpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4LCB5LCB6KSB7XG4gICAgKytkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRYMCArPSAoeCAtIGQzX2dlb19jZW50cm9pZFgwKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFkwICs9ICh5IC0gZDNfZ2VvX2NlbnRyb2lkWTApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWjAgKz0gKHogLSBkM19nZW9fY2VudHJvaWRaMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gICAgdmFyIHgwLCB5MCwgejA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgICB4MCA9IGNvc8+GICogTWF0aC5jb3MozrspO1xuICAgICAgeTAgPSBjb3PPhiAqIE1hdGguc2luKM67KTtcbiAgICAgIHowID0gTWF0aC5zaW4oz4YpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyksIHggPSBjb3PPhiAqIE1hdGguY29zKM67KSwgeSA9IGNvc8+GICogTWF0aC5zaW4ozrspLCB6ID0gTWF0aC5zaW4oz4YpLCB3ID0gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFcxICs9IHc7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkTGluZUVuZCgpIHtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBkM19nZW9fY2VudHJvaWRQb2ludDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gICAgdmFyIM67MDAsIM+GMDAsIHgwLCB5MCwgejA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICDOuzAwID0gzrssIM+GMDAgPSDPhjtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICAgIHgwID0gY29zz4YgKiBNYXRoLmNvcyjOuyk7XG4gICAgICB5MCA9IGNvc8+GICogTWF0aC5zaW4ozrspO1xuICAgICAgejAgPSBNYXRoLnNpbijPhik7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9O1xuICAgIGQzX2dlb19jZW50cm9pZC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQozrswMCwgz4YwMCk7XG4gICAgICBkM19nZW9fY2VudHJvaWQubGluZUVuZCA9IGQzX2dlb19jZW50cm9pZExpbmVFbmQ7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBkM19nZW9fY2VudHJvaWRQb2ludDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKSwgeCA9IGNvc8+GICogTWF0aC5jb3MozrspLCB5ID0gY29zz4YgKiBNYXRoLnNpbijOuyksIHogPSBNYXRoLnNpbijPhiksIGN4ID0geTAgKiB6IC0gejAgKiB5LCBjeSA9IHowICogeCAtIHgwICogeiwgY3ogPSB4MCAqIHkgLSB5MCAqIHgsIG0gPSBNYXRoLnNxcnQoY3ggKiBjeCArIGN5ICogY3kgKyBjeiAqIGN6KSwgdSA9IHgwICogeCArIHkwICogeSArIHowICogeiwgdiA9IG0gJiYgLWQzX2Fjb3ModSkgLyBtLCB3ID0gTWF0aC5hdGFuMihtLCB1KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgyICs9IHYgKiBjeDtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkyICs9IHYgKiBjeTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoyICs9IHYgKiBjejtcbiAgICAgIGQzX2dlb19jZW50cm9pZFcxICs9IHc7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbXBvc2UoYSwgYikge1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgICBpZiAoYS5pbnZlcnQgJiYgYi5pbnZlcnQpIGNvbXBvc2UuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgICB9O1xuICAgIHJldHVybiBjb21wb3NlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uKHNlZ21lbnRzLCBjb21wYXJlLCBjbGlwU3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzdWJqZWN0ID0gW10sIGNsaXAgPSBbXTtcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dO1xuICAgICAgaWYgKGQzX2dlb19zcGhlcmljYWxFcXVhbChwMCwgcDEpKSB7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgbGlzdGVuZXIucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYSA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpLCBiID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMCwgbnVsbCwgYSwgZmFsc2UpO1xuICAgICAgYS5vID0gYjtcbiAgICAgIHN1YmplY3QucHVzaChhKTtcbiAgICAgIGNsaXAucHVzaChiKTtcbiAgICAgIGEgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSk7XG4gICAgICBiID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMSwgbnVsbCwgYSwgdHJ1ZSk7XG4gICAgICBhLm8gPSBiO1xuICAgICAgc3ViamVjdC5wdXNoKGEpO1xuICAgICAgY2xpcC5wdXNoKGIpO1xuICAgIH0pO1xuICAgIGNsaXAuc29ydChjb21wYXJlKTtcbiAgICBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoc3ViamVjdCk7XG4gICAgZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKGNsaXApO1xuICAgIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMCwgZW50cnkgPSBjbGlwU3RhcnRJbnNpZGUsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY2xpcFtpXS5lID0gZW50cnkgPSAhZW50cnk7XG4gICAgfVxuICAgIHZhciBzdGFydCA9IHN1YmplY3RbMF0sIHBvaW50cywgcG9pbnQ7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gc3RhcnQsIGlzU3ViamVjdCA9IHRydWU7XG4gICAgICB3aGlsZSAoY3VycmVudC52KSBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydCkgcmV0dXJuO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICBkbyB7XG4gICAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihhcnJheSkge1xuICAgIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIG4sIGkgPSAwLCBhID0gYXJyYXlbMF0sIGI7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEubiA9IGIgPSBhcnJheVtpXTtcbiAgICAgIGIucCA9IGE7XG4gICAgICBhID0gYjtcbiAgICB9XG4gICAgYS5uID0gYiA9IGFycmF5WzBdO1xuICAgIGIucCA9IGE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICAgIHRoaXMueCA9IHBvaW50O1xuICAgIHRoaXMueiA9IHBvaW50cztcbiAgICB0aGlzLm8gPSBvdGhlcjtcbiAgICB0aGlzLmUgPSBlbnRyeTtcbiAgICB0aGlzLnYgPSBmYWxzZTtcbiAgICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBjbGlwU3RhcnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocm90YXRlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpbmUgPSBjbGlwTGluZShsaXN0ZW5lciksIHJvdGF0ZWRDbGlwU3RhcnQgPSByb3RhdGUuaW52ZXJ0KGNsaXBTdGFydFswXSwgY2xpcFN0YXJ0WzFdKTtcbiAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgICAgc2VnbWVudHMgPSBkMy5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgdmFyIGNsaXBTdGFydEluc2lkZSA9IGQzX2dlb19wb2ludEluUG9seWdvbihyb3RhdGVkQ2xpcFN0YXJ0LCBwb2x5Z29uKTtcbiAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvX2NsaXBQb2x5Z29uKHNlZ21lbnRzLCBkM19nZW9fY2xpcFNvcnQsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaXBTdGFydEluc2lkZSkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcG9pbnQozrssIM+GKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICBpZiAocG9pbnRWaXNpYmxlKM67ID0gcG9pbnRbMF0sIM+GID0gcG9pbnRbMV0pKSBsaXN0ZW5lci5wb2ludCjOuywgz4YpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnRMaW5lKM67LCDPhikge1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgbGluZS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgICBsaW5lLmxpbmVTdGFydCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBsaW5lLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWdtZW50cztcbiAgICAgIHZhciBidWZmZXIgPSBkM19nZW9fY2xpcEJ1ZmZlckxpc3RlbmVyKCksIHJpbmdMaXN0ZW5lciA9IGNsaXBMaW5lKGJ1ZmZlciksIHBvbHlnb25TdGFydGVkID0gZmFsc2UsIHBvbHlnb24sIHJpbmc7XG4gICAgICBmdW5jdGlvbiBwb2ludFJpbmcozrssIM+GKSB7XG4gICAgICAgIHJpbmcucHVzaChbIM67LCDPhiBdKTtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgICByaW5nTGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIHJpbmcgPSBbXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgICAgcmluZ0xpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgdmFyIGNsZWFuID0gcmluZ0xpc3RlbmVyLmNsZWFuKCksIHJpbmdTZWdtZW50cyA9IGJ1ZmZlci5idWZmZXIoKSwgc2VnbWVudCwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHJpbmcucG9wKCk7XG4gICAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICAgICAgcmluZyA9IG51bGw7XG4gICAgICAgIGlmICghbikgcmV0dXJuO1xuICAgICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcbiAgICAgICAgICB2YXIgbiA9IHNlZ21lbnQubGVuZ3RoIC0gMSwgaSA9IC0xLCBwb2ludDtcbiAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMikgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIoZDNfZ2VvX2NsaXBTZWdtZW50TGVuZ3RoMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFNlZ21lbnRMZW5ndGgxKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gc2VnbWVudC5sZW5ndGggPiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSB7XG4gICAgdmFyIGxpbmVzID0gW10sIGxpbmU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICAgIGxpbmUucHVzaChbIM67LCDPhiBdKTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgICAgYnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGxpbmVzO1xuICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICBsaW5lID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH0sXG4gICAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZs+AIC0gzrUgOiBoYWxmz4AgLSBhWzFdKSAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGbPgCAtIM61IDogaGFsZs+AIC0gYlsxXSk7XG4gIH1cbiAgdmFyIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuID0gZDNfZ2VvX2NsaXAoZDNfdHJ1ZSwgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5MaW5lLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLCBbIC3PgCwgLc+AIC8gMiBdKTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5MaW5lKGxpc3RlbmVyKSB7XG4gICAgdmFyIM67MCA9IE5hTiwgz4YwID0gTmFOLCBzzrswID0gTmFOLCBjbGVhbjtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIGNsZWFuID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24ozrsxLCDPhjEpIHtcbiAgICAgICAgdmFyIHPOuzEgPSDOuzEgPiAwID8gz4AgOiAtz4AsIGTOuyA9IGFicyjOuzEgLSDOuzApO1xuICAgICAgICBpZiAoYWJzKGTOuyAtIM+AKSA8IM61KSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQozrswLCDPhjAgPSAoz4YwICsgz4YxKSAvIDIgPiAwID8gaGFsZs+AIDogLWhhbGbPgCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MCwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MSwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzEsIM+GMCk7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHPOuzAgIT09IHPOuzEgJiYgZM67ID49IM+AKSB7XG4gICAgICAgICAgaWYgKGFicyjOuzAgLSBzzrswKSA8IM61KSDOuzAgLT0gc867MCAqIM61O1xuICAgICAgICAgIGlmIChhYnMozrsxIC0gc867MSkgPCDOtSkgzrsxIC09IHPOuzEgKiDOtTtcbiAgICAgICAgICDPhjAgPSBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVyc2VjdCjOuzAsIM+GMCwgzrsxLCDPhjEpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzAsIM+GMCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzEsIM+GMCk7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyLnBvaW50KM67MCA9IM67MSwgz4YwID0gz4YxKTtcbiAgICAgICAgc867MCA9IHPOuzE7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgzrswID0gz4YwID0gTmFOO1xuICAgICAgfSxcbiAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDIgLSBjbGVhbjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KM67MCwgz4YwLCDOuzEsIM+GMSkge1xuICAgIHZhciBjb3PPhjAsIGNvc8+GMSwgc2luzrswX867MSA9IE1hdGguc2luKM67MCAtIM67MSk7XG4gICAgcmV0dXJuIGFicyhzaW7OuzBfzrsxKSA+IM61ID8gTWF0aC5hdGFuKChNYXRoLnNpbijPhjApICogKGNvc8+GMSA9IE1hdGguY29zKM+GMSkpICogTWF0aC5zaW4ozrsxKSAtIE1hdGguc2luKM+GMSkgKiAoY29zz4YwID0gTWF0aC5jb3Moz4YwKSkgKiBNYXRoLnNpbijOuzApKSAvIChjb3PPhjAgKiBjb3PPhjEgKiBzaW7OuzBfzrsxKSkgOiAoz4YwICsgz4YxKSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgIHZhciDPhjtcbiAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICDPhiA9IGRpcmVjdGlvbiAqIGhhbGbPgDtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KM+ALCAwKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KM+ALCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgLc+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgLc+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgMCk7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIM+GKTtcbiAgICB9IGVsc2UgaWYgKGFicyhmcm9tWzBdIC0gdG9bMF0pID4gzrUpIHtcbiAgICAgIHZhciBzID0gZnJvbVswXSA8IHRvWzBdID8gz4AgOiAtz4A7XG4gICAgICDPhiA9IGRpcmVjdGlvbiAqIHMgLyAyO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLXMsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KDAsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KHMsIM+GKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGVuZXIucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gICAgdmFyIG1lcmlkaWFuID0gcG9pbnRbMF0sIHBhcmFsbGVsID0gcG9pbnRbMV0sIG1lcmlkaWFuTm9ybWFsID0gWyBNYXRoLnNpbihtZXJpZGlhbiksIC1NYXRoLmNvcyhtZXJpZGlhbiksIDAgXSwgcG9sYXJBbmdsZSA9IDAsIHdpbmRpbmcgPSAwO1xuICAgIGQzX2dlb19hcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciByaW5nID0gcG9seWdvbltpXSwgbSA9IHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKCFtKSBjb250aW51ZTtcbiAgICAgIHZhciBwb2ludDAgPSByaW5nWzBdLCDOuzAgPSBwb2ludDBbMF0sIM+GMCA9IHBvaW50MFsxXSAvIDIgKyDPgCAvIDQsIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIGogPSAxO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGogPT09IG0pIGogPSAwO1xuICAgICAgICBwb2ludCA9IHJpbmdbal07XG4gICAgICAgIHZhciDOuyA9IHBvaW50WzBdLCDPhiA9IHBvaW50WzFdIC8gMiArIM+AIC8gNCwgc2luz4YgPSBNYXRoLnNpbijPhiksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCBkzrsgPSDOuyAtIM67MCwgc2TOuyA9IGTOuyA+PSAwID8gMSA6IC0xLCBhZM67ID0gc2TOuyAqIGTOuywgYW50aW1lcmlkaWFuID0gYWTOuyA+IM+ALCBrID0gc2luz4YwICogc2luz4Y7XG4gICAgICAgIGQzX2dlb19hcmVhUmluZ1N1bS5hZGQoTWF0aC5hdGFuMihrICogc2TOuyAqIE1hdGguc2luKGFkzrspLCBjb3PPhjAgKiBjb3PPhiArIGsgKiBNYXRoLmNvcyhhZM67KSkpO1xuICAgICAgICBwb2xhckFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGTOuyArIHNkzrsgKiDPhCA6IGTOuztcbiAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIM67MCA+PSBtZXJpZGlhbiBeIM67ID49IG1lcmlkaWFuKSB7XG4gICAgICAgICAgdmFyIGFyYyA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhkM19nZW9fY2FydGVzaWFuKHBvaW50MCksIGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQpKTtcbiAgICAgICAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGFyYyk7XG4gICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhtZXJpZGlhbk5vcm1hbCwgYXJjKTtcbiAgICAgICAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGludGVyc2VjdGlvbik7XG4gICAgICAgICAgdmFyIM+GYXJjID0gKGFudGltZXJpZGlhbiBeIGTOuyA+PSAwID8gLTEgOiAxKSAqIGQzX2FzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgICBpZiAocGFyYWxsZWwgPiDPhmFyYyB8fCBwYXJhbGxlbCA9PT0gz4ZhcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGTOuyA+PSAwID8gMSA6IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWorKykgYnJlYWs7XG4gICAgICAgIM67MCA9IM67LCBzaW7PhjAgPSBzaW7PhiwgY29zz4YwID0gY29zz4YsIHBvaW50MCA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHBvbGFyQW5nbGUgPCAtzrUgfHwgcG9sYXJBbmdsZSA8IM61ICYmIGQzX2dlb19hcmVhUmluZ1N1bSA8IDApIF4gd2luZGluZyAmIDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBDaXJjbGUocmFkaXVzKSB7XG4gICAgdmFyIGNyID0gTWF0aC5jb3MocmFkaXVzKSwgc21hbGxSYWRpdXMgPSBjciA+IDAsIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gzrUsIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKHJhZGl1cywgNiAqIGQzX3JhZGlhbnMpO1xuICAgIHJldHVybiBkM19nZW9fY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWyAwLCAtcmFkaXVzIF0gOiBbIC3PgCwgcmFkaXVzIC0gz4AgXSk7XG4gICAgZnVuY3Rpb24gdmlzaWJsZSjOuywgz4YpIHtcbiAgICAgIHJldHVybiBNYXRoLmNvcyjOuykgKiBNYXRoLmNvcyjPhikgPiBjcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcExpbmUobGlzdGVuZXIpIHtcbiAgICAgIHZhciBwb2ludDAsIGMwLCB2MCwgdjAwLCBjbGVhbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgICBjbGVhbiA9IDE7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgICB2YXIgcG9pbnQxID0gWyDOuywgz4YgXSwgcG9pbnQyLCB2ID0gdmlzaWJsZSjOuywgz4YpLCBjID0gc21hbGxSYWRpdXMgPyB2ID8gMCA6IGNvZGUozrssIM+GKSA6IHYgPyBjb2RlKM67ICsgKM67IDwgMCA/IM+AIDogLc+AKSwgz4YpIDogMDtcbiAgICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgaWYgKGQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDAsIHBvaW50MikgfHwgZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xuICAgICAgICAgICAgICBwb2ludDFbMF0gKz0gzrU7XG4gICAgICAgICAgICAgIHBvaW50MVsxXSArPSDOtTtcbiAgICAgICAgICAgICAgdiA9IHZpc2libGUocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodjApIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFuIHwgKHYwMCAmJiB2MCkgPDwgMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgICAgdmFyIHBhID0gZDNfZ2VvX2NhcnRlc2lhbihhKSwgcGIgPSBkM19nZW9fY2FydGVzaWFuKGIpO1xuICAgICAgdmFyIG4xID0gWyAxLCAwLCAwIF0sIG4yID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHBhLCBwYiksIG4ybjIgPSBkM19nZW9fY2FydGVzaWFuRG90KG4yLCBuMiksIG4xbjIgPSBuMlswXSwgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG4gICAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xuICAgICAgdmFyIGMxID0gY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LCBuMXhuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLCBBID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKG4xLCBjMSksIEIgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQoQSwgQik7XG4gICAgICB2YXIgdSA9IG4xeG4yLCB3ID0gZDNfZ2VvX2NhcnRlc2lhbkRvdChBLCB1KSwgdXUgPSBkM19nZW9fY2FydGVzaWFuRG90KHUsIHUpLCB0MiA9IHcgKiB3IC0gdXUgKiAoZDNfZ2VvX2NhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuICAgICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xuICAgICAgdmFyIHQgPSBNYXRoLnNxcnQodDIpLCBxID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChxLCBBKTtcbiAgICAgIHEgPSBkM19nZW9fc3BoZXJpY2FsKHEpO1xuICAgICAgaWYgKCF0d28pIHJldHVybiBxO1xuICAgICAgdmFyIM67MCA9IGFbMF0sIM67MSA9IGJbMF0sIM+GMCA9IGFbMV0sIM+GMSA9IGJbMV0sIHo7XG4gICAgICBpZiAozrsxIDwgzrswKSB6ID0gzrswLCDOuzAgPSDOuzEsIM67MSA9IHo7XG4gICAgICB2YXIgzrTOuyA9IM67MSAtIM67MCwgcG9sYXIgPSBhYnMozrTOuyAtIM+AKSA8IM61LCBtZXJpZGlhbiA9IHBvbGFyIHx8IM60zrsgPCDOtTtcbiAgICAgIGlmICghcG9sYXIgJiYgz4YxIDwgz4YwKSB6ID0gz4YwLCDPhjAgPSDPhjEsIM+GMSA9IHo7XG4gICAgICBpZiAobWVyaWRpYW4gPyBwb2xhciA/IM+GMCArIM+GMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gzrswKSA8IM61ID8gz4YwIDogz4YxKSA6IM+GMCA8PSBxWzFdICYmIHFbMV0gPD0gz4YxIDogzrTOuyA+IM+AIF4gKM67MCA8PSBxWzBdICYmIHFbMF0gPD0gzrsxKSkge1xuICAgICAgICB2YXIgcTEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQocTEsIEEpO1xuICAgICAgICByZXR1cm4gWyBxLCBkM19nZW9fc3BoZXJpY2FsKHExKSBdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb2RlKM67LCDPhikge1xuICAgICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IM+AIC0gcmFkaXVzLCBjb2RlID0gMDtcbiAgICAgIGlmICjOuyA8IC1yKSBjb2RlIHw9IDE7IGVsc2UgaWYgKM67ID4gcikgY29kZSB8PSAyO1xuICAgICAgaWYgKM+GIDwgLXIpIGNvZGUgfD0gNDsgZWxzZSBpZiAoz4YgPiByKSBjb2RlIHw9IDg7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9jbGlwTGluZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgYSA9IGxpbmUuYSwgYiA9IGxpbmUuYiwgYXggPSBhLngsIGF5ID0gYS55LCBieCA9IGIueCwgYnkgPSBiLnksIHQwID0gMCwgdDEgPSAxLCBkeCA9IGJ4IC0gYXgsIGR5ID0gYnkgLSBheSwgcjtcbiAgICAgIHIgPSB4MCAtIGF4O1xuICAgICAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeDtcbiAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB4MSAtIGF4O1xuICAgICAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeDtcbiAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB5MCAtIGF5O1xuICAgICAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeTtcbiAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB5MSAtIGF5O1xuICAgICAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeTtcbiAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH1cbiAgICAgIGlmICh0MCA+IDApIGxpbmUuYSA9IHtcbiAgICAgICAgeDogYXggKyB0MCAqIGR4LFxuICAgICAgICB5OiBheSArIHQwICogZHlcbiAgICAgIH07XG4gICAgICBpZiAodDEgPCAxKSBsaW5lLmIgPSB7XG4gICAgICAgIHg6IGF4ICsgdDEgKiBkeCxcbiAgICAgICAgeTogYXkgKyB0MSAqIGR5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBFeHRlbnRNQVggPSAxZTk7XG4gIGQzLmdlby5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHgwLCB5MCwgeDEsIHkxLCBzdHJlYW0sIGNsaXAsIGNsaXBFeHRlbnQgPSB7XG4gICAgICBzdHJlYW06IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtID0gY2xpcChvdXRwdXQpO1xuICAgICAgICBzdHJlYW0udmFsaWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXTtcbiAgICAgICAgY2xpcCA9IGQzX2dlb19jbGlwRXh0ZW50KHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pO1xuICAgICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZSwgc3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNsaXBFeHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2xpcEV4dGVudC5leHRlbnQoWyBbIDAsIDAgXSwgWyA5NjAsIDUwMCBdIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEV4dGVudCh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3RlbmVyXyA9IGxpc3RlbmVyLCBidWZmZXJMaXN0ZW5lciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgY2xpcExpbmUgPSBkM19nZW9tX2NsaXBMaW5lKHgwLCB5MCwgeDEsIHkxKSwgc2VnbWVudHMsIHBvbHlnb24sIHJpbmc7XG4gICAgICB2YXIgY2xpcCA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGJ1ZmZlckxpc3RlbmVyO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICAgIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcl87XG4gICAgICAgICAgc2VnbWVudHMgPSBkMy5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgdmFyIGNsaXBTdGFydEluc2lkZSA9IGluc2lkZVBvbHlnb24oWyB4MCwgeTEgXSksIGluc2lkZSA9IGNsZWFuICYmIGNsaXBTdGFydEluc2lkZSwgdmlzaWJsZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBpbnNpZGVQb2x5Z29uKHApIHtcbiAgICAgICAgdmFyIHduID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoLCB5ID0gcFsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMSwgdiA9IHBvbHlnb25baV0sIG0gPSB2Lmxlbmd0aCwgYSA9IHZbMF0sIGI7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGIgPSB2W2pdO1xuICAgICAgICAgICAgaWYgKGFbMV0gPD0geSkge1xuICAgICAgICAgICAgICBpZiAoYlsxXSA+IHkgJiYgZDNfY3Jvc3MyZChhLCBiLCBwKSA+IDApICsrd247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYlsxXSA8PSB5ICYmIGQzX2Nyb3NzMmQoYSwgYiwgcCkgPCAwKSAtLXduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3biAhPT0gMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpIHx8IGNvbXBhcmVQb2ludHMoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgICAgIH0gd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnRWaXNpYmxlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUoeCwgeSkpIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgfVxuICAgICAgdmFyIHhfXywgeV9fLCB2X18sIHhfLCB5Xywgdl8sIGZpcnN0LCBjbGVhbjtcbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgIHZfID0gZmFsc2U7XG4gICAgICAgIHhfID0geV8gPSBOYU47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICAgIGlmICh2X18gJiYgdl8pIGJ1ZmZlckxpc3RlbmVyLnJlam9pbigpO1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyTGlzdGVuZXIuYnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgaWYgKHZfKSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoLWQzX2dlb19jbGlwRXh0ZW50TUFYLCBNYXRoLm1pbihkM19nZW9fY2xpcEV4dGVudE1BWCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoLWQzX2dlb19jbGlwRXh0ZW50TUFYLCBNYXRoLm1pbihkM19nZW9fY2xpcEV4dGVudE1BWCwgeSkpO1xuICAgICAgICB2YXIgdiA9IHBvaW50VmlzaWJsZSh4LCB5KTtcbiAgICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbIHgsIHkgXSk7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgJiYgdl8pIGxpc3RlbmVyLnBvaW50KHgsIHkpOyBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsID0ge1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgeDogeF8sXG4gICAgICAgICAgICAgICAgeTogeV9cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNsaXBMaW5lKGwpKSB7XG4gICAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChsLmEueCwgbC5hLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGwuYi54LCBsLmIueSk7XG4gICAgICAgICAgICAgIGlmICghdikgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMCA6IDMgOiBhYnMocFswXSAtIHgxKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxIDogYWJzKHBbMV0gLSB5MCkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMCA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLngsIGIueCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVQb2ludHMoYSwgYikge1xuICAgICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLCBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXSA6IGNhID09PSAxID8gYVswXSAtIGJbMF0gOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdIDogYlswXSAtIGFbMF07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pYyhwcm9qZWN0QXQpIHtcbiAgICB2YXIgz4YwID0gMCwgz4YxID0gz4AgLyAzLCBtID0gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksIHAgPSBtKM+GMCwgz4YxKTtcbiAgICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgz4YwIC8gz4AgKiAxODAsIM+GMSAvIM+AICogMTgwIF07XG4gICAgICByZXR1cm4gbSjPhjAgPSBfWzBdICogz4AgLyAxODAsIM+GMSA9IF9bMV0gKiDPgCAvIDE4MCk7XG4gICAgfTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29uaWNFcXVhbEFyZWEoz4YwLCDPhjEpIHtcbiAgICB2YXIgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgbiA9IChzaW7PhjAgKyBNYXRoLnNpbijPhjEpKSAvIDIsIEMgPSAxICsgc2luz4YwICogKDIgKiBuIC0gc2luz4YwKSwgz4EwID0gTWF0aC5zcXJ0KEMpIC8gbjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgdmFyIM+BID0gTWF0aC5zcXJ0KEMgLSAyICogbiAqIE1hdGguc2luKM+GKSkgLyBuO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbijOuyAqPSBuKSwgz4EwIC0gz4EgKiBNYXRoLmNvcyjOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSDPgTAgLSB5O1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCBkM19hc2luKChDIC0gKHggKiB4ICsgz4EwX3kgKiDPgTBfeSkgKiBuICogbikgLyAoMiAqIG4pKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0VxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljRXF1YWxBcmVhKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljRXF1YWxBcmVhO1xuICBkMy5nZW8uYWxiZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDk2LCAwIF0pLmNlbnRlcihbIC0uNiwgMzguNyBdKS5wYXJhbGxlbHMoWyAyOS41LCA0NS41IF0pLnNjYWxlKDEwNzApO1xuICB9O1xuICBkMy5nZW8uYWxiZXJzVXNhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvd2VyNDggPSBkMy5nZW8uYWxiZXJzKCk7XG4gICAgdmFyIGFsYXNrYSA9IGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDE1NCwgMCBdKS5jZW50ZXIoWyAtMiwgNTguNSBdKS5wYXJhbGxlbHMoWyA1NSwgNjUgXSk7XG4gICAgdmFyIGhhd2FpaSA9IGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDE1NywgMCBdKS5jZW50ZXIoWyAtMywgMTkuOSBdKS5wYXJhbGxlbHMoWyA4LCAxOCBdKTtcbiAgICB2YXIgcG9pbnQsIHBvaW50U3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcG9pbnQgPSBbIHgsIHkgXTtcbiAgICAgIH1cbiAgICB9LCBsb3dlcjQ4UG9pbnQsIGFsYXNrYVBvaW50LCBoYXdhaWlQb2ludDtcbiAgICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIChsb3dlcjQ4UG9pbnQoeCwgeSksIHBvaW50KSB8fCAoYWxhc2thUG9pbnQoeCwgeSksIHBvaW50KSB8fCBoYXdhaWlQb2ludCh4LCB5KTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICByZXR1cm4gKHkgPj0gLjEyICYmIHkgPCAuMjM0ICYmIHggPj0gLS40MjUgJiYgeCA8IC0uMjE0ID8gYWxhc2thIDogeSA+PSAuMTY2ICYmIHkgPCAuMjM0ICYmIHggPj0gLS4yMTQgJiYgeCA8IC0uMTE1ID8gaGF3YWlpIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBsb3dlcjQ4U3RyZWFtID0gbG93ZXI0OC5zdHJlYW0oc3RyZWFtKSwgYWxhc2thU3RyZWFtID0gYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWlTdHJlYW0gPSBoYXdhaWkuc3RyZWFtKHN0cmVhbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pO1xuICAgICAgYWxhc2thLnByZWNpc2lvbihfKTtcbiAgICAgIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgICAgbG93ZXI0OC5zY2FsZShfKTtcbiAgICAgIGFsYXNrYS5zY2FsZShfICogLjM1KTtcbiAgICAgIGhhd2FpaS5zY2FsZShfKTtcbiAgICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4LnRyYW5zbGF0ZShfKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjQ1NSAqIGssIHkgLSAuMjM4ICogayBdLCBbIHggKyAuNDU1ICogaywgeSArIC4yMzggKiBrIF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIGFsYXNrYVBvaW50ID0gYWxhc2thLnRyYW5zbGF0ZShbIHggLSAuMzA3ICogaywgeSArIC4yMDEgKiBrIF0pLmNsaXBFeHRlbnQoWyBbIHggLSAuNDI1ICogayArIM61LCB5ICsgLjEyICogayArIM61IF0sIFsgeCAtIC4yMTQgKiBrIC0gzrUsIHkgKyAuMjM0ICogayAtIM61IF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpLnRyYW5zbGF0ZShbIHggLSAuMjA1ICogaywgeSArIC4yMTIgKiBrIF0pLmNsaXBFeHRlbnQoWyBbIHggLSAuMjE0ICogayArIM61LCB5ICsgLjE2NiAqIGsgKyDOtSBdLCBbIHggLSAuMTE1ICogayAtIM61LCB5ICsgLjIzNCAqIGsgLSDOtSBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgIH07XG4gICAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbiAgfTtcbiAgdmFyIGQzX2dlb19wYXRoQXJlYVN1bSwgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiwgZDNfZ2VvX3BhdGhBcmVhID0ge1xuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFQb2x5Z29uID0gMDtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5saW5lU3RhcnQgPSBkM19nZW9fcGF0aEFyZWFSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5saW5lU3RhcnQgPSBkM19nZW9fcGF0aEFyZWEubGluZUVuZCA9IGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgICBkM19nZW9fcGF0aEFyZWFTdW0gKz0gYWJzKGQzX2dlb19wYXRoQXJlYVBvbHlnb24gLyAyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgeDAwLCB5MDAsIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFQb2x5Z29uICs9IHkwICogeCAtIHgwICogeTtcbiAgICAgIHgwID0geCwgeTAgPSB5O1xuICAgIH1cbiAgICBkM19nZW9fcGF0aEFyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KHgwMCwgeTAwKTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19nZW9fcGF0aEJvdW5kc1gwLCBkM19nZW9fcGF0aEJvdW5kc1kwLCBkM19nZW9fcGF0aEJvdW5kc1gxLCBkM19nZW9fcGF0aEJvdW5kc1kxO1xuICB2YXIgZDNfZ2VvX3BhdGhCb3VuZHMgPSB7XG4gICAgcG9pbnQ6IGQzX2dlb19wYXRoQm91bmRzUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBkM19ub29wLFxuICAgIHBvbHlnb25FbmQ6IGQzX25vb3BcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCb3VuZHNQb2ludCh4LCB5KSB7XG4gICAgaWYgKHggPCBkM19nZW9fcGF0aEJvdW5kc1gwKSBkM19nZW9fcGF0aEJvdW5kc1gwID0geDtcbiAgICBpZiAoeCA+IGQzX2dlb19wYXRoQm91bmRzWDEpIGQzX2dlb19wYXRoQm91bmRzWDEgPSB4O1xuICAgIGlmICh5IDwgZDNfZ2VvX3BhdGhCb3VuZHNZMCkgZDNfZ2VvX3BhdGhCb3VuZHNZMCA9IHk7XG4gICAgaWYgKHkgPiBkM19nZW9fcGF0aEJvdW5kc1kxKSBkM19nZW9fcGF0aEJvdW5kc1kxID0geTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJ1ZmZlcigpIHtcbiAgICB2YXIgcG9pbnRDaXJjbGUgPSBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZSg0LjUpLCBidWZmZXIgPSBbXTtcbiAgICB2YXIgc3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lU3RhcnQ7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZFBvbHlnb247XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcG9pbnRDaXJjbGUgPSBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZShfKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBidWZmZXIuam9pbihcIlwiKTtcbiAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHBvaW50Q2lyY2xlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lU3RhcnQoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTFwiLCB4LCBcIixcIiwgeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZFBvbHlnb24oKSB7XG4gICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUocmFkaXVzKSB7XG4gICAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXMgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAyICogcmFkaXVzICsgXCJ6XCI7XG4gIH1cbiAgdmFyIGQzX2dlb19wYXRoQ2VudHJvaWQgPSB7XG4gICAgcG9pbnQ6IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZUVuZCA9IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgsIHkpIHtcbiAgICBkM19nZW9fY2VudHJvaWRYMCArPSB4O1xuICAgIGQzX2dlb19jZW50cm9pZFkwICs9IHk7XG4gICAgKytkM19nZW9fY2VudHJvaWRaMDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgIHZhciB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB6O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQoKSB7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgIHZhciB4MDAsIHkwMCwgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gejtcbiAgICAgIHogPSB5MCAqIHggLSB4MCAqIHk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMiArPSB6ICogKHgwICsgeCk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMiArPSB6ICogKHkwICsgeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMiArPSB6ICogMztcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfVxuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KHgwMCwgeTAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgdmFyIHBvaW50UmFkaXVzID0gNC41O1xuICAgIHZhciBzdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmVTdGFydDtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kUG9seWdvbjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIH0sXG4gICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgICAgICBwb2ludFJhZGl1cyA9IF87XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgcmVzdWx0OiBkM19ub29wXG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgcG9pbnRSYWRpdXMsIHkpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgcG9pbnRSYWRpdXMsIDAsIM+EKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lU3RhcnQoeCwgeSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZSh4LCB5KSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kUG9seWdvbigpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Jlc2FtcGxlKHByb2plY3QpIHtcbiAgICB2YXIgzrQyID0gLjUsIGNvc01pbkRpc3RhbmNlID0gTWF0aC5jb3MoMzAgKiBkM19yYWRpYW5zKSwgbWF4RGVwdGggPSAxNjtcbiAgICBmdW5jdGlvbiByZXNhbXBsZShzdHJlYW0pIHtcbiAgICAgIHJldHVybiAobWF4RGVwdGggPyByZXNhbXBsZVJlY3Vyc2l2ZSA6IHJlc2FtcGxlTm9uZSkoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVOb25lKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZVJlY3Vyc2l2ZShzdHJlYW0pIHtcbiAgICAgIHZhciDOuzAwLCDPhjAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgzrswLCB4MCwgeTAsIGEwLCBiMCwgYzA7XG4gICAgICB2YXIgcmVzYW1wbGUgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIHJlc2FtcGxlLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICByZXNhbXBsZS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIHgwID0gTmFOO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVBvaW50KM67LCDPhikge1xuICAgICAgICB2YXIgYyA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuywgz4YgXSksIHAgPSBwcm9qZWN0KM67LCDPhik7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgzrswID0gzrssIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIGxpbmVTdGFydCgpO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgcmVzYW1wbGUubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nUG9pbnQozrssIM+GKSB7XG4gICAgICAgIGxpbmVQb2ludCjOuzAwID0gzrssIM+GMDAgPSDPhiksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDAwLCB5MDAsIM67MDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICByZXNhbXBsZS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgbGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc2FtcGxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDEsIHkxLCDOuzEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICAgIHZhciBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MCwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA+IDQgKiDOtDIgJiYgZGVwdGgtLSkge1xuICAgICAgICB2YXIgYSA9IGEwICsgYTEsIGIgPSBiMCArIGIxLCBjID0gYzAgKyBjMSwgbSA9IE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpLCDPhjIgPSBNYXRoLmFzaW4oYyAvPSBtKSwgzrsyID0gYWJzKGFicyhjKSAtIDEpIDwgzrUgfHwgYWJzKM67MCAtIM67MSkgPCDOtSA/ICjOuzAgKyDOuzEpIC8gMiA6IE1hdGguYXRhbjIoYiwgYSksIHAgPSBwcm9qZWN0KM67Miwgz4YyKSwgeDIgPSBwWzBdLCB5MiA9IHBbMV0sIGR4MiA9IHgyIC0geDAsIGR5MiA9IHkyIC0geTAsIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgICAgaWYgKGR6ICogZHogLyBkMiA+IM60MiB8fCBhYnMoKGR4ICogZHgyICsgZHkgKiBkeTIpIC8gZDIgLSAuNSkgPiAuMyB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkge1xuICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MiwgeTIsIM67MiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgzrsyLCBhLCBiLCBjLCB4MSwgeTEsIM67MSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzYW1wbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KM60Mik7XG4gICAgICBtYXhEZXB0aCA9ICjOtDIgPSBfICogXykgPiAwICYmIDE2O1xuICAgICAgcmV0dXJuIHJlc2FtcGxlO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2FtcGxlO1xuICB9XG4gIGQzLmdlby5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBvaW50UmFkaXVzID0gNC41LCBwcm9qZWN0aW9uLCBjb250ZXh0LCBwcm9qZWN0U3RyZWFtLCBjb250ZXh0U3RyZWFtLCBjYWNoZVN0cmVhbTtcbiAgICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoIWNhY2hlU3RyZWFtIHx8ICFjYWNoZVN0cmVhbS52YWxpZCkgY2FjaGVTdHJlYW0gPSBwcm9qZWN0U3RyZWFtKGNvbnRleHRTdHJlYW0pO1xuICAgICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgY2FjaGVTdHJlYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gICAgfVxuICAgIHBhdGguYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhU3VtID0gMDtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQXJlYSkpO1xuICAgICAgcmV0dXJuIGQzX2dlb19wYXRoQXJlYVN1bTtcbiAgICB9O1xuICAgIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgwID0gZDNfZ2VvX2NlbnRyb2lkWTAgPSBkM19nZW9fY2VudHJvaWRaMCA9IGQzX2dlb19jZW50cm9pZFgxID0gZDNfZ2VvX2NlbnRyb2lkWTEgPSBkM19nZW9fY2VudHJvaWRaMSA9IGQzX2dlb19jZW50cm9pZFgyID0gZDNfZ2VvX2NlbnRyb2lkWTIgPSBkM19nZW9fY2VudHJvaWRaMiA9IDA7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aENlbnRyb2lkKSk7XG4gICAgICByZXR1cm4gZDNfZ2VvX2NlbnRyb2lkWjIgPyBbIGQzX2dlb19jZW50cm9pZFgyIC8gZDNfZ2VvX2NlbnRyb2lkWjIsIGQzX2dlb19jZW50cm9pZFkyIC8gZDNfZ2VvX2NlbnRyb2lkWjIgXSA6IGQzX2dlb19jZW50cm9pZFoxID8gWyBkM19nZW9fY2VudHJvaWRYMSAvIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRZMSAvIGQzX2dlb19jZW50cm9pZFoxIF0gOiBkM19nZW9fY2VudHJvaWRaMCA/IFsgZDNfZ2VvX2NlbnRyb2lkWDAgLyBkM19nZW9fY2VudHJvaWRaMCwgZDNfZ2VvX2NlbnRyb2lkWTAgLyBkM19nZW9fY2VudHJvaWRaMCBdIDogWyBOYU4sIE5hTiBdO1xuICAgIH07XG4gICAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19wYXRoQm91bmRzWDEgPSBkM19nZW9fcGF0aEJvdW5kc1kxID0gLShkM19nZW9fcGF0aEJvdW5kc1gwID0gZDNfZ2VvX3BhdGhCb3VuZHNZMCA9IEluZmluaXR5KTtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQm91bmRzKSk7XG4gICAgICByZXR1cm4gWyBbIGQzX2dlb19wYXRoQm91bmRzWDAsIGQzX2dlb19wYXRoQm91bmRzWTAgXSwgWyBkM19nZW9fcGF0aEJvdW5kc1gxLCBkM19nZW9fcGF0aEJvdW5kc1kxIF0gXTtcbiAgICB9O1xuICAgIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICBwcm9qZWN0U3RyZWFtID0gKHByb2plY3Rpb24gPSBfKSA/IF8uc3RyZWFtIHx8IGQzX2dlb19wYXRoUHJvamVjdFN0cmVhbShfKSA6IGQzX2lkZW50aXR5O1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgICAgY29udGV4dFN0cmVhbSA9IChjb250ZXh0ID0gXykgPT0gbnVsbCA/IG5ldyBkM19nZW9fcGF0aEJ1ZmZlcigpIDogbmV3IGQzX2dlb19wYXRoQ29udGV4dChfKTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihkMy5nZW8uYWxiZXJzVXNhKCkpLmNvbnRleHQobnVsbCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoUHJvamVjdFN0cmVhbShwcm9qZWN0KSB7XG4gICAgdmFyIHJlc2FtcGxlID0gZDNfZ2VvX3Jlc2FtcGxlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0KFsgeCAqIGQzX2RlZ3JlZXMsIHkgKiBkM19kZWdyZWVzIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMocmVzYW1wbGUoc3RyZWFtKSk7XG4gICAgfTtcbiAgfVxuICBkMy5nZW8udHJhbnNmb3JtID0gZnVuY3Rpb24obWV0aG9kcykge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IGQzX2dlb190cmFuc2Zvcm0oc3RyZWFtKTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBtZXRob2RzKSB0cmFuc2Zvcm1ba10gPSBtZXRob2RzW2tdO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc2Zvcm0oc3RyZWFtKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cbiAgZDNfZ2VvX3RyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnNwaGVyZSgpO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5saW5lRW5kKCk7XG4gICAgfSxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIHBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgICAgIH0sXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDMuZ2VvLnByb2plY3Rpb24gPSBkM19nZW9fcHJvamVjdGlvbjtcbiAgZDMuZ2VvLnByb2plY3Rpb25NdXRhdG9yID0gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yO1xuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH0pKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICAgIHZhciBwcm9qZWN0LCByb3RhdGUsIHByb2plY3RSb3RhdGUsIHByb2plY3RSZXNhbXBsZSA9IGQzX2dlb19yZXNhbXBsZShmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHJldHVybiBbIHhbMF0gKiBrICsgzrR4LCDOtHkgLSB4WzFdICogayBdO1xuICAgIH0pLCBrID0gMTUwLCB4ID0gNDgwLCB5ID0gMjUwLCDOuyA9IDAsIM+GID0gMCwgzrTOuyA9IDAsIM60z4YgPSAwLCDOtM6zID0gMCwgzrR4LCDOtHksIHByZWNsaXAgPSBkM19nZW9fY2xpcEFudGltZXJpZGlhbiwgcG9zdGNsaXAgPSBkM19pZGVudGl0eSwgY2xpcEFuZ2xlID0gbnVsbCwgY2xpcEV4dGVudCA9IG51bGwsIHN0cmVhbTtcbiAgICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUocG9pbnRbMF0gKiBkM19yYWRpYW5zLCBwb2ludFsxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIFsgcG9pbnRbMF0gKiBrICsgzrR4LCDOtHkgLSBwb2ludFsxXSAqIGsgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUuaW52ZXJ0KChwb2ludFswXSAtIM60eCkgLyBrLCAozrR5IC0gcG9pbnRbMV0pIC8gayk7XG4gICAgICByZXR1cm4gcG9pbnQgJiYgWyBwb2ludFswXSAqIGQzX2RlZ3JlZXMsIHBvaW50WzFdICogZDNfZGVncmVlcyBdO1xuICAgIH1cbiAgICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2U7XG4gICAgICBzdHJlYW0gPSBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMocHJlY2xpcChyb3RhdGUsIHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChvdXRwdXQpKSkpO1xuICAgICAgc3RyZWFtLnZhbGlkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBBbmdsZTtcbiAgICAgIHByZWNsaXAgPSBfID09IG51bGwgPyAoY2xpcEFuZ2xlID0gXywgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4pIDogZDNfZ2VvX2NsaXBDaXJjbGUoKGNsaXBBbmdsZSA9ICtfKSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQ7XG4gICAgICBjbGlwRXh0ZW50ID0gXztcbiAgICAgIHBvc3RjbGlwID0gXyA/IGQzX2dlb19jbGlwRXh0ZW50KF9bMF1bMF0sIF9bMF1bMV0sIF9bMV1bMF0sIF9bMV1bMV0pIDogZDNfaWRlbnRpdHk7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGs7XG4gICAgICBrID0gK187XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB4LCB5IF07XG4gICAgICB4ID0gK19bMF07XG4gICAgICB5ID0gK19bMV07XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDOuyAqIGQzX2RlZ3JlZXMsIM+GICogZDNfZGVncmVlcyBdO1xuICAgICAgzrsgPSBfWzBdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM+GID0gX1sxXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDOtM67ICogZDNfZGVncmVlcywgzrTPhiAqIGQzX2RlZ3JlZXMsIM60zrMgKiBkM19kZWdyZWVzIF07XG4gICAgICDOtM67ID0gX1swXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDOtM+GID0gX1sxXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDOtM6zID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIGQzX3JhZGlhbnMgOiAwO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBkMy5yZWJpbmQocHJvamVjdGlvbiwgcHJvamVjdFJlc2FtcGxlLCBcInByZWNpc2lvblwiKTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHByb2plY3RSb3RhdGUgPSBkM19nZW9fY29tcG9zZShyb3RhdGUgPSBkM19nZW9fcm90YXRpb24ozrTOuywgzrTPhiwgzrTOsyksIHByb2plY3QpO1xuICAgICAgdmFyIGNlbnRlciA9IHByb2plY3QozrssIM+GKTtcbiAgICAgIM60eCA9IHggLSBjZW50ZXJbMF0gKiBrO1xuICAgICAgzrR5ID0geSArIGNlbnRlclsxXSAqIGs7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2UsIHN0cmVhbSA9IG51bGw7XG4gICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhzdHJlYW0pIHtcbiAgICByZXR1cm4gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgc3RyZWFtLnBvaW50KHggKiBkM19yYWRpYW5zLCB5ICogZDNfcmFkaWFucyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuywgz4YgXTtcbiAgfVxuICAoZDMuZ2VvLmVxdWlyZWN0YW5ndWxhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fZXF1aXJlY3Rhbmd1bGFyKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhci5pbnZlcnQgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICBkMy5nZW8ucm90YXRpb24gPSBmdW5jdGlvbihyb3RhdGUpIHtcbiAgICByb3RhdGUgPSBkM19nZW9fcm90YXRpb24ocm90YXRlWzBdICUgMzYwICogZDNfcmFkaWFucywgcm90YXRlWzFdICogZDNfcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiBkM19yYWRpYW5zIDogMCk7XG4gICAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiBkM19yYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiBkM19yYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19pZGVudGl0eVJvdGF0aW9uKM67LCDPhikge1xuICAgIHJldHVybiBbIM67ID4gz4AgPyDOuyAtIM+EIDogzrsgPCAtz4AgPyDOuyArIM+EIDogzrssIM+GIF07XG4gIH1cbiAgZDNfZ2VvX2lkZW50aXR5Um90YXRpb24uaW52ZXJ0ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uKM60zrssIM60z4YsIM60zrMpIHtcbiAgICByZXR1cm4gzrTOuyA/IM60z4YgfHwgzrTOsyA/IGQzX2dlb19jb21wb3NlKGQzX2dlb19yb3RhdGlvbs67KM60zrspLCBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpKSA6IGQzX2dlb19yb3RhdGlvbs67KM60zrspIDogzrTPhiB8fCDOtM6zID8gZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSA6IGQzX2dlb19pZGVudGl0eVJvdGF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19mb3J3YXJkUm90YXRpb27OuyjOtM67KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgcmV0dXJuIM67ICs9IM60zrssIFsgzrsgPiDPgCA/IM67IC0gz4QgOiDOuyA8IC3PgCA/IM67ICsgz4QgOiDOuywgz4YgXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbs67KM60zrspIHtcbiAgICB2YXIgcm90YXRpb24gPSBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsozrTOuyk7XG4gICAgcm90YXRpb24uaW52ZXJ0ID0gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KC3OtM67KTtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSB7XG4gICAgdmFyIGNvc860z4YgPSBNYXRoLmNvcyjOtM+GKSwgc2luzrTPhiA9IE1hdGguc2luKM60z4YpLCBjb3POtM6zID0gTWF0aC5jb3MozrTOsyksIHNpbs60zrMgPSBNYXRoLnNpbijOtM6zKTtcbiAgICBmdW5jdGlvbiByb3RhdGlvbijOuywgz4YpIHtcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GKSwgeCA9IE1hdGguY29zKM67KSAqIGNvc8+GLCB5ID0gTWF0aC5zaW4ozrspICogY29zz4YsIHogPSBNYXRoLnNpbijPhiksIGsgPSB6ICogY29zzrTPhiArIHggKiBzaW7OtM+GO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5ICogY29zzrTOsyAtIGsgKiBzaW7OtM6zLCB4ICogY29zzrTPhiAtIHogKiBzaW7OtM+GKSwgZDNfYXNpbihrICogY29zzrTOsyArIHkgKiBzaW7OtM6zKSBdO1xuICAgIH1cbiAgICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GKSwgeCA9IE1hdGguY29zKM67KSAqIGNvc8+GLCB5ID0gTWF0aC5zaW4ozrspICogY29zz4YsIHogPSBNYXRoLnNpbijPhiksIGsgPSB6ICogY29zzrTOsyAtIHkgKiBzaW7OtM6zO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5ICogY29zzrTOsyArIHogKiBzaW7OtM6zLCB4ICogY29zzrTPhiArIGsgKiBzaW7OtM+GKSwgZDNfYXNpbihrICogY29zzrTPhiAtIHggKiBzaW7OtM+GKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG4gIGQzLmdlby5jaXJjbGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luID0gWyAwLCAwIF0sIGFuZ2xlLCBwcmVjaXNpb24gPSA2LCBpbnRlcnBvbGF0ZTtcbiAgICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgICB2YXIgY2VudGVyID0gdHlwZW9mIG9yaWdpbiA9PT0gXCJmdW5jdGlvblwiID8gb3JpZ2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvcmlnaW4sIHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbigtY2VudGVyWzBdICogZDNfcmFkaWFucywgLWNlbnRlclsxXSAqIGQzX3JhZGlhbnMsIDApLmludmVydCwgcmluZyA9IFtdO1xuICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwge1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICAgICAgICB4WzBdICo9IGQzX2RlZ3JlZXMsIHhbMV0gKj0gZDNfZGVncmVlcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgcmluZyBdXG4gICAgICB9O1xuICAgIH1cbiAgICBjaXJjbGUub3JpZ2luID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luO1xuICAgICAgb3JpZ2luID0geDtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICBjaXJjbGUuYW5nbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhbmdsZTtcbiAgICAgIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKChhbmdsZSA9ICt4KSAqIGQzX3JhZGlhbnMsIHByZWNpc2lvbiAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgICBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShhbmdsZSAqIGQzX3JhZGlhbnMsIChwcmVjaXNpb24gPSArXykgKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICByZXR1cm4gY2lyY2xlLmFuZ2xlKDkwKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKHJhZGl1cywgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGNyID0gTWF0aC5jb3MocmFkaXVzKSwgc3IgPSBNYXRoLnNpbihyYWRpdXMpO1xuICAgIHJldHVybiBmdW5jdGlvbihmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIHN0ZXAgPSBkaXJlY3Rpb24gKiBwcmVjaXNpb247XG4gICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIGZyb20pO1xuICAgICAgICB0byA9IGQzX2dlb19jaXJjbGVBbmdsZShjciwgdG8pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCA/IGZyb20gPCB0byA6IGZyb20gPiB0bykgZnJvbSArPSBkaXJlY3Rpb24gKiDPhDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSByYWRpdXMgKyBkaXJlY3Rpb24gKiDPhDtcbiAgICAgICAgdG8gPSByYWRpdXMgLSAuNSAqIHN0ZXA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwb2ludCwgdCA9IGZyb207IGRpcmVjdGlvbiA+IDAgPyB0ID4gdG8gOiB0IDwgdG87IHQgLT0gc3RlcCkge1xuICAgICAgICBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBkM19nZW9fc3BoZXJpY2FsKFsgY3IsIC1zciAqIE1hdGguY29zKHQpLCAtc3IgKiBNYXRoLnNpbih0KSBdKSlbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jaXJjbGVBbmdsZShjciwgcG9pbnQpIHtcbiAgICB2YXIgYSA9IGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQpO1xuICAgIGFbMF0gLT0gY3I7XG4gICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShhKTtcbiAgICB2YXIgYW5nbGUgPSBkM19hY29zKC1hWzFdKTtcbiAgICByZXR1cm4gKCgtYVsyXSA8IDAgPyAtYW5nbGUgOiBhbmdsZSkgKyAyICogTWF0aC5QSSAtIM61KSAlICgyICogTWF0aC5QSSk7XG4gIH1cbiAgZDMuZ2VvLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciDOlM67ID0gKGJbMF0gLSBhWzBdKSAqIGQzX3JhZGlhbnMsIM+GMCA9IGFbMV0gKiBkM19yYWRpYW5zLCDPhjEgPSBiWzFdICogZDNfcmFkaWFucywgc2luzpTOuyA9IE1hdGguc2luKM6UzrspLCBjb3POlM67ID0gTWF0aC5jb3MozpTOuyksIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIHNpbs+GMSA9IE1hdGguc2luKM+GMSksIGNvc8+GMSA9IE1hdGguY29zKM+GMSksIHQ7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh0ID0gY29zz4YxICogc2luzpTOuykgKiB0ICsgKHQgPSBjb3PPhjAgKiBzaW7PhjEgLSBzaW7PhjAgKiBjb3PPhjEgKiBjb3POlM67KSAqIHQpLCBzaW7PhjAgKiBzaW7PhjEgKyBjb3PPhjAgKiBjb3PPhjEgKiBjb3POlM67KTtcbiAgfTtcbiAgZDMuZ2VvLmdyYXRpY3VsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4MSwgeDAsIFgxLCBYMCwgeTEsIHkwLCBZMSwgWTAsIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLCB4LCB5LCBYLCBZLCBwcmVjaXNpb24gPSAyLjU7XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGxpbmVzKClcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKE1hdGguY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGFicyh4ICUgRFgpID4gzrU7XG4gICAgICB9KS5tYXAoeCkpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gYWJzKHkgJSBEWSkgPiDOtTtcbiAgICAgIH0pLm1hcCh5KSk7XG4gICAgfVxuICAgIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgWChYMCkuY29uY2F0KFkoWTEpLnNsaWNlKDEpLCBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSkgXVxuICAgICAgfTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUubWlub3JFeHRlbnQoKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JFeHRlbnQoXykubWlub3JFeHRlbnQoXyk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWFqb3JFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgWDAsIFkwIF0sIFsgWDEsIFkxIF0gXTtcbiAgICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5taW5vckV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdO1xuICAgICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgICBpZiAoeTAgPiB5MSkgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUubWlub3JTdGVwKCk7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yU3RlcChfKS5taW5vclN0ZXAoXyk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWFqb3JTdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBEWCwgRFkgXTtcbiAgICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1pbm9yU3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgZHgsIGR5IF07XG4gICAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgICBwcmVjaXNpb24gPSArXztcbiAgICAgIHggPSBkM19nZW9fZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICAgIHkgPSBkM19nZW9fZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgICBYID0gZDNfZ2VvX2dyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgICBZID0gZDNfZ2VvX2dyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JFeHRlbnQoWyBbIC0xODAsIC05MCArIM61IF0sIFsgMTgwLCA5MCAtIM61IF0gXSkubWlub3JFeHRlbnQoWyBbIC0xODAsIC04MCAtIM61IF0sIFsgMTgwLCA4MCArIM61IF0gXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19ncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgICB2YXIgeSA9IGQzLnJhbmdlKHkwLCB5MSAtIM61LCBkeSkuY29uY2F0KHkxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gICAgdmFyIHggPSBkMy5yYW5nZSh4MCwgeDEgLSDOtSwgZHgpLmNvbmNhdCh4MSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc291cmNlKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGFyZ2V0KGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH1cbiAgZDMuZ2VvLmdyZWF0QXJjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgc291cmNlXywgdGFyZ2V0ID0gZDNfdGFyZ2V0LCB0YXJnZXRfO1xuICAgIGZ1bmN0aW9uIGdyZWF0QXJjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIHNvdXJjZV8gfHwgc291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRhcmdldF8gfHwgdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgXVxuICAgICAgfTtcbiAgICB9XG4gICAgZ3JlYXRBcmMuZGlzdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkMy5nZW8uZGlzdGFuY2Uoc291cmNlXyB8fCBzb3VyY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGFyZ2V0XyB8fCB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBncmVhdEFyYy5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBfLCBzb3VyY2VfID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIGdyZWF0QXJjO1xuICAgIH07XG4gICAgZ3JlYXRBcmMudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gXywgdGFyZ2V0XyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBudWxsIDogXztcbiAgICAgIHJldHVybiBncmVhdEFyYztcbiAgICB9O1xuICAgIGdyZWF0QXJjLnByZWNpc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBncmVhdEFyYyA6IDA7XG4gICAgfTtcbiAgICByZXR1cm4gZ3JlYXRBcmM7XG4gIH07XG4gIGQzLmdlby5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGQzX2dlb19pbnRlcnBvbGF0ZShzb3VyY2VbMF0gKiBkM19yYWRpYW5zLCBzb3VyY2VbMV0gKiBkM19yYWRpYW5zLCB0YXJnZXRbMF0gKiBkM19yYWRpYW5zLCB0YXJnZXRbMV0gKiBkM19yYWRpYW5zKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2ludGVycG9sYXRlKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgdmFyIGN5MCA9IE1hdGguY29zKHkwKSwgc3kwID0gTWF0aC5zaW4oeTApLCBjeTEgPSBNYXRoLmNvcyh5MSksIHN5MSA9IE1hdGguc2luKHkxKSwga3gwID0gY3kwICogTWF0aC5jb3MoeDApLCBreTAgPSBjeTAgKiBNYXRoLnNpbih4MCksIGt4MSA9IGN5MSAqIE1hdGguY29zKHgxKSwga3kxID0gY3kxICogTWF0aC5zaW4oeDEpLCBkID0gMiAqIE1hdGguYXNpbihNYXRoLnNxcnQoZDNfaGF2ZXJzaW4oeTEgLSB5MCkgKyBjeTAgKiBjeTEgKiBkM19oYXZlcnNpbih4MSAtIHgwKSkpLCBrID0gMSAvIE1hdGguc2luKGQpO1xuICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgQiA9IE1hdGguc2luKHQgKj0gZCkgKiBrLCBBID0gTWF0aC5zaW4oZCAtIHQpICogaywgeCA9IEEgKiBreDAgKyBCICoga3gxLCB5ID0gQSAqIGt5MCArIEIgKiBreTEsIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBNYXRoLmF0YW4yKHosIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSkgKiBkM19kZWdyZWVzIF07XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFsgeDAgKiBkM19kZWdyZWVzLCB5MCAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9O1xuICAgIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGU7XG4gIH1cbiAgZDMuZ2VvLmxlbmd0aCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19sZW5ndGhTdW0gPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fbGVuZ3RoKTtcbiAgICByZXR1cm4gZDNfZ2VvX2xlbmd0aFN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19sZW5ndGhTdW07XG4gIHZhciBkM19nZW9fbGVuZ3RoID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19sZW5ndGhMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGQzX25vb3AsXG4gICAgcG9seWdvbkVuZDogZDNfbm9vcFxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fbGVuZ3RoTGluZVN0YXJ0KCkge1xuICAgIHZhciDOuzAsIHNpbs+GMCwgY29zz4YwO1xuICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MCA9IM67ICogZDNfcmFkaWFucywgc2luz4YwID0gTWF0aC5zaW4oz4YgKj0gZDNfcmFkaWFucyksIGNvc8+GMCA9IE1hdGguY29zKM+GKTtcbiAgICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgfTtcbiAgICBkM19nZW9fbGVuZ3RoLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBkM19nZW9fbGVuZ3RoLmxpbmVFbmQgPSBkM19ub29wO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgdmFyIHNpbs+GID0gTWF0aC5zaW4oz4YgKj0gZDNfcmFkaWFucyksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB0ID0gYWJzKCjOuyAqPSBkM19yYWRpYW5zKSAtIM67MCksIGNvc86UzrsgPSBNYXRoLmNvcyh0KTtcbiAgICAgIGQzX2dlb19sZW5ndGhTdW0gKz0gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHQgPSBjb3PPhiAqIE1hdGguc2luKHQpKSAqIHQgKyAodCA9IGNvc8+GMCAqIHNpbs+GIC0gc2luz4YwICogY29zz4YgKiBjb3POlM67KSAqIHQpLCBzaW7PhjAgKiBzaW7PhiArIGNvc8+GMCAqIGNvc8+GICogY29zzpTOuyk7XG4gICAgICDOuzAgPSDOuywgc2luz4YwID0gc2luz4YsIGNvc8+GMCA9IGNvc8+GO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fYXppbXV0aGFsKHNjYWxlLCBhbmdsZSkge1xuICAgIGZ1bmN0aW9uIGF6aW11dGhhbCjOuywgz4YpIHtcbiAgICAgIHZhciBjb3POuyA9IE1hdGguY29zKM67KSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGsgPSBzY2FsZShjb3POuyAqIGNvc8+GKTtcbiAgICAgIHJldHVybiBbIGsgKiBjb3PPhiAqIE1hdGguc2luKM67KSwgayAqIE1hdGguc2luKM+GKSBdO1xuICAgIH1cbiAgICBhemltdXRoYWwuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjID0gYW5nbGUoz4EpLCBzaW5jID0gTWF0aC5zaW4oYyksIGNvc2MgPSBNYXRoLmNvcyhjKTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCAqIHNpbmMsIM+BICogY29zYyksIE1hdGguYXNpbijPgSAmJiB5ICogc2luYyAvIM+BKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGF6aW11dGhhbDtcbiAgfVxuICB2YXIgZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYSA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMiAvICgxICsgY29zzrtjb3PPhikpO1xuICB9LCBmdW5jdGlvbijPgSkge1xuICAgIHJldHVybiAyICogTWF0aC5hc2luKM+BIC8gMik7XG4gIH0pO1xuICAoZDMuZ2VvLmF6aW11dGhhbEVxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYTtcbiAgdmFyIGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudCA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHZhciBjID0gTWF0aC5hY29zKGNvc867Y29zz4YpO1xuICAgIHJldHVybiBjICYmIGMgLyBNYXRoLnNpbihjKTtcbiAgfSwgZDNfaWRlbnRpdHkpO1xuICAoZDMuZ2VvLmF6aW11dGhhbEVxdWlkaXN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudCk7XG4gIH0pLnJhdyA9IGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudDtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljQ29uZm9ybWFsKM+GMCwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIHQgPSBmdW5jdGlvbijPhikge1xuICAgICAgcmV0dXJuIE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMik7XG4gICAgfSwgbiA9IM+GMCA9PT0gz4YxID8gTWF0aC5zaW4oz4YwKSA6IE1hdGgubG9nKGNvc8+GMCAvIE1hdGguY29zKM+GMSkpIC8gTWF0aC5sb2codCjPhjEpIC8gdCjPhjApKSwgRiA9IGNvc8+GMCAqIE1hdGgucG93KHQoz4YwKSwgbikgLyBuO1xuICAgIGlmICghbikgcmV0dXJuIGQzX2dlb19tZXJjYXRvcjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgaWYgKEYgPiAwKSB7XG4gICAgICAgIGlmICjPhiA8IC1oYWxmz4AgKyDOtSkgz4YgPSAtaGFsZs+AICsgzrU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoz4YgPiBoYWxmz4AgLSDOtSkgz4YgPSBoYWxmz4AgLSDOtTtcbiAgICAgIH1cbiAgICAgIHZhciDPgSA9IEYgLyBNYXRoLnBvdyh0KM+GKSwgbik7XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKG4gKiDOuyksIEYgLSDPgSAqIE1hdGguY29zKG4gKiDOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSBGIC0geSwgz4EgPSBkM19zZ24obikgKiBNYXRoLnNxcnQoeCAqIHggKyDPgTBfeSAqIM+BMF95KTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgMiAqIE1hdGguYXRhbihNYXRoLnBvdyhGIC8gz4EsIDEgLyBuKSkgLSBoYWxmz4AgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNDb25mb3JtYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0NvbmZvcm1hbCk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0NvbmZvcm1hbDtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQoz4YwLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgbiA9IM+GMCA9PT0gz4YxID8gTWF0aC5zaW4oz4YwKSA6IChjb3PPhjAgLSBNYXRoLmNvcyjPhjEpKSAvICjPhjEgLSDPhjApLCBHID0gY29zz4YwIC8gbiArIM+GMDtcbiAgICBpZiAoYWJzKG4pIDwgzrUpIHJldHVybiBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICB2YXIgz4EgPSBHIC0gz4Y7XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKG4gKiDOuyksIEcgLSDPgSAqIE1hdGguY29zKG4gKiDOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSBHIC0geTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgRyAtIGQzX3NnbihuKSAqIE1hdGguc3FydCh4ICogeCArIM+BMF95ICogz4EwX3kpIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0VxdWlkaXN0YW50KTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQ7XG4gIHZhciBkM19nZW9fZ25vbW9uaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gMSAvIGNvc867Y29zz4Y7XG4gIH0sIE1hdGguYXRhbik7XG4gIChkMy5nZW8uZ25vbW9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2dub21vbmljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2dub21vbmljO1xuICBmdW5jdGlvbiBkM19nZW9fbWVyY2F0b3IozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrssIE1hdGgubG9nKE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMikpIF07XG4gIH1cbiAgZDNfZ2VvX21lcmNhdG9yLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyB4LCAyICogTWF0aC5hdGFuKE1hdGguZXhwKHkpKSAtIGhhbGbPgCBdO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICB2YXIgbSA9IGQzX2dlb19wcm9qZWN0aW9uKHByb2plY3QpLCBzY2FsZSA9IG0uc2NhbGUsIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLCBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LCBjbGlwQXV0bztcbiAgICBtLnNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHNjYWxlLmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdiA9PT0gbSA/IGNsaXBBdXRvID8gbS5jbGlwRXh0ZW50KG51bGwpIDogbSA6IHY7XG4gICAgfTtcbiAgICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB0cmFuc2xhdGUuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2ID09PSBtID8gY2xpcEF1dG8gPyBtLmNsaXBFeHRlbnQobnVsbCkgOiBtIDogdjtcbiAgICB9O1xuICAgIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciB2ID0gY2xpcEV4dGVudC5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT09IG0pIHtcbiAgICAgICAgaWYgKGNsaXBBdXRvID0gXyA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGsgPSDPgCAqIHNjYWxlKCksIHQgPSB0cmFuc2xhdGUoKTtcbiAgICAgICAgICBjbGlwRXh0ZW50KFsgWyB0WzBdIC0gaywgdFsxXSAtIGsgXSwgWyB0WzBdICsgaywgdFsxXSArIGsgXSBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGlwQXV0bykge1xuICAgICAgICB2ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgcmV0dXJuIG0uY2xpcEV4dGVudChudWxsKTtcbiAgfVxuICAoZDMuZ2VvLm1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24oZDNfZ2VvX21lcmNhdG9yKTtcbiAgfSkucmF3ID0gZDNfZ2VvX21lcmNhdG9yO1xuICB2YXIgZDNfZ2VvX29ydGhvZ3JhcGhpYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sIE1hdGguYXNpbik7XG4gIChkMy5nZW8ub3J0aG9ncmFwaGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19vcnRob2dyYXBoaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fb3J0aG9ncmFwaGljO1xuICB2YXIgZDNfZ2VvX3N0ZXJlb2dyYXBoaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gMSAvICgxICsgY29zzrtjb3PPhik7XG4gIH0sIGZ1bmN0aW9uKM+BKSB7XG4gICAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oz4EpO1xuICB9KTtcbiAgKGQzLmdlby5zdGVyZW9ncmFwaGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19zdGVyZW9ncmFwaGljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX3N0ZXJlb2dyYXBoaWM7XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5sb2coTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKSksIC3OuyBdO1xuICB9XG4gIGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbIC15LCAyICogTWF0aC5hdGFuKE1hdGguZXhwKHgpKSAtIGhhbGbPgCBdO1xuICB9O1xuICAoZDMuZ2VvLnRyYW5zdmVyc2VNZXJjYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9qZWN0aW9uID0gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yKSwgY2VudGVyID0gcHJvamVjdGlvbi5jZW50ZXIsIHJvdGF0ZSA9IHByb2plY3Rpb24ucm90YXRlO1xuICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIF8gPyBjZW50ZXIoWyAtX1sxXSwgX1swXSBdKSA6IChfID0gY2VudGVyKCksIFsgX1sxXSwgLV9bMF0gXSk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBfID8gcm90YXRlKFsgX1swXSwgX1sxXSwgXy5sZW5ndGggPiAyID8gX1syXSArIDkwIDogOTAgXSkgOiAoXyA9IHJvdGF0ZSgpLCBcbiAgICAgIFsgX1swXSwgX1sxXSwgX1syXSAtIDkwIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdGF0ZShbIDAsIDAsIDkwIF0pO1xuICB9KS5yYXcgPSBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yO1xuICBkMy5nZW9tID0ge307XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9pbnRYKGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvaW50WShkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH1cbiAgZDMuZ2VvbS5odWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBodWxsKHZlcnRpY2VzKTtcbiAgICBmdW5jdGlvbiBodWxsKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDMpIHJldHVybiBbXTtcbiAgICAgIHZhciBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KSwgaSwgbiA9IGRhdGEubGVuZ3RoLCBwb2ludHMgPSBbXSwgZmxpcHBlZFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaChbICtmeC5jYWxsKHRoaXMsIGRhdGFbaV0sIGkpLCArZnkuY2FsbCh0aGlzLCBkYXRhW2ldLCBpKSwgaSBdKTtcbiAgICAgIH1cbiAgICAgIHBvaW50cy5zb3J0KGQzX2dlb21faHVsbE9yZGVyKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGZsaXBwZWRQb2ludHMucHVzaChbIHBvaW50c1tpXVswXSwgLXBvaW50c1tpXVsxXSBdKTtcbiAgICAgIHZhciB1cHBlciA9IGQzX2dlb21faHVsbFVwcGVyKHBvaW50cyksIGxvd2VyID0gZDNfZ2VvbV9odWxsVXBwZXIoZmxpcHBlZFBvaW50cyk7XG4gICAgICB2YXIgc2tpcExlZnQgPSBsb3dlclswXSA9PT0gdXBwZXJbMF0sIHNraXBSaWdodCA9IGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdID09PSB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgcG9seWdvbiA9IFtdO1xuICAgICAgZm9yIChpID0gdXBwZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHBvbHlnb24ucHVzaChkYXRhW3BvaW50c1t1cHBlcltpXV1bMl1dKTtcbiAgICAgIGZvciAoaSA9ICtza2lwTGVmdDsgaSA8IGxvd2VyLmxlbmd0aCAtIHNraXBSaWdodDsgKytpKSBwb2x5Z29uLnB1c2goZGF0YVtwb2ludHNbbG93ZXJbaV1dWzJdXSk7XG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9XG4gICAgaHVsbC54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IF8sIGh1bGwpIDogeDtcbiAgICB9O1xuICAgIGh1bGwueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBfLCBodWxsKSA6IHk7XG4gICAgfTtcbiAgICByZXR1cm4gaHVsbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9odWxsVXBwZXIocG9pbnRzKSB7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLCBodWxsID0gWyAwLCAxIF0sIGhzID0gMjtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IG47IGkrKykge1xuICAgICAgd2hpbGUgKGhzID4gMSAmJiBkM19jcm9zczJkKHBvaW50c1todWxsW2hzIC0gMl1dLCBwb2ludHNbaHVsbFtocyAtIDFdXSwgcG9pbnRzW2ldKSA8PSAwKSAtLWhzO1xuICAgICAgaHVsbFtocysrXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBodWxsLnNsaWNlKDAsIGhzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX2h1bGxPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xuICB9XG4gIGQzLmdlb20ucG9seWdvbiA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgZDNfc3ViY2xhc3MoY29vcmRpbmF0ZXMsIGQzX2dlb21fcG9seWdvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9O1xuICB2YXIgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlID0gZDMuZ2VvbS5wb2x5Z29uLnByb3RvdHlwZSA9IFtdO1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgYSwgYiA9IHRoaXNbbiAtIDFdLCBhcmVhID0gMDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGFyZWEgKz0gYVsxXSAqIGJbMF0gLSBhWzBdICogYlsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZWEgKiAuNTtcbiAgfTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmNlbnRyb2lkID0gZnVuY3Rpb24oaykge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgeCA9IDAsIHkgPSAwLCBhLCBiID0gdGhpc1tuIC0gMV0sIGM7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBrID0gLTEgLyAoNiAqIHRoaXMuYXJlYSgpKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGMgPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuICAgICAgeCArPSAoYVswXSArIGJbMF0pICogYztcbiAgICAgIHkgKz0gKGFbMV0gKyBiWzFdKSAqIGM7XG4gICAgfVxuICAgIHJldHVybiBbIHggKiBrLCB5ICogayBdO1xuICB9O1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uKHN1YmplY3QpIHtcbiAgICB2YXIgaW5wdXQsIGNsb3NlZCA9IGQzX2dlb21fcG9seWdvbkNsb3NlZChzdWJqZWN0KSwgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGggLSBkM19nZW9tX3BvbHlnb25DbG9zZWQodGhpcyksIGosIG0sIGEgPSB0aGlzW24gLSAxXSwgYiwgYywgZDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaW5wdXQgPSBzdWJqZWN0LnNsaWNlKCk7XG4gICAgICBzdWJqZWN0Lmxlbmd0aCA9IDA7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGMgPSBpbnB1dFsobSA9IGlucHV0Lmxlbmd0aCAtIGNsb3NlZCkgLSAxXTtcbiAgICAgIGogPSAtMTtcbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgIGQgPSBpbnB1dFtqXTtcbiAgICAgICAgaWYgKGQzX2dlb21fcG9seWdvbkluc2lkZShkLCBhLCBiKSkge1xuICAgICAgICAgIGlmICghZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGMsIGEsIGIpKSB7XG4gICAgICAgICAgICBzdWJqZWN0LnB1c2goZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3ViamVjdC5wdXNoKGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGQzX2dlb21fcG9seWdvbkluc2lkZShjLCBhLCBiKSkge1xuICAgICAgICAgIHN1YmplY3QucHVzaChkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikpO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBkO1xuICAgICAgfVxuICAgICAgaWYgKGNsb3NlZCkgc3ViamVjdC5wdXNoKHN1YmplY3RbMF0pO1xuICAgICAgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBzdWJqZWN0O1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25JbnNpZGUocCwgYSwgYikge1xuICAgIHJldHVybiAoYlswXSAtIGFbMF0pICogKHBbMV0gLSBhWzFdKSA8IChiWzFdIC0gYVsxXSkgKiAocFswXSAtIGFbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSB7XG4gICAgdmFyIHgxID0gY1swXSwgeDMgPSBhWzBdLCB4MjEgPSBkWzBdIC0geDEsIHg0MyA9IGJbMF0gLSB4MywgeTEgPSBjWzFdLCB5MyA9IGFbMV0sIHkyMSA9IGRbMV0gLSB5MSwgeTQzID0gYlsxXSAtIHkzLCB1YSA9ICh4NDMgKiAoeTEgLSB5MykgLSB5NDMgKiAoeDEgLSB4MykpIC8gKHk0MyAqIHgyMSAtIHg0MyAqIHkyMSk7XG4gICAgcmV0dXJuIFsgeDEgKyB1YSAqIHgyMSwgeTEgKyB1YSAqIHkyMSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkNsb3NlZChjb29yZGluYXRlcykge1xuICAgIHZhciBhID0gY29vcmRpbmF0ZXNbMF0sIGIgPSBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gIShhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSk7XG4gIH1cbiAgdmFyIGQzX2dlb21fdm9yb25vaUVkZ2VzLCBkM19nZW9tX3Zvcm9ub2lDZWxscywgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcywgZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sID0gW10sIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlLCBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLCBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sID0gW107XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUJlYWNoKCkge1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgICB0aGlzLmVkZ2UgPSB0aGlzLnNpdGUgPSB0aGlzLmNpcmNsZSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2goc2l0ZSkge1xuICAgIHZhciBiZWFjaCA9IGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbC5wb3AoKSB8fCBuZXcgZDNfZ2VvbV92b3Jvbm9pQmVhY2goKTtcbiAgICBiZWFjaC5zaXRlID0gc2l0ZTtcbiAgICByZXR1cm4gYmVhY2g7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2goYmVhY2gpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUoYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMucmVtb3ZlKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wucHVzaChiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKGJlYWNoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZW1vdmVCZWFjaChiZWFjaCkge1xuICAgIHZhciBjaXJjbGUgPSBiZWFjaC5jaXJjbGUsIHggPSBjaXJjbGUueCwgeSA9IGNpcmNsZS5jeSwgdmVydGV4ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9LCBwcmV2aW91cyA9IGJlYWNoLlAsIG5leHQgPSBiZWFjaC5OLCBkaXNhcHBlYXJpbmcgPSBbIGJlYWNoIF07XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2goYmVhY2gpO1xuICAgIHZhciBsQXJjID0gcHJldmlvdXM7XG4gICAgd2hpbGUgKGxBcmMuY2lyY2xlICYmIGFicyh4IC0gbEFyYy5jaXJjbGUueCkgPCDOtSAmJiBhYnMoeSAtIGxBcmMuY2lyY2xlLmN5KSA8IM61KSB7XG4gICAgICBwcmV2aW91cyA9IGxBcmMuUDtcbiAgICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2gobEFyYyk7XG4gICAgICBsQXJjID0gcHJldmlvdXM7XG4gICAgfVxuICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICB2YXIgckFyYyA9IG5leHQ7XG4gICAgd2hpbGUgKHJBcmMuY2lyY2xlICYmIGFicyh4IC0gckFyYy5jaXJjbGUueCkgPCDOtSAmJiBhYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IM61KSB7XG4gICAgICBuZXh0ID0gckFyYy5OO1xuICAgICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChyQXJjKTtcbiAgICAgIHJBcmMgPSBuZXh0O1xuICAgIH1cbiAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUockFyYyk7XG4gICAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCwgaUFyYztcbiAgICBmb3IgKGlBcmMgPSAxOyBpQXJjIDwgbkFyY3M7ICsraUFyYykge1xuICAgICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcbiAgICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxBcmMuc2l0ZSwgckFyYy5zaXRlLCB2ZXJ0ZXgpO1xuICAgIH1cbiAgICBsQXJjID0gZGlzYXBwZWFyaW5nWzBdO1xuICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbbkFyY3MgLSAxXTtcbiAgICByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgckFyYy5zaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQWRkQmVhY2goc2l0ZSkge1xuICAgIHZhciB4ID0gc2l0ZS54LCBkaXJlY3RyaXggPSBzaXRlLnksIGxBcmMsIHJBcmMsIGR4bCwgZHhyLCBub2RlID0gZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5fO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBkeGwgPSBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpIC0geDtcbiAgICAgIGlmIChkeGwgPiDOtSkgbm9kZSA9IG5vZGUuTDsgZWxzZSB7XG4gICAgICAgIGR4ciA9IHggLSBkM19nZW9tX3Zvcm9ub2lSaWdodEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KTtcbiAgICAgICAgaWYgKGR4ciA+IM61KSB7XG4gICAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLlI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGR4bCA+IC3OtSkge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICAgIHJBcmMgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZHhyID4gLc61KSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxBcmMgPSByQXJjID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld0FyYyA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKHNpdGUpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMuaW5zZXJ0KGxBcmMsIG5ld0FyYyk7XG4gICAgaWYgKCFsQXJjICYmICFyQXJjKSByZXR1cm47XG4gICAgaWYgKGxBcmMgPT09IHJBcmMpIHtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICAgIHJBcmMgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChsQXJjLnNpdGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5pbnNlcnQobmV3QXJjLCByQXJjKTtcbiAgICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFyQXJjKSB7XG4gICAgICBuZXdBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUockFyYyk7XG4gICAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLCBheCA9IGxTaXRlLngsIGF5ID0gbFNpdGUueSwgYnggPSBzaXRlLnggLSBheCwgYnkgPSBzaXRlLnkgLSBheSwgclNpdGUgPSByQXJjLnNpdGUsIGN4ID0gclNpdGUueCAtIGF4LCBjeSA9IHJTaXRlLnkgLSBheSwgZCA9IDIgKiAoYnggKiBjeSAtIGJ5ICogY3gpLCBoYiA9IGJ4ICogYnggKyBieSAqIGJ5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB2ZXJ0ZXggPSB7XG4gICAgICB4OiAoY3kgKiBoYiAtIGJ5ICogaGMpIC8gZCArIGF4LFxuICAgICAgeTogKGJ4ICogaGMgLSBjeCAqIGhiKSAvIGQgKyBheVxuICAgIH07XG4gICAgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KTtcbiAgICBuZXdBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobFNpdGUsIHNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gICAgdmFyIHNpdGUgPSBhcmMuc2l0ZSwgcmZvY3ggPSBzaXRlLngsIHJmb2N5ID0gc2l0ZS55LCBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG4gICAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG4gICAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgICBpZiAoIWxBcmMpIHJldHVybiAtSW5maW5pdHk7XG4gICAgc2l0ZSA9IGxBcmMuc2l0ZTtcbiAgICB2YXIgbGZvY3ggPSBzaXRlLngsIGxmb2N5ID0gc2l0ZS55LCBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuICAgIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcbiAgICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LCBhYnkyID0gMSAvIHBieTIgLSAxIC8gcGxieTIsIGIgPSBobCAvIHBsYnkyO1xuICAgIGlmIChhYnkyKSByZXR1cm4gKC1iICsgTWF0aC5zcXJ0KGIgKiBiIC0gMiAqIGFieTIgKiAoaGwgKiBobCAvICgtMiAqIHBsYnkyKSAtIGxmb2N5ICsgcGxieTIgLyAyICsgcmZvY3kgLSBwYnkyIC8gMikpKSAvIGFieTIgKyByZm9jeDtcbiAgICByZXR1cm4gKHJmb2N4ICsgbGZvY3gpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICB2YXIgckFyYyA9IGFyYy5OO1xuICAgIGlmIChyQXJjKSByZXR1cm4gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQockFyYywgZGlyZWN0cml4KTtcbiAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICAgIHJldHVybiBzaXRlLnkgPT09IGRpcmVjdHJpeCA/IHNpdGUueCA6IEluZmluaXR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNlbGwoc2l0ZSkge1xuICAgIHRoaXMuc2l0ZSA9IHNpdGU7XG4gICAgdGhpcy5lZGdlcyA9IFtdO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaUNlbGwucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFsZkVkZ2VzID0gdGhpcy5lZGdlcywgaUhhbGZFZGdlID0gaGFsZkVkZ2VzLmxlbmd0aCwgZWRnZTtcbiAgICB3aGlsZSAoaUhhbGZFZGdlLS0pIHtcbiAgICAgIGVkZ2UgPSBoYWxmRWRnZXNbaUhhbGZFZGdlXS5lZGdlO1xuICAgICAgaWYgKCFlZGdlLmIgfHwgIWVkZ2UuYSkgaGFsZkVkZ2VzLnNwbGljZShpSGFsZkVkZ2UsIDEpO1xuICAgIH1cbiAgICBoYWxmRWRnZXMuc29ydChkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKTtcbiAgICByZXR1cm4gaGFsZkVkZ2VzLmxlbmd0aDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2xvc2VDZWxscyhleHRlbnQpIHtcbiAgICB2YXIgeDAgPSBleHRlbnRbMF1bMF0sIHgxID0gZXh0ZW50WzFdWzBdLCB5MCA9IGV4dGVudFswXVsxXSwgeTEgPSBleHRlbnRbMV1bMV0sIHgyLCB5MiwgeDMsIHkzLCBjZWxscyA9IGQzX2dlb21fdm9yb25vaUNlbGxzLCBpQ2VsbCA9IGNlbGxzLmxlbmd0aCwgY2VsbCwgaUhhbGZFZGdlLCBoYWxmRWRnZXMsIG5IYWxmRWRnZXMsIHN0YXJ0LCBlbmQ7XG4gICAgd2hpbGUgKGlDZWxsLS0pIHtcbiAgICAgIGNlbGwgPSBjZWxsc1tpQ2VsbF07XG4gICAgICBpZiAoIWNlbGwgfHwgIWNlbGwucHJlcGFyZSgpKSBjb250aW51ZTtcbiAgICAgIGhhbGZFZGdlcyA9IGNlbGwuZWRnZXM7XG4gICAgICBuSGFsZkVkZ2VzID0gaGFsZkVkZ2VzLmxlbmd0aDtcbiAgICAgIGlIYWxmRWRnZSA9IDA7XG4gICAgICB3aGlsZSAoaUhhbGZFZGdlIDwgbkhhbGZFZGdlcykge1xuICAgICAgICBlbmQgPSBoYWxmRWRnZXNbaUhhbGZFZGdlXS5lbmQoKSwgeDMgPSBlbmQueCwgeTMgPSBlbmQueTtcbiAgICAgICAgc3RhcnQgPSBoYWxmRWRnZXNbKytpSGFsZkVkZ2UgJSBuSGFsZkVkZ2VzXS5zdGFydCgpLCB4MiA9IHN0YXJ0LngsIHkyID0gc3RhcnQueTtcbiAgICAgICAgaWYgKGFicyh4MyAtIHgyKSA+IM61IHx8IGFicyh5MyAtIHkyKSA+IM61KSB7XG4gICAgICAgICAgaGFsZkVkZ2VzLnNwbGljZShpSGFsZkVkZ2UsIDAsIG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShkM19nZW9tX3Zvcm9ub2lDcmVhdGVCb3JkZXJFZGdlKGNlbGwuc2l0ZSwgZW5kLCBhYnMoeDMgLSB4MCkgPCDOtSAmJiB5MSAtIHkzID4gzrUgPyB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGFicyh4MiAtIHgwKSA8IM61ID8geTIgOiB5MVxuICAgICAgICAgIH0gOiBhYnMoeTMgLSB5MSkgPCDOtSAmJiB4MSAtIHgzID4gzrUgPyB7XG4gICAgICAgICAgICB4OiBhYnMoeTIgLSB5MSkgPCDOtSA/IHgyIDogeDEsXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH0gOiBhYnMoeDMgLSB4MSkgPCDOtSAmJiB5MyAtIHkwID4gzrUgPyB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGFicyh4MiAtIHgxKSA8IM61ID8geTIgOiB5MFxuICAgICAgICAgIH0gOiBhYnMoeTMgLSB5MCkgPCDOtSAmJiB4MyAtIHgwID4gzrUgPyB7XG4gICAgICAgICAgICB4OiBhYnMoeTIgLSB5MCkgPCDOtSA/IHgyIDogeDAsXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH0gOiBudWxsKSwgY2VsbC5zaXRlLCBudWxsKSk7XG4gICAgICAgICAgKytuSGFsZkVkZ2VzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBiLmFuZ2xlIC0gYS5hbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDaXJjbGUoKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMuYXJjID0gdGhpcy5zaXRlID0gdGhpcy5jeSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGFyYykge1xuICAgIHZhciBsQXJjID0gYXJjLlAsIHJBcmMgPSBhcmMuTjtcbiAgICBpZiAoIWxBcmMgfHwgIXJBcmMpIHJldHVybjtcbiAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGNTaXRlID0gYXJjLnNpdGUsIHJTaXRlID0gckFyYy5zaXRlO1xuICAgIGlmIChsU2l0ZSA9PT0gclNpdGUpIHJldHVybjtcbiAgICB2YXIgYnggPSBjU2l0ZS54LCBieSA9IGNTaXRlLnksIGF4ID0gbFNpdGUueCAtIGJ4LCBheSA9IGxTaXRlLnkgLSBieSwgY3ggPSByU2l0ZS54IC0gYngsIGN5ID0gclNpdGUueSAtIGJ5O1xuICAgIHZhciBkID0gMiAqIChheCAqIGN5IC0gYXkgKiBjeCk7XG4gICAgaWYgKGQgPj0gLc61MikgcmV0dXJuO1xuICAgIHZhciBoYSA9IGF4ICogYXggKyBheSAqIGF5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB4ID0gKGN5ICogaGEgLSBheSAqIGhjKSAvIGQsIHkgPSAoYXggKiBoYyAtIGN4ICogaGEpIC8gZCwgY3kgPSB5ICsgYnk7XG4gICAgdmFyIGNpcmNsZSA9IGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wucG9wKCkgfHwgbmV3IGQzX2dlb21fdm9yb25vaUNpcmNsZSgpO1xuICAgIGNpcmNsZS5hcmMgPSBhcmM7XG4gICAgY2lyY2xlLnNpdGUgPSBjU2l0ZTtcbiAgICBjaXJjbGUueCA9IHggKyBieDtcbiAgICBjaXJjbGUueSA9IGN5ICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNpcmNsZS5jeSA9IGN5O1xuICAgIGFyYy5jaXJjbGUgPSBjaXJjbGU7XG4gICAgdmFyIGJlZm9yZSA9IG51bGwsIG5vZGUgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLl87XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCBjaXJjbGUueSA9PT0gbm9kZS55ICYmIGNpcmNsZS54IDw9IG5vZGUueCkge1xuICAgICAgICBpZiAobm9kZS5MKSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBub2RlLlA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLlIpIG5vZGUgPSBub2RlLlI7IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5pbnNlcnQoYmVmb3JlLCBjaXJjbGUpO1xuICAgIGlmICghYmVmb3JlKSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSA9IGNpcmNsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUoYXJjKSB7XG4gICAgdmFyIGNpcmNsZSA9IGFyYy5jaXJjbGU7XG4gICAgaWYgKGNpcmNsZSkge1xuICAgICAgaWYgKCFjaXJjbGUuUCkgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUgPSBjaXJjbGUuTjtcbiAgICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMucmVtb3ZlKGNpcmNsZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sLnB1c2goY2lyY2xlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShjaXJjbGUpO1xuICAgICAgYXJjLmNpcmNsZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNsaXBFZGdlcyhleHRlbnQpIHtcbiAgICB2YXIgZWRnZXMgPSBkM19nZW9tX3Zvcm9ub2lFZGdlcywgY2xpcCA9IGQzX2dlb21fY2xpcExpbmUoZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVswXSwgZXh0ZW50WzFdWzFdKSwgaSA9IGVkZ2VzLmxlbmd0aCwgZTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlID0gZWRnZXNbaV07XG4gICAgICBpZiAoIWQzX2dlb21fdm9yb25vaUNvbm5lY3RFZGdlKGUsIGV4dGVudCkgfHwgIWNsaXAoZSkgfHwgYWJzKGUuYS54IC0gZS5iLngpIDwgzrUgJiYgYWJzKGUuYS55IC0gZS5iLnkpIDwgzrUpIHtcbiAgICAgICAgZS5hID0gZS5iID0gbnVsbDtcbiAgICAgICAgZWRnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDb25uZWN0RWRnZShlZGdlLCBleHRlbnQpIHtcbiAgICB2YXIgdmIgPSBlZGdlLmI7XG4gICAgaWYgKHZiKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgdmEgPSBlZGdlLmEsIHgwID0gZXh0ZW50WzBdWzBdLCB4MSA9IGV4dGVudFsxXVswXSwgeTAgPSBleHRlbnRbMF1bMV0sIHkxID0gZXh0ZW50WzFdWzFdLCBsU2l0ZSA9IGVkZ2UubCwgclNpdGUgPSBlZGdlLnIsIGx4ID0gbFNpdGUueCwgbHkgPSBsU2l0ZS55LCByeCA9IHJTaXRlLngsIHJ5ID0gclNpdGUueSwgZnggPSAobHggKyByeCkgLyAyLCBmeSA9IChseSArIHJ5KSAvIDIsIGZtLCBmYjtcbiAgICBpZiAocnkgPT09IGx5KSB7XG4gICAgICBpZiAoZnggPCB4MCB8fCBmeCA+PSB4MSkgcmV0dXJuO1xuICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTBcbiAgICAgICAgfTsgZWxzZSBpZiAodmEueSA+PSB5MSkgcmV0dXJuO1xuICAgICAgICB2YiA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTFcbiAgICAgICAgfTsgZWxzZSBpZiAodmEueSA8IHkwKSByZXR1cm47XG4gICAgICAgIHZiID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZtID0gKGx4IC0gcngpIC8gKHJ5IC0gbHkpO1xuICAgICAgZmIgPSBmeSAtIGZtICogZng7XG4gICAgICBpZiAoZm0gPCAtMSB8fCBmbSA+IDEpIHtcbiAgICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6ICh5MCAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS55ID49IHkxKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiAoeTEgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6ICh5MSAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS55IDwgeTApIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6ICh5MCAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobHkgPCByeSkge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBmbSAqIHgwICsgZmJcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS54ID49IHgxKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGZtICogeDEgKyBmYlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGZtICogeDEgKyBmYlxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnggPCB4MCkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBmbSAqIHgwICsgZmJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVkZ2UuYSA9IHZhO1xuICAgIGVkZ2UuYiA9IHZiO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIHJTaXRlKSB7XG4gICAgdGhpcy5sID0gbFNpdGU7XG4gICAgdGhpcy5yID0gclNpdGU7XG4gICAgdGhpcy5hID0gdGhpcy5iID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxTaXRlLCByU2l0ZSwgdmEsIHZiKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgclNpdGUpO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgaWYgKHZhKSBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIGxTaXRlLCByU2l0ZSwgdmEpO1xuICAgIGlmICh2YikgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCByU2l0ZSwgbFNpdGUsIHZiKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tsU2l0ZS5pXS5lZGdlcy5wdXNoKG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCBsU2l0ZSwgclNpdGUpKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tyU2l0ZS5pXS5lZGdlcy5wdXNoKG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCByU2l0ZSwgbFNpdGUpKTtcbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCb3JkZXJFZGdlKGxTaXRlLCB2YSwgdmIpIHtcbiAgICB2YXIgZWRnZSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCBudWxsKTtcbiAgICBlZGdlLmEgPSB2YTtcbiAgICBlZGdlLmIgPSB2YjtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpIHtcbiAgICBpZiAoIWVkZ2UuYSAmJiAhZWRnZS5iKSB7XG4gICAgICBlZGdlLmEgPSB2ZXJ0ZXg7XG4gICAgICBlZGdlLmwgPSBsU2l0ZTtcbiAgICAgIGVkZ2UuciA9IHJTaXRlO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5sID09PSByU2l0ZSkge1xuICAgICAgZWRnZS5iID0gdmVydGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlLmEgPSB2ZXJ0ZXg7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIGxTaXRlLCByU2l0ZSkge1xuICAgIHZhciB2YSA9IGVkZ2UuYSwgdmIgPSBlZGdlLmI7XG4gICAgdGhpcy5lZGdlID0gZWRnZTtcbiAgICB0aGlzLnNpdGUgPSBsU2l0ZTtcbiAgICB0aGlzLmFuZ2xlID0gclNpdGUgPyBNYXRoLmF0YW4yKHJTaXRlLnkgLSBsU2l0ZS55LCByU2l0ZS54IC0gbFNpdGUueCkgOiBlZGdlLmwgPT09IGxTaXRlID8gTWF0aC5hdGFuMih2Yi54IC0gdmEueCwgdmEueSAtIHZiLnkpIDogTWF0aC5hdGFuMih2YS54IC0gdmIueCwgdmIueSAtIHZhLnkpO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlLnByb3RvdHlwZSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlLmwgPT09IHRoaXMuc2l0ZSA/IHRoaXMuZWRnZS5hIDogdGhpcy5lZGdlLmI7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZS5sID09PSB0aGlzLnNpdGUgPyB0aGlzLmVkZ2UuYiA6IHRoaXMuZWRnZS5hO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCkge1xuICAgIHRoaXMuXyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKG5vZGUpIHtcbiAgICBub2RlLlUgPSBub2RlLkMgPSBub2RlLkwgPSBub2RlLlIgPSBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZS5wcm90b3R5cGUgPSB7XG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhZnRlciwgbm9kZSkge1xuICAgICAgdmFyIHBhcmVudCwgZ3JhbmRwYSwgdW5jbGU7XG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgbm9kZS5QID0gYWZ0ZXI7XG4gICAgICAgIG5vZGUuTiA9IGFmdGVyLk47XG4gICAgICAgIGlmIChhZnRlci5OKSBhZnRlci5OLlAgPSBub2RlO1xuICAgICAgICBhZnRlci5OID0gbm9kZTtcbiAgICAgICAgaWYgKGFmdGVyLlIpIHtcbiAgICAgICAgICBhZnRlciA9IGFmdGVyLlI7XG4gICAgICAgICAgd2hpbGUgKGFmdGVyLkwpIGFmdGVyID0gYWZ0ZXIuTDtcbiAgICAgICAgICBhZnRlci5MID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZnRlci5SID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fKSB7XG4gICAgICAgIGFmdGVyID0gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdCh0aGlzLl8pO1xuICAgICAgICBub2RlLlAgPSBudWxsO1xuICAgICAgICBub2RlLk4gPSBhZnRlcjtcbiAgICAgICAgYWZ0ZXIuUCA9IGFmdGVyLkwgPSBub2RlO1xuICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gICAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLkwgPSBub2RlLlIgPSBudWxsO1xuICAgICAgbm9kZS5VID0gcGFyZW50O1xuICAgICAgbm9kZS5DID0gdHJ1ZTtcbiAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LkMpIHtcbiAgICAgICAgZ3JhbmRwYSA9IHBhcmVudC5VO1xuICAgICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcbiAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcbiAgICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5jbGUgPSBncmFuZHBhLkw7XG4gICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICB9XG4gICAgICB0aGlzLl8uQyA9IGZhbHNlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5OKSBub2RlLk4uUCA9IG5vZGUuUDtcbiAgICAgIGlmIChub2RlLlApIG5vZGUuUC5OID0gbm9kZS5OO1xuICAgICAgbm9kZS5OID0gbm9kZS5QID0gbnVsbDtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLlUsIHNpYmxpbmcsIGxlZnQgPSBub2RlLkwsIHJpZ2h0ID0gbm9kZS5SLCBuZXh0LCByZWQ7XG4gICAgICBpZiAoIWxlZnQpIG5leHQgPSByaWdodDsgZWxzZSBpZiAoIXJpZ2h0KSBuZXh0ID0gbGVmdDsgZWxzZSBuZXh0ID0gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdChyaWdodCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuTCA9PT0gbm9kZSkgcGFyZW50LkwgPSBuZXh0OyBlbHNlIHBhcmVudC5SID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuXyA9IG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICByZWQgPSBuZXh0LkM7XG4gICAgICAgIG5leHQuQyA9IG5vZGUuQztcbiAgICAgICAgbmV4dC5MID0gbGVmdDtcbiAgICAgICAgbGVmdC5VID0gbmV4dDtcbiAgICAgICAgaWYgKG5leHQgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgcGFyZW50ID0gbmV4dC5VO1xuICAgICAgICAgIG5leHQuVSA9IG5vZGUuVTtcbiAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICAgIHBhcmVudC5MID0gbm9kZTtcbiAgICAgICAgICBuZXh0LlIgPSByaWdodDtcbiAgICAgICAgICByaWdodC5VID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0LlUgPSBwYXJlbnQ7XG4gICAgICAgICAgcGFyZW50ID0gbmV4dDtcbiAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWQgPSBub2RlLkM7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUpIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgIGlmIChyZWQpIHJldHVybjtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuQykge1xuICAgICAgICBub2RlLkMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKSBicmVhaztcbiAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMgfHwgc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcuUiB8fCAhc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgICAgc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2libGluZy5MICYmIHNpYmxpbmcuTC5DIHx8IHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5VO1xuICAgICAgfSB3aGlsZSAoIW5vZGUuQyk7XG4gICAgICBpZiAobm9kZSkgbm9kZS5DID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodHJlZSwgbm9kZSkge1xuICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuUiwgcGFyZW50ID0gcC5VO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxOyBlbHNlIHBhcmVudC5SID0gcTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZS5fID0gcTtcbiAgICB9XG4gICAgcS5VID0gcGFyZW50O1xuICAgIHAuVSA9IHE7XG4gICAgcC5SID0gcS5MO1xuICAgIGlmIChwLlIpIHAuUi5VID0gcDtcbiAgICBxLkwgPSBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xuICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuTCwgcGFyZW50ID0gcC5VO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxOyBlbHNlIHBhcmVudC5SID0gcTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZS5fID0gcTtcbiAgICB9XG4gICAgcS5VID0gcGFyZW50O1xuICAgIHAuVSA9IHE7XG4gICAgcC5MID0gcS5SO1xuICAgIGlmIChwLkwpIHAuTC5VID0gcDtcbiAgICBxLlIgPSBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pKHNpdGVzLCBiYm94KSB7XG4gICAgdmFyIHNpdGUgPSBzaXRlcy5zb3J0KGQzX2dlb21fdm9yb25vaVZlcnRleE9yZGVyKS5wb3AoKSwgeDAsIHkwLCBjaXJjbGU7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMgPSBbXTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxscyA9IG5ldyBBcnJheShzaXRlcy5sZW5ndGgpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcyA9IG5ldyBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY2lyY2xlID0gZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGU7XG4gICAgICBpZiAoc2l0ZSAmJiAoIWNpcmNsZSB8fCBzaXRlLnkgPCBjaXJjbGUueSB8fCBzaXRlLnkgPT09IGNpcmNsZS55ICYmIHNpdGUueCA8IGNpcmNsZS54KSkge1xuICAgICAgICBpZiAoc2l0ZS54ICE9PSB4MCB8fCBzaXRlLnkgIT09IHkwKSB7XG4gICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbc2l0ZS5pXSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lDZWxsKHNpdGUpO1xuICAgICAgICAgIGQzX2dlb21fdm9yb25vaUFkZEJlYWNoKHNpdGUpO1xuICAgICAgICAgIHgwID0gc2l0ZS54LCB5MCA9IHNpdGUueTtcbiAgICAgICAgfVxuICAgICAgICBzaXRlID0gc2l0ZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKGNpcmNsZSkge1xuICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZW1vdmVCZWFjaChjaXJjbGUuYXJjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmJveCkgZDNfZ2VvbV92b3Jvbm9pQ2xpcEVkZ2VzKGJib3gpLCBkM19nZW9tX3Zvcm9ub2lDbG9zZUNlbGxzKGJib3gpO1xuICAgIHZhciBkaWFncmFtID0ge1xuICAgICAgY2VsbHM6IGQzX2dlb21fdm9yb25vaUNlbGxzLFxuICAgICAgZWRnZXM6IGQzX2dlb21fdm9yb25vaUVkZ2VzXG4gICAgfTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcyA9IGQzX2dlb21fdm9yb25vaUVkZ2VzID0gZDNfZ2VvbV92b3Jvbm9pQ2VsbHMgPSBudWxsO1xuICAgIHJldHVybiBkaWFncmFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVZlcnRleE9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYi55IC0gYS55IHx8IGIueCAtIGEueDtcbiAgfVxuICBkMy5nZW9tLnZvcm9ub2kgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGZ4ID0geCwgZnkgPSB5LCBjbGlwRXh0ZW50ID0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudDtcbiAgICBpZiAocG9pbnRzKSByZXR1cm4gdm9yb25vaShwb2ludHMpO1xuICAgIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xuICAgICAgdmFyIHBvbHlnb25zID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKSwgeDAgPSBjbGlwRXh0ZW50WzBdWzBdLCB5MCA9IGNsaXBFeHRlbnRbMF1bMV0sIHgxID0gY2xpcEV4dGVudFsxXVswXSwgeTEgPSBjbGlwRXh0ZW50WzFdWzFdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpLCBjbGlwRXh0ZW50KS5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gY2VsbC5lZGdlcywgc2l0ZSA9IGNlbGwuc2l0ZSwgcG9seWdvbiA9IHBvbHlnb25zW2ldID0gZWRnZXMubGVuZ3RoID8gZWRnZXMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcyA9IGUuc3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gWyBzLngsIHMueSBdO1xuICAgICAgICB9KSA6IHNpdGUueCA+PSB4MCAmJiBzaXRlLnggPD0geDEgJiYgc2l0ZS55ID49IHkwICYmIHNpdGUueSA8PSB5MSA/IFsgWyB4MCwgeTEgXSwgWyB4MSwgeTEgXSwgWyB4MSwgeTAgXSwgWyB4MCwgeTAgXSBdIDogW107XG4gICAgICAgIHBvbHlnb24ucG9pbnQgPSBkYXRhW2ldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpdGVzKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZChmeChkLCBpKSAvIM61KSAqIM61LFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoZnkoZCwgaSkgLyDOtSkgKiDOtSxcbiAgICAgICAgICBpOiBpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgdm9yb25vaS5saW5rcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSkpLmVkZ2VzLmZpbHRlcihmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmwgJiYgZWRnZS5yO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IGRhdGFbZWRnZS5sLmldLFxuICAgICAgICAgIHRhcmdldDogZGF0YVtlZGdlLnIuaV1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgdHJpYW5nbGVzID0gW107XG4gICAgICBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSkpLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSwgZWRnZXMgPSBjZWxsLmVkZ2VzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlciksIGogPSAtMSwgbSA9IGVkZ2VzLmxlbmd0aCwgZTAsIHMwLCBlMSA9IGVkZ2VzW20gLSAxXS5lZGdlLCBzMSA9IGUxLmwgPT09IHNpdGUgPyBlMS5yIDogZTEubDtcbiAgICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgICBlMCA9IGUxO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgZTEgPSBlZGdlc1tqXS5lZGdlO1xuICAgICAgICAgIHMxID0gZTEubCA9PT0gc2l0ZSA/IGUxLnIgOiBlMS5sO1xuICAgICAgICAgIGlmIChpIDwgczAuaSAmJiBpIDwgczEuaSAmJiBkM19nZW9tX3Zvcm9ub2lUcmlhbmdsZUFyZWEoc2l0ZSwgczAsIHMxKSA8IDApIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKFsgZGF0YVtpXSwgZGF0YVtzMC5pXSwgZGF0YVtzMS5pXSBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgICB9O1xuICAgIHZvcm9ub2kueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZ4ID0gZDNfZnVuY3Rvcih4ID0gXyksIHZvcm9ub2kpIDogeDtcbiAgICB9O1xuICAgIHZvcm9ub2kueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZ5ID0gZDNfZnVuY3Rvcih5ID0gXyksIHZvcm9ub2kpIDogeTtcbiAgICB9O1xuICAgIHZvcm9ub2kuY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQgPT09IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPyBudWxsIDogY2xpcEV4dGVudDtcbiAgICAgIGNsaXBFeHRlbnQgPSBfID09IG51bGwgPyBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50IDogXztcbiAgICAgIHJldHVybiB2b3Jvbm9pO1xuICAgIH07XG4gICAgdm9yb25vaS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudCA9PT0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA/IG51bGwgOiBjbGlwRXh0ZW50ICYmIGNsaXBFeHRlbnRbMV07XG4gICAgICByZXR1cm4gdm9yb25vaS5jbGlwRXh0ZW50KF8gJiYgWyBbIDAsIDAgXSwgXyBdKTtcbiAgICB9O1xuICAgIHJldHVybiB2b3Jvbm9pO1xuICB9O1xuICB2YXIgZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA9IFsgWyAtMWU2LCAtMWU2IF0sIFsgMWU2LCAxZTYgXSBdO1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lUcmlhbmdsZUFyZWEoYSwgYiwgYykge1xuICAgIHJldHVybiAoYS54IC0gYy54KSAqIChiLnkgLSBhLnkpIC0gKGEueCAtIGIueCkgKiAoYy55IC0gYS55KTtcbiAgfVxuICBkMy5nZW9tLmRlbGF1bmF5ID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICByZXR1cm4gZDMuZ2VvbS52b3Jvbm9pKCkudHJpYW5nbGVzKHZlcnRpY2VzKTtcbiAgfTtcbiAgZDMuZ2VvbS5xdWFkdHJlZSA9IGZ1bmN0aW9uKHBvaW50cywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGNvbXBhdDtcbiAgICBpZiAoY29tcGF0ID0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeCA9IGQzX2dlb21fcXVhZHRyZWVDb21wYXRYO1xuICAgICAgeSA9IGQzX2dlb21fcXVhZHRyZWVDb21wYXRZO1xuICAgICAgaWYgKGNvbXBhdCA9PT0gMykge1xuICAgICAgICB5MiA9IHkxO1xuICAgICAgICB4MiA9IHgxO1xuICAgICAgICB5MSA9IHgxID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWFkdHJlZShwb2ludHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWFkdHJlZShkYXRhKSB7XG4gICAgICB2YXIgZCwgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSksIHhzLCB5cywgaSwgbiwgeDFfLCB5MV8sIHgyXywgeTJfO1xuICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgeDFfID0geDEsIHkxXyA9IHkxLCB4Ml8gPSB4MiwgeTJfID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4Ml8gPSB5Ml8gPSAtKHgxXyA9IHkxXyA9IEluZmluaXR5KTtcbiAgICAgICAgeHMgPSBbXSwgeXMgPSBbXTtcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoY29tcGF0KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgaWYgKGQueCA8IHgxXykgeDFfID0gZC54O1xuICAgICAgICAgIGlmIChkLnkgPCB5MV8pIHkxXyA9IGQueTtcbiAgICAgICAgICBpZiAoZC54ID4geDJfKSB4Ml8gPSBkLng7XG4gICAgICAgICAgaWYgKGQueSA+IHkyXykgeTJfID0gZC55O1xuICAgICAgICAgIHhzLnB1c2goZC54KTtcbiAgICAgICAgICB5cy5wdXNoKGQueSk7XG4gICAgICAgIH0gZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgdmFyIHhfID0gK2Z4KGQgPSBkYXRhW2ldLCBpKSwgeV8gPSArZnkoZCwgaSk7XG4gICAgICAgICAgaWYgKHhfIDwgeDFfKSB4MV8gPSB4XztcbiAgICAgICAgICBpZiAoeV8gPCB5MV8pIHkxXyA9IHlfO1xuICAgICAgICAgIGlmICh4XyA+IHgyXykgeDJfID0geF87XG4gICAgICAgICAgaWYgKHlfID4geTJfKSB5Ml8gPSB5XztcbiAgICAgICAgICB4cy5wdXNoKHhfKTtcbiAgICAgICAgICB5cy5wdXNoKHlfKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGR4ID0geDJfIC0geDFfLCBkeSA9IHkyXyAtIHkxXztcbiAgICAgIGlmIChkeCA+IGR5KSB5Ml8gPSB5MV8gKyBkeDsgZWxzZSB4Ml8gPSB4MV8gKyBkeTtcbiAgICAgIGZ1bmN0aW9uIGluc2VydChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybjtcbiAgICAgICAgaWYgKG4ubGVhZikge1xuICAgICAgICAgIHZhciBueCA9IG4ueCwgbnkgPSBuLnk7XG4gICAgICAgICAgaWYgKG54ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChhYnMobnggLSB4KSArIGFicyhueSAtIHkpIDwgLjAxKSB7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBuUG9pbnQgPSBuLnBvaW50O1xuICAgICAgICAgICAgICBuLnggPSBuLnkgPSBuLnBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgblBvaW50LCBueCwgbnksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnggPSB4LCBuLnkgPSB5LCBuLnBvaW50ID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW0sIGkgPSBiZWxvdyA8PCAxIHwgcmlnaHQ7XG4gICAgICAgIG4ubGVhZiA9IGZhbHNlO1xuICAgICAgICBuID0gbi5ub2Rlc1tpXSB8fCAobi5ub2Rlc1tpXSA9IGQzX2dlb21fcXVhZHRyZWVOb2RlKCkpO1xuICAgICAgICBpZiAocmlnaHQpIHgxID0geG07IGVsc2UgeDIgPSB4bTtcbiAgICAgICAgaWYgKGJlbG93KSB5MSA9IHltOyBlbHNlIHkyID0geW07XG4gICAgICAgIGluc2VydChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICB9XG4gICAgICB2YXIgcm9vdCA9IGQzX2dlb21fcXVhZHRyZWVOb2RlKCk7XG4gICAgICByb290LmFkZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaW5zZXJ0KHJvb3QsIGQsICtmeChkLCArK2kpLCArZnkoZCwgaSksIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgcm9vdC52aXNpdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIHJvb3QsIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgcm9vdC5maW5kID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGQzX2dlb21fcXVhZHRyZWVGaW5kKHJvb3QsIHBvaW50WzBdLCBwb2ludFsxXSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICBpID0gLTE7XG4gICAgICBpZiAoeDEgPT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGluc2VydChyb290LCBkYXRhW2ldLCB4c1tpXSwgeXNbaV0sIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICAgIH1cbiAgICAgICAgLS1pO1xuICAgICAgfSBlbHNlIGRhdGEuZm9yRWFjaChyb290LmFkZCk7XG4gICAgICB4cyA9IHlzID0gZGF0YSA9IGQgPSBudWxsO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHF1YWR0cmVlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXywgcXVhZHRyZWUpIDogeDtcbiAgICB9O1xuICAgIHF1YWR0cmVlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gXywgcXVhZHRyZWUpIDogeTtcbiAgICB9O1xuICAgIHF1YWR0cmVlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxID09IG51bGwgPyBudWxsIDogWyBbIHgxLCB5MSBdLCBbIHgyLCB5MiBdIF07XG4gICAgICBpZiAoXyA9PSBudWxsKSB4MSA9IHkxID0geDIgPSB5MiA9IG51bGw7IGVsc2UgeDEgPSArX1swXVswXSwgeTEgPSArX1swXVsxXSwgeDIgPSArX1sxXVswXSwgXG4gICAgICB5MiA9ICtfWzFdWzFdO1xuICAgICAgcmV0dXJuIHF1YWR0cmVlO1xuICAgIH07XG4gICAgcXVhZHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxID09IG51bGwgPyBudWxsIDogWyB4MiAtIHgxLCB5MiAtIHkxIF07XG4gICAgICBpZiAoXyA9PSBudWxsKSB4MSA9IHkxID0geDIgPSB5MiA9IG51bGw7IGVsc2UgeDEgPSB5MSA9IDAsIHgyID0gK19bMF0sIHkyID0gK19bMV07XG4gICAgICByZXR1cm4gcXVhZHRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gcXVhZHRyZWU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVDb21wYXRYKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVDb21wYXRZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVOb2RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWFmOiB0cnVlLFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgcG9pbnQ6IG51bGwsXG4gICAgICB4OiBudWxsLFxuICAgICAgeTogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIG5vZGUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKCFmKG5vZGUsIHgxLCB5MSwgeDIsIHkyKSkge1xuICAgICAgdmFyIHN4ID0gKHgxICsgeDIpICogLjUsIHN5ID0gKHkxICsgeTIpICogLjUsIGNoaWxkcmVuID0gbm9kZS5ub2RlcztcbiAgICAgIGlmIChjaGlsZHJlblswXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzBdLCB4MSwgeTEsIHN4LCBzeSk7XG4gICAgICBpZiAoY2hpbGRyZW5bMV0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblsxXSwgc3gsIHkxLCB4Miwgc3kpO1xuICAgICAgaWYgKGNoaWxkcmVuWzJdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMl0sIHgxLCBzeSwgc3gsIHkyKTtcbiAgICAgIGlmIChjaGlsZHJlblszXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzNdLCBzeCwgc3ksIHgyLCB5Mik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVGaW5kKHJvb3QsIHgsIHksIHgwLCB5MCwgeDMsIHkzKSB7XG4gICAgdmFyIG1pbkRpc3RhbmNlMiA9IEluZmluaXR5LCBjbG9zZXN0UG9pbnQ7XG4gICAgKGZ1bmN0aW9uIGZpbmQobm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGlmICh4MSA+IHgzIHx8IHkxID4geTMgfHwgeDIgPCB4MCB8fCB5MiA8IHkwKSByZXR1cm47XG4gICAgICBpZiAocG9pbnQgPSBub2RlLnBvaW50KSB7XG4gICAgICAgIHZhciBwb2ludCwgZHggPSB4IC0gbm9kZS54LCBkeSA9IHkgLSBub2RlLnksIGRpc3RhbmNlMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZGlzdGFuY2UyIDwgbWluRGlzdGFuY2UyKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlMiA9IGRpc3RhbmNlMik7XG4gICAgICAgICAgeDAgPSB4IC0gZGlzdGFuY2UsIHkwID0geSAtIGRpc3RhbmNlO1xuICAgICAgICAgIHgzID0geCArIGRpc3RhbmNlLCB5MyA9IHkgKyBkaXN0YW5jZTtcbiAgICAgICAgICBjbG9zZXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5ub2RlcywgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW07XG4gICAgICBmb3IgKHZhciBpID0gYmVsb3cgPDwgMSB8IHJpZ2h0LCBqID0gaSArIDQ7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBjaGlsZHJlbltpICYgM10pIHN3aXRjaCAoaSAmIDMpIHtcbiAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBmaW5kKG5vZGUsIHgxLCB5MSwgeG0sIHltKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGZpbmQobm9kZSwgeG0sIHkxLCB4MiwgeW0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZmluZChub2RlLCB4MSwgeW0sIHhtLCB5Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5bSwgeDIsIHkyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKHJvb3QsIHgwLCB5MCwgeDMsIHkzKTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xuICB9XG4gIGQzLmludGVycG9sYXRlUmdiID0gZDNfaW50ZXJwb2xhdGVSZ2I7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUmdiKGEsIGIpIHtcbiAgICBhID0gZDMucmdiKGEpO1xuICAgIGIgPSBkMy5yZ2IoYik7XG4gICAgdmFyIGFyID0gYS5yLCBhZyA9IGEuZywgYWIgPSBhLmIsIGJyID0gYi5yIC0gYXIsIGJnID0gYi5nIC0gYWcsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhciArIGJyICogdCkpICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFnICsgYmcgKiB0KSkgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYWIgKyBiYiAqIHQpKTtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlT2JqZWN0ID0gZDNfaW50ZXJwb2xhdGVPYmplY3Q7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlT2JqZWN0KGEsIGIpIHtcbiAgICB2YXIgaSA9IHt9LCBjID0ge30sIGs7XG4gICAgZm9yIChrIGluIGEpIHtcbiAgICAgIGlmIChrIGluIGIpIHtcbiAgICAgICAgaVtrXSA9IGQzX2ludGVycG9sYXRlKGFba10sIGJba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY1trXSA9IGFba107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayBpbiBiKSB7XG4gICAgICBpZiAoIShrIGluIGEpKSB7XG4gICAgICAgIGNba10gPSBiW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZU51bWJlciA9IGQzX2ludGVycG9sYXRlTnVtYmVyO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gICAgYSA9ICthLCBiID0gK2I7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVTdHJpbmcgPSBkM19pbnRlcnBvbGF0ZVN0cmluZztcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTdHJpbmcoYSwgYikge1xuICAgIHZhciBiaSA9IGQzX2ludGVycG9sYXRlX251bWJlckEubGFzdEluZGV4ID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXggPSAwLCBhbSwgYm0sIGJzLCBpID0gLTEsIHMgPSBbXSwgcSA9IFtdO1xuICAgIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuICAgIHdoaWxlICgoYW0gPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJBLmV4ZWMoYSkpICYmIChibSA9IGQzX2ludGVycG9sYXRlX251bWJlckIuZXhlYyhiKSkpIHtcbiAgICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkge1xuICAgICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgICB9XG4gICAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IGVsc2Ugc1srK2ldID0gYm07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzWysraV0gPSBudWxsO1xuICAgICAgICBxLnB1c2goe1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoYW0sIGJtKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJpID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIHJldHVybiBzLmxlbmd0aCA8IDIgPyBxWzBdID8gKGIgPSBxWzBdLngsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgICB9KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIHZhciBkM19pbnRlcnBvbGF0ZV9udW1iZXJBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLCBkM19pbnRlcnBvbGF0ZV9udW1iZXJCID0gbmV3IFJlZ0V4cChkM19pbnRlcnBvbGF0ZV9udW1iZXJBLnNvdXJjZSwgXCJnXCIpO1xuICBkMy5pbnRlcnBvbGF0ZSA9IGQzX2ludGVycG9sYXRlO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0b3JzLmxlbmd0aCwgZjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgIShmID0gZDMuaW50ZXJwb2xhdG9yc1tpXShhLCBiKSkpIDtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBkMy5pbnRlcnBvbGF0b3JzID0gWyBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgYjtcbiAgICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBkM19yZ2JfbmFtZXMuaGFzKGIudG9Mb3dlckNhc2UoKSkgfHwgL14oI3xyZ2JcXCh8aHNsXFwoKS9pLnRlc3QoYikgPyBkM19pbnRlcnBvbGF0ZVJnYiA6IGQzX2ludGVycG9sYXRlU3RyaW5nIDogYiBpbnN0YW5jZW9mIGQzX2NvbG9yID8gZDNfaW50ZXJwb2xhdGVSZ2IgOiBBcnJheS5pc0FycmF5KGIpID8gZDNfaW50ZXJwb2xhdGVBcnJheSA6IHQgPT09IFwib2JqZWN0XCIgJiYgaXNOYU4oYikgPyBkM19pbnRlcnBvbGF0ZU9iamVjdCA6IGQzX2ludGVycG9sYXRlTnVtYmVyKShhLCBiKTtcbiAgfSBdO1xuICBkMy5pbnRlcnBvbGF0ZUFycmF5ID0gZDNfaW50ZXJwb2xhdGVBcnJheTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVBcnJheShhLCBiKSB7XG4gICAgdmFyIHggPSBbXSwgYyA9IFtdLCBuYSA9IGEubGVuZ3RoLCBuYiA9IGIubGVuZ3RoLCBuMCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIHgucHVzaChkM19pbnRlcnBvbGF0ZShhW2ldLCBiW2ldKSk7XG4gICAgZm9yICg7aSA8IG5hOyArK2kpIGNbaV0gPSBhW2ldO1xuICAgIGZvciAoO2kgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZWFzZV9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2lkZW50aXR5O1xuICB9O1xuICB2YXIgZDNfZWFzZSA9IGQzLm1hcCh7XG4gICAgbGluZWFyOiBkM19lYXNlX2RlZmF1bHQsXG4gICAgcG9seTogZDNfZWFzZV9wb2x5LFxuICAgIHF1YWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfcXVhZDtcbiAgICB9LFxuICAgIGN1YmljOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2N1YmljO1xuICAgIH0sXG4gICAgc2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3NpbjtcbiAgICB9LFxuICAgIGV4cDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9leHA7XG4gICAgfSxcbiAgICBjaXJjbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfY2lyY2xlO1xuICAgIH0sXG4gICAgZWxhc3RpYzogZDNfZWFzZV9lbGFzdGljLFxuICAgIGJhY2s6IGQzX2Vhc2VfYmFjayxcbiAgICBib3VuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfYm91bmNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBkM19lYXNlX21vZGUgPSBkMy5tYXAoe1xuICAgIFwiaW5cIjogZDNfaWRlbnRpdHksXG4gICAgb3V0OiBkM19lYXNlX3JldmVyc2UsXG4gICAgXCJpbi1vdXRcIjogZDNfZWFzZV9yZWZsZWN0LFxuICAgIFwib3V0LWluXCI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3JlZmxlY3QoZDNfZWFzZV9yZXZlcnNlKGYpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5lYXNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLVwiKSwgdCA9IGkgPj0gMCA/IG5hbWUuc2xpY2UoMCwgaSkgOiBuYW1lLCBtID0gaSA+PSAwID8gbmFtZS5zbGljZShpICsgMSkgOiBcImluXCI7XG4gICAgdCA9IGQzX2Vhc2UuZ2V0KHQpIHx8IGQzX2Vhc2VfZGVmYXVsdDtcbiAgICBtID0gZDNfZWFzZV9tb2RlLmdldChtKSB8fCBkM19pZGVudGl0eTtcbiAgICByZXR1cm4gZDNfZWFzZV9jbGFtcChtKHQuYXBwbHkobnVsbCwgZDNfYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY2xhbXAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCA8PSAwID8gMCA6IHQgPj0gMSA/IDEgOiBmKHQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9yZXZlcnNlKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIDEgLSBmKDEgLSB0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcmVmbGVjdChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAuNSAqICh0IDwgLjUgPyBmKDIgKiB0KSA6IDIgLSBmKDIgLSAyICogdCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9xdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2N1YmljSW5PdXQodCkge1xuICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuICAgIGlmICh0ID49IDEpIHJldHVybiAxO1xuICAgIHZhciB0MiA9IHQgKiB0LCB0MyA9IHQyICogdDtcbiAgICByZXR1cm4gNCAqICh0IDwgLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gLjc1KTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3BvbHkoZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3Npbih0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZs+AKTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2V4cCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jaXJjbGUodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9lbGFzdGljKGEsIHApIHtcbiAgICB2YXIgcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHAgPSAuNDU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHMgPSBwIC8gz4QgKiBNYXRoLmFzaW4oMSAvIGEpOyBlbHNlIGEgPSAxLCBzID0gcCAvIDQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAxICsgYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIM+EIC8gcCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2JhY2socykge1xuICAgIGlmICghcykgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9ib3VuY2UodCkge1xuICAgIHJldHVybiB0IDwgMSAvIDIuNzUgPyA3LjU2MjUgKiB0ICogdCA6IHQgPCAyIC8gMi43NSA/IDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIC43NSA6IHQgPCAyLjUgLyAyLjc1ID8gNy41NjI1ICogKHQgLT0gMi4yNSAvIDIuNzUpICogdCArIC45Mzc1IDogNy41NjI1ICogKHQgLT0gMi42MjUgLyAyLjc1KSAqIHQgKyAuOTg0Mzc1O1xuICB9XG4gIGQzLmludGVycG9sYXRlSGNsID0gZDNfaW50ZXJwb2xhdGVIY2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSGNsKGEsIGIpIHtcbiAgICBhID0gZDMuaGNsKGEpO1xuICAgIGIgPSBkMy5oY2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhYyA9IGEuYywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJjID0gYi5jIC0gYWMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJjKSkgYmMgPSAwLCBhYyA9IGlzTmFOKGFjKSA/IGIuYyA6IGFjO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oY2xfbGFiKGFoICsgYmggKiB0LCBhYyArIGJjICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlSHNsID0gZDNfaW50ZXJwb2xhdGVIc2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSHNsKGEsIGIpIHtcbiAgICBhID0gZDMuaHNsKGEpO1xuICAgIGIgPSBkMy5oc2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhcyA9IGEucywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJzID0gYi5zIC0gYXMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJzKSkgYnMgPSAwLCBhcyA9IGlzTmFOKGFzKSA/IGIucyA6IGFzO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oc2xfcmdiKGFoICsgYmggKiB0LCBhcyArIGJzICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlTGFiID0gZDNfaW50ZXJwb2xhdGVMYWI7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlTGFiKGEsIGIpIHtcbiAgICBhID0gZDMubGFiKGEpO1xuICAgIGIgPSBkMy5sYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLCBhYSA9IGEuYSwgYWIgPSBhLmIsIGJsID0gYi5sIC0gYWwsIGJhID0gYi5hIC0gYWEsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19sYWJfcmdiKGFsICsgYmwgKiB0LCBhYSArIGJhICogdCwgYWIgKyBiYiAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlUm91bmQgPSBkM19pbnRlcnBvbGF0ZVJvdW5kO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdW5kKGEsIGIpIHtcbiAgICBiIC09IGE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gICAgfTtcbiAgfVxuICBkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZyA9IGQzX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhkMy5ucy5wcmVmaXguc3ZnLCBcImdcIik7XG4gICAgcmV0dXJuIChkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdHJpbmcpO1xuICAgICAgICB2YXIgdCA9IGcudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZDNfdHJhbnNmb3JtKHQgPyB0Lm1hdHJpeCA6IGQzX3RyYW5zZm9ybUlkZW50aXR5KTtcbiAgICB9KShzdHJpbmcpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2Zvcm0obSkge1xuICAgIHZhciByMCA9IFsgbS5hLCBtLmIgXSwgcjEgPSBbIG0uYywgbS5kIF0sIGt4ID0gZDNfdHJhbnNmb3JtTm9ybWFsaXplKHIwKSwga3ogPSBkM190cmFuc2Zvcm1Eb3QocjAsIHIxKSwga3kgPSBkM190cmFuc2Zvcm1Ob3JtYWxpemUoZDNfdHJhbnNmb3JtQ29tYmluZShyMSwgcjAsIC1reikpIHx8IDA7XG4gICAgaWYgKHIwWzBdICogcjFbMV0gPCByMVswXSAqIHIwWzFdKSB7XG4gICAgICByMFswXSAqPSAtMTtcbiAgICAgIHIwWzFdICo9IC0xO1xuICAgICAga3ggKj0gLTE7XG4gICAgICBreiAqPSAtMTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGUgPSAoa3ggPyBNYXRoLmF0YW4yKHIwWzFdLCByMFswXSkgOiBNYXRoLmF0YW4yKC1yMVswXSwgcjFbMV0pKSAqIGQzX2RlZ3JlZXM7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBbIG0uZSwgbS5mIF07XG4gICAgdGhpcy5zY2FsZSA9IFsga3gsIGt5IF07XG4gICAgdGhpcy5za2V3ID0ga3kgPyBNYXRoLmF0YW4yKGt6LCBreSkgKiBkM19kZWdyZWVzIDogMDtcbiAgfVxuICBkM190cmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy50cmFuc2xhdGUgKyBcIilyb3RhdGUoXCIgKyB0aGlzLnJvdGF0ZSArIFwiKXNrZXdYKFwiICsgdGhpcy5za2V3ICsgXCIpc2NhbGUoXCIgKyB0aGlzLnNjYWxlICsgXCIpXCI7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybURvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtTm9ybWFsaXplKGEpIHtcbiAgICB2YXIgayA9IE1hdGguc3FydChkM190cmFuc2Zvcm1Eb3QoYSwgYSkpO1xuICAgIGlmIChrKSB7XG4gICAgICBhWzBdIC89IGs7XG4gICAgICBhWzFdIC89IGs7XG4gICAgfVxuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybUNvbWJpbmUoYSwgYiwgaykge1xuICAgIGFbMF0gKz0gayAqIGJbMF07XG4gICAgYVsxXSArPSBrICogYlsxXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2YXIgZDNfdHJhbnNmb3JtSWRlbnRpdHkgPSB7XG4gICAgYTogMSxcbiAgICBiOiAwLFxuICAgIGM6IDAsXG4gICAgZDogMSxcbiAgICBlOiAwLFxuICAgIGY6IDBcbiAgfTtcbiAgZDMuaW50ZXJwb2xhdGVUcmFuc2Zvcm0gPSBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIixcIiA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2xhdGUodGEsIHRiLCBzLCBxKSB7XG4gICAgaWYgKHRhWzBdICE9PSB0YlswXSB8fCB0YVsxXSAhPT0gdGJbMV0pIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzBdLCB0YlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogaSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzFdLCB0YlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGJbMF0gfHwgdGJbMV0pIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHRiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdGF0ZShyYSwgcmIsIHMsIHEpIHtcbiAgICBpZiAocmEgIT09IHJiKSB7XG4gICAgICBpZiAocmEgLSByYiA+IDE4MCkgcmIgKz0gMzYwOyBlbHNlIGlmIChyYiAtIHJhID4gMTgwKSByYSArPSAzNjA7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgXCIpXCIpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIocmEsIHJiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyYikge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJyb3RhdGUoXCIgKyByYiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTa2V3KHdhLCB3YiwgcywgcSkge1xuICAgIGlmICh3YSAhPT0gd2IpIHtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2tld1goXCIsIG51bGwsIFwiKVwiKSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHdhLCB3YilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAod2IpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2tld1goXCIgKyB3YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTY2FsZShrYSwga2IsIHMsIHEpIHtcbiAgICBpZiAoa2FbMF0gIT09IGtiWzBdIHx8IGthWzFdICE9PSBrYlsxXSkge1xuICAgICAgdmFyIGkgPSBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzBdLCBrYlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogaSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzFdLCBrYlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2JbMF0gIT09IDEgfHwga2JbMV0gIT09IDEpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2NhbGUoXCIgKyBrYiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0oYSwgYikge1xuICAgIHZhciBzID0gW10sIHEgPSBbXTtcbiAgICBhID0gZDMudHJhbnNmb3JtKGEpLCBiID0gZDMudHJhbnNmb3JtKGIpO1xuICAgIGQzX2ludGVycG9sYXRlVHJhbnNsYXRlKGEudHJhbnNsYXRlLCBiLnRyYW5zbGF0ZSwgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVSb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVNrZXcoYS5za2V3LCBiLnNrZXcsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlU2NhbGUoYS5zY2FsZSwgYi5zY2FsZSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3VuaW50ZXJwb2xhdGVOdW1iZXIoYSwgYikge1xuICAgIGIgPSAoYiAtPSBhID0gK2EpIHx8IDEgLyBiO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gKHggLSBhKSAvIGI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM191bmludGVycG9sYXRlQ2xhbXAoYSwgYikge1xuICAgIGIgPSAoYiAtPSBhID0gK2EpIHx8IDEgLyBiO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHggLSBhKSAvIGIpKTtcbiAgICB9O1xuICB9XG4gIGQzLmxheW91dCA9IHt9O1xuICBkMy5sYXlvdXQuYnVuZGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmtzKSB7XG4gICAgICB2YXIgcGF0aHMgPSBbXSwgaSA9IC0xLCBuID0gbGlua3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHBhdGhzLnB1c2goZDNfbGF5b3V0X2J1bmRsZVBhdGgobGlua3NbaV0pKTtcbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlUGF0aChsaW5rKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2UsIGVuZCA9IGxpbmsudGFyZ2V0LCBsY2EgPSBkM19sYXlvdXRfYnVuZGxlTGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSwgcG9pbnRzID0gWyBzdGFydCBdO1xuICAgIHdoaWxlIChzdGFydCAhPT0gbGNhKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcbiAgICAgIHBvaW50cy5wdXNoKHN0YXJ0KTtcbiAgICB9XG4gICAgdmFyIGsgPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlIChlbmQgIT09IGxjYSkge1xuICAgICAgcG9pbnRzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgICAgZW5kID0gZW5kLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW10sIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlTGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICAgIHZhciBhTm9kZXMgPSBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKGEpLCBiTm9kZXMgPSBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKGIpLCBhTm9kZSA9IGFOb2Rlcy5wb3AoKSwgYk5vZGUgPSBiTm9kZXMucG9wKCksIHNoYXJlZE5vZGUgPSBudWxsO1xuICAgIHdoaWxlIChhTm9kZSA9PT0gYk5vZGUpIHtcbiAgICAgIHNoYXJlZE5vZGUgPSBhTm9kZTtcbiAgICAgIGFOb2RlID0gYU5vZGVzLnBvcCgpO1xuICAgICAgYk5vZGUgPSBiTm9kZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBzaGFyZWROb2RlO1xuICB9XG4gIGQzLmxheW91dC5jaG9yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaG9yZCA9IHt9LCBjaG9yZHMsIGdyb3VwcywgbWF0cml4LCBuLCBwYWRkaW5nID0gMCwgc29ydEdyb3Vwcywgc29ydFN1Ymdyb3Vwcywgc29ydENob3JkcztcbiAgICBmdW5jdGlvbiByZWxheW91dCgpIHtcbiAgICAgIHZhciBzdWJncm91cHMgPSB7fSwgZ3JvdXBTdW1zID0gW10sIGdyb3VwSW5kZXggPSBkMy5yYW5nZShuKSwgc3ViZ3JvdXBJbmRleCA9IFtdLCBrLCB4LCB4MCwgaSwgajtcbiAgICAgIGNob3JkcyA9IFtdO1xuICAgICAgZ3JvdXBzID0gW107XG4gICAgICBrID0gMCwgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgeCA9IDAsIGogPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB4ICs9IG1hdHJpeFtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgICBncm91cFN1bXMucHVzaCh4KTtcbiAgICAgICAgc3ViZ3JvdXBJbmRleC5wdXNoKGQzLnJhbmdlKG4pKTtcbiAgICAgICAgayArPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHNvcnRHcm91cHMpIHtcbiAgICAgICAgZ3JvdXBJbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gc29ydEdyb3Vwcyhncm91cFN1bXNbYV0sIGdyb3VwU3Vtc1tiXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNvcnRTdWJncm91cHMpIHtcbiAgICAgICAgc3ViZ3JvdXBJbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICBkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRTdWJncm91cHMobWF0cml4W2ldW2FdLCBtYXRyaXhbaV1bYl0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGsgPSAoz4QgLSBwYWRkaW5nICogbikgLyBrO1xuICAgICAgeCA9IDAsIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHgwID0geCwgaiA9IC0xO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHZhciBkaSA9IGdyb3VwSW5kZXhbaV0sIGRqID0gc3ViZ3JvdXBJbmRleFtkaV1bal0sIHYgPSBtYXRyaXhbZGldW2RqXSwgYTAgPSB4LCBhMSA9IHggKz0gdiAqIGs7XG4gICAgICAgICAgc3ViZ3JvdXBzW2RpICsgXCItXCIgKyBkal0gPSB7XG4gICAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgICBzdWJpbmRleDogZGosXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHNbZGldID0ge1xuICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiB4MCxcbiAgICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgICB2YWx1ZTogZ3JvdXBTdW1zW2RpXVxuICAgICAgICB9O1xuICAgICAgICB4ICs9IHBhZGRpbmc7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBqID0gaSAtIDE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tpICsgXCItXCIgKyBqXSwgdGFyZ2V0ID0gc3ViZ3JvdXBzW2ogKyBcIi1cIiArIGldO1xuICAgICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBjaG9yZHMucHVzaChzb3VyY2UudmFsdWUgPCB0YXJnZXQudmFsdWUgPyB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGFyZ2V0LFxuICAgICAgICAgICAgICB0YXJnZXQ6IHNvdXJjZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb3J0Q2hvcmRzKSByZXNvcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb3J0KCkge1xuICAgICAgY2hvcmRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydENob3JkcygoYS5zb3VyY2UudmFsdWUgKyBhLnRhcmdldC52YWx1ZSkgLyAyLCAoYi5zb3VyY2UudmFsdWUgKyBiLnRhcmdldC52YWx1ZSkgLyAyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaG9yZC5tYXRyaXggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXRyaXg7XG4gICAgICBuID0gKG1hdHJpeCA9IHgpICYmIG1hdHJpeC5sZW5ndGg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0geDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0R3JvdXBzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydEdyb3VwcztcbiAgICAgIHNvcnRHcm91cHMgPSB4O1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRTdWJncm91cHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0U3ViZ3JvdXBzO1xuICAgICAgc29ydFN1Ymdyb3VwcyA9IHg7XG4gICAgICBjaG9yZHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydENob3JkcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRDaG9yZHM7XG4gICAgICBzb3J0Q2hvcmRzID0geDtcbiAgICAgIGlmIChjaG9yZHMpIHJlc29ydCgpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuY2hvcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNob3JkcykgcmVsYXlvdXQoKTtcbiAgICAgIHJldHVybiBjaG9yZHM7XG4gICAgfTtcbiAgICBjaG9yZC5ncm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZ3JvdXBzKSByZWxheW91dCgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9O1xuICAgIHJldHVybiBjaG9yZDtcbiAgfTtcbiAgZDMubGF5b3V0LmZvcmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcmNlID0ge30sIGV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcInRpY2tcIiwgXCJlbmRcIiksIHRpbWVyLCBzaXplID0gWyAxLCAxIF0sIGRyYWcsIGFscGhhLCBmcmljdGlvbiA9IC45LCBsaW5rRGlzdGFuY2UgPSBkM19sYXlvdXRfZm9yY2VMaW5rRGlzdGFuY2UsIGxpbmtTdHJlbmd0aCA9IGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCwgY2hhcmdlID0gLTMwLCBjaGFyZ2VEaXN0YW5jZTIgPSBkM19sYXlvdXRfZm9yY2VDaGFyZ2VEaXN0YW5jZTIsIGdyYXZpdHkgPSAuMSwgdGhldGEyID0gLjY0LCBub2RlcyA9IFtdLCBsaW5rcyA9IFtdLCBkaXN0YW5jZXMsIHN0cmVuZ3RocywgY2hhcmdlcztcbiAgICBmdW5jdGlvbiByZXB1bHNlKG5vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihxdWFkLCB4MSwgXywgeDIpIHtcbiAgICAgICAgaWYgKHF1YWQucG9pbnQgIT09IG5vZGUpIHtcbiAgICAgICAgICB2YXIgZHggPSBxdWFkLmN4IC0gbm9kZS54LCBkeSA9IHF1YWQuY3kgLSBub2RlLnksIGR3ID0geDIgLSB4MSwgZG4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICBpZiAoZHcgKiBkdyAvIHRoZXRhMiA8IGRuKSB7XG4gICAgICAgICAgICBpZiAoZG4gPCBjaGFyZ2VEaXN0YW5jZTIpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBxdWFkLmNoYXJnZSAvIGRuO1xuICAgICAgICAgICAgICBub2RlLnB4IC09IGR4ICogaztcbiAgICAgICAgICAgICAgbm9kZS5weSAtPSBkeSAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHF1YWQucG9pbnQgJiYgZG4gJiYgZG4gPCBjaGFyZ2VEaXN0YW5jZTIpIHtcbiAgICAgICAgICAgIHZhciBrID0gcXVhZC5wb2ludENoYXJnZSAvIGRuO1xuICAgICAgICAgICAgbm9kZS5weCAtPSBkeCAqIGs7XG4gICAgICAgICAgICBub2RlLnB5IC09IGR5ICogaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFxdWFkLmNoYXJnZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZvcmNlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgoYWxwaGEgKj0gLjk5KSA8IC4wMDUpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBldmVudC5lbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgYWxwaGE6IGFscGhhID0gMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aCwgbSA9IGxpbmtzLmxlbmd0aCwgcSwgaSwgbywgcywgdCwgbCwgaywgeCwgeTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbyA9IGxpbmtzW2ldO1xuICAgICAgICBzID0gby5zb3VyY2U7XG4gICAgICAgIHQgPSBvLnRhcmdldDtcbiAgICAgICAgeCA9IHQueCAtIHMueDtcbiAgICAgICAgeSA9IHQueSAtIHMueTtcbiAgICAgICAgaWYgKGwgPSB4ICogeCArIHkgKiB5KSB7XG4gICAgICAgICAgbCA9IGFscGhhICogc3RyZW5ndGhzW2ldICogKChsID0gTWF0aC5zcXJ0KGwpKSAtIGRpc3RhbmNlc1tpXSkgLyBsO1xuICAgICAgICAgIHggKj0gbDtcbiAgICAgICAgICB5ICo9IGw7XG4gICAgICAgICAgdC54IC09IHggKiAoayA9IHMud2VpZ2h0ICsgdC53ZWlnaHQgPyBzLndlaWdodCAvIChzLndlaWdodCArIHQud2VpZ2h0KSA6IC41KTtcbiAgICAgICAgICB0LnkgLT0geSAqIGs7XG4gICAgICAgICAgcy54ICs9IHggKiAoayA9IDEgLSBrKTtcbiAgICAgICAgICBzLnkgKz0geSAqIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrID0gYWxwaGEgKiBncmF2aXR5KSB7XG4gICAgICAgIHggPSBzaXplWzBdIC8gMjtcbiAgICAgICAgeSA9IHNpemVbMV0gLyAyO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIGlmIChrKSB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgICBvLnggKz0gKHggLSBvLngpICogaztcbiAgICAgICAgICBvLnkgKz0gKHkgLSBvLnkpICogaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYXJnZSkge1xuICAgICAgICBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKHEgPSBkMy5nZW9tLnF1YWR0cmVlKG5vZGVzKSwgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKCEobyA9IG5vZGVzW2ldKS5maXhlZCkge1xuICAgICAgICAgICAgcS52aXNpdChyZXB1bHNlKG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG8uZml4ZWQpIHtcbiAgICAgICAgICBvLnggPSBvLnB4O1xuICAgICAgICAgIG8ueSA9IG8ucHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby54IC09IChvLnB4IC0gKG8ucHggPSBvLngpKSAqIGZyaWN0aW9uO1xuICAgICAgICAgIG8ueSAtPSAoby5weSAtIChvLnB5ID0gby55KSkgKiBmcmljdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudGljayh7XG4gICAgICAgIHR5cGU6IFwidGlja1wiLFxuICAgICAgICBhbHBoYTogYWxwaGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yY2Uubm9kZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcbiAgICAgIG5vZGVzID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgICBsaW5rcyA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UubGlua0Rpc3RhbmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua0Rpc3RhbmNlO1xuICAgICAgbGlua0Rpc3RhbmNlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmRpc3RhbmNlID0gZm9yY2UubGlua0Rpc3RhbmNlO1xuICAgIGZvcmNlLmxpbmtTdHJlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtTdHJlbmd0aDtcbiAgICAgIGxpbmtTdHJlbmd0aCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5mcmljdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyaWN0aW9uO1xuICAgICAgZnJpY3Rpb24gPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmNoYXJnZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJnZTtcbiAgICAgIGNoYXJnZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5jaGFyZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydChjaGFyZ2VEaXN0YW5jZTIpO1xuICAgICAgY2hhcmdlRGlzdGFuY2UyID0geCAqIHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5ncmF2aXR5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3Jhdml0eTtcbiAgICAgIGdyYXZpdHkgPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnRoZXRhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KHRoZXRhMik7XG4gICAgICB0aGV0YTIgPSB4ICogeDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmFscGhhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYWxwaGE7XG4gICAgICB4ID0gK3g7XG4gICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgYWxwaGEgPSB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVyLmMgPSBudWxsLCB0aW1lci50ID0gTmFOLCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgZXZlbnQuZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEgPSAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeCA+IDApIHtcbiAgICAgICAgZXZlbnQuc3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFwic3RhcnRcIixcbiAgICAgICAgICBhbHBoYTogYWxwaGEgPSB4XG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lciA9IGQzX3RpbWVyKGZvcmNlLnRpY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2Uuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBtID0gbGlua3MubGVuZ3RoLCB3ID0gc2l6ZVswXSwgaCA9IHNpemVbMV0sIG5laWdoYm9ycywgbztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgKG8gPSBub2Rlc1tpXSkuaW5kZXggPSBpO1xuICAgICAgICBvLndlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIG8gPSBsaW5rc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnNvdXJjZSA9PSBcIm51bWJlclwiKSBvLnNvdXJjZSA9IG5vZGVzW28uc291cmNlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnRhcmdldCA9PSBcIm51bWJlclwiKSBvLnRhcmdldCA9IG5vZGVzW28udGFyZ2V0XTtcbiAgICAgICAgKytvLnNvdXJjZS53ZWlnaHQ7XG4gICAgICAgICsrby50YXJnZXQud2VpZ2h0O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChpc05hTihvLngpKSBvLnggPSBwb3NpdGlvbihcInhcIiwgdyk7XG4gICAgICAgIGlmIChpc05hTihvLnkpKSBvLnkgPSBwb3NpdGlvbihcInlcIiwgaCk7XG4gICAgICAgIGlmIChpc05hTihvLnB4KSkgby5weCA9IG8ueDtcbiAgICAgICAgaWYgKGlzTmFOKG8ucHkpKSBvLnB5ID0gby55O1xuICAgICAgfVxuICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGxpbmtEaXN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBkaXN0YW5jZXNbaV0gPSArbGlua0Rpc3RhbmNlLmNhbGwodGhpcywgbGlua3NbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIGRpc3RhbmNlc1tpXSA9IGxpbmtEaXN0YW5jZTtcbiAgICAgIHN0cmVuZ3RocyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rU3RyZW5ndGggPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc3RyZW5ndGhzW2ldID0gK2xpbmtTdHJlbmd0aC5jYWxsKHRoaXMsIGxpbmtzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzdHJlbmd0aHNbaV0gPSBsaW5rU3RyZW5ndGg7XG4gICAgICBjaGFyZ2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGNoYXJnZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gK2NoYXJnZS5jYWxsKHRoaXMsIG5vZGVzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gY2hhcmdlO1xuICAgICAgZnVuY3Rpb24gcG9zaXRpb24oZGltZW5zaW9uLCBzaXplKSB7XG4gICAgICAgIGlmICghbmVpZ2hib3JzKSB7XG4gICAgICAgICAgbmVpZ2hib3JzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIG5laWdoYm9yc1tqXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGxpbmtzW2pdO1xuICAgICAgICAgICAgbmVpZ2hib3JzW28uc291cmNlLmluZGV4XS5wdXNoKG8udGFyZ2V0KTtcbiAgICAgICAgICAgIG5laWdoYm9yc1tvLnRhcmdldC5pbmRleF0ucHVzaChvLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gbmVpZ2hib3JzW2ldLCBqID0gLTEsIGwgPSBjYW5kaWRhdGVzLmxlbmd0aCwgeDtcbiAgICAgICAgd2hpbGUgKCsraiA8IGwpIGlmICghaXNOYU4oeCA9IGNhbmRpZGF0ZXNbal1bZGltZW5zaW9uXSkpIHJldHVybiB4O1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yY2UucmVzdW1lKCk7XG4gICAgfTtcbiAgICBmb3JjZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JjZS5hbHBoYSguMSk7XG4gICAgfTtcbiAgICBmb3JjZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9yY2UuYWxwaGEoMCk7XG4gICAgfTtcbiAgICBmb3JjZS5kcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWRyYWcpIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCkub3JpZ2luKGQzX2lkZW50aXR5KS5vbihcImRyYWdzdGFydC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQpLm9uKFwiZHJhZy5mb3JjZVwiLCBkcmFnbW92ZSkub24oXCJkcmFnZW5kLmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZURyYWdlbmQpO1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHJhZztcbiAgICAgIHRoaXMub24oXCJtb3VzZW92ZXIuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlTW91c2VvdmVyKS5vbihcIm1vdXNlb3V0LmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZU1vdXNlb3V0KS5jYWxsKGRyYWcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZHJhZ21vdmUoZCkge1xuICAgICAgZC5weCA9IGQzLmV2ZW50LngsIGQucHkgPSBkMy5ldmVudC55O1xuICAgICAgZm9yY2UucmVzdW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoZm9yY2UsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQoZCkge1xuICAgIGQuZml4ZWQgfD0gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnZW5kKGQpIHtcbiAgICBkLmZpeGVkICY9IH42O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZU1vdXNlb3ZlcihkKSB7XG4gICAgZC5maXhlZCB8PSA0O1xuICAgIGQucHggPSBkLngsIGQucHkgPSBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlTW91c2VvdXQoZCkge1xuICAgIGQuZml4ZWQgJj0gfjQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShxdWFkLCBhbHBoYSwgY2hhcmdlcykge1xuICAgIHZhciBjeCA9IDAsIGN5ID0gMDtcbiAgICBxdWFkLmNoYXJnZSA9IDA7XG4gICAgaWYgKCFxdWFkLmxlYWYpIHtcbiAgICAgIHZhciBub2RlcyA9IHF1YWQubm9kZXMsIG4gPSBub2Rlcy5sZW5ndGgsIGkgPSAtMSwgYztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGMgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUoYywgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBxdWFkLmNoYXJnZSArPSBjLmNoYXJnZTtcbiAgICAgICAgY3ggKz0gYy5jaGFyZ2UgKiBjLmN4O1xuICAgICAgICBjeSArPSBjLmNoYXJnZSAqIGMuY3k7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWFkLnBvaW50KSB7XG4gICAgICBpZiAoIXF1YWQubGVhZikge1xuICAgICAgICBxdWFkLnBvaW50LnggKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgICBxdWFkLnBvaW50LnkgKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBhbHBoYSAqIGNoYXJnZXNbcXVhZC5wb2ludC5pbmRleF07XG4gICAgICBxdWFkLmNoYXJnZSArPSBxdWFkLnBvaW50Q2hhcmdlID0gaztcbiAgICAgIGN4ICs9IGsgKiBxdWFkLnBvaW50Lng7XG4gICAgICBjeSArPSBrICogcXVhZC5wb2ludC55O1xuICAgIH1cbiAgICBxdWFkLmN4ID0gY3ggLyBxdWFkLmNoYXJnZTtcbiAgICBxdWFkLmN5ID0gY3kgLyBxdWFkLmNoYXJnZTtcbiAgfVxuICB2YXIgZDNfbGF5b3V0X2ZvcmNlTGlua0Rpc3RhbmNlID0gMjAsIGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCA9IDEsIGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiA9IEluZmluaXR5O1xuICBkMy5sYXlvdXQuaGllcmFyY2h5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvcnQgPSBkM19sYXlvdXRfaGllcmFyY2h5U29ydCwgY2hpbGRyZW4gPSBkM19sYXlvdXRfaGllcmFyY2h5Q2hpbGRyZW4sIHZhbHVlID0gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlO1xuICAgIGZ1bmN0aW9uIGhpZXJhcmNoeShyb290KSB7XG4gICAgICB2YXIgc3RhY2sgPSBbIHJvb3QgXSwgbm9kZXMgPSBbXSwgbm9kZTtcbiAgICAgIHJvb3QuZGVwdGggPSAwO1xuICAgICAgd2hpbGUgKChub2RlID0gc3RhY2sucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKChjaGlsZHMgPSBjaGlsZHJlbi5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgbiwgY2hpbGRzLCBjaGlsZDtcbiAgICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQgPSBjaGlsZHNbbl0pO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUpIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcywgcGFyZW50O1xuICAgICAgICBpZiAoc29ydCAmJiAoY2hpbGRzID0gbm9kZS5jaGlsZHJlbikpIGNoaWxkcy5zb3J0KHNvcnQpO1xuICAgICAgICBpZiAodmFsdWUgJiYgKHBhcmVudCA9IG5vZGUucGFyZW50KSkgcGFyZW50LnZhbHVlICs9IG5vZGUudmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgaGllcmFyY2h5LnNvcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0O1xuICAgICAgc29ydCA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LmNoaWxkcmVuID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnJldmFsdWUgPSBmdW5jdGlvbihyb290KSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgaWYgKHBhcmVudCA9IG5vZGUucGFyZW50KSBwYXJlbnQudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIHJldHVybiBoaWVyYXJjaHk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQob2JqZWN0LCBoaWVyYXJjaHkpIHtcbiAgICBkMy5yZWJpbmQob2JqZWN0LCBoaWVyYXJjaHksIFwic29ydFwiLCBcImNoaWxkcmVuXCIsIFwidmFsdWVcIik7XG4gICAgb2JqZWN0Lm5vZGVzID0gb2JqZWN0O1xuICAgIG9iamVjdC5saW5rcyA9IGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcztcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdO1xuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIGlmICgoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIG5vZGVzLnB1c2goY2hpbGRyZW5bbl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdLCBub2RlczIgPSBbXTtcbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgbm9kZXMyLnB1c2gobm9kZSk7XG4gICAgICBpZiAoKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzMi5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlDaGlsZHJlbihkKSB7XG4gICAgcmV0dXJuIGQuY2hpbGRyZW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlKGQpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcyhub2Rlcykge1xuICAgIHJldHVybiBkMy5tZXJnZShub2Rlcy5tYXAoZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gKHBhcmVudC5jaGlsZHJlbiB8fCBbXSkubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBwYXJlbnQsXG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG4gIGQzLmxheW91dC5wYXJ0aXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLCBzaXplID0gWyAxLCAxIF07XG4gICAgZnVuY3Rpb24gcG9zaXRpb24obm9kZSwgeCwgZHgsIGR5KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS54ID0geDtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgICAgIG5vZGUuZHggPSBkeDtcbiAgICAgIG5vZGUuZHkgPSBkeTtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiwgYywgZDtcbiAgICAgICAgZHggPSBub2RlLnZhbHVlID8gZHggLyBub2RlLnZhbHVlIDogMDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBwb3NpdGlvbihjID0gY2hpbGRyZW5baV0sIHgsIGQgPSBjLnZhbHVlICogZHgsIGR5KTtcbiAgICAgICAgICB4ICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVwdGgobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgZCA9IDA7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG47XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBkID0gTWF0aC5tYXgoZCwgZGVwdGgoY2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxICsgZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgcG9zaXRpb24obm9kZXNbMF0sIDAsIHNpemVbMF0sIHNpemVbMV0gLyBkZXB0aChub2Rlc1swXSkpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiBwYXJ0aXRpb247XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChwYXJ0aXRpb24sIGhpZXJhcmNoeSk7XG4gIH07XG4gIGQzLmxheW91dC5waWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBOdW1iZXIsIHNvcnQgPSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUsIHN0YXJ0QW5nbGUgPSAwLCBlbmRBbmdsZSA9IM+ELCBwYWRBbmdsZSA9IDA7XG4gICAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIHZhbHVlcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICt2YWx1ZS5jYWxsKHBpZSwgZCwgaSk7XG4gICAgICB9KSwgYSA9ICsodHlwZW9mIHN0YXJ0QW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHN0YXJ0QW5nbGUpLCBkYSA9ICh0eXBlb2YgZW5kQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBlbmRBbmdsZSkgLSBhLCBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgKyh0eXBlb2YgcGFkQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwYWRBbmdsZSkpLCBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSwgc3VtID0gZDMuc3VtKHZhbHVlcyksIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMCwgaW5kZXggPSBkMy5yYW5nZShuKSwgYXJjcyA9IFtdLCB2O1xuICAgICAgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChzb3J0ID09PSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPyBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbal0gLSB2YWx1ZXNbaV07XG4gICAgICB9IDogZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTtcbiAgICAgIH0pO1xuICAgICAgaW5kZXguZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGFyY3NbaV0gPSB7XG4gICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICB2YWx1ZTogdiA9IHZhbHVlc1tpXSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBhLFxuICAgICAgICAgIGVuZEFuZ2xlOiBhICs9IHYgKiBrICsgcGEsXG4gICAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfVxuICAgIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydDtcbiAgICAgIHNvcnQgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHJldHVybiBwaWU7XG4gIH07XG4gIHZhciBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPSB7fTtcbiAgZDMubGF5b3V0LnN0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IGQzX2lkZW50aXR5LCBvcmRlciA9IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdCwgb2Zmc2V0ID0gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybywgb3V0ID0gZDNfbGF5b3V0X3N0YWNrT3V0LCB4ID0gZDNfbGF5b3V0X3N0YWNrWCwgeSA9IGQzX2xheW91dF9zdGFja1k7XG4gICAgZnVuY3Rpb24gc3RhY2soZGF0YSwgaW5kZXgpIHtcbiAgICAgIGlmICghKG4gPSBkYXRhLmxlbmd0aCkpIHJldHVybiBkYXRhO1xuICAgICAgdmFyIHNlcmllcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5jYWxsKHN0YWNrLCBkLCBpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50cyA9IHNlcmllcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgIHJldHVybiBbIHguY2FsbChzdGFjaywgdiwgaSksIHkuY2FsbChzdGFjaywgdiwgaSkgXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvcmRlcnMgPSBvcmRlci5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHNlcmllcyA9IGQzLnBlcm11dGUoc2VyaWVzLCBvcmRlcnMpO1xuICAgICAgcG9pbnRzID0gZDMucGVybXV0ZShwb2ludHMsIG9yZGVycyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG9mZnNldC5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHZhciBtID0gc2VyaWVzWzBdLmxlbmd0aCwgbiwgaSwgaiwgbztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgb3V0LmNhbGwoc3RhY2ssIHNlcmllc1swXVtqXSwgbyA9IG9mZnNldHNbal0sIHBvaW50c1swXVtqXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBvdXQuY2FsbChzdGFjaywgc2VyaWVzW2ldW2pdLCBvICs9IHBvaW50c1tpIC0gMV1bal1bMV0sIHBvaW50c1tpXVtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBzdGFjay52YWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXM7XG4gICAgICB2YWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmRlcjtcbiAgICAgIG9yZGVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBkM19sYXlvdXRfc3RhY2tPcmRlcnMuZ2V0KHgpIHx8IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdDtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9mZnNldDtcbiAgICAgIG9mZnNldCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cy5nZXQoeCkgfHwgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybztcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3V0ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0O1xuICAgICAgb3V0ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrWChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja091dChkLCB5MCwgeSkge1xuICAgIGQueTAgPSB5MDtcbiAgICBkLnkgPSB5O1xuICB9XG4gIHZhciBkM19sYXlvdXRfc3RhY2tPcmRlcnMgPSBkMy5tYXAoe1xuICAgIFwiaW5zaWRlLW91dFwiOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBpLCBqLCBtYXggPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tNYXhJbmRleCksIHN1bXMgPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0pLCBpbmRleCA9IGQzLnJhbmdlKG4pLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gbWF4W2FdIC0gbWF4W2JdO1xuICAgICAgfSksIHRvcCA9IDAsIGJvdHRvbSA9IDAsIHRvcHMgPSBbXSwgYm90dG9tcyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBqID0gaW5kZXhbaV07XG4gICAgICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgICAgICB0b3BzLnB1c2goaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRhdGEubGVuZ3RoKS5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0XG4gIH0pO1xuICB2YXIgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cyA9IGQzLm1hcCh7XG4gICAgc2lsaG91ZXR0ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBzdW1zID0gW10sIG1heCA9IDAsIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvID4gbWF4KSBtYXggPSBvO1xuICAgICAgICBzdW1zLnB1c2gobyk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHkwW2pdID0gKG1heCAtIHN1bXNbal0pIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIHdpZ2dsZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgeCA9IGRhdGFbMF0sIG0gPSB4Lmxlbmd0aCwgaSwgaiwgaywgczEsIHMyLCBzMywgZHgsIG8sIG8wLCB5MCA9IFtdO1xuICAgICAgeTBbMF0gPSBvID0gbzAgPSAwO1xuICAgICAgZm9yIChqID0gMTsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBzMSA9IDA7IGkgPCBuOyArK2kpIHMxICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGZvciAoaSA9IDAsIHMyID0gMCwgZHggPSB4W2pdWzBdIC0geFtqIC0gMV1bMF07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKGsgPSAwLCBzMyA9IChkYXRhW2ldW2pdWzFdIC0gZGF0YVtpXVtqIC0gMV1bMV0pIC8gKDIgKiBkeCk7IGsgPCBpOyArK2spIHtcbiAgICAgICAgICAgIHMzICs9IChkYXRhW2tdW2pdWzFdIC0gZGF0YVtrXVtqIC0gMV1bMV0pIC8gZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMyICs9IHMzICogZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5MFtqXSA9IG8gLT0gczEgPyBzMiAvIHMxICogZHggOiAwO1xuICAgICAgICBpZiAobyA8IG8wKSBvMCA9IG87XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSAtPSBvMDtcbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBrID0gMSAvIG4sIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvKSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkYXRhW2ldW2pdWzFdIC89IG87IGVsc2UgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZGF0YVtpXVtqXVsxXSA9IGs7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSA9IDA7XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICB6ZXJvOiBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvXG4gIH0pO1xuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQoZGF0YSkge1xuICAgIHJldHVybiBkMy5yYW5nZShkYXRhLmxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybyhkYXRhKSB7XG4gICAgdmFyIGogPSAtMSwgbSA9IGRhdGFbMF0ubGVuZ3RoLCB5MCA9IFtdO1xuICAgIHdoaWxlICgrK2ogPCBtKSB5MFtqXSA9IDA7XG4gICAgcmV0dXJuIHkwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja01heEluZGV4KGFycmF5KSB7XG4gICAgdmFyIGkgPSAxLCBqID0gMCwgdiA9IGFycmF5WzBdWzFdLCBrLCBuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoayA9IGFycmF5W2ldWzFdKSA+IHYpIHtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIHYgPSBrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gajtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0oZCkge1xuICAgIHJldHVybiBkLnJlZHVjZShkM19sYXlvdXRfc3RhY2tTdW0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1N1bShwLCBkKSB7XG4gICAgcmV0dXJuIHAgKyBkWzFdO1xuICB9XG4gIGQzLmxheW91dC5oaXN0b2dyYW0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJlcXVlbmN5ID0gdHJ1ZSwgdmFsdWVyID0gTnVtYmVyLCByYW5nZXIgPSBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UsIGJpbm5lciA9IGQzX2xheW91dF9oaXN0b2dyYW1CaW5TdHVyZ2VzO1xuICAgIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhLCBpKSB7XG4gICAgICB2YXIgYmlucyA9IFtdLCB2YWx1ZXMgPSBkYXRhLm1hcCh2YWx1ZXIsIHRoaXMpLCByYW5nZSA9IHJhbmdlci5jYWxsKHRoaXMsIHZhbHVlcywgaSksIHRocmVzaG9sZHMgPSBiaW5uZXIuY2FsbCh0aGlzLCByYW5nZSwgdmFsdWVzLCBpKSwgYmluLCBpID0gLTEsIG4gPSB2YWx1ZXMubGVuZ3RoLCBtID0gdGhyZXNob2xkcy5sZW5ndGggLSAxLCBrID0gZnJlcXVlbmN5ID8gMSA6IDEgLyBuLCB4O1xuICAgICAgd2hpbGUgKCsraSA8IG0pIHtcbiAgICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgICBiaW4uZHggPSB0aHJlc2hvbGRzW2kgKyAxXSAtIChiaW4ueCA9IHRocmVzaG9sZHNbaV0pO1xuICAgICAgICBiaW4ueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICAgICAgaWYgKHggPj0gcmFuZ2VbMF0gJiYgeCA8PSByYW5nZVsxXSkge1xuICAgICAgICAgICAgYmluID0gYmluc1tkMy5iaXNlY3QodGhyZXNob2xkcywgeCwgMSwgbSkgLSAxXTtcbiAgICAgICAgICAgIGJpbi55ICs9IGs7XG4gICAgICAgICAgICBiaW4ucHVzaChkYXRhW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5zO1xuICAgIH1cbiAgICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXI7XG4gICAgICB2YWx1ZXIgPSB4O1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlcjtcbiAgICAgIHJhbmdlciA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmJpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiaW5uZXI7XG4gICAgICBiaW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIHgpO1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmZyZXF1ZW5jeSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyZXF1ZW5jeTtcbiAgICAgIGZyZXF1ZW5jeSA9ICEheDtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtQmluU3R1cmdlcyhyYW5nZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIgKyAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCBuKSB7XG4gICAgdmFyIHggPSAtMSwgYiA9ICtyYW5nZVswXSwgbSA9IChyYW5nZVsxXSAtIGIpIC8gbiwgZiA9IFtdO1xuICAgIHdoaWxlICgrK3ggPD0gbikgZlt4XSA9IG0gKiB4ICsgYjtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UodmFsdWVzKSB7XG4gICAgcmV0dXJuIFsgZDMubWluKHZhbHVlcyksIGQzLm1heCh2YWx1ZXMpIF07XG4gIH1cbiAgZDMubGF5b3V0LnBhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQoZDNfbGF5b3V0X3BhY2tTb3J0KSwgcGFkZGluZyA9IDAsIHNpemUgPSBbIDEsIDEgXSwgcmFkaXVzO1xuICAgIGZ1bmN0aW9uIHBhY2soZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QgPSBub2Rlc1swXSwgdyA9IHNpemVbMF0sIGggPSBzaXplWzFdLCByID0gcmFkaXVzID09IG51bGwgPyBNYXRoLnNxcnQgOiB0eXBlb2YgcmFkaXVzID09PSBcImZ1bmN0aW9uXCIgPyByYWRpdXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICAgIH07XG4gICAgICByb290LnggPSByb290LnkgPSAwO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICBkLnIgPSArcihkLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyk7XG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICB2YXIgZHIgPSBwYWRkaW5nICogKHJhZGl1cyA/IDEgOiBNYXRoLm1heCgyICogcm9vdC5yIC8gdywgMiAqIHJvb3QuciAvIGgpKSAvIDI7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkLnIgKz0gZHI7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBkM19sYXlvdXRfcGFja1NpYmxpbmdzKTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGQuciAtPSBkcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShyb290LCB3IC8gMiwgaCAvIDIsIHJhZGl1cyA/IDEgOiAxIC8gTWF0aC5tYXgoMiAqIHJvb3QuciAvIHcsIDIgKiByb290LnIgLyBoKSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpdXM7XG4gICAgICByYWRpdXMgPSBfID09IG51bGwgfHwgdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIHBhZGRpbmcgPSArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQocGFjaywgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYikge1xuICAgIHZhciBjID0gYS5fcGFja19uZXh0O1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgICBiLl9wYWNrX25leHQgPSBjO1xuICAgIGMuX3BhY2tfcHJldiA9IGI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYikge1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoYSwgYikge1xuICAgIHZhciBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnksIGRyID0gYS5yICsgYi5yO1xuICAgIHJldHVybiAuOTk5ICogZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU2libGluZ3Mobm9kZSkge1xuICAgIGlmICghKG5vZGVzID0gbm9kZS5jaGlsZHJlbikgfHwgIShuID0gbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBub2RlcywgeE1pbiA9IEluZmluaXR5LCB4TWF4ID0gLUluZmluaXR5LCB5TWluID0gSW5maW5pdHksIHlNYXggPSAtSW5maW5pdHksIGEsIGIsIGMsIGksIGosIGssIG47XG4gICAgZnVuY3Rpb24gYm91bmQobm9kZSkge1xuICAgICAgeE1pbiA9IE1hdGgubWluKG5vZGUueCAtIG5vZGUuciwgeE1pbik7XG4gICAgICB4TWF4ID0gTWF0aC5tYXgobm9kZS54ICsgbm9kZS5yLCB4TWF4KTtcbiAgICAgIHlNaW4gPSBNYXRoLm1pbihub2RlLnkgLSBub2RlLnIsIHlNaW4pO1xuICAgICAgeU1heCA9IE1hdGgubWF4KG5vZGUueSArIG5vZGUuciwgeU1heCk7XG4gICAgfVxuICAgIG5vZGVzLmZvckVhY2goZDNfbGF5b3V0X3BhY2tMaW5rKTtcbiAgICBhID0gbm9kZXNbMF07XG4gICAgYS54ID0gLWEucjtcbiAgICBhLnkgPSAwO1xuICAgIGJvdW5kKGEpO1xuICAgIGlmIChuID4gMSkge1xuICAgICAgYiA9IG5vZGVzWzFdO1xuICAgICAgYi54ID0gYi5yO1xuICAgICAgYi55ID0gMDtcbiAgICAgIGJvdW5kKGIpO1xuICAgICAgaWYgKG4gPiAyKSB7XG4gICAgICAgIGMgPSBub2Rlc1syXTtcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjKTtcbiAgICAgICAgYm91bmQoYyk7XG4gICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGMpO1xuICAgICAgICBhLl9wYWNrX3ByZXYgPSBjO1xuICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChjLCBiKTtcbiAgICAgICAgYiA9IGEuX3BhY2tfbmV4dDtcbiAgICAgICAgZm9yIChpID0gMzsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYyA9IG5vZGVzW2ldKTtcbiAgICAgICAgICB2YXIgaXNlY3QgPSAwLCBzMSA9IDEsIHMyID0gMTtcbiAgICAgICAgICBmb3IgKGogPSBiLl9wYWNrX25leHQ7IGogIT09IGI7IGogPSBqLl9wYWNrX25leHQsIHMxKyspIHtcbiAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaiwgYykpIHtcbiAgICAgICAgICAgICAgaXNlY3QgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzZWN0ID09IDEpIHtcbiAgICAgICAgICAgIGZvciAoayA9IGEuX3BhY2tfcHJldjsgayAhPT0gai5fcGFja19wcmV2OyBrID0gay5fcGFja19wcmV2LCBzMisrKSB7XG4gICAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaywgYykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNlY3QpIHtcbiAgICAgICAgICAgIGlmIChzMSA8IHMyIHx8IHMxID09IHMyICYmIGIuciA8IGEucikgZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYiA9IGopOyBlbHNlIGQzX2xheW91dF9wYWNrU3BsaWNlKGEgPSBrLCBiKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYyk7XG4gICAgICAgICAgICBiID0gYztcbiAgICAgICAgICAgIGJvdW5kKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY3ggPSAoeE1pbiArIHhNYXgpIC8gMiwgY3kgPSAoeU1pbiArIHlNYXgpIC8gMiwgY3IgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgIGMueCAtPSBjeDtcbiAgICAgIGMueSAtPSBjeTtcbiAgICAgIGNyID0gTWF0aC5tYXgoY3IsIGMuciArIE1hdGguc3FydChjLnggKiBjLnggKyBjLnkgKiBjLnkpKTtcbiAgICB9XG4gICAgbm9kZS5yID0gY3I7XG4gICAgbm9kZXMuZm9yRWFjaChkM19sYXlvdXRfcGFja1VubGluayk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tMaW5rKG5vZGUpIHtcbiAgICBub2RlLl9wYWNrX25leHQgPSBub2RlLl9wYWNrX3ByZXYgPSBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrVW5saW5rKG5vZGUpIHtcbiAgICBkZWxldGUgbm9kZS5fcGFja19uZXh0O1xuICAgIGRlbGV0ZSBub2RlLl9wYWNrX3ByZXY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0obm9kZSwgeCwgeSwgaykge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgbm9kZS54ID0geCArPSBrICogbm9kZS54O1xuICAgIG5vZGUueSA9IHkgKz0gayAqIG5vZGUueTtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0oY2hpbGRyZW5baV0sIHgsIHksIGspO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMpIHtcbiAgICB2YXIgZGIgPSBhLnIgKyBjLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICBpZiAoZGIgJiYgKGR4IHx8IGR5KSkge1xuICAgICAgdmFyIGRhID0gYi5yICsgYy5yLCBkYyA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgZGEgKj0gZGE7XG4gICAgICBkYiAqPSBkYjtcbiAgICAgIHZhciB4ID0gLjUgKyAoZGIgLSBkYSkgLyAoMiAqIGRjKSwgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCAyICogZGEgKiAoZGIgKyBkYykgLSAoZGIgLT0gZGMpICogZGIgLSBkYSAqIGRhKSkgLyAoMiAqIGRjKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCArIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSAtIHkgKiBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgYy54ID0gYS54ICsgZGI7XG4gICAgICBjLnkgPSBhLnk7XG4gICAgfVxuICB9XG4gIGQzLmxheW91dC50cmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KG51bGwpLnZhbHVlKG51bGwpLCBzZXBhcmF0aW9uID0gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uLCBzaXplID0gWyAxLCAxIF0sIG5vZGVTaXplID0gbnVsbDtcbiAgICBmdW5jdGlvbiB0cmVlKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290MCA9IG5vZGVzWzBdLCByb290MSA9IHdyYXBUcmVlKHJvb3QwKTtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QxLCBmaXJzdFdhbGspLCByb290MS5wYXJlbnQubSA9IC1yb290MS56O1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QxLCBzZWNvbmRXYWxrKTtcbiAgICAgIGlmIChub2RlU2l6ZSkgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBzaXplTm9kZSk7IGVsc2Uge1xuICAgICAgICB2YXIgbGVmdCA9IHJvb3QwLCByaWdodCA9IHJvb3QwLCBib3R0b20gPSByb290MDtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgICBpZiAobm9kZS5kZXB0aCA+IGJvdHRvbS5kZXB0aCkgYm90dG9tID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0eCA9IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiAtIGxlZnQueCwga3ggPSBzaXplWzBdIC8gKHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDIgKyB0eCksIGt5ID0gc2l6ZVsxXSAvIChib3R0b20uZGVwdGggfHwgMSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cmFwVHJlZShyb290MCkge1xuICAgICAgdmFyIHJvb3QxID0ge1xuICAgICAgICBBOiBudWxsLFxuICAgICAgICBjaGlsZHJlbjogWyByb290MCBdXG4gICAgICB9LCBxdWV1ZSA9IFsgcm9vdDEgXSwgbm9kZTE7XG4gICAgICB3aGlsZSAoKG5vZGUxID0gcXVldWUucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBub2RlMS5jaGlsZHJlbiwgY2hpbGQsIGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgcXVldWUucHVzaCgoY2hpbGRyZW5baV0gPSBjaGlsZCA9IHtcbiAgICAgICAgICAgIF86IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgcGFyZW50OiBub2RlMSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoY2hpbGQgPSBjaGlsZHJlbltpXS5jaGlsZHJlbikgJiYgY2hpbGQuc2xpY2UoKSB8fCBbXSxcbiAgICAgICAgICAgIEE6IG51bGwsXG4gICAgICAgICAgICBhOiBudWxsLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIG06IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICBpOiBpXG4gICAgICAgICAgfSkuYSA9IGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3QxLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbiwgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgZDNfbGF5b3V0X3RyZWVTaGlmdCh2KTtcbiAgICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgIH1cbiAgICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgICAgdi5tICs9IHYucGFyZW50Lm07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdmFyIHZpcCA9IHYsIHZvcCA9IHYsIHZpbSA9IHcsIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sIHNpcCA9IHZpcC5tLCBzb3AgPSB2b3AubSwgc2ltID0gdmltLm0sIHNvbSA9IHZvbS5tLCBzaGlmdDtcbiAgICAgICAgd2hpbGUgKHZpbSA9IGQzX2xheW91dF90cmVlUmlnaHQodmltKSwgdmlwID0gZDNfbGF5b3V0X3RyZWVMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgICB2b20gPSBkM19sYXlvdXRfdHJlZUxlZnQodm9tKTtcbiAgICAgICAgICB2b3AgPSBkM19sYXlvdXRfdHJlZVJpZ2h0KHZvcCk7XG4gICAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgICBkM19sYXlvdXRfdHJlZU1vdmUoZDNfbGF5b3V0X3RyZWVBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbSAmJiAhZDNfbGF5b3V0X3RyZWVSaWdodCh2b3ApKSB7XG4gICAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgICAgdm9wLm0gKz0gc2ltIC0gc29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXAgJiYgIWQzX2xheW91dF90cmVlTGVmdCh2b20pKSB7XG4gICAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgICBub2RlLnggKj0gc2l6ZVswXTtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBzaXplWzFdO1xuICAgIH1cbiAgICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZXBhcmF0aW9uO1xuICAgICAgc2VwYXJhdGlvbiA9IHg7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gbnVsbCA6IHNpemU7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IHNpemVOb2RlIDogbnVsbDtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gc2l6ZSA6IG51bGw7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IG51bGwgOiBzaXplTm9kZTtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQodHJlZSwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wYXJlbnQgPT0gYi5wYXJlbnQgPyAxIDogMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUxlZnQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdIDogdi50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlUmlnaHQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIG47XG4gICAgcmV0dXJuIChuID0gY2hpbGRyZW4ubGVuZ3RoKSA/IGNoaWxkcmVuW24gLSAxXSA6IHYudDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZU1vdmUod20sIHdwLCBzaGlmdCkge1xuICAgIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gICAgd3AuYyAtPSBjaGFuZ2U7XG4gICAgd3AucyArPSBzaGlmdDtcbiAgICB3bS5jICs9IGNoYW5nZTtcbiAgICB3cC56ICs9IHNoaWZ0O1xuICAgIHdwLm0gKz0gc2hpZnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTaGlmdCh2KSB7XG4gICAgdmFyIHNoaWZ0ID0gMCwgY2hhbmdlID0gMCwgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBpID0gY2hpbGRyZW4ubGVuZ3RoLCB3O1xuICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgdy56ICs9IHNoaWZ0O1xuICAgICAgdy5tICs9IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgICByZXR1cm4gdmltLmEucGFyZW50ID09PSB2LnBhcmVudCA/IHZpbS5hIDogYW5jZXN0b3I7XG4gIH1cbiAgZDMubGF5b3V0LmNsdXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQobnVsbCkudmFsdWUobnVsbCksIHNlcGFyYXRpb24gPSBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24sIHNpemUgPSBbIDEsIDEgXSwgbm9kZVNpemUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjbHVzdGVyKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290ID0gbm9kZXNbMF0sIHByZXZpb3VzTm9kZSwgeCA9IDA7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLnggPSBkM19sYXlvdXRfY2x1c3RlclgoY2hpbGRyZW4pO1xuICAgICAgICAgIG5vZGUueSA9IGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbGVmdCA9IGQzX2xheW91dF9jbHVzdGVyTGVmdChyb290KSwgcmlnaHQgPSBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KHJvb3QpLCB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiwgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgbm9kZVNpemUgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogc2l6ZVswXTtcbiAgICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBzaXplWzFdO1xuICAgICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIHNpemVbMF07XG4gICAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIHNpemVbMV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VwYXJhdGlvbjtcbiAgICAgIHNlcGFyYXRpb24gPSB4O1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IG51bGwgOiBzaXplO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IHNpemUgOiBudWxsO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpICE9IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKGNsdXN0ZXIsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbikge1xuICAgIHJldHVybiAxICsgZDMubWF4KGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJYKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbih4LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHggKyBjaGlsZC54O1xuICAgIH0sIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyTGVmdChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID8gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KGNoaWxkcmVuWzBdKSA6IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpID8gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChjaGlsZHJlbltuIC0gMV0pIDogbm9kZTtcbiAgfVxuICBkMy5sYXlvdXQudHJlZW1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCksIHJvdW5kID0gTWF0aC5yb3VuZCwgc2l6ZSA9IFsgMSwgMSBdLCBwYWRkaW5nID0gbnVsbCwgcGFkID0gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsLCBzdGlja3kgPSBmYWxzZSwgc3RpY2tpZXMsIG1vZGUgPSBcInNxdWFyaWZ5XCIsIHJhdGlvID0gLjUgKiAoMSArIE1hdGguc3FydCg1KSk7XG4gICAgZnVuY3Rpb24gc2NhbGUoY2hpbGRyZW4sIGspIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGgsIGNoaWxkLCBhcmVhO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYXJlYSA9IChjaGlsZCA9IGNoaWxkcmVuW2ldKS52YWx1ZSAqIChrIDwgMCA/IDAgOiBrKTtcbiAgICAgICAgY2hpbGQuYXJlYSA9IGlzTmFOKGFyZWEpIHx8IGFyZWEgPD0gMCA/IDAgOiBhcmVhO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzcXVhcmlmeShub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHBhZChub2RlKSwgcm93ID0gW10sIHJlbWFpbmluZyA9IGNoaWxkcmVuLnNsaWNlKCksIGNoaWxkLCBiZXN0ID0gSW5maW5pdHksIHNjb3JlLCB1ID0gbW9kZSA9PT0gXCJzbGljZVwiID8gcmVjdC5keCA6IG1vZGUgPT09IFwiZGljZVwiID8gcmVjdC5keSA6IG1vZGUgPT09IFwic2xpY2UtZGljZVwiID8gbm9kZS5kZXB0aCAmIDEgPyByZWN0LmR5IDogcmVjdC5keCA6IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpLCBuO1xuICAgICAgICBzY2FsZShyZW1haW5pbmcsIHJlY3QuZHggKiByZWN0LmR5IC8gbm9kZS52YWx1ZSk7XG4gICAgICAgIHJvdy5hcmVhID0gMDtcbiAgICAgICAgd2hpbGUgKChuID0gcmVtYWluaW5nLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgcm93LnB1c2goY2hpbGQgPSByZW1haW5pbmdbbiAtIDFdKTtcbiAgICAgICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xuICAgICAgICAgIGlmIChtb2RlICE9PSBcInNxdWFyaWZ5XCIgfHwgKHNjb3JlID0gd29yc3Qocm93LCB1KSkgPD0gYmVzdCkge1xuICAgICAgICAgICAgcmVtYWluaW5nLnBvcCgpO1xuICAgICAgICAgICAgYmVzdCA9IHNjb3JlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3cuYXJlYSAtPSByb3cucG9wKCkuYXJlYTtcbiAgICAgICAgICAgIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgdSA9IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICAgIGJlc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgICAgICBwb3NpdGlvbihyb3csIHUsIHJlY3QsIHRydWUpO1xuICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzcXVhcmlmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0aWNraWZ5KG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gcGFkKG5vZGUpLCByZW1haW5pbmcgPSBjaGlsZHJlbi5zbGljZSgpLCBjaGlsZCwgcm93ID0gW107XG4gICAgICAgIHNjYWxlKHJlbWFpbmluZywgcmVjdC5keCAqIHJlY3QuZHkgLyBub2RlLnZhbHVlKTtcbiAgICAgICAgcm93LmFyZWEgPSAwO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSByZW1haW5pbmcucG9wKCkpIHtcbiAgICAgICAgICByb3cucHVzaChjaGlsZCk7XG4gICAgICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgICAgICBpZiAoY2hpbGQueiAhPSBudWxsKSB7XG4gICAgICAgICAgICBwb3NpdGlvbihyb3csIGNoaWxkLnogPyByZWN0LmR4IDogcmVjdC5keSwgcmVjdCwgIXJlbWFpbmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzdGlja2lmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcnN0KHJvdywgdSkge1xuICAgICAgdmFyIHMgPSByb3cuYXJlYSwgciwgcm1heCA9IDAsIHJtaW4gPSBJbmZpbml0eSwgaSA9IC0xLCBuID0gcm93Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICghKHIgPSByb3dbaV0uYXJlYSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAociA8IHJtaW4pIHJtaW4gPSByO1xuICAgICAgICBpZiAociA+IHJtYXgpIHJtYXggPSByO1xuICAgICAgfVxuICAgICAgcyAqPSBzO1xuICAgICAgdSAqPSB1O1xuICAgICAgcmV0dXJuIHMgPyBNYXRoLm1heCh1ICogcm1heCAqIHJhdGlvIC8gcywgcyAvICh1ICogcm1pbiAqIHJhdGlvKSkgOiBJbmZpbml0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb24ocm93LCB1LCByZWN0LCBmbHVzaCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHJvdy5sZW5ndGgsIHggPSByZWN0LngsIHkgPSByZWN0LnksIHYgPSB1ID8gcm91bmQocm93LmFyZWEgLyB1KSA6IDAsIG87XG4gICAgICBpZiAodSA9PSByZWN0LmR4KSB7XG4gICAgICAgIGlmIChmbHVzaCB8fCB2ID4gcmVjdC5keSkgdiA9IHJlY3QuZHk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IHJvd1tpXTtcbiAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgIG8ueSA9IHk7XG4gICAgICAgICAgby5keSA9IHY7XG4gICAgICAgICAgeCArPSBvLmR4ID0gTWF0aC5taW4ocmVjdC54ICsgcmVjdC5keCAtIHgsIHYgPyByb3VuZChvLmFyZWEgLyB2KSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIG8ueiA9IHRydWU7XG4gICAgICAgIG8uZHggKz0gcmVjdC54ICsgcmVjdC5keCAtIHg7XG4gICAgICAgIHJlY3QueSArPSB2O1xuICAgICAgICByZWN0LmR5IC09IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmx1c2ggfHwgdiA+IHJlY3QuZHgpIHYgPSByZWN0LmR4O1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSByb3dbaV07XG4gICAgICAgICAgby54ID0geDtcbiAgICAgICAgICBvLnkgPSB5O1xuICAgICAgICAgIG8uZHggPSB2O1xuICAgICAgICAgIHkgKz0gby5keSA9IE1hdGgubWluKHJlY3QueSArIHJlY3QuZHkgLSB5LCB2ID8gcm91bmQoby5hcmVhIC8gdikgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBvLnogPSBmYWxzZTtcbiAgICAgICAgby5keSArPSByZWN0LnkgKyByZWN0LmR5IC0geTtcbiAgICAgICAgcmVjdC54ICs9IHY7XG4gICAgICAgIHJlY3QuZHggLT0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJlZW1hcChkKSB7XG4gICAgICB2YXIgbm9kZXMgPSBzdGlja2llcyB8fCBoaWVyYXJjaHkoZCksIHJvb3QgPSBub2Rlc1swXTtcbiAgICAgIHJvb3QueCA9IHJvb3QueSA9IDA7XG4gICAgICBpZiAocm9vdC52YWx1ZSkgcm9vdC5keCA9IHNpemVbMF0sIHJvb3QuZHkgPSBzaXplWzFdOyBlbHNlIHJvb3QuZHggPSByb290LmR5ID0gMDtcbiAgICAgIGlmIChzdGlja2llcykgaGllcmFyY2h5LnJldmFsdWUocm9vdCk7XG4gICAgICBzY2FsZShbIHJvb3QgXSwgcm9vdC5keCAqIHJvb3QuZHkgLyByb290LnZhbHVlKTtcbiAgICAgIChzdGlja2llcyA/IHN0aWNraWZ5IDogc3F1YXJpZnkpKHJvb3QpO1xuICAgICAgaWYgKHN0aWNreSkgc3RpY2tpZXMgPSBub2RlcztcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgZnVuY3Rpb24gcGFkRnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHguY2FsbCh0cmVlbWFwLCBub2RlLCBub2RlLmRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHAgPT0gbnVsbCA/IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbChub2RlKSA6IGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHR5cGVvZiBwID09PSBcIm51bWJlclwiID8gWyBwLCBwLCBwLCBwIF0gOiBwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhZENvbnN0YW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHgpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGU7XG4gICAgICBwYWQgPSAocGFkZGluZyA9IHgpID09IG51bGwgPyBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwgOiAodHlwZSA9IHR5cGVvZiB4KSA9PT0gXCJmdW5jdGlvblwiID8gcGFkRnVuY3Rpb24gOiB0eXBlID09PSBcIm51bWJlclwiID8gKHggPSBbIHgsIHgsIHgsIHggXSwgXG4gICAgICBwYWRDb25zdGFudCkgOiBwYWRDb25zdGFudDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJvdW5kICE9IE51bWJlcjtcbiAgICAgIHJvdW5kID0geCA/IE1hdGgucm91bmQgOiBOdW1iZXI7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAuc3RpY2t5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RpY2t5O1xuICAgICAgc3RpY2t5ID0geDtcbiAgICAgIHN0aWNraWVzID0gbnVsbDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhdGlvO1xuICAgICAgcmF0aW8gPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLm1vZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtb2RlO1xuICAgICAgbW9kZSA9IHggKyBcIlwiO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZCh0cmVlbWFwLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwobm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBub2RlLngsXG4gICAgICB5OiBub2RlLnksXG4gICAgICBkeDogbm9kZS5keCxcbiAgICAgIGR5OiBub2RlLmR5XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCBwYWRkaW5nKSB7XG4gICAgdmFyIHggPSBub2RlLnggKyBwYWRkaW5nWzNdLCB5ID0gbm9kZS55ICsgcGFkZGluZ1swXSwgZHggPSBub2RlLmR4IC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sIGR5ID0gbm9kZS5keSAtIHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdO1xuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHggKz0gZHggLyAyO1xuICAgICAgZHggPSAwO1xuICAgIH1cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICB5ICs9IGR5IC8gMjtcbiAgICAgIGR5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgZHg6IGR4LFxuICAgICAgZHk6IGR5XG4gICAgfTtcbiAgfVxuICBkMy5yYW5kb20gPSB7XG4gICAgbm9ybWFsOiBmdW5jdGlvbijCtSwgz4MpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChuIDwgMikgz4MgPSAxO1xuICAgICAgaWYgKG4gPCAxKSDCtSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4LCB5LCByO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgeCA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICB5ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgIHIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG4gICAgICAgIHJldHVybiDCtSArIM+DICogeCAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgbG9nTm9ybWFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYW5kb20gPSBkMy5yYW5kb20ubm9ybWFsLmFwcGx5KGQzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAocmFuZG9tKCkpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGJhdGVzOiBmdW5jdGlvbihtKSB7XG4gICAgICB2YXIgcmFuZG9tID0gZDMucmFuZG9tLmlyd2luSGFsbChtKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbSgpIC8gbTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBpcndpbkhhbGw6IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGogPSAwOyBqIDwgbTsgaisrKSBzICs9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGQzLnNjYWxlID0ge307XG4gIGZ1bmN0aW9uIGQzX3NjYWxlRXh0ZW50KGRvbWFpbikge1xuICAgIHZhciBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFsgc3RhcnQsIHN0b3AgXSA6IFsgc3RvcCwgc3RhcnQgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZVJhbmdlKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlLnJhbmdlRXh0ZW50ID8gc2NhbGUucmFuZ2VFeHRlbnQoKSA6IGQzX3NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2JpbGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gICAgdmFyIHUgPSB1bmludGVycG9sYXRlKGRvbWFpblswXSwgZG9tYWluWzFdKSwgaSA9IGludGVycG9sYXRlKHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBpKHUoeCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbmljZShkb21haW4sIG5pY2UpIHtcbiAgICB2YXIgaTAgPSAwLCBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLCB4MCA9IGRvbWFpbltpMF0sIHgxID0gZG9tYWluW2kxXSwgZHg7XG4gICAgaWYgKHgxIDwgeDApIHtcbiAgICAgIGR4ID0gaTAsIGkwID0gaTEsIGkxID0gZHg7XG4gICAgICBkeCA9IHgwLCB4MCA9IHgxLCB4MSA9IGR4O1xuICAgIH1cbiAgICBkb21haW5baTBdID0gbmljZS5mbG9vcih4MCk7XG4gICAgZG9tYWluW2kxXSA9IG5pY2UuY2VpbCh4MSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9uaWNlU3RlcChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXAgPyB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfVxuICAgIH0gOiBkM19zY2FsZV9uaWNlSWRlbnRpdHk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX25pY2VJZGVudGl0eSA9IHtcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG9seWxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciB1ID0gW10sIGkgPSBbXSwgaiA9IDAsIGsgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMTtcbiAgICBpZiAoZG9tYWluW2tdIDwgZG9tYWluWzBdKSB7XG4gICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB3aGlsZSAoKytqIDw9IGspIHtcbiAgICAgIHUucHVzaCh1bmludGVycG9sYXRlKGRvbWFpbltqIC0gMV0sIGRvbWFpbltqXSkpO1xuICAgICAgaS5wdXNoKGludGVycG9sYXRlKHJhbmdlW2ogLSAxXSwgcmFuZ2Vbal0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBqID0gZDMuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaykgLSAxO1xuICAgICAgcmV0dXJuIGlbal0odVtqXSh4KSk7XG4gICAgfTtcbiAgfVxuICBkMy5zY2FsZS5saW5lYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKFsgMCwgMSBdLCBbIDAsIDEgXSwgZDNfaW50ZXJwb2xhdGUsIGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCkge1xuICAgIHZhciBvdXRwdXQsIGlucHV0O1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgbGluZWFyID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSA+IDIgPyBkM19zY2FsZV9wb2x5bGluZWFyIDogZDNfc2NhbGVfYmlsaW5lYXIsIHVuaW50ZXJwb2xhdGUgPSBjbGFtcCA/IGQzX3VuaW50ZXJwb2xhdGVDbGFtcCA6IGQzX3VuaW50ZXJwb2xhdGVOdW1iZXI7XG4gICAgICBvdXRwdXQgPSBsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICAgICAgaW5wdXQgPSBsaW5lYXIocmFuZ2UsIGRvbWFpbiwgdW5pbnRlcnBvbGF0ZSwgZDNfaW50ZXJwb2xhdGUpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gb3V0cHV0KHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gaW5wdXQoeSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChOdW1iZXIpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBzY2FsZS5yYW5nZSh4KS5pbnRlcnBvbGF0ZShkM19pbnRlcnBvbGF0ZVJvdW5kKTtcbiAgICB9O1xuICAgIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xhbXA7XG4gICAgICBjbGFtcCA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICAgIGludGVycG9sYXRlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKSB7XG4gICAgcmV0dXJuIGQzLnJlYmluZChzY2FsZSwgbGluZWFyLCBcInJhbmdlXCIsIFwicmFuZ2VSb3VuZFwiLCBcImludGVycG9sYXRlXCIsIFwiY2xhbXBcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pIHtcbiAgICBkM19zY2FsZV9uaWNlKGRvbWFpbiwgZDNfc2NhbGVfbmljZVN0ZXAoZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSlbMl0pKTtcbiAgICBkM19zY2FsZV9uaWNlKGRvbWFpbiwgZDNfc2NhbGVfbmljZVN0ZXAoZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSlbMl0pKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pIHtcbiAgICBpZiAobSA9PSBudWxsKSBtID0gMTA7XG4gICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIHN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzcGFuIC8gbSkgLyBNYXRoLkxOMTApKSwgZXJyID0gbSAvIHNwYW4gKiBzdGVwO1xuICAgIGlmIChlcnIgPD0gLjE1KSBzdGVwICo9IDEwOyBlbHNlIGlmIChlcnIgPD0gLjM1KSBzdGVwICo9IDU7IGVsc2UgaWYgKGVyciA8PSAuNzUpIHN0ZXAgKj0gMjtcbiAgICBleHRlbnRbMF0gPSBNYXRoLmNlaWwoZXh0ZW50WzBdIC8gc3RlcCkgKiBzdGVwO1xuICAgIGV4dGVudFsxXSA9IE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gc3RlcCkgKiBzdGVwICsgc3RlcCAqIC41O1xuICAgIGV4dGVudFsyXSA9IHN0ZXA7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pIHtcbiAgICByZXR1cm4gZDMucmFuZ2UuYXBwbHkoZDMsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KSB7XG4gICAgdmFyIHJhbmdlID0gZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSk7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgdmFyIG1hdGNoID0gZDNfZm9ybWF0X3JlLmV4ZWMoZm9ybWF0KTtcbiAgICAgIG1hdGNoLnNoaWZ0KCk7XG4gICAgICBpZiAobWF0Y2hbOF0gPT09IFwic1wiKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBkMy5mb3JtYXRQcmVmaXgoTWF0aC5tYXgoYWJzKHJhbmdlWzBdKSwgYWJzKHJhbmdlWzFdKSkpO1xuICAgICAgICBpZiAoIW1hdGNoWzddKSBtYXRjaFs3XSA9IFwiLlwiICsgZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHByZWZpeC5zY2FsZShyYW5nZVsyXSkpO1xuICAgICAgICBtYXRjaFs4XSA9IFwiZlwiO1xuICAgICAgICBmb3JtYXQgPSBkMy5mb3JtYXQobWF0Y2guam9pbihcIlwiKSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdChwcmVmaXguc2NhbGUoZCkpICsgcHJlZml4LnN5bWJvbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2hbN10pIG1hdGNoWzddID0gXCIuXCIgKyBkM19zY2FsZV9saW5lYXJGb3JtYXRQcmVjaXNpb24obWF0Y2hbOF0sIHJhbmdlKTtcbiAgICAgIGZvcm1hdCA9IG1hdGNoLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdCA9IFwiLC5cIiArIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihyYW5nZVsyXSkgKyBcImZcIjtcbiAgICB9XG4gICAgcmV0dXJuIGQzLmZvcm1hdChmb3JtYXQpO1xuICB9XG4gIHZhciBkM19zY2FsZV9saW5lYXJGb3JtYXRTaWduaWZpY2FudCA9IHtcbiAgICBzOiAxLFxuICAgIGc6IDEsXG4gICAgcDogMSxcbiAgICByOiAxLFxuICAgIGU6IDFcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCArIC4wMSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyRm9ybWF0UHJlY2lzaW9uKHR5cGUsIHJhbmdlKSB7XG4gICAgdmFyIHAgPSBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocmFuZ2VbMl0pO1xuICAgIHJldHVybiB0eXBlIGluIGQzX3NjYWxlX2xpbmVhckZvcm1hdFNpZ25pZmljYW50ID8gTWF0aC5hYnMocCAtIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihNYXRoLm1heChhYnMocmFuZ2VbMF0pLCBhYnMocmFuZ2VbMV0pKSkpICsgKyh0eXBlICE9PSBcImVcIikgOiBwIC0gKHR5cGUgPT09IFwiJVwiKSAqIDI7XG4gIH1cbiAgZDMuc2NhbGUubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xvZyhkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWyAwLCAxIF0pLCAxMCwgdHJ1ZSwgWyAxLCAxMCBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbG9nKGxpbmVhciwgYmFzZSwgcG9zaXRpdmUsIGRvbWFpbikge1xuICAgIGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICByZXR1cm4gKHBvc2l0aXZlID8gTWF0aC5sb2coeCA8IDAgPyAwIDogeCkgOiAtTWF0aC5sb2coeCA+IDAgPyAwIDogLXgpKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3coeCkge1xuICAgICAgcmV0dXJuIHBvc2l0aXZlID8gTWF0aC5wb3coYmFzZSwgeCkgOiAtTWF0aC5wb3coYmFzZSwgLXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKGxvZyh4KSk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBwb3cobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBwb3NpdGl2ZSA9IHhbMF0gPj0gMDtcbiAgICAgIGxpbmVhci5kb21haW4oKGRvbWFpbiA9IHgubWFwKE51bWJlcikpLm1hcChsb2cpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYXNlO1xuICAgICAgYmFzZSA9ICtfO1xuICAgICAgbGluZWFyLmRvbWFpbihkb21haW4ubWFwKGxvZykpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5pY2VkID0gZDNfc2NhbGVfbmljZShkb21haW4ubWFwKGxvZyksIHBvc2l0aXZlID8gTWF0aCA6IGQzX3NjYWxlX2xvZ05pY2VOZWdhdGl2ZSk7XG4gICAgICBsaW5lYXIuZG9tYWluKG5pY2VkKTtcbiAgICAgIGRvbWFpbiA9IG5pY2VkLm1hcChwb3cpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCB0aWNrcyA9IFtdLCB1ID0gZXh0ZW50WzBdLCB2ID0gZXh0ZW50WzFdLCBpID0gTWF0aC5mbG9vcihsb2codSkpLCBqID0gTWF0aC5jZWlsKGxvZyh2KSksIG4gPSBiYXNlICUgMSA/IDIgOiBiYXNlO1xuICAgICAgaWYgKGlzRmluaXRlKGogLSBpKSkge1xuICAgICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgICBmb3IgKDtpIDwgajsgaSsrKSBmb3IgKHZhciBrID0gMTsgayA8IG47IGsrKykgdGlja3MucHVzaChwb3coaSkgKiBrKTtcbiAgICAgICAgICB0aWNrcy5wdXNoKHBvdyhpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja3MucHVzaChwb3coaSkpO1xuICAgICAgICAgIGZvciAoO2krKyA8IGo7ICkgZm9yICh2YXIgayA9IG4gLSAxOyBrID4gMDsgay0tKSB0aWNrcy5wdXNoKHBvdyhpKSAqIGspO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IHRpY2tzW2ldIDwgdTsgaSsrKSB7fVxuICAgICAgICBmb3IgKGogPSB0aWNrcy5sZW5ndGg7IHRpY2tzW2ogLSAxXSA+IHY7IGotLSkge31cbiAgICAgICAgdGlja3MgPSB0aWNrcy5zbGljZShpLCBqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrcztcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihuLCBmb3JtYXQpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGQzX3NjYWxlX2xvZ0Zvcm1hdDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgZm9ybWF0ID0gZDNfc2NhbGVfbG9nRm9ybWF0OyBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9PSBcImZ1bmN0aW9uXCIpIGZvcm1hdCA9IGQzLmZvcm1hdChmb3JtYXQpO1xuICAgICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogbiAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpID0gZCAvIHBvdyhNYXRoLnJvdW5kKGxvZyhkKSkpO1xuICAgICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gLjUpIGkgKj0gYmFzZTtcbiAgICAgICAgcmV0dXJuIGkgPD0gayA/IGZvcm1hdChkKSA6IFwiXCI7XG4gICAgICB9O1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xvZyhsaW5lYXIuY29weSgpLCBiYXNlLCBwb3NpdGl2ZSwgZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX2xvZ0Zvcm1hdCA9IGQzLmZvcm1hdChcIi4wZVwiKSwgZDNfc2NhbGVfbG9nTmljZU5lZ2F0aXZlID0ge1xuICAgIGZsb29yOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLU1hdGguY2VpbCgteCk7XG4gICAgfSxcbiAgICBjZWlsOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLU1hdGguZmxvb3IoLXgpO1xuICAgIH1cbiAgfTtcbiAgZDMuc2NhbGUucG93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3BvdyhkMy5zY2FsZS5saW5lYXIoKSwgMSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9wb3cobGluZWFyLCBleHBvbmVudCwgZG9tYWluKSB7XG4gICAgdmFyIHBvd3AgPSBkM19zY2FsZV9wb3dQb3coZXhwb25lbnQpLCBwb3diID0gZDNfc2NhbGVfcG93UG93KDEgLyBleHBvbmVudCk7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcihwb3dwKHgpKTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBvd2IobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBsaW5lYXIuZG9tYWluKChkb21haW4gPSB4Lm1hcChOdW1iZXIpKS5tYXAocG93cCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gc2NhbGUuZG9tYWluKGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKSk7XG4gICAgfTtcbiAgICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGV4cG9uZW50O1xuICAgICAgcG93cCA9IGQzX3NjYWxlX3Bvd1BvdyhleHBvbmVudCA9IHgpO1xuICAgICAgcG93YiA9IGQzX3NjYWxlX3Bvd1BvdygxIC8gZXhwb25lbnQpO1xuICAgICAgbGluZWFyLmRvbWFpbihkb21haW4ubWFwKHBvd3ApKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9wb3cobGluZWFyLmNvcHkoKSwgZXhwb25lbnQsIGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3Bvd1BvdyhlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZSkgOiBNYXRoLnBvdyh4LCBlKTtcbiAgICB9O1xuICB9XG4gIGQzLnNjYWxlLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUucG93KCkuZXhwb25lbnQoLjUpO1xuICB9O1xuICBkMy5zY2FsZS5vcmRpbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX29yZGluYWwoW10sIHtcbiAgICAgIHQ6IFwicmFuZ2VcIixcbiAgICAgIGE6IFsgW10gXVxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9vcmRpbmFsKGRvbWFpbiwgcmFuZ2VyKSB7XG4gICAgdmFyIGluZGV4LCByYW5nZSwgcmFuZ2VCYW5kO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiByYW5nZVsoKGluZGV4LmdldCh4KSB8fCAocmFuZ2VyLnQgPT09IFwicmFuZ2VcIiA/IGluZGV4LnNldCh4LCBkb21haW4ucHVzaCh4KSkgOiBOYU4pKSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcHMoc3RhcnQsIHN0ZXApIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShkb21haW4ubGVuZ3RoKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBzdGVwICogaTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSBbXTtcbiAgICAgIGluZGV4ID0gbmV3IGQzX01hcCgpO1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHgubGVuZ3RoLCB4aTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4Lmhhcyh4aSA9IHhbaV0pKSBpbmRleC5zZXQoeGksIGRvbWFpbi5wdXNoKHhpKSk7XG4gICAgICByZXR1cm4gc2NhbGVbcmFuZ2VyLnRdLmFwcGx5KHNjYWxlLCByYW5nZXIuYSk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVwiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVBvaW50cyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICB2YXIgc3RhcnQgPSB4WzBdLCBzdG9wID0geFsxXSwgc3RlcCA9IGRvbWFpbi5sZW5ndGggPCAyID8gKHN0YXJ0ID0gKHN0YXJ0ICsgc3RvcCkgLyAyLCBcbiAgICAgIDApIDogKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBzdGVwICogcGFkZGluZyAvIDIsIHN0ZXApO1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVBvaW50c1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kUG9pbnRzID0gZnVuY3Rpb24oeCwgcGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIHZhciBzdGFydCA9IHhbMF0sIHN0b3AgPSB4WzFdLCBzdGVwID0gZG9tYWluLmxlbmd0aCA8IDIgPyAoc3RhcnQgPSBzdG9wID0gTWF0aC5yb3VuZCgoc3RhcnQgKyBzdG9wKSAvIDIpLCBcbiAgICAgIDApIDogKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKSB8IDA7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgTWF0aC5yb3VuZChzdGVwICogcGFkZGluZyAvIDIgKyAoc3RvcCAtIHN0YXJ0IC0gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZykgKiBzdGVwKSAvIDIpLCBzdGVwKTtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VSb3VuZFBvaW50c1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUJhbmRzID0gZnVuY3Rpb24oeCwgcGFkZGluZywgb3V0ZXJQYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBvdXRlclBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdmFyIHJldmVyc2UgPSB4WzFdIDwgeFswXSwgc3RhcnQgPSB4W3JldmVyc2UgLSAwXSwgc3RvcCA9IHhbMSAtIHJldmVyc2VdLCBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcgKyAyICogb3V0ZXJQYWRkaW5nKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBzdGVwICogb3V0ZXJQYWRkaW5nLCBzdGVwKTtcbiAgICAgIGlmIChyZXZlcnNlKSByYW5nZS5yZXZlcnNlKCk7XG4gICAgICByYW5nZUJhbmQgPSBzdGVwICogKDEgLSBwYWRkaW5nKTtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZUJhbmRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcsIG91dGVyUGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgb3V0ZXJQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIHZhciByZXZlcnNlID0geFsxXSA8IHhbMF0sIHN0YXJ0ID0geFtyZXZlcnNlIC0gMF0sIHN0b3AgPSB4WzEgLSByZXZlcnNlXSwgc3RlcCA9IE1hdGguZmxvb3IoKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcgKyAyICogb3V0ZXJQYWRkaW5nKSk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgTWF0aC5yb3VuZCgoc3RvcCAtIHN0YXJ0IC0gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nKSAqIHN0ZXApIC8gMiksIHN0ZXApO1xuICAgICAgaWYgKHJldmVyc2UpIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlQmFuZCA9IE1hdGgucm91bmQoc3RlcCAqICgxIC0gcGFkZGluZykpO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUm91bmRCYW5kc1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUJhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5nZUJhbmQ7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlRXh0ZW50KHJhbmdlci5hWzBdKTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9vcmRpbmFsKGRvbWFpbiwgcmFuZ2VyKTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgfVxuICBkMy5zY2FsZS5jYXRlZ29yeTEwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTEwKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMCk7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjBiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwYik7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjBjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwYyk7XG4gIH07XG4gIHZhciBkM19jYXRlZ29yeTEwID0gWyAyMDYyMjYwLCAxNjc0NDIwNiwgMjkyNDU4OCwgMTQwMzQ3MjgsIDk3MjU4ODUsIDkxOTcxMzEsIDE0OTA3MzMwLCA4MzU1NzExLCAxMjM2OTE4NiwgMTU1NjE3NSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMCA9IFsgMjA2MjI2MCwgMTE0NTQ0NDAsIDE2NzQ0MjA2LCAxNjc1OTY3MiwgMjkyNDU4OCwgMTAwMTg2OTgsIDE0MDM0NzI4LCAxNjc1MDc0MiwgOTcyNTg4NSwgMTI5NTU4NjEsIDkxOTcxMzEsIDEyODg1MTQwLCAxNDkwNzMzMCwgMTYyMzQxOTQsIDgzNTU3MTEsIDEzMDkyODA3LCAxMjM2OTE4NiwgMTQ0MDg1ODksIDE1NTYxNzUsIDEwNDEwNzI1IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwYiA9IFsgMzc1MDc3NywgNTM5NTYxOSwgNzA0MDcxOSwgMTAyNjQyODYsIDY1MTkwOTcsIDkyMTY1OTQsIDExOTE1MTE1LCAxMzU1NjYzNiwgOTIwMjk5MywgMTI0MjY4MDksIDE1MTg2NTE0LCAxNTE5MDkzMiwgODY2NjE2OSwgMTEzNTY0OTAsIDE0MDQ5NjQzLCAxNTE3NzM3MiwgODA3NzY4MywgMTA4MzQzMjQsIDEzNTI4NTA5LCAxNDU4OTY1NCBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMGMgPSBbIDMyNDQ3MzMsIDcwNTcxMTAsIDEwNDA2NjI1LCAxMzAzMjQzMSwgMTUwOTUwNTMsIDE2NjE2NzY0LCAxNjYyNTI1OSwgMTY2MzQwMTgsIDMyNTMwNzYsIDc2NTI0NzAsIDEwNjA3MDAzLCAxMzEwMTUwNCwgNzY5NTI4MSwgMTAzOTQzMTIsIDEyMzY5MzcyLCAxNDM0Mjg5MSwgNjUxMzUwNywgOTg2ODk1MCwgMTI0MzQ4NzcsIDE0Mjc3MDgxIF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIGQzLnNjYWxlLnF1YW50aWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aWxlKFtdLCBbXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3F1YW50aWxlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICB2YXIgdGhyZXNob2xkcztcbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGsgPSAwLCBxID0gcmFuZ2UubGVuZ3RoO1xuICAgICAgdGhyZXNob2xkcyA9IFtdO1xuICAgICAgd2hpbGUgKCsrayA8IHEpIHRocmVzaG9sZHNbayAtIDFdID0gZDMucXVhbnRpbGUoZG9tYWluLCBrIC8gcSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIHJhbmdlW2QzLmJpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKGQzX251bWJlcikuZmlsdGVyKGQzX251bWVyaWMpLnNvcnQoZDNfYXNjZW5kaW5nKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZHM7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiB5IDwgMCA/IFsgTmFOLCBOYU4gXSA6IFsgeSA+IDAgPyB0aHJlc2hvbGRzW3kgLSAxXSA6IGRvbWFpblswXSwgeSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1t5XSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9xdWFudGlsZShkb21haW4sIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZDMuc2NhbGUucXVhbnRpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpemUoMCwgMSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9xdWFudGl6ZSh4MCwgeDEsIHJhbmdlKSB7XG4gICAgdmFyIGt4LCBpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihpLCBNYXRoLmZsb29yKGt4ICogKHggLSB4MCkpKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAga3ggPSByYW5nZS5sZW5ndGggLyAoeDEgLSB4MCk7XG4gICAgICBpID0gcmFuZ2UubGVuZ3RoIC0gMTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB4MCwgeDEgXTtcbiAgICAgIHgwID0gK3hbMF07XG4gICAgICB4MSA9ICt4W3gubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHkgPSB5IDwgMCA/IE5hTiA6IHkgLyBreCArIHgwO1xuICAgICAgcmV0dXJuIFsgeSwgeSArIDEgLyBreCBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aXplKHgwLCB4MSwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBkMy5zY2FsZS50aHJlc2hvbGQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfdGhyZXNob2xkKFsgLjUgXSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV90aHJlc2hvbGQoZG9tYWluLCByYW5nZSkge1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZVtkMy5iaXNlY3QoZG9tYWluLCB4KV07XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IF87XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSBfO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICByZXR1cm4gWyBkb21haW5beSAtIDFdLCBkb21haW5beV0gXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV90aHJlc2hvbGQoZG9tYWluLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cbiAgZDMuc2NhbGUuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfaWRlbnRpdHkoWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9pZGVudGl0eShkb21haW4pIHtcbiAgICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgICByZXR1cm4gK3g7XG4gICAgfVxuICAgIGlkZW50aXR5LmludmVydCA9IGlkZW50aXR5O1xuICAgIGlkZW50aXR5LmRvbWFpbiA9IGlkZW50aXR5LnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoaWRlbnRpdHkpO1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH07XG4gICAgaWRlbnRpdHkudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIGlkZW50aXR5LnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIGlkZW50aXR5LmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9pZGVudGl0eShkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGQzLnN2ZyA9IHt9O1xuICBmdW5jdGlvbiBkM196ZXJvKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGQzLnN2Zy5hcmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSBkM19zdmdfYXJjSW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzID0gZDNfc3ZnX2FyY091dGVyUmFkaXVzLCBjb3JuZXJSYWRpdXMgPSBkM196ZXJvLCBwYWRSYWRpdXMgPSBkM19zdmdfYXJjQXV0bywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZSwgcGFkQW5nbGUgPSBkM19zdmdfYXJjUGFkQW5nbGU7XG4gICAgZnVuY3Rpb24gYXJjKCkge1xuICAgICAgdmFyIHIwID0gTWF0aC5tYXgoMCwgK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByMSA9IE1hdGgubWF4KDAsICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmz4AsIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGbPgCwgZGEgPSBNYXRoLmFicyhhMSAtIGEwKSwgY3cgPSBhMCA+IGExID8gMCA6IDE7XG4gICAgICBpZiAocjEgPCByMCkgcmMgPSByMSwgcjEgPSByMCwgcjAgPSByYztcbiAgICAgIGlmIChkYSA+PSDPhM61KSByZXR1cm4gY2lyY2xlU2VnbWVudChyMSwgY3cpICsgKHIwID8gY2lyY2xlU2VnbWVudChyMCwgMSAtIGN3KSA6IFwiXCIpICsgXCJaXCI7XG4gICAgICB2YXIgcmMsIGNyLCBycCwgYXAsIHAwID0gMCwgcDEgPSAwLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHBhdGggPSBbXTtcbiAgICAgIGlmIChhcCA9ICgrcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwKSAvIDIpIHtcbiAgICAgICAgcnAgPSBwYWRSYWRpdXMgPT09IGQzX3N2Z19hcmNBdXRvID8gTWF0aC5zcXJ0KHIwICogcjAgKyByMSAqIHIxKSA6ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFjdykgcDEgKj0gLTE7XG4gICAgICAgIGlmIChyMSkgcDEgPSBkM19hc2luKHJwIC8gcjEgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgICBpZiAocjApIHAwID0gZDNfYXNpbihycCAvIHIwICogTWF0aC5zaW4oYXApKTtcbiAgICAgIH1cbiAgICAgIGlmIChyMSkge1xuICAgICAgICB4MCA9IHIxICogTWF0aC5jb3MoYTAgKyBwMSk7XG4gICAgICAgIHkwID0gcjEgKiBNYXRoLnNpbihhMCArIHAxKTtcbiAgICAgICAgeDEgPSByMSAqIE1hdGguY29zKGExIC0gcDEpO1xuICAgICAgICB5MSA9IHIxICogTWF0aC5zaW4oYTEgLSBwMSk7XG4gICAgICAgIHZhciBsMSA9IE1hdGguYWJzKGExIC0gYTAgLSAyICogcDEpIDw9IM+AID8gMCA6IDE7XG4gICAgICAgIGlmIChwMSAmJiBkM19zdmdfYXJjU3dlZXAoeDAsIHkwLCB4MSwgeTEpID09PSBjdyBeIGwxKSB7XG4gICAgICAgICAgdmFyIGgxID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICB4MCA9IHIxICogTWF0aC5jb3MoaDEpO1xuICAgICAgICAgIHkwID0gcjEgKiBNYXRoLnNpbihoMSk7XG4gICAgICAgICAgeDEgPSB5MSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwID0geTAgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHIwKSB7XG4gICAgICAgIHgyID0gcjAgKiBNYXRoLmNvcyhhMSAtIHAwKTtcbiAgICAgICAgeTIgPSByMCAqIE1hdGguc2luKGExIC0gcDApO1xuICAgICAgICB4MyA9IHIwICogTWF0aC5jb3MoYTAgKyBwMCk7XG4gICAgICAgIHkzID0gcjAgKiBNYXRoLnNpbihhMCArIHAwKTtcbiAgICAgICAgdmFyIGwwID0gTWF0aC5hYnMoYTAgLSBhMSArIDIgKiBwMCkgPD0gz4AgPyAwIDogMTtcbiAgICAgICAgaWYgKHAwICYmIGQzX3N2Z19hcmNTd2VlcCh4MiwgeTIsIHgzLCB5MykgPT09IDEgLSBjdyBeIGwwKSB7XG4gICAgICAgICAgdmFyIGgwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICB4MiA9IHIwICogTWF0aC5jb3MoaDApO1xuICAgICAgICAgIHkyID0gcjAgKiBNYXRoLnNpbihoMCk7XG4gICAgICAgICAgeDMgPSB5MyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0geTIgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGRhID4gzrUgJiYgKHJjID0gTWF0aC5taW4oTWF0aC5hYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSA+IC4wMDEpIHtcbiAgICAgICAgY3IgPSByMCA8IHIxIF4gY3cgPyAwIDogMTtcbiAgICAgICAgdmFyIHJjMSA9IHJjLCByYzAgPSByYztcbiAgICAgICAgaWYgKGRhIDwgz4ApIHtcbiAgICAgICAgICB2YXIgb2MgPSB4MyA9PSBudWxsID8gWyB4MiwgeTIgXSA6IHgxID09IG51bGwgPyBbIHgwLCB5MCBdIDogZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KFsgeDAsIHkwIF0sIFsgeDMsIHkzIF0sIFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0pLCBheCA9IHgwIC0gb2NbMF0sIGF5ID0geTAgLSBvY1sxXSwgYnggPSB4MSAtIG9jWzBdLCBieSA9IHkxIC0gb2NbMV0sIGtjID0gMSAvIE1hdGguc2luKE1hdGguYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSwgbGMgPSBNYXRoLnNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IE1hdGgubWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0MzAgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoeDMgPT0gbnVsbCA/IFsgeDIsIHkyIF0gOiBbIHgzLCB5MyBdLCBbIHgwLCB5MCBdLCByMSwgcmMxLCBjdyksIHQxMiA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgxLCB5MSBdLCBbIHgyLCB5MiBdLCByMSwgcmMxLCBjdyk7XG4gICAgICAgICAgaWYgKHJjID09PSByYzEpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgdDMwWzBdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDMwWzFdLCBcIkFcIiwgcjEsIFwiLFwiLCByMSwgXCIgMCBcIiwgMSAtIGN3IF4gZDNfc3ZnX2FyY1N3ZWVwKHQzMFsxXVswXSwgdDMwWzFdWzFdLCB0MTJbMV1bMF0sIHQxMlsxXVsxXSksIFwiLFwiLCBjdywgXCIgXCIsIHQxMlsxXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQxMlswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgdDMwWzBdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDEsXCIsIGNyLCBcIiBcIiwgdDEyWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB4MCwgXCIsXCIsIHkwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDMgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0MDMgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MCwgeTAgXSwgWyB4MywgeTMgXSwgcjAsIC1yYzAsIGN3KSwgdDIxID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDIsIHkyIF0sIHgxID09IG51bGwgPyBbIHgwLCB5MCBdIDogWyB4MSwgeTEgXSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgICBpZiAocmMgPT09IHJjMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB0MjFbMF0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MjFbMV0sIFwiQVwiLCByMCwgXCIsXCIsIHIwLCBcIiAwIFwiLCBjdyBeIGQzX3N2Z19hcmNTd2VlcCh0MjFbMV1bMF0sIHQyMVsxXVsxXSwgdDAzWzFdWzBdLCB0MDNbMV1bMV0pLCBcIixcIiwgMSAtIGN3LCBcIiBcIiwgdDAzWzFdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDAzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB0MjFbMF0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MDNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHgyLCBcIixcIiwgeTIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHgwLCBcIixcIiwgeTApO1xuICAgICAgICBpZiAoeDEgIT0gbnVsbCkgcGF0aC5wdXNoKFwiQVwiLCByMSwgXCIsXCIsIHIxLCBcIiAwIFwiLCBsMSwgXCIsXCIsIGN3LCBcIiBcIiwgeDEsIFwiLFwiLCB5MSk7XG4gICAgICAgIHBhdGgucHVzaChcIkxcIiwgeDIsIFwiLFwiLCB5Mik7XG4gICAgICAgIGlmICh4MyAhPSBudWxsKSBwYXRoLnB1c2goXCJBXCIsIHIwLCBcIixcIiwgcjAsIFwiIDAgXCIsIGwwLCBcIixcIiwgMSAtIGN3LCBcIiBcIiwgeDMsIFwiLFwiLCB5Myk7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goXCJaXCIpO1xuICAgICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2lyY2xlU2VnbWVudChyMSwgY3cpIHtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcjEgKyBcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiIDAgMSxcIiArIGN3ICsgXCIgMCxcIiArIC1yMSArIFwiQVwiICsgcjEgKyBcIixcIiArIHIxICsgXCIgMCAxLFwiICsgY3cgKyBcIiAwLFwiICsgcjE7XG4gICAgfVxuICAgIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dGVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb3JuZXJSYWRpdXM7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRSYWRpdXM7XG4gICAgICBwYWRSYWRpdXMgPSB2ID09IGQzX3N2Z19hcmNBdXRvID8gZDNfc3ZnX2FyY0F1dG8gOiBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLCBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgTWF0aC5jb3MoYSkgKiByLCBNYXRoLnNpbihhKSAqIHIgXTtcbiAgICB9O1xuICAgIHJldHVybiBhcmM7XG4gIH07XG4gIHZhciBkM19zdmdfYXJjQXV0byA9IFwiYXV0b1wiO1xuICBmdW5jdGlvbiBkM19zdmdfYXJjSW5uZXJSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLmlubmVyUmFkaXVzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNPdXRlclJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUoZCkge1xuICAgIHJldHVybiBkLnN0YXJ0QW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0VuZEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZC5lbmRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjUGFkQW5nbGUoZCkge1xuICAgIHJldHVybiBkICYmIGQucGFkQW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1N3ZWVwKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuICh4MCAtIHgxKSAqIHkwIC0gKHkwIC0geTEpICogeDAgPiAwID8gMCA6IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKHAwLCBwMSwgcjEsIHJjLCBjdykge1xuICAgIHZhciB4MDEgPSBwMFswXSAtIHAxWzBdLCB5MDEgPSBwMFsxXSAtIHAxWzFdLCBsbyA9IChjdyA/IHJjIDogLXJjKSAvIE1hdGguc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLCBveCA9IGxvICogeTAxLCBveSA9IC1sbyAqIHgwMSwgeDEgPSBwMFswXSArIG94LCB5MSA9IHAwWzFdICsgb3ksIHgyID0gcDFbMF0gKyBveCwgeTIgPSBwMVsxXSArIG95LCB4MyA9ICh4MSArIHgyKSAvIDIsIHkzID0gKHkxICsgeTIpIC8gMiwgZHggPSB4MiAtIHgxLCBkeSA9IHkyIC0geTEsIGQyID0gZHggKiBkeCArIGR5ICogZHksIHIgPSByMSAtIHJjLCBEID0geDEgKiB5MiAtIHgyICogeTEsIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIE1hdGguc3FydChNYXRoLm1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSwgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMiwgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLCBkeDAgPSBjeDAgLSB4MywgZHkwID0gY3kwIC0geTMsIGR4MSA9IGN4MSAtIHgzLCBkeTEgPSBjeTEgLSB5MztcbiAgICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcbiAgICByZXR1cm4gWyBbIGN4MCAtIG94LCBjeTAgLSBveSBdLCBbIGN4MCAqIHIxIC8gciwgY3kwICogcjEgLyByIF0gXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZShwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBkZWZpbmVkID0gZDNfdHJ1ZSwgaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUxpbmVhciwgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZS5rZXksIHRlbnNpb24gPSAuNztcbiAgICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBwb2ludHMgPSBbXSwgaSA9IC0xLCBuID0gZGF0YS5sZW5ndGgsIGQsIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpO1xuICAgICAgZnVuY3Rpb24gc2VnbWVudCgpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChcIk1cIiwgaW50ZXJwb2xhdGUocHJvamVjdGlvbihwb2ludHMpLCB0ZW5zaW9uKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZCwgaSksICtmeS5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiKSBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlID0gXzsgZWxzZSBpbnRlcnBvbGF0ZUtleSA9IChpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5nZXQoXykgfHwgZDNfc3ZnX2xpbmVMaW5lYXIpLmtleTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS50ZW5zaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGVuc2lvbjtcbiAgICAgIHRlbnNpb24gPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICBkMy5zdmcubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zdmdfbGluZShkM19pZGVudGl0eSk7XG4gIH07XG4gIHZhciBkM19zdmdfbGluZUludGVycG9sYXRvcnMgPSBkMy5tYXAoe1xuICAgIGxpbmVhcjogZDNfc3ZnX2xpbmVMaW5lYXIsXG4gICAgXCJsaW5lYXItY2xvc2VkXCI6IGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkLFxuICAgIHN0ZXA6IGQzX3N2Z19saW5lU3RlcCxcbiAgICBcInN0ZXAtYmVmb3JlXCI6IGQzX3N2Z19saW5lU3RlcEJlZm9yZSxcbiAgICBcInN0ZXAtYWZ0ZXJcIjogZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIsXG4gICAgYmFzaXM6IGQzX3N2Z19saW5lQmFzaXMsXG4gICAgXCJiYXNpcy1vcGVuXCI6IGQzX3N2Z19saW5lQmFzaXNPcGVuLFxuICAgIFwiYmFzaXMtY2xvc2VkXCI6IGQzX3N2Z19saW5lQmFzaXNDbG9zZWQsXG4gICAgYnVuZGxlOiBkM19zdmdfbGluZUJ1bmRsZSxcbiAgICBjYXJkaW5hbDogZDNfc3ZnX2xpbmVDYXJkaW5hbCxcbiAgICBcImNhcmRpbmFsLW9wZW5cIjogZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4sXG4gICAgXCJjYXJkaW5hbC1jbG9zZWRcIjogZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZCxcbiAgICBtb25vdG9uZTogZDNfc3ZnX2xpbmVNb25vdG9uZVxuICB9KTtcbiAgZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhbHVlLmtleSA9IGtleTtcbiAgICB2YWx1ZS5jbG9zZWQgPSAvLWNsb3NlZCQvLnRlc3Qoa2V5KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoID4gMSA/IHBvaW50cy5qb2luKFwiTFwiKSA6IHBvaW50cyArIFwiWlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMuam9pbihcIkxcIikgKyBcIlpcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXAocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiSFwiLCAocFswXSArIChwID0gcG9pbnRzW2ldKVswXSkgLyAyLCBcIlZcIiwgcFsxXSk7XG4gICAgaWYgKG4gPiAxKSBwYXRoLnB1c2goXCJIXCIsIHBbMF0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwQmVmb3JlKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIlZcIiwgKHAgPSBwb2ludHNbaV0pWzFdLCBcIkhcIiwgcFswXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXBBZnRlcihwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJIXCIsIChwID0gcG9pbnRzW2ldKVswXSwgXCJWXCIsIHBbMV0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4ocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCA0ID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1sxXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMuc2xpY2UoMSwgLTEpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZChwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhckNsb3NlZChwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKChwb2ludHMucHVzaChwb2ludHNbMF0pLCBcbiAgICBwb2ludHMpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMoWyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdIF0uY29uY2F0KHBvaW50cywgWyBwb2ludHNbMV0gXSksIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgdGFuZ2VudHMpIHtcbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoIDwgMSB8fCBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCAmJiBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCArIDIpIHtcbiAgICAgIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIH1cbiAgICB2YXIgcXVhZCA9IHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoLCBwYXRoID0gXCJcIiwgcDAgPSBwb2ludHNbMF0sIHAgPSBwb2ludHNbMV0sIHQwID0gdGFuZ2VudHNbMF0sIHQgPSB0MCwgcGkgPSAxO1xuICAgIGlmIChxdWFkKSB7XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gLSB0MFswXSAqIDIgLyAzKSArIFwiLFwiICsgKHBbMV0gLSB0MFsxXSAqIDIgLyAzKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIHAwID0gcG9pbnRzWzFdO1xuICAgICAgcGkgPSAyO1xuICAgIH1cbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoID4gMSkge1xuICAgICAgdCA9IHRhbmdlbnRzWzFdO1xuICAgICAgcCA9IHBvaW50c1twaV07XG4gICAgICBwaSsrO1xuICAgICAgcGF0aCArPSBcIkNcIiArIChwMFswXSArIHQwWzBdKSArIFwiLFwiICsgKHAwWzFdICsgdDBbMV0pICsgXCIsXCIgKyAocFswXSAtIHRbMF0pICsgXCIsXCIgKyAocFsxXSAtIHRbMV0pICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB0YW5nZW50cy5sZW5ndGg7IGkrKywgcGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW3BpXTtcbiAgICAgICAgdCA9IHRhbmdlbnRzW2ldO1xuICAgICAgICBwYXRoICs9IFwiU1wiICsgKHBbMF0gLSB0WzBdKSArIFwiLFwiICsgKHBbMV0gLSB0WzFdKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWQpIHtcbiAgICAgIHZhciBscCA9IHBvaW50c1twaV07XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gKyB0WzBdICogMiAvIDMpICsgXCIsXCIgKyAocFsxXSArIHRbMV0gKiAyIC8gMykgKyBcIixcIiArIGxwWzBdICsgXCIsXCIgKyBscFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBhID0gKDEgLSB0ZW5zaW9uKSAvIDIsIHAwLCBwMSA9IHBvaW50c1swXSwgcDIgPSBwb2ludHNbMV0sIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHBvaW50c1tpXTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBhICogKHAyWzBdIC0gcDBbMF0pLCBhICogKHAyWzFdIC0gcDBbMV0pIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFuZ2VudHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpcyhwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpID0gcG9pbnRzWzBdLCB4MCA9IHBpWzBdLCB5MCA9IHBpWzFdLCBweCA9IFsgeDAsIHgwLCB4MCwgKHBpID0gcG9pbnRzWzFdKVswXSBdLCBweSA9IFsgeTAsIHkwLCB5MCwgcGlbMV0gXSwgcGF0aCA9IFsgeDAsIFwiLFwiLCB5MCwgXCJMXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkgXTtcbiAgICBwb2ludHMucHVzaChwb2ludHNbbiAtIDFdKTtcbiAgICB3aGlsZSAoKytpIDw9IG4pIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICBwb2ludHMucG9wKCk7XG4gICAgcGF0aC5wdXNoKFwiTFwiLCBwaSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzT3Blbihwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDQpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBwYXRoID0gW10sIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpLCBweCA9IFsgMCBdLCBweSA9IFsgMCBdO1xuICAgIHdoaWxlICgrK2kgPCAzKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgfVxuICAgIHBhdGgucHVzaChkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSArIFwiLFwiICsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkpO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc0Nsb3NlZChwb2ludHMpIHtcbiAgICB2YXIgcGF0aCwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgbSA9IG4gKyA0LCBwaSwgcHggPSBbXSwgcHkgPSBbXTtcbiAgICB3aGlsZSAoKytpIDwgNCkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICB9XG4gICAgcGF0aCA9IFsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSBdO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbSkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQnVuZGxlKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciB4MCA9IHBvaW50c1swXVswXSwgeTAgPSBwb2ludHNbMF1bMV0sIGR4ID0gcG9pbnRzW25dWzBdIC0geDAsIGR5ID0gcG9pbnRzW25dWzFdIC0geTAsIGkgPSAtMSwgcCwgdDtcbiAgICAgIHdoaWxlICgrK2kgPD0gbikge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICB0ID0gaSAvIG47XG4gICAgICAgIHBbMF0gPSB0ZW5zaW9uICogcFswXSArICgxIC0gdGVuc2lvbikgKiAoeDAgKyB0ICogZHgpO1xuICAgICAgICBwWzFdID0gdGVuc2lvbiAqIHBbMV0gKyAoMSAtIHRlbnNpb24pICogKHkwICsgdCAqIGR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lQmFzaXMocG9pbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZURvdDQoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbiAgfVxuICB2YXIgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEgPSBbIDAsIDIgLyAzLCAxIC8gMywgMCBdLCBkM19zdmdfbGluZUJhc2lzQmV6aWVyMiA9IFsgMCwgMSAvIDMsIDIgLyAzLCAwIF0sIGQzX3N2Z19saW5lQmFzaXNCZXppZXIzID0gWyAwLCAxIC8gNiwgMiAvIDMsIDEgLyA2IF07XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgeCwgeSkge1xuICAgIHBhdGgucHVzaChcIkNcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIxLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMSwgeSksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIyLCB5KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHkpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVNsb3BlKHAwLCBwMSkge1xuICAgIHJldHVybiAocDFbMV0gLSBwMFsxXSkgLyAocDFbMF0gLSBwMFswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIGogPSBwb2ludHMubGVuZ3RoIC0gMSwgbSA9IFtdLCBwMCA9IHBvaW50c1swXSwgcDEgPSBwb2ludHNbMV0sIGQgPSBtWzBdID0gZDNfc3ZnX2xpbmVTbG9wZShwMCwgcDEpO1xuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBtW2ldID0gKGQgKyAoZCA9IGQzX3N2Z19saW5lU2xvcGUocDAgPSBwMSwgcDEgPSBwb2ludHNbaSArIDFdKSkpIC8gMjtcbiAgICB9XG4gICAgbVtpXSA9IGQ7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVNb25vdG9uZVRhbmdlbnRzKHBvaW50cykge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBkLCBhLCBiLCBzLCBtID0gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpLCBpID0gLTEsIGogPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgZCA9IGQzX3N2Z19saW5lU2xvcGUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIGlmIChhYnMoZCkgPCDOtSkge1xuICAgICAgICBtW2ldID0gbVtpICsgMV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IG1baV0gLyBkO1xuICAgICAgICBiID0gbVtpICsgMV0gLyBkO1xuICAgICAgICBzID0gYSAqIGEgKyBiICogYjtcbiAgICAgICAgaWYgKHMgPiA5KSB7XG4gICAgICAgICAgcyA9IGQgKiAzIC8gTWF0aC5zcXJ0KHMpO1xuICAgICAgICAgIG1baV0gPSBzICogYTtcbiAgICAgICAgICBtW2kgKyAxXSA9IHMgKiBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgIHMgPSAocG9pbnRzW01hdGgubWluKGosIGkgKyAxKV1bMF0gLSBwb2ludHNbTWF0aC5tYXgoMCwgaSAtIDEpXVswXSkgLyAoNiAqICgxICsgbVtpXSAqIG1baV0pKTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBzIHx8IDAsIG1baV0gKiBzIHx8IDAgXSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZU1vbm90b25lKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZU1vbm90b25lVGFuZ2VudHMocG9pbnRzKSk7XG4gIH1cbiAgZDMuc3ZnLmxpbmUucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbmUgPSBkM19zdmdfbGluZShkM19zdmdfbGluZVJhZGlhbCk7XG4gICAgbGluZS5yYWRpdXMgPSBsaW5lLngsIGRlbGV0ZSBsaW5lLng7XG4gICAgbGluZS5hbmdsZSA9IGxpbmUueSwgZGVsZXRlIGxpbmUueTtcbiAgICByZXR1cm4gbGluZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVSYWRpYWwocG9pbnRzKSB7XG4gICAgdmFyIHBvaW50LCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCByLCBhO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHIgPSBwb2ludFswXTtcbiAgICAgIGEgPSBwb2ludFsxXSAtIGhhbGbPgDtcbiAgICAgIHBvaW50WzBdID0gciAqIE1hdGguY29zKGEpO1xuICAgICAgcG9pbnRbMV0gPSByICogTWF0aC5zaW4oYSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyZWEocHJvamVjdGlvbikge1xuICAgIHZhciB4MCA9IGQzX2dlb21fcG9pbnRYLCB4MSA9IGQzX2dlb21fcG9pbnRYLCB5MCA9IDAsIHkxID0gZDNfZ2VvbV9wb2ludFksIGRlZmluZWQgPSBkM190cnVlLCBpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lTGluZWFyLCBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlLmtleSwgaW50ZXJwb2xhdGVSZXZlcnNlID0gaW50ZXJwb2xhdGUsIEwgPSBcIkxcIiwgdGVuc2lvbiA9IC43O1xuICAgIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHBvaW50czAgPSBbXSwgcG9pbnRzMSA9IFtdLCBpID0gLTEsIG4gPSBkYXRhLmxlbmd0aCwgZCwgZngwID0gZDNfZnVuY3Rvcih4MCksIGZ5MCA9IGQzX2Z1bmN0b3IoeTApLCBmeDEgPSB4MCA9PT0geDEgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9IDogZDNfZnVuY3Rvcih4MSksIGZ5MSA9IHkwID09PSB5MSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHkxKSwgeCwgeTtcbiAgICAgIGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goXCJNXCIsIGludGVycG9sYXRlKHByb2plY3Rpb24ocG9pbnRzMSksIHRlbnNpb24pLCBMLCBpbnRlcnBvbGF0ZVJldmVyc2UocHJvamVjdGlvbihwb2ludHMwLnJldmVyc2UoKSksIHRlbnNpb24pLCBcIlpcIik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50czAucHVzaChbIHggPSArZngwLmNhbGwodGhpcywgZCwgaSksIHkgPSArZnkwLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgICAgcG9pbnRzMS5wdXNoKFsgK2Z4MS5jYWxsKHRoaXMsIGQsIGkpLCArZnkxLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzMC5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzMCA9IFtdO1xuICAgICAgICAgIHBvaW50czEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvaW50czAubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDAgPSB4MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MDtcbiAgICAgIHgwID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkwID0geTEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTA7XG4gICAgICB5MCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmaW5lZDtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGVLZXk7XG4gICAgICBpZiAodHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIikgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZSA9IF87IGVsc2UgaW50ZXJwb2xhdGVLZXkgPSAoaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZ2V0KF8pIHx8IGQzX3N2Z19saW5lTGluZWFyKS5rZXk7XG4gICAgICBpbnRlcnBvbGF0ZVJldmVyc2UgPSBpbnRlcnBvbGF0ZS5yZXZlcnNlIHx8IGludGVycG9sYXRlO1xuICAgICAgTCA9IGludGVycG9sYXRlLmNsb3NlZCA/IFwiTVwiIDogXCJMXCI7XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEudGVuc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRlbnNpb247XG4gICAgICB0ZW5zaW9uID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbiAgZDNfc3ZnX2xpbmVTdGVwQmVmb3JlLnJldmVyc2UgPSBkM19zdmdfbGluZVN0ZXBBZnRlcjtcbiAgZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIucmV2ZXJzZSA9IGQzX3N2Z19saW5lU3RlcEJlZm9yZTtcbiAgZDMuc3ZnLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc3ZnX2FyZWEoZDNfaWRlbnRpdHkpO1xuICB9O1xuICBkMy5zdmcuYXJlYS5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYSA9IGQzX3N2Z19hcmVhKGQzX3N2Z19saW5lUmFkaWFsKTtcbiAgICBhcmVhLnJhZGl1cyA9IGFyZWEueCwgZGVsZXRlIGFyZWEueDtcbiAgICBhcmVhLmlubmVyUmFkaXVzID0gYXJlYS54MCwgZGVsZXRlIGFyZWEueDA7XG4gICAgYXJlYS5vdXRlclJhZGl1cyA9IGFyZWEueDEsIGRlbGV0ZSBhcmVhLngxO1xuICAgIGFyZWEuYW5nbGUgPSBhcmVhLnksIGRlbGV0ZSBhcmVhLnk7XG4gICAgYXJlYS5zdGFydEFuZ2xlID0gYXJlYS55MCwgZGVsZXRlIGFyZWEueTA7XG4gICAgYXJlYS5lbmRBbmdsZSA9IGFyZWEueTEsIGRlbGV0ZSBhcmVhLnkxO1xuICAgIHJldHVybiBhcmVhO1xuICB9O1xuICBkMy5zdmcuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCB0YXJnZXQgPSBkM190YXJnZXQsIHJhZGl1cyA9IGQzX3N2Z19jaG9yZFJhZGl1cywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZTtcbiAgICBmdW5jdGlvbiBjaG9yZChkLCBpKSB7XG4gICAgICB2YXIgcyA9IHN1Ymdyb3VwKHRoaXMsIHNvdXJjZSwgZCwgaSksIHQgPSBzdWJncm91cCh0aGlzLCB0YXJnZXQsIGQsIGkpO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcy5wMCArIGFyYyhzLnIsIHMucDEsIHMuYTEgLSBzLmEwKSArIChlcXVhbHMocywgdCkgPyBjdXJ2ZShzLnIsIHMucDEsIHMuciwgcy5wMCkgOiBjdXJ2ZShzLnIsIHMucDEsIHQuciwgdC5wMCkgKyBhcmModC5yLCB0LnAxLCB0LmExIC0gdC5hMCkgKyBjdXJ2ZSh0LnIsIHQucDEsIHMuciwgcy5wMCkpICsgXCJaXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1Ymdyb3VwKHNlbGYsIGYsIGQsIGkpIHtcbiAgICAgIHZhciBzdWJncm91cCA9IGYuY2FsbChzZWxmLCBkLCBpKSwgciA9IHJhZGl1cy5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSwgYTAgPSBzdGFydEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+ALCBhMSA9IGVuZEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogcixcbiAgICAgICAgYTA6IGEwLFxuICAgICAgICBhMTogYTEsXG4gICAgICAgIHAwOiBbIHIgKiBNYXRoLmNvcyhhMCksIHIgKiBNYXRoLnNpbihhMCkgXSxcbiAgICAgICAgcDE6IFsgciAqIE1hdGguY29zKGExKSwgciAqIE1hdGguc2luKGExKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIGEuYTAgPT0gYi5hMCAmJiBhLmExID09IGIuYTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyYyhyLCBwLCBhKSB7XG4gICAgICByZXR1cm4gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCBcIiArICsoYSA+IM+AKSArIFwiLDEgXCIgKyBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJ2ZShyMCwgcDAsIHIxLCBwMSkge1xuICAgICAgcmV0dXJuIFwiUSAwLDAgXCIgKyBwMTtcbiAgICB9XG4gICAgY2hvcmQucmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFkaXVzO1xuICAgICAgcmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvdXJjZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC50YXJnZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLmVuZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICByZXR1cm4gY2hvcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19jaG9yZFJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQucmFkaXVzO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHRhcmdldCA9IGQzX3RhcmdldCwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb247XG4gICAgZnVuY3Rpb24gZGlhZ29uYWwoZCwgaSkge1xuICAgICAgdmFyIHAwID0gc291cmNlLmNhbGwodGhpcywgZCwgaSksIHAzID0gdGFyZ2V0LmNhbGwodGhpcywgZCwgaSksIG0gPSAocDAueSArIHAzLnkpIC8gMiwgcCA9IFsgcDAsIHtcbiAgICAgICAgeDogcDAueCxcbiAgICAgICAgeTogbVxuICAgICAgfSwge1xuICAgICAgICB4OiBwMy54LFxuICAgICAgICB5OiBtXG4gICAgICB9LCBwMyBdO1xuICAgICAgcCA9IHAubWFwKHByb2plY3Rpb24pO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcFswXSArIFwiQ1wiICsgcFsxXSArIFwiIFwiICsgcFsyXSArIFwiIFwiICsgcFszXTtcbiAgICB9XG4gICAgZGlhZ29uYWwuc291cmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIGRpYWdvbmFsLnRhcmdldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3Rpb24gPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uKGQpIHtcbiAgICByZXR1cm4gWyBkLngsIGQueSBdO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbC5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlhZ29uYWwgPSBkMy5zdmcuZGlhZ29uYWwoKSwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb24sIHByb2plY3Rpb25fID0gZGlhZ29uYWwucHJvamVjdGlvbjtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBwcm9qZWN0aW9uXyhkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24gPSB4KSkgOiBwcm9qZWN0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IHByb2plY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgciA9IGRbMF0sIGEgPSBkWzFdIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgciAqIE1hdGguY29zKGEpLCByICogTWF0aC5zaW4oYSkgXTtcbiAgICB9O1xuICB9XG4gIGQzLnN2Zy5zeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHlwZSA9IGQzX3N2Z19zeW1ib2xUeXBlLCBzaXplID0gZDNfc3ZnX3N5bWJvbFNpemU7XG4gICAgZnVuY3Rpb24gc3ltYm9sKGQsIGkpIHtcbiAgICAgIHJldHVybiAoZDNfc3ZnX3N5bWJvbHMuZ2V0KHR5cGUuY2FsbCh0aGlzLCBkLCBpKSkgfHwgZDNfc3ZnX3N5bWJvbENpcmNsZSkoc2l6ZS5jYWxsKHRoaXMsIGQsIGkpKTtcbiAgICB9XG4gICAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0eXBlO1xuICAgICAgdHlwZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbFNpemUoKSB7XG4gICAgcmV0dXJuIDY0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xUeXBlKCkge1xuICAgIHJldHVybiBcImNpcmNsZVwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xDaXJjbGUoc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyDPgCk7XG4gICAgcmV0dXJuIFwiTTAsXCIgKyByICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIC1yICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIHIgKyBcIlpcIjtcbiAgfVxuICB2YXIgZDNfc3ZnX3N5bWJvbHMgPSBkMy5tYXAoe1xuICAgIGNpcmNsZTogZDNfc3ZnX3N5bWJvbENpcmNsZSxcbiAgICBjcm9zczogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC0zICogciArIFwiLFwiICsgLXIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyAtMyAqIHIgKyBcIkhcIiArIHIgKyBcIlZcIiArIC1yICsgXCJIXCIgKyAzICogciArIFwiVlwiICsgciArIFwiSFwiICsgciArIFwiVlwiICsgMyAqIHIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyByICsgXCJIXCIgKyAtMyAqIHIgKyBcIlpcIjtcbiAgICB9LFxuICAgIGRpYW1vbmQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiBkM19zdmdfc3ltYm9sVGFuMzApKSwgcnggPSByeSAqIGQzX3N2Z19zeW1ib2xUYW4zMDtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgLXJ5ICsgXCJMXCIgKyByeCArIFwiLDBcIiArIFwiIDAsXCIgKyByeSArIFwiIFwiICsgLXJ4ICsgXCIsMFwiICsgXCJaXCI7XG4gICAgfSxcbiAgICBzcXVhcmU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC1yICsgXCIsXCIgKyAtciArIFwiTFwiICsgciArIFwiLFwiICsgLXIgKyBcIiBcIiArIHIgKyBcIixcIiArIHIgKyBcIiBcIiArIC1yICsgXCIsXCIgKyByICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLWRvd25cIjogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBkM19zdmdfc3ltYm9sU3FydDMpLCByeSA9IHJ4ICogZDNfc3ZnX3N5bWJvbFNxcnQzIC8gMjtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcnkgKyBcIkxcIiArIHJ4ICsgXCIsXCIgKyAtcnkgKyBcIiBcIiArIC1yeCArIFwiLFwiICsgLXJ5ICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLXVwXCI6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeCA9IE1hdGguc3FydChzaXplIC8gZDNfc3ZnX3N5bWJvbFNxcnQzKSwgcnkgPSByeCAqIGQzX3N2Z19zeW1ib2xTcXJ0MyAvIDI7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIC1yeSArIFwiTFwiICsgcnggKyBcIixcIiArIHJ5ICsgXCIgXCIgKyAtcnggKyBcIixcIiArIHJ5ICsgXCJaXCI7XG4gICAgfVxuICB9KTtcbiAgZDMuc3ZnLnN5bWJvbFR5cGVzID0gZDNfc3ZnX3N5bWJvbHMua2V5cygpO1xuICB2YXIgZDNfc3ZnX3N5bWJvbFNxcnQzID0gTWF0aC5zcXJ0KDMpLCBkM19zdmdfc3ltYm9sVGFuMzAgPSBNYXRoLnRhbigzMCAqIGQzX3JhZGlhbnMpO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkIHx8ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSksIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgbm9kZSwgdHJhbnNpdGlvbiA9IGQzX3RyYW5zaXRpb25Jbmhlcml0IHx8IHtcbiAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICBlYXNlOiBkM19lYXNlX2N1YmljSW5PdXQsXG4gICAgICBkZWxheTogMCxcbiAgICAgIGR1cmF0aW9uOiAyNTBcbiAgICB9O1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lID09IG51bGwgPyBkM19zZWxlY3Rpb25faW50ZXJydXB0IDogZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSkpKTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQgPSBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMoZDNfdHJhbnNpdGlvbk5hbWVzcGFjZSgpKTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKG5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvY2ssIGFjdGl2ZUlkLCBhY3RpdmU7XG4gICAgICBpZiAoKGxvY2sgPSB0aGlzW25zXSkgJiYgKGFjdGl2ZSA9IGxvY2tbYWN0aXZlSWQgPSBsb2NrLmFjdGl2ZV0pKSB7XG4gICAgICAgIGFjdGl2ZS50aW1lci5jID0gbnVsbDtcbiAgICAgICAgYWN0aXZlLnRpbWVyLnQgPSBOYU47XG4gICAgICAgIGlmICgtLWxvY2suY291bnQpIGRlbGV0ZSBsb2NrW2FjdGl2ZUlkXTsgZWxzZSBkZWxldGUgdGhpc1tuc107XG4gICAgICAgIGxvY2suYWN0aXZlICs9IC41O1xuICAgICAgICBhY3RpdmUuZXZlbnQgJiYgYWN0aXZlLmV2ZW50LmludGVycnVwdC5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGFjdGl2ZS5pbmRleCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uKGdyb3VwcywgbnMsIGlkKSB7XG4gICAgZDNfc3ViY2xhc3MoZ3JvdXBzLCBkM190cmFuc2l0aW9uUHJvdG90eXBlKTtcbiAgICBncm91cHMubmFtZXNwYWNlID0gbnM7XG4gICAgZ3JvdXBzLmlkID0gaWQ7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfdHJhbnNpdGlvblByb3RvdHlwZSA9IFtdLCBkM190cmFuc2l0aW9uSWQgPSAwLCBkM190cmFuc2l0aW9uSW5oZXJpdElkLCBkM190cmFuc2l0aW9uSW5oZXJpdDtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5jYWxsID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGw7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZW1wdHkgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHk7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUubm9kZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcbiAgZDMudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnRyYW5zaXRpb24gPyBkM190cmFuc2l0aW9uSW5oZXJpdElkID8gc2VsZWN0aW9uLnRyYW5zaXRpb24obmFtZSkgOiBzZWxlY3Rpb24gOiBkMy5zZWxlY3Rpb24oKS50cmFuc2l0aW9uKHNlbGVjdGlvbik7XG4gIH07XG4gIGQzLnRyYW5zaXRpb24ucHJvdG90eXBlID0gZDNfdHJhbnNpdGlvblByb3RvdHlwZTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKSB7XG4gICAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgICBkM190cmFuc2l0aW9uTm9kZShzdWJub2RlLCBpLCBucywgaWQsIG5vZGVbbnNdW2lkXSk7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZXMsIG5vZGUsIHN1Ym5vZGUsIHRyYW5zaXRpb247XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZF07XG4gICAgICAgICAgc3Vibm9kZXMgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAtMSwgbyA9IHN1Ym5vZGVzLmxlbmd0aDsgKytrIDwgbzsgKSB7XG4gICAgICAgICAgICBpZiAoc3Vibm9kZSA9IHN1Ym5vZGVzW2tdKSBkM190cmFuc2l0aW9uTm9kZShzdWJub2RlLCBrLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIGZpbHRlci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMubmFtZXNwYWNlLCB0aGlzLmlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50d2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHR3ZWVuKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLnR3ZWVuLmdldChuYW1lKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHdlZW4gPT0gbnVsbCA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5yZW1vdmUobmFtZSk7XG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdHdlZW4pO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uX3R3ZWVuKGdyb3VwcywgbmFtZSwgdmFsdWUsIHR3ZWVuKSB7XG4gICAgdmFyIGlkID0gZ3JvdXBzLmlkLCBucyA9IGdyb3Vwcy5uYW1lc3BhY2U7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKGdyb3VwcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHR3ZWVuKHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKTtcbiAgICB9IDogKHZhbHVlID0gdHdlZW4odmFsdWUpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9KSk7XG4gIH1cbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24obmFtZU5TLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lTlMpIHRoaXMuYXR0cih2YWx1ZSwgbmFtZU5TW3ZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGludGVycG9sYXRlID0gbmFtZU5TID09IFwidHJhbnNmb3JtXCIgPyBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGQzX2ludGVycG9sYXRlLCBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lTlMpO1xuICAgIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW4oYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IGF0dHJOdWxsIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuTlMoYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IGF0dHJOdWxsTlMgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJhdHRyLlwiICsgbmFtZU5TLCB2YWx1ZSwgbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5hdHRyVHdlZW4gPSBmdW5jdGlvbihuYW1lTlMsIHR3ZWVuKSB7XG4gICAgdmFyIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWVOUyk7XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGYodCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuTlMoZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIHRoaXMuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIGYodCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHdlZW4oXCJhdHRyLlwiICsgbmFtZU5TLCBuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHByaW9yaXR5IGluIG5hbWUpIHRoaXMuc3R5bGUocHJpb3JpdHksIG5hbWVbcHJpb3JpdHldLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZU51bGwoKSB7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZVN0cmluZyhiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gc3R5bGVOdWxsIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gZDNfd2luZG93KHRoaXMpLmdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBkM19pbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaSh0KSwgcHJpb3JpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUsIHN0eWxlU3RyaW5nKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zdHlsZVR3ZWVuID0gZnVuY3Rpb24obmFtZSwgdHdlZW4sIHByaW9yaXR5KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBwcmlvcml0eSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gc3R5bGVUd2VlbihkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgZDNfd2luZG93KHRoaXMpLmdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgZih0KSwgcHJpb3JpdHkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHdlZW4oXCJzdHlsZS5cIiArIG5hbWUsIHN0eWxlVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSwgZDNfdHJhbnNpdGlvbl90ZXh0KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbl90ZXh0KGIpIHtcbiAgICBpZiAoYiA9PSBudWxsKSBiID0gXCJcIjtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gYjtcbiAgICB9O1xuICB9XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChcImVuZC50cmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAodGhpc1tuc10uY291bnQgPCAyICYmIChwID0gdGhpcy5wYXJlbnROb2RlKSkgcC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZWFzZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gZDMuZWFzZS5hcHBseShkMywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmVhc2UgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmRlbGF5O1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kZWxheSA9ICt2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgIH0gOiAodmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kZWxheSA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmR1cmF0aW9uO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kdXJhdGlvbiA9IE1hdGgubWF4KDEsIHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgIH0gOiAodmFsdWUgPSBNYXRoLm1heCgxLCB2YWx1ZSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kdXJhdGlvbiA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIGluaGVyaXQgPSBkM190cmFuc2l0aW9uSW5oZXJpdCwgaW5oZXJpdElkID0gZDNfdHJhbnNpdGlvbkluaGVyaXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPSBpZDtcbiAgICAgICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0ID0gbm9kZVtuc11baWRdO1xuICAgICAgICAgIHR5cGUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdCA9IGluaGVyaXQ7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPSBpbmhlcml0SWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZF07XG4gICAgICAgICh0cmFuc2l0aW9uLmV2ZW50IHx8ICh0cmFuc2l0aW9uLmV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImludGVycnVwdFwiKSkpLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkMCA9IHRoaXMuaWQsIGlkMSA9ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlLCB0cmFuc2l0aW9uO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkMF07XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkMSwge1xuICAgICAgICAgICAgdGltZTogdHJhbnNpdGlvbi50aW1lLFxuICAgICAgICAgICAgZWFzZTogdHJhbnNpdGlvbi5lYXNlLFxuICAgICAgICAgICAgZGVsYXk6IHRyYW5zaXRpb24uZGVsYXkgKyB0cmFuc2l0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb246IHRyYW5zaXRpb24uZHVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZDEpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PSBudWxsID8gXCJfX3RyYW5zaXRpb25fX1wiIDogXCJfX3RyYW5zaXRpb25fXCIgKyBuYW1lICsgXCJfX1wiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZCwgaW5oZXJpdCkge1xuICAgIHZhciBsb2NrID0gbm9kZVtuc10gfHwgKG5vZGVbbnNdID0ge1xuICAgICAgYWN0aXZlOiAwLFxuICAgICAgY291bnQ6IDBcbiAgICB9KSwgdHJhbnNpdGlvbiA9IGxvY2tbaWRdLCB0aW1lLCB0aW1lciwgZHVyYXRpb24sIGVhc2UsIHR3ZWVucztcbiAgICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgICB2YXIgZGVsYXkgPSB0cmFuc2l0aW9uLmRlbGF5O1xuICAgICAgdGltZXIudCA9IGRlbGF5ICsgdGltZTtcbiAgICAgIGlmIChkZWxheSA8PSBlbGFwc2VkKSByZXR1cm4gc3RhcnQoZWxhcHNlZCAtIGRlbGF5KTtcbiAgICAgIHRpbWVyLmMgPSBzdGFydDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgICAgdmFyIGFjdGl2ZUlkID0gbG9jay5hY3RpdmUsIGFjdGl2ZSA9IGxvY2tbYWN0aXZlSWRdO1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUudGltZXIuYyA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS50aW1lci50ID0gTmFOO1xuICAgICAgICAtLWxvY2suY291bnQ7XG4gICAgICAgIGRlbGV0ZSBsb2NrW2FjdGl2ZUlkXTtcbiAgICAgICAgYWN0aXZlLmV2ZW50ICYmIGFjdGl2ZS5ldmVudC5pbnRlcnJ1cHQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBhY3RpdmUuaW5kZXgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY2FuY2VsSWQgaW4gbG9jaykge1xuICAgICAgICBpZiAoK2NhbmNlbElkIDwgaWQpIHtcbiAgICAgICAgICB2YXIgY2FuY2VsID0gbG9ja1tjYW5jZWxJZF07XG4gICAgICAgICAgY2FuY2VsLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICAgIGNhbmNlbC50aW1lci50ID0gTmFOO1xuICAgICAgICAgIC0tbG9jay5jb3VudDtcbiAgICAgICAgICBkZWxldGUgbG9ja1tjYW5jZWxJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVyLmMgPSB0aWNrO1xuICAgICAgZDNfdGltZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lci5jICYmIHRpY2soZWxhcHNlZCB8fCAxKSkge1xuICAgICAgICAgIHRpbWVyLmMgPSBudWxsO1xuICAgICAgICAgIHRpbWVyLnQgPSBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9LCAwLCB0aW1lKTtcbiAgICAgIGxvY2suYWN0aXZlID0gaWQ7XG4gICAgICB0cmFuc2l0aW9uLmV2ZW50ICYmIHRyYW5zaXRpb24uZXZlbnQuc3RhcnQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgIHR3ZWVucyA9IFtdO1xuICAgICAgdHJhbnNpdGlvbi50d2Vlbi5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID0gdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKSkge1xuICAgICAgICAgIHR3ZWVucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYXNlID0gdHJhbnNpdGlvbi5lYXNlO1xuICAgICAgZHVyYXRpb24gPSB0cmFuc2l0aW9uLmR1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICAgIHZhciB0ID0gZWxhcHNlZCAvIGR1cmF0aW9uLCBlID0gZWFzZSh0KSwgbiA9IHR3ZWVucy5sZW5ndGg7XG4gICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgdHdlZW5zWy0tbl0uY2FsbChub2RlLCBlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ldmVudCAmJiB0cmFuc2l0aW9uLmV2ZW50LmVuZC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpO1xuICAgICAgICBpZiAoLS1sb2NrLmNvdW50KSBkZWxldGUgbG9ja1tpZF07IGVsc2UgZGVsZXRlIG5vZGVbbnNdO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICB0aW1lID0gaW5oZXJpdC50aW1lO1xuICAgICAgdGltZXIgPSBkM190aW1lcihzY2hlZHVsZSwgMCwgdGltZSk7XG4gICAgICB0cmFuc2l0aW9uID0gbG9ja1tpZF0gPSB7XG4gICAgICAgIHR3ZWVuOiBuZXcgZDNfTWFwKCksXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHRpbWVyOiB0aW1lcixcbiAgICAgICAgZGVsYXk6IGluaGVyaXQuZGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2UsXG4gICAgICAgIGluZGV4OiBpXG4gICAgICB9O1xuICAgICAgaW5oZXJpdCA9IG51bGw7XG4gICAgICArK2xvY2suY291bnQ7XG4gICAgfVxuICB9XG4gIGQzLnN2Zy5heGlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKCksIG9yaWVudCA9IGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudCwgaW5uZXJUaWNrU2l6ZSA9IDYsIG91dGVyVGlja1NpemUgPSA2LCB0aWNrUGFkZGluZyA9IDMsIHRpY2tBcmd1bWVudHNfID0gWyAxMCBdLCB0aWNrVmFsdWVzID0gbnVsbCwgdGlja0Zvcm1hdF87XG4gICAgZnVuY3Rpb24gYXhpcyhnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGUsIHNjYWxlMSA9IHRoaXMuX19jaGFydF9fID0gc2NhbGUuY29weSgpO1xuICAgICAgICB2YXIgdGlja3MgPSB0aWNrVmFsdWVzID09IG51bGwgPyBzY2FsZTEudGlja3MgPyBzY2FsZTEudGlja3MuYXBwbHkoc2NhbGUxLCB0aWNrQXJndW1lbnRzXykgOiBzY2FsZTEuZG9tYWluKCkgOiB0aWNrVmFsdWVzLCB0aWNrRm9ybWF0ID0gdGlja0Zvcm1hdF8gPT0gbnVsbCA/IHNjYWxlMS50aWNrRm9ybWF0ID8gc2NhbGUxLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUxLCB0aWNrQXJndW1lbnRzXykgOiBkM19pZGVudGl0eSA6IHRpY2tGb3JtYXRfLCB0aWNrID0gZy5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHRpY2tzLCBzY2FsZTEpLCB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuaW5zZXJ0KFwiZ1wiLCBcIi5kb21haW5cIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKS5zdHlsZShcIm9wYWNpdHlcIiwgzrUpLCB0aWNrRXhpdCA9IGQzLnRyYW5zaXRpb24odGljay5leGl0KCkpLnN0eWxlKFwib3BhY2l0eVwiLCDOtSkucmVtb3ZlKCksIHRpY2tVcGRhdGUgPSBkMy50cmFuc2l0aW9uKHRpY2sub3JkZXIoKSkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpLCB0aWNrU3BhY2luZyA9IE1hdGgubWF4KGlubmVyVGlja1NpemUsIDApICsgdGlja1BhZGRpbmcsIHRpY2tUcmFuc2Zvcm07XG4gICAgICAgIHZhciByYW5nZSA9IGQzX3NjYWxlUmFuZ2Uoc2NhbGUxKSwgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFsgMCBdKSwgcGF0aFVwZGF0ZSA9IChwYXRoLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIiksIFxuICAgICAgICBkMy50cmFuc2l0aW9uKHBhdGgpKTtcbiAgICAgICAgdGlja0VudGVyLmFwcGVuZChcImxpbmVcIik7XG4gICAgICAgIHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuICAgICAgICB2YXIgbGluZUVudGVyID0gdGlja0VudGVyLnNlbGVjdChcImxpbmVcIiksIGxpbmVVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcImxpbmVcIiksIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIikudGV4dCh0aWNrRm9ybWF0KSwgdGV4dEVudGVyID0gdGlja0VudGVyLnNlbGVjdChcInRleHRcIiksIHRleHRVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcInRleHRcIiksIHNpZ24gPSBvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIiA/IC0xIDogMSwgeDEsIHgyLCB5MSwgeTI7XG4gICAgICAgIGlmIChvcmllbnQgPT09IFwiYm90dG9tXCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGQzX3N2Z19heGlzWCwgeDEgPSBcInhcIiwgeTEgPSBcInlcIiwgeDIgPSBcIngyXCIsIHkyID0gXCJ5MlwiO1xuICAgICAgICAgIHRleHQuYXR0cihcImR5XCIsIHNpZ24gPCAwID8gXCIwZW1cIiA6IFwiLjcxZW1cIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgICAgICAgICBwYXRoVXBkYXRlLmF0dHIoXCJkXCIsIFwiTVwiICsgcmFuZ2VbMF0gKyBcIixcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplICsgXCJWMEhcIiArIHJhbmdlWzFdICsgXCJWXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGQzX3N2Z19heGlzWSwgeDEgPSBcInlcIiwgeTEgPSBcInhcIiwgeDIgPSBcInkyXCIsIHkyID0gXCJ4MlwiO1xuICAgICAgICAgIHRleHQuYXR0cihcImR5XCIsIFwiLjMyZW1cIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBzaWduIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpO1xuICAgICAgICAgIHBhdGhVcGRhdGUuYXR0cihcImRcIiwgXCJNXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSArIFwiLFwiICsgcmFuZ2VbMF0gKyBcIkgwVlwiICsgcmFuZ2VbMV0gKyBcIkhcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lRW50ZXIuYXR0cih5Miwgc2lnbiAqIGlubmVyVGlja1NpemUpO1xuICAgICAgICB0ZXh0RW50ZXIuYXR0cih5MSwgc2lnbiAqIHRpY2tTcGFjaW5nKTtcbiAgICAgICAgbGluZVVwZGF0ZS5hdHRyKHgyLCAwKS5hdHRyKHkyLCBzaWduICogaW5uZXJUaWNrU2l6ZSk7XG4gICAgICAgIHRleHRVcGRhdGUuYXR0cih4MSwgMCkuYXR0cih5MSwgc2lnbiAqIHRpY2tTcGFjaW5nKTtcbiAgICAgICAgaWYgKHNjYWxlMS5yYW5nZUJhbmQpIHtcbiAgICAgICAgICB2YXIgeCA9IHNjYWxlMSwgZHggPSB4LnJhbmdlQmFuZCgpIC8gMjtcbiAgICAgICAgICBzY2FsZTAgPSBzY2FsZTEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4geChkKSArIGR4O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGUwLnJhbmdlQmFuZCkge1xuICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrRXhpdC5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMSwgc2NhbGUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aWNrRW50ZXIuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTAsIHNjYWxlMSk7XG4gICAgICAgIHRpY2tVcGRhdGUuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTEsIHNjYWxlMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXhpcy5zY2FsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgICAgc2NhbGUgPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLm9yaWVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICAgIG9yaWVudCA9IHggaW4gZDNfc3ZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQ7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tBcmd1bWVudHNfO1xuICAgICAgdGlja0FyZ3VtZW50c18gPSBkM19hcnJheShhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgICAgdGlja1ZhbHVlcyA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tGb3JtYXRfO1xuICAgICAgdGlja0Zvcm1hdF8gPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFuKSByZXR1cm4gaW5uZXJUaWNrU2l6ZTtcbiAgICAgIGlubmVyVGlja1NpemUgPSAreDtcbiAgICAgIG91dGVyVGlja1NpemUgPSArYXJndW1lbnRzW24gLSAxXTtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5pbm5lclRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW5uZXJUaWNrU2l6ZTtcbiAgICAgIGlubmVyVGlja1NpemUgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5vdXRlclRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0ZXJUaWNrU2l6ZTtcbiAgICAgIG91dGVyVGlja1NpemUgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tQYWRkaW5nO1xuICAgICAgdGlja1BhZGRpbmcgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAmJiBheGlzO1xuICAgIH07XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIHZhciBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQgPSBcImJvdHRvbVwiLCBkM19zdmdfYXhpc09yaWVudHMgPSB7XG4gICAgdG9wOiAxLFxuICAgIHJpZ2h0OiAxLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAxXG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19heGlzWChzZWxlY3Rpb24sIHgwLCB4MSkge1xuICAgIHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciB2MCA9IHgwKGQpO1xuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKGlzRmluaXRlKHYwKSA/IHYwIDogeDEoZCkpICsgXCIsMClcIjtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXhpc1koc2VsZWN0aW9uLCB5MCwgeTEpIHtcbiAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdjAgPSB5MChkKTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKGlzRmluaXRlKHYwKSA/IHYwIDogeTEoZCkpICsgXCIpXCI7XG4gICAgfSk7XG4gIH1cbiAgZDMuc3ZnLmJydXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaChicnVzaCwgXCJicnVzaHN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJicnVzaGVuZFwiKSwgeCA9IG51bGwsIHkgPSBudWxsLCB4RXh0ZW50ID0gWyAwLCAwIF0sIHlFeHRlbnQgPSBbIDAsIDAgXSwgeEV4dGVudERvbWFpbiwgeUV4dGVudERvbWFpbiwgeENsYW1wID0gdHJ1ZSwgeUNsYW1wID0gdHJ1ZSwgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbMF07XG4gICAgZnVuY3Rpb24gYnJ1c2goZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKS5vbihcIm1vdXNlZG93bi5icnVzaFwiLCBicnVzaHN0YXJ0KS5vbihcInRvdWNoc3RhcnQuYnJ1c2hcIiwgYnJ1c2hzdGFydCk7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kID0gZy5zZWxlY3RBbGwoXCIuYmFja2dyb3VuZFwiKS5kYXRhKFsgMCBdKTtcbiAgICAgICAgYmFja2dyb3VuZC5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikuc3R5bGUoXCJjdXJzb3JcIiwgXCJjcm9zc2hhaXJcIik7XG4gICAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudFwiKS5kYXRhKFsgMCBdKS5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiZXh0ZW50XCIpLnN0eWxlKFwiY3Vyc29yXCIsIFwibW92ZVwiKTtcbiAgICAgICAgdmFyIHJlc2l6ZSA9IGcuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5kYXRhKHJlc2l6ZXMsIGQzX2lkZW50aXR5KTtcbiAgICAgICAgcmVzaXplLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgcmVzaXplLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBcInJlc2l6ZSBcIiArIGQ7XG4gICAgICAgIH0pLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZDNfc3ZnX2JydXNoQ3Vyc29yW2RdO1xuICAgICAgICB9KS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gL1tld10kLy50ZXN0KGQpID8gLTMgOiBudWxsO1xuICAgICAgICB9KS5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIC9eW25zXS8udGVzdChkKSA/IC0zIDogbnVsbDtcbiAgICAgICAgfSkuYXR0cihcIndpZHRoXCIsIDYpLmF0dHIoXCJoZWlnaHRcIiwgNikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICByZXNpemUuc3R5bGUoXCJkaXNwbGF5XCIsIGJydXNoLmVtcHR5KCkgPyBcIm5vbmVcIiA6IG51bGwpO1xuICAgICAgICB2YXIgZ1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24oZyksIGJhY2tncm91bmRVcGRhdGUgPSBkMy50cmFuc2l0aW9uKGJhY2tncm91bmQpLCByYW5nZTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICByYW5nZSA9IGQzX3NjYWxlUmFuZ2UoeCk7XG4gICAgICAgICAgYmFja2dyb3VuZFVwZGF0ZS5hdHRyKFwieFwiLCByYW5nZVswXSkuYXR0cihcIndpZHRoXCIsIHJhbmdlWzFdIC0gcmFuZ2VbMF0pO1xuICAgICAgICAgIHJlZHJhd1goZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICByYW5nZSA9IGQzX3NjYWxlUmFuZ2UoeSk7XG4gICAgICAgICAgYmFja2dyb3VuZFVwZGF0ZS5hdHRyKFwieVwiLCByYW5nZVswXSkuYXR0cihcImhlaWdodFwiLCByYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICAgICAgICByZWRyYXdZKGdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlZHJhdyhnVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBicnVzaC5ldmVudCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV2ZW50XyA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyksIGV4dGVudDEgPSB7XG4gICAgICAgICAgeDogeEV4dGVudCxcbiAgICAgICAgICB5OiB5RXh0ZW50LFxuICAgICAgICAgIGk6IHhFeHRlbnREb21haW4sXG4gICAgICAgICAgajogeUV4dGVudERvbWFpblxuICAgICAgICB9LCBleHRlbnQwID0gdGhpcy5fX2NoYXJ0X18gfHwgZXh0ZW50MTtcbiAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSBleHRlbnQxO1xuICAgICAgICBpZiAoZDNfdHJhbnNpdGlvbkluaGVyaXRJZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZWFjaChcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IGV4dGVudDAuaTtcbiAgICAgICAgICAgIHlFeHRlbnREb21haW4gPSBleHRlbnQwLmo7XG4gICAgICAgICAgICB4RXh0ZW50ID0gZXh0ZW50MC54O1xuICAgICAgICAgICAgeUV4dGVudCA9IGV4dGVudDAueTtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS50d2VlbihcImJydXNoOmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHhpID0gZDNfaW50ZXJwb2xhdGVBcnJheSh4RXh0ZW50LCBleHRlbnQxLngpLCB5aSA9IGQzX2ludGVycG9sYXRlQXJyYXkoeUV4dGVudCwgZXh0ZW50MS55KTtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSB5RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHhFeHRlbnQgPSBleHRlbnQxLnggPSB4aSh0KTtcbiAgICAgICAgICAgICAgeUV4dGVudCA9IGV4dGVudDEueSA9IHlpKHQpO1xuICAgICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5lYWNoKFwiZW5kLmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IGV4dGVudDEuaTtcbiAgICAgICAgICAgIHlFeHRlbnREb21haW4gPSBleHRlbnQxLmo7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWRyYXcoZykge1xuICAgICAgZy5zZWxlY3RBbGwoXCIucmVzaXplXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4RXh0ZW50WysvZSQvLnRlc3QoZCldICsgXCIsXCIgKyB5RXh0ZW50WysvXnMvLnRlc3QoZCldICsgXCIpXCI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkcmF3WChnKSB7XG4gICAgICBnLnNlbGVjdChcIi5leHRlbnRcIikuYXR0cihcInhcIiwgeEV4dGVudFswXSk7XG4gICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnQsLm4+cmVjdCwucz5yZWN0XCIpLmF0dHIoXCJ3aWR0aFwiLCB4RXh0ZW50WzFdIC0geEV4dGVudFswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHJhd1koZykge1xuICAgICAgZy5zZWxlY3QoXCIuZXh0ZW50XCIpLmF0dHIoXCJ5XCIsIHlFeHRlbnRbMF0pO1xuICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50LC5lPnJlY3QsLnc+cmVjdFwiKS5hdHRyKFwiaGVpZ2h0XCIsIHlFeHRlbnRbMV0gLSB5RXh0ZW50WzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnJ1c2hzdGFydCgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBldmVudFRhcmdldCA9IGQzLnNlbGVjdChkMy5ldmVudC50YXJnZXQpLCBldmVudF8gPSBldmVudC5vZih0YXJnZXQsIGFyZ3VtZW50cyksIGcgPSBkMy5zZWxlY3QodGFyZ2V0KSwgcmVzaXppbmcgPSBldmVudFRhcmdldC5kYXR1bSgpLCByZXNpemluZ1ggPSAhL14obnxzKSQvLnRlc3QocmVzaXppbmcpICYmIHgsIHJlc2l6aW5nWSA9ICEvXihlfHcpJC8udGVzdChyZXNpemluZykgJiYgeSwgZHJhZ2dpbmcgPSBldmVudFRhcmdldC5jbGFzc2VkKFwiZXh0ZW50XCIpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0YXJnZXQpLCBjZW50ZXIsIG9yaWdpbiA9IGQzLm1vdXNlKHRhcmdldCksIG9mZnNldDtcbiAgICAgIHZhciB3ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyh0YXJnZXQpKS5vbihcImtleWRvd24uYnJ1c2hcIiwga2V5ZG93bikub24oXCJrZXl1cC5icnVzaFwiLCBrZXl1cCk7XG4gICAgICBpZiAoZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgdy5vbihcInRvdWNobW92ZS5icnVzaFwiLCBicnVzaG1vdmUpLm9uKFwidG91Y2hlbmQuYnJ1c2hcIiwgYnJ1c2hlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBicnVzaG1vdmUpLm9uKFwibW91c2V1cC5icnVzaFwiLCBicnVzaGVuZCk7XG4gICAgICB9XG4gICAgICBnLmludGVycnVwdCgpLnNlbGVjdEFsbChcIipcIikuaW50ZXJydXB0KCk7XG4gICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFswXSAtIG9yaWdpblswXTtcbiAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFswXSAtIG9yaWdpblsxXTtcbiAgICAgIH0gZWxzZSBpZiAocmVzaXppbmcpIHtcbiAgICAgICAgdmFyIGV4ID0gKy93JC8udGVzdChyZXNpemluZyksIGV5ID0gKy9ebi8udGVzdChyZXNpemluZyk7XG4gICAgICAgIG9mZnNldCA9IFsgeEV4dGVudFsxIC0gZXhdIC0gb3JpZ2luWzBdLCB5RXh0ZW50WzEgLSBleV0gLSBvcmlnaW5bMV0gXTtcbiAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFtleF07XG4gICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbZXldO1xuICAgICAgfSBlbHNlIGlmIChkMy5ldmVudC5hbHRLZXkpIGNlbnRlciA9IG9yaWdpbi5zbGljZSgpO1xuICAgICAgZy5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5zZWxlY3RBbGwoXCIucmVzaXplXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKTtcbiAgICAgIGQzLnNlbGVjdChcImJvZHlcIikuc3R5bGUoXCJjdXJzb3JcIiwgZXZlbnRUYXJnZXQuc3R5bGUoXCJjdXJzb3JcIikpO1xuICAgICAgZXZlbnRfKHtcbiAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgIH0pO1xuICAgICAgYnJ1c2htb3ZlKCk7XG4gICAgICBmdW5jdGlvbiBrZXlkb3duKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PSAzMikge1xuICAgICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICBvcmlnaW5bMF0gLT0geEV4dGVudFsxXTtcbiAgICAgICAgICAgIG9yaWdpblsxXSAtPSB5RXh0ZW50WzFdO1xuICAgICAgICAgICAgZHJhZ2dpbmcgPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGtleXVwKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PSAzMiAmJiBkcmFnZ2luZyA9PSAyKSB7XG4gICAgICAgICAgb3JpZ2luWzBdICs9IHhFeHRlbnRbMV07XG4gICAgICAgICAgb3JpZ2luWzFdICs9IHlFeHRlbnRbMV07XG4gICAgICAgICAgZHJhZ2dpbmcgPSAwO1xuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnJ1c2htb3ZlKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBkMy5tb3VzZSh0YXJnZXQpLCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgcG9pbnRbMF0gKz0gb2Zmc2V0WzBdO1xuICAgICAgICAgIHBvaW50WzFdICs9IG9mZnNldFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgaWYgKGQzLmV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgaWYgKCFjZW50ZXIpIGNlbnRlciA9IFsgKHhFeHRlbnRbMF0gKyB4RXh0ZW50WzFdKSAvIDIsICh5RXh0ZW50WzBdICsgeUV4dGVudFsxXSkgLyAyIF07XG4gICAgICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50WysocG9pbnRbMF0gPCBjZW50ZXJbMF0pXTtcbiAgICAgICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbKyhwb2ludFsxXSA8IGNlbnRlclsxXSldO1xuICAgICAgICAgIH0gZWxzZSBjZW50ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNpemluZ1ggJiYgbW92ZTEocG9pbnQsIHgsIDApKSB7XG4gICAgICAgICAgcmVkcmF3WChnKTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2l6aW5nWSAmJiBtb3ZlMShwb2ludCwgeSwgMSkpIHtcbiAgICAgICAgICByZWRyYXdZKGcpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICByZWRyYXcoZyk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgIG1vZGU6IGRyYWdnaW5nID8gXCJtb3ZlXCIgOiBcInJlc2l6ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmUxKHBvaW50LCBzY2FsZSwgaSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHNjYWxlKSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXSwgcG9zaXRpb24gPSBvcmlnaW5baV0sIGV4dGVudCA9IGkgPyB5RXh0ZW50IDogeEV4dGVudCwgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgbWluLCBtYXg7XG4gICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgIHIwIC09IHBvc2l0aW9uO1xuICAgICAgICAgIHIxIC09IHNpemUgKyBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBtaW4gPSAoaSA/IHlDbGFtcCA6IHhDbGFtcCkgPyBNYXRoLm1heChyMCwgTWF0aC5taW4ocjEsIHBvaW50W2ldKSkgOiBwb2ludFtpXTtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgbWF4ID0gKG1pbiArPSBwb3NpdGlvbikgKyBzaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjZW50ZXIpIHBvc2l0aW9uID0gTWF0aC5tYXgocjAsIE1hdGgubWluKHIxLCAyICogY2VudGVyW2ldIC0gbWluKSk7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgbWluKSB7XG4gICAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgICBtaW4gPSBwb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4ID0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbnRbMF0gIT0gbWluIHx8IGV4dGVudFsxXSAhPSBtYXgpIHtcbiAgICAgICAgICBpZiAoaSkgeUV4dGVudERvbWFpbiA9IG51bGw7IGVsc2UgeEV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICAgICAgZXh0ZW50WzBdID0gbWluO1xuICAgICAgICAgIGV4dGVudFsxXSA9IG1heDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnJ1c2hlbmQoKSB7XG4gICAgICAgIGJydXNobW92ZSgpO1xuICAgICAgICBnLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgYnJ1c2guZW1wdHkoKSA/IFwibm9uZVwiIDogbnVsbCk7XG4gICAgICAgIGQzLnNlbGVjdChcImJvZHlcIikuc3R5bGUoXCJjdXJzb3JcIiwgbnVsbCk7XG4gICAgICAgIHcub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbnVsbCkub24oXCJtb3VzZXVwLmJydXNoXCIsIG51bGwpLm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIG51bGwpLm9uKFwidG91Y2hlbmQuYnJ1c2hcIiwgbnVsbCkub24oXCJrZXlkb3duLmJydXNoXCIsIG51bGwpLm9uKFwia2V5dXAuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKCk7XG4gICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBicnVzaC54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSB6O1xuICAgICAgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbIXggPDwgMSB8ICF5XTtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IHo7XG4gICAgICByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1sheCA8PCAxIHwgIXldO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guY2xhbXAgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4ICYmIHkgPyBbIHhDbGFtcCwgeUNsYW1wIF0gOiB4ID8geENsYW1wIDogeSA/IHlDbGFtcCA6IG51bGw7XG4gICAgICBpZiAoeCAmJiB5KSB4Q2xhbXAgPSAhIXpbMF0sIHlDbGFtcCA9ICEhelsxXTsgZWxzZSBpZiAoeCkgeENsYW1wID0gISF6OyBlbHNlIGlmICh5KSB5Q2xhbXAgPSAhIXo7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5leHRlbnQgPSBmdW5jdGlvbih6KSB7XG4gICAgICB2YXIgeDAsIHgxLCB5MCwgeTEsIHQ7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeEV4dGVudERvbWFpbikge1xuICAgICAgICAgICAgeDAgPSB4RXh0ZW50RG9tYWluWzBdLCB4MSA9IHhFeHRlbnREb21haW5bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgwID0geEV4dGVudFswXSwgeDEgPSB4RXh0ZW50WzFdO1xuICAgICAgICAgICAgaWYgKHguaW52ZXJ0KSB4MCA9IHguaW52ZXJ0KHgwKSwgeDEgPSB4LmludmVydCh4MSk7XG4gICAgICAgICAgICBpZiAoeDEgPCB4MCkgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgaWYgKHlFeHRlbnREb21haW4pIHtcbiAgICAgICAgICAgIHkwID0geUV4dGVudERvbWFpblswXSwgeTEgPSB5RXh0ZW50RG9tYWluWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MCA9IHlFeHRlbnRbMF0sIHkxID0geUV4dGVudFsxXTtcbiAgICAgICAgICAgIGlmICh5LmludmVydCkgeTAgPSB5LmludmVydCh5MCksIHkxID0geS5pbnZlcnQoeTEpO1xuICAgICAgICAgICAgaWYgKHkxIDwgeTApIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCAmJiB5ID8gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF0gOiB4ID8gWyB4MCwgeDEgXSA6IHkgJiYgWyB5MCwgeTEgXTtcbiAgICAgIH1cbiAgICAgIGlmICh4KSB7XG4gICAgICAgIHgwID0gelswXSwgeDEgPSB6WzFdO1xuICAgICAgICBpZiAoeSkgeDAgPSB4MFswXSwgeDEgPSB4MVswXTtcbiAgICAgICAgeEV4dGVudERvbWFpbiA9IFsgeDAsIHgxIF07XG4gICAgICAgIGlmICh4LmludmVydCkgeDAgPSB4KHgwKSwgeDEgPSB4KHgxKTtcbiAgICAgICAgaWYgKHgxIDwgeDApIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICAgICAgICBpZiAoeDAgIT0geEV4dGVudFswXSB8fCB4MSAhPSB4RXh0ZW50WzFdKSB4RXh0ZW50ID0gWyB4MCwgeDEgXTtcbiAgICAgIH1cbiAgICAgIGlmICh5KSB7XG4gICAgICAgIHkwID0gelswXSwgeTEgPSB6WzFdO1xuICAgICAgICBpZiAoeCkgeTAgPSB5MFsxXSwgeTEgPSB5MVsxXTtcbiAgICAgICAgeUV4dGVudERvbWFpbiA9IFsgeTAsIHkxIF07XG4gICAgICAgIGlmICh5LmludmVydCkgeTAgPSB5KHkwKSwgeTEgPSB5KHkxKTtcbiAgICAgICAgaWYgKHkxIDwgeTApIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICBpZiAoeTAgIT0geUV4dGVudFswXSB8fCB5MSAhPSB5RXh0ZW50WzFdKSB5RXh0ZW50ID0gWyB5MCwgeTEgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgeEV4dGVudCA9IFsgMCwgMCBdLCB5RXh0ZW50ID0gWyAwLCAwIF07XG4gICAgICAgIHhFeHRlbnREb21haW4gPSB5RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF4ICYmIHhFeHRlbnRbMF0gPT0geEV4dGVudFsxXSB8fCAhIXkgJiYgeUV4dGVudFswXSA9PSB5RXh0ZW50WzFdO1xuICAgIH07XG4gICAgcmV0dXJuIGQzLnJlYmluZChicnVzaCwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIHZhciBkM19zdmdfYnJ1c2hDdXJzb3IgPSB7XG4gICAgbjogXCJucy1yZXNpemVcIixcbiAgICBlOiBcImV3LXJlc2l6ZVwiLFxuICAgIHM6IFwibnMtcmVzaXplXCIsXG4gICAgdzogXCJldy1yZXNpemVcIixcbiAgICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICAgIG5lOiBcIm5lc3ctcmVzaXplXCIsXG4gICAgc2U6IFwibndzZS1yZXNpemVcIixcbiAgICBzdzogXCJuZXN3LXJlc2l6ZVwiXG4gIH07XG4gIHZhciBkM19zdmdfYnJ1c2hSZXNpemVzID0gWyBbIFwiblwiLCBcImVcIiwgXCJzXCIsIFwid1wiLCBcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCIgXSwgWyBcImVcIiwgXCJ3XCIgXSwgWyBcIm5cIiwgXCJzXCIgXSwgW10gXTtcbiAgdmFyIGQzX3RpbWVfZm9ybWF0ID0gZDNfdGltZS5mb3JtYXQgPSBkM19sb2NhbGVfZW5VUy50aW1lRm9ybWF0O1xuICB2YXIgZDNfdGltZV9mb3JtYXRVdGMgPSBkM190aW1lX2Zvcm1hdC51dGM7XG4gIHZhciBkM190aW1lX2Zvcm1hdElzbyA9IGQzX3RpbWVfZm9ybWF0VXRjKFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCIpO1xuICBkM190aW1lX2Zvcm1hdC5pc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIikgPyBkM190aW1lX2Zvcm1hdElzb05hdGl2ZSA6IGQzX3RpbWVfZm9ybWF0SXNvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdElzb05hdGl2ZShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbiAgfVxuICBkM190aW1lX2Zvcm1hdElzb05hdGl2ZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBudWxsIDogZGF0ZTtcbiAgfTtcbiAgZDNfdGltZV9mb3JtYXRJc29OYXRpdmUudG9TdHJpbmcgPSBkM190aW1lX2Zvcm1hdElzby50b1N0cmluZztcbiAgZDNfdGltZS5zZWNvbmQgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoTWF0aC5mbG9vcihkYXRlIC8gMWUzKSAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gIH0pO1xuICBkM190aW1lLnNlY29uZHMgPSBkM190aW1lLnNlY29uZC5yYW5nZTtcbiAgZDNfdGltZS5zZWNvbmRzLnV0YyA9IGQzX3RpbWUuc2Vjb25kLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5taW51dGUgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoTWF0aC5mbG9vcihkYXRlIC8gNmU0KSAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIH0pO1xuICBkM190aW1lLm1pbnV0ZXMgPSBkM190aW1lLm1pbnV0ZS5yYW5nZTtcbiAgZDNfdGltZS5taW51dGVzLnV0YyA9IGQzX3RpbWUubWludXRlLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5ob3VyID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIHRpbWV6b25lID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC8gNjA7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKChNYXRoLmZsb29yKGRhdGUgLyAzNmU1IC0gdGltZXpvbmUpICsgdGltZXpvbmUpICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbiAgfSk7XG4gIGQzX3RpbWUuaG91cnMgPSBkM190aW1lLmhvdXIucmFuZ2U7XG4gIGQzX3RpbWUuaG91cnMudXRjID0gZDNfdGltZS5ob3VyLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5tb250aCA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUgPSBkM190aW1lLmRheShkYXRlKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG4gIH0pO1xuICBkM190aW1lLm1vbnRocyA9IGQzX3RpbWUubW9udGgucmFuZ2U7XG4gIGQzX3RpbWUubW9udGhzLnV0YyA9IGQzX3RpbWUubW9udGgudXRjLnJhbmdlO1xuICBmdW5jdGlvbiBkM190aW1lX3NjYWxlKGxpbmVhciwgbWV0aG9kcywgZm9ybWF0KSB7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcih4KTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfc2NhbGVEYXRlKGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGluZWFyLmRvbWFpbigpLm1hcChkM190aW1lX3NjYWxlRGF0ZSk7XG4gICAgICBsaW5lYXIuZG9tYWluKHgpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdGlja01ldGhvZChleHRlbnQsIGNvdW50KSB7XG4gICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgdGFyZ2V0ID0gc3BhbiAvIGNvdW50LCBpID0gZDMuYmlzZWN0KGQzX3RpbWVfc2NhbGVTdGVwcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiBpID09IGQzX3RpbWVfc2NhbGVTdGVwcy5sZW5ndGggPyBbIG1ldGhvZHMueWVhciwgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGV4dGVudC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIDMxNTM2ZTY7XG4gICAgICB9KSwgY291bnQpWzJdIF0gOiAhaSA/IFsgZDNfdGltZV9zY2FsZU1pbGxpc2Vjb25kcywgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGV4dGVudCwgY291bnQpWzJdIF0gOiBtZXRob2RzW3RhcmdldCAvIGQzX3RpbWVfc2NhbGVTdGVwc1tpIC0gMV0gPCBkM190aW1lX3NjYWxlU3RlcHNbaV0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgIH1cbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHNraXApIHtcbiAgICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW4oKSwgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgbWV0aG9kID0gaW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tNZXRob2QoZXh0ZW50LCAxMCkgOiB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgJiYgdGlja01ldGhvZChleHRlbnQsIGludGVydmFsKTtcbiAgICAgIGlmIChtZXRob2QpIGludGVydmFsID0gbWV0aG9kWzBdLCBza2lwID0gbWV0aG9kWzFdO1xuICAgICAgZnVuY3Rpb24gc2tpcHBlZChkYXRlKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZSkgJiYgIWludGVydmFsLnJhbmdlKGRhdGUsIGQzX3RpbWVfc2NhbGVEYXRlKCtkYXRlICsgMSksIHNraXApLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZS5kb21haW4oZDNfc2NhbGVfbmljZShkb21haW4sIHNraXAgPiAxID8ge1xuICAgICAgICBmbG9vcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHdoaWxlIChza2lwcGVkKGRhdGUgPSBpbnRlcnZhbC5mbG9vcihkYXRlKSkpIGRhdGUgPSBkM190aW1lX3NjYWxlRGF0ZShkYXRlIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNlaWw6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoc2tpcHBlZChkYXRlID0gaW50ZXJ2YWwuY2VpbChkYXRlKSkpIGRhdGUgPSBkM190aW1lX3NjYWxlRGF0ZSgrZGF0ZSArIDEpO1xuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IDogaW50ZXJ2YWwpKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHNraXApIHtcbiAgICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksIG1ldGhvZCA9IGludGVydmFsID09IG51bGwgPyB0aWNrTWV0aG9kKGV4dGVudCwgMTApIDogdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiID8gdGlja01ldGhvZChleHRlbnQsIGludGVydmFsKSA6ICFpbnRlcnZhbC5yYW5nZSAmJiBbIHtcbiAgICAgICAgcmFuZ2U6IGludGVydmFsXG4gICAgICB9LCBza2lwIF07XG4gICAgICBpZiAobWV0aG9kKSBpbnRlcnZhbCA9IG1ldGhvZFswXSwgc2tpcCA9IG1ldGhvZFsxXTtcbiAgICAgIHJldHVybiBpbnRlcnZhbC5yYW5nZShleHRlbnRbMF0sIGQzX3RpbWVfc2NhbGVEYXRlKCtleHRlbnRbMV0gKyAxKSwgc2tpcCA8IDEgPyAxIDogc2tpcCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUobGluZWFyLmNvcHkoKSwgbWV0aG9kcywgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9zY2FsZURhdGUodCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0KTtcbiAgfVxuICB2YXIgZDNfdGltZV9zY2FsZVN0ZXBzID0gWyAxZTMsIDVlMywgMTVlMywgM2U0LCA2ZTQsIDNlNSwgOWU1LCAxOGU1LCAzNmU1LCAxMDhlNSwgMjE2ZTUsIDQzMmU1LCA4NjRlNSwgMTcyOGU1LCA2MDQ4ZTUsIDI1OTJlNiwgNzc3NmU2LCAzMTUzNmU2IF07XG4gIHZhciBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzID0gWyBbIGQzX3RpbWUuc2Vjb25kLCAxIF0sIFsgZDNfdGltZS5zZWNvbmQsIDUgXSwgWyBkM190aW1lLnNlY29uZCwgMTUgXSwgWyBkM190aW1lLnNlY29uZCwgMzAgXSwgWyBkM190aW1lLm1pbnV0ZSwgMSBdLCBbIGQzX3RpbWUubWludXRlLCA1IF0sIFsgZDNfdGltZS5taW51dGUsIDE1IF0sIFsgZDNfdGltZS5taW51dGUsIDMwIF0sIFsgZDNfdGltZS5ob3VyLCAxIF0sIFsgZDNfdGltZS5ob3VyLCAzIF0sIFsgZDNfdGltZS5ob3VyLCA2IF0sIFsgZDNfdGltZS5ob3VyLCAxMiBdLCBbIGQzX3RpbWUuZGF5LCAxIF0sIFsgZDNfdGltZS5kYXksIDIgXSwgWyBkM190aW1lLndlZWssIDEgXSwgWyBkM190aW1lLm1vbnRoLCAxIF0sIFsgZDNfdGltZS5tb250aCwgMyBdLCBbIGQzX3RpbWUueWVhciwgMSBdIF07XG4gIHZhciBkM190aW1lX3NjYWxlTG9jYWxGb3JtYXQgPSBkM190aW1lX2Zvcm1hdC5tdWx0aShbIFsgXCIuJUxcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1pbGxpc2Vjb25kcygpO1xuICB9IF0sIFsgXCI6JVNcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFNlY29uZHMoKTtcbiAgfSBdLCBbIFwiJUk6JU1cIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1pbnV0ZXMoKTtcbiAgfSBdLCBbIFwiJUkgJXBcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldEhvdXJzKCk7XG4gIH0gXSwgWyBcIiVhICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXkoKSAmJiBkLmdldERhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlYiAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiVCXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNb250aCgpO1xuICB9IF0sIFsgXCIlWVwiLCBkM190cnVlIF0gXSk7XG4gIHZhciBkM190aW1lX3NjYWxlTWlsbGlzZWNvbmRzID0ge1xuICAgIHJhbmdlOiBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcCwgK3N0b3AsIHN0ZXApLm1hcChkM190aW1lX3NjYWxlRGF0ZSk7XG4gICAgfSxcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcy55ZWFyID0gZDNfdGltZS55ZWFyO1xuICBkM190aW1lLnNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUoZDMuc2NhbGUubGluZWFyKCksIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMsIGQzX3RpbWVfc2NhbGVMb2NhbEZvcm1hdCk7XG4gIH07XG4gIHZhciBkM190aW1lX3NjYWxlVXRjTWV0aG9kcyA9IGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gWyBtWzBdLnV0YywgbVsxXSBdO1xuICB9KTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVVdGNGb3JtYXQgPSBkM190aW1lX2Zvcm1hdFV0Yy5tdWx0aShbIFsgXCIuJUxcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB9IF0sIFsgXCI6JVNcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ1NlY29uZHMoKTtcbiAgfSBdLCBbIFwiJUk6JU1cIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01pbnV0ZXMoKTtcbiAgfSBdLCBbIFwiJUkgJXBcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0hvdXJzKCk7XG4gIH0gXSwgWyBcIiVhICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXkoKSAmJiBkLmdldFVUQ0RhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlYiAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiVCXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICB9IF0sIFsgXCIlWVwiLCBkM190cnVlIF0gXSk7XG4gIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzLnllYXIgPSBkM190aW1lLnllYXIudXRjO1xuICBkM190aW1lLnNjYWxlLnV0YyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM190aW1lX3NjYWxlKGQzLnNjYWxlLmxpbmVhcigpLCBkM190aW1lX3NjYWxlVXRjTWV0aG9kcywgZDNfdGltZV9zY2FsZVV0Y0Zvcm1hdCk7XG4gIH07XG4gIGQzLnRleHQgPSBkM194aHJUeXBlKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH0pO1xuICBkMy5qc29uID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkM194aHIodXJsLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgZDNfanNvbiwgY2FsbGJhY2spO1xuICB9O1xuICBmdW5jdGlvbiBkM19qc29uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cbiAgZDMuaHRtbCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfeGhyKHVybCwgXCJ0ZXh0L2h0bWxcIiwgZDNfaHRtbCwgY2FsbGJhY2spO1xuICB9O1xuICBmdW5jdGlvbiBkM19odG1sKHJlcXVlc3QpIHtcbiAgICB2YXIgcmFuZ2UgPSBkM19kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGUoZDNfZG9jdW1lbnQuYm9keSk7XG4gICAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cbiAgZDMueG1sID0gZDNfeGhyVHlwZShmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VYTUw7XG4gIH0pO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHRoaXMuZDMgPSBkMywgZGVmaW5lKGQzKTsgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkMzsgZWxzZSB0aGlzLmQzID0gZDM7XG59KCk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9EaXNwYXRjaGVyJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc3BhdGNoZXJcbiAqIFxuICogQHByZXZlbnRNdW5nZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIF9wcmVmaXggPSAnSURfJztcblxuLyoqXG4gKiBEaXNwYXRjaGVyIGlzIHVzZWQgdG8gYnJvYWRjYXN0IHBheWxvYWRzIHRvIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLiBUaGlzIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSBnZW5lcmljIHB1Yi1zdWIgc3lzdGVtcyBpbiB0d28gd2F5czpcbiAqXG4gKiAgIDEpIENhbGxiYWNrcyBhcmUgbm90IHN1YnNjcmliZWQgdG8gcGFydGljdWxhciBldmVudHMuIEV2ZXJ5IHBheWxvYWQgaXNcbiAqICAgICAgZGlzcGF0Y2hlZCB0byBldmVyeSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICogICAyKSBDYWxsYmFja3MgY2FuIGJlIGRlZmVycmVkIGluIHdob2xlIG9yIHBhcnQgdW50aWwgb3RoZXIgY2FsbGJhY2tzIGhhdmVcbiAqICAgICAgYmVlbiBleGVjdXRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhpcyBoeXBvdGhldGljYWwgZmxpZ2h0IGRlc3RpbmF0aW9uIGZvcm0sIHdoaWNoXG4gKiBzZWxlY3RzIGEgZGVmYXVsdCBjaXR5IHdoZW4gYSBjb3VudHJ5IGlzIHNlbGVjdGVkOlxuICpcbiAqICAgdmFyIGZsaWdodERpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcigpO1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY291bnRyeSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ291bnRyeVN0b3JlID0ge2NvdW50cnk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY2l0eSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ2l0eVN0b3JlID0ge2NpdHk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGJhc2UgZmxpZ2h0IHByaWNlIG9mIHRoZSBzZWxlY3RlZCBjaXR5XG4gKiAgIHZhciBGbGlnaHRQcmljZVN0b3JlID0ge3ByaWNlOiBudWxsfVxuICpcbiAqIFdoZW4gYSB1c2VyIGNoYW5nZXMgdGhlIHNlbGVjdGVkIGNpdHksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NpdHktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENpdHk6ICdwYXJpcydcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGBDaXR5U3RvcmVgOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NpdHktdXBkYXRlJykge1xuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBwYXlsb2FkLnNlbGVjdGVkQ2l0eTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvdW50cnksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NvdW50cnktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENvdW50cnk6ICdhdXN0cmFsaWEnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBib3RoIHN0b3JlczpcbiAqXG4gKiAgIENvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgQ291bnRyeVN0b3JlLmNvdW50cnkgPSBwYXlsb2FkLnNlbGVjdGVkQ291bnRyeTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIGNhbGxiYWNrIHRvIHVwZGF0ZSBgQ291bnRyeVN0b3JlYCBpcyByZWdpc3RlcmVkLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgcmV0dXJuZWQgdG9rZW4uIFVzaW5nIHRoaXMgdG9rZW4gd2l0aCBgd2FpdEZvcigpYCwgd2UgY2FuIGd1YXJhbnRlZVxuICogdGhhdCBgQ291bnRyeVN0b3JlYCBpcyB1cGRhdGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgdGhhdCB1cGRhdGVzIGBDaXR5U3RvcmVgXG4gKiBuZWVkcyB0byBxdWVyeSBpdHMgZGF0YS5cbiAqXG4gKiAgIENpdHlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gKiAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogICAgICAgLy8gU2VsZWN0IHRoZSBkZWZhdWx0IGNpdHkgZm9yIHRoZSBuZXcgY291bnRyeVxuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBnZXREZWZhdWx0Q2l0eUZvckNvdW50cnkoQ291bnRyeVN0b3JlLmNvdW50cnkpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIHVzYWdlIG9mIGB3YWl0Rm9yKClgIGNhbiBiZSBjaGFpbmVkLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgIEZsaWdodFByaWNlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9XG4gKiAgICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uVHlwZSkge1xuICogICAgICAgICBjYXNlICdjb3VudHJ5LXVwZGF0ZSc6XG4gKiAgICAgICAgIGNhc2UgJ2NpdHktdXBkYXRlJzpcbiAqICAgICAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NpdHlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZS5wcmljZSA9XG4gKiAgICAgICAgICAgICBnZXRGbGlnaHRQcmljZVN0b3JlKENvdW50cnlTdG9yZS5jb3VudHJ5LCBDaXR5U3RvcmUuY2l0eSk7XG4gKiAgICAgICAgICAgYnJlYWs7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgYGNvdW50cnktdXBkYXRlYCBwYXlsb2FkIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBpbnZva2UgdGhlIHN0b3JlcydcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIGluIG9yZGVyOiBgQ291bnRyeVN0b3JlYCwgYENpdHlTdG9yZWAsIHRoZW5cbiAqIGBGbGlnaHRQcmljZVN0b3JlYC5cbiAqL1xuXG52YXIgRGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpc3BhdGNoZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzSGFuZGxlZCA9IHt9O1xuICAgIHRoaXMuX2lzUGVuZGluZyA9IHt9O1xuICAgIHRoaXMuX2xhc3RJRCA9IDE7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aXRoIGV2ZXJ5IGRpc3BhdGNoZWQgcGF5bG9hZC4gUmV0dXJuc1xuICAgKiBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgd2FpdEZvcigpYC5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IF9wcmVmaXggKyB0aGlzLl9sYXN0SUQrKztcbiAgICB0aGlzLl9jYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgYmFzZWQgb24gaXRzIHRva2VuLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihpZCkge1xuICAgICF0aGlzLl9jYWxsYmFja3NbaWRdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIudW5yZWdpc3RlciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBjYWxsYmFja3Mgc3BlY2lmaWVkIHRvIGJlIGludm9rZWQgYmVmb3JlIGNvbnRpbnVpbmcgZXhlY3V0aW9uXG4gICAqIG9mIHRoZSBjdXJyZW50IGNhbGxiYWNrLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IGEgY2FsbGJhY2sgaW5cbiAgICogcmVzcG9uc2UgdG8gYSBkaXNwYXRjaGVkIHBheWxvYWQuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiB3YWl0Rm9yKGlkcykge1xuICAgICF0aGlzLl9pc0Rpc3BhdGNoaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBNdXN0IGJlIGludm9rZWQgd2hpbGUgZGlzcGF0Y2hpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpZHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaWldO1xuICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgIXRoaXMuX2lzSGFuZGxlZFtpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgJyArICd3YWl0aW5nIGZvciBgJXNgLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgIXRoaXMuX2NhbGxiYWNrc1tpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIHBheWxvYWQgdG8gYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKHBheWxvYWQpIHtcbiAgICAhIXRoaXMuX2lzRGlzcGF0Y2hpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2guZGlzcGF0Y2goLi4uKTogQ2Fubm90IGRpc3BhdGNoIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9zdG9wRGlzcGF0Y2hpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgRGlzcGF0Y2hlciBjdXJyZW50bHkgZGlzcGF0Y2hpbmcuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmlzRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBpc0Rpc3BhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Rpc3BhdGNoaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjYWxsYmFjayBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWQuIEFsc28gZG8gc29tZSBpbnRlcm5hbFxuICAgKiBib29ra2VlcGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9pbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uIF9pbnZva2VDYWxsYmFjayhpZCkge1xuICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0odGhpcy5fcGVuZGluZ1BheWxvYWQpO1xuICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgYm9va2tlZXBpbmcgbmVlZGVkIHdoZW4gZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5fc3RhcnREaXNwYXRjaGluZyA9IGZ1bmN0aW9uIF9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpIHtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ1BheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBib29ra2VlcGluZyB1c2VkIGZvciBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9zdG9wRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBfc3RvcERpc3BhdGNoaW5nKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUGF5bG9hZDtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIERpc3BhdGNoZXI7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignSW52YXJpYW50IFZpb2xhdGlvbjogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7IiwiLyoqXG4gKiBJbnRyby5qcyB2MS4xLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS91c2FibGljYS9pbnRyby5qc1xuICogTUlUIGxpY2Vuc2VkXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEzIHVzYWJsaS5jYSAtIEEgd2Vla2VuZCBwcm9qZWN0IGJ5IEFmc2hpbiBNZWhyYWJhbmkgKEBhZnNoaW5tZWgpXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBDb21tb25KU1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeShyb290KTtcbiAgfVxufSAodGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgLy9EZWZhdWx0IGNvbmZpZy92YXJpYWJsZXNcbiAgdmFyIFZFUlNJT04gPSAnMS4xLjEnO1xuXG4gIC8qKlxuICAgKiBJbnRyb0pzIG1haW4gY2xhc3NcbiAgICpcbiAgICogQGNsYXNzIEludHJvSnNcbiAgICovXG4gIGZ1bmN0aW9uIEludHJvSnMob2JqKSB7XG4gICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IG9iajtcblxuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAvKiBOZXh0IGJ1dHRvbiBsYWJlbCBpbiB0b29sdGlwIGJveCAqL1xuICAgICAgbmV4dExhYmVsOiAnTmV4dCAmcmFycjsnLFxuICAgICAgLyogUHJldmlvdXMgYnV0dG9uIGxhYmVsIGluIHRvb2x0aXAgYm94ICovXG4gICAgICBwcmV2TGFiZWw6ICcmbGFycjsgQmFjaycsXG4gICAgICAvKiBTa2lwIGJ1dHRvbiBsYWJlbCBpbiB0b29sdGlwIGJveCAqL1xuICAgICAgc2tpcExhYmVsOiAnU2tpcCcsXG4gICAgICAvKiBEb25lIGJ1dHRvbiBsYWJlbCBpbiB0b29sdGlwIGJveCAqL1xuICAgICAgZG9uZUxhYmVsOiAnRG9uZScsXG4gICAgICAvKiBEZWZhdWx0IHRvb2x0aXAgYm94IHBvc2l0aW9uICovXG4gICAgICB0b29sdGlwUG9zaXRpb246ICdib3R0b20nLFxuICAgICAgLyogTmV4dCBDU1MgY2xhc3MgZm9yIHRvb2x0aXAgYm94ZXMgKi9cbiAgICAgIHRvb2x0aXBDbGFzczogJycsXG4gICAgICAvKiBDU1MgY2xhc3MgdGhhdCBpcyBhZGRlZCB0byB0aGUgaGVscGVyTGF5ZXIgKi9cbiAgICAgIGhpZ2hsaWdodENsYXNzOiAnJyxcbiAgICAgIC8qIENsb3NlIGludHJvZHVjdGlvbiB3aGVuIHByZXNzaW5nIEVzY2FwZSBidXR0b24/ICovXG4gICAgICBleGl0T25Fc2M6IHRydWUsXG4gICAgICAvKiBDbG9zZSBpbnRyb2R1Y3Rpb24gd2hlbiBjbGlja2luZyBvbiBvdmVybGF5IGxheWVyPyAqL1xuICAgICAgZXhpdE9uT3ZlcmxheUNsaWNrOiB0cnVlLFxuICAgICAgLyogU2hvdyBzdGVwIG51bWJlcnMgaW4gaW50cm9kdWN0aW9uPyAqL1xuICAgICAgc2hvd1N0ZXBOdW1iZXJzOiB0cnVlLFxuICAgICAgLyogTGV0IHVzZXIgdXNlIGtleWJvYXJkIHRvIG5hdmlnYXRlIHRoZSB0b3VyPyAqL1xuICAgICAga2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuICAgICAgLyogU2hvdyB0b3VyIGNvbnRyb2wgYnV0dG9ucz8gKi9cbiAgICAgIHNob3dCdXR0b25zOiB0cnVlLFxuICAgICAgLyogU2hvdyB0b3VyIGJ1bGxldHM/ICovXG4gICAgICBzaG93QnVsbGV0czogdHJ1ZSxcbiAgICAgIC8qIFNob3cgdG91ciBwcm9ncmVzcz8gKi9cbiAgICAgIHNob3dQcm9ncmVzczogZmFsc2UsXG4gICAgICAvKiBTY3JvbGwgdG8gaGlnaGxpZ2h0ZWQgZWxlbWVudD8gKi9cbiAgICAgIHNjcm9sbFRvRWxlbWVudDogdHJ1ZSxcbiAgICAgIC8qIFNldCB0aGUgb3ZlcmxheSBvcGFjaXR5ICovXG4gICAgICBvdmVybGF5T3BhY2l0eTogMC44LFxuICAgICAgLyogUHJlY2VkZW5jZSBvZiBwb3NpdGlvbnMsIHdoZW4gYXV0byBpcyBlbmFibGVkICovXG4gICAgICBwb3NpdGlvblByZWNlZGVuY2U6IFtcImJvdHRvbVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwibGVmdFwiXSxcbiAgICAgIC8qIERpc2FibGUgYW4gaW50ZXJhY3Rpb24gd2l0aCBlbGVtZW50PyAqL1xuICAgICAgZGlzYWJsZUludGVyYWN0aW9uOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGUgYSBuZXcgaW50cm9kdWN0aW9uL2d1aWRlIGZyb20gYW4gZWxlbWVudCBpbiB0aGUgcGFnZVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfaW50cm9Gb3JFbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRFbG1cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFN1Y2Nlc3Mgb3Igbm90P1xuICAgKi9cbiAgZnVuY3Rpb24gX2ludHJvRm9yRWxlbWVudCh0YXJnZXRFbG0pIHtcbiAgICB2YXIgaW50cm9JdGVtcyA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnN0ZXBzKSB7XG4gICAgICAvL3VzZSBzdGVwcyBwYXNzZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHN0ZXBzTGVuZ3RoID0gdGhpcy5fb3B0aW9ucy5zdGVwcy5sZW5ndGg7IGkgPCBzdGVwc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50SXRlbSA9IF9jbG9uZU9iamVjdCh0aGlzLl9vcHRpb25zLnN0ZXBzW2ldKTtcbiAgICAgICAgLy9zZXQgdGhlIHN0ZXBcbiAgICAgICAgY3VycmVudEl0ZW0uc3RlcCA9IGludHJvSXRlbXMubGVuZ3RoICsgMTtcbiAgICAgICAgLy91c2UgcXVlcnlTZWxlY3RvciBmdW5jdGlvbiBvbmx5IHdoZW4gZGV2ZWxvcGVyIHVzZWQgQ1NTIHNlbGVjdG9yXG4gICAgICAgIGlmICh0eXBlb2YoY3VycmVudEl0ZW0uZWxlbWVudCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy9ncmFiIHRoZSBlbGVtZW50IHdpdGggZ2l2ZW4gc2VsZWN0b3IgZnJvbSB0aGUgcGFnZVxuICAgICAgICAgIGN1cnJlbnRJdGVtLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGN1cnJlbnRJdGVtLmVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbnRybyB3aXRob3V0IGVsZW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZihjdXJyZW50SXRlbS5lbGVtZW50KSA9PT0gJ3VuZGVmaW5lZCcgfHwgY3VycmVudEl0ZW0uZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZsb2F0aW5nRWxlbWVudFF1ZXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5pbnRyb2pzRmxvYXRpbmdFbGVtZW50XCIpO1xuXG4gICAgICAgICAgaWYgKGZsb2F0aW5nRWxlbWVudFF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZsb2F0aW5nRWxlbWVudFF1ZXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBmbG9hdGluZ0VsZW1lbnRRdWVyeS5jbGFzc05hbWUgPSAnaW50cm9qc0Zsb2F0aW5nRWxlbWVudCc7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZmxvYXRpbmdFbGVtZW50UXVlcnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRJdGVtLmVsZW1lbnQgID0gZmxvYXRpbmdFbGVtZW50UXVlcnk7XG4gICAgICAgICAgY3VycmVudEl0ZW0ucG9zaXRpb24gPSAnZmxvYXRpbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGludHJvSXRlbXMucHVzaChjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvL3VzZSBzdGVwcyBmcm9tIGRhdGEtKiBhbm5vdGF0aW9uc1xuICAgICAgdmFyIGFsbEludHJvU3RlcHMgPSB0YXJnZXRFbG0ucXVlcnlTZWxlY3RvckFsbCgnKltkYXRhLWludHJvXScpO1xuICAgICAgLy9pZiB0aGVyZSdzIG5vIGVsZW1lbnQgdG8gaW50cm9cbiAgICAgIGlmIChhbGxJbnRyb1N0ZXBzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2ZpcnN0IGFkZCBpbnRybyBpdGVtcyB3aXRoIGRhdGEtc3RlcFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGVsbXNMZW5ndGggPSBhbGxJbnRyb1N0ZXBzLmxlbmd0aDsgaSA8IGVsbXNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBhbGxJbnRyb1N0ZXBzW2ldO1xuICAgICAgICB2YXIgc3RlcCA9IHBhcnNlSW50KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGVwJyksIDEwKTtcblxuICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICBpbnRyb0l0ZW1zW3N0ZXAgLSAxXSA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGN1cnJlbnRFbGVtZW50LFxuICAgICAgICAgICAgaW50cm86IGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbnRybycpLFxuICAgICAgICAgICAgc3RlcDogcGFyc2VJbnQoY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0ZXAnKSwgMTApLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiBjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcENsYXNzJyksXG4gICAgICAgICAgICBoaWdobGlnaHRDbGFzczogY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWhpZ2hsaWdodENsYXNzJyksXG4gICAgICAgICAgICBwb3NpdGlvbjogY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBvc2l0aW9uJykgfHwgdGhpcy5fb3B0aW9ucy50b29sdGlwUG9zaXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vbmV4dCBhZGQgaW50cm8gaXRlbXMgd2l0aG91dCBkYXRhLXN0ZXBcbiAgICAgIC8vdG9kbzogd2UgbmVlZCBhIGNsZWFudXAgaGVyZSwgdHdvIGxvb3BzIGFyZSByZWR1bmRhbnRcbiAgICAgIHZhciBuZXh0U3RlcCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZWxtc0xlbmd0aCA9IGFsbEludHJvU3RlcHMubGVuZ3RoOyBpIDwgZWxtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IGFsbEludHJvU3RlcHNbaV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGVwJykgPT0gbnVsbCkge1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW50cm9JdGVtc1tuZXh0U3RlcF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0U3RlcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGludHJvSXRlbXNbbmV4dFN0ZXBdID0ge1xuICAgICAgICAgICAgZWxlbWVudDogY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgICBpbnRybzogY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWludHJvJyksXG4gICAgICAgICAgICBzdGVwOiBuZXh0U3RlcCArIDEsXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6IGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwQ2xhc3MnKSxcbiAgICAgICAgICAgIGhpZ2hsaWdodENsYXNzOiBjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGlnaGxpZ2h0Q2xhc3MnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zaXRpb24nKSB8fCB0aGlzLl9vcHRpb25zLnRvb2x0aXBQb3NpdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3JlbW92aW5nIHVuZGVmaW5lZC9udWxsIGVsZW1lbnRzXG4gICAgdmFyIHRlbXBJbnRyb0l0ZW1zID0gW107XG4gICAgZm9yICh2YXIgeiA9IDA7IHogPCBpbnRyb0l0ZW1zLmxlbmd0aDsgeisrKSB7XG4gICAgICBpbnRyb0l0ZW1zW3pdICYmIHRlbXBJbnRyb0l0ZW1zLnB1c2goaW50cm9JdGVtc1t6XSk7ICAvLyBjb3B5IG5vbi1lbXB0eSB2YWx1ZXMgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICB9XG5cbiAgICBpbnRyb0l0ZW1zID0gdGVtcEludHJvSXRlbXM7XG5cbiAgICAvL09rLCBzb3J0IGFsbCBpdGVtcyB3aXRoIGdpdmVuIHN0ZXBzXG4gICAgaW50cm9JdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zdGVwIC0gYi5zdGVwO1xuICAgIH0pO1xuXG4gICAgLy9zZXQgaXQgdG8gdGhlIGludHJvSnMgb2JqZWN0XG4gICAgc2VsZi5faW50cm9JdGVtcyA9IGludHJvSXRlbXM7XG5cbiAgICAvL2FkZCBvdmVybGF5IGxheWVyIHRvIHRoZSBwYWdlXG4gICAgaWYoX2FkZE92ZXJsYXlMYXllci5jYWxsKHNlbGYsIHRhcmdldEVsbSkpIHtcbiAgICAgIC8vdGhlbiwgc3RhcnQgdGhlIHNob3dcbiAgICAgIF9uZXh0U3RlcC5jYWxsKHNlbGYpO1xuXG4gICAgICB2YXIgc2tpcEJ1dHRvbiAgICAgPSB0YXJnZXRFbG0ucXVlcnlTZWxlY3RvcignLmludHJvanMtc2tpcGJ1dHRvbicpLFxuICAgICAgICAgIG5leHRTdGVwQnV0dG9uID0gdGFyZ2V0RWxtLnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLW5leHRidXR0b24nKTtcblxuICAgICAgc2VsZi5fb25LZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiBzZWxmLl9vcHRpb25zLmV4aXRPbkVzYyA9PSB0cnVlKSB7XG4gICAgICAgICAgLy9lc2NhcGUga2V5IHByZXNzZWQsIGV4aXQgdGhlIGludHJvXG4gICAgICAgICAgLy9jaGVjayBpZiBleGl0IGNhbGxiYWNrIGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoc2VsZi5faW50cm9FeGl0Q2FsbGJhY2sgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLl9pbnRyb0V4aXRDYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZXhpdEludHJvLmNhbGwoc2VsZiwgdGFyZ2V0RWxtKTtcbiAgICAgICAgfSBlbHNlIGlmKGUua2V5Q29kZSA9PT0gMzcpIHtcbiAgICAgICAgICAvL2xlZnQgYXJyb3dcbiAgICAgICAgICBfcHJldmlvdXNTdGVwLmNhbGwoc2VsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzOSkge1xuICAgICAgICAgIC8vcmlnaHQgYXJyb3dcbiAgICAgICAgICBfbmV4dFN0ZXAuY2FsbChzZWxmKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgLy9zcmNFbGVtZW50ID09PSBpZVxuICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ2ludHJvanMtcHJldmJ1dHRvbicpID4gMCkge1xuICAgICAgICAgICAgLy91c2VyIGhpdCBlbnRlciB3aGlsZSBmb2N1c2luZyBvbiBwcmV2aW91cyBidXR0b25cbiAgICAgICAgICAgIF9wcmV2aW91c1N0ZXAuY2FsbChzZWxmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ2ludHJvanMtc2tpcGJ1dHRvbicpID4gMCkge1xuICAgICAgICAgICAgLy91c2VyIGhpdCBlbnRlciB3aGlsZSBmb2N1c2luZyBvbiBza2lwIGJ1dHRvblxuICAgICAgICAgICAgaWYgKHNlbGYuX2ludHJvSXRlbXMubGVuZ3RoIC0gMSA9PSBzZWxmLl9jdXJyZW50U3RlcCAmJiB0eXBlb2YgKHNlbGYuX2ludHJvQ29tcGxldGVDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnRyb0NvbXBsZXRlQ2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgYW55IGNhbGxiYWNrIGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnRyb0V4aXRDYWxsYmFjayAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi5faW50cm9FeGl0Q2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9leGl0SW50cm8uY2FsbChzZWxmLCB0YXJnZXRFbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2RlZmF1bHQgYmVoYXZpb3IgZm9yIHJlc3BvbmRpbmcgdG8gZW50ZXJcbiAgICAgICAgICAgIF9uZXh0U3RlcC5jYWxsKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vcHJldmVudCBkZWZhdWx0IGJlaGF2aW91ciBvbiBoaXR0aW5nIEVudGVyLCB0byBwcmV2ZW50IHN0ZXBzIGJlaW5nIHNraXBwZWQgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICAgIGlmKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5fb25SZXNpemUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwoc2VsZiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtaGVscGVyTGF5ZXInKSk7XG4gICAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwoc2VsZiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJykpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2VsZi5fb25LZXlEb3duLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvciB3aW5kb3cgcmVzaXplXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZWxmLl9vblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7IC8vSUVcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5ZG93bicsIHNlbGYuX29uS2V5RG93bik7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3Igd2luZG93IHJlc2l6ZVxuICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZXNpemUnLCBzZWxmLl9vblJlc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gLypcbiAgICogbWFrZXMgYSBjb3B5IG9mIHRoZSBvYmplY3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX2Nsb25lT2JqZWN0XG4gICovXG4gIGZ1bmN0aW9uIF9jbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCB8fCB0eXBlb2YgKG9iamVjdCkgIT0gJ29iamVjdCcgfHwgdHlwZW9mIChvYmplY3Qubm9kZVR5cGUpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIChqUXVlcnkpICE9ICd1bmRlZmluZWQnICYmIG9iamVjdFtrZXldIGluc3RhbmNlb2YgalF1ZXJ5KSB7XG4gICAgICAgICAgdGVtcFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFtrZXldID0gX2Nsb25lT2JqZWN0KG9iamVjdFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXA7XG4gIH1cbiAgLyoqXG4gICAqIEdvIHRvIHNwZWNpZmljIHN0ZXAgb2YgaW50cm9kdWN0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nb1RvU3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gX2dvVG9TdGVwKHN0ZXApIHtcbiAgICAvL2JlY2F1c2Ugc3RlcHMgc3RhcnRzIHdpdGggemVyb1xuICAgIHRoaXMuX2N1cnJlbnRTdGVwID0gc3RlcCAtIDI7XG4gICAgaWYgKHR5cGVvZiAodGhpcy5faW50cm9JdGVtcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfbmV4dFN0ZXAuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gbmV4dCBzdGVwIG9uIGludHJvXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9uZXh0U3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gX25leHRTdGVwKCkge1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9ICdmb3J3YXJkJztcblxuICAgIGlmICh0eXBlb2YgKHRoaXMuX2N1cnJlbnRTdGVwKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGVwID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLl9jdXJyZW50U3RlcDtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMuX2ludHJvSXRlbXMubGVuZ3RoKSA8PSB0aGlzLl9jdXJyZW50U3RlcCkge1xuICAgICAgLy9lbmQgb2YgdGhlIGludHJvXG4gICAgICAvL2NoZWNrIGlmIGFueSBjYWxsYmFjayBpcyBkZWZpbmVkXG4gICAgICBpZiAodHlwZW9mICh0aGlzLl9pbnRyb0NvbXBsZXRlQ2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2ludHJvQ29tcGxldGVDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgX2V4aXRJbnRyby5jYWxsKHRoaXMsIHRoaXMuX3RhcmdldEVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RlcCA9IHRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdO1xuICAgIGlmICh0eXBlb2YgKHRoaXMuX2ludHJvQmVmb3JlQ2hhbmdlQ2FsbGJhY2spICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faW50cm9CZWZvcmVDaGFuZ2VDYWxsYmFjay5jYWxsKHRoaXMsIG5leHRTdGVwLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIF9zaG93RWxlbWVudC5jYWxsKHRoaXMsIG5leHRTdGVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byBwcmV2aW91cyBzdGVwIG9uIGludHJvXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9uZXh0U3RlcFxuICAgKi9cbiAgZnVuY3Rpb24gX3ByZXZpb3VzU3RlcCgpIHtcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGVwID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGVwID0gdGhpcy5faW50cm9JdGVtc1stLXRoaXMuX2N1cnJlbnRTdGVwXTtcbiAgICBpZiAodHlwZW9mICh0aGlzLl9pbnRyb0JlZm9yZUNoYW5nZUNhbGxiYWNrKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2ludHJvQmVmb3JlQ2hhbmdlQ2FsbGJhY2suY2FsbCh0aGlzLCBuZXh0U3RlcC5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBfc2hvd0VsZW1lbnQuY2FsbCh0aGlzLCBuZXh0U3RlcCk7XG4gIH1cblxuICAvKipcbiAgICogRXhpdCBmcm9tIGludHJvXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9leGl0SW50cm9cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIF9leGl0SW50cm8odGFyZ2V0RWxlbWVudCkge1xuICAgIC8vcmVtb3ZlIG92ZXJsYXkgbGF5ZXIgZnJvbSB0aGUgcGFnZVxuICAgIHZhciBvdmVybGF5TGF5ZXIgPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLW92ZXJsYXknKTtcblxuICAgIC8vcmV0dXJuIGlmIGludHJvIGFscmVhZHkgY29tcGxldGVkIG9yIHNraXBwZWRcbiAgICBpZiAob3ZlcmxheUxheWVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL2ZvciBmYWRlLW91dCBhbmltYXRpb25cbiAgICBvdmVybGF5TGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3ZlcmxheUxheWVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgb3ZlcmxheUxheWVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3ZlcmxheUxheWVyKTtcbiAgICAgIH1cbiAgICB9LCA1MDApO1xuXG4gICAgLy9yZW1vdmUgYWxsIGhlbHBlciBsYXllcnNcbiAgICB2YXIgaGVscGVyTGF5ZXIgPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLWhlbHBlckxheWVyJyk7XG4gICAgaWYgKGhlbHBlckxheWVyKSB7XG4gICAgICBoZWxwZXJMYXllci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhlbHBlckxheWVyKTtcbiAgICB9XG5cbiAgICB2YXIgcmVmZXJlbmNlTGF5ZXIgPSB0YXJnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLXRvb2x0aXBSZWZlcmVuY2VMYXllcicpO1xuICAgIGlmIChyZWZlcmVuY2VMYXllcikge1xuICAgICAgcmVmZXJlbmNlTGF5ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZWZlcmVuY2VMYXllcik7XG4gICAgfVxuICAgIC8vcmVtb3ZlIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyXG4gICAgdmFyIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyID0gdGFyZ2V0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1kaXNhYmxlSW50ZXJhY3Rpb24nKTtcbiAgICBpZiAoZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIpIHtcbiAgICAgIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIpO1xuICAgIH1cblxuICAgIC8vcmVtb3ZlIGludHJvIGZsb2F0aW5nIGVsZW1lbnRcbiAgICB2YXIgZmxvYXRpbmdFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanNGbG9hdGluZ0VsZW1lbnQnKTtcbiAgICBpZiAoZmxvYXRpbmdFbGVtZW50KSB7XG4gICAgICBmbG9hdGluZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmbG9hdGluZ0VsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vcmVtb3ZlIGBpbnRyb2pzLXNob3dFbGVtZW50YCBjbGFzcyBmcm9tIHRoZSBlbGVtZW50XG4gICAgdmFyIHNob3dFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtc2hvd0VsZW1lbnQnKTtcbiAgICBpZiAoc2hvd0VsZW1lbnQpIHtcbiAgICAgIHNob3dFbGVtZW50LmNsYXNzTmFtZSA9IHNob3dFbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKC9pbnRyb2pzLVthLXpBLVpdKy9nLCAnJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBUaGlzIGlzIGEgbWFudWFsIHRyaW0uXG4gICAgfVxuXG4gICAgLy9yZW1vdmUgYGludHJvanMtZml4UGFyZW50YCBjbGFzcyBmcm9tIHRoZSBlbGVtZW50c1xuICAgIHZhciBmaXhQYXJlbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmludHJvanMtZml4UGFyZW50Jyk7XG4gICAgaWYgKGZpeFBhcmVudHMgJiYgZml4UGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gZml4UGFyZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmaXhQYXJlbnRzW2ldLmNsYXNzTmFtZSA9IGZpeFBhcmVudHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoL2ludHJvanMtZml4UGFyZW50L2csICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jbGVhbiBsaXN0ZW5lcnNcbiAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmRldGFjaEV2ZW50KSB7IC8vSUVcbiAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KCdvbmtleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xuICAgIH1cblxuICAgIC8vc2V0IHRoZSBzdGVwIHRvIHplcm9cbiAgICB0aGlzLl9jdXJyZW50U3RlcCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdG9vbHRpcCBib3ggaW4gdGhlIHBhZ2VcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX3BsYWNlVG9vbHRpcFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvb2x0aXBMYXllclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhcnJvd0xheWVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhlbHBlck51bWJlckxheWVyXG4gICAqL1xuICBmdW5jdGlvbiBfcGxhY2VUb29sdGlwKHRhcmdldEVsZW1lbnQsIHRvb2x0aXBMYXllciwgYXJyb3dMYXllciwgaGVscGVyTnVtYmVyTGF5ZXIpIHtcbiAgICB2YXIgdG9vbHRpcENzc0NsYXNzID0gJycsXG4gICAgICAgIGN1cnJlbnRTdGVwT2JqLFxuICAgICAgICB0b29sdGlwT2Zmc2V0LFxuICAgICAgICB0YXJnZXRPZmZzZXQsXG4gICAgICAgIHdpbmRvd1NpemUsXG4gICAgICAgIGN1cnJlbnRUb29sdGlwUG9zaXRpb247XG5cbiAgICAvL3Jlc2V0IHRoZSBvbGQgc3R5bGVcbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUudG9wICAgICAgICA9IG51bGw7XG4gICAgdG9vbHRpcExheWVyLnN0eWxlLnJpZ2h0ICAgICAgPSBudWxsO1xuICAgIHRvb2x0aXBMYXllci5zdHlsZS5ib3R0b20gICAgID0gbnVsbDtcbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUubGVmdCAgICAgICA9IG51bGw7XG4gICAgdG9vbHRpcExheWVyLnN0eWxlLm1hcmdpbkxlZnQgPSBudWxsO1xuICAgIHRvb2x0aXBMYXllci5zdHlsZS5tYXJnaW5Ub3AgID0gbnVsbDtcblxuICAgIGFycm93TGF5ZXIuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcblxuICAgIGlmICh0eXBlb2YoaGVscGVyTnVtYmVyTGF5ZXIpICE9ICd1bmRlZmluZWQnICYmIGhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgIGhlbHBlck51bWJlckxheWVyLnN0eWxlLnRvcCAgPSBudWxsO1xuICAgICAgaGVscGVyTnVtYmVyTGF5ZXIuc3R5bGUubGVmdCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy9wcmV2ZW50IGVycm9yIHdoZW4gYHRoaXMuX2N1cnJlbnRTdGVwYCBpcyB1bmRlZmluZWRcbiAgICBpZiAoIXRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdKSByZXR1cm47XG5cbiAgICAvL2lmIHdlIGhhdmUgYSBjdXN0b20gY3NzIGNsYXNzIGZvciBlYWNoIHN0ZXBcbiAgICBjdXJyZW50U3RlcE9iaiA9IHRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdO1xuICAgIGlmICh0eXBlb2YgKGN1cnJlbnRTdGVwT2JqLnRvb2x0aXBDbGFzcykgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0b29sdGlwQ3NzQ2xhc3MgPSBjdXJyZW50U3RlcE9iai50b29sdGlwQ2xhc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXBDc3NDbGFzcyA9IHRoaXMuX29wdGlvbnMudG9vbHRpcENsYXNzO1xuICAgIH1cblxuICAgIHRvb2x0aXBMYXllci5jbGFzc05hbWUgPSAoJ2ludHJvanMtdG9vbHRpcCAnICsgdG9vbHRpcENzc0NsYXNzKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cbiAgICBjdXJyZW50VG9vbHRpcFBvc2l0aW9uID0gdGhpcy5faW50cm9JdGVtc1t0aGlzLl9jdXJyZW50U3RlcF0ucG9zaXRpb247XG4gICAgaWYgKChjdXJyZW50VG9vbHRpcFBvc2l0aW9uID09IFwiYXV0b1wiIHx8IHRoaXMuX29wdGlvbnMudG9vbHRpcFBvc2l0aW9uID09IFwiYXV0b1wiKSkge1xuICAgICAgaWYgKGN1cnJlbnRUb29sdGlwUG9zaXRpb24gIT0gXCJmbG9hdGluZ1wiKSB7IC8vIEZsb2F0aW5nIGlzIGFsd2F5cyB2YWxpZCwgbm8gcG9pbnQgaW4gY2FsY3VsYXRpbmdcbiAgICAgICAgY3VycmVudFRvb2x0aXBQb3NpdGlvbiA9IF9kZXRlcm1pbmVBdXRvUG9zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXRFbGVtZW50LCB0b29sdGlwTGF5ZXIsIGN1cnJlbnRUb29sdGlwUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXRPZmZzZXQgID0gX2dldE9mZnNldCh0YXJnZXRFbGVtZW50KTtcbiAgICB0b29sdGlwT2Zmc2V0ID0gX2dldE9mZnNldCh0b29sdGlwTGF5ZXIpO1xuICAgIHdpbmRvd1NpemUgICAgPSBfZ2V0V2luU2l6ZSgpO1xuICAgIHN3aXRjaCAoY3VycmVudFRvb2x0aXBQb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1hcnJvdyBib3R0b20nO1xuXG4gICAgICAgIHZhciB0b29sdGlwTGF5ZXJTdHlsZUxlZnQgPSAxNTtcbiAgICAgICAgX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnQsIHRvb2x0aXBPZmZzZXQsIHdpbmRvd1NpemUsIHRvb2x0aXBMYXllcik7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5ib3R0b20gPSAodGFyZ2V0T2Zmc2V0LmhlaWdodCArICAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLmxlZnQgPSAodGFyZ2V0T2Zmc2V0LndpZHRoICsgMjApICsgJ3B4JztcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldC50b3AgKyB0b29sdGlwT2Zmc2V0LmhlaWdodCA+IHdpbmRvd1NpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCByaWdodCB3b3VsZCBoYXZlIGZhbGxlbiBiZWxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgICAgLy8gTW9kaWZ5IHNvIHRoYXQgdGhlIGJvdHRvbSBvZiB0aGUgdG9vbHRpcCBjb25uZWN0cyB3aXRoIHRoZSB0YXJnZXRcbiAgICAgICAgICBhcnJvd0xheWVyLmNsYXNzTmFtZSA9IFwiaW50cm9qcy1hcnJvdyBsZWZ0LWJvdHRvbVwiO1xuICAgICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgPSBcIi1cIiArICh0b29sdGlwT2Zmc2V0LmhlaWdodCAtIHRhcmdldE9mZnNldC5oZWlnaHQgLSAyMCkgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1hcnJvdyBsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zaG93U3RlcE51bWJlcnMgPT0gdHJ1ZSkge1xuICAgICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgPSAnMTVweCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0T2Zmc2V0LnRvcCArIHRvb2x0aXBPZmZzZXQuaGVpZ2h0ID4gd2luZG93U2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGxlZnQgd291bGQgaGF2ZSBmYWxsZW4gYmVsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuLlxuICAgICAgICAgIC8vIE1vZGlmeSBzbyB0aGF0IHRoZSBib3R0b20gb2YgdGhlIHRvb2x0aXAgY29ubmVjdHMgd2l0aCB0aGUgdGFyZ2V0XG4gICAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLnRvcCA9IFwiLVwiICsgKHRvb2x0aXBPZmZzZXQuaGVpZ2h0IC0gdGFyZ2V0T2Zmc2V0LmhlaWdodCAtIDIwKSArIFwicHhcIjtcbiAgICAgICAgICBhcnJvd0xheWVyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWFycm93IHJpZ2h0LWJvdHRvbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1hcnJvdyByaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLnJpZ2h0ID0gKHRhcmdldE9mZnNldC53aWR0aCArIDIwKSArICdweCc7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdGluZyc6XG4gICAgICAgIGFycm93TGF5ZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAvL3dlIGhhdmUgdG8gYWRqdXN0IHRoZSB0b3AgYW5kIGxlZnQgb2YgbGF5ZXIgbWFudWFsbHkgZm9yIGludHJvIGl0ZW1zIHdpdGhvdXQgZWxlbWVudFxuICAgICAgICB0b29sdGlwTGF5ZXIuc3R5bGUubGVmdCAgID0gJzUwJSc7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgICAgPSAnNTAlJztcbiAgICAgICAgdG9vbHRpcExheWVyLnN0eWxlLm1hcmdpbkxlZnQgPSAnLScgKyAodG9vbHRpcE9mZnNldC53aWR0aCAvIDIpICArICdweCc7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5tYXJnaW5Ub3AgID0gJy0nICsgKHRvb2x0aXBPZmZzZXQuaGVpZ2h0IC8gMikgKyAncHgnO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaGVscGVyTnVtYmVyTGF5ZXIpICE9ICd1bmRlZmluZWQnICYmIGhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICBoZWxwZXJOdW1iZXJMYXllci5zdHlsZS5sZWZ0ID0gJy0nICsgKCh0b29sdGlwT2Zmc2V0LndpZHRoIC8gMikgKyAxOCkgKyAncHgnO1xuICAgICAgICAgIGhlbHBlck51bWJlckxheWVyLnN0eWxlLnRvcCAgPSAnLScgKyAoKHRvb2x0aXBPZmZzZXQuaGVpZ2h0IC8gMikgKyAxOCkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQtYWxpZ25lZCc6XG4gICAgICAgIGFycm93TGF5ZXIuY2xhc3NOYW1lICAgICAgPSAnaW50cm9qcy1hcnJvdyB0b3AtcmlnaHQnO1xuXG4gICAgICAgIHZhciB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0ID0gMDtcbiAgICAgICAgX2NoZWNrTGVmdCh0YXJnZXRPZmZzZXQsIHRvb2x0aXBMYXllclN0eWxlUmlnaHQsIHRvb2x0aXBPZmZzZXQsIHRvb2x0aXBMYXllcik7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgICAgPSAodGFyZ2V0T2Zmc2V0LmhlaWdodCArICAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tLW1pZGRsZS1hbGlnbmVkJzpcbiAgICAgICAgYXJyb3dMYXllci5jbGFzc05hbWUgICAgICA9ICdpbnRyb2pzLWFycm93IHRvcC1taWRkbGUnO1xuXG4gICAgICAgIHZhciB0b29sdGlwTGF5ZXJTdHlsZUxlZnRSaWdodCA9IHRhcmdldE9mZnNldC53aWR0aCAvIDIgLSB0b29sdGlwT2Zmc2V0LndpZHRoIC8gMjtcbiAgICAgICAgaWYgKF9jaGVja0xlZnQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnRSaWdodCwgdG9vbHRpcE9mZnNldCwgdG9vbHRpcExheWVyKSkge1xuICAgICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5yaWdodCA9IG51bGw7XG4gICAgICAgICAgX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnRSaWdodCwgdG9vbHRpcE9mZnNldCwgd2luZG93U2l6ZSwgdG9vbHRpcExheWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwTGF5ZXIuc3R5bGUudG9wID0gKHRhcmdldE9mZnNldC5oZWlnaHQgKyAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tLWxlZnQtYWxpZ25lZCc6XG4gICAgICAvLyBCb3R0b20tbGVmdC1hbGlnbmVkIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0IGJvdHRvbVxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIC8vIEJvdHRvbSBnb2luZyB0byBmb2xsb3cgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFycm93TGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtYXJyb3cgdG9wJztcblxuICAgICAgICB2YXIgdG9vbHRpcExheWVyU3R5bGVMZWZ0ID0gMDtcbiAgICAgICAgX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnQsIHRvb2x0aXBPZmZzZXQsIHdpbmRvd1NpemUsIHRvb2x0aXBMYXllcik7XG4gICAgICAgIHRvb2x0aXBMYXllci5zdHlsZS50b3AgICAgPSAodGFyZ2V0T2Zmc2V0LmhlaWdodCArICAyMCkgKyAncHgnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRvb2x0aXAgbGVmdCBzbyBpdCBkb2Vzbid0IGdvIG9mZiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgd2luZG93XG4gICAqXG4gICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlLCBpZiB0b29sdGlwTGF5ZXJTdHlsZUxlZnQgaXMgb2suICBmYWxzZSwgb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2NoZWNrUmlnaHQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZUxlZnQsIHRvb2x0aXBPZmZzZXQsIHdpbmRvd1NpemUsIHRvb2x0aXBMYXllcikge1xuICAgIGlmICh0YXJnZXRPZmZzZXQubGVmdCArIHRvb2x0aXBMYXllclN0eWxlTGVmdCArIHRvb2x0aXBPZmZzZXQud2lkdGggPiB3aW5kb3dTaXplLndpZHRoKSB7XG4gICAgICAvLyBvZmYgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHdpbmRvd1xuICAgICAgdG9vbHRpcExheWVyLnN0eWxlLmxlZnQgPSAod2luZG93U2l6ZS53aWR0aCAtIHRvb2x0aXBPZmZzZXQud2lkdGggLSB0YXJnZXRPZmZzZXQubGVmdCkgKyAncHgnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUubGVmdCA9IHRvb2x0aXBMYXllclN0eWxlTGVmdCArICdweCc7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRvb2x0aXAgcmlnaHQgc28gaXQgZG9lc24ndCBnbyBvZmYgdGhlIGxlZnQgc2lkZSBvZiB0aGUgd2luZG93XG4gICAqXG4gICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlLCBpZiB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0IGlzIG9rLiAgZmFsc2UsIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9jaGVja0xlZnQodGFyZ2V0T2Zmc2V0LCB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0LCB0b29sdGlwT2Zmc2V0LCB0b29sdGlwTGF5ZXIpIHtcbiAgICBpZiAodGFyZ2V0T2Zmc2V0LmxlZnQgKyB0YXJnZXRPZmZzZXQud2lkdGggLSB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0IC0gdG9vbHRpcE9mZnNldC53aWR0aCA8IDApIHtcbiAgICAgIC8vIG9mZiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB3aW5kb3dcbiAgICAgIHRvb2x0aXBMYXllci5zdHlsZS5sZWZ0ID0gKC10YXJnZXRPZmZzZXQubGVmdCkgKyAncHgnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b29sdGlwTGF5ZXIuc3R5bGUucmlnaHQgPSB0b29sdGlwTGF5ZXJTdHlsZVJpZ2h0ICsgJ3B4JztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCBiYXNlZCBvbiB0aGUgcG9zaXRpb24gcHJlY2VkZW5jZSBhbmQgYXZhaWxhYmlsaXR5XG4gICAqIG9mIHNjcmVlbiBzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2x0aXBMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzaXJlZFRvb2x0aXBQb3NpdGlvblxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gX2RldGVybWluZUF1dG9Qb3NpdGlvbih0YXJnZXRFbGVtZW50LCB0b29sdGlwTGF5ZXIsIGRlc2lyZWRUb29sdGlwUG9zaXRpb24pIHtcblxuICAgIC8vIFRha2UgYSBjbG9uZSBvZiBwb3NpdGlvbiBwcmVjZWRlbmNlLiBUaGVzZSB3aWxsIGJlIHRoZSBhdmFpbGFibGVcbiAgICB2YXIgcG9zc2libGVQb3NpdGlvbnMgPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUHJlY2VkZW5jZS5zbGljZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSBfZ2V0V2luU2l6ZSgpO1xuICAgIHZhciB0b29sdGlwSGVpZ2h0ID0gX2dldE9mZnNldCh0b29sdGlwTGF5ZXIpLmhlaWdodCArIDEwO1xuICAgIHZhciB0b29sdGlwV2lkdGggPSBfZ2V0T2Zmc2V0KHRvb2x0aXBMYXllcikud2lkdGggKyAyMDtcbiAgICB2YXIgdGFyZ2V0T2Zmc2V0ID0gX2dldE9mZnNldCh0YXJnZXRFbGVtZW50KTtcblxuICAgIC8vIElmIHdlIGNoZWNrIGFsbCB0aGUgcG9zc2libGUgYXJlYXMsIGFuZCB0aGVyZSBhcmUgbm8gdmFsaWQgcGxhY2VzIGZvciB0aGUgdG9vbHRpcCwgdGhlIGVsZW1lbnRcbiAgICAvLyBtdXN0IHRha2UgdXAgbW9zdCBvZiB0aGUgc2NyZWVuIHJlYWwgZXN0YXRlLiBTaG93IHRoZSB0b29sdGlwIGZsb2F0aW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cbiAgICB2YXIgY2FsY3VsYXRlZFBvc2l0aW9uID0gXCJmbG9hdGluZ1wiO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHdpZHRoIG9mIHRoZSB0b29sdGlwICsgdGhlIHN0YXJ0aW5nIHBvaW50IHdvdWxkIHNwaWxsIG9mZiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc2NyZWVuXG4gICAgLy8gSWYgbm8sIG5laXRoZXIgYm90dG9tIG9yIHRvcCBhcmUgdmFsaWRcbiAgICBpZiAodGFyZ2V0T2Zmc2V0LmxlZnQgKyB0b29sdGlwV2lkdGggPiB3aW5kb3dTaXplLndpZHRoIHx8ICgodGFyZ2V0T2Zmc2V0LmxlZnQgKyAodGFyZ2V0T2Zmc2V0LndpZHRoIC8gMikpIC0gdG9vbHRpcFdpZHRoKSA8IDApIHtcbiAgICAgIF9yZW1vdmVFbnRyeShwb3NzaWJsZVBvc2l0aW9ucywgXCJib3R0b21cIik7XG4gICAgICBfcmVtb3ZlRW50cnkocG9zc2libGVQb3NpdGlvbnMsIFwidG9wXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBmb3Igc3BhY2UgYmVsb3dcbiAgICAgIGlmICgodGFyZ2V0T2Zmc2V0LmhlaWdodCArIHRhcmdldE9mZnNldC50b3AgKyB0b29sdGlwSGVpZ2h0KSA+IHdpbmRvd1NpemUuaGVpZ2h0KSB7XG4gICAgICAgIF9yZW1vdmVFbnRyeShwb3NzaWJsZVBvc2l0aW9ucywgXCJib3R0b21cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzcGFjZSBhYm92ZVxuICAgICAgaWYgKHRhcmdldE9mZnNldC50b3AgLSB0b29sdGlwSGVpZ2h0IDwgMCkge1xuICAgICAgICBfcmVtb3ZlRW50cnkocG9zc2libGVQb3NpdGlvbnMsIFwidG9wXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzcGFjZSB0byB0aGUgcmlnaHRcbiAgICBpZiAodGFyZ2V0T2Zmc2V0LndpZHRoICsgdGFyZ2V0T2Zmc2V0LmxlZnQgKyB0b29sdGlwV2lkdGggPiB3aW5kb3dTaXplLndpZHRoKSB7XG4gICAgICBfcmVtb3ZlRW50cnkocG9zc2libGVQb3NpdGlvbnMsIFwicmlnaHRcIik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHNwYWNlIHRvIHRoZSBsZWZ0XG4gICAgaWYgKHRhcmdldE9mZnNldC5sZWZ0IC0gdG9vbHRpcFdpZHRoIDwgMCkge1xuICAgICAgX3JlbW92ZUVudHJ5KHBvc3NpYmxlUG9zaXRpb25zLCBcImxlZnRcIik7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgb3VyIGFycmF5IG9ubHkgaGFzIHBvc2l0aW9ucyB0aGF0IGFyZSB2YWxpZC4gUGljayB0aGUgZmlyc3Qgb25lLCBhcyBpdCByZW1haW5zIGluIG9yZGVyXG4gICAgaWYgKHBvc3NpYmxlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNhbGN1bGF0ZWRQb3NpdGlvbiA9IHBvc3NpYmxlUG9zaXRpb25zWzBdO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgaW4gdGhlIGxpc3QsIHJlcGxhY2Ugb3VyIGNhbGN1bGF0ZWQgY2hvaWNlIHdpdGggdGhhdFxuICAgIGlmIChkZXNpcmVkVG9vbHRpcFBvc2l0aW9uICYmIGRlc2lyZWRUb29sdGlwUG9zaXRpb24gIT0gXCJhdXRvXCIpIHtcbiAgICAgIGlmIChwb3NzaWJsZVBvc2l0aW9ucy5pbmRleE9mKGRlc2lyZWRUb29sdGlwUG9zaXRpb24pID4gLTEpIHtcbiAgICAgICAgY2FsY3VsYXRlZFBvc2l0aW9uID0gZGVzaXJlZFRvb2x0aXBQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2FsY3VsYXRlZFBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIGEgc3RyaW5nIGFycmF5IGlmIGl0J3MgdGhlcmUsIGRvZXMgbm90aGluZyBpZiBpdCBpc24ndCB0aGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyaW5nQXJyYXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmVtb3ZlXG4gICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRW50cnkoc3RyaW5nQXJyYXksIHN0cmluZ1RvUmVtb3ZlKSB7XG4gICAgaWYgKHN0cmluZ0FycmF5LmluZGV4T2Yoc3RyaW5nVG9SZW1vdmUpID4gLTEpIHtcbiAgICAgIHN0cmluZ0FycmF5LnNwbGljZShzdHJpbmdBcnJheS5pbmRleE9mKHN0cmluZ1RvUmVtb3ZlKSwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBsYXllciBvbiB0aGUgc2NyZWVuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWxwZXJMYXllclxuICAgKi9cbiAgZnVuY3Rpb24gX3NldEhlbHBlckxheWVyUG9zaXRpb24oaGVscGVyTGF5ZXIpIHtcbiAgICBpZiAoaGVscGVyTGF5ZXIpIHtcbiAgICAgIC8vcHJldmVudCBlcnJvciB3aGVuIGB0aGlzLl9jdXJyZW50U3RlcGAgaW4gdW5kZWZpbmVkXG4gICAgICBpZiAoIXRoaXMuX2ludHJvSXRlbXNbdGhpcy5fY3VycmVudFN0ZXBdKSByZXR1cm47XG5cbiAgICAgIHZhciBjdXJyZW50RWxlbWVudCAgPSB0aGlzLl9pbnRyb0l0ZW1zW3RoaXMuX2N1cnJlbnRTdGVwXSxcbiAgICAgICAgICBlbGVtZW50UG9zaXRpb24gPSBfZ2V0T2Zmc2V0KGN1cnJlbnRFbGVtZW50LmVsZW1lbnQpLFxuICAgICAgICAgIHdpZHRoSGVpZ2h0UGFkZGluZyA9IDEwO1xuXG4gICAgICBpZiAoY3VycmVudEVsZW1lbnQucG9zaXRpb24gPT0gJ2Zsb2F0aW5nJykge1xuICAgICAgICB3aWR0aEhlaWdodFBhZGRpbmcgPSAwO1xuICAgICAgfVxuXG4gICAgICAvL3NldCBuZXcgcG9zaXRpb24gdG8gaGVscGVyIGxheWVyXG4gICAgICBoZWxwZXJMYXllci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAnICsgKGVsZW1lbnRQb3NpdGlvbi53aWR0aCAgKyB3aWR0aEhlaWdodFBhZGRpbmcpICArICdweDsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodDonICsgKGVsZW1lbnRQb3NpdGlvbi5oZWlnaHQgKyB3aWR0aEhlaWdodFBhZGRpbmcpICArICdweDsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcDonICAgICsgKGVsZW1lbnRQb3NpdGlvbi50b3AgICAgLSA1KSAgICsgJ3B4OycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0OiAnICArIChlbGVtZW50UG9zaXRpb24ubGVmdCAgIC0gNSkgICArICdweDsnKTtcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGlzYWJsZWludGVyYWN0aW9uIGxheWVyIGFuZCBhZGp1c3QgdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoZSBsYXllclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfZGlzYWJsZUludGVyYWN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBfZGlzYWJsZUludGVyYWN0aW9uICgpIHtcbiAgICB2YXIgZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1kaXNhYmxlSW50ZXJhY3Rpb24nKTtcbiAgICBpZiAoZGlzYWJsZUludGVyYWN0aW9uTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgIGRpc2FibGVJbnRlcmFjdGlvbkxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXNhYmxlSW50ZXJhY3Rpb25MYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1kaXNhYmxlSW50ZXJhY3Rpb24nO1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChkaXNhYmxlSW50ZXJhY3Rpb25MYXllcik7XG4gICAgfVxuXG4gICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbCh0aGlzLCBkaXNhYmxlSW50ZXJhY3Rpb25MYXllcik7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhbiBlbGVtZW50IG9uIHRoZSBwYWdlXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9zaG93RWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0RWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gX3Nob3dFbGVtZW50KHRhcmdldEVsZW1lbnQpIHtcblxuICAgIGlmICh0eXBlb2YgKHRoaXMuX2ludHJvQ2hhbmdlQ2FsbGJhY2spICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faW50cm9DaGFuZ2VDYWxsYmFjay5jYWxsKHRoaXMsIHRhcmdldEVsZW1lbnQuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBvbGRIZWxwZXJMYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLWhlbHBlckxheWVyJyksXG4gICAgICAgIG9sZFJlZmVyZW5jZUxheWVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJyksXG4gICAgICAgIGhpZ2hsaWdodENsYXNzID0gJ2ludHJvanMtaGVscGVyTGF5ZXInLFxuICAgICAgICBlbGVtZW50UG9zaXRpb24gPSBfZ2V0T2Zmc2V0KHRhcmdldEVsZW1lbnQuZWxlbWVudCk7XG5cbiAgICAvL2NoZWNrIGZvciBhIGN1cnJlbnQgc3RlcCBoaWdobGlnaHQgY2xhc3NcbiAgICBpZiAodHlwZW9mICh0YXJnZXRFbGVtZW50LmhpZ2hsaWdodENsYXNzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhpZ2hsaWdodENsYXNzICs9ICgnICcgKyB0YXJnZXRFbGVtZW50LmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG4gICAgLy9jaGVjayBmb3Igb3B0aW9ucyBoaWdobGlnaHQgY2xhc3NcbiAgICBpZiAodHlwZW9mICh0aGlzLl9vcHRpb25zLmhpZ2hsaWdodENsYXNzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhpZ2hsaWdodENsYXNzICs9ICgnICcgKyB0aGlzLl9vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAob2xkSGVscGVyTGF5ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEhlbHBlck51bWJlckxheWVyID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtaGVscGVyTnVtYmVyTGF5ZXInKSxcbiAgICAgICAgICBvbGR0b29sdGlwTGF5ZXIgICAgICA9IG9sZFJlZmVyZW5jZUxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLXRvb2x0aXB0ZXh0JyksXG4gICAgICAgICAgb2xkQXJyb3dMYXllciAgICAgICAgPSBvbGRSZWZlcmVuY2VMYXllci5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1hcnJvdycpLFxuICAgICAgICAgIG9sZHRvb2x0aXBDb250YWluZXIgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcCcpLFxuICAgICAgICAgIHNraXBUb29sdGlwQnV0dG9uICAgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtc2tpcGJ1dHRvbicpLFxuICAgICAgICAgIHByZXZUb29sdGlwQnV0dG9uICAgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtcHJldmJ1dHRvbicpLFxuICAgICAgICAgIG5leHRUb29sdGlwQnV0dG9uICAgID0gb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtbmV4dGJ1dHRvbicpO1xuXG4gICAgICAvL3VwZGF0ZSBvciByZXNldCB0aGUgaGVscGVyIGhpZ2hsaWdodCBjbGFzc1xuICAgICAgb2xkSGVscGVyTGF5ZXIuY2xhc3NOYW1lID0gaGlnaGxpZ2h0Q2xhc3M7XG4gICAgICAvL2hpZGUgdGhlIHRvb2x0aXBcbiAgICAgIG9sZHRvb2x0aXBDb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICBvbGR0b29sdGlwQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgICAgaWYgKG9sZEhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxhc3RJbnRyb0l0ZW0gPSB0aGlzLl9pbnRyb0l0ZW1zWyh0YXJnZXRFbGVtZW50LnN0ZXAgLSAyID49IDAgPyB0YXJnZXRFbGVtZW50LnN0ZXAgLSAyIDogMCldO1xuXG4gICAgICAgIGlmIChsYXN0SW50cm9JdGVtICE9IG51bGwgJiYgKHRoaXMuX2RpcmVjdGlvbiA9PSAnZm9yd2FyZCcgJiYgbGFzdEludHJvSXRlbS5wb3NpdGlvbiA9PSAnZmxvYXRpbmcnKSB8fCAodGhpcy5fZGlyZWN0aW9uID09ICdiYWNrd2FyZCcgJiYgdGFyZ2V0RWxlbWVudC5wb3NpdGlvbiA9PSAnZmxvYXRpbmcnKSkge1xuICAgICAgICAgIG9sZEhlbHBlck51bWJlckxheWVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vc2V0IG5ldyBwb3NpdGlvbiB0byBoZWxwZXIgbGF5ZXJcbiAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwoc2VsZiwgb2xkSGVscGVyTGF5ZXIpO1xuICAgICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbChzZWxmLCBvbGRSZWZlcmVuY2VMYXllcik7XG5cbiAgICAgIC8vcmVtb3ZlIGBpbnRyb2pzLWZpeFBhcmVudGAgY2xhc3MgZnJvbSB0aGUgZWxlbWVudHNcbiAgICAgIHZhciBmaXhQYXJlbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmludHJvanMtZml4UGFyZW50Jyk7XG4gICAgICBpZiAoZml4UGFyZW50cyAmJiBmaXhQYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpeFBhcmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBmaXhQYXJlbnRzW2ldLmNsYXNzTmFtZSA9IGZpeFBhcmVudHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoL2ludHJvanMtZml4UGFyZW50L2csICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vcmVtb3ZlIG9sZCBjbGFzc2VzXG4gICAgICB2YXIgb2xkU2hvd0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1zaG93RWxlbWVudCcpO1xuICAgICAgb2xkU2hvd0VsZW1lbnQuY2xhc3NOYW1lID0gb2xkU2hvd0VsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ludHJvanMtW2EtekEtWl0rL2csICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cbiAgICAgIC8vd2Ugc2hvdWxkIHdhaXQgdW50aWwgdGhlIENTUzMgdHJhbnNpdGlvbiBpcyBjb21wZXRlZCAoaXQncyAwLjMgc2VjKSB0byBwcmV2ZW50IGluY29ycmVjdCBgaGVpZ2h0YCBhbmQgYHdpZHRoYCBjYWxjdWxhdGlvblxuICAgICAgaWYgKHNlbGYuX2xhc3RTaG93RWxlbWVudFRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9sYXN0U2hvd0VsZW1lbnRUaW1lcik7XG4gICAgICB9XG4gICAgICBzZWxmLl9sYXN0U2hvd0VsZW1lbnRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vc2V0IGN1cnJlbnQgc3RlcCB0byB0aGUgbGFiZWxcbiAgICAgICAgaWYgKG9sZEhlbHBlck51bWJlckxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICBvbGRIZWxwZXJOdW1iZXJMYXllci5pbm5lckhUTUwgPSB0YXJnZXRFbGVtZW50LnN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgLy9zZXQgY3VycmVudCB0b29sdGlwIHRleHRcbiAgICAgICAgb2xkdG9vbHRpcExheWVyLmlubmVySFRNTCA9IHRhcmdldEVsZW1lbnQuaW50cm87XG4gICAgICAgIC8vc2V0IHRoZSB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIG9sZHRvb2x0aXBDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgX3BsYWNlVG9vbHRpcC5jYWxsKHNlbGYsIHRhcmdldEVsZW1lbnQuZWxlbWVudCwgb2xkdG9vbHRpcENvbnRhaW5lciwgb2xkQXJyb3dMYXllciwgb2xkSGVscGVyTnVtYmVyTGF5ZXIpO1xuXG4gICAgICAgIC8vY2hhbmdlIGFjdGl2ZSBidWxsZXRcbiAgICAgICAgb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtYnVsbGV0cyBsaSA+IGEuYWN0aXZlJykuY2xhc3NOYW1lID0gJyc7XG4gICAgICAgIG9sZFJlZmVyZW5jZUxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5pbnRyb2pzLWJ1bGxldHMgbGkgPiBhW2RhdGEtc3RlcG51bWJlcj1cIicgKyB0YXJnZXRFbGVtZW50LnN0ZXAgKyAnXCJdJykuY2xhc3NOYW1lID0gJ2FjdGl2ZSc7XG5cbiAgICAgICAgb2xkUmVmZXJlbmNlTGF5ZXIucXVlcnlTZWxlY3RvcignLmludHJvanMtcHJvZ3Jlc3MgLmludHJvanMtcHJvZ3Jlc3NiYXInKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOicgKyBfZ2V0UHJvZ3Jlc3MuY2FsbChzZWxmKSArICclOycpO1xuXG4gICAgICAgIC8vc2hvdyB0aGUgdG9vbHRpcFxuICAgICAgICBvbGR0b29sdGlwQ29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBpZiAob2xkSGVscGVyTnVtYmVyTGF5ZXIpIG9sZEhlbHBlck51bWJlckxheWVyLnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgICAgIC8vcmVzZXQgYnV0dG9uIGZvY3VzXG4gICAgICAgIGlmIChuZXh0VG9vbHRpcEJ1dHRvbi50YWJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAvL3RhYmluZGV4IG9mIC0xIG1lYW5zIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSB0b3VyIC0gZm9jdXMgb24gc2tpcCAvIGRvbmVcbiAgICAgICAgICBza2lwVG9vbHRpcEJ1dHRvbi5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vc3RpbGwgaW4gdGhlIHRvdXIsIGZvY3VzIG9uIG5leHRcbiAgICAgICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LCAzNTApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZWxwZXJMYXllciAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIHJlZmVyZW5jZUxheWVyICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgYXJyb3dMYXllciAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICB0b29sdGlwTGF5ZXIgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIHRvb2x0aXBUZXh0TGF5ZXIgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgYnVsbGV0c0xheWVyICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICBwcm9ncmVzc0xheWVyICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIGJ1dHRvbnNMYXllciAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGhlbHBlckxheWVyLmNsYXNzTmFtZSA9IGhpZ2hsaWdodENsYXNzO1xuICAgICAgcmVmZXJlbmNlTGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJztcblxuICAgICAgLy9zZXQgbmV3IHBvc2l0aW9uIHRvIGhlbHBlciBsYXllclxuICAgICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbChzZWxmLCBoZWxwZXJMYXllcik7XG4gICAgICBfc2V0SGVscGVyTGF5ZXJQb3NpdGlvbi5jYWxsKHNlbGYsIHJlZmVyZW5jZUxheWVyKTtcblxuICAgICAgLy9hZGQgaGVscGVyIGxheWVyIHRvIHRhcmdldCBlbGVtZW50XG4gICAgICB0aGlzLl90YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKGhlbHBlckxheWVyKTtcbiAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQocmVmZXJlbmNlTGF5ZXIpO1xuXG4gICAgICBhcnJvd0xheWVyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWFycm93JztcblxuICAgICAgdG9vbHRpcFRleHRMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy10b29sdGlwdGV4dCc7XG4gICAgICB0b29sdGlwVGV4dExheWVyLmlubmVySFRNTCA9IHRhcmdldEVsZW1lbnQuaW50cm87XG5cbiAgICAgIGJ1bGxldHNMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1idWxsZXRzJztcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd0J1bGxldHMgPT09IGZhbHNlKSB7XG4gICAgICAgIGJ1bGxldHNMYXllci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICB2YXIgdWxDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgc3RlcHNMZW5ndGggPSB0aGlzLl9pbnRyb0l0ZW1zLmxlbmd0aDsgaSA8IHN0ZXBzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlubmVyTGkgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICB2YXIgYW5jaG9yTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICBhbmNob3JMaW5rLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmdvVG9TdGVwKHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXN0ZXBudW1iZXInKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGkgPT09ICh0YXJnZXRFbGVtZW50LnN0ZXAtMSkpIGFuY2hvckxpbmsuY2xhc3NOYW1lID0gJ2FjdGl2ZSc7XG5cbiAgICAgICAgYW5jaG9yTGluay5ocmVmID0gJ2phdmFzY3JpcHQ6dm9pZCgwKTsnO1xuICAgICAgICBhbmNob3JMaW5rLmlubmVySFRNTCA9IFwiJm5ic3A7XCI7XG4gICAgICAgIGFuY2hvckxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLXN0ZXBudW1iZXInLCB0aGlzLl9pbnRyb0l0ZW1zW2ldLnN0ZXApO1xuXG4gICAgICAgIGlubmVyTGkuYXBwZW5kQ2hpbGQoYW5jaG9yTGluayk7XG4gICAgICAgIHVsQ29udGFpbmVyLmFwcGVuZENoaWxkKGlubmVyTGkpO1xuICAgICAgfVxuXG4gICAgICBidWxsZXRzTGF5ZXIuYXBwZW5kQ2hpbGQodWxDb250YWluZXIpO1xuXG4gICAgICBwcm9ncmVzc0xheWVyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLXByb2dyZXNzJztcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd1Byb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICBwcm9ncmVzc0xheWVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3Jlc3NCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHByb2dyZXNzQmFyLmNsYXNzTmFtZSA9ICdpbnRyb2pzLXByb2dyZXNzYmFyJztcbiAgICAgIHByb2dyZXNzQmFyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6JyArIF9nZXRQcm9ncmVzcy5jYWxsKHRoaXMpICsgJyU7Jyk7XG5cbiAgICAgIHByb2dyZXNzTGF5ZXIuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NCYXIpO1xuXG4gICAgICBidXR0b25zTGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtdG9vbHRpcGJ1dHRvbnMnO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd0J1dHRvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGJ1dHRvbnNMYXllci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwTGF5ZXIuY2xhc3NOYW1lID0gJ2ludHJvanMtdG9vbHRpcCc7XG4gICAgICB0b29sdGlwTGF5ZXIuYXBwZW5kQ2hpbGQodG9vbHRpcFRleHRMYXllcik7XG4gICAgICB0b29sdGlwTGF5ZXIuYXBwZW5kQ2hpbGQoYnVsbGV0c0xheWVyKTtcbiAgICAgIHRvb2x0aXBMYXllci5hcHBlbmRDaGlsZChwcm9ncmVzc0xheWVyKTtcblxuICAgICAgLy9hZGQgaGVscGVyIGxheWVyIG51bWJlclxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd1N0ZXBOdW1iZXJzID09IHRydWUpIHtcbiAgICAgICAgdmFyIGhlbHBlck51bWJlckxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBoZWxwZXJOdW1iZXJMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1oZWxwZXJOdW1iZXJMYXllcic7XG4gICAgICAgIGhlbHBlck51bWJlckxheWVyLmlubmVySFRNTCA9IHRhcmdldEVsZW1lbnQuc3RlcDtcbiAgICAgICAgcmVmZXJlbmNlTGF5ZXIuYXBwZW5kQ2hpbGQoaGVscGVyTnVtYmVyTGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwTGF5ZXIuYXBwZW5kQ2hpbGQoYXJyb3dMYXllcik7XG4gICAgICByZWZlcmVuY2VMYXllci5hcHBlbmRDaGlsZCh0b29sdGlwTGF5ZXIpO1xuXG4gICAgICAvL25leHQgYnV0dG9uXG4gICAgICB2YXIgbmV4dFRvb2x0aXBCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICAgIG5leHRUb29sdGlwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2ludHJvSXRlbXMubGVuZ3RoIC0gMSAhPSBzZWxmLl9jdXJyZW50U3RlcCkge1xuICAgICAgICAgIF9uZXh0U3RlcC5jYWxsKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5ocmVmID0gJ2phdmFzY3JpcHQ6dm9pZCgwKTsnO1xuICAgICAgbmV4dFRvb2x0aXBCdXR0b24uaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5uZXh0TGFiZWw7XG5cbiAgICAgIC8vcHJldmlvdXMgYnV0dG9uXG4gICAgICB2YXIgcHJldlRvb2x0aXBCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICAgIHByZXZUb29sdGlwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2N1cnJlbnRTdGVwICE9IDApIHtcbiAgICAgICAgICBfcHJldmlvdXNTdGVwLmNhbGwoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHByZXZUb29sdGlwQnV0dG9uLmhyZWYgPSAnamF2YXNjcmlwdDp2b2lkKDApOyc7XG4gICAgICBwcmV2VG9vbHRpcEJ1dHRvbi5pbm5lckhUTUwgPSB0aGlzLl9vcHRpb25zLnByZXZMYWJlbDtcblxuICAgICAgLy9za2lwIGJ1dHRvblxuICAgICAgdmFyIHNraXBUb29sdGlwQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgc2tpcFRvb2x0aXBCdXR0b24uY2xhc3NOYW1lID0gJ2ludHJvanMtYnV0dG9uIGludHJvanMtc2tpcGJ1dHRvbic7XG4gICAgICBza2lwVG9vbHRpcEJ1dHRvbi5ocmVmID0gJ2phdmFzY3JpcHQ6dm9pZCgwKTsnO1xuICAgICAgc2tpcFRvb2x0aXBCdXR0b24uaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5za2lwTGFiZWw7XG5cbiAgICAgIHNraXBUb29sdGlwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2ludHJvSXRlbXMubGVuZ3RoIC0gMSA9PSBzZWxmLl9jdXJyZW50U3RlcCAmJiB0eXBlb2YgKHNlbGYuX2ludHJvQ29tcGxldGVDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzZWxmLl9pbnRyb0NvbXBsZXRlQ2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9pbnRyb0l0ZW1zLmxlbmd0aCAtIDEgIT0gc2VsZi5fY3VycmVudFN0ZXAgJiYgdHlwZW9mIChzZWxmLl9pbnRyb0V4aXRDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzZWxmLl9pbnRyb0V4aXRDYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2V4aXRJbnRyby5jYWxsKHNlbGYsIHNlbGYuX3RhcmdldEVsZW1lbnQpO1xuICAgICAgfTtcblxuICAgICAgYnV0dG9uc0xheWVyLmFwcGVuZENoaWxkKHNraXBUb29sdGlwQnV0dG9uKTtcblxuICAgICAgLy9pbiBvcmRlciB0byBwcmV2ZW50IGRpc3BsYXlpbmcgbmV4dC9wcmV2aW91cyBidXR0b24gYWx3YXlzXG4gICAgICBpZiAodGhpcy5faW50cm9JdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGJ1dHRvbnNMYXllci5hcHBlbmRDaGlsZChwcmV2VG9vbHRpcEJ1dHRvbik7XG4gICAgICAgIGJ1dHRvbnNMYXllci5hcHBlbmRDaGlsZChuZXh0VG9vbHRpcEJ1dHRvbik7XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXBMYXllci5hcHBlbmRDaGlsZChidXR0b25zTGF5ZXIpO1xuXG4gICAgICAvL3NldCBwcm9wZXIgcG9zaXRpb25cbiAgICAgIF9wbGFjZVRvb2x0aXAuY2FsbChzZWxmLCB0YXJnZXRFbGVtZW50LmVsZW1lbnQsIHRvb2x0aXBMYXllciwgYXJyb3dMYXllciwgaGVscGVyTnVtYmVyTGF5ZXIpO1xuICAgIH1cblxuICAgIC8vZGlzYWJsZSBpbnRlcmFjdGlvblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVJbnRlcmFjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgX2Rpc2FibGVJbnRlcmFjdGlvbi5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIHByZXZUb29sdGlwQnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBuZXh0VG9vbHRpcEJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFN0ZXAgPT0gMCAmJiB0aGlzLl9pbnRyb0l0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHByZXZUb29sdGlwQnV0dG9uLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWJ1dHRvbiBpbnRyb2pzLXByZXZidXR0b24gaW50cm9qcy1kaXNhYmxlZCc7XG4gICAgICBwcmV2VG9vbHRpcEJ1dHRvbi50YWJJbmRleCA9ICctMSc7XG4gICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5jbGFzc05hbWUgPSAnaW50cm9qcy1idXR0b24gaW50cm9qcy1uZXh0YnV0dG9uJztcbiAgICAgIHNraXBUb29sdGlwQnV0dG9uLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuc2tpcExhYmVsO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faW50cm9JdGVtcy5sZW5ndGggLSAxID09IHRoaXMuX2N1cnJlbnRTdGVwIHx8IHRoaXMuX2ludHJvSXRlbXMubGVuZ3RoID09IDEpIHtcbiAgICAgIHNraXBUb29sdGlwQnV0dG9uLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuZG9uZUxhYmVsO1xuICAgICAgcHJldlRvb2x0aXBCdXR0b24uY2xhc3NOYW1lID0gJ2ludHJvanMtYnV0dG9uIGludHJvanMtcHJldmJ1dHRvbic7XG4gICAgICBuZXh0VG9vbHRpcEJ1dHRvbi5jbGFzc05hbWUgPSAnaW50cm9qcy1idXR0b24gaW50cm9qcy1uZXh0YnV0dG9uIGludHJvanMtZGlzYWJsZWQnO1xuICAgICAgbmV4dFRvb2x0aXBCdXR0b24udGFiSW5kZXggPSAnLTEnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2VG9vbHRpcEJ1dHRvbi5jbGFzc05hbWUgPSAnaW50cm9qcy1idXR0b24gaW50cm9qcy1wcmV2YnV0dG9uJztcbiAgICAgIG5leHRUb29sdGlwQnV0dG9uLmNsYXNzTmFtZSA9ICdpbnRyb2pzLWJ1dHRvbiBpbnRyb2pzLW5leHRidXR0b24nO1xuICAgICAgc2tpcFRvb2x0aXBCdXR0b24uaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5za2lwTGFiZWw7XG4gICAgfVxuXG4gICAgLy9TZXQgZm9jdXMgb24gXCJuZXh0XCIgYnV0dG9uLCBzbyB0aGF0IGhpdHRpbmcgRW50ZXIgYWx3YXlzIG1vdmVzIHlvdSBvbnRvIHRoZSBuZXh0IHN0ZXBcbiAgICBuZXh0VG9vbHRpcEJ1dHRvbi5mb2N1cygpO1xuXG4gICAgLy9hZGQgdGFyZ2V0IGVsZW1lbnQgcG9zaXRpb24gc3R5bGVcbiAgICB0YXJnZXRFbGVtZW50LmVsZW1lbnQuY2xhc3NOYW1lICs9ICcgaW50cm9qcy1zaG93RWxlbWVudCc7XG5cbiAgICB2YXIgY3VycmVudEVsZW1lbnRQb3NpdGlvbiA9IF9nZXRQcm9wVmFsdWUodGFyZ2V0RWxlbWVudC5lbGVtZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAoY3VycmVudEVsZW1lbnRQb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJlxuICAgICAgICBjdXJyZW50RWxlbWVudFBvc2l0aW9uICE9PSAncmVsYXRpdmUnKSB7XG4gICAgICAvL2NoYW5nZSB0byBuZXcgaW50cm8gaXRlbVxuICAgICAgdGFyZ2V0RWxlbWVudC5lbGVtZW50LmNsYXNzTmFtZSArPSAnIGludHJvanMtcmVsYXRpdmVQb3NpdGlvbic7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEVsbSA9IHRhcmdldEVsZW1lbnQuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChwYXJlbnRFbG0gIT0gbnVsbCkge1xuICAgICAgaWYgKHBhcmVudEVsbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdib2R5JykgYnJlYWs7XG5cbiAgICAgIC8vZml4IFRoZSBTdGFja2luZyBDb250ZW54dCBwcm9ibGVtLlxuICAgICAgLy9Nb3JlIGRldGFpbDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICAgICAgdmFyIHpJbmRleCA9IF9nZXRQcm9wVmFsdWUocGFyZW50RWxtLCAnei1pbmRleCcpO1xuICAgICAgdmFyIG9wYWNpdHkgPSBwYXJzZUZsb2F0KF9nZXRQcm9wVmFsdWUocGFyZW50RWxtLCAnb3BhY2l0eScpKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBfZ2V0UHJvcFZhbHVlKHBhcmVudEVsbSwgJ3RyYW5zZm9ybScpIHx8IF9nZXRQcm9wVmFsdWUocGFyZW50RWxtLCAnLXdlYmtpdC10cmFuc2Zvcm0nKSB8fCBfZ2V0UHJvcFZhbHVlKHBhcmVudEVsbSwgJy1tb3otdHJhbnNmb3JtJykgfHwgX2dldFByb3BWYWx1ZShwYXJlbnRFbG0sICctbXMtdHJhbnNmb3JtJykgfHwgX2dldFByb3BWYWx1ZShwYXJlbnRFbG0sICctby10cmFuc2Zvcm0nKTtcbiAgICAgIGlmICgvWzAtOV0rLy50ZXN0KHpJbmRleCkgfHwgb3BhY2l0eSA8IDEgfHwgKHRyYW5zZm9ybSAhPT0gJ25vbmUnICYmIHRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBwYXJlbnRFbG0uY2xhc3NOYW1lICs9ICcgaW50cm9qcy1maXhQYXJlbnQnO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRFbG0gPSBwYXJlbnRFbG0ucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoIV9lbGVtZW50SW5WaWV3cG9ydCh0YXJnZXRFbGVtZW50LmVsZW1lbnQpICYmIHRoaXMuX29wdGlvbnMuc2Nyb2xsVG9FbGVtZW50ID09PSB0cnVlKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldEVsZW1lbnQuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgd2luSGVpZ2h0ID0gX2dldFdpblNpemUoKS5oZWlnaHQsXG4gICAgICAgIHRvcCA9IHJlY3QuYm90dG9tIC0gKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSAtIHdpbkhlaWdodDtcblxuICAgICAgLy9TY3JvbGwgdXBcbiAgICAgIGlmICh0b3AgPCAwIHx8IHRhcmdldEVsZW1lbnQuZWxlbWVudC5jbGllbnRIZWlnaHQgPiB3aW5IZWlnaHQpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIHRvcCAtIDMwKTsgLy8gMzBweCBwYWRkaW5nIGZyb20gZWRnZSB0byBsb29rIG5pY2VcblxuICAgICAgLy9TY3JvbGwgZG93blxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIGJvdHRvbSArIDEwMCk7IC8vIDcwcHggKyAzMHB4IHBhZGRpbmcgZnJvbSBlZGdlIHRvIGxvb2sgbmljZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgKHRoaXMuX2ludHJvQWZ0ZXJDaGFuZ2VDYWxsYmFjaykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9pbnRyb0FmdGVyQ2hhbmdlQ2FsbGJhY2suY2FsbCh0aGlzLCB0YXJnZXRFbGVtZW50LmVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gZWxlbWVudCBDU1MgcHJvcGVydHkgb24gdGhlIHBhZ2VcbiAgICogVGhhbmtzIHRvIEphdmFTY3JpcHQgS2l0OiBodHRwOi8vd3d3LmphdmFzY3JpcHRraXQuY29tL2RodG1sdHV0b3JzL2RodG1sY2FzY2FkZTQuc2h0bWxcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX2dldFByb3BWYWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgICogQHJldHVybnMgRWxlbWVudCdzIHByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJvcFZhbHVlIChlbGVtZW50LCBwcm9wTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSAnJztcbiAgICBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUpIHsgLy9JRVxuICAgICAgcHJvcFZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbcHJvcE5hbWVdO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkgeyAvL090aGVyc1xuICAgICAgcHJvcFZhbHVlID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgICB9XG5cbiAgICAvL1ByZXZlbnQgZXhjZXB0aW9uIGluIElFXG4gICAgaWYgKHByb3BWYWx1ZSAmJiBwcm9wVmFsdWUudG9Mb3dlckNhc2UpIHtcbiAgICAgIHJldHVybiBwcm9wVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjcm9zcy1icm93c2VyIHdheSB0byBnZXQgdGhlIHNjcmVlbiBkaW1lbnNpb25zXG4gICAqIHZpYTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODY0NDY3L2ludGVybmV0LWV4cGxvcmVyLWlubmVyaGVpZ2h0XG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nZXRXaW5TaXplXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlc1xuICAgKi9cbiAgZnVuY3Rpb24gX2dldFdpblNpemUoKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgRCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHJldHVybiB7IHdpZHRoOiBELmNsaWVudFdpZHRoLCBoZWlnaHQ6IEQuY2xpZW50SGVpZ2h0IH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvdmVybGF5IGxheWVyIHRvIHRoZSBwYWdlXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIzOTk5L2hvdy10by10ZWxsLWlmLWEtZG9tLWVsZW1lbnQtaXMtdmlzaWJsZS1pbi10aGUtY3VycmVudC12aWV3cG9ydFxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfZWxlbWVudEluVmlld3BvcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsXG4gICAqL1xuICBmdW5jdGlvbiBfZWxlbWVudEluVmlld3BvcnQoZWwpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3QudG9wID49IDAgJiZcbiAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAocmVjdC5ib3R0b20rODApIDw9IHdpbmRvdy5pbm5lckhlaWdodCAmJiAvLyBhZGQgODAgdG8gZ2V0IHRoZSB0ZXh0IHJpZ2h0XG4gICAgICByZWN0LnJpZ2h0IDw9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb3ZlcmxheSBsYXllciB0byB0aGUgcGFnZVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfYWRkT3ZlcmxheUxheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRFbG1cbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRPdmVybGF5TGF5ZXIodGFyZ2V0RWxtKSB7XG4gICAgdmFyIG92ZXJsYXlMYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBzdHlsZVRleHQgPSAnJyxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvL3NldCBjc3MgY2xhc3MgbmFtZVxuICAgIG92ZXJsYXlMYXllci5jbGFzc05hbWUgPSAnaW50cm9qcy1vdmVybGF5JztcblxuICAgIC8vY2hlY2sgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGJvZHksIHdlIHNob3VsZCBjYWxjdWxhdGUgdGhlIHNpemUgb2Ygb3ZlcmxheSBsYXllciBpbiBhIGJldHRlciB3YXlcbiAgICBpZiAodGFyZ2V0RWxtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2JvZHknKSB7XG4gICAgICBzdHlsZVRleHQgKz0gJ3RvcDogMDtib3R0b206IDA7IGxlZnQ6IDA7cmlnaHQ6IDA7cG9zaXRpb246IGZpeGVkOyc7XG4gICAgICBvdmVybGF5TGF5ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc2V0IG92ZXJsYXkgbGF5ZXIgcG9zaXRpb25cbiAgICAgIHZhciBlbGVtZW50UG9zaXRpb24gPSBfZ2V0T2Zmc2V0KHRhcmdldEVsbSk7XG4gICAgICBpZiAoZWxlbWVudFBvc2l0aW9uKSB7XG4gICAgICAgIHN0eWxlVGV4dCArPSAnd2lkdGg6ICcgKyBlbGVtZW50UG9zaXRpb24ud2lkdGggKyAncHg7IGhlaWdodDonICsgZWxlbWVudFBvc2l0aW9uLmhlaWdodCArICdweDsgdG9wOicgKyBlbGVtZW50UG9zaXRpb24udG9wICsgJ3B4O2xlZnQ6ICcgKyBlbGVtZW50UG9zaXRpb24ubGVmdCArICdweDsnO1xuICAgICAgICBvdmVybGF5TGF5ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlVGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFyZ2V0RWxtLmFwcGVuZENoaWxkKG92ZXJsYXlMYXllcik7XG5cbiAgICBvdmVybGF5TGF5ZXIub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuX29wdGlvbnMuZXhpdE9uT3ZlcmxheUNsaWNrID09IHRydWUpIHtcblxuICAgICAgICAvL2NoZWNrIGlmIGFueSBjYWxsYmFjayBpcyBkZWZpbmVkXG4gICAgICAgIGlmIChzZWxmLl9pbnRyb0V4aXRDYWxsYmFjayAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmLl9pbnRyb0V4aXRDYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIF9leGl0SW50cm8uY2FsbChzZWxmLCB0YXJnZXRFbG0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc3R5bGVUZXh0ICs9ICdvcGFjaXR5OiAnICsgc2VsZi5fb3B0aW9ucy5vdmVybGF5T3BhY2l0eS50b1N0cmluZygpICsgJzsnO1xuICAgICAgb3ZlcmxheUxheWVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZVRleHQpO1xuICAgIH0sIDEwKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBlbGVtZW50IHBvc2l0aW9uIG9uIHRoZSBwYWdlXG4gICAqIFRoYW5rcyB0byBgbWVvdXdgOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDI0NzQvMzc1OTY2XG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nZXRPZmZzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICogQHJldHVybnMgRWxlbWVudCdzIHBvc2l0aW9uIGluZm9cbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBlbGVtZW50UG9zaXRpb24gPSB7fTtcblxuICAgIC8vc2V0IHdpZHRoXG4gICAgZWxlbWVudFBvc2l0aW9uLndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgIC8vc2V0IGhlaWdodFxuICAgIGVsZW1lbnRQb3NpdGlvbi5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgIC8vY2FsY3VsYXRlIGVsZW1lbnQgdG9wIGFuZCBsZWZ0XG4gICAgdmFyIF94ID0gMDtcbiAgICB2YXIgX3kgPSAwO1xuICAgIHdoaWxlIChlbGVtZW50ICYmICFpc05hTihlbGVtZW50Lm9mZnNldExlZnQpICYmICFpc05hTihlbGVtZW50Lm9mZnNldFRvcCkpIHtcbiAgICAgIF94ICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgIF95ICs9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICAvL3NldCB0b3BcbiAgICBlbGVtZW50UG9zaXRpb24udG9wID0gX3k7XG4gICAgLy9zZXQgbGVmdFxuICAgIGVsZW1lbnRQb3NpdGlvbi5sZWZ0ID0gX3g7XG5cbiAgICByZXR1cm4gZWxlbWVudFBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfZ2V0UHJvZ3Jlc3NcbiAgICogQHJldHVybnMgY3VycmVudCBwcm9ncmVzcyBwZXJjZW50YWdlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgLy8gU3RlcHMgYXJlIDAgaW5kZXhlZFxuICAgIHZhciBjdXJyZW50U3RlcCA9IHBhcnNlSW50KCh0aGlzLl9jdXJyZW50U3RlcCArIDEpLCAxMCk7XG4gICAgcmV0dXJuICgoY3VycmVudFN0ZXAgLyB0aGlzLl9pbnRyb0l0ZW1zLmxlbmd0aCkgKiAxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJ3cml0ZXMgb2JqMSdzIHZhbHVlcyB3aXRoIG9iajIncyBhbmQgYWRkcyBvYmoyJ3MgaWYgbm9uIGV4aXN0ZW50IGluIG9iajFcbiAgICogdmlhOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3MTI1MS9ob3ctY2FuLWktbWVyZ2UtcHJvcGVydGllcy1vZi10d28tamF2YXNjcmlwdC1vYmplY3RzLWR5bmFtaWNhbGx5XG4gICAqXG4gICAqIEBwYXJhbSBvYmoxXG4gICAqIEBwYXJhbSBvYmoyXG4gICAqIEByZXR1cm5zIG9iajMgYSBuZXcgb2JqZWN0IGJhc2VkIG9uIG9iajEgYW5kIG9iajJcbiAgICovXG4gIGZ1bmN0aW9uIF9tZXJnZU9wdGlvbnMob2JqMSxvYmoyKSB7XG4gICAgdmFyIG9iajMgPSB7fTtcbiAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBvYmoxKSB7IG9iajNbYXR0cm5hbWVdID0gb2JqMVthdHRybmFtZV07IH1cbiAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBvYmoyKSB7IG9iajNbYXR0cm5hbWVdID0gb2JqMlthdHRybmFtZV07IH1cbiAgICByZXR1cm4gb2JqMztcbiAgfVxuXG4gIHZhciBpbnRyb0pzID0gZnVuY3Rpb24gKHRhcmdldEVsbSkge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldEVsbSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAvL09rLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2VcbiAgICAgIHJldHVybiBuZXcgSW50cm9Kcyh0YXJnZXRFbG0pO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKHRhcmdldEVsbSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvL3NlbGVjdCB0aGUgdGFyZ2V0IGVsZW1lbnQgd2l0aCBxdWVyeSBzZWxlY3RvclxuICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldEVsbSk7XG5cbiAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50cm9Kcyh0YXJnZXRFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZWxlbWVudCB3aXRoIGdpdmVuIHNlbGVjdG9yLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludHJvSnMoZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IEludHJvSnMgdmVyc2lvblxuICAgKlxuICAgKiBAcHJvcGVydHkgdmVyc2lvblxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICovXG4gIGludHJvSnMudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgLy9Qcm90b3R5cGVcbiAgaW50cm9Kcy5mbiA9IEludHJvSnMucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEludHJvSnModGhpcyk7XG4gICAgfSxcbiAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gX21lcmdlT3B0aW9ucyh0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9pbnRyb0ZvckVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLl90YXJnZXRFbGVtZW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ29Ub1N0ZXA6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgIF9nb1RvU3RlcC5jYWxsKHRoaXMsIHN0ZXApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0U3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICBfbmV4dFN0ZXAuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHJldmlvdXNTdGVwOiBmdW5jdGlvbigpIHtcbiAgICAgIF9wcmV2aW91c1N0ZXAuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXhpdDogZnVuY3Rpb24oKSB7XG4gICAgICBfZXhpdEludHJvLmNhbGwodGhpcywgdGhpcy5fdGFyZ2V0RWxlbWVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgX3NldEhlbHBlckxheWVyUG9zaXRpb24uY2FsbCh0aGlzLCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm9qcy1oZWxwZXJMYXllcicpKTtcbiAgICAgIF9zZXRIZWxwZXJMYXllclBvc2l0aW9uLmNhbGwodGhpcywgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvanMtdG9vbHRpcFJlZmVyZW5jZUxheWVyJykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmJlZm9yZWNoYW5nZTogZnVuY3Rpb24ocHJvdmlkZWRDYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiAocHJvdmlkZWRDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5faW50cm9CZWZvcmVDaGFuZ2VDYWxsYmFjayA9IHByb3ZpZGVkQ2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGNhbGxiYWNrIGZvciBvbmJlZm9yZWNoYW5nZSB3YXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jaGFuZ2U6IGZ1bmN0aW9uKHByb3ZpZGVkQ2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVkQ2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2ludHJvQ2hhbmdlQ2FsbGJhY2sgPSBwcm92aWRlZENhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBjYWxsYmFjayBmb3Igb25jaGFuZ2Ugd2FzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmFmdGVyY2hhbmdlOiBmdW5jdGlvbihwcm92aWRlZENhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIChwcm92aWRlZENhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9pbnRyb0FmdGVyQ2hhbmdlQ2FsbGJhY2sgPSBwcm92aWRlZENhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBjYWxsYmFjayBmb3Igb25hZnRlcmNoYW5nZSB3YXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jb21wbGV0ZTogZnVuY3Rpb24ocHJvdmlkZWRDYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiAocHJvdmlkZWRDYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5faW50cm9Db21wbGV0ZUNhbGxiYWNrID0gcHJvdmlkZWRDYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgY2FsbGJhY2sgZm9yIG9uY29tcGxldGUgd2FzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmV4aXQ6IGZ1bmN0aW9uKHByb3ZpZGVkQ2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVkQ2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2ludHJvRXhpdENhbGxiYWNrID0gcHJvdmlkZWRDYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgY2FsbGJhY2sgZm9yIG9uZXhpdCB3YXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5pbnRyb0pzID0gaW50cm9KcztcbiAgcmV0dXJuIGludHJvSnM7XG59KSk7XG4iLCIvKlxuIExlYWZsZXQsIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBtb2JpbGUtZnJpZW5kbHkgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cDovL2xlYWZsZXRqcy5jb21cbiAoYykgMjAxMC0yMDEzLCBWbGFkaW1pciBBZ2Fmb25raW5cbiAoYykgMjAxMC0yMDExLCBDbG91ZE1hZGVcbiovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG52YXIgb2xkTCA9IHdpbmRvdy5MLFxyXG4gICAgTCA9IHt9O1xyXG5cclxuTC52ZXJzaW9uID0gJzAuNy43JztcclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGZvciBOb2RlIG1vZHVsZSBwYXR0ZXJuIGxvYWRlcnMsIGluY2x1ZGluZyBCcm93c2VyaWZ5XHJcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBMO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYW4gQU1EIG1vZHVsZVxyXG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdGRlZmluZShMKTtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYSBnbG9iYWwgTCB2YXJpYWJsZSwgc2F2aW5nIHRoZSBvcmlnaW5hbCBMIHRvIHJlc3RvcmUgbGF0ZXIgaWYgbmVlZGVkXHJcblxyXG5MLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0d2luZG93LkwgPSBvbGRMO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxud2luZG93LkwgPSBMO1xyXG5cblxuLypcclxuICogTC5VdGlsIGNvbnRhaW5zIHZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCB0aHJvdWdob3V0IExlYWZsZXQgY29kZS5cclxuICovXHJcblxyXG5MLlV0aWwgPSB7XHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoZGVzdCkgeyAvLyAoT2JqZWN0WywgT2JqZWN0LCAuLi5dKSAtPlxyXG5cdFx0dmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRcdGZvciAoaiA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdFx0c3JjID0gc291cmNlc1tqXSB8fCB7fTtcclxuXHRcdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGVzdDtcclxuXHR9LFxyXG5cclxuXHRiaW5kOiBmdW5jdGlvbiAoZm4sIG9iaikgeyAvLyAoRnVuY3Rpb24sIE9iamVjdCkgLT4gRnVuY3Rpb25cclxuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogbnVsbDtcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MgfHwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0c3RhbXA6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGFzdElkID0gMCxcclxuXHRcdCAgICBrZXkgPSAnX2xlYWZsZXRfaWQnO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqW2tleV0gPSBvYmpba2V5XSB8fCArK2xhc3RJZDtcclxuXHRcdFx0cmV0dXJuIG9ialtrZXldO1xyXG5cdFx0fTtcclxuXHR9KCkpLFxyXG5cclxuXHRpbnZva2VFYWNoOiBmdW5jdGlvbiAob2JqLCBtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdHZhciBpLCBhcmdzO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcclxuXHJcblx0XHRcdGZvciAoaSBpbiBvYmopIHtcclxuXHRcdFx0XHRtZXRob2QuYXBwbHkoY29udGV4dCwgW2ksIG9ialtpXV0uY29uY2F0KGFyZ3MpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0bGltaXRFeGVjQnlJbnRlcnZhbDogZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbG9jaywgZXhlY09uVW5sb2NrO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB3cmFwcGVyRm4oKSB7XHJcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0XHRleGVjT25VbmxvY2sgPSB0cnVlO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblxyXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRsb2NrID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmIChleGVjT25VbmxvY2spIHtcclxuXHRcdFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0XHRcdGV4ZWNPblVubG9jayA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGltZSk7XHJcblxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0ZmFsc2VGbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGZvcm1hdE51bTogZnVuY3Rpb24gKG51bSwgZGlnaXRzKSB7XHJcblx0XHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIGRpZ2l0cyB8fCA1KTtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcblx0fSxcclxuXHJcblx0dHJpbTogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcblx0fSxcclxuXHJcblx0c3BsaXRXb3JkczogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIEwuVXRpbC50cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuXHR9LFxyXG5cclxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCBvYmoub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyYW1TdHJpbmc6IGZ1bmN0aW9uIChvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHRcdHZhciBwYXJhbXMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG5cdH0sXHJcblx0dGVtcGxhdGU6IGZ1bmN0aW9uIChzdHIsIGRhdGEpIHtcclxuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFx7ICooW1xcd19dKykgKlxcfS9nLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuXHR9LFxyXG5cclxuXHRlbXB0eUltYWdlVXJsOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSdcclxufTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5cdGZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRcdHZhciBpLCBmbixcclxuXHRcdCAgICBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdvJywgJ21zJ107XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aCAmJiAhZm47IGkrKykge1xyXG5cdFx0XHRmbiA9IHdpbmRvd1twcmVmaXhlc1tpXSArIG5hbWVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmbjtcclxuXHR9XHJcblxyXG5cdHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG5cdGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHRcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdFx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdCAgICAgICAgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuXHJcblx0dmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0ICAgICAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdCAgICAgICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG5cclxuXHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgaW1tZWRpYXRlLCBlbGVtZW50KSB7XHJcblx0XHRmbiA9IEwuYmluZChmbiwgY29udGV4dCk7XHJcblxyXG5cdFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0XHRmbigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgZm4sIGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG59KCkpO1xyXG5cclxuLy8gc2hvcnRjdXRzIGZvciBtb3N0IHVzZWQgdXRpbGl0eSBmdW5jdGlvbnNcclxuTC5leHRlbmQgPSBMLlV0aWwuZXh0ZW5kO1xyXG5MLmJpbmQgPSBMLlV0aWwuYmluZDtcclxuTC5zdGFtcCA9IEwuVXRpbC5zdGFtcDtcclxuTC5zZXRPcHRpb25zID0gTC5VdGlsLnNldE9wdGlvbnM7XHJcblxuXG4vKlxyXG4gKiBMLkNsYXNzIHBvd2VycyB0aGUgT09QIGZhY2lsaXRpZXMgb2YgdGhlIGxpYnJhcnkuXHJcbiAqIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG4gKi9cclxuXHJcbkwuQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbkwuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIGV4dGVuZGVkIGNsYXNzIHdpdGggdGhlIG5ldyBwcm90b3R5cGVcclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3MpIHtcclxuXHRcdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gaW5zdGFudGlhdGUgY2xhc3Mgd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yXHJcblx0dmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHRGLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBuZXcgRigpO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvL2luaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdEwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0TC5VdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm9wcy5vcHRpb25zICYmIHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgcHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRMLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdHZhciBwYXJlbnQgPSB0aGlzO1xyXG5cdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0TmV3Q2xhc3MuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudC5wcm90b3R5cGUuY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnQucHJvdG90eXBlLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gbWV0aG9kIGZvciBhZGRpbmcgcHJvcGVydGllcyB0byBwcm90b3R5cGVcclxuTC5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxufTtcclxuXHJcbi8vIG1lcmdlIG5ldyBkZWZhdWx0IG9wdGlvbnMgdG8gdGhlIENsYXNzXHJcbkwuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8vIGFkZCBhIGNvbnN0cnVjdG9yIGhvb2tcclxuTC5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5NaXhpbi5FdmVudHMgaXMgdXNlZCB0byBhZGQgY3VzdG9tIGV2ZW50cyBmdW5jdGlvbmFsaXR5IHRvIExlYWZsZXQgY2xhc3Nlcy5cclxuICovXHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG5MLk1peGluID0ge307XHJcblxyXG5MLk1peGluLkV2ZW50cyA9IHtcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkgeyAvLyAoU3RyaW5nLCBGdW5jdGlvblssIE9iamVjdF0pIG9yIChPYmplY3RbLCBPYmplY3RdKVxyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKEwuVXRpbC5pbnZva2VFYWNoKHR5cGVzLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIsIHRoaXMsIGZuLCBjb250ZXh0KSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudHMgPSB0aGlzW2V2ZW50c0tleV0gPSB0aGlzW2V2ZW50c0tleV0gfHwge30sXHJcblx0XHQgICAgY29udGV4dElkID0gY29udGV4dCAmJiBjb250ZXh0ICE9PSB0aGlzICYmIEwuc3RhbXAoY29udGV4dCksXHJcblx0XHQgICAgaSwgbGVuLCBldmVudCwgdHlwZSwgaW5kZXhLZXksIGluZGV4TGVuS2V5LCB0eXBlSW5kZXg7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZXZlbnQgPSB7XHJcblx0XHRcdFx0YWN0aW9uOiBmbixcclxuXHRcdFx0XHRjb250ZXh0OiBjb250ZXh0IHx8IHRoaXNcclxuXHRcdFx0fTtcclxuXHRcdFx0dHlwZSA9IHR5cGVzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGNvbnRleHRJZCkge1xyXG5cdFx0XHRcdC8vIHN0b3JlIGxpc3RlbmVycyBvZiBhIHBhcnRpY3VsYXIgY29udGV4dCBpbiBhIHNlcGFyYXRlIGhhc2ggKGlmIGl0IGhhcyBhbiBpZClcclxuXHRcdFx0XHQvLyBnaXZlcyBhIG1ham9yIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcmVtb3ZpbmcgdGhvdXNhbmRzIG9mIG1hcCBsYXllcnNcclxuXHJcblx0XHRcdFx0aW5kZXhLZXkgPSB0eXBlICsgJ19pZHgnO1xyXG5cdFx0XHRcdGluZGV4TGVuS2V5ID0gaW5kZXhLZXkgKyAnX2xlbic7XHJcblxyXG5cdFx0XHRcdHR5cGVJbmRleCA9IGV2ZW50c1tpbmRleEtleV0gPSBldmVudHNbaW5kZXhLZXldIHx8IHt9O1xyXG5cclxuXHRcdFx0XHRpZiAoIXR5cGVJbmRleFtjb250ZXh0SWRdKSB7XHJcblx0XHRcdFx0XHR0eXBlSW5kZXhbY29udGV4dElkXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBrZXlzIGluIHRoZSBpbmRleCB0byBxdWlja2x5IGNoZWNrIGlmIGl0J3MgZW1wdHlcclxuXHRcdFx0XHRcdGV2ZW50c1tpbmRleExlbktleV0gPSAoZXZlbnRzW2luZGV4TGVuS2V5XSB8fCAwKSArIDE7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0eXBlSW5kZXhbY29udGV4dElkXS5wdXNoKGV2ZW50KTtcclxuXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGV2ZW50c1t0eXBlXSA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcclxuXHRcdFx0XHRldmVudHNbdHlwZV0ucHVzaChldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRoYXNFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKHR5cGUpIHsgLy8gKFN0cmluZykgLT4gQm9vbGVhblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XTtcclxuXHRcdHJldHVybiAhIWV2ZW50cyAmJiAoKHR5cGUgaW4gZXZlbnRzICYmIGV2ZW50c1t0eXBlXS5sZW5ndGggPiAwKSB8fFxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICAodHlwZSArICdfaWR4JyBpbiBldmVudHMgJiYgZXZlbnRzW3R5cGUgKyAnX2lkeF9sZW4nXSA+IDApKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7IC8vIChbU3RyaW5nLCBGdW5jdGlvbiwgT2JqZWN0XSkgb3IgKE9iamVjdFssIE9iamVjdF0pXHJcblxyXG5cdFx0aWYgKCF0aGlzW2V2ZW50c0tleV0pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0eXBlcykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuVXRpbC5pbnZva2VFYWNoKHR5cGVzLCB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIsIHRoaXMsIGZuLCBjb250ZXh0KSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudHMgPSB0aGlzW2V2ZW50c0tleV0sXHJcblx0XHQgICAgY29udGV4dElkID0gY29udGV4dCAmJiBjb250ZXh0ICE9PSB0aGlzICYmIEwuc3RhbXAoY29udGV4dCksXHJcblx0XHQgICAgaSwgbGVuLCB0eXBlLCBsaXN0ZW5lcnMsIGosIGluZGV4S2V5LCBpbmRleExlbktleSwgdHlwZUluZGV4LCByZW1vdmVkO1xyXG5cclxuXHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHR5cGUgPSB0eXBlc1tpXTtcclxuXHRcdFx0aW5kZXhLZXkgPSB0eXBlICsgJ19pZHgnO1xyXG5cdFx0XHRpbmRleExlbktleSA9IGluZGV4S2V5ICsgJ19sZW4nO1xyXG5cclxuXHRcdFx0dHlwZUluZGV4ID0gZXZlbnRzW2luZGV4S2V5XTtcclxuXHJcblx0XHRcdGlmICghZm4pIHtcclxuXHRcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzW2luZGV4S2V5XTtcclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzW2luZGV4TGVuS2V5XTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzID0gY29udGV4dElkICYmIHR5cGVJbmRleCA/IHR5cGVJbmRleFtjb250ZXh0SWRdIDogZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0XHRmb3IgKGogPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0XHRcdFx0aWYgKChsaXN0ZW5lcnNbal0uYWN0aW9uID09PSBmbikgJiYgKCFjb250ZXh0IHx8IChsaXN0ZW5lcnNbal0uY29udGV4dCA9PT0gY29udGV4dCkpKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVtb3ZlZCA9IGxpc3RlbmVycy5zcGxpY2UoaiwgMSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gc2V0IHRoZSBvbGQgYWN0aW9uIHRvIGEgbm8tb3AsIGJlY2F1c2UgaXQgaXMgcG9zc2libGVcclxuXHRcdFx0XHRcdFx0XHQvLyB0aGF0IHRoZSBsaXN0ZW5lciBpcyBiZWluZyBpdGVyYXRlZCBvdmVyIGFzIHBhcnQgb2YgYSBkaXNwYXRjaFxyXG5cdFx0XHRcdFx0XHRcdHJlbW92ZWRbMF0uYWN0aW9uID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoY29udGV4dCAmJiB0eXBlSW5kZXggJiYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApKSB7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSB0eXBlSW5kZXhbY29udGV4dElkXTtcclxuXHRcdFx0XHRcdFx0ZXZlbnRzW2luZGV4TGVuS2V5XS0tO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGRlbGV0ZSB0aGlzW2V2ZW50c0tleV07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRmaXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7IC8vIChTdHJpbmdbLCBPYmplY3RdKVxyXG5cdFx0aWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXJzKHR5cGUpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBldmVudCA9IEwuVXRpbC5leHRlbmQoe30sIGRhdGEsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzIH0pO1xyXG5cclxuXHRcdHZhciBldmVudHMgPSB0aGlzW2V2ZW50c0tleV0sXHJcblx0XHQgICAgbGlzdGVuZXJzLCBpLCBsZW4sIHR5cGVJbmRleCwgY29udGV4dElkO1xyXG5cclxuXHRcdGlmIChldmVudHNbdHlwZV0pIHtcclxuXHRcdFx0Ly8gbWFrZSBzdXJlIGFkZGluZy9yZW1vdmluZyBsaXN0ZW5lcnMgaW5zaWRlIG90aGVyIGxpc3RlbmVycyB3b24ndCBjYXVzZSBpbmZpbml0ZSBsb29wXHJcblx0XHRcdGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXS5zbGljZSgpO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmFjdGlvbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaXJlIGV2ZW50IGZvciB0aGUgY29udGV4dC1pbmRleGVkIGxpc3RlbmVycyBhcyB3ZWxsXHJcblx0XHR0eXBlSW5kZXggPSBldmVudHNbdHlwZSArICdfaWR4J107XHJcblxyXG5cdFx0Zm9yIChjb250ZXh0SWQgaW4gdHlwZUluZGV4KSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHR5cGVJbmRleFtjb250ZXh0SWRdLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uYWN0aW9uLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmIChMLlV0aWwuaW52b2tlRWFjaCh0eXBlcywgdGhpcy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciwgdGhpcywgZm4sIGNvbnRleHQpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBMLmJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5hZGRFdmVudExpc3RlbmVyKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAuYWRkRXZlbnRMaXN0ZW5lcih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5NaXhpbi5FdmVudHMub24gPSBMLk1peGluLkV2ZW50cy5hZGRFdmVudExpc3RlbmVyO1xyXG5MLk1peGluLkV2ZW50cy5vZmYgPSBMLk1peGluLkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5MLk1peGluLkV2ZW50cy5vbmNlID0gTC5NaXhpbi5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXI7XHJcbkwuTWl4aW4uRXZlbnRzLmZpcmUgPSBMLk1peGluLkV2ZW50cy5maXJlRXZlbnQ7XHJcblxuXG4vKlxyXG4gKiBMLkJyb3dzZXIgaGFuZGxlcyBkaWZmZXJlbnQgYnJvd3NlciBhbmQgZmVhdHVyZSBkZXRlY3Rpb25zIGZvciBpbnRlcm5hbCBMZWFmbGV0IHVzZS5cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93LFxyXG5cdFx0aWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixcclxuXHJcblx0ICAgIC8vIHRlcnJpYmxlIGJyb3dzZXIgZGV0ZWN0aW9uIHRvIHdvcmsgYXJvdW5kIFNhZmFyaSAvIGlPUyAvIEFuZHJvaWQgYnJvd3NlciBidWdzXHJcblx0ICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxyXG5cdCAgICB3ZWJraXQgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEsXHJcblx0ICAgIGNocm9tZSA9IHVhLmluZGV4T2YoJ2Nocm9tZScpICE9PSAtMSxcclxuXHQgICAgcGhhbnRvbWpzID0gdWEuaW5kZXhPZigncGhhbnRvbScpICE9PSAtMSxcclxuXHQgICAgYW5kcm9pZCA9IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblx0ICAgIGFuZHJvaWQyMyA9IHVhLnNlYXJjaCgnYW5kcm9pZCBbMjNdJykgIT09IC0xLFxyXG5cdFx0Z2Vja28gPSB1YS5pbmRleE9mKCdnZWNrbycpICE9PSAtMSxcclxuXHJcblx0ICAgIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkICsgJycsXHJcblx0ICAgIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudCxcclxuXHRcdHBvaW50ZXIgPSAod2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB8fFxyXG5cdFx0XHRcdCAgbXNQb2ludGVyLFxyXG5cdCAgICByZXRpbmEgPSAoJ2RldmljZVBpeGVsUmF0aW8nIGluIHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpIHx8XHJcblx0ICAgICAgICAgICAgICgnbWF0Y2hNZWRpYScgaW4gd2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXJlc29sdXRpb246MTQ0ZHBpKScpICYmXHJcblx0ICAgICAgICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi1yZXNvbHV0aW9uOjE0NGRwaSknKS5tYXRjaGVzKSxcclxuXHJcblx0ICAgIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHQgICAgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlKSxcclxuXHQgICAgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMyxcclxuXHQgICAgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gZG9jLnN0eWxlLFxyXG5cdCAgICBvcGVyYTNkID0gJ09UcmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCB8fCBvcGVyYTNkKSAmJiAhcGhhbnRvbWpzO1xyXG5cclxuXHR2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgIXBoYW50b21qcyAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHRcdGllOiBpZSxcclxuXHRcdGllbHQ5OiBpZWx0OSxcclxuXHRcdHdlYmtpdDogd2Via2l0LFxyXG5cdFx0Z2Vja286IGdlY2tvICYmICF3ZWJraXQgJiYgIXdpbmRvdy5vcGVyYSAmJiAhaWUsXHJcblxyXG5cdFx0YW5kcm9pZDogYW5kcm9pZCxcclxuXHRcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cclxuXHRcdGllM2Q6IGllM2QsXHJcblx0XHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0XHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cdFx0b3BlcmEzZDogb3BlcmEzZCxcclxuXHRcdGFueTNkOiBhbnkzZCxcclxuXHJcblx0XHRtb2JpbGU6IG1vYmlsZSxcclxuXHRcdG1vYmlsZVdlYmtpdDogbW9iaWxlICYmIHdlYmtpdCxcclxuXHRcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGUgJiYgd2Via2l0M2QsXHJcblx0XHRtb2JpbGVPcGVyYTogbW9iaWxlICYmIHdpbmRvdy5vcGVyYSxcclxuXHJcblx0XHR0b3VjaDogdG91Y2gsXHJcblx0XHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuXHRcdHBvaW50ZXI6IHBvaW50ZXIsXHJcblxyXG5cdFx0cmV0aW5hOiByZXRpbmFcclxuXHR9O1xyXG5cclxufSgpKTtcclxuXG5cbi8qXHJcbiAqIEwuUG9pbnQgcmVwcmVzZW50cyBhIHBvaW50IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLlBvaW50ID0gZnVuY3Rpb24gKC8qTnVtYmVyKi8geCwgLypOdW1iZXIqLyB5LCAvKkJvb2xlYW4qLyByb3VuZCkge1xyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn07XHJcblxyXG5MLlBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbkwucG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQm91bmRzIHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5Cb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyhQb2ludCwgUG9pbnQpIG9yIFBvaW50W11cclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHsgLy8gKEJvb2xlYW4pIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKEJvdW5kcykgb3IgKFBvaW50KSAtPiBCb29sZWFuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gTC5wb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5ib3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuYm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHsgLy8gKEJvdW5kcykgb3IgKFBvaW50LCBQb2ludCkgb3IgKFBvaW50W10pXHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Cb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlRyYW5zZm9ybWF0aW9uIGlzIGFuIHV0aWxpdHkgY2xhc3MgdG8gcGVyZm9ybSBzaW1wbGUgcG9pbnQgdHJhbnNmb3JtYXRpb25zIHRocm91Z2ggYSAyZC1tYXRyaXguXHJcbiAqL1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn07XHJcblxyXG5MLlRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXG5cbi8qXHJcbiAqIEwuRG9tVXRpbCBjb250YWlucyB2YXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRE9NLlxyXG4gKi9cclxuXHJcbkwuRG9tVXRpbCA9IHtcclxuXHRnZXQ6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdO1xyXG5cclxuXHRcdGlmICghdmFsdWUgJiYgZWwuY3VycmVudFN0eWxlKSB7XHJcblx0XHRcdHZhbHVlID0gZWwuY3VycmVudFN0eWxlW3N0eWxlXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Z2V0Vmlld3BvcnRPZmZzZXQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcblxyXG5cdFx0dmFyIHRvcCA9IDAsXHJcblx0XHQgICAgbGVmdCA9IDAsXHJcblx0XHQgICAgZWwgPSBlbGVtZW50LFxyXG5cdFx0ICAgIGRvY0JvZHkgPSBkb2N1bWVudC5ib2R5LFxyXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG5cdFx0ICAgIHBvcztcclxuXHJcblx0XHRkbyB7XHJcblx0XHRcdHRvcCAgKz0gZWwub2Zmc2V0VG9wICB8fCAwO1xyXG5cdFx0XHRsZWZ0ICs9IGVsLm9mZnNldExlZnQgfHwgMDtcclxuXHJcblx0XHRcdC8vYWRkIGJvcmRlcnNcclxuXHRcdFx0dG9wICs9IHBhcnNlSW50KEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JvcmRlclRvcFdpZHRoJyksIDEwKSB8fCAwO1xyXG5cdFx0XHRsZWZ0ICs9IHBhcnNlSW50KEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JvcmRlckxlZnRXaWR0aCcpLCAxMCkgfHwgMDtcclxuXHJcblx0XHRcdHBvcyA9IEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0XHRpZiAoZWwub2Zmc2V0UGFyZW50ID09PSBkb2NCb2R5ICYmIHBvcyA9PT0gJ2Fic29sdXRlJykgeyBicmVhazsgfVxyXG5cclxuXHRcdFx0aWYgKHBvcyA9PT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRcdHRvcCAgKz0gZG9jQm9keS5zY3JvbGxUb3AgIHx8IGRvY0VsLnNjcm9sbFRvcCAgfHwgMDtcclxuXHRcdFx0XHRsZWZ0ICs9IGRvY0JvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0IHx8IDA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChwb3MgPT09ICdyZWxhdGl2ZScgJiYgIWVsLm9mZnNldExlZnQpIHtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICd3aWR0aCcpLFxyXG5cdFx0XHRcdCAgICBtYXhXaWR0aCA9IEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ21heC13aWR0aCcpLFxyXG5cdFx0XHRcdCAgICByID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0XHRcdGlmICh3aWR0aCAhPT0gJ25vbmUnIHx8IG1heFdpZHRoICE9PSAnbm9uZScpIHtcclxuXHRcdFx0XHRcdGxlZnQgKz0gci5sZWZ0ICsgZWwuY2xpZW50TGVmdDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vY2FsY3VsYXRlIGZ1bGwgeSBvZmZzZXQgc2luY2Ugd2UncmUgYnJlYWtpbmcgb3V0IG9mIHRoZSBsb29wXHJcblx0XHRcdFx0dG9wICs9IHIudG9wICsgKGRvY0JvZHkuc2Nyb2xsVG9wICB8fCBkb2NFbC5zY3JvbGxUb3AgIHx8IDApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XHJcblxyXG5cdFx0fSB3aGlsZSAoZWwpO1xyXG5cclxuXHRcdGVsID0gZWxlbWVudDtcclxuXHJcblx0XHRkbyB7XHJcblx0XHRcdGlmIChlbCA9PT0gZG9jQm9keSkgeyBicmVhazsgfVxyXG5cclxuXHRcdFx0dG9wICAtPSBlbC5zY3JvbGxUb3AgIHx8IDA7XHJcblx0XHRcdGxlZnQgLT0gZWwuc2Nyb2xsTGVmdCB8fCAwO1xyXG5cclxuXHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0fSB3aGlsZSAoZWwpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsZWZ0LCB0b3ApO1xyXG5cdH0sXHJcblxyXG5cdGRvY3VtZW50SXNMdHI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghTC5Eb21VdGlsLl9kb2NJc0x0ckNhY2hlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuX2RvY0lzTHRyQ2FjaGVkID0gdHJ1ZTtcclxuXHRcdFx0TC5Eb21VdGlsLl9kb2NJc0x0ciA9IEwuRG9tVXRpbC5nZXRTdHlsZShkb2N1bWVudC5ib2R5LCAnZGlyZWN0aW9uJykgPT09ICdsdHInO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIEwuRG9tVXRpbC5fZG9jSXNMdHI7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlOiBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHJcblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG5cclxuXHRcdGlmIChjb250YWluZXIpIHtcclxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0aGFzQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0XHR9XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLl9nZXRDbGFzcyhlbCk7XHJcblx0XHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG5cdH0sXHJcblxyXG5cdGFkZENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR2YXIgY2xhc3NlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoIUwuRG9tVXRpbC5oYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IEwuRG9tVXRpbC5fZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0XHRMLkRvbVV0aWwuX3NldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuX3NldENsYXNzKGVsLCBMLlV0aWwudHJpbSgoJyAnICsgTC5Eb21VdGlsLl9nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9zZXRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldENsYXNzOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcblx0fSxcclxuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cclxuXHRcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHJcblx0XHRcdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHRcdFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHRcdFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHRcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdFx0XHRpZiAoZmlsdGVyKSB7XHJcblx0XHRcdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dGVzdFByb3A6IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGdldFRyYW5zbGF0ZVN0cmluZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBvbiBXZWJLaXQgYnJvd3NlcnMgKENocm9tZS9TYWZhcmkvaU9TIFNhZmFyaS9BbmRyb2lkKSB1c2luZyB0cmFuc2xhdGUzZCBpbnN0ZWFkIG9mIHRyYW5zbGF0ZVxyXG5cdFx0Ly8gbWFrZXMgYW5pbWF0aW9uIHNtb290aGVyIGFzIGl0IGVuc3VyZXMgSFcgYWNjZWwgaXMgdXNlZC4gRmlyZWZveCAxMyBkb2Vzbid0IGNhcmVcclxuXHRcdC8vIChzYW1lIHNwZWVkIGVpdGhlciB3YXkpLCBPcGVyYSAxMiBkb2Vzbid0IHN1cHBvcnQgdHJhbnNsYXRlM2RcclxuXHJcblx0XHR2YXIgaXMzZCA9IEwuQnJvd3Nlci53ZWJraXQzZCxcclxuXHRcdCAgICBvcGVuID0gJ3RyYW5zbGF0ZScgKyAoaXMzZCA/ICczZCcgOiAnJykgKyAnKCcsXHJcblx0XHQgICAgY2xvc2UgPSAoaXMzZCA/ICcsMCcgOiAnJykgKyAnKSc7XHJcblxyXG5cdFx0cmV0dXJuIG9wZW4gKyBwb2ludC54ICsgJ3B4LCcgKyBwb2ludC55ICsgJ3B4JyArIGNsb3NlO1xyXG5cdH0sXHJcblxyXG5cdGdldFNjYWxlU3RyaW5nOiBmdW5jdGlvbiAoc2NhbGUsIG9yaWdpbikge1xyXG5cclxuXHRcdHZhciBwcmVUcmFuc2xhdGVTdHIgPSBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbi5hZGQob3JpZ2luLm11bHRpcGx5QnkoLTEgKiBzY2FsZSkpKSxcclxuXHRcdCAgICBzY2FsZVN0ciA9ICcgc2NhbGUoJyArIHNjYWxlICsgJykgJztcclxuXHJcblx0XHRyZXR1cm4gcHJlVHJhbnNsYXRlU3RyICsgc2NhbGVTdHI7XHJcblx0fSxcclxuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcG9pbnQsIGRpc2FibGUzRCkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgQm9vbGVhbl0pXHJcblxyXG5cdFx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2VcclxuXHRcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cclxuXHRcdGlmICghZGlzYWJsZTNEICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRlbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9ICBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKHBvaW50KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0XHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBwcmVmaXggc3R5bGUgcHJvcGVydHkgbmFtZXNcclxuXHJcbkwuRG9tVXRpbC5UUkFOU0ZPUk0gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcbiAgICAgICAgWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbkwuRG9tVXRpbC5UUkFOU0lUSU9OID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG4gICAgICAgIFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5EID1cclxuICAgICAgICBMLkRvbVV0aWwuVFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IEwuRG9tVXRpbC5UUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID9cclxuICAgICAgICBMLkRvbVV0aWwuVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICBMLmV4dGVuZChMLkRvbVV0aWwsIHtcclxuICAgICAgICAgICAgZGlzYWJsZVRleHRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGVuYWJsZVRleHRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuICAgICAgICAgICAgWyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG4gICAgICAgIEwuZXh0ZW5kKEwuRG9tVXRpbCwge1xyXG4gICAgICAgICAgICBkaXNhYmxlVGV4dFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZW5hYmxlVGV4dFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gdGhpcy5fdXNlclNlbGVjdDtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdXNlclNlbGVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHRMLmV4dGVuZChMLkRvbVV0aWwsIHtcclxuXHRcdGRpc2FibGVJbWFnZURyYWc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0ZW5hYmxlSW1hZ2VEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59KSgpO1xyXG5cblxuLypcclxuICogTC5MYXRMbmcgcmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5MYXRMbmcgPSBmdW5jdGlvbiAobGF0LCBsbmcsIGFsdCkgeyAvLyAoTnVtYmVyLCBOdW1iZXIsIE51bWJlcilcclxuXHRsYXQgPSBwYXJzZUZsb2F0KGxhdCk7XHJcblx0bG5nID0gcGFyc2VGbG9hdChsbmcpO1xyXG5cclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdHRoaXMubGF0ID0gbGF0O1xyXG5cdHRoaXMubG5nID0gbG5nO1xyXG5cclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gcGFyc2VGbG9hdChhbHQpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuZXh0ZW5kKEwuTGF0TG5nLCB7XHJcblx0REVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcclxuXHRSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cdE1BWF9NQVJHSU46IDEuMEUtOSAvLyBtYXggbWFyZ2luIG9mIGVycm9yIGZvciB0aGUgXCJlcXVhbHNcIiBjaGVja1xyXG59KTtcclxuXHJcbkwuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gTC5sYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gTC5MYXRMbmcuTUFYX01BUkdJTjtcclxuXHR9LFxyXG5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikgeyAvLyAoTnVtYmVyKSAtPiBTdHJpbmdcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gSGF2ZXJzaW5lIGRpc3RhbmNlIGZvcm11bGEsIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXHJcblx0Ly8gVE9ETyBtb3ZlIHRvIHByb2plY3Rpb24gY29kZSwgTGF0TG5nIHNob3VsZG4ndCBrbm93IGFib3V0IEVhcnRoXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7IC8vIChMYXRMbmcpIC0+IE51bWJlclxyXG5cdFx0b3RoZXIgPSBMLmxhdExuZyhvdGhlcik7XHJcblxyXG5cdFx0dmFyIFIgPSA2Mzc4MTM3LCAvLyBlYXJ0aCByYWRpdXMgaW4gbWV0ZXJzXHJcblx0XHQgICAgZDJyID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcclxuXHRcdCAgICBkTGF0ID0gKG90aGVyLmxhdCAtIHRoaXMubGF0KSAqIGQycixcclxuXHRcdCAgICBkTG9uID0gKG90aGVyLmxuZyAtIHRoaXMubG5nKSAqIGQycixcclxuXHRcdCAgICBsYXQxID0gdGhpcy5sYXQgKiBkMnIsXHJcblx0XHQgICAgbGF0MiA9IG90aGVyLmxhdCAqIGQycixcclxuXHRcdCAgICBzaW4xID0gTWF0aC5zaW4oZExhdCAvIDIpLFxyXG5cdFx0ICAgIHNpbjIgPSBNYXRoLnNpbihkTG9uIC8gMik7XHJcblxyXG5cdFx0dmFyIGEgPSBzaW4xICogc2luMSArIHNpbjIgKiBzaW4yICogTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcclxuXHJcblx0XHRyZXR1cm4gUiAqIDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XHJcblx0fSxcclxuXHJcblx0d3JhcDogZnVuY3Rpb24gKGEsIGIpIHsgLy8gKE51bWJlciwgTnVtYmVyKSAtPiBMYXRMbmdcclxuXHRcdHZhciBsbmcgPSB0aGlzLmxuZztcclxuXHJcblx0XHRhID0gYSB8fCAtMTgwO1xyXG5cdFx0YiA9IGIgfHwgIDE4MDtcclxuXHJcblx0XHRsbmcgPSAobG5nICsgYikgJSAoYiAtIGEpICsgKGxuZyA8IGEgfHwgbG5nID09PSBiID8gYiA6IGEpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5sYXQsIGxuZyk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5sYXRMbmcgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTGF0TG5nKSBvciAoW051bWJlciwgTnVtYmVyXSkgb3IgKE51bWJlciwgTnVtYmVyKVxyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoYSkpIHtcclxuXHRcdGlmICh0eXBlb2YgYVswXSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFbMF0gPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbik7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEsIGIpO1xyXG59O1xyXG5cclxuXG5cbi8qXHJcbiAqIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIG9uIHRoZSBtYXAgaW4gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuXHJcbkwuTGF0TG5nQm91bmRzID0gZnVuY3Rpb24gKHNvdXRoV2VzdCwgbm9ydGhFYXN0KSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghc291dGhXZXN0KSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IG5vcnRoRWFzdCA/IFtzb3V0aFdlc3QsIG5vcnRoRWFzdF0gOiBzb3V0aFdlc3Q7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmcpIG9yIChMYXRMbmdCb3VuZHMpXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXRMbmcgPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0aWYgKGxhdExuZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRvYmogPSBsYXRMbmc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3NvdXRoV2VzdCAmJiAhdGhpcy5fbm9ydGhFYXN0KSB7XHJcblx0XHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IEwuTGF0TG5nKG9iai5sYXQsIG9iai5sbmcpO1xyXG5cdFx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMLkxhdExuZyhvYmoubGF0LCBvYmoubG5nKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9zb3V0aFdlc3QubGF0ID0gTWF0aC5taW4ob2JqLmxhdCwgdGhpcy5fc291dGhXZXN0LmxhdCk7XHJcblx0XHRcdFx0dGhpcy5fc291dGhXZXN0LmxuZyA9IE1hdGgubWluKG9iai5sbmcsIHRoaXMuX3NvdXRoV2VzdC5sbmcpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9ub3J0aEVhc3QubGF0ID0gTWF0aC5tYXgob2JqLmxhdCwgdGhpcy5fbm9ydGhFYXN0LmxhdCk7XHJcblx0XHRcdFx0dGhpcy5fbm9ydGhFYXN0LmxuZyA9IE1hdGgubWF4KG9iai5sbmcsIHRoaXMuX25vcnRoRWFzdC5sbmcpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMuZXh0ZW5kKG9iai5fc291dGhXZXN0KTtcclxuXHRcdFx0dGhpcy5leHRlbmQob2JqLl9ub3J0aEVhc3QpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgYnkgYSBwZXJjZW50YWdlXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHsgLy8gKE51bWJlcikgLT4gTGF0TG5nQm91bmRzXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMLkxhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHsgLy8gLT4gTGF0TG5nXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoTGF0TG5nQm91bmRzKVxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKExhdExuZ0JvdW5kcylcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy9UT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuTC5sYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nLCBMYXRMbmcpXHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlByb2plY3Rpb24gY29udGFpbnMgdmFyaW91cyBnZW9ncmFwaGljYWwgcHJvamVjdGlvbnMgdXNlZCBieSBDUlMgY2xhc3Nlcy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24gPSB7fTtcclxuXG5cbi8qXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBpcyB0aGUgbW9zdCBwb3B1bGFyIG1hcCBwcm9qZWN0aW9uLCB1c2VkIGJ5IEVQU0c6Mzg1NyBDUlMgdXNlZCBieSBkZWZhdWx0LlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICB4ID0gbGF0bG5nLmxuZyAqIGQsXHJcblx0XHQgICAgeSA9IGxhdCAqIGQ7XHJcblxyXG5cdFx0eSA9IE1hdGgubG9nKE1hdGgudGFuKChNYXRoLlBJIC8gNCkgKyAoeSAvIDIpKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludCwgQm9vbGVhbikgLT4gTGF0TG5nXHJcblx0XHR2YXIgZCA9IEwuTGF0TG5nLlJBRF9UT19ERUcsXHJcblx0XHQgICAgbG5nID0gcG9pbnQueCAqIGQsXHJcblx0XHQgICAgbGF0ID0gKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSkpIC0gKE1hdGguUEkgLyAyKSkgKiBkO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcobGF0LCBsbmcpO1xyXG5cdH1cclxufTtcclxuXG5cbi8qXHJcbiAqIFNpbXBsZSBlcXVpcmVjdGFuZ3VsYXIgKFBsYXRlIENhcnJlZSkgcHJvamVjdGlvbiwgdXNlZCBieSBDUlMgbGlrZSBFUFNHOjQzMjYgYW5kIFNpbXBsZS5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkNSUyBpcyBhIGJhc2Ugb2JqZWN0IGZvciBhbGwgZGVmaW5lZCBDUlMgKENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbXMpIGluIExlYWZsZXQuXHJcbiAqL1xyXG5cclxuTC5DUlMgPSB7XHJcblx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkgeyAvLyAoTGF0TG5nLCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7IC8vIChQb2ludCwgTnVtYmVyWywgQm9vbGVhbl0pIC0+IExhdExuZ1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIHMgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cdFx0cmV0dXJuIEwucG9pbnQocywgcyk7XHJcblx0fVxyXG59O1xyXG5cblxuLypcbiAqIEEgc2ltcGxlIENSUyB0aGF0IGNhbiBiZSB1c2VkIGZvciBmbGF0IG5vbi1FYXJ0aCBtYXBzIGxpa2UgcGFub3JhbWFzIG9yIGdhbWUgbWFwcy5cbiAqL1xuXG5MLkNSUy5TaW1wbGUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH1cbn0pO1xuXG5cbi8qXHJcbiAqIEwuQ1JTLkVQU0czODU3IChTcGhlcmljYWwgTWVyY2F0b3IpIGlzIHRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIHdlYiBtYXBwaW5nXHJcbiAqIGFuZCBpcyB1c2VkIGJ5IExlYWZsZXQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzg1NyA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDAuNSAvIE1hdGguUEksIDAuNSwgLTAuNSAvIE1hdGguUEksIDAuNSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Lm11bHRpcGx5QnkoZWFydGhSYWRpdXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLkNSUy5FUFNHOTAwOTEzID0gTC5leHRlbmQoe30sIEwuQ1JTLkVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuXG5cbi8qXHJcbiAqIEwuQ1JTLkVQU0c0MzI2IGlzIGEgQ1JTIHBvcHVsYXIgYW1vbmcgYWR2YW5jZWQgR0lTIHNwZWNpYWxpc3RzLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0c0MzI2ID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5Mb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEgLyAzNjAsIDAuNSwgLTEgLyAzNjAsIDAuNSlcclxufSk7XHJcblxuXG4vKlxyXG4gKiBMLk1hcCBpcyB0aGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIC0gaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAuXHJcbiAqL1xyXG5cclxuTC5NYXAgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Y3JzOiBMLkNSUy5FUFNHMzg1NyxcclxuXHJcblx0XHQvKlxyXG5cdFx0Y2VudGVyOiBMYXRMbmcsXHJcblx0XHR6b29tOiBOdW1iZXIsXHJcblx0XHRsYXllcnM6IEFycmF5LFxyXG5cdFx0Ki9cclxuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlLFxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogTC5Eb21VdGlsLlRSQU5TSVRJT04gJiYgTC5Ccm93c2VyLmFueTNkXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gTC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KEwubGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl90aWxlTGF5ZXJzTnVtID0gMDtcclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnMob3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwdWJsaWMgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gcmVwbGFjZWQgYnkgYW5pbWF0aW9uLXBvd2VyZWQgaW1wbGVtZW50YXRpb24gaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb207XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoTC5sYXRMbmcoY2VudGVyKSwgdGhpcy5fbGltaXRab29tKHpvb20pKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgKGRlbHRhIHx8IDEpLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIChkZWx0YSB8fCAxKSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAob3B0aW9ucy5tYXhab29tKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCkgeyAvLyAoUG9pbnQpXHJcblx0XHQvLyByZXBsYWNlZCB3aXRoIGFuaW1hdGVkIHBhbkJ5IGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblxyXG5cdFx0dGhpcy5fcmF3UGFuQnkoTC5wb2ludChvZmZzZXQpKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAoIWJvdW5kcykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHQvLyBUT0RPIG1ldGhvZCBpcyB0b28gYmlnLCByZWZhY3RvclxyXG5cclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdC8vIFRPRE8gZ2V0TWF4Wm9vbSwgZ2V0TWluWm9vbSBpbiBJTGF5ZXIgKGluc3RlYWQgb2Ygb3B0aW9ucylcclxuXHRcdGlmIChsYXllci5vcHRpb25zICYmICghaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkpIHtcclxuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyBsb29rcyB1Z2x5LCByZWZhY3RvciEhIVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuVGlsZUxheWVyICYmIChsYXllciBpbnN0YW5jZW9mIEwuVGlsZUxheWVyKSkge1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzTnVtKys7XHJcblx0XHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQrKztcclxuXHRcdFx0bGF5ZXIub24oJ2xvYWQnLCB0aGlzLl9vblRpbGVMYXllckxvYWQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJBZGQobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyBsb29rcyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuVGlsZUxheWVyICYmIChsYXllciBpbnN0YW5jZW9mIEwuVGlsZUxheWVyKSkge1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzTnVtLS07XHJcblx0XHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQtLTtcclxuXHRcdFx0bGF5ZXIub2ZmKCdsb2FkJywgdGhpcy5fb25UaWxlTGF5ZXJMb2FkLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIWxheWVyKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHJldHVybiAoTC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9pbml0aWFsQ2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBoYW5kbGVyLmFkZFRvXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoJ29mZicpO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJQYW5lcygpO1xyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHB1YmxpYyBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHsgLy8gKEJvb2xlYW4pIC0+IExhdExuZ1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0aWFsQ2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9pbml0aWFsQ2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01pblpvb20gPT09IHVuZGVmaW5lZCA/IDAgOiB0aGlzLl9sYXllcnNNaW5ab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRNaW5ab29tKCkgLSAoaW5zaWRlID8gMSA6IDApLFxyXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICB6b29tTm90Rm91bmQgPSB0cnVlLFxyXG5cdFx0ICAgIGJvdW5kc1NpemU7XHJcblxyXG5cdFx0cGFkZGluZyA9IEwucG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdGRvIHtcclxuXHRcdFx0em9vbSsrO1xyXG5cdFx0XHRib3VuZHNTaXplID0gdGhpcy5wcm9qZWN0KHNlLCB6b29tKS5zdWJ0cmFjdCh0aGlzLnByb2plY3QobncsIHpvb20pKS5hZGQocGFkZGluZyk7XHJcblx0XHRcdHpvb21Ob3RGb3VuZCA9ICFpbnNpZGUgPyBzaXplLmNvbnRhaW5zKGJvdW5kc1NpemUpIDogYm91bmRzU2l6ZS54IDwgc2l6ZS54IHx8IGJvdW5kc1NpemUueSA8IHNpemUueTtcclxuXHJcblx0XHR9IHdoaWxlICh6b29tTm90Rm91bmQgJiYgem9vbSA8PSBtYXhab29tKTtcclxuXHJcblx0XHRpZiAoem9vbU5vdEZvdW5kICYmIGluc2lkZSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5zaWRlID8gem9vbSA6IHpvb20gLSAxO1xyXG5cdH0sXHJcblxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IEwuUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoKTtcclxuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9pbml0aWFsVG9wTGVmdFBvaW50O1xyXG5cdH0sXHJcblxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZSh0aGlzLl96b29tKTtcclxuXHR9LFxyXG5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb20gKyAoTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBjb252ZXJzaW9uIG1ldGhvZHNcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkgeyAvLyAoTGF0TG5nWywgTnVtYmVyXSkgLT4gUG9pbnRcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQoTC5sYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHsgLy8gKFBvaW50WywgTnVtYmVyXSkgLT4gTGF0TG5nXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKEwucG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7IC8vIChMYXRMbmcpXHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QoTC5sYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChMLnBvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoTC5sYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb250YWluZXIuX2xlYWZsZXQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBMLkRvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSBwYW5lcy5tYXBQYW5lID0gdGhpcy5fY3JlYXRlUGFuZSgnbGVhZmxldC1tYXAtcGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0dGhpcy5fdGlsZVBhbmUgPSBwYW5lcy50aWxlUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtdGlsZS1wYW5lJywgdGhpcy5fbWFwUGFuZSk7XHJcblx0XHRwYW5lcy5vYmplY3RzUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtb2JqZWN0cy1wYW5lJywgdGhpcy5fbWFwUGFuZSk7XHJcblx0XHRwYW5lcy5zaGFkb3dQYW5lID0gdGhpcy5fY3JlYXRlUGFuZSgnbGVhZmxldC1zaGFkb3ctcGFuZScpO1xyXG5cdFx0cGFuZXMub3ZlcmxheVBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LW92ZXJsYXktcGFuZScpO1xyXG5cdFx0cGFuZXMubWFya2VyUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtbWFya2VyLXBhbmUnKTtcclxuXHRcdHBhbmVzLnBvcHVwUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtcG9wdXAtcGFuZScpO1xyXG5cclxuXHRcdHZhciB6b29tSGlkZSA9ICcgbGVhZmxldC16b29tLWhpZGUnO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsIHpvb21IaWRlKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsIHpvb21IaWRlKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnBvcHVwUGFuZSwgem9vbUhpZGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVQYW5lOiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9wYW5lcy5vYmplY3RzUGFuZSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyUGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9tYXBQYW5lKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoTC5VdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHByZXNlcnZlTWFwT2Zmc2V0LCBhZnRlclpvb21BbmltKSB7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gKHRoaXMuX3pvb20gIT09IHpvb20pO1xyXG5cclxuXHRcdGlmICghYWZ0ZXJab29tQW5pbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5faW5pdGlhbENlbnRlciA9IGNlbnRlcjtcclxuXHJcblx0XHR0aGlzLl9pbml0aWFsVG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0TmV3VG9wTGVmdFBvaW50KGNlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFwcmVzZXJ2ZU1hcE9mZnNldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IEwuUG9pbnQoMCwgMCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5faW5pdGlhbFRvcExlZnRQb2ludC5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZUxheWVyc1RvTG9hZCA9IHRoaXMuX3RpbGVMYXllcnNOdW07XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcsIHtoYXJkOiAhcHJlc2VydmVNYXBPZmZzZXR9KTtcclxuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fbGF5ZXJBZGQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCBhZnRlclpvb21BbmltKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcsIHtoYXJkOiAhcHJlc2VydmVNYXBPZmZzZXR9KTtcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksXHJcblx0XHRcdG1pblpvb20gPSBJbmZpbml0eSxcclxuXHRcdFx0bWF4Wm9vbSA9IC1JbmZpbml0eSxcclxuXHRcdFx0b2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldO1xyXG5cdFx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcclxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5taW4obWluWm9vbSwgbGF5ZXIub3B0aW9ucy5taW5ab29tKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkpIHtcclxuXHRcdFx0XHRtYXhab29tID0gTWF0aC5tYXgobWF4Wm9vbSwgbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHsgLy8gd2UgaGF2ZSBubyB0aWxlbGF5ZXJzXHJcblx0XHRcdHRoaXMuX2xheWVyc01heFpvb20gPSB0aGlzLl9sYXllcnNNaW5ab29tID0gdW5kZWZpbmVkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb207XHJcblx0XHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBtYXAgZXZlbnRzXHJcblxyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAob25PZmYpIHtcclxuXHRcdGlmICghTC5Eb21FdmVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRvbk9mZiA9IG9uT2ZmIHx8ICdvbic7XHJcblxyXG5cdFx0TC5Eb21FdmVudFtvbk9mZl0odGhpcy5fY29udGFpbmVyLCAnY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBldmVudHMgPSBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlZW50ZXInLFxyXG5cdFx0ICAgICAgICAgICAgICAnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXSxcclxuXHRcdCAgICBpLCBsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lciwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50W29uT2ZmXSh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzLCBmYWxzZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgKCFlLl9zaW11bGF0ZWQgJiZcclxuXHRcdCAgICAgICAgKCh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcubW92ZWQoKSkgfHxcclxuXHRcdCAgICAgICAgICh0aGlzLmJveFpvb20gICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKSkpIHx8XHJcblx0XHQgICAgICAgICAgICBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuZmlyZSgncHJlY2xpY2snKTtcclxuXHRcdHRoaXMuX2ZpcmVNb3VzZUV2ZW50KGUpO1xyXG5cdH0sXHJcblxyXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IEwuRG9tRXZlbnQuX3NraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0dHlwZSA9ICh0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICh0eXBlID09PSAnbW91c2VsZWF2ZScgPyAnbW91c2VvdXQnIDogdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGhpcy5oYXNFdmVudExpc3RlbmVycyh0eXBlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250YWluZXJQb2ludCA9IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSksXHJcblx0XHQgICAgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpLFxyXG5cdFx0ICAgIGxhdGxuZyA9IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSh0eXBlLCB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxyXG5cdFx0XHRjb250YWluZXJQb2ludDogY29udGFpbmVyUG9pbnQsXHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVMYXllckxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQtLTtcclxuXHRcdGlmICh0aGlzLl90aWxlTGF5ZXJzTnVtICYmICF0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndGlsZWxheWVyc2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2xheWVyQWRkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9uQWRkKHRoaXMpO1xyXG5cdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdC8vIFRPRE8gcm91bmQgb24gZGlzcGxheSwgbm90IGNhbGN1bGF0aW9uIHRvIGluY3JlYXNlIHByZWNpc2lvbj9cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIG5ld1pvb20sIG5ld0NlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdUb3BMZWZ0UG9pbnQobmV3Q2VudGVyLCBuZXdab29tKS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCBuZXdab29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEwuQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBud09mZnNldCA9IHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgc2VPZmZzZXQgPSB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobndPZmZzZXQueCwgLXNlT2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChud09mZnNldC55LCAtc2VPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLm1hcCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXAoaWQsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTWVyY2F0b3IgcHJvamVjdGlvbiB0aGF0IHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBFYXJ0aCBpcyBub3QgYSBwZXJmZWN0IHNwaGVyZS5cclxuICogTGVzcyBwb3B1bGFyIHRoYW4gc3BoZXJpY2FsIG1lcmNhdG9yOyB1c2VkIGJ5IHByb2plY3Rpb25zIGxpa2UgRVBTRzozMzk1LlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5NZXJjYXRvciA9IHtcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA4NDA1OTE1NTYsXHJcblxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cdFJfTUFKT1I6IDYzNzgxMzcsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICByID0gdGhpcy5SX01BSk9SLFxyXG5cdFx0ICAgIHIyID0gdGhpcy5SX01JTk9SLFxyXG5cdFx0ICAgIHggPSBsYXRsbmcubG5nICogZCAqIHIsXHJcblx0XHQgICAgeSA9IGxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gcjIgLyByLFxyXG5cdFx0ICAgIGVjY2VudCA9IE1hdGguc3FydCgxLjAgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGVjY2VudCAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZWNjZW50ICogMC41KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbigwLjUgKiAoKE1hdGguUEkgKiAwLjUpIC0geSkpIC8gY29uO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2codHMpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQsIEJvb2xlYW4pIC0+IExhdExuZ1xyXG5cdFx0dmFyIGQgPSBMLkxhdExuZy5SQURfVE9fREVHLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlJfTUFKT1IsXHJcblx0XHQgICAgcjIgPSB0aGlzLlJfTUlOT1IsXHJcblx0XHQgICAgbG5nID0gcG9pbnQueCAqIGQgLyByLFxyXG5cdFx0ICAgIHRtcCA9IHIyIC8gcixcclxuXHRcdCAgICBlY2NlbnQgPSBNYXRoLnNxcnQoMSAtICh0bXAgKiB0bXApKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC0gcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IChNYXRoLlBJIC8gMikgLSAyICogTWF0aC5hdGFuKHRzKSxcclxuXHRcdCAgICBudW1JdGVyID0gMTUsXHJcblx0XHQgICAgdG9sID0gMWUtNyxcclxuXHRcdCAgICBpID0gbnVtSXRlcixcclxuXHRcdCAgICBkcGhpID0gMC4xLFxyXG5cdFx0ICAgIGNvbjtcclxuXHJcblx0XHR3aGlsZSAoKE1hdGguYWJzKGRwaGkpID4gdG9sKSAmJiAoLS1pID4gMCkpIHtcclxuXHRcdFx0Y29uID0gZWNjZW50ICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0ZHBoaSA9IChNYXRoLlBJIC8gMikgLSAyICogTWF0aC5hdGFuKHRzICpcclxuXHRcdFx0ICAgICAgICAgICAgTWF0aC5wb3coKDEuMCAtIGNvbikgLyAoMS4wICsgY29uKSwgMC41ICogZWNjZW50KSkgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcocGhpICogZCwgbG5nKTtcclxuXHR9XHJcbn07XHJcblxuXG5cclxuTC5DUlMuRVBTRzMzOTUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtID0gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cdFx0ICAgIHIgPSBtLlJfTUFKT1IsXHJcblx0XHQgICAgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIHIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIEwuVGlsZUxheWVyIGlzIHVzZWQgZm9yIHN0YW5kYXJkIHh5ei1udW1iZXJlZCB0aWxlIGxheWVycy5cclxuICovXHJcblxyXG5MLlRpbGVMYXllciA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1pblpvb206IDAsXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHRcdHRpbGVTaXplOiAyNTYsXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblx0XHRhdHRyaWJ1dGlvbjogJycsXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHRcdC8qXHJcblx0XHRtYXhOYXRpdmVab29tOiBudWxsLFxyXG5cdFx0ekluZGV4OiBudWxsLFxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHRcdGNvbnRpbnVvdXNXb3JsZDogZmFsc2UsXHJcblx0XHRub1dyYXA6IGZhbHNlLFxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHRcdHJldXNlVGlsZXM6IGZhbHNlLFxyXG5cdFx0Ym91bmRzOiBmYWxzZSxcclxuXHRcdCovXHJcblx0XHR1bmxvYWRJbnZpc2libGVUaWxlczogTC5Ccm93c2VyLm1vYmlsZSxcclxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBMLkJyb3dzZXIubW9iaWxlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMubWluWm9vbSA+IDApIHtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20tLTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmJvdW5kcykge1xyXG5cdFx0XHRvcHRpb25zLmJvdW5kcyA9IEwubGF0TG5nQm91bmRzKG9wdGlvbnMuYm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHN1YmRvbWFpbnMgPSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucztcclxuXHJcblx0XHRpZiAodHlwZW9mIHN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5zdWJkb21haW5zID0gc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHRoaXMuX2FuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0Ly8gY3JlYXRlIGEgY29udGFpbmVyIGRpdiBmb3IgdGlsZXNcclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcclxuXHJcblx0XHQvLyBzZXQgdXAgZXZlbnRzXHJcblx0XHRtYXAub24oe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5fcmVzZXQsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlXHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKHtcclxuXHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcclxuXHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFpvb21BbmltXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XHJcblx0XHRcdHRoaXMuX2xpbWl0ZWRVcGRhdGUgPSBMLlV0aWwubGltaXRFeGVjQnlJbnRlcnZhbCh0aGlzLl91cGRhdGUsIDE1MCwgdGhpcyk7XHJcblx0XHRcdG1hcC5vbignbW92ZScsIHRoaXMuX2xpbWl0ZWRVcGRhdGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0bWFwLm9mZih7XHJcblx0XHRcdCd2aWV3cmVzZXQnOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0J21vdmVlbmQnOiB0aGlzLl91cGRhdGVcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKHtcclxuXHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcclxuXHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFpvb21BbmltXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XHJcblx0XHRcdG1hcC5vZmYoJ21vdmUnLCB0aGlzLl9saW1pdGVkVXBkYXRlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lID0gdGhpcy5fbWFwLl9wYW5lcy50aWxlUGFuZTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChwYW5lLCBNYXRoLm1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lID0gdGhpcy5fbWFwLl9wYW5lcy50aWxlUGFuZTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHBhbmUuaW5zZXJ0QmVmb3JlKHRoaXMuX2NvbnRhaW5lciwgcGFuZS5maXJzdENoaWxkKTtcclxuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChwYW5lLCBNYXRoLm1pbik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoe2hhcmQ6IHRydWV9KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKHBhbmUsIGNvbXBhcmUpIHtcclxuXHJcblx0XHR2YXIgbGF5ZXJzID0gcGFuZS5jaGlsZHJlbixcclxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoSW5maW5pdHksIC1JbmZpbml0eSksIC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXHJcblx0XHQgICAgekluZGV4LCBpLCBsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0XHR6SW5kZXggPSBwYXJzZUludChsYXllcnNbaV0uc3R5bGUuekluZGV4LCAxMCk7XHJcblxyXG5cdFx0XHRcdGlmICghaXNOYU4oekluZGV4KSkge1xyXG5cdFx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgekluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9XHJcblx0XHQgICAgICAgIChpc0Zpbml0ZShlZGdlWkluZGV4KSA/IGVkZ2VaSW5kZXggOiAwKSArIGNvbXBhcmUoMSwgLTEpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSxcclxuXHRcdCAgICB0aWxlcyA9IHRoaXMuX3RpbGVzO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0Zm9yIChpIGluIHRpbGVzKSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZXNbaV0sIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB0aWxlUGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXInKTtcclxuXHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXRpbGUtY29udGFpbmVyJztcclxuXHJcblx0XHRcdFx0dGhpcy5fYmdCdWZmZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGlsZVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge3RpbGU6IHRoaXMuX3RpbGVzW2tleV19KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xyXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQgPSAwO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmV1c2VUaWxlcykge1xyXG5cdFx0XHR0aGlzLl91bnVzZWRUaWxlcyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RpbGVDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkICYmIGUgJiYgZS5oYXJkKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQmdCdWZmZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XHJcblx0fSxcclxuXHJcblx0X2dldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpICsgdGhpcy5vcHRpb25zLnpvb21PZmZzZXQsXHJcblx0XHQgICAgem9vbU4gPSB0aGlzLm9wdGlvbnMubWF4TmF0aXZlWm9vbSxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcclxuXHJcblx0XHRpZiAoem9vbU4gJiYgem9vbSA+IHpvb21OKSB7XHJcblx0XHRcdHRpbGVTaXplID0gTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbVNjYWxlKHpvb20pIC8gbWFwLmdldFpvb21TY2FsZSh6b29tTikgKiB0aWxlU2l6ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpbGVTaXplO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcclxuXHJcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSBMLmJvdW5kcyhcclxuXHRcdCAgICAgICAgYm91bmRzLm1pbi5kaXZpZGVCeSh0aWxlU2l6ZSkuX2Zsb29yKCksXHJcblx0XHQgICAgICAgIGJvdW5kcy5tYXguZGl2aWRlQnkodGlsZVNpemUpLl9mbG9vcigpKTtcclxuXHJcblx0XHR0aGlzLl9hZGRUaWxlc0Zyb21DZW50ZXJPdXQodGlsZUJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy51bmxvYWRJbnZpc2libGVUaWxlcyB8fCB0aGlzLm9wdGlvbnMucmV1c2VUaWxlcykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVPdGhlclRpbGVzKHRpbGVCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hZGRUaWxlc0Zyb21DZW50ZXJPdXQ6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBxdWV1ZSA9IFtdLFxyXG5cdFx0ICAgIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcclxuXHJcblx0XHR2YXIgaiwgaSwgcG9pbnQ7XHJcblxyXG5cdFx0Zm9yIChqID0gYm91bmRzLm1pbi55OyBqIDw9IGJvdW5kcy5tYXgueTsgaisrKSB7XHJcblx0XHRcdGZvciAoaSA9IGJvdW5kcy5taW4ueDsgaSA8PSBib3VuZHMubWF4Lng7IGkrKykge1xyXG5cdFx0XHRcdHBvaW50ID0gbmV3IEwuUG9pbnQoaSwgaik7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLl90aWxlU2hvdWxkQmVMb2FkZWQocG9pbnQpKSB7XHJcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBvaW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGlsZXNUb0xvYWQgPSBxdWV1ZS5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKHRpbGVzVG9Mb2FkID09PSAwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXHJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8oY2VudGVyKSAtIGIuZGlzdGFuY2VUbyhjZW50ZXIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG5cclxuXHRcdC8vIGlmIGl0cyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxyXG5cdFx0aWYgKCF0aGlzLl90aWxlc1RvTG9hZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90aWxlc1RvTG9hZCArPSB0aWxlc1RvTG9hZDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlsZXNUb0xvYWQ7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZUNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVTaG91bGRCZUxvYWRlZDogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0aWYgKCh0aWxlUG9pbnQueCArICc6JyArIHRpbGVQb2ludC55KSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGFscmVhZHkgbG9hZGVkXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKCFvcHRpb25zLmNvbnRpbnVvdXNXb3JsZCkge1xyXG5cdFx0XHR2YXIgbGltaXQgPSB0aGlzLl9nZXRXcmFwVGlsZU51bSgpO1xyXG5cclxuXHRcdFx0Ly8gZG9uJ3QgbG9hZCBpZiBleGNlZWRzIHdvcmxkIGJvdW5kc1xyXG5cdFx0XHRpZiAoKG9wdGlvbnMubm9XcmFwICYmICh0aWxlUG9pbnQueCA8IDAgfHwgdGlsZVBvaW50LnggPj0gbGltaXQueCkpIHx8XHJcblx0XHRcdFx0dGlsZVBvaW50LnkgPCAwIHx8IHRpbGVQb2ludC55ID49IGxpbWl0LnkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYm91bmRzKSB7XHJcblx0XHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuX2dldFRpbGVTaXplKCksXHJcblx0XHRcdCAgICBud1BvaW50ID0gdGlsZVBvaW50Lm11bHRpcGx5QnkodGlsZVNpemUpLFxyXG5cdFx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKFt0aWxlU2l6ZSwgdGlsZVNpemVdKSxcclxuXHRcdFx0ICAgIG53ID0gdGhpcy5fbWFwLnVucHJvamVjdChud1BvaW50KSxcclxuXHRcdFx0ICAgIHNlID0gdGhpcy5fbWFwLnVucHJvamVjdChzZVBvaW50KTtcclxuXHJcblx0XHRcdC8vIFRPRE8gdGVtcG9yYXJ5IGhhY2ssIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xNjE4XHJcblx0XHRcdGlmICghb3B0aW9ucy5jb250aW51b3VzV29ybGQgJiYgIW9wdGlvbnMubm9XcmFwKSB7XHJcblx0XHRcdFx0bncgPSBudy53cmFwKCk7XHJcblx0XHRcdFx0c2UgPSBzZS53cmFwKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy5ib3VuZHMuaW50ZXJzZWN0cyhbbncsIHNlXSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZU90aGVyVGlsZXM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBrQXJyLCB4LCB5LCBrZXk7XHJcblxyXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0a0FyciA9IGtleS5zcGxpdCgnOicpO1xyXG5cdFx0XHR4ID0gcGFyc2VJbnQoa0FyclswXSwgMTApO1xyXG5cdFx0XHR5ID0gcGFyc2VJbnQoa0FyclsxXSwgMTApO1xyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzXHJcblx0XHRcdGlmICh4IDwgYm91bmRzLm1pbi54IHx8IHggPiBib3VuZHMubWF4LnggfHwgeSA8IGJvdW5kcy5taW4ueSB8fCB5ID4gYm91bmRzLm1heC55KSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7dGlsZTogdGlsZSwgdXJsOiB0aWxlLnNyY30pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmV1c2VUaWxlcykge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcclxuXHRcdFx0dGhpcy5fdW51c2VkVGlsZXMucHVzaCh0aWxlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRpbGUucGFyZW50Tm9kZSA9PT0gdGhpcy5fdGlsZUNvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl90aWxlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRpbGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vQ2xvdWRNYWRlL0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHR0aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0XHRcdHRpbGUuc3JjID0gTC5VdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XHJcblx0fSxcclxuXHJcblx0X2FkZFRpbGU6IGZ1bmN0aW9uICh0aWxlUG9pbnQsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKHRpbGVQb2ludCk7XHJcblxyXG5cdFx0Ly8gZ2V0IHVudXNlZCB0aWxlIC0gb3IgY3JlYXRlIGEgbmV3IHRpbGVcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fZ2V0VGlsZSgpO1xyXG5cclxuXHRcdC8qXHJcblx0XHRDaHJvbWUgMjAgbGF5b3V0cyBtdWNoIGZhc3RlciB3aXRoIHRvcC9sZWZ0ICh2ZXJpZnkgd2l0aCB0aW1lbGluZSwgZnJhbWVzKVxyXG5cdFx0QW5kcm9pZCA0IGJyb3dzZXIgaGFzIGRpc3BsYXkgaXNzdWVzIHdpdGggdG9wL2xlZnQgYW5kIHJlcXVpcmVzIHRyYW5zZm9ybSBpbnN0ZWFkXHJcblx0XHQob3RoZXIgYnJvd3NlcnMgZG9uJ3QgY3VycmVudGx5IGNhcmUpIC0gc2VlIGRlYnVnL2hhY2tzL2ppdHRlci5odG1sIGZvciBhbiBleGFtcGxlXHJcblx0XHQqL1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MsIEwuQnJvd3Nlci5jaHJvbWUpO1xyXG5cclxuXHRcdHRoaXMuX3RpbGVzW3RpbGVQb2ludC54ICsgJzonICsgdGlsZVBvaW50LnldID0gdGlsZTtcclxuXHJcblx0XHR0aGlzLl9sb2FkVGlsZSh0aWxlLCB0aWxlUG9pbnQpO1xyXG5cclxuXHRcdGlmICh0aWxlLnBhcmVudE5vZGUgIT09IHRoaXMuX3RpbGVDb250YWluZXIpIHtcclxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG9wdGlvbnMubWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0em9vbSArPSBvcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4TmF0aXZlWm9vbSkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgb3JpZ2luID0gdGhpcy5fbWFwLmdldFBpeGVsT3JpZ2luKCksXHJcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl9nZXRUaWxlU2l6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlUG9pbnQubXVsdGlwbHlCeSh0aWxlU2l6ZSkuc3VidHJhY3Qob3JpZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBpbWFnZS1zcGVjaWZpYyBjb2RlIChvdmVycmlkZSB0byBpbXBsZW1lbnQgZS5nLiBDYW52YXMgb3IgU1ZHIHRpbGUgbGF5ZXIpXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHJldHVybiBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBMLmV4dGVuZCh7XHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbih0aWxlUG9pbnQpLFxyXG5cdFx0XHR6OiB0aWxlUG9pbnQueixcclxuXHRcdFx0eDogdGlsZVBvaW50LngsXHJcblx0XHRcdHk6IHRpbGVQb2ludC55XHJcblx0XHR9LCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0V3JhcFRpbGVOdW06IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnMsXHJcblx0XHQgICAgc2l6ZSA9IGNycy5nZXRTaXplKHRoaXMuX21hcC5nZXRab29tKCkpO1xyXG5cdFx0cmV0dXJuIHNpemUuZGl2aWRlQnkodGhpcy5fZ2V0VGlsZVNpemUoKSkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFRpbGVQb2ludDogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cclxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX2dldFdyYXBUaWxlTnVtKCk7XHJcblxyXG5cdFx0Ly8gd3JhcCB0aWxlIGNvb3JkaW5hdGVzXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jb250aW51b3VzV29ybGQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcclxuXHRcdFx0dGlsZVBvaW50LnggPSAoKHRpbGVQb2ludC54ICUgbGltaXQueCkgKyBsaW1pdC54KSAlIGxpbWl0Lng7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0dGlsZVBvaW50LnkgPSBsaW1pdC55IC0gdGlsZVBvaW50LnkgLSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRpbGVQb2ludC56ID0gdGhpcy5fZ2V0Wm9vbUZvclVybCgpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VGlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXVzZVRpbGVzICYmIHRoaXMuX3VudXNlZFRpbGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl91bnVzZWRUaWxlcy5wb3AoKTtcclxuXHRcdFx0dGhpcy5fcmVzZXRUaWxlKHRpbGUpO1xyXG5cdFx0XHRyZXR1cm4gdGlsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVUaWxlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gT3ZlcnJpZGUgaWYgZGF0YSBzdG9yZWQgb24gYSB0aWxlIG5lZWRzIHRvIGJlIGNsZWFuZWQgdXAgYmVmb3JlIHJldXNlXHJcblx0X3Jlc2V0VGlsZTogZnVuY3Rpb24gKC8qdGlsZSovKSB7fSxcclxuXHJcblx0X2NyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW1nJywgJ2xlYWZsZXQtdGlsZScpO1xyXG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZ2V0VGlsZVNpemUoKSArICdweCc7XHJcblx0XHR0aWxlLmdhbGxlcnlpbWcgPSAnbm8nO1xyXG5cclxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxyXG5cdFx0aWYgKEwuQnJvd3Nlci5tb2JpbGVXZWJraXQzZCkge1xyXG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0X2xvYWRUaWxlOiBmdW5jdGlvbiAodGlsZSwgdGlsZVBvaW50KSB7XHJcblx0XHR0aWxlLl9sYXllciAgPSB0aGlzO1xyXG5cdFx0dGlsZS5vbmxvYWQgID0gdGhpcy5fdGlsZU9uTG9hZDtcclxuXHRcdHRpbGUub25lcnJvciA9IHRoaXMuX3RpbGVPbkVycm9yO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFRpbGVQb2ludCh0aWxlUG9pbnQpO1xyXG5cdFx0dGlsZS5zcmMgICAgID0gdGhpcy5nZXRUaWxlVXJsKHRpbGVQb2ludCk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xyXG5cdFx0XHR0aWxlOiB0aWxlLFxyXG5cdFx0XHR1cmw6IHRpbGUuc3JjXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZUxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQtLTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3RpbGVDb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3RpbGVzVG9Mb2FkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdFx0Ly8gY2xlYXIgc2NhbGVkIHRpbGVzIGFmdGVyIGFsbCBuZXcgdGlsZXMgYXJlIGxvYWRlZCAoZm9yIHBlcmZvcm1hbmNlKVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9jbGVhckJnQnVmZmVyVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX2NsZWFyQmdCdWZmZXJUaW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX2NsZWFyQmdCdWZmZXIsIHRoaXMpLCA1MDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyO1xyXG5cclxuXHRcdC8vT25seSBpZiB3ZSBhcmUgbG9hZGluZyBhbiBhY3R1YWwgaW1hZ2VcclxuXHRcdGlmICh0aGlzLnNyYyAhPT0gTC5VdGlsLmVtcHR5SW1hZ2VVcmwpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XHJcblxyXG5cdFx0XHRsYXllci5maXJlKCd0aWxlbG9hZCcsIHtcclxuXHRcdFx0XHR0aWxlOiB0aGlzLFxyXG5cdFx0XHRcdHVybDogdGhpcy5zcmNcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuX3RpbGVMb2FkZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyO1xyXG5cclxuXHRcdGxheWVyLmZpcmUoJ3RpbGVlcnJvcicsIHtcclxuXHRcdFx0dGlsZTogdGhpcyxcclxuXHRcdFx0dXJsOiB0aGlzLnNyY1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIG5ld1VybCA9IGxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKG5ld1VybCkge1xyXG5cdFx0XHR0aGlzLnNyYyA9IG5ld1VybDtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5fdGlsZUxvYWRlZCgpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnRpbGVMYXllciA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlRpbGVMYXllci5XTVMgaXMgdXNlZCBmb3IgcHV0dGluZyBXTVMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLlRpbGVMYXllci5XTVMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJyxcclxuXHRcdGxheWVyczogJycsXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIE9iamVjdClcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IEwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZSB8fCB0aGlzLm9wdGlvbnMudGlsZVNpemU7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEpIHtcclxuXHRcdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplICogMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdtc1BhcmFtcy53aWR0aCA9IHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ2NycycpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblxyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdEwuVGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKHRpbGVQb2ludCkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gU3RyaW5nXHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSxcclxuXHJcblx0XHQgICAgbndQb2ludCA9IHRpbGVQb2ludC5tdWx0aXBseUJ5KHRpbGVTaXplKSxcclxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQoW3RpbGVTaXplLCB0aWxlU2l6ZV0pLFxyXG5cclxuXHRcdCAgICBudyA9IHRoaXMuX2Nycy5wcm9qZWN0KG1hcC51bnByb2plY3QobndQb2ludCwgdGlsZVBvaW50LnopKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2Nycy5wcm9qZWN0KG1hcC51bnByb2plY3Qoc2VQb2ludCwgdGlsZVBvaW50LnopKSxcclxuXHRcdCAgICBiYm94ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBMLkNSUy5FUFNHNDMyNiA/XHJcblx0XHQgICAgICAgIFtzZS55LCBudy54LCBudy55LCBzZS54XS5qb2luKCcsJykgOlxyXG5cdFx0ICAgICAgICBbbncueCwgc2UueSwgc2UueCwgbncueV0uam9pbignLCcpLFxyXG5cclxuXHRcdCAgICB1cmwgPSBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCB7czogdGhpcy5fZ2V0U3ViZG9tYWluKHRpbGVQb2ludCl9KTtcclxuXHJcblx0XHRyZXR1cm4gdXJsICsgTC5VdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRydWUpICsgJyZCQk9YPScgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRMLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbkwudGlsZUxheWVyLndtcyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLldNUyh1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5UaWxlTGF5ZXIuQ2FudmFzIGlzIGEgY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSBhcyBhIGJhc2UgZm9yIGNyZWF0aW5nXHJcbiAqIGR5bmFtaWNhbGx5IGRyYXduIENhbnZhcy1iYXNlZCB0aWxlIGxheWVycy5cclxuICovXHJcblxyXG5MLlRpbGVMYXllci5DYW52YXMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGFzeW5jOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KHtoYXJkOiB0cnVlfSk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fcmVkcmF3VGlsZSh0aGlzLl90aWxlc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVkcmF3VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcclxuXHRcdHRoaXMuZHJhd1RpbGUodGlsZSwgdGlsZS5fdGlsZVBvaW50LCB0aGlzLl9tYXAuX3pvb20pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcclxuXHRcdHRpbGUud2lkdGggPSB0aWxlLmhlaWdodCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcclxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdF9sb2FkVGlsZTogZnVuY3Rpb24gKHRpbGUsIHRpbGVQb2ludCkge1xyXG5cdFx0dGlsZS5fbGF5ZXIgPSB0aGlzO1xyXG5cdFx0dGlsZS5fdGlsZVBvaW50ID0gdGlsZVBvaW50O1xyXG5cclxuXHRcdHRoaXMuX3JlZHJhd1RpbGUodGlsZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXN5bmMpIHtcclxuXHRcdFx0dGhpcy50aWxlRHJhd24odGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhd1RpbGU6IGZ1bmN0aW9uICgvKnRpbGUsIHRpbGVQb2ludCovKSB7XHJcblx0XHQvLyBvdmVycmlkZSB3aXRoIHJlbmRlcmluZyBjb2RlXHJcblx0fSxcclxuXHJcblx0dGlsZURyYXduOiBmdW5jdGlvbiAodGlsZSkge1xyXG5cdFx0dGhpcy5fdGlsZU9uTG9hZC5jYWxsKHRpbGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuTC50aWxlTGF5ZXIuY2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLkNhbnZhcyhvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuSW1hZ2VPdmVybGF5IGlzIHVzZWQgdG8gb3ZlcmxheSBpbWFnZXMgb3ZlciB0aGUgbWFwICh0byBzcGVjaWZpYyBnZW9ncmFwaGljYWwgYm91bmRzKS5cclxuICovXHJcblxyXG5MLkltYWdlT3ZlcmxheSA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG9wYWNpdHk6IDFcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWFwLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblxyXG5cdFx0bWFwLm9uKCd2aWV3cmVzZXQnLCB0aGlzLl9yZXNldCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG1hcC5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgTC5Ccm93c2VyLmFueTNkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmdldFBhbmVzKCkub3ZlcmxheVBhbmUucmVtb3ZlQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cclxuXHRcdG1hcC5vZmYoJ3ZpZXdyZXNldCcsIHRoaXMuX3Jlc2V0LCB0aGlzKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gcmVtb3ZlIGJyaW5nVG9Gcm9udC9icmluZ1RvQmFjayBkdXBsaWNhdGlvbiBmcm9tIFRpbGVMYXllci9QYXRoXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmUgPSB0aGlzLl9tYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHBhbmUuaW5zZXJ0QmVmb3JlKHRoaXMuX2ltYWdlLCBwYW5lLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9pbWFnZS5zcmMgPSB0aGlzLl91cmw7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5faW1hZ2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdpbWcnLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cclxuXHRcdC8vVE9ETyBjcmVhdGVJbWFnZSB1dGlsIG1ldGhvZCB0byByZW1vdmUgZHVwbGljYXRpb25cclxuXHRcdEwuZXh0ZW5kKHRoaXMuX2ltYWdlLCB7XHJcblx0XHRcdGdhbGxlcnlpbWc6ICdubycsXHJcblx0XHRcdG9uc2VsZWN0c3RhcnQ6IEwuVXRpbC5mYWxzZUZuLFxyXG5cdFx0XHRvbm1vdXNlbW92ZTogTC5VdGlsLmZhbHNlRm4sXHJcblx0XHRcdG9ubG9hZDogTC5iaW5kKHRoaXMuX29uSW1hZ2VMb2FkLCB0aGlzKSxcclxuXHRcdFx0c3JjOiB0aGlzLl91cmxcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBudyA9IHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgdG9wTGVmdCA9IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KG53LCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQoc2UsIGUuem9vbSwgZS5jZW50ZXIpLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdCAgICBvcmlnaW4gPSB0b3BMZWZ0Ll9hZGQoc2l6ZS5fbXVsdGlwbHlCeSgoMSAvIDIpICogKDEgLSAxIC8gc2NhbGUpKSk7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPVxyXG5cdFx0ICAgICAgICBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbikgKyAnIHNjYWxlKCcgKyBzY2FsZSArICcpICc7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgICA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIHRvcExlZnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCB0b3BMZWZ0KTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfb25JbWFnZUxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5JY29uIGlzIGFuIGltYWdlLWJhc2VkIGljb24gY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSB3aXRoIEwuTWFya2VyIGZvciBjdXN0b20gbWFya2Vycy5cclxuICovXHJcblxyXG5MLkljb24gPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0LypcclxuXHRcdGljb25Vcmw6IChTdHJpbmcpIChyZXF1aXJlZClcclxuXHRcdGljb25SZXRpbmFVcmw6IChTdHJpbmcpIChvcHRpb25hbCwgdXNlZCBmb3IgcmV0aW5hIGRldmljZXMgaWYgZGV0ZWN0ZWQpXHJcblx0XHRpY29uU2l6ZTogKFBvaW50KSAoY2FuIGJlIHNldCB0aHJvdWdoIENTUylcclxuXHRcdGljb25BbmNob3I6IChQb2ludCkgKGNlbnRlcmVkIGJ5IGRlZmF1bHQsIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucylcclxuXHRcdHBvcHVwQW5jaG9yOiAoUG9pbnQpIChpZiBub3Qgc3BlY2lmaWVkLCBwb3B1cCBvcGVucyBpbiB0aGUgYW5jaG9yIHBvaW50KVxyXG5cdFx0c2hhZG93VXJsOiAoU3RyaW5nKSAobm8gc2hhZG93IGJ5IGRlZmF1bHQpXHJcblx0XHRzaGFkb3dSZXRpbmFVcmw6IChTdHJpbmcpIChvcHRpb25hbCwgdXNlZCBmb3IgcmV0aW5hIGRldmljZXMgaWYgZGV0ZWN0ZWQpXHJcblx0XHRzaGFkb3dTaXplOiAoUG9pbnQpXHJcblx0XHRzaGFkb3dBbmNob3I6IChQb2ludClcclxuXHRcdCovXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWc7XHJcblx0XHRpZiAoIW9sZEljb24gfHwgb2xkSWNvbi50YWdOYW1lICE9PSAnSU1HJykge1xyXG5cdFx0XHRpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIHNpemUgPSBMLnBvaW50KG9wdGlvbnNbbmFtZSArICdTaXplJ10pLFxyXG5cdFx0ICAgIGFuY2hvcjtcclxuXHJcblx0XHRpZiAobmFtZSA9PT0gJ3NoYWRvdycpIHtcclxuXHRcdFx0YW5jaG9yID0gTC5wb2ludChvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YW5jaG9yID0gTC5wb2ludChvcHRpb25zLmljb25BbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghYW5jaG9yICYmIHNpemUpIHtcclxuXHRcdFx0YW5jaG9yID0gc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgb3B0aW9ucy5jbGFzc05hbWU7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0aWYgKEwuQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmljb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JY29uKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcbiAqIEwuSWNvbi5EZWZhdWx0IGlzIHRoZSBibHVlIG1hcmtlciBpY29uIHVzZWQgYnkgZGVmYXVsdCBpbiBMZWFmbGV0LlxuICovXG5cbkwuSWNvbi5EZWZhdWx0ID0gTC5JY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25TaXplOiBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cblx0XHRzaGFkb3dTaXplOiBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBrZXkgPSBuYW1lICsgJ1VybCc7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zW2tleV0pIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcblx0XHR9XG5cblx0XHRpZiAoTC5Ccm93c2VyLnJldGluYSAmJiBuYW1lID09PSAnaWNvbicpIHtcblx0XHRcdG5hbWUgKz0gJy0yeCc7XG5cdFx0fVxuXG5cdFx0dmFyIHBhdGggPSBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGg7XG5cblx0XHRpZiAoIXBhdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBhdXRvZGV0ZWN0IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCwgc2V0IGl0IG1hbnVhbGx5LicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoICsgJy9tYXJrZXItJyArIG5hbWUgKyAnLnBuZyc7XG5cdH1cbn0pO1xuXG5MLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcblx0ICAgIGxlYWZsZXRSZSA9IC9bXFwvXl1sZWFmbGV0W1xcLVxcLl9dPyhbXFx3XFwtXFwuX10qKVxcLmpzXFw/Py87XG5cblx0dmFyIGksIGxlbiwgc3JjLCBtYXRjaGVzLCBwYXRoO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHNjcmlwdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRzcmMgPSBzY3JpcHRzW2ldLnNyYztcblx0XHRtYXRjaGVzID0gc3JjLm1hdGNoKGxlYWZsZXRSZSk7XG5cblx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0cGF0aCA9IHNyYy5zcGxpdChsZWFmbGV0UmUpWzBdO1xuXHRcdFx0cmV0dXJuIChwYXRoID8gcGF0aCArICcvJyA6ICcnKSArICdpbWFnZXMnO1xuXHRcdH1cblx0fVxufSgpKTtcblxuXG4vKlxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGljb246IG5ldyBMLkljb24uRGVmYXVsdCgpLFxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cdFx0YWx0OiAnJyxcclxuXHRcdGNsaWNrYWJsZTogdHJ1ZSxcclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHRcdG9wYWNpdHk6IDEsXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTBcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0bWFwLm9uKCd2aWV3cmVzZXQnLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xyXG5cclxuXHRcdGlmIChtYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgncmVtb3ZlJyk7XHJcblxyXG5cdFx0bWFwLm9mZih7XHJcblx0XHRcdCd2aWV3cmVzZXQnOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0J3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb21cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7IGxhdGxuZzogdGhpcy5fbGF0bG5nIH0pO1xyXG5cdH0sXHJcblxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9zZXRQb3ModGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgYW5pbWF0aW9uID0gKG1hcC5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbiksXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9IGFuaW1hdGlvbiA/ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnIDogJ2xlYWZsZXQtem9vbS1oaWRlJztcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0XHRhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0Lm9uKGljb24sICdtb3VzZW92ZXInLCB0aGlzLl9icmluZ1RvRnJvbnQsIHRoaXMpXHJcblx0XHRcdFx0Lm9uKGljb24sICdtb3VzZW91dCcsIHRoaXMuX3Jlc2V0WkluZGV4LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0XHRhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9tYXAuX3BhbmVzO1xyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHBhbmVzLm1hcmtlclBhbmUuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0cGFuZXMuc2hhZG93UGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0ICAgIC5vZmYodGhpcy5faWNvbiwgJ21vdXNlb3ZlcicsIHRoaXMuX2JyaW5nVG9Gcm9udClcclxuXHRcdFx0ICAgIC5vZmYodGhpcy5faWNvbiwgJ21vdXNlb3V0JywgdGhpcy5fcmVzZXRaSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5fcGFuZXMubWFya2VyUGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX21hcC5fcGFuZXMuc2hhZG93UGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFRPRE8gcmVmYWN0b3IgaW50byBzb21ldGhpbmcgc2hhcmVkIHdpdGggTWFwL1BhdGgvZXRjLiB0byBEUlkgaXQgdXBcclxuXHJcblx0XHR2YXIgaWNvbiA9IHRoaXMuX2ljb24sXHJcblx0XHQgICAgZXZlbnRzID0gWydkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cdFx0TC5Eb21FdmVudC5vbihpY29uLCAnY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2ssIHRoaXMpO1xyXG5cdFx0TC5Eb21FdmVudC5vbihpY29uLCAna2V5cHJlc3MnLCB0aGlzLl9vbktleVByZXNzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGljb24sIGV2ZW50c1tpXSwgdGhpcy5fZmlyZU1vdXNlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChMLkhhbmRsZXIuTWFya2VyRHJhZykge1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VDbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciB3YXNEcmFnZ2VkID0gdGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLm1vdmVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcnMoZS50eXBlKSB8fCB3YXNEcmFnZ2VkKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNEcmFnZ2VkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICgoIXRoaXMuZHJhZ2dpbmcgfHwgIXRoaXMuZHJhZ2dpbmcuX2VuYWJsZWQpICYmIHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92ZWQoKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGUsXHJcblx0XHRcdGxhdGxuZzogdGhpcy5fbGF0bG5nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnY2xpY2snLCB7XHJcblx0XHRcdFx0b3JpZ2luYWxFdmVudDogZSxcclxuXHRcdFx0XHRsYXRsbmc6IHRoaXMuX2xhdGxuZ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0dGhpcy5maXJlKGUudHlwZSwge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlLFxyXG5cdFx0XHRsYXRsbmc6IHRoaXMuX2xhdGxuZ1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVE9ETyBwcm9wZXIgY3VzdG9tIGV2ZW50IHByb3BhZ2F0aW9uXHJcblx0XHQvLyB0aGlzIGxpbmUgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGlmIG1hcmtlciBpcyBpbiBhIEZlYXR1cmVHcm91cFxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0aGlzLmhhc0V2ZW50TGlzdGVuZXJzKGUudHlwZSkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLnR5cGUgIT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fc2hhZG93LCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcbiAqIEwuRGl2SWNvbiBpcyBhIGxpZ2h0d2VpZ2h0IEhUTUwtYmFzZWQgaWNvbiBjbGFzcyAoYXMgb3Bwb3NlZCB0byB0aGUgaW1hZ2UtYmFzZWQgTC5JY29uKVxuICogdG8gdXNlIHdpdGggTC5NYXJrZXIuXG4gKi9cblxuTC5EaXZJY29uID0gTC5JY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXHRcdC8qXG5cdFx0aWNvbkFuY2hvcjogKFBvaW50KVxuXHRcdHBvcHVwQW5jaG9yOiAoUG9pbnQpXG5cdFx0aHRtbDogKFN0cmluZylcblx0XHRiZ1BvczogKFBvaW50KVxuXHRcdCovXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbicsXG5cdFx0aHRtbDogZmFsc2Vcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgIT09IGZhbHNlKSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPVxuXHRcdFx0ICAgICAgICAoLW9wdGlvbnMuYmdQb3MueCkgKyAncHggJyArICgtb3B0aW9ucy5iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5EaXZJY29uKG9wdGlvbnMpO1xufTtcblxuXG4vKlxyXG4gKiBMLlBvcHVwIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgcG9wdXBzIG9uIHRoZSBtYXAuXHJcbiAqL1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcbkwuUG9wdXAgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cdFx0Ly8gbWF4SGVpZ2h0OiBudWxsLFxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cdFx0Ly8gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cdFx0Ly8gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHRcdHpvb21BbmltYXRpb246IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0dGhpcy5fYW5pbWF0ZWQgPSBMLkJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblx0XHR0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYW5pbUZhZGUgPSBtYXAub3B0aW9ucy5mYWRlQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmIChhbmltRmFkZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cdFx0bWFwLl9wYW5lcy5wb3B1cFBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRtYXAub24odGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKGFuaW1GYWRlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5maXJlKCdvcGVuJyk7XHJcblxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLl9wYW5lcy5wb3B1cFBhbmUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRMLlV0aWwuZmFsc2VGbih0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgpOyAvLyBmb3JjZSByZWZsb3dcclxuXHJcblx0XHRtYXAub2ZmKHRoaXMuX2dldEV2ZW50cygpLCB0aGlzKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuZmFkZUFuaW1hdGlvbikge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdjbG9zZScpO1xyXG5cclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl96b29tQW5pbWF0aW9uO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCdjbG9zZU9uQ2xpY2snIGluIHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdFx0Y29udGFpbmVyQ2xhc3MgPSBwcmVmaXggKyAnICcgKyB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgJyBsZWFmbGV0LXpvb20tJyArXHJcblx0XHRcdCAgICAgICAgKHRoaXMuX2FuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyksXHJcblx0XHRcdGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNvbnRhaW5lckNsYXNzKSxcclxuXHRcdFx0Y2xvc2VCdXR0b247XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHRjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID1cclxuXHRcdFx0ICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cdFx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNsb3NlQnV0dG9uKTtcclxuXHJcblx0XHRcdEwuRG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID1cclxuXHRcdCAgICAgICAgTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcclxuXHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdEwuRG9tRXZlbnQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRlbnROb2RlLmlubmVySFRNTCA9IHRoaXMuX2NvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAodGhpcy5fY29udGVudE5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0dGhpcy5fY29udGVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGVudE5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fY29udGVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgYW5pbWF0ZWQgPSB0aGlzLl9hbmltYXRlZCxcclxuXHRcdCAgICBvZmZzZXQgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xyXG5cclxuXHRcdGlmIChhbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSAtIChhbmltYXRlZCA/IDAgOiBwb3MueSk7XHJcblx0XHR0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54ICsgKGFuaW1hdGVkID8gMCA6IHBvcy54KTtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF96b29tQW5pbWF0aW9uOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcik7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBMLlBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRsYXllclBvcy5fYWRkKEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgTC5Qb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHsgLy8gKFBvcHVwKSBvciAoU3RyaW5nIHx8IEhUTUxFbGVtZW50LCBMYXRMbmdbLCBPYmplY3RdKVxyXG5cdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblxyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBMLlBvcHVwKSkge1xyXG5cdFx0XHR2YXIgY29udGVudCA9IHBvcHVwO1xyXG5cclxuXHRcdFx0cG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zKVxyXG5cdFx0XHQgICAgLnNldExhdExuZyhsYXRsbmcpXHJcblx0XHRcdCAgICAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHBvcHVwLl9pc09wZW4gPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHRcdHBvcHVwLl9pc09wZW4gPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBQb3B1cCBleHRlbnNpb24gdG8gTC5NYXJrZXIsIGFkZGluZyBwb3B1cC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwICYmICF0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyh0aGlzLl9sYXRsbmcpO1xyXG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5faXNPcGVuKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIGFuY2hvciA9IEwucG9pbnQodGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvciB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdGFuY2hvciA9IGFuY2hvci5hZGQoTC5Qb3B1cC5wcm90b3R5cGUub3B0aW9ucy5vZmZzZXQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMub2Zmc2V0KSB7XHJcblx0XHRcdGFuY2hvciA9IGFuY2hvci5hZGQob3B0aW9ucy5vZmZzZXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7b2Zmc2V0OiBhbmNob3J9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub24oJ2NsaWNrJywgdGhpcy50b2dnbGVQb3B1cCwgdGhpcylcclxuXHRcdFx0ICAgIC5vbigncmVtb3ZlJywgdGhpcy5jbG9zZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9uKCdtb3ZlJywgdGhpcy5fbW92ZVBvcHVwLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIEwuUG9wdXApIHtcclxuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMsIHRoaXMpXHJcblx0XHRcdFx0LnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZignY2xpY2snLCB0aGlzLnRvZ2dsZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9mZigncmVtb3ZlJywgdGhpcy5jbG9zZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9mZignbW92ZScsIHRoaXMuX21vdmVQb3B1cCwgdGhpcyk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogTC5MYXllckdyb3VwIGlzIGEgY2xhc3MgdG8gY29tYmluZSBzZXZlcmFsIGxheWVycyBpbnRvIG9uZSBzbyB0aGF0XHJcbiAqIHlvdSBjYW4gbWFuaXB1bGF0ZSB0aGUgZ3JvdXAgKGUuZy4gYWRkL3JlbW92ZSBpdCkgYXMgb25lIGxheWVyLlxyXG4gKi9cclxuXHJcbkwuTGF5ZXJHcm91cCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghbGF5ZXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0cmV0dXJuIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2godGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gTC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcbkwubGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTGF5ZXJHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5GZWF0dXJlR3JvdXAgZXh0ZW5kcyBMLkxheWVyR3JvdXAgYnkgaW50cm9kdWNpbmcgbW91c2UgZXZlbnRzIGFuZCBhZGRpdGlvbmFsIG1ldGhvZHNcclxuICogc2hhcmVkIGJldHdlZW4gYSBncm91cCBvZiBpbnRlcmFjdGl2ZSBsYXllcnMgKGxpa2UgdmVjdG9ycyBvciBtYXJrZXJzKS5cclxuICovXHJcblxyXG5MLkZlYXR1cmVHcm91cCA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0RVZFTlRTOiAnY2xpY2sgZGJsY2xpY2sgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBwb3B1cG9wZW4gcG9wdXBjbG9zZSdcclxuXHR9LFxyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCdvbicgaW4gbGF5ZXIpIHtcclxuXHRcdFx0bGF5ZXIub24oTC5GZWF0dXJlR3JvdXAuRVZFTlRTLCB0aGlzLl9wcm9wYWdhdGVFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXBDb250ZW50ICYmIGxheWVyLmJpbmRQb3B1cCkge1xyXG5cdFx0XHRsYXllci5iaW5kUG9wdXAodGhpcy5fcG9wdXBDb250ZW50LCB0aGlzLl9wb3B1cE9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJ29mZicgaW4gbGF5ZXIpIHtcclxuXHRcdFx0bGF5ZXIub2ZmKEwuRmVhdHVyZUdyb3VwLkVWRU5UUywgdGhpcy5fcHJvcGFnYXRlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwQ29udGVudCkge1xyXG5cdFx0XHR0aGlzLmludm9rZSgndW5iaW5kUG9wdXAnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9wb3B1cENvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy5fcG9wdXBPcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYmluZFBvcHVwJywgY29udGVudCwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHQvLyBvcGVuIHBvcHVwIG9uIHRoZSBmaXJzdCBsYXllclxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0ub3BlblBvcHVwKGxhdGxuZyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyID8gbGF5ZXIuZ2V0TGF0TG5nKCkgOiBsYXllci5nZXRCb3VuZHMoKSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzXHJcblx0XHR9LCBlKTtcclxuXHRcdHRoaXMuZmlyZShlLnR5cGUsIGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlBhdGggaXMgYSBiYXNlIGNsYXNzIGZvciByZW5kZXJpbmcgdmVjdG9yIHBhdGhzIG9uIGEgbWFwLiBJbmhlcml0ZWQgYnkgUG9seWxpbmUsIENpcmNsZSwgZXRjLlxyXG4gKi9cclxuXHJcbkwuUGF0aCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogW0wuTWl4aW4uRXZlbnRzXSxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0Ly8gaG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlld1xyXG5cdFx0Ly8gKHJlbGF0aXZlIHRvIGl0cyBzaXplLCBlLmcuIDAuNSBpcyBoYWxmIHRoZSBzY3JlZW4gaW4gZWFjaCBkaXJlY3Rpb24pXHJcblx0XHQvLyBzZXQgaXQgc28gdGhhdCBTVkcgZWxlbWVudCBkb2Vzbid0IGV4Y2VlZCAxMjgwcHggKHZlY3RvcnMgZmxpY2tlciBvbiBkcmFnZW5kIGlmIGl0IGlzKVxyXG5cdFx0Q0xJUF9QQURESU5HOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgbWF4ID0gTC5Ccm93c2VyLm1vYmlsZSA/IDEyODAgOiAyMDAwLFxyXG5cdFx0XHQgICAgdGFyZ2V0ID0gKG1heCAvIE1hdGgubWF4KHdpbmRvdy5vdXRlcldpZHRoLCB3aW5kb3cub3V0ZXJIZWlnaHQpIC0gMSkgLyAyO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMC41LCB0YXJnZXQpKTtcclxuXHRcdH0pKClcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRzdHJva2U6IHRydWUsXHJcblx0XHRjb2xvcjogJyMwMDMzZmYnLFxyXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxyXG5cdFx0bGluZUNhcDogbnVsbCxcclxuXHRcdGxpbmVKb2luOiBudWxsLFxyXG5cdFx0d2VpZ2h0OiA1LFxyXG5cdFx0b3BhY2l0eTogMC41LFxyXG5cclxuXHRcdGZpbGw6IGZhbHNlLFxyXG5cdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxyXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcclxuXHJcblx0XHRjbGlja2FibGU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdEVsZW1lbnRzKCk7XHJcblx0XHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnByb2plY3RMYXRsbmdzKCk7XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9tYXAuX3BhdGhSb290LmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcclxuXHJcblx0XHRtYXAub24oe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5wcm9qZWN0TGF0bG5ncyxcclxuXHRcdFx0J21vdmVlbmQnOiB0aGlzLl91cGRhdGVQYXRoXHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5fcGF0aFJvb3QucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBOZWVkIHRvIGZpcmUgcmVtb3ZlIGV2ZW50IGJlZm9yZSB3ZSBzZXQgX21hcCB0byBudWxsIGFzIHRoZSBldmVudCBob29rcyBtaWdodCBuZWVkIHRoZSBvYmplY3RcclxuXHRcdHRoaXMuZmlyZSgncmVtb3ZlJyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIudm1sKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XHJcblx0XHRcdHRoaXMuX3N0cm9rZSA9IG51bGw7XHJcblx0XHRcdHRoaXMuX2ZpbGwgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hcC5vZmYoe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5wcm9qZWN0TGF0bG5ncyxcclxuXHRcdFx0J21vdmVlbmQnOiB0aGlzLl91cGRhdGVQYXRoXHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZG8gYWxsIHByb2plY3Rpb24gc3R1ZmYgaGVyZVxyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLnByb2plY3RMYXRsbmdzKCk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfdXBkYXRlUGF0aFZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcCA9IEwuUGF0aC5DTElQX1BBRERJTkcsXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHBhbmVQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSksXHJcblx0XHQgICAgbWluID0gcGFuZVBvcy5tdWx0aXBseUJ5KC0xKS5fc3VidHJhY3Qoc2l6ZS5tdWx0aXBseUJ5KHApLl9yb3VuZCgpKSxcclxuXHRcdCAgICBtYXggPSBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpLl9yb3VuZCgpKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoVmlld3BvcnQgPSBuZXcgTC5Cb3VuZHMobWluLCBtYXgpO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBFeHRlbmRzIEwuUGF0aCB3aXRoIFNWRy1zcGVjaWZpYyByZW5kZXJpbmcgY29kZS5cclxuICovXHJcblxyXG5MLlBhdGguU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuXHJcbkwuQnJvd3Nlci5zdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKEwuUGF0aC5TVkdfTlMsICdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbkwuUGF0aCA9IEwuUGF0aC5leHRlbmQoe1xyXG5cdHN0YXRpY3M6IHtcclxuXHRcdFNWRzogTC5Ccm93c2VyLnN2Z1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9tYXAuX3BhdGhSb290LFxyXG5cdFx0ICAgIHBhdGggPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0aWYgKHBhdGggJiYgcm9vdC5sYXN0Q2hpbGQgIT09IHBhdGgpIHtcclxuXHRcdFx0cm9vdC5hcHBlbmRDaGlsZChwYXRoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX21hcC5fcGF0aFJvb3QsXHJcblx0XHQgICAgcGF0aCA9IHRoaXMuX2NvbnRhaW5lcixcclxuXHRcdCAgICBmaXJzdCA9IHJvb3QuZmlyc3RDaGlsZDtcclxuXHJcblx0XHRpZiAocGF0aCAmJiBmaXJzdCAhPT0gcGF0aCkge1xyXG5cdFx0XHRyb290Lmluc2VydEJlZm9yZShwYXRoLCBmaXJzdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBmb3JtIHBhdGggc3RyaW5nIGhlcmVcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoTC5QYXRoLlNWR19OUywgbmFtZSk7XHJcblx0fSxcclxuXHJcblx0X2luaXRFbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLl9pbml0UGF0aFJvb3QoKTtcclxuXHRcdHRoaXMuX2luaXRQYXRoKCk7XHJcblx0XHR0aGlzLl9pbml0U3R5bGUoKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ2cnKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoID0gdGhpcy5fY3JlYXRlRWxlbWVudCgncGF0aCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9wYXRoLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcGF0aCk7XHJcblx0fSxcclxuXHJcblx0X2luaXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsICdyb3VuZCcpO1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZmlsbCkge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCB0aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUgJiYgIXRoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHRoaXMub3B0aW9ucy5jb2xvcik7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMub3B0aW9ucy53ZWlnaHQpO1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRhc2hBcnJheSkge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgdGhpcy5vcHRpb25zLmRhc2hBcnJheSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fcGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmxpbmVDYXApIHtcclxuXHRcdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCB0aGlzLm9wdGlvbnMubGluZUNhcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5saW5lSm9pbikge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCB0aGlzLm9wdGlvbnMubGluZUpvaW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZmlsbCkge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMub3B0aW9ucy5maWxsQ29sb3IgfHwgdGhpcy5vcHRpb25zLmNvbG9yKTtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIHRoaXMub3B0aW9ucy5maWxsT3BhY2l0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzdHIgPSB0aGlzLmdldFBhdGhTdHJpbmcoKTtcclxuXHRcdGlmICghc3RyKSB7XHJcblx0XHRcdC8vIGZpeCB3ZWJraXQgZW1wdHkgc3RyaW5nIHBhcnNpbmcgYnVnXHJcblx0XHRcdHN0ciA9ICdNMCAwJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgc3RyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIHJlbW92ZSBkdXBsaWNhdGlvbiB3aXRoIEwuTWFwXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdGlmIChMLkJyb3dzZXIuc3ZnIHx8ICFMLkJyb3dzZXIudm1sKSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGgsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fb25Nb3VzZUNsaWNrLCB0aGlzKTtcclxuXHJcblx0XHRcdHZhciBldmVudHMgPSBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZW92ZXInLFxyXG5cdFx0XHQgICAgICAgICAgICAgICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92ZWQoKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9maXJlTW91c2VFdmVudChlKTtcclxuXHR9LFxyXG5cclxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAhdGhpcy5oYXNFdmVudExpc3RlbmVycyhlLnR5cGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSksXHJcblx0XHQgICAgbGF5ZXJQb2ludCA9IG1hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCksXHJcblx0XHQgICAgbGF0bG5nID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxyXG5cdFx0XHRjb250YWluZXJQb2ludDogY29udGFpbmVyUG9pbnQsXHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLnR5cGUgIT09ICdtb3VzZW1vdmUnKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3BhdGhSb290KSB7XHJcblx0XHRcdHRoaXMuX3BhdGhSb290ID0gTC5QYXRoLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCgnc3ZnJyk7XHJcblx0XHRcdHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lLmFwcGVuZENoaWxkKHRoaXMuX3BhdGhSb290KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aFJvb3QsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlUGF0aFpvb20sXHJcblx0XHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFBhdGhab29tXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGhSb290LCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVN2Z1ZpZXdwb3J0KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3ZnVmlld3BvcnQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVBhdGhab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoZS5jZW50ZXIpLl9tdWx0aXBseUJ5KC1zY2FsZSkuX2FkZCh0aGlzLl9wYXRoVmlld3BvcnQubWluKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoUm9vdC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9XHJcblx0XHQgICAgICAgIEwuRG9tVXRpbC5nZXRUcmFuc2xhdGVTdHJpbmcob2Zmc2V0KSArICcgc2NhbGUoJyArIHNjYWxlICsgJykgJztcclxuXHJcblx0XHR0aGlzLl9wYXRoWm9vbWluZyA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X2VuZFBhdGhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9wYXRoWm9vbWluZyA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdmdWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9wYXRoWm9vbWluZykge1xyXG5cdFx0XHQvLyBEbyBub3QgdXBkYXRlIFNWR3Mgd2hpbGUgYSB6b29tIGFuaW1hdGlvbiBpcyBnb2luZyBvbiBvdGhlcndpc2UgdGhlIGFuaW1hdGlvbiB3aWxsIGJyZWFrLlxyXG5cdFx0XHQvLyBXaGVuIHRoZSB6b29tIGFuaW1hdGlvbiBlbmRzIHdlIHdpbGwgYmUgdXBkYXRlZCBhZ2FpbiBhbnl3YXlcclxuXHRcdFx0Ly8gVGhpcyBmaXhlcyB0aGUgY2FzZSB3aGVyZSB5b3UgZG8gYSBtb21lbnR1bSBtb3ZlIGFuZCB6b29tIHdoaWxlIHRoZSBtb3ZlIGlzIHN0aWxsIG9uZ29pbmcuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHJcblx0XHR2YXIgdnAgPSB0aGlzLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbWluID0gdnAubWluLFxyXG5cdFx0ICAgIG1heCA9IHZwLm1heCxcclxuXHRcdCAgICB3aWR0aCA9IG1heC54IC0gbWluLngsXHJcblx0XHQgICAgaGVpZ2h0ID0gbWF4LnkgLSBtaW4ueSxcclxuXHRcdCAgICByb290ID0gdGhpcy5fcGF0aFJvb3QsXHJcblx0XHQgICAgcGFuZSA9IHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lO1xyXG5cclxuXHRcdC8vIEhhY2sgdG8gbWFrZSBmbGlja2VyIG9uIGRyYWcgZW5kIG9uIG1vYmlsZSB3ZWJraXQgbGVzcyBpcnJpdGF0aW5nXHJcblx0XHRpZiAoTC5Ccm93c2VyLm1vYmlsZVdlYmtpdCkge1xyXG5cdFx0XHRwYW5lLnJlbW92ZUNoaWxkKHJvb3QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihyb290LCBtaW4pO1xyXG5cdFx0cm9vdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xyXG5cdFx0cm9vdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XHJcblx0XHRyb290LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFttaW4ueCwgbWluLnksIHdpZHRoLCBoZWlnaHRdLmpvaW4oJyAnKSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5tb2JpbGVXZWJraXQpIHtcclxuXHRcdFx0cGFuZS5hcHBlbmRDaGlsZChyb290KTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogUG9wdXAgZXh0ZW5zaW9uIHRvIEwuUGF0aCAocG9seWxpbmVzLCBwb2x5Z29ucywgY2lyY2xlcyksIGFkZGluZyBwb3B1cC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5QYXRoLmluY2x1ZGUoe1xyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBMLlBvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghdGhpcy5fcG9wdXAgfHwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub24oJ2NsaWNrJywgdGhpcy5fb3BlblBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9uKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXAsIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZignY2xpY2snLCB0aGlzLl9vcGVuUG9wdXApXHJcblx0XHRcdCAgICAub2ZmKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXApO1xyXG5cclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgZnJvbSBvbmUgb2YgdGhlIHBhdGgncyBwb2ludHMgaWYgbm90IHNwZWNpZmllZFxyXG5cdFx0XHRsYXRsbmcgPSBsYXRsbmcgfHwgdGhpcy5fbGF0bG5nIHx8XHJcblx0XHRcdCAgICAgICAgIHRoaXMuX2xhdGxuZ3NbTWF0aC5mbG9vcih0aGlzLl9sYXRsbmdzLmxlbmd0aCAvIDIpXTtcclxuXHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cCh7bGF0bG5nOiBsYXRsbmd9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXApO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBWZWN0b3IgcmVuZGVyaW5nIGZvciBJRTYtOCB0aHJvdWdoIFZNTC5cclxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcclxuICovXHJcblxyXG5MLkJyb3dzZXIudm1sID0gIUwuQnJvd3Nlci5zdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0oKSk7XHJcblxyXG5MLlBhdGggPSBMLkJyb3dzZXIuc3ZnIHx8ICFMLkJyb3dzZXIudm1sID8gTC5QYXRoIDogTC5QYXRoLmV4dGVuZCh7XHJcblx0c3RhdGljczoge1xyXG5cdFx0Vk1MOiB0cnVlLFxyXG5cdFx0Q0xJUF9QQURESU5HOiAwLjAyXHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUVsZW1lbnQ6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcclxuXHRcdFx0XHQgICAgICAgICc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KCkpLFxyXG5cclxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdzaGFwZScpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZScgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgOiAnJykpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcclxuXHJcblx0XHR0aGlzLl9wYXRoID0gdGhpcy5fY3JlYXRlRWxlbWVudCgncGF0aCcpO1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3BhdGgpO1xyXG5cclxuXHRcdHRoaXMuX21hcC5fcGF0aFJvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdFN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN0cm9rZSA9IHRoaXMuX3N0cm9rZSxcclxuXHRcdCAgICBmaWxsID0gdGhpcy5fZmlsbCxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHRjb250YWluZXIuc3Ryb2tlZCA9IG9wdGlvbnMuc3Ryb2tlO1xyXG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9IG9wdGlvbnMuZmlsbDtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0aWYgKCFzdHJva2UpIHtcclxuXHRcdFx0XHRzdHJva2UgPSB0aGlzLl9zdHJva2UgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdzdHJva2UnKTtcclxuXHRcdFx0XHRzdHJva2UuZW5kY2FwID0gJ3JvdW5kJztcclxuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xyXG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBMLlV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xyXG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxyXG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmxpbmVDYXApIHtcclxuXHRcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmxpbmVKb2luKSB7XHJcblx0XHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xyXG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcclxuXHRcdFx0dGhpcy5fc3Ryb2tlID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdGlmICghZmlsbCkge1xyXG5cdFx0XHRcdGZpbGwgPSB0aGlzLl9maWxsID0gdGhpcy5fY3JlYXRlRWxlbWVudCgnZmlsbCcpO1xyXG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcclxuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcclxuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xyXG5cdFx0XHR0aGlzLl9maWxsID0gbnVsbDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblx0XHR0aGlzLl9wYXRoLnYgPSB0aGlzLmdldFBhdGhTdHJpbmcoKSArICcgJzsgLy8gdGhlIHNwYWNlIGZpeGVzIElFIGVtcHR5IHBhdGggc3RyaW5nIGJ1Z1xyXG5cdFx0c3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKEwuQnJvd3Nlci5zdmcgfHwgIUwuQnJvd3Nlci52bWwgPyB7fSA6IHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcGF0aFJvb3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9wYXRoUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cm9vdC5jbGFzc05hbWUgPSAnbGVhZmxldC12bWwtY29udGFpbmVyJztcclxuXHRcdHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lLmFwcGVuZENoaWxkKHJvb3QpO1xyXG5cclxuXHRcdHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUGF0aFZpZXdwb3J0KCk7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIFZlY3RvciByZW5kZXJpbmcgZm9yIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgY2FudmFzLlxyXG4gKi9cclxuXHJcbkwuQnJvd3Nlci5jYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG5MLlBhdGggPSAoTC5QYXRoLlNWRyAmJiAhd2luZG93LkxfUFJFRkVSX0NBTlZBUykgfHwgIUwuQnJvd3Nlci5jYW52YXMgPyBMLlBhdGggOiBMLlBhdGguZXh0ZW5kKHtcclxuXHRzdGF0aWNzOiB7XHJcblx0XHQvL0NMSVBfUEFERElORzogMC4wMiwgLy8gbm90IHN1cmUgaWYgdGhlcmUncyBhIG5lZWQgdG8gc2V0IGl0IHRvIGEgc21hbGwgdmFsdWVcclxuXHRcdENBTlZBUzogdHJ1ZSxcclxuXHRcdFNWRzogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHRcdFx0dGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5vZmYoJ3ZpZXdyZXNldCcsIHRoaXMucHJvamVjdExhdGxuZ3MsIHRoaXMpXHJcblx0XHQgICAgLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVBhdGgsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblx0XHRcclxuXHRcdHRoaXMuZmlyZSgncmVtb3ZlJyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZXF1ZXN0VXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICFMLlBhdGguX3VwZGF0ZVJlcXVlc3QpIHtcclxuXHRcdFx0TC5QYXRoLl91cGRhdGVSZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fZmlyZU1hcE1vdmVFbmQsIHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpcmVNYXBNb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlBhdGguX3VwZGF0ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRFbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLl9pbml0UGF0aFJvb3QoKTtcclxuXHRcdHRoaXMuX2N0eCA9IHRoaXMuX21hcC5fY2FudmFzQ3R4O1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcclxuXHRcdFx0dGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubGluZUNhcCkge1xyXG5cdFx0XHR0aGlzLl9jdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLmxpbmVKb2luKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYXdQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgaiwgbGVuLCBsZW4yLCBwb2ludCwgZHJhd01ldGhvZDtcclxuXHJcblx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHRoaXMuX3BhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xyXG5cdFx0XHRcdHBvaW50ID0gdGhpcy5fcGFydHNbaV1bal07XHJcblx0XHRcdFx0ZHJhd01ldGhvZCA9IChqID09PSAwID8gJ21vdmUnIDogJ2xpbmUnKSArICdUbyc7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N0eFtkcmF3TWV0aG9kXShwb2ludC54LCBwb2ludC55KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBUT0RPIHJlZmFjdG9yIHVnbHkgaGFja1xyXG5cdFx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIEwuUG9seWdvbikge1xyXG5cdFx0XHRcdHRoaXMuX2N0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fcGFydHMubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fY2hlY2tJZkVtcHR5KCkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGN0eCA9IHRoaXMuX2N0eCxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX2RyYXdQYXRoKCk7XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XHJcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xyXG5cdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2sgZGJsY2xpY2sgY29udGV4dG1lbnUnLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpcmVNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zUG9pbnQoZS5sYXllclBvaW50KSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoZS50eXBlLCBlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gVE9ETyBkb24ndCBkbyBvbiBlYWNoIG1vdmVcclxuXHRcdGlmICh0aGlzLl9jb250YWluc1BvaW50KGUubGF5ZXJQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcblx0XHRcdHRoaXMuX21vdXNlSW5zaWRlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3VzZW92ZXInLCBlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuX21vdXNlSW5zaWRlKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJyc7XHJcblx0XHRcdHRoaXMuX21vdXNlSW5zaWRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW91c2VvdXQnLCBlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuaW5jbHVkZSgoTC5QYXRoLlNWRyAmJiAhd2luZG93LkxfUFJFRkVSX0NBTlZBUykgfHwgIUwuQnJvd3Nlci5jYW52YXMgPyB7fSA6IHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX3BhdGhSb290LFxyXG5cdFx0ICAgIGN0eDtcclxuXHJcblx0XHRpZiAoIXJvb3QpIHtcclxuXHRcdFx0cm9vdCA9IHRoaXMuX3BhdGhSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdHJvb3Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRjdHggPSB0aGlzLl9jYW52YXNDdHggPSByb290LmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0XHRjdHgubGluZUNhcCA9ICdyb3VuZCc7XHJcblx0XHRcdGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZChyb290KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGhSb290LmNsYXNzTmFtZSA9ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnO1xyXG5cdFx0XHRcdHRoaXMub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVBhdGhab29tKTtcclxuXHRcdFx0XHR0aGlzLm9uKCd6b29tZW5kJywgdGhpcy5fZW5kUGF0aFpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVDYW52YXNWaWV3cG9ydCk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZUNhbnZhc1ZpZXdwb3J0KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNhbnZhc1ZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBkb24ndCByZWRyYXcgd2hpbGUgem9vbWluZy4gU2VlIF91cGRhdGVTdmdWaWV3cG9ydCBmb3IgbW9yZSBkZXRhaWxzXHJcblx0XHRpZiAodGhpcy5fcGF0aFpvb21pbmcpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHJcblx0XHR2YXIgdnAgPSB0aGlzLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbWluID0gdnAubWluLFxyXG5cdFx0ICAgIHNpemUgPSB2cC5tYXguc3VidHJhY3QobWluKSxcclxuXHRcdCAgICByb290ID0gdGhpcy5fcGF0aFJvb3Q7XHJcblxyXG5cdFx0Ly9UT0RPIGNoZWNrIGlmIHRoaXMgd29ya3MgcHJvcGVybHkgb24gbW9iaWxlIHdlYmtpdFxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHJvb3QsIG1pbik7XHJcblx0XHRyb290LndpZHRoID0gc2l6ZS54O1xyXG5cdFx0cm9vdC5oZWlnaHQgPSBzaXplLnk7XHJcblx0XHRyb290LmdldENvbnRleHQoJzJkJykudHJhbnNsYXRlKC1taW4ueCwgLW1pbi55KTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogTC5MaW5lVXRpbCBjb250YWlucyBkaWZmZXJlbnQgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxpbmUgc2VnbWVudHNcclxuICogYW5kIHBvbHlsaW5lcyAoY2xpcHBpbmcsIHNpbXBsaWZpY2F0aW9uLCBkaXN0YW5jZXMsIGV0Yy4pXHJcbiAqL1xyXG5cclxuLypqc2hpbnQgYml0d2lzZTpmYWxzZSAqLyAvLyBhbGxvdyBiaXR3aXNlIG9wZXJhdGlvbnMgZm9yIHRoaXMgZmlsZVxyXG5cclxuTC5MaW5lVXRpbCA9IHtcclxuXHJcblx0Ly8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcblx0Ly8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcblx0c2ltcGxpZnk6IGZ1bmN0aW9uICgvKlBvaW50W10qLyBwb2ludHMsIC8qTnVtYmVyKi8gdG9sZXJhbmNlKSB7XHJcblx0XHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHRcdC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50IGJldHdlZW4gdHdvIHBvaW50c1xyXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6ICBmdW5jdGlvbiAoLypQb2ludCovIHAsIC8qUG9pbnQqLyBwMSwgLypQb2ludCovIHAyKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcblx0fSxcclxuXHJcblx0Ly8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcblx0X3NpbXBsaWZ5RFA6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0XHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHRcdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0XHRtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdFx0dmFyIGksXHJcblx0XHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdQb2ludHM7XHJcblx0fSxcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwOiBmdW5jdGlvbiAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0XHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRcdCAgICBpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRcdHNxRGlzdCA9IHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcblx0X3JlZHVjZVBvaW50czogZnVuY3Rpb24gKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHRcdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRcdHByZXYgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBDb2hlbi1TdXRoZXJsYW5kIGxpbmUgY2xpcHBpbmcgYWxnb3JpdGhtLlxyXG5cdC8vIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWxpbmUgdGhhdCBhcmUgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG5cclxuXHRjbGlwU2VnbWVudDogZnVuY3Rpb24gKGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUpIHtcclxuXHRcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gdGhpcy5fbGFzdENvZGUgOiB0aGlzLl9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0XHQgICAgY29kZUIgPSB0aGlzLl9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdFx0Ly8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0XHR0aGlzLl9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0XHRcdHAgPSB0aGlzLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcyk7XHJcblx0XHRcdFx0bmV3Q29kZSA9IHRoaXMuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdFx0XHRhID0gcDtcclxuXHRcdFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YiA9IHA7XHJcblx0XHRcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEVkZ2VJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChhLCBiLCBjb2RlLCBib3VuZHMpIHtcclxuXHRcdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHRcdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXg7XHJcblxyXG5cdFx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHksIG1heC55KTtcclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2ludChhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeSwgbWluLnkpO1xyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobWF4LngsIGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4KTtcclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobWluLngsIGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0Qml0Q29kZTogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCBib3VuZHMpIHtcclxuXHRcdHZhciBjb2RlID0gMDtcclxuXHJcblx0XHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdFx0Y29kZSB8PSAxO1xyXG5cdFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdFx0Y29kZSB8PSAyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdFx0Y29kZSB8PSA0O1xyXG5cdFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRcdGNvZGUgfD0gODtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29kZTtcclxuXHR9LFxyXG5cclxuXHQvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocDEsIHAyKSB7XHJcblx0XHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5cdF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0XHR2YXIgeCA9IHAxLngsXHJcblx0XHQgICAgeSA9IHAxLnksXHJcblx0XHQgICAgZHggPSBwMi54IC0geCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdFx0ICAgIHQ7XHJcblxyXG5cdFx0aWYgKGRvdCA+IDApIHtcclxuXHRcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHRcdHkgPSBwMi55O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRkeCA9IHAueCAtIHg7XHJcblx0XHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fVxyXG59O1xyXG5cblxuLypcclxuICogTC5Qb2x5bGluZSBpcyB1c2VkIHRvIGRpc3BsYXkgcG9seWxpbmVzIG9uIGEgbWFwLlxyXG4gKi9cclxuXHJcbkwuUG9seWxpbmUgPSBMLlBhdGguZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIGhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWxcclxuXHRcdC8vIG1vcmUgPSBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGxlc3MgPSBtb3JlIGFjY3VyYXRlXHJcblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcclxuXHRcdG5vQ2xpcDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fb3JpZ2luYWxQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9vcmlnaW5hbFBvaW50c1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UGF0aFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aCwgc3RyID0gJyc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRzdHIgKz0gdGhpcy5fZ2V0UGF0aFBhcnRTdHIodGhpcy5fcGFydHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmdzLnB1c2goTC5sYXRMbmcobGF0bG5nKSk7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcclxuXHR9LFxyXG5cclxuXHRzcGxpY2VMYXRMbmdzOiBmdW5jdGlvbiAoKSB7IC8vIChOdW1iZXIgaW5kZXgsIE51bWJlciBob3dNYW55KVxyXG5cdFx0dmFyIHJlbW92ZWQgPSBbXS5zcGxpY2UuYXBwbHkodGhpcy5fbGF0bG5ncywgYXJndW1lbnRzKTtcclxuXHRcdHRoaXMuX2NvbnZlcnRMYXRMbmdzKHRoaXMuX2xhdGxuZ3MsIHRydWUpO1xyXG5cdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdHJldHVybiByZW1vdmVkO1xyXG5cdH0sXHJcblxyXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xyXG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksIHBhcnRzID0gdGhpcy5fcGFydHMsIHAxLCBwMiwgbWluUG9pbnQgPSBudWxsO1xyXG5cclxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XHJcblx0XHRcdHZhciBwb2ludHMgPSBwYXJ0c1tqXTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcclxuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcclxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKTtcclxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcclxuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xyXG5cdFx0XHRcdFx0bWluUG9pbnQgPSBMLkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG1pblBvaW50KSB7XHJcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtaW5Qb2ludDtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHModGhpcy5nZXRMYXRMbmdzKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIG92ZXJ3cml0ZSkge1xyXG5cdFx0dmFyIGksIGxlbiwgdGFyZ2V0ID0gb3ZlcndyaXRlID8gbGF0bG5ncyA6IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKEwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbaV0pICYmIHR5cGVvZiBsYXRsbmdzW2ldWzBdICE9PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0YXJnZXRbaV0gPSBMLmxhdExuZyhsYXRsbmdzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuUGF0aC5wcm90b3R5cGUuX2luaXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UGF0aFBhcnRTdHI6IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuXHRcdHZhciByb3VuZCA9IEwuUGF0aC5WTUw7XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoLCBzdHIgPSAnJywgcDsgaiA8IGxlbjI7IGorKykge1xyXG5cdFx0XHRwID0gcG9pbnRzW2pdO1xyXG5cdFx0XHRpZiAocm91bmQpIHtcclxuXHRcdFx0XHRwLl9yb3VuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH0sXHJcblxyXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXHJcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHRcdCAgICBpLCBrLCBzZWdtZW50O1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XHJcblx0XHRcdHRoaXMuX3BhcnRzID0gW3BvaW50c107XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xyXG5cclxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxyXG5cdFx0ICAgIHZwID0gdGhpcy5fbWFwLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbHUgPSBMLkxpbmVVdGlsO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGsgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcblx0XHRcdHNlZ21lbnQgPSBsdS5jbGlwU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIHZwLCBpKTtcclxuXHRcdFx0aWYgKCFzZWdtZW50KSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XHJcblx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XHJcblxyXG5cdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XHJcblx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2kgKyAxXSkgfHwgKGkgPT09IGxlbiAtIDIpKSB7XHJcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcclxuXHRcdFx0XHRrKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmVcclxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxyXG5cdFx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cGFydHNbaV0gPSBsdS5zaW1wbGlmeShwYXJ0c1tpXSwgdGhpcy5vcHRpb25zLnNtb290aEZhY3Rvcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcclxuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XHJcblxyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5fdXBkYXRlUGF0aC5jYWxsKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlBvbHlVdGlsIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29ucyAoY2xpcHBpbmcsIGV0Yy4pLlxyXG4gKi9cclxuXHJcbi8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi8gLy8gYWxsb3cgYml0d2lzZSBvcGVyYXRpb25zIGhlcmVcclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qXHJcbiAqIFN1dGhlcmxhbmQtSG9kZ2VtYW4gcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG0uXHJcbiAqIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWdvbiB0aGF0IGFyZSBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAqL1xyXG5MLlBvbHlVdGlsLmNsaXBQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgYm91bmRzKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHAsXHJcblx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLlBvbHlnb24gaXMgdXNlZCB0byBkaXNwbGF5IHBvbHlnb25zIG9uIGEgbWFwLlxyXG4gKi9cclxuXHJcbkwuUG9seWdvbiA9IEwuUG9seWxpbmUuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRmaWxsOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdEwuUG9seWxpbmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBsYXRsbmdzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2luaXRXaXRoSG9sZXMobGF0bG5ncyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRXaXRoSG9sZXM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XHJcblx0XHR2YXIgaSwgbGVuLCBob2xlO1xyXG5cdFx0aWYgKGxhdGxuZ3MgJiYgTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgJiYgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnbnVtYmVyJykpIHtcclxuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbMF0pO1xyXG5cdFx0XHR0aGlzLl9ob2xlcyA9IGxhdGxuZ3Muc2xpY2UoMSk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9ob2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGhvbGUgPSB0aGlzLl9ob2xlc1tpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKHRoaXMuX2hvbGVzW2ldKTtcclxuXHRcdFx0XHRpZiAoaG9sZVswXS5lcXVhbHMoaG9sZVtob2xlLmxlbmd0aCAtIDFdKSkge1xyXG5cdFx0XHRcdFx0aG9sZS5wb3AoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgb3V0IGxhc3QgcG9pbnQgaWYgaXRzIGVxdWFsIHRvIHRoZSBmaXJzdCBvbmVcclxuXHRcdGxhdGxuZ3MgPSB0aGlzLl9sYXRsbmdzO1xyXG5cclxuXHRcdGlmIChsYXRsbmdzLmxlbmd0aCA+PSAyICYmIGxhdGxuZ3NbMF0uZXF1YWxzKGxhdGxuZ3NbbGF0bG5ncy5sZW5ndGggLSAxXSkpIHtcclxuXHRcdFx0bGF0bG5ncy5wb3AoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Qb2x5bGluZS5wcm90b3R5cGUucHJvamVjdExhdGxuZ3MuY2FsbCh0aGlzKTtcclxuXHJcblx0XHQvLyBwcm9qZWN0IHBvbHlnb24gaG9sZXMgcG9pbnRzXHJcblx0XHQvLyBUT0RPIG1vdmUgdGhpcyBsb2dpYyB0byBQb2x5bGluZSB0byBnZXQgcmlkIG9mIGR1cGxpY2F0aW9uXHJcblx0XHR0aGlzLl9ob2xlUG9pbnRzID0gW107XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ob2xlcykgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgaSwgaiwgbGVuLCBsZW4yO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hvbGVQb2ludHNbaV0gPSBbXTtcclxuXHJcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSB0aGlzLl9ob2xlc1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcclxuXHRcdFx0XHR0aGlzLl9ob2xlUG9pbnRzW2ldW2pdID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ob2xlc1tpXVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0aWYgKGxhdGxuZ3MgJiYgTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgJiYgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnbnVtYmVyJykpIHtcclxuXHRcdFx0dGhpcy5faW5pdFdpdGhIb2xlcyhsYXRsbmdzKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gTC5Qb2x5bGluZS5wcm90b3R5cGUuc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXHJcblx0XHQgICAgbmV3UGFydHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9wYXJ0cyA9IFtwb2ludHNdLmNvbmNhdCh0aGlzLl9ob2xlUG9pbnRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGNsaXBwZWQgPSBMLlBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3BhcnRzW2ldLCB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCk7XHJcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xyXG5cdFx0XHRcdG5ld1BhcnRzLnB1c2goY2xpcHBlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wYXJ0cyA9IG5ld1BhcnRzO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQYXRoUGFydFN0cjogZnVuY3Rpb24gKHBvaW50cykge1xyXG5cdFx0dmFyIHN0ciA9IEwuUG9seWxpbmUucHJvdG90eXBlLl9nZXRQYXRoUGFydFN0ci5jYWxsKHRoaXMsIHBvaW50cyk7XHJcblx0XHRyZXR1cm4gc3RyICsgKEwuQnJvd3Nlci5zdmcgPyAneicgOiAneCcpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnBvbHlnb24gPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogQ29udGFpbnMgTC5NdWx0aVBvbHlsaW5lIGFuZCBMLk11bHRpUG9seWdvbiBsYXllcnMuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBjcmVhdGVNdWx0aShLbGFzcykge1xyXG5cclxuXHRcdHJldHVybiBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdFx0XHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdFx0XHR0aGlzLnNldExhdExuZ3MobGF0bG5ncyk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0XHRcdHZhciBpID0gMCxcclxuXHRcdFx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKGkgPCBsZW4pIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXIuc2V0TGF0TG5ncyhsYXRsbmdzW2krK10pO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHdoaWxlIChpIDwgbGVuKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZExheWVyKG5ldyBLbGFzcyhsYXRsbmdzW2krK10sIHRoaXMuX29wdGlvbnMpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdFx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRcdFx0bGF0bG5ncy5wdXNoKGxheWVyLmdldExhdExuZ3MoKSk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBsYXRsbmdzO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdEwuTXVsdGlQb2x5bGluZSA9IGNyZWF0ZU11bHRpKEwuUG9seWxpbmUpO1xyXG5cdEwuTXVsdGlQb2x5Z29uID0gY3JlYXRlTXVsdGkoTC5Qb2x5Z29uKTtcclxuXHJcblx0TC5tdWx0aVBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5NdWx0aVBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cdEwubXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5NdWx0aVBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblx0fTtcclxufSgpKTtcclxuXG5cbi8qXHJcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXHJcbiAqL1xyXG5cclxuTC5SZWN0YW5nbGUgPSBMLlBvbHlnb24uZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XHJcblx0XHR0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcclxuXHRcdGxhdExuZ0JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcclxuXHRcdF07XHJcblx0fVxyXG59KTtcclxuXHJcbkwucmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5SZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQ2lyY2xlIGlzIGEgY2lyY2xlIG92ZXJsYXkgKHdpdGggYSBjZXJ0YWluIHJhZGl1cyBpbiBtZXRlcnMpLlxyXG4gKi9cclxuXHJcbkwuQ2lyY2xlID0gTC5QYXRoLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBhdGgucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRmaWxsOiB0cnVlXHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XHJcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsbmdSYWRpdXMgPSB0aGlzLl9nZXRMbmdSYWRpdXMoKSxcclxuXHRcdCAgICBsYXRsbmcgPSB0aGlzLl9sYXRsbmcsXHJcblx0XHQgICAgcG9pbnRMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZyAtIGxuZ1JhZGl1c10pO1xyXG5cclxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpO1xyXG5cdFx0dGhpcy5fcmFkaXVzID0gTWF0aC5tYXgodGhpcy5fcG9pbnQueCAtIHBvaW50TGVmdC54LCAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsbmdSYWRpdXMgPSB0aGlzLl9nZXRMbmdSYWRpdXMoKSxcclxuXHRcdCAgICBsYXRSYWRpdXMgPSAodGhpcy5fbVJhZGl1cyAvIDQwMDc1MDE3KSAqIDM2MCxcclxuXHRcdCAgICBsYXRsbmcgPSB0aGlzLl9sYXRsbmc7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW2xhdGxuZy5sYXQgLSBsYXRSYWRpdXMsIGxhdGxuZy5sbmcgLSBsbmdSYWRpdXNdLFxyXG5cdFx0ICAgICAgICBbbGF0bG5nLmxhdCArIGxhdFJhZGl1cywgbGF0bG5nLmxuZyArIGxuZ1JhZGl1c10pO1xyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcCA9IHRoaXMuX3BvaW50LFxyXG5cdFx0ICAgIHIgPSB0aGlzLl9yYWRpdXM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NoZWNrSWZFbXB0eSgpKSB7XHJcblx0XHRcdHJldHVybiAnJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnN2Zykge1xyXG5cdFx0XHRyZXR1cm4gJ00nICsgcC54ICsgJywnICsgKHAueSAtIHIpICtcclxuXHRcdFx0ICAgICAgICdBJyArIHIgKyAnLCcgKyByICsgJywwLDEsMSwnICtcclxuXHRcdFx0ICAgICAgIChwLnggLSAwLjEpICsgJywnICsgKHAueSAtIHIpICsgJyB6JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHAuX3JvdW5kKCk7XHJcblx0XHRcdHIgPSBNYXRoLnJvdW5kKHIpO1xyXG5cdFx0XHRyZXR1cm4gJ0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgciArICcgMCwnICsgKDY1NTM1ICogMzYwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gRWFydGggaGFyZGNvZGVkLCBtb3ZlIGludG8gcHJvamVjdGlvbiBjb2RlIVxyXG5cclxuXHRfZ2V0TGF0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21SYWRpdXMgLyA0MDA3NTAxNykgKiAzNjA7XHJcblx0fSxcclxuXHJcblx0X2dldExuZ1JhZGl1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldExhdFJhZGl1cygpIC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIHRoaXMuX2xhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHZhciB2cCA9IHRoaXMuX21hcC5fcGF0aFZpZXdwb3J0LFxyXG5cdFx0ICAgIHIgPSB0aGlzLl9yYWRpdXMsXHJcblx0XHQgICAgcCA9IHRoaXMuX3BvaW50O1xyXG5cclxuXHRcdHJldHVybiBwLnggLSByID4gdnAubWF4LnggfHwgcC55IC0gciA+IHZwLm1heC55IHx8XHJcblx0XHQgICAgICAgcC54ICsgciA8IHZwLm1pbi54IHx8IHAueSArIHIgPCB2cC5taW4ueTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jaXJjbGUgPSBmdW5jdGlvbiAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQ2lyY2xlTWFya2VyIGlzIGEgY2lyY2xlIG92ZXJsYXkgd2l0aCBhIHBlcm1hbmVudCBwaXhlbCByYWRpdXMuXHJcbiAqL1xyXG5cclxuTC5DaXJjbGVNYXJrZXIgPSBMLkNpcmNsZS5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHJhZGl1czogMTAsXHJcblx0XHR3ZWlnaHQ6IDJcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLkNpcmNsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGxhdGxuZywgbnVsbCwgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlU3R5bGUgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkNpcmNsZS5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLnNldFJhZGl1cyh0aGlzLm9wdGlvbnMucmFkaXVzKTtcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdEwuQ2lyY2xlLnByb3RvdHlwZS5zZXRMYXRMbmcuY2FsbCh0aGlzLCBsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLl9pc09wZW4pIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY2lyY2xlTWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5DaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEV4dGVuZHMgTC5Qb2x5bGluZSB0byBiZSBhYmxlIHRvIG1hbnVhbGx5IGRldGVjdCBjbGlja3Mgb24gQ2FudmFzLXJlbmRlcmVkIHBvbHlsaW5lcy5cclxuICovXHJcblxyXG5MLlBvbHlsaW5lLmluY2x1ZGUoIUwuUGF0aC5DQU5WQVMgPyB7fSA6IHtcclxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xyXG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgZGlzdCwgcGFydCxcclxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCAvIDI7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHR3ICs9IDEwOyAvLyBwb2x5bGluZSBjbGljayB0b2xlcmFuY2Ugb24gdG91Y2ggZGV2aWNlc1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcclxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XHJcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRpc3QgPSBMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSk7XHJcblxyXG5cdFx0XHRcdGlmIChkaXN0IDw9IHcpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBFeHRlbmRzIEwuUG9seWdvbiB0byBiZSBhYmxlIHRvIG1hbnVhbGx5IGRldGVjdCBjbGlja3Mgb24gQ2FudmFzLXJlbmRlcmVkIHBvbHlnb25zLlxyXG4gKi9cclxuXHJcbkwuUG9seWdvbi5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XHJcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XHJcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXHJcblx0XHQgICAgcGFydCwgcDEsIHAyLFxyXG5cdFx0ICAgIGksIGosIGssXHJcblx0XHQgICAgbGVuLCBsZW4yO1xyXG5cclxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiBjaGVjayBpZiB3aXRoaW4gYm91bmRzIGZpcnN0XHJcblxyXG5cdFx0aWYgKEwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSkpIHtcclxuXHRcdFx0Ly8gY2xpY2sgb24gcG9seWdvbiBib3JkZXJcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcclxuXHJcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xyXG5cdFx0XHRcdHAxID0gcGFydFtqXTtcclxuXHRcdFx0XHRwMiA9IHBhcnRba107XHJcblxyXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmXHJcblx0XHRcdFx0XHRcdChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XHJcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnNpZGU7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIEV4dGVuZHMgTC5DaXJjbGUgd2l0aCBDYW52YXMtc3BlY2lmaWMgY29kZS5cclxuICovXHJcblxyXG5MLkNpcmNsZS5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XHJcblx0X2RyYXdQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcCA9IHRoaXMuX3BvaW50O1xyXG5cdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0dGhpcy5fY3R4LmFyYyhwLngsIHAueSwgdGhpcy5fcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuX3BvaW50LFxyXG5cdFx0ICAgIHcyID0gdGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMDtcclxuXHJcblx0XHRyZXR1cm4gKHAuZGlzdGFuY2VUbyhjZW50ZXIpIDw9IHRoaXMuX3JhZGl1cyArIHcyKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcbiAqIENpcmNsZU1hcmtlciBjYW52YXMgc3BlY2lmaWMgZHJhd2luZyBwYXJ0cy5cbiAqL1xuXG5MLkNpcmNsZU1hcmtlci5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuUGF0aC5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlLmNhbGwodGhpcyk7XG5cdH1cbn0pO1xuXG5cbi8qXHJcbiAqIEwuR2VvSlNPTiB0dXJucyBhbnkgR2VvSlNPTiBkYXRhIGludG8gYSBMZWFmbGV0IGxheWVyLlxyXG4gKi9cclxuXHJcbkwuR2VvSlNPTiA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBMLlV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBPbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmVzW2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMucG9pbnRUb0xheWVyLCBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nLCBvcHRpb25zKTtcclxuXHRcdGxheWVyLmZlYXR1cmUgPSBMLkdlb0pTT04uYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBzdHlsZSA9IHRoaXMub3B0aW9ucy5zdHlsZTtcclxuXHRcdGlmIChzdHlsZSkge1xyXG5cdFx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0XHRMLlV0aWwuZXh0ZW5kKGxheWVyLm9wdGlvbnMsIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdH1cclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuZXh0ZW5kKEwuR2VvSlNPTiwge1xyXG5cdGdlb21ldHJ5VG9MYXllcjogZnVuY3Rpb24gKGdlb2pzb24sIHBvaW50VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIHZlY3Rvck9wdGlvbnMpIHtcclxuXHRcdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0XHQgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXHJcblx0XHQgICAgbGF5ZXJzID0gW10sXHJcblx0XHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdFx0Y29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nO1xyXG5cclxuXHRcdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdFx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKTtcclxuXHJcblx0XHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0XHRsYXllcnMucHVzaChwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIDAsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ1BvbHlnb24nOlxyXG5cdFx0XHRpZiAoY29vcmRzLmxlbmd0aCA9PT0gMiAmJiAhY29vcmRzWzFdLmxlbmd0aCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIDEsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWxpbmUobGF0bG5ncywgdmVjdG9yT3B0aW9ucyk7XHJcblxyXG5cdFx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdFx0bGF0bG5ncyA9IHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgMiwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuTXVsdGlQb2x5Z29uKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcblx0XHRcdFx0bGF5ZXJzLnB1c2godGhpcy5nZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0XHR9LCBwb2ludFRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCB2ZWN0b3JPcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjb29yZHNUb0xhdExuZzogZnVuY3Rpb24gKGNvb3JkcykgeyAvLyAoQXJyYXlbLCBCb29sZWFuXSkgLT4gTGF0TG5nXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG5cdH0sXHJcblxyXG5cdGNvb3Jkc1RvTGF0TG5nczogZnVuY3Rpb24gKGNvb3JkcywgbGV2ZWxzRGVlcCwgY29vcmRzVG9MYXRMbmcpIHsgLy8gKEFycmF5WywgTnVtYmVyLCBGdW5jdGlvbl0pIC0+IEFycmF5XHJcblx0XHR2YXIgbGF0bG5nLCBpLCBsZW4sXHJcblx0XHQgICAgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0ICAgICAgICB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBjb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQgICAgICAgIChjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9Db29yZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF07XHJcblxyXG5cdFx0aWYgKGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXRsbmcuYWx0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nc1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0TG5ncykge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRMbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKEwuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyhsYXRMbmdzW2ldKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9LFxyXG5cclxuXHRnZXRGZWF0dXJlOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/IEwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOiBMLkdlb0pTT04uYXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxuXHR9LFxyXG5cclxuXHRhc0ZlYXR1cmU6IGZ1bmN0aW9uIChnZW9KU09OKSB7XHJcblx0XHRpZiAoZ2VvSlNPTi50eXBlID09PSAnRmVhdHVyZScpIHtcclxuXHRcdFx0cmV0dXJuIGdlb0pTT047XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdFx0Z2VvbWV0cnk6IGdlb0pTT05cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBMLkdlb0pTT04ubGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5MLkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuTC5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5MLlBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLmdldExhdExuZ3MoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLlBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW0wuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5nZXRMYXRMbmdzKCkpXSxcclxuXHRcdCAgICBpLCBsZW4sIGhvbGU7XHJcblxyXG5cdFx0Y29vcmRzWzBdLnB1c2goY29vcmRzWzBdWzBdKTtcclxuXHJcblx0XHRpZiAodGhpcy5faG9sZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5faG9sZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRob2xlID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9ob2xlc1tpXSk7XHJcblx0XHRcdFx0aG9sZS5wdXNoKGhvbGVbMF0pO1xyXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKGhvbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBtdWx0aVRvR2VvSlNPTih0eXBlKSB7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04oKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0TC5NdWx0aVBvbHlsaW5lLmluY2x1ZGUoe3RvR2VvSlNPTjogbXVsdGlUb0dlb0pTT04oJ011bHRpTGluZVN0cmluZycpfSk7XHJcblx0TC5NdWx0aVBvbHlnb24uaW5jbHVkZSh7dG9HZW9KU09OOiBtdWx0aVRvR2VvSlNPTignTXVsdGlQb2x5Z29uJyl9KTtcclxuXHJcblx0TC5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdFx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LFxyXG5cdFx0XHRcdGpzb25zID0gW10sXHJcblx0XHRcdFx0anNvbjtcclxuXHJcblx0XHRcdGlmIChnZW9tZXRyeSAmJiBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0XHRyZXR1cm4gbXVsdGlUb0dlb0pTT04oJ011bHRpUG9pbnQnKS5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeSAmJiBnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJztcclxuXHJcblx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHRcdGpzb24gPSBsYXllci50b0dlb0pTT04oKTtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBqc29uLmdlb21ldHJ5IDogTC5HZW9KU09OLmFzRmVhdHVyZShqc29uKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KTtcclxufSgpKTtcclxuXHJcbkwuZ2VvSnNvbiA9IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkRvbUV2ZW50IGNvbnRhaW5zIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIERPTSBldmVudHMuXHJcbiAqL1xyXG5cclxuTC5Eb21FdmVudCA9IHtcclxuXHQvKiBpbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMgKi9cclxuXHRhZGRMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHsgLy8gKEhUTUxFbGVtZW50LCBTdHJpbmcsIEZ1bmN0aW9uWywgT2JqZWN0XSlcclxuXHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGZuKSxcclxuXHRcdCAgICBrZXkgPSAnX2xlYWZsZXRfJyArIHR5cGUgKyBpZCxcclxuXHRcdCAgICBoYW5kbGVyLCBvcmlnaW5hbEhhbmRsZXIsIG5ld1R5cGU7XHJcblxyXG5cdFx0aWYgKG9ialtrZXldKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IEwuRG9tRXZlbnQuX2dldEV2ZW50KCkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHRcdH1cclxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblxyXG5cdFx0XHRcdG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblx0XHRcdFx0bmV3VHlwZSA9ICh0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcpO1xyXG5cclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGlmICghTC5Eb21FdmVudC5fY2hlY2tNb3VzZShvYmosIGUpKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihuZXdUeXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjbGljaycgJiYgTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIEwuRG9tRXZlbnQuX2ZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpba2V5XSA9IGhhbmRsZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuKSB7ICAvLyAoSFRNTEVsZW1lbnQsIFN0cmluZywgRnVuY3Rpb24pXHJcblxyXG5cdFx0dmFyIGlkID0gTC5zdGFtcChmbiksXHJcblx0XHQgICAga2V5ID0gJ19sZWFmbGV0XycgKyB0eXBlICsgaWQsXHJcblx0XHQgICAgaGFuZGxlciA9IG9ialtrZXldO1xyXG5cclxuXHRcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JyksIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpba2V5XSA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcHBlZChlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQub24oZWwsICdtb3VzZXdoZWVsJywgc3RvcClcclxuXHRcdFx0Lm9uKGVsLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHN0b3ApO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IEwuRHJhZ2dhYmxlLlNUQVJULmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24oZWwsIEwuRHJhZ2dhYmxlLlNUQVJUW2ldLCBzdG9wKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQub24oZWwsICdjbGljaycsIEwuRG9tRXZlbnQuX2Zha2VTdG9wKVxyXG5cdFx0XHQub24oZWwsICdkYmxjbGljaycsIHN0b3ApO1xyXG5cdH0sXHJcblxyXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudFxyXG5cdFx0XHQucHJldmVudERlZmF1bHQoZSlcclxuXHRcdFx0LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRNb3VzZVBvc2l0aW9uOiBmdW5jdGlvbiAoZSwgY29udGFpbmVyKSB7XHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdFx0ZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHRcdGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0V2hlZWxEZWx0YTogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHR2YXIgZGVsdGEgPSAwO1xyXG5cclxuXHRcdGlmIChlLndoZWVsRGVsdGEpIHtcclxuXHRcdFx0ZGVsdGEgPSBlLndoZWVsRGVsdGEgLyAxMjA7XHJcblx0XHR9XHJcblx0XHRpZiAoZS5kZXRhaWwpIHtcclxuXHRcdFx0ZGVsdGEgPSAtZS5kZXRhaWwgLyAzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRlbHRhO1xyXG5cdH0sXHJcblxyXG5cdF9za2lwRXZlbnRzOiB7fSxcclxuXHJcblx0X2Zha2VTdG9wOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpXHJcblx0XHRMLkRvbUV2ZW50Ll9za2lwRXZlbnRzW2UudHlwZV0gPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9za2lwcGVkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNraXBwZWQgPSB0aGlzLl9za2lwRXZlbnRzW2UudHlwZV07XHJcblx0XHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG5cdFx0dGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gc2tpcHBlZDtcclxuXHR9LFxyXG5cclxuXHQvLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuXHRfY2hlY2tNb3VzZTogZnVuY3Rpb24gKGVsLCBlKSB7XHJcblxyXG5cdFx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdFx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0RXZlbnQ6IGZ1bmN0aW9uICgpIHsgLy8gZXZpbCBtYWdpYyBmb3IgSUVcclxuXHRcdC8qanNoaW50IG5vYXJnOmZhbHNlICovXHJcblx0XHR2YXIgZSA9IHdpbmRvdy5ldmVudDtcclxuXHRcdGlmICghZSkge1xyXG5cdFx0XHR2YXIgY2FsbGVyID0gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7XHJcblx0XHRcdHdoaWxlIChjYWxsZXIpIHtcclxuXHRcdFx0XHRlID0gY2FsbGVyWydhcmd1bWVudHMnXVswXTtcclxuXHRcdFx0XHRpZiAoZSAmJiB3aW5kb3cuRXZlbnQgPT09IGUuY29uc3RydWN0b3IpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsZXIgPSBjYWxsZXIuY2FsbGVyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZTtcclxuXHR9LFxyXG5cclxuXHQvLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcblx0X2ZpbHRlckNsaWNrOiBmdW5jdGlvbiAoZSwgaGFuZGxlcikge1xyXG5cdFx0dmFyIHRpbWVTdGFtcCA9IChlLnRpbWVTdGFtcCB8fCBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSxcclxuXHRcdFx0ZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcclxuXHJcblx0XHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRcdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdFx0cmV0dXJuIGhhbmRsZXIoZSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5Eb21FdmVudC5vbiA9IEwuRG9tRXZlbnQuYWRkTGlzdGVuZXI7XHJcbkwuRG9tRXZlbnQub2ZmID0gTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcjtcclxuXG5cbi8qXHJcbiAqIEwuRHJhZ2dhYmxlIGFsbG93cyB5b3UgdG8gYWRkIGRyYWdnaW5nIGNhcGFiaWxpdGllcyB0byBhbnkgZWxlbWVudC4gU3VwcG9ydHMgbW9iaWxlIGRldmljZXMgdG9vLlxyXG4gKi9cclxuXHJcbkwuRHJhZ2dhYmxlID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0U1RBUlQ6IEwuQnJvd3Nlci50b3VjaCA/IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSA6IFsnbW91c2Vkb3duJ10sXHJcblx0XHRFTkQ6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcblx0XHR9LFxyXG5cdFx0TU9WRToge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQpIHtcclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gTC5EcmFnZ2FibGUuU1RBUlQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJUW2ldLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gTC5EcmFnZ2FibGUuU1RBUlQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVFtpXSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHJcblx0XHRpZiAoTC5EcmFnZ2FibGUuX2Rpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2ggJiYgTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgMykgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlLCB0aGlzLl9kcmFnU3RhcnRUYXJnZXQpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJyk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHRcdHRoaXMuZmlyZSgnZHJhZycpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBMLkRyYWdnYWJsZS5NT1ZFKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSlcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtpXSwgdGhpcy5fb25VcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuTC5IYW5kbGVyID0gTC5DbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHR9LFxuXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG59KTtcblxuXG4vKlxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHRpbmVydGlhOiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3Ncblx0aW5lcnRpYVRocmVzaG9sZDogTC5Ccm93c2VyLnRvdWNoID8gMzIgOiAxOCwgLy8gbXNcblx0ZWFzZUxpbmVhcml0eTogMC4yNSxcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHR3b3JsZENvcHlKdW1wOiBmYWxzZVxufSk7XG5cbkwuTWFwLkRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdCdkcmFnJzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHQnZHJhZ2VuZCc6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZywgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbigndmlld3Jlc2V0JywgdGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwLl9wYW5BbmltKSB7XG5cdFx0XHRtYXAuX3BhbkFuaW0uc3RvcCgpO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDIwMCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnKVxuXHRcdCAgICAuZmlyZSgnZHJhZycpO1xuXHR9LFxuXG5cdF9vblZpZXdSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gZml4IGhhcmRjb2RlZCBFYXJ0aCB2YWx1ZXNcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5wcm9qZWN0KFswLCAxODBdKS54O1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXHRcdCAgICBkZWxheSA9ICtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRpbWUsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBkZWxheSA+IG9wdGlvbnMuaW5lcnRpYVRocmVzaG9sZCB8fCAhdGhpcy5fcG9zaXRpb25zWzBdO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lICsgZGVsYXkgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCB8fCAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIEwuTWFwLkRyYWcpO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Eb3VibGVDbGlja1pvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpICsgKGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IC0xIDogMSk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIEwuTWFwLkRvdWJsZUNsaWNrWm9vbSk7XG5cblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRzY3JvbGxXaGVlbFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5TY3JvbGxXaGVlbFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoNDAgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBkZWx0YSA9IHRoaXMuX2RlbHRhLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdGRlbHRhID0gZGVsdGEgPiAwID8gTWF0aC5jZWlsKGRlbHRhKSA6IE1hdGguZmxvb3IoZGVsdGEpO1xuXHRcdGRlbHRhID0gTWF0aC5tYXgoTWF0aC5taW4oZGVsdGEsIDQpLCAtNCk7XG5cdFx0ZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgZGVsdGEpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgTC5NYXAuU2Nyb2xsV2hlZWxab29tKTtcblxuXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xyXG5cclxuXHRfdG91Y2hzdGFydDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JyxcclxuXHRfdG91Y2hlbmQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogTC5Ccm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCcsXHJcblxyXG5cdC8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcblx0YWRkRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0XHR2YXIgbGFzdCxcclxuXHRcdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHRcdCAgICBkZWxheSA9IDI1MCxcclxuXHRcdCAgICB0b3VjaCxcclxuXHRcdCAgICBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gdGhpcy5fdG91Y2hzdGFydCxcclxuXHRcdCAgICB0b3VjaGVuZCA9IHRoaXMuX3RvdWNoZW5kLFxyXG5cdFx0ICAgIHRyYWNrZWRUb3VjaGVzID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0dHJhY2tlZFRvdWNoZXMucHVzaChlLnBvaW50ZXJJZCk7XHJcblx0XHRcdFx0Y291bnQgPSB0cmFja2VkVG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjb3VudCA+IDEpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBub3cgPSBEYXRlLm5vdygpLFxyXG5cdFx0XHRcdGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRcdGxhc3QgPSBub3c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdHZhciBpZHggPSB0cmFja2VkVG91Y2hlcy5pbmRleE9mKGUucG9pbnRlcklkKTtcclxuXHRcdFx0XHRpZiAoaWR4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0cmFja2VkVG91Y2hlcy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRvdWJsZVRhcCkge1xyXG5cdFx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdFx0dmFyIG5ld1RvdWNoID0geyB9LFxyXG5cdFx0XHRcdFx0XHRwcm9wO1xyXG5cclxuXHRcdFx0XHRcdC8vIGpzaGludCBmb3JpbjpmYWxzZVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcC5iaW5kKHRvdWNoKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3A7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRvYmpbcHJlICsgdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRcdG9ialtwcmUgKyB0b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblxyXG5cdFx0Ly8gb24gcG9pbnRlciB3ZSBuZWVkIHRvIGxpc3RlbiBvbiB0aGUgZG9jdW1lbnQsIG90aGVyd2lzZSBhIGRyYWcgc3RhcnRpbmcgb24gdGhlIG1hcCBhbmQgbW92aW5nIG9mZiBzY3JlZW5cclxuXHRcdC8vIHdpbGwgbm90IGNvbWUgdGhyb3VnaCB0byB1cywgc28gd2Ugd2lsbCBsb3NlIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgYXJlIG9uZ29pbmdcclxuXHRcdHZhciBlbmRFbGVtZW50ID0gTC5Ccm93c2VyLnBvaW50ZXIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBvYmo7XHJcblxyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XHJcblx0XHRlbmRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0ZW5kRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEwuRG9tRXZlbnQuUE9JTlRFUl9DQU5DRUwsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaHN0YXJ0LCBvYmpbcHJlICsgdGhpcy5fdG91Y2hzdGFydCArIGlkXSwgZmFsc2UpO1xyXG5cdFx0KEwuQnJvd3Nlci5wb2ludGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogb2JqKS5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0ICAgICAgICB0aGlzLl90b3VjaGVuZCwgb2JqW3ByZSArIHRoaXMuX3RvdWNoZW5kICsgaWRdLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEwuRG9tRXZlbnQuUE9JTlRFUl9DQU5DRUwsIG9ialtwcmUgKyB0aGlzLl90b3VjaGVuZCArIGlkXSxcclxuXHRcdFx0XHRmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcblxuXHQvL3N0YXRpY1xuXHRQT0lOVEVSX0RPV046IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiAncG9pbnRlcmRvd24nLFxuXHRQT0lOVEVSX01PVkU6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgOiAncG9pbnRlcm1vdmUnLFxuXHRQT0lOVEVSX1VQOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6ICdwb2ludGVydXAnLFxuXHRQT0lOVEVSX0NBTkNFTDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnLFxuXG5cdF9wb2ludGVyczogW10sXG5cdF9wb2ludGVyRG9jdW1lbnRMaXN0ZW5lcjogZmFsc2UsXG5cblx0Ly8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuXHQvLyBCYXNlZCBvbiBjaGFuZ2VzIGJ5IHZlcHJvemEgaHR0cHM6Ly9naXRodWIuY29tL0Nsb3VkTWFkZS9MZWFmbGV0L3B1bGwvMTAxOVxuXHQvL3JlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAndG91Y2hzdGFydCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJTdGFydChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcblx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJFbmQob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XG5cdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdHJldHVybiB0aGlzLmFkZFBvaW50ZXJMaXN0ZW5lck1vdmUob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93ICdVbmtub3duIHRvdWNoIGV2ZW50IHR5cGUnO1xuXHRcdH1cblx0fSxcblxuXHRhZGRQb2ludGVyTGlzdGVuZXJTdGFydDogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXG5cdFx0ICAgIHBvaW50ZXJzID0gdGhpcy5fcG9pbnRlcnM7XG5cblx0XHR2YXIgY2IgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYWxyZWFkeUluQXJyYXkgPSBmYWxzZTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHRhbHJlYWR5SW5BcnJheSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghYWxyZWFkeUluQXJyYXkpIHtcblx0XHRcdFx0cG9pbnRlcnMucHVzaChlKTtcblx0XHRcdH1cblxuXHRcdFx0ZS50b3VjaGVzID0gcG9pbnRlcnMuc2xpY2UoKTtcblx0XHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRcdGhhbmRsZXIoZSk7XG5cdFx0fTtcblxuXHRcdG9ialtwcmUgKyAndG91Y2hzdGFydCcgKyBpZF0gPSBjYjtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgY2IsIGZhbHNlKTtcblxuXHRcdC8vIG5lZWQgdG8gYWxzbyBsaXN0ZW4gZm9yIGVuZCBldmVudHMgdG8ga2VlcCB0aGUgX3BvaW50ZXJzIGxpc3QgYWNjdXJhdGVcblx0XHQvLyB0aGlzIG5lZWRzIHRvIGJlIG9uIHRoZSBib2R5IGFuZCBuZXZlciBnbyBhd2F5XG5cdFx0aWYgKCF0aGlzLl9wb2ludGVyRG9jdW1lbnRMaXN0ZW5lcikge1xuXHRcdFx0dmFyIGludGVybmFsQ2IgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHRcdHBvaW50ZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdC8vV2UgbGlzdGVuIG9uIHRoZSBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGludGVybmFsQ2IsIGZhbHNlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIGludGVybmFsQ2IsIGZhbHNlKTtcblxuXHRcdFx0dGhpcy5fcG9pbnRlckRvY3VtZW50TGlzdGVuZXIgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFkZFBvaW50ZXJMaXN0ZW5lck1vdmU6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxuXHRcdCAgICB0b3VjaGVzID0gdGhpcy5fcG9pbnRlcnM7XG5cblx0XHRmdW5jdGlvbiBjYihlKSB7XG5cblx0XHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRvdWNoZXNbaV0ucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuXHRcdFx0XHRcdHRvdWNoZXNbaV0gPSBlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGUudG91Y2hlcyA9IHRvdWNoZXMuc2xpY2UoKTtcblx0XHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRcdGhhbmRsZXIoZSk7XG5cdFx0fVxuXG5cdFx0b2JqW3ByZSArICd0b3VjaG1vdmUnICsgaWRdID0gY2I7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGNiLCBmYWxzZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhZGRQb2ludGVyTGlzdGVuZXJFbmQ6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxuXHRcdCAgICB0b3VjaGVzID0gdGhpcy5fcG9pbnRlcnM7XG5cblx0XHR2YXIgY2IgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0b3VjaGVzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHR0b3VjaGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlLnRvdWNoZXMgPSB0b3VjaGVzLnNsaWNlKCk7XG5cdFx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdFx0XHRoYW5kbGVyKGUpO1xuXHRcdH07XG5cblx0XHRvYmpbcHJlICsgJ3RvdWNoZW5kJyArIGlkXSA9IGNiO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgY2IsIGZhbHNlKTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBjYiwgZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBpZCkge1xuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcblx0XHQgICAgY2IgPSBvYmpbcHJlICsgdHlwZSArIGlkXTtcblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIGNiLCBmYWxzZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGNiLCBmYWxzZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGNiLCBmYWxzZSk7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBjYiwgZmFsc2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHR0b3VjaFpvb206IEwuQnJvd3Nlci50b3VjaCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuTC5NYXAuVG91Y2hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICB2aWV3Q2VudGVyID0gbWFwLl9nZXRDZW50ZXJMYXllclBvaW50KCk7XG5cblx0XHR0aGlzLl9zdGFydENlbnRlciA9IHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2NlbnRlck9mZnNldCA9IHZpZXdDZW50ZXIuc3VidHJhY3QodGhpcy5fc3RhcnRDZW50ZXIpO1xuXG5cdFx0aWYgKG1hcC5fcGFuQW5pbSkge1xuXHRcdFx0bWFwLl9wYW5BbmltLnN0b3AoKTtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9zY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXHRcdHRoaXMuX2RlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydENlbnRlcik7XG5cblx0XHRpZiAodGhpcy5fc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cykge1xuXHRcdFx0aWYgKChtYXAuZ2V0Wm9vbSgpID09PSBtYXAuZ2V0TWluWm9vbSgpICYmIHRoaXMuX3NjYWxlIDwgMSkgfHxcblx0XHRcdCAgICAobWFwLmdldFpvb20oKSA9PT0gbWFwLmdldE1heFpvb20oKSAmJiB0aGlzLl9zY2FsZSA+IDEpKSB7IHJldHVybjsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhtYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJyk7XG5cblx0XHRcdG1hcFxuXHRcdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdFx0ICAgIC5maXJlKCd6b29tc3RhcnQnKTtcblxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoXG5cdFx0ICAgICAgICB0aGlzLl91cGRhdGVPbk1vdmUsIHRoaXMsIHRydWUsIHRoaXMuX21hcC5fY29udGFpbmVyKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X3VwZGF0ZU9uTW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9yaWdpbiA9IHRoaXMuX2dldFNjYWxlT3JpZ2luKCksXG5cdFx0ICAgIGNlbnRlciA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcob3JpZ2luKSxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRTY2FsZVpvb20odGhpcy5fc2NhbGUpO1xuXG5cdFx0bWFwLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRoaXMuX3N0YXJ0Q2VudGVyLCB0aGlzLl9zY2FsZSwgdGhpcy5fZGVsdGEsIGZhbHNlLCB0cnVlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhtYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJyk7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSlcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHR2YXIgb3JpZ2luID0gdGhpcy5fZ2V0U2NhbGVPcmlnaW4oKSxcblx0XHQgICAgY2VudGVyID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhvcmlnaW4pLFxuXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBmbG9hdFpvb21EZWx0YSA9IG1hcC5nZXRTY2FsZVpvb20odGhpcy5fc2NhbGUpIC0gb2xkWm9vbSxcblx0XHQgICAgcm91bmRab29tRGVsdGEgPSAoZmxvYXRab29tRGVsdGEgPiAwID9cblx0XHQgICAgICAgICAgICBNYXRoLmNlaWwoZmxvYXRab29tRGVsdGEpIDogTWF0aC5mbG9vcihmbG9hdFpvb21EZWx0YSkpLFxuXG5cdFx0ICAgIHpvb20gPSBtYXAuX2xpbWl0Wm9vbShvbGRab29tICsgcm91bmRab29tRGVsdGEpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUoem9vbSkgLyB0aGlzLl9zY2FsZTtcblxuXHRcdG1hcC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCBvcmlnaW4sIHNjYWxlKTtcblx0fSxcblxuXHRfZ2V0U2NhbGVPcmlnaW46IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2VudGVyT2Zmc2V0ID0gdGhpcy5fY2VudGVyT2Zmc2V0LnN1YnRyYWN0KHRoaXMuX2RlbHRhKS5kaXZpZGVCeSh0aGlzLl9zY2FsZSk7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXJ0Q2VudGVyLmFkZChjZW50ZXJPZmZzZXQpO1xuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgTC5NYXAuVG91Y2hab29tKTtcblxuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHR0YXA6IHRydWUsXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5MLk1hcC5UYXAgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcylcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25VcCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpXG5cdFx0XHQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblVwLCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XG5cdEwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIEwuTWFwLlRhcCk7XG59XG5cblxuLypcbiAqIEwuSGFuZGxlci5TaGlmdERyYWdab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbkwuTWFwLkJveFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblxuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0TGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX2JveCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fcGFuZSk7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCB0aGlzLl9zdGFydExheWVyUG9pbnQpO1xuXG5cdFx0XHQvL1RPRE8gcmVmYWN0b3I6IG1vdmUgY3Vyc29yIHRvIHN0eWxlc1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHZhciBzdGFydFBvaW50ID0gdGhpcy5fc3RhcnRMYXllclBvaW50LFxuXHRcdCAgICBib3ggPSB0aGlzLl9ib3gsXG5cblx0XHQgICAgbGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLFxuXHRcdCAgICBvZmZzZXQgPSBsYXllclBvaW50LnN1YnRyYWN0KHN0YXJ0UG9pbnQpLFxuXG5cdFx0ICAgIG5ld1BvcyA9IG5ldyBMLlBvaW50KFxuXHRcdCAgICAgICAgTWF0aC5taW4obGF5ZXJQb2ludC54LCBzdGFydFBvaW50LngpLFxuXHRcdCAgICAgICAgTWF0aC5taW4obGF5ZXJQb2ludC55LCBzdGFydFBvaW50LnkpKTtcblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihib3gsIG5ld1Bvcyk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHQvLyBUT0RPIHJlZmFjdG9yOiByZW1vdmUgaGFyZGNvZGVkIDQgcGl4ZWxzXG5cdFx0Ym94LnN0eWxlLndpZHRoICA9IChNYXRoLm1heCgwLCBNYXRoLmFicyhvZmZzZXQueCkgLSA0KSkgKyAncHgnO1xuXHRcdGJveC5zdHlsZS5oZWlnaHQgPSAoTWF0aC5tYXgoMCwgTWF0aC5hYnMob2Zmc2V0LnkpIC0gNCkpICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9wYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2JveCk7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJyc7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBsYXllclBvaW50ID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cblx0XHRpZiAodGhpcy5fc3RhcnRMYXllclBvaW50LmVxdWFscyhsYXllclBvaW50KSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0TGF5ZXJQb2ludCksXG5cdFx0ICAgICAgICBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpKTtcblxuXHRcdG1hcC5maXRCb3VuZHMoYm91bmRzKTtcblxuXHRcdG1hcC5maXJlKCdib3h6b29tZW5kJywge1xuXHRcdFx0Ym94Wm9vbUJvdW5kczogYm91bmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEwuTWFwLkJveFpvb20pO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRrZXlib2FyZDogdHJ1ZSxcblx0a2V5Ym9hcmRQYW5PZmZzZXQ6IDgwLFxuXHRrZXlib2FyZFpvb21PZmZzZXQ6IDFcbn0pO1xuXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5PZmZzZXQpO1xuXHRcdHRoaXMuX3NldFpvb21PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRab29tT2Zmc2V0KTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPT09IC0xKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oY29udGFpbmVyLCAnZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB0aGlzKVxuXHRcdCAgICAub24oY29udGFpbmVyLCAnYmx1cicsIHRoaXMuX29uQmx1ciwgdGhpcylcblx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAub24oJ2ZvY3VzJywgdGhpcy5fYWRkSG9va3MsIHRoaXMpXG5cdFx0ICAgIC5vbignYmx1cicsIHRoaXMuX3JlbW92ZUhvb2tzLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoY29udGFpbmVyLCAnZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB0aGlzKVxuXHRcdCAgICAub2ZmKGNvbnRhaW5lciwgJ2JsdXInLCB0aGlzLl9vbkJsdXIsIHRoaXMpXG5cdFx0ICAgIC5vZmYoY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5vZmYoJ2ZvY3VzJywgdGhpcy5fYWRkSG9va3MsIHRoaXMpXG5cdFx0ICAgIC5vZmYoJ2JsdXInLCB0aGlzLl9yZW1vdmVIb29rcywgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuT2Zmc2V0OiBmdW5jdGlvbiAocGFuKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbiwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW4sIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbl07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbl07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tT2Zmc2V0OiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb207XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHRcdG1hcC5wYW5CeSh0aGlzLl9wYW5LZXlzW2tleV0pO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgTC5NYXAuS2V5Ym9hcmQpO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuTC5IYW5kbGVyLk1hcmtlckRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoaWNvbiwgaWNvbik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlXG5cdFx0XHQub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9uKCdkcmFnJywgdGhpcy5fb25EcmFnLCB0aGlzKVxuXHRcdFx0Lm9uKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCB0aGlzKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlXG5cdFx0XHQub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWcnLCB0aGlzLl9vbkRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIHtsYXRsbmc6IGxhdGxuZ30pXG5cdFx0ICAgIC5maXJlKCdkcmFnJyk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcblxuXG4vKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5MLkNvbnRyb2wgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdGNvcm5lci5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKG1hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vLyBhZGRzIGNvbnRyb2wtcmVsYXRlZCBtZXRob2RzIHRvIEwuTWFwXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZUZyb20odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBMLkNvbnRyb2wuWm9vbSBpcyB1c2VkIGZvciB0aGUgZGVmYXVsdCB6b29tIGJ1dHRvbnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuWm9vbSA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cdFx0em9vbU91dFRleHQ6ICctJyxcclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKFxyXG5cdFx0ICAgICAgICB0aGlzLm9wdGlvbnMuem9vbUluVGV4dCwgdGhpcy5vcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4sICB0aGlzKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXHJcblx0XHQgICAgICAgIHRoaXMub3B0aW9ucy56b29tT3V0VGV4dCwgdGhpcy5vcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fbWFwLnpvb21JbihlLnNoaWZ0S2V5ID8gMyA6IDEpO1xyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fbWFwLnpvb21PdXQoZS5zaGlmdEtleSA/IDMgOiAxKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBzdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnbW91c2Vkb3duJywgc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ2RibGNsaWNrJywgc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgY29udGV4dCk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0XHRjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdGlmIChtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wuem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuWm9vbShvcHRpb25zKTtcclxufTtcclxuXHJcblxuXG4vKlxyXG4gKiBMLkNvbnRyb2wuQXR0cmlidXRpb24gaXMgdXNlZCBmb3IgZGlzcGxheWluZyBhdHRyaWJ1dGlvbiBvbiB0aGUgbWFwIChhZGRlZCBieSBkZWZhdWx0KS5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRtYXBcclxuXHRcdCAgICAub24oJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckFkZCwgdGhpcylcclxuXHRcdCAgICAub24oJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllclJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQWRkKVxyXG5cdFx0ICAgIC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllclJlbW92ZSk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihlLmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGlvbihlLmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wgPSAobmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbigpKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sLmF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXG4gKiBMLkNvbnRyb2wuU2NhbGUgaXMgdXNlZCBmb3IgZGlzcGxheWluZyBtZXRyaWMvaW1wZXJpYWwgc2NhbGUgb24gdGhlIG1hcC5cbiAqL1xuXG5MLkNvbnRyb2wuU2NhbGUgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cdFx0bWF4V2lkdGg6IDEwMCxcblx0XHRtZXRyaWM6IHRydWUsXG5cdFx0aW1wZXJpYWw6IHRydWUsXG5cdFx0dXBkYXRlV2hlbklkbGU6IGZhbHNlXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldEJvdW5kcygpLFxuXHRcdCAgICBjZW50ZXJMYXQgPSBib3VuZHMuZ2V0Q2VudGVyKCkubGF0LFxuXHRcdCAgICBoYWxmV29ybGRNZXRlcnMgPSA2Mzc4MTM3ICogTWF0aC5QSSAqIE1hdGguY29zKGNlbnRlckxhdCAqIE1hdGguUEkgLyAxODApLFxuXHRcdCAgICBkaXN0ID0gaGFsZldvcmxkTWV0ZXJzICogKGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sbmcgLSBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKSAvIDE4MCxcblxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHQgICAgbWF4TWV0ZXJzID0gMDtcblxuXHRcdGlmIChzaXplLnggPiAwKSB7XG5cdFx0XHRtYXhNZXRlcnMgPSBkaXN0ICogKG9wdGlvbnMubWF4V2lkdGggLyBzaXplLngpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhvcHRpb25zLCBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBtYXhNZXRlcnMpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKTtcblxuXHRcdHRoaXMuX21TY2FsZS5zdHlsZS53aWR0aCA9IHRoaXMuX2dldFNjYWxlV2lkdGgobWV0ZXJzIC8gbWF4TWV0ZXJzKSArICdweCc7XG5cdFx0dGhpcy5fbVNjYWxlLmlubmVySFRNTCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5faVNjYWxlLFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblxuXHRcdFx0c2NhbGUuc3R5bGUud2lkdGggPSB0aGlzLl9nZXRTY2FsZVdpZHRoKG1pbGVzIC8gbWF4TWlsZXMpICsgJ3B4Jztcblx0XHRcdHNjYWxlLmlubmVySFRNTCA9IG1pbGVzICsgJyBtaSc7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXG5cdFx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IHRoaXMuX2dldFNjYWxlV2lkdGgoZmVldCAvIG1heEZlZXQpICsgJ3B4Jztcblx0XHRcdHNjYWxlLmlubmVySFRNTCA9IGZlZXQgKyAnIGZ0Jztcblx0XHR9XG5cdH0sXG5cblx0X2dldFNjYWxlV2lkdGg6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSAtIDEwO1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDogZCA+PSA1ID8gNSA6IGQgPj0gMyA/IDMgOiBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5MLmNvbnRyb2wuc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5TY2FsZShvcHRpb25zKTtcbn07XG5cblxuLypcclxuICogTC5Db250cm9sLkxheWVycyBpcyBhIGNvbnRyb2wgdG8gYWxsb3cgdXNlcnMgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGxheWVycyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5MYXllcnMgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHRcdGF1dG9aSW5kZXg6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRtYXBcclxuXHRcdCAgICAub24oJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcylcclxuXHRcdCAgICAub24oJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKVxyXG5cdFx0ICAgIC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0Ly9NYWtlcyB0aGlzIHdvcmsgb24gSUUxMCBUb3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcilcclxuXHRcdFx0XHQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdCAgICAub24oY29udGFpbmVyLCAnbW91c2VvdmVyJywgdGhpcy5fZXhwYW5kLCB0aGlzKVxyXG5cdFx0XHRcdCAgICAub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxyXG5cdFx0XHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuX2V4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9Xb3JrIGFyb3VuZCBmb3IgRmlyZWZveCBhbmRyb2lkIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwMzNcclxuXHRcdFx0TC5Eb21FdmVudC5vbihmb3JtLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKSwgMCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX2NvbGxhcHNlLCB0aGlzKTtcclxuXHRcdFx0Ly8gVE9ETyBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBmb3JtKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSB7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcblx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5pbm5lckhUTUwgPSAnJztcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdC5pbm5lckhUTUwgPSAnJztcclxuXHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQgPSBmYWxzZSxcclxuXHRcdCAgICBvdmVybGF5c1ByZXNlbnQgPSBmYWxzZSxcclxuXHRcdCAgICBpLCBvYmo7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2xheWVyc1tMLnN0YW1wKGUubGF5ZXIpXTtcclxuXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcblx0XHRcdChlLnR5cGUgPT09ICdsYXllcmFkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2xheWVyYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgKyBuYW1lICsgJ1wiJztcclxuXHRcdGlmIChjaGVja2VkKSB7XHJcblx0XHRcdHJhZGlvSHRtbCArPSAnIGNoZWNrZWQ9XCJjaGVja2VkXCInO1xyXG5cdFx0fVxyXG5cdFx0cmFkaW9IdG1sICs9ICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzJywgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IEwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCBpbnB1dCwgb2JqLFxyXG5cdFx0ICAgIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXRzTGVuID0gaW5wdXRzLmxlbmd0aDtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgaW5wdXRzTGVuOyBpKyspIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpbnB1dC5sYXllcklkXTtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkICYmICF0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihvYmoubGF5ZXIpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihvYmoubGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5fY29udGFpbmVyLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcsICcnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sLmxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxuICogTC5Qb3NBbmltYXRpb24gaXMgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgZm9yIHBhbiBhbmltYXRpb25zLlxuICovXG5cbkwuUG9zQW5pbWF0aW9uID0gTC5DbGFzcy5leHRlbmQoe1xuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIE51bWJlciwgTnVtYmVyXSlcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3UG9zO1xuXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TSVRJT05dID0gJ2FsbCAnICsgKGR1cmF0aW9uIHx8IDAuMjUpICtcblx0XHQgICAgICAgICdzIGN1YmljLWJlemllcigwLDAsJyArIChlYXNlTGluZWFyaXR5IHx8IDAuNSkgKyAnLDEpJztcblxuXHRcdEwuRG9tRXZlbnQub24oZWwsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oZWwsIG5ld1Bvcyk7XG5cblx0XHQvLyB0b2dnbGUgcmVmbG93LCBDaHJvbWUgZmxpY2tlcnMgZm9yIHNvbWUgcmVhc29uIGlmIHlvdSBkb24ndCBkbyB0aGlzXG5cdFx0TC5VdGlsLmZhbHNlRm4oZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0Ly8gdGhlcmUncyBubyBuYXRpdmUgd2F5IHRvIHRyYWNrIHZhbHVlIHVwZGF0ZXMgb2YgdHJhbnNpdGlvbmVkIHByb3BlcnRpZXMsIHNvIHdlIGltaXRhdGUgdGhpc1xuXHRcdHRoaXMuX3N0ZXBUaW1lciA9IHNldEludGVydmFsKEwuYmluZCh0aGlzLl9vblN0ZXAsIHRoaXMpLCA1MCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdC8vIGlmIHdlIGp1c3QgcmVtb3ZlZCB0aGUgdHJhbnNpdGlvbiBwcm9wZXJ0eSwgdGhlIGVsZW1lbnQgd291bGQganVtcCB0byBpdHMgZmluYWwgcG9zaXRpb24sXG5cdFx0Ly8gc28gd2UgbmVlZCB0byBtYWtlIGl0IHN0YXkgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fZ2V0UG9zKCkpO1xuXHRcdHRoaXMuX29uVHJhbnNpdGlvbkVuZCgpO1xuXHRcdEwuVXRpbC5mYWxzZUZuKHRoaXMuX2VsLm9mZnNldFdpZHRoKTsgLy8gZm9yY2UgcmVmbG93IGluIGNhc2Ugd2UgYXJlIGFib3V0IHRvIHN0YXJ0IGEgbmV3IGFuaW1hdGlvblxuXHR9LFxuXG5cdF9vblN0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc3RlcFBvcyA9IHRoaXMuX2dldFBvcygpO1xuXHRcdGlmICghc3RlcFBvcykge1xuXHRcdFx0dGhpcy5fb25UcmFuc2l0aW9uRW5kKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXG5cdFx0Ly8gbWFrZSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24gcmV0dXJuIGludGVybWVkaWF0ZSBwb3NpdGlvbiB2YWx1ZSBkdXJpbmcgYW5pbWF0aW9uXG5cdFx0dGhpcy5fZWwuX2xlYWZsZXRfcG9zID0gc3RlcFBvcztcblxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdC8vIHlvdSBjYW4ndCBlYXNpbHkgZ2V0IGludGVybWVkaWF0ZSB2YWx1ZXMgb2YgcHJvcGVydGllcyBhbmltYXRlZCB3aXRoIENTUzMgVHJhbnNpdGlvbnMsXG5cdC8vIHdlIG5lZWQgdG8gcGFyc2UgY29tcHV0ZWQgc3R5bGUgKGluIGNhc2Ugb2YgdHJhbnNmb3JtIGl0IHJldHVybnMgbWF0cml4IHN0cmluZylcblxuXHRfdHJhbnNmb3JtUmU6IC8oWy0rXT8oPzpcXGQqXFwuKT9cXGQrKVxcRCosIChbLStdPyg/OlxcZCpcXC4pP1xcZCspXFxEKlxcKS8sXG5cblx0X2dldFBvczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsZWZ0LCB0b3AsIG1hdGNoZXMsXG5cdFx0ICAgIGVsID0gdGhpcy5fZWwsXG5cdFx0ICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0bWF0Y2hlcyA9IHN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dLm1hdGNoKHRoaXMuX3RyYW5zZm9ybVJlKTtcblx0XHRcdGlmICghbWF0Y2hlcykgeyByZXR1cm47IH1cblx0XHRcdGxlZnQgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuXHRcdFx0dG9wICA9IHBhcnNlRmxvYXQobWF0Y2hlc1syXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmxlZnQpO1xuXHRcdFx0dG9wICA9IHBhcnNlRmxvYXQoc3R5bGUudG9wKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGVmdCwgdG9wLCB0cnVlKTtcblx0fSxcblxuXHRfb25UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZWwsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCB0aGlzKTtcblxuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cblx0XHR0aGlzLl9lbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNJVElPTl0gPSAnJztcblxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXG5cdFx0Ly8gbWFrZSBzdXJlIEwuRG9tVXRpbC5nZXRQb3NpdGlvbiByZXR1cm5zIHRoZSBmaW5hbCBwb3NpdGlvbiB2YWx1ZSBhZnRlciBhbmltYXRpb25cblx0XHR0aGlzLl9lbC5fbGVhZmxldF9wb3MgPSB0aGlzLl9uZXdQb3M7XG5cblx0XHRjbGVhckludGVydmFsKHRoaXMuX3N0ZXBUaW1lcik7XG5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKS5maXJlKCdlbmQnKTtcblx0fVxuXG59KTtcblxuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgcGFubmluZyBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLmluY2x1ZGUoe1xuXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKEwubGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b3B0aW9ucy56b29tID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XG5cdFx0XHRcdG9wdGlvbnMucGFuID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMucGFuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuXHRcdFx0dmFyIGFuaW1hdGVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcblxuXHRcdFx0aWYgKGFuaW1hdGVkKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xuXHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xuXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCk7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZmxvb3IoKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5cbi8qXG4gKiBMLlBvc0FuaW1hdGlvbiBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiB0aGF0IHBvd2VycyBMZWFmbGV0IHBhbiBhbmltYXRpb25zXG4gKiBpbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucy5cbiAqL1xuXG5MLlBvc0FuaW1hdGlvbiA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OID8gTC5Qb3NBbmltYXRpb24gOiBMLlBvc0FuaW1hdGlvbi5leHRlbmQoe1xuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBOdW1iZXIsIE51bWJlcl0pXG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCgpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuXG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSB6b29tIGFuaW1hdGlvbnMuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcblx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNFxufSk7XG5cbmlmIChMLkRvbVV0aWwuVFJBTlNJVElPTikge1xuXG5cdEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJlxuXHRcdFx0XHRMLkJyb3dzZXIuYW55M2QgJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMgJiYgIUwuQnJvd3Nlci5tb2JpbGVPcGVyYTtcblxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwUGFuZSwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59XG5cbkwuTWFwLmluY2x1ZGUoIUwuRG9tVXRpbC5UUkFOU0lUSU9OID8ge30gOiB7XG5cblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xuXHR9LFxuXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpLFxuXHRcdFx0b3JpZ2luID0gdGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpLl9hZGQob2Zmc2V0KTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXNcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCd6b29tc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgb3JpZ2luLCBzY2FsZSwgbnVsbCwgdHJ1ZSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9yaWdpbiwgc2NhbGUsIGRlbHRhLCBiYWNrd2FyZHMsIGZvclRvdWNoWm9vbSkge1xuXG5cdFx0aWYgKCFmb3JUb3VjaFpvb20pIHtcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIHB1dCB0cmFuc2Zvcm0gdHJhbnNpdGlvbiBvbiBhbGwgbGF5ZXJzIHdpdGggbGVhZmxldC16b29tLWFuaW1hdGVkIGNsYXNzXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXG5cdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xuXHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xuXG5cdFx0Ly8gZGlzYWJsZSBhbnkgZHJhZ2dpbmcgZHVyaW5nIGFuaW1hdGlvblxuXHRcdGlmIChMLkRyYWdnYWJsZSkge1xuXHRcdFx0TC5EcmFnZ2FibGUuX2Rpc2FibGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xuXHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0em9vbTogem9vbSxcblx0XHRcdFx0b3JpZ2luOiBvcmlnaW4sXG5cdFx0XHRcdHNjYWxlOiBzY2FsZSxcblx0XHRcdFx0ZGVsdGE6IGRlbHRhLFxuXHRcdFx0XHRiYWNrd2FyZHM6IGJhY2t3YXJkc1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBob3JyaWJsZSBoYWNrIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5XG5cdFx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblxuXHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHRydWUsIHRydWUpO1xuXG5cdFx0XHRpZiAoTC5EcmFnZ2FibGUpIHtcblx0XHRcdFx0TC5EcmFnZ2FibGUuX2Rpc2FibGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cdH1cbn0pO1xuXG5cbi8qXG5cdFpvb20gYW5pbWF0aW9uIGxvZ2ljIGZvciBMLlRpbGVMYXllci5cbiovXG5cbkwuVGlsZUxheWVyLmluY2x1ZGUoe1xuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcblx0XHRcdHRoaXMuX2FuaW1hdGluZyA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcmVwYXJlQmdCdWZmZXIoKTtcblx0XHR9XG5cblx0XHR2YXIgYmcgPSB0aGlzLl9iZ0J1ZmZlcixcblx0XHQgICAgdHJhbnNmb3JtID0gTC5Eb21VdGlsLlRSQU5TRk9STSxcblx0XHQgICAgaW5pdGlhbFRyYW5zZm9ybSA9IGUuZGVsdGEgPyBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKGUuZGVsdGEpIDogYmcuc3R5bGVbdHJhbnNmb3JtXSxcblx0XHQgICAgc2NhbGVTdHIgPSBMLkRvbVV0aWwuZ2V0U2NhbGVTdHJpbmcoZS5zY2FsZSwgZS5vcmlnaW4pO1xuXG5cdFx0Ymcuc3R5bGVbdHJhbnNmb3JtXSA9IGUuYmFja3dhcmRzID9cblx0XHRcdFx0c2NhbGVTdHIgKyAnICcgKyBpbml0aWFsVHJhbnNmb3JtIDpcblx0XHRcdFx0aW5pdGlhbFRyYW5zZm9ybSArICcgJyArIHNjYWxlU3RyO1xuXHR9LFxuXG5cdF9lbmRab29tQW5pbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBmcm9udCA9IHRoaXMuX3RpbGVDb250YWluZXIsXG5cdFx0ICAgIGJnID0gdGhpcy5fYmdCdWZmZXI7XG5cblx0XHRmcm9udC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cdFx0ZnJvbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChmcm9udCk7IC8vIEJyaW5nIHRvIGZvcmVcblxuXHRcdC8vIGZvcmNlIHJlZmxvd1xuXHRcdEwuVXRpbC5mYWxzZUZuKGJnLm9mZnNldFdpZHRoKTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fY2xlYXJCZ0J1ZmZlcigpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FuaW1hdGluZyA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckJnQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmIChtYXAgJiYgIW1hcC5fYW5pbWF0aW5nWm9vbSAmJiAhbWFwLnRvdWNoWm9vbS5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fYmdCdWZmZXIuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHR0aGlzLl9iZ0J1ZmZlci5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9ICcnO1xuXHRcdH1cblx0fSxcblxuXHRfcHJlcGFyZUJnQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZnJvbnQgPSB0aGlzLl90aWxlQ29udGFpbmVyLFxuXHRcdCAgICBiZyA9IHRoaXMuX2JnQnVmZmVyO1xuXG5cdFx0Ly8gaWYgZm9yZWdyb3VuZCBsYXllciBkb2Vzbid0IGhhdmUgbWFueSB0aWxlcyBidXQgYmcgbGF5ZXIgZG9lcyxcblx0XHQvLyBrZWVwIHRoZSBleGlzdGluZyBiZyBsYXllciBhbmQganVzdCB6b29tIGl0IHNvbWUgbW9yZVxuXG5cdFx0dmFyIGJnTG9hZGVkID0gdGhpcy5fZ2V0TG9hZGVkVGlsZXNQZXJjZW50YWdlKGJnKSxcblx0XHQgICAgZnJvbnRMb2FkZWQgPSB0aGlzLl9nZXRMb2FkZWRUaWxlc1BlcmNlbnRhZ2UoZnJvbnQpO1xuXG5cdFx0aWYgKGJnICYmIGJnTG9hZGVkID4gMC41ICYmIGZyb250TG9hZGVkIDwgMC41KSB7XG5cblx0XHRcdGZyb250LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHRcdHRoaXMuX3N0b3BMb2FkaW5nSW1hZ2VzKGZyb250KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBwcmVwYXJlIHRoZSBidWZmZXIgdG8gYmVjb21lIHRoZSBmcm9udCB0aWxlIHBhbmVcblx0XHRiZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0Ymcuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPSAnJztcblxuXHRcdC8vIHN3aXRjaCBvdXQgdGhlIGN1cnJlbnQgbGF5ZXIgdG8gYmUgdGhlIG5ldyBiZyBsYXllciAoYW5kIHZpY2UtdmVyc2EpXG5cdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IGJnO1xuXHRcdGJnID0gdGhpcy5fYmdCdWZmZXIgPSBmcm9udDtcblxuXHRcdHRoaXMuX3N0b3BMb2FkaW5nSW1hZ2VzKGJnKTtcblxuXHRcdC8vcHJldmVudCBiZyBidWZmZXIgZnJvbSBjbGVhcmluZyByaWdodCBhZnRlciB6b29tXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2NsZWFyQmdCdWZmZXJUaW1lcik7XG5cdH0sXG5cblx0X2dldExvYWRlZFRpbGVzUGVyY2VudGFnZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlcyA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJyksXG5cdFx0ICAgIGksIGxlbiwgY291bnQgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICh0aWxlc1tpXS5jb21wbGV0ZSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY291bnQgLyBsZW47XG5cdH0sXG5cblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcblx0X3N0b3BMb2FkaW5nSW1hZ2VzOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSksXG5cdFx0ICAgIGksIGxlbiwgdGlsZTtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aWxlID0gdGlsZXNbaV07XG5cblx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IEwuVXRpbC5mYWxzZUZuO1xuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBMLlV0aWwuZmFsc2VGbjtcblx0XHRcdFx0dGlsZS5zcmMgPSBMLlV0aWwuZW1wdHlJbWFnZVVybDtcblxuXHRcdFx0XHR0aWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuXG4vKlxyXG4gKiBQcm92aWRlcyBMLk1hcCB3aXRoIGNvbnZlbmllbnQgc2hvcnRjdXRzIGZvciB1c2luZyBicm93c2VyIGdlb2xvY2F0aW9uIGZlYXR1cmVzLlxyXG4gKi9cclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdF9kZWZhdWx0TG9jYXRlT3B0aW9uczoge1xyXG5cdFx0d2F0Y2g6IGZhbHNlLFxyXG5cdFx0c2V0VmlldzogZmFsc2UsXHJcblx0XHRtYXhab29tOiBJbmZpbml0eSxcclxuXHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0bWF4aW11bUFnZTogMCxcclxuXHRcdGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uICgvKk9iamVjdCovIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHRoaXMuX2RlZmF1bHRMb2NhdGVPcHRpb25zLCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0XHRvbkVycm9yID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblxyXG5cdFx0ICAgIGxhdEFjY3VyYWN5ID0gMTgwICogcG9zLmNvb3Jkcy5hY2N1cmFjeSAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcyhMLkxhdExuZy5ERUdfVE9fUkFEICogbGF0KSxcclxuXHJcblx0XHQgICAgYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgICAgICBbbGF0IC0gbGF0QWNjdXJhY3ksIGxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgICAgIFtsYXQgKyBsYXRBY2N1cmFjeSwgbG5nICsgbG5nQWNjdXJhY3ldKSxcclxuXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IE1hdGgubWluKHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpLCBvcHRpb25zLm1heFpvb20pO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcblxuXG59KHdpbmRvdywgZG9jdW1lbnQpKTsiLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlRWFjaCcpLFxuICAgIGNyZWF0ZUZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jcmVhdGVGb3JFYWNoJyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gKiBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiIHByb3BlcnR5XG4gKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gKiAgIGNvbnNvbGUubG9nKG4pO1xuICogfSkudmFsdWUoKTtcbiAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24obiwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZS1rZXkgcGFpciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbnZhciBmb3JFYWNoID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2gsIGJhc2VFYWNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXJyYXlSZWR1Y2UnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VFYWNoJyksXG4gICAgY3JlYXRlUmVkdWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY3JlYXRlUmVkdWNlJyk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICogdmFsdWUuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBzb3J0QnlBbGxgLFxuICogYW5kIGBzb3J0QnlPcmRlcmBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbih0b3RhbCwgbikge1xuICogICByZXR1cm4gdG90YWwgKyBuO1xuICogfSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICogICByZXN1bHRba2V5XSA9IG4gKiAzO1xuICogICByZXR1cm4gcmVzdWx0O1xuICogfSwge30pO1xuICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbnZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2UsIGJhc2VFYWNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG4iLCIvKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29weShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUNvcHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWBcbiAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5hc3NpZ25gIGZvciBjdXN0b21pemluZyBhc3NpZ25lZCB2YWx1ZXMgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmBcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBhc3NpZ25XaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHx8XG4gICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25XaXRoO1xuIiwidmFyIGJhc2VDb3B5ID0gcmVxdWlyZSgnLi9iYXNlQ29weScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlID09IG51bGxcbiAgICA/IG9iamVjdFxuICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi9iaW5kQ2FsbGJhY2snKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvaWRlbnRpdHknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAqIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuICAgICAgPyBmdW5jXG4gICAgICA6IGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gIH1cbiAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgfVxuICByZXR1cm4gdGhpc0FyZyA9PT0gdW5kZWZpbmVkXG4gICAgPyBwcm9wZXJ0eShmdW5jKVxuICAgIDogYmFzZU1hdGNoZXNQcm9wZXJ0eShmdW5jLCB0aGlzQXJnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2FsbGJhY2s7XG4iLCJ2YXIgYXJyYXlDb3B5ID0gcmVxdWlyZSgnLi9hcnJheUNvcHknKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL2FycmF5RWFjaCcpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9iYXNlRm9yT3duJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID1cbmNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgYHZhbHVlYCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWc7XG5cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcbiAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lLlxuICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsIi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNvcHk7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9hcnJheVB1c2gnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIGFkZGVkIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nXG4gKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMtbGlrZSBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAoaXNTdHJpY3QgfHwgaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9ySW5gIGFuZCBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXNcbiAqIG92ZXIgYG9iamVjdGAgcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGludm9raW5nIGBpdGVyYXRlZWAgZm9yXG4gKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAqIHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL2Jhc2VGb3InKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9ySW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvckluO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi4vb2JqZWN0L2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIHBhdGhzXG4gKiBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aEtleV0gVGhlIGtleSByZXByZXNlbnRhdGlvbiBvZiBwYXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCwgcGF0aEtleSkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhdGhLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXRoS2V5IGluIHRvT2JqZWN0KG9iamVjdCkpIHtcbiAgICBwYXRoID0gW3BhdGhLZXldO1xuICB9XG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleCsrXV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNgIGJpbmRpbmdcbiAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vZXF1YWxPYmplY3RzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgIGlmIChvYmpUYWcgPT0gYXJnc1RhZykge1xuICAgICAgb2JqVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob3RoVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgIH1cbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgfVxuICBpZiAoIWlzTG9vc2UpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXIsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZXRlY3RpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBzZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNKTy5cbiAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gb2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gb3RoZXI7XG4gICAgfVxuICB9XG4gIC8vIEFkZCBgb2JqZWN0YCBhbmQgYG90aGVyYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gIHN0YWNrQi5wdXNoKG90aGVyKTtcblxuICB2YXIgcmVzdWx0ID0gKG9iaklzQXJyID8gZXF1YWxBcnJheXMgOiBlcXVhbE9iamVjdHMpKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXG4gIHN0YWNrQS5wb3AoKTtcbiAgc3RhY2tCLnBvcCgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9iYXNlSXNFcXVhbCcpLFxuICAgIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVyeSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgdHJ1ZSkgOiByZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9nZXRNYXRjaERhdGEnKSxcbiAgICB0b09iamVjdCA9IHJlcXVpcmUoJy4vdG9PYmplY3QnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2VzIG5vdCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHZhciBrZXkgPSBtYXRjaERhdGFbMF1bMF0sXG4gICAgICAgIHZhbHVlID0gbWF0Y2hEYXRhWzBdWzFdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gdmFsdWUgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiB0b09iamVjdChvYmplY3QpKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9iYXNlR2V0JyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL2Jhc2VJc0VxdWFsJyksXG4gICAgYmFzZVNsaWNlID0gcmVxdWlyZSgnLi9iYXNlU2xpY2UnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBsYXN0ID0gcmVxdWlyZSgnLi4vYXJyYXkvbGFzdCcpLFxuICAgIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpLFxuICAgIHRvUGF0aCA9IHJlcXVpcmUoJy4vdG9QYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkocGF0aCksXG4gICAgICBpc0NvbW1vbiA9IGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSksXG4gICAgICBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cbiAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIga2V5ID0gcGF0aEtleTtcbiAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgIGlmICgoaXNBcnIgfHwgIWlzQ29tbW9uKSAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGtleSA9IGxhc3QocGF0aCk7XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlXG4gICAgICA/IChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gb2JqZWN0KSlcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9iamVjdFtrZXldLCB1bmRlZmluZWQsIHRydWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9iYXNlR2V0JyksXG4gICAgdG9QYXRoID0gcmVxdWlyZSgnLi90b1BhdGgnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgdmFyIHBhdGhLZXkgPSAocGF0aCArICcnKTtcbiAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCwgcGF0aEtleSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICogdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEZyb21Db2xsZWN0aW9uIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudFxuICogIG9mIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21Db2xsZWN0aW9uLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRGcm9tQ29sbGVjdGlvblxuICAgICAgPyAoaW5pdEZyb21Db2xsZWN0aW9uID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNsaWNlO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBmb3IgYG51bGxgIG9yIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiAodmFsdWUgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vdXRpbGl0eS9pZGVudGl0eScpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHRoaXNBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG4gIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmRDYWxsYmFjaztcbiIsIi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWwuQXJyYXlCdWZmZXIsXG4gICAgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cbiAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyQ2xvbmU7XG4iLCJ2YXIgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi9iaW5kQ2FsbGJhY2snKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vaXNJdGVyYXRlZUNhbGwnKSxcbiAgICByZXN0UGFyYW0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9yZXN0UGFyYW0nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uYXNzaWduYCwgYF8uZGVmYXVsdHNgLCBvciBgXy5tZXJnZWAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgIGxlbmd0aCAtPSAoY3VzdG9taXplciA/IDEgOiAwKTtcbiAgICB9XG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBnZXRMZW5ndGggPSByZXF1aXJlKCcuL2dldExlbmd0aCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gdG9PYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2JpbmRDYWxsYmFjaycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckVhY2hgIG9yIGBfLmZvckVhY2hSaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGFycmF5RnVuYywgZWFjaEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgID8gYXJyYXlGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKVxuICAgICAgOiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVGb3JFYWNoO1xuIiwidmFyIGJhc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4vYmFzZUNhbGxiYWNrJyksXG4gICAgYmFzZVJlZHVjZSA9IHJlcXVpcmUoJy4vYmFzZVJlZHVjZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnJlZHVjZWAgb3IgYF8ucmVkdWNlUmlnaHRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGFycmF5RnVuYywgZWFjaEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgIHZhciBpbml0RnJvbUFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgID8gYXJyYXlGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSlcbiAgICAgIDogYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBiYXNlQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSwgZWFjaEZ1bmMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZHVjZTtcbiIsInZhciBhcnJheVNvbWUgPSByZXF1aXJlKCcuL2FycmF5U29tZScpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBhcnJheXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc0xvb3NlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF0sXG4gICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKGlzTG9vc2UgPyBvdGhWYWx1ZSA6IGFyclZhbHVlLCBpc0xvb3NlID8gYXJyVmFsdWUgOiBvdGhWYWx1ZSwgaW5kZXgpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChpc0xvb3NlKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCIvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAvLyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhcyBub3QgZXF1YWwuXG4gICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgcmV0dXJuIChvYmplY3QgIT0gK29iamVjdClcbiAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgOiBvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzIHByaW1pdGl2ZXMgYW5kIHN0cmluZ1xuICAgICAgLy8gb2JqZWN0cyBhcyBlcXVhbC4gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogb2JqVmFsdWUsIGlzTG9vc2U/IG9ialZhbHVlIDogb3RoVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSA6IHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmICghc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TGVuZ3RoO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vaXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgcGFpcnMgPSByZXF1aXJlKCcuLi9vYmplY3QvcGFpcnMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHBhaXJzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHJlc3VsdFtsZW5ndGhdWzJdID0gaXNTdHJpY3RDb21wYXJhYmxlKHJlc3VsdFtsZW5ndGhdWzFdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCIvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBidWZmZXJDbG9uZSA9IHJlcXVpcmUoJy4vYnVmZmVyQ2xvbmUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHZhciBidWZmZXIgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwiLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgIEN0b3IgPSBPYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG5ldyBDdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBnZXRMZW5ndGggPSByZXF1aXJlKCcuL2dldExlbmd0aCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkpIHtcbiAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXG5cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAoKHR5cGUgPT0gJ3N0cmluZycgJiYgcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSkgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIHJlc3VsdCB8fCAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gdG9PYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vdG9PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2Agd2hpY2ggcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBzcGVjaWZpZWRcbiAqIGJ5IGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHBpY2tCeUFycmF5KG9iamVjdCwgcHJvcHMpIHtcbiAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrQnlBcnJheTtcbiIsInZhciBiYXNlRm9ySW4gPSByZXF1aXJlKCcuL2Jhc2VGb3JJbicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5waWNrYCB3aGljaCBwaWNrcyBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgXG4gKiByZXR1cm5zIHRydXRoeSBmb3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgYmFzZUZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlja0J5Q2FsbGJhY2s7XG4iLCJ2YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICogb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gcHJvcHNMZW5ndGggJiYgb2JqZWN0Lmxlbmd0aDtcblxuICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hpbUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvT2JqZWN0O1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vYmFzZVRvU3RyaW5nJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXG5cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlVG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QYXRoO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDbG9uZScpLFxuICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2JpbmRDYWxsYmFjaycpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIGFyZSBjbG9uZWQsXG4gKiBvdGhlcndpc2UgdGhleSBhcmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQnc1xuICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdXAgdG8gdGhyZWUgYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pLlxuICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG4gKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKHVzZXJzKTtcbiAqIHNoYWxsb3dbMF0gPT09IHVzZXJzWzBdO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZSh1c2VycywgdHJ1ZSk7XG4gKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gKiB2YXIgZWwgPSBfLmNsb25lKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAqICAgfVxuICogfSk7XG4gKlxuICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAqIC8vID0+IGZhbHNlXG4gKiBlbC5ub2RlTmFtZVxuICogLy8gPT4gQk9EWVxuICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gKiAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgaWYgKGlzRGVlcCAmJiB0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyKSkge1xuICAgIGlzRGVlcCA9IGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBpc0RlZXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXNBcmcgPSBjdXN0b21pemVyO1xuICAgIGN1c3RvbWl6ZXIgPSBpc0RlZXA7XG4gICAgaXNEZWVwID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbidcbiAgICA/IGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMykpXG4gICAgOiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2dldE5hdGl2ZScpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VJc0VxdWFsJyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmluZENhbGxiYWNrJyk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0J3MgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAqIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2RcbiAqIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdXAgdG9cbiAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciBbLCBpbmRleHxrZXldKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAqIGFyZSAqKm5vdCoqIHN1cHBvcnRlZC4gUHJvdmlkZSBhIGN1c3RvbWl6ZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHN1cHBvcnRcbiAqIGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgZXFcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHZhbHVlIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogb2JqZWN0ID09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICpcbiAqIF8uaXNFcXVhbChhcnJheSwgb3RoZXIsIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICogICBpZiAoXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pKSB7XG4gKiAgICAgcmV0dXJuIHRydWU7XG4gKiAgIH1cbiAqIH0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gIHJldHVybiAgcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05hdGl2ZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCJ2YXIgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG50eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG4iLCJ2YXIgYXNzaWduV2l0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Fzc2lnbldpdGgnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUFzc2lnbicpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICogSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0J3MgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOlxuICogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QuYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGV4dGVuZFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICpcbiAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBvdGhlciA6IHZhbHVlO1xuICogfSk7XG4gKlxuICogZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gKi9cbnZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICByZXR1cm4gY3VzdG9taXplclxuICAgID8gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcilcbiAgICA6IGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2dldE5hdGl2ZScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBzaGltS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3NoaW1LZXlzJyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbnZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKSxcbiAgICB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiB0aGUga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCxcbiAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHBhaXJzKG9iamVjdCkge1xuICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFpcnM7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlRmxhdHRlbicpLFxuICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2JpbmRDYWxsYmFjaycpLFxuICAgIHBpY2tCeUFycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGlja0J5QXJyYXknKSxcbiAgICBwaWNrQnlDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BpY2tCeUNhbGxiYWNrJyksXG4gICAgcmVzdFBhcmFtID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vcmVzdFBhcmFtJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLiBQcm9wZXJ0eVxuICogbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAqIG5hbWVzLiBJZiBgcHJlZGljYXRlYCBpcyBwcm92aWRlZCBpdCdzIGludm9rZWQgZm9yIGVhY2ggcHJvcGVydHkgb2YgYG9iamVjdGBcbiAqIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbnwuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3ByZWRpY2F0ZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyXG4gKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsICd1c2VyJyk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBfLmlzU3RyaW5nKTtcbiAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICovXG52YXIgcGljayA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHByb3BzWzBdID09ICdmdW5jdGlvbidcbiAgICA/IHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMykpXG4gICAgOiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VGbGF0dGVuKHByb3BzKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGF0IGBwYXRoYCBvbiBhXG4gKiBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAyIH0gfSB9LFxuICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAxIH0gfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYi5jJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5wbHVjayhfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eShwYXRoKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVRvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG52YXIgaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIHByb3ZpZGVkIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICpcbiAqIF8udW5pcXVlSWQoKTtcbiAqIC8vID0+ICcxMDUnXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgcmV0dXJuIGJhc2VUb1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgncXVldWUnLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwucXVldWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICB2YXIgbm9hYm9ydCA9IHt9O1xuICB2YXIgc3VjY2VzcyA9IFtudWxsXTtcbiAgZnVuY3Rpb24gbmV3UXVldWUoY29uY3VycmVuY3kpIHtcbiAgICBpZiAoIShjb25jdXJyZW5jeSA+PSAxKSkgdGhyb3cgbmV3IEVycm9yO1xuXG4gICAgdmFyIHEsXG4gICAgICAgIHRhc2tzID0gW10sXG4gICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgd2FpdGluZyA9IDAsXG4gICAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICAgIGVuZGVkID0gMCxcbiAgICAgICAgc3RhcnRpbmcsIC8vIGluc2lkZSBhIHN5bmNocm9ub3VzIHRhc2sgY2FsbGJhY2s/XG4gICAgICAgIGVycm9yLFxuICAgICAgICBjYWxsYmFjayA9IG5vb3AsXG4gICAgICAgIGNhbGxiYWNrQWxsID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgaWYgKHN0YXJ0aW5nKSByZXR1cm47IC8vIGxldCB0aGUgY3VycmVudCB0YXNrIGNvbXBsZXRlXG4gICAgICB3aGlsZSAoc3RhcnRpbmcgPSB3YWl0aW5nICYmIGFjdGl2ZSA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIHZhciBpID0gZW5kZWQgKyBhY3RpdmUsXG4gICAgICAgICAgICB0ID0gdGFza3NbaV0sXG4gICAgICAgICAgICBqID0gdC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgYyA9IHRbal07XG4gICAgICAgIHRbal0gPSBlbmQoaSk7XG4gICAgICAgIC0td2FpdGluZywgKythY3RpdmUsIHRhc2tzW2ldID0gYy5hcHBseShudWxsLCB0KSB8fCBub2Fib3J0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZChpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSwgcikge1xuICAgICAgICBpZiAoIXRhc2tzW2ldKSB0aHJvdyBuZXcgRXJyb3I7IC8vIGRldGVjdCBtdWx0aXBsZSBjYWxsYmFja3NcbiAgICAgICAgLS1hY3RpdmUsICsrZW5kZWQsIHRhc2tzW2ldID0gbnVsbDtcbiAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHJldHVybjsgLy8gb25seSByZXBvcnQgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICBhYm9ydChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzW2ldID0gcjtcbiAgICAgICAgICBpZiAod2FpdGluZykgc3RhcnQoKTtcbiAgICAgICAgICBlbHNlIGlmICghYWN0aXZlKSBub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYm9ydChlKSB7XG4gICAgICBlcnJvciA9IGU7IC8vIGlnbm9yZSBuZXcgdGFza3MgYW5kIHNxdWVsY2ggYWN0aXZlIGNhbGxiYWNrc1xuICAgICAgd2FpdGluZyA9IE5hTjsgLy8gc3RvcCBxdWV1ZWQgdGFza3MgZnJvbSBzdGFydGluZ1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrQWxsKSBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgIGVsc2UgY2FsbGJhY2suYXBwbHkobnVsbCwgc3VjY2Vzcy5jb25jYXQocmVzdWx0cykpO1xuICAgIH1cblxuICAgIHJldHVybiBxID0ge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBub29wKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgICAgIHZhciB0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB0LnB1c2goZik7XG4gICAgICAgICsrd2FpdGluZywgdGFza3MucHVzaCh0KTtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpID0gZW5kZWQgKyBhY3RpdmUsIHQ7XG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSAodCA9IHRhc2tzW2ldKSAmJiB0LmFib3J0ICYmIHQuYWJvcnQoKTtcbiAgICAgICAgICBhYm9ydChuZXcgRXJyb3IoXCJhYm9ydFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBub29wKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgICAgIGNhbGxiYWNrID0gZiwgY2FsbGJhY2tBbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF3YWl0aW5nICYmICFhY3RpdmUpIG5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sXG4gICAgICBhd2FpdEFsbDogZnVuY3Rpb24oZikge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG5vb3ApIHRocm93IG5ldyBFcnJvcjtcbiAgICAgICAgY2FsbGJhY2sgPSBmLCBjYWxsYmFja0FsbCA9IHRydWU7XG4gICAgICAgIGlmICghd2FpdGluZyAmJiAhYWN0aXZlKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1ZXVlKGNvbmN1cnJlbmN5KSB7XG4gICAgcmV0dXJuIG5ld1F1ZXVlKGFyZ3VtZW50cy5sZW5ndGggPyArY29uY3VycmVuY3kgOiBJbmZpbml0eSk7XG4gIH1cblxuICBxdWV1ZS52ZXJzaW9uID0gXCIxLjIuMVwiO1xuXG4gIHJldHVybiBxdWV1ZTtcblxufSkpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVG9vbHRpcCA9IHJlcXVpcmUoJ3JjLXRvb2x0aXAnKTtcblxudmFyIF9yY1Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUb29sdGlwKTtcblxudmFyIEhhbmRsZSA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSGFuZGxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYW5kbGUocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFuZGxlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEhhbmRsZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Rvb2x0aXBWaXNpYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGFuZGxlLCBbe1xuICAgIGtleTogJ3Nob3dUb29sdGlwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd1Rvb2x0aXAoKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNUb29sdGlwVmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZVRvb2x0aXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1Rvb2x0aXBWaXNpYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgICB2YXIgdGlwVHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50aXBUcmFuc2l0aW9uTmFtZTtcbiAgICAgIHZhciB0aXBGb3JtYXR0ZXIgPSBwcm9wcy50aXBGb3JtYXR0ZXI7XG4gICAgICB2YXIgdmVydGljYWwgPSBwcm9wcy52ZXJ0aWNhbDtcbiAgICAgIHZhciBvZmZzZXQgPSBwcm9wcy5vZmZzZXQ7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgIHZhciBkcmFnZ2luZyA9IHByb3BzLmRyYWdnaW5nO1xuICAgICAgdmFyIG5vVGlwID0gcHJvcHMubm9UaXA7XG5cbiAgICAgIHZhciBzdHlsZSA9IHZlcnRpY2FsID8geyBib3R0b206IG9mZnNldCArICclJyB9IDogeyBsZWZ0OiBvZmZzZXQgKyAnJScgfTtcbiAgICAgIHZhciBoYW5kbGUgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvbk1vdXNlVXA6IHRoaXMuc2hvd1Rvb2x0aXAuYmluZCh0aGlzKSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLnNob3dUb29sdGlwLmJpbmQodGhpcyksXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oaWRlVG9vbHRpcC5iaW5kKHRoaXMpIH0pO1xuXG4gICAgICBpZiAobm9UaXApIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzVG9vbHRpcFZpc2libGUgPSBkcmFnZ2luZyB8fCB0aGlzLnN0YXRlLmlzVG9vbHRpcFZpc2libGU7XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9yY1Rvb2x0aXAyWydkZWZhdWx0J10sXG4gICAgICAgIHtcbiAgICAgICAgICBwcmVmaXhDbHM6IGNsYXNzTmFtZS5yZXBsYWNlKCdzbGlkZXItaGFuZGxlJywgJ3Rvb2x0aXAnKSxcbiAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAgIHZpc2libGU6IGlzVG9vbHRpcFZpc2libGUsXG4gICAgICAgICAgb3ZlcmxheTogX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGlwRm9ybWF0dGVyKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRpcFRyYW5zaXRpb25OYW1lIH0sXG4gICAgICAgIGhhbmRsZVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGFuZGxlO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEhhbmRsZTtcblxuSGFuZGxlLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgdmVydGljYWw6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgb2Zmc2V0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgdGlwVHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICB0aXBGb3JtYXR0ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgdmFsdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLFxuICBkcmFnZ2luZzogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBub1RpcDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgTWFya3MgPSBmdW5jdGlvbiBNYXJrcyhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcbiAgdmFyIHZlcnRpY2FsID0gX3JlZi52ZXJ0aWNhbDtcbiAgdmFyIG1hcmtzID0gX3JlZi5tYXJrcztcbiAgdmFyIGluY2x1ZGVkID0gX3JlZi5pbmNsdWRlZDtcbiAgdmFyIHVwcGVyQm91bmQgPSBfcmVmLnVwcGVyQm91bmQ7XG4gIHZhciBsb3dlckJvdW5kID0gX3JlZi5sb3dlckJvdW5kO1xuICB2YXIgbWF4ID0gX3JlZi5tYXg7XG4gIHZhciBtaW4gPSBfcmVmLm1pbjtcblxuICB2YXIgbWFya3NLZXlzID0gT2JqZWN0LmtleXMobWFya3MpO1xuICB2YXIgbWFya3NDb3VudCA9IG1hcmtzS2V5cy5sZW5ndGg7XG4gIHZhciB1bml0ID0gMTAwIC8gKG1hcmtzQ291bnQgLSAxKTtcbiAgdmFyIG1hcmtXaWR0aCA9IHVuaXQgKiAwLjk7XG5cbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICB2YXIgZWxlbWVudHMgPSBtYXJrc0tleXMubWFwKHBhcnNlRmxvYXQpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgX2NsYXNzTmFtZXM7XG5cbiAgICB2YXIgaXNBY3RpdmVkID0gIWluY2x1ZGVkICYmIHBvaW50ID09PSB1cHBlckJvdW5kIHx8IGluY2x1ZGVkICYmIHBvaW50IDw9IHVwcGVyQm91bmQgJiYgcG9pbnQgPj0gbG93ZXJCb3VuZDtcbiAgICB2YXIgbWFya0NsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgY2xhc3NOYW1lICsgJy10ZXh0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgY2xhc3NOYW1lICsgJy10ZXh0LWFjdGl2ZScsIGlzQWN0aXZlZCksIF9jbGFzc05hbWVzKSk7XG5cbiAgICB2YXIgYm90dG9tU3R5bGUgPSB7XG4gICAgICAvLyBoZWlnaHQ6IG1hcmtXaWR0aCArICclJyxcbiAgICAgIG1hcmdpbkJvdHRvbTogJy0yMDAnICsgJyUnLFxuICAgICAgYm90dG9tOiAocG9pbnQgLSBtaW4pIC8gcmFuZ2UgKiAxMDAgKyAnJSdcbiAgICB9O1xuXG4gICAgdmFyIGxlZnRTdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBtYXJrV2lkdGggKyAnJScsXG4gICAgICBtYXJnaW5MZWZ0OiAtbWFya1dpZHRoIC8gMiArICclJyxcbiAgICAgIGxlZnQ6IChwb2ludCAtIG1pbikgLyByYW5nZSAqIDEwMCArICclJ1xuICAgIH07XG5cbiAgICB2YXIgc3R5bGUgPSB2ZXJ0aWNhbCA/IGJvdHRvbVN0eWxlIDogbGVmdFN0eWxlO1xuXG4gICAgdmFyIG1hcmtQb2ludCA9IG1hcmtzW3BvaW50XTtcbiAgICB2YXIgbWFya1BvaW50SXNPYmplY3QgPSB0eXBlb2YgbWFya1BvaW50ID09PSAnb2JqZWN0JyAmJiAhX3JlYWN0MlsnZGVmYXVsdCddLmlzVmFsaWRFbGVtZW50KG1hcmtQb2ludCk7XG4gICAgdmFyIG1hcmtMYWJlbCA9IG1hcmtQb2ludElzT2JqZWN0ID8gbWFya1BvaW50LmxhYmVsIDogbWFya1BvaW50O1xuICAgIHZhciBtYXJrU3R5bGUgPSBtYXJrUG9pbnRJc09iamVjdCA/IF9leHRlbmRzKHt9LCBzdHlsZSwgbWFya1BvaW50LnN0eWxlKSA6IHN0eWxlO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdzcGFuJyxcbiAgICAgIHsgY2xhc3NOYW1lOiBtYXJrQ2xhc3NOYW1lLCBzdHlsZTogbWFya1N0eWxlLCBrZXk6IHBvaW50IH0sXG4gICAgICBtYXJrTGFiZWxcbiAgICApO1xuICB9KTtcblxuICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2RpdicsXG4gICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgIGVsZW1lbnRzXG4gICk7XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNYXJrcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVXRpbExpYkRvbUFkZEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdyYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgX3JjVXRpbExpYkRvbUFkZEV2ZW50TGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsTGliRG9tQWRkRXZlbnRMaXN0ZW5lcik7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX1RyYWNrID0gcmVxdWlyZSgnLi9UcmFjaycpO1xuXG52YXIgX1RyYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RyYWNrKTtcblxudmFyIF9IYW5kbGUgPSByZXF1aXJlKCcuL0hhbmRsZScpO1xuXG52YXIgX0hhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IYW5kbGUpO1xuXG52YXIgX1N0ZXBzID0gcmVxdWlyZSgnLi9TdGVwcycpO1xuXG52YXIgX1N0ZXBzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0ZXBzKTtcblxudmFyIF9NYXJrcyA9IHJlcXVpcmUoJy4vTWFya3MnKTtcblxudmFyIF9NYXJrczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXJrcyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc05vdFRvdWNoRXZlbnQoZSkge1xuICByZXR1cm4gZS50b3VjaGVzLmxlbmd0aCA+IDEgfHwgZS50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICd0b3VjaGVuZCcgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoUG9zaXRpb24odmVydGljYWwsIGUpIHtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLnRvdWNoZXNbMF0ucGFnZVg7XG59XG5cbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24odmVydGljYWwsIGUpIHtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZS5jbGllbnRZIDogZS5wYWdlWDtcbn1cblxuZnVuY3Rpb24gcGF1c2VFdmVudChlKSB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxudmFyIFNsaWRlciA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU2xpZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTbGlkZXIocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFNsaWRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIHZhciByYW5nZSA9IHByb3BzLnJhbmdlO1xuICAgIHZhciBtaW4gPSBwcm9wcy5taW47XG4gICAgdmFyIG1heCA9IHByb3BzLm1heDtcblxuICAgIHZhciBpbml0aWFsVmFsdWUgPSByYW5nZSA/IFttaW4sIG1pbl0gOiBtaW47XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9ICdkZWZhdWx0VmFsdWUnIGluIHByb3BzID8gcHJvcHMuZGVmYXVsdFZhbHVlIDogaW5pdGlhbFZhbHVlO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcblxuICAgIHZhciB1cHBlckJvdW5kID0gdW5kZWZpbmVkO1xuICAgIHZhciBsb3dlckJvdW5kID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wcy5yYW5nZSkge1xuICAgICAgbG93ZXJCb3VuZCA9IHRoaXMudHJpbUFsaWduVmFsdWUodmFsdWVbMF0pO1xuICAgICAgdXBwZXJCb3VuZCA9IHRoaXMudHJpbUFsaWduVmFsdWUodmFsdWVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cHBlckJvdW5kID0gdGhpcy50cmltQWxpZ25WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlY2VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcHMucmFuZ2UgJiYgdXBwZXJCb3VuZCA9PT0gbG93ZXJCb3VuZCkge1xuICAgICAgcmVjZW50ID0gbG93ZXJCb3VuZCA9PT0gbWF4ID8gJ2xvd2VyQm91bmQnIDogJ3VwcGVyQm91bmQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnQgPSAndXBwZXJCb3VuZCc7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhbmRsZTogbnVsbCxcbiAgICAgIHJlY2VudDogcmVjZW50LFxuICAgICAgdXBwZXJCb3VuZDogdXBwZXJCb3VuZCxcbiAgICAgIC8vIElmIFNsaWRlciBpcyBub3QgcmFuZ2UsIHNldCBgbG93ZXJCb3VuZGAgZXF1YWwgdG8gYG1pbmAuXG4gICAgICBsb3dlckJvdW5kOiBsb3dlckJvdW5kIHx8IG1pblxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMgfHwgJ21pbicgaW4gbmV4dFByb3BzIHx8ICdtYXgnIGluIG5leHRQcm9wcykpIHJldHVybjtcblxuICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgbG93ZXJCb3VuZCA9IF9zdGF0ZS5sb3dlckJvdW5kO1xuICAgICAgdmFyIHVwcGVyQm91bmQgPSBfc3RhdGUudXBwZXJCb3VuZDtcblxuICAgICAgaWYgKG5leHRQcm9wcy5yYW5nZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWUgfHwgW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdO1xuICAgICAgICB2YXIgbmV4dFVwcGVyQm91bmQgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHZhbHVlWzFdLCBuZXh0UHJvcHMpO1xuICAgICAgICB2YXIgbmV4dExvd2VyQm91bmQgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHZhbHVlWzBdLCBuZXh0UHJvcHMpO1xuICAgICAgICBpZiAobmV4dExvd2VyQm91bmQgPT09IGxvd2VyQm91bmQgJiYgbmV4dFVwcGVyQm91bmQgPT09IHVwcGVyQm91bmQpIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB1cHBlckJvdW5kOiBuZXh0VXBwZXJCb3VuZCxcbiAgICAgICAgICBsb3dlckJvdW5kOiBuZXh0TG93ZXJCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWx1ZU91dE9mQm91bmRzKHVwcGVyQm91bmQsIG5leHRQcm9wcykgfHwgdGhpcy5pc1ZhbHVlT3V0T2ZCb3VuZHMobG93ZXJCb3VuZCwgbmV4dFByb3BzKSkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoW25leHRMb3dlckJvdW5kLCBuZXh0VXBwZXJCb3VuZF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCA/IG5leHRQcm9wcy52YWx1ZSA6IHVwcGVyQm91bmQ7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSB0aGlzLnRyaW1BbGlnblZhbHVlKHZhbHVlLCBuZXh0UHJvcHMpO1xuICAgICAgICBpZiAobmV4dFZhbHVlID09PSB1cHBlckJvdW5kICYmIGxvd2VyQm91bmQgPT09IG5leHRQcm9wcy5taW4pIHJldHVybjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB1cHBlckJvdW5kOiBuZXh0VmFsdWUsXG4gICAgICAgICAgbG93ZXJCb3VuZDogbmV4dFByb3BzLm1pblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWx1ZU91dE9mQm91bmRzKHVwcGVyQm91bmQsIG5leHRQcm9wcykpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKHN0YXRlKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGlzTm90Q29udHJvbGxlZCA9ICEoJ3ZhbHVlJyBpbiBwcm9wcyk7XG4gICAgICBpZiAoaXNOb3RDb250cm9sbGVkKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oYW5kbGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhhbmRsZTogc3RhdGUuaGFuZGxlIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCB0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gICAgICB2YXIgY2hhbmdlZFZhbHVlID0gcHJvcHMucmFuZ2UgPyBbZGF0YS5sb3dlckJvdW5kLCBkYXRhLnVwcGVyQm91bmRdIDogZGF0YS51cHBlckJvdW5kO1xuICAgICAgcHJvcHMub25DaGFuZ2UoY2hhbmdlZFZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1vdXNlTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldE1vdXNlUG9zaXRpb24odGhpcy5wcm9wcy52ZXJ0aWNhbCwgZSk7XG4gICAgICB0aGlzLm9uTW92ZShlLCBwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Ub3VjaE1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgICBpZiAoaXNOb3RUb3VjaEV2ZW50KGUpKSB7XG4gICAgICAgIHRoaXMuZW5kKCd0b3VjaCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldFRvdWNoUG9zaXRpb24odGhpcy5wcm9wcy52ZXJ0aWNhbCwgZSk7XG4gICAgICB0aGlzLm9uTW92ZShlLCBwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3ZlKGUsIHBvc2l0aW9uKSB7XG4gICAgICBwYXVzZUV2ZW50KGUpO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIHZhciBkaWZmUG9zaXRpb24gPSBwb3NpdGlvbiAtIHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIGRpZmZQb3NpdGlvbiA9IHRoaXMucHJvcHMudmVydGljYWwgPyAtZGlmZlBvc2l0aW9uIDogZGlmZlBvc2l0aW9uO1xuICAgICAgdmFyIGRpZmZWYWx1ZSA9IGRpZmZQb3NpdGlvbiAvIHRoaXMuZ2V0U2xpZGVyTGVuZ3RoKCkgKiAocHJvcHMubWF4IC0gcHJvcHMubWluKTtcblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy50cmltQWxpZ25WYWx1ZSh0aGlzLnN0YXJ0VmFsdWUgKyBkaWZmVmFsdWUpO1xuICAgICAgdmFyIG9sZFZhbHVlID0gc3RhdGVbc3RhdGUuaGFuZGxlXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcblxuICAgICAgaWYgKHByb3BzLmFsbG93Q3Jvc3MgJiYgdmFsdWUgPCBzdGF0ZS5sb3dlckJvdW5kICYmIHN0YXRlLmhhbmRsZSA9PT0gJ3VwcGVyQm91bmQnKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2Uoe1xuICAgICAgICAgIGhhbmRsZTogJ2xvd2VyQm91bmQnLFxuICAgICAgICAgIGxvd2VyQm91bmQ6IHZhbHVlLFxuICAgICAgICAgIHVwcGVyQm91bmQ6IHRoaXMuc3RhdGUubG93ZXJCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmFsbG93Q3Jvc3MgJiYgdmFsdWUgPiBzdGF0ZS51cHBlckJvdW5kICYmIHN0YXRlLmhhbmRsZSA9PT0gJ2xvd2VyQm91bmQnKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2Uoe1xuICAgICAgICAgIGhhbmRsZTogJ3VwcGVyQm91bmQnLFxuICAgICAgICAgIHVwcGVyQm91bmQ6IHZhbHVlLFxuICAgICAgICAgIGxvd2VyQm91bmQ6IHRoaXMuc3RhdGUudXBwZXJCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uQ2hhbmdlKF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3RhdGUuaGFuZGxlLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uVG91Y2hTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoaXNOb3RUb3VjaEV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldFRvdWNoUG9zaXRpb24odGhpcy5wcm9wcy52ZXJ0aWNhbCwgZSk7XG4gICAgICB0aGlzLm9uU3RhcnQocG9zaXRpb24pO1xuICAgICAgdGhpcy5hZGREb2N1bWVudEV2ZW50cygndG91Y2gnKTtcbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBpZiAoZS5idXR0b24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0TW91c2VQb3NpdGlvbih0aGlzLnByb3BzLnZlcnRpY2FsLCBlKTtcbiAgICAgIHRoaXMub25TdGFydChwb3NpdGlvbik7XG4gICAgICB0aGlzLmFkZERvY3VtZW50RXZlbnRzKCdtb3VzZScpO1xuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblN0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdGFydChwb3NpdGlvbikge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHByb3BzLm9uQmVmb3JlQ2hhbmdlKHRoaXMuZ2V0VmFsdWUoKSk7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsY1ZhbHVlQnlQb3MocG9zaXRpb24pO1xuICAgICAgdGhpcy5zdGFydFZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciB1cHBlckJvdW5kID0gc3RhdGUudXBwZXJCb3VuZDtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gc3RhdGUubG93ZXJCb3VuZDtcblxuICAgICAgdmFyIHZhbHVlTmVlZENoYW5naW5nID0gJ3VwcGVyQm91bmQnO1xuICAgICAgaWYgKHRoaXMucHJvcHMucmFuZ2UpIHtcbiAgICAgICAgdmFyIGlzTG93ZXJCb3VuZENsb3NlciA9IE1hdGguYWJzKHVwcGVyQm91bmQgLSB2YWx1ZSkgPiBNYXRoLmFicyhsb3dlckJvdW5kIC0gdmFsdWUpO1xuICAgICAgICBpZiAoaXNMb3dlckJvdW5kQ2xvc2VyKSB7XG4gICAgICAgICAgdmFsdWVOZWVkQ2hhbmdpbmcgPSAnbG93ZXJCb3VuZCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNBdFRoZVNhbWVQb2ludCA9IHVwcGVyQm91bmQgPT09IGxvd2VyQm91bmQ7XG4gICAgICAgIGlmIChpc0F0VGhlU2FtZVBvaW50KSB7XG4gICAgICAgICAgdmFsdWVOZWVkQ2hhbmdpbmcgPSBzdGF0ZS5yZWNlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBdFRoZVNhbWVQb2ludCAmJiB2YWx1ZSAhPT0gdXBwZXJCb3VuZCkge1xuICAgICAgICAgIHZhbHVlTmVlZENoYW5naW5nID0gdmFsdWUgPCB1cHBlckJvdW5kID8gJ2xvd2VyQm91bmQnIDogJ3VwcGVyQm91bmQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBoYW5kbGU6IHZhbHVlTmVlZENoYW5naW5nLFxuICAgICAgICByZWNlbnQ6IHZhbHVlTmVlZENoYW5naW5nXG4gICAgICB9KTtcblxuICAgICAgdmFyIG9sZFZhbHVlID0gc3RhdGVbdmFsdWVOZWVkQ2hhbmdpbmddO1xuICAgICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLm9uQ2hhbmdlKF9kZWZpbmVQcm9wZXJ0eSh7fSwgdmFsdWVOZWVkQ2hhbmdpbmcsIHZhbHVlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHZhciBfc3RhdGUyID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gX3N0YXRlMi5sb3dlckJvdW5kO1xuICAgICAgdmFyIHVwcGVyQm91bmQgPSBfc3RhdGUyLnVwcGVyQm91bmQ7XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnJhbmdlID8gW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdIDogdXBwZXJCb3VuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTbGlkZXJMZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTbGlkZXJMZW5ndGgoKSB7XG4gICAgICB2YXIgc2xpZGVyID0gdGhpcy5yZWZzLnNsaWRlcjtcbiAgICAgIGlmICghc2xpZGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy52ZXJ0aWNhbCA/IHNsaWRlci5jbGllbnRIZWlnaHQgOiBzbGlkZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2xpZGVyU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTbGlkZXJTdGFydCgpIHtcbiAgICAgIHZhciBzbGlkZXIgPSB0aGlzLnJlZnMuc2xpZGVyO1xuICAgICAgdmFyIHJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnZlcnRpY2FsID8gcmVjdC50b3AgOiByZWN0LmxlZnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJlY2lzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKHN0ZXApIHtcbiAgICAgIHZhciBzdGVwU3RyaW5nID0gc3RlcC50b1N0cmluZygpO1xuICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICBpZiAoc3RlcFN0cmluZy5pbmRleE9mKCcuJykgPj0gMCkge1xuICAgICAgICBwcmVjaXNpb24gPSBzdGVwU3RyaW5nLmxlbmd0aCAtIHN0ZXBTdHJpbmcuaW5kZXhPZignLicpIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVjaXNpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNWYWx1ZU91dE9mQm91bmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWx1ZU91dE9mQm91bmRzKHZhbHVlLCBwcm9wcykge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgcHJvcHMubWluIHx8IHZhbHVlID4gcHJvcHMubWF4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyaW1BbGlnblZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJpbUFsaWduVmFsdWUodiwgbmV4dFByb3BzKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgICAgdmFyIGhhbmRsZSA9IHN0YXRlLmhhbmRsZTtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gc3RhdGUubG93ZXJCb3VuZDtcbiAgICAgIHZhciB1cHBlckJvdW5kID0gc3RhdGUudXBwZXJCb3VuZDtcblxuICAgICAgdmFyIF9leHRlbmRzMiA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCBuZXh0UHJvcHMgfHwge30pO1xuXG4gICAgICB2YXIgbWFya3MgPSBfZXh0ZW5kczIubWFya3M7XG4gICAgICB2YXIgc3RlcCA9IF9leHRlbmRzMi5zdGVwO1xuICAgICAgdmFyIG1pbiA9IF9leHRlbmRzMi5taW47XG4gICAgICB2YXIgbWF4ID0gX2V4dGVuZHMyLm1heDtcbiAgICAgIHZhciBhbGxvd0Nyb3NzID0gX2V4dGVuZHMyLmFsbG93Q3Jvc3M7XG5cbiAgICAgIHZhciB2YWwgPSB2O1xuICAgICAgaWYgKHZhbCA8PSBtaW4pIHtcbiAgICAgICAgdmFsID0gbWluO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA+PSBtYXgpIHtcbiAgICAgICAgdmFsID0gbWF4O1xuICAgICAgfVxuICAgICAgaWYgKCFhbGxvd0Nyb3NzICYmIGhhbmRsZSA9PT0gJ3VwcGVyQm91bmQnICYmIHZhbCA8PSBsb3dlckJvdW5kKSB7XG4gICAgICAgIHZhbCA9IGxvd2VyQm91bmQ7XG4gICAgICB9XG4gICAgICBpZiAoIWFsbG93Q3Jvc3MgJiYgaGFuZGxlID09PSAnbG93ZXJCb3VuZCcgJiYgdmFsID49IHVwcGVyQm91bmQpIHtcbiAgICAgICAgdmFsID0gdXBwZXJCb3VuZDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50cyA9IE9iamVjdC5rZXlzKG1hcmtzKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgICBpZiAoc3RlcCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2xvc2VzdFN0ZXAgPSBNYXRoLnJvdW5kKHZhbCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgcG9pbnRzLnB1c2goY2xvc2VzdFN0ZXApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlmZnMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModmFsIC0gcG9pbnQpO1xuICAgICAgfSk7XG4gICAgICB2YXIgY2xvc2VzdFBvaW50ID0gcG9pbnRzW2RpZmZzLmluZGV4T2YoTWF0aC5taW4uYXBwbHkoTWF0aCwgZGlmZnMpKV07XG5cbiAgICAgIHJldHVybiBzdGVwICE9PSBudWxsID8gcGFyc2VGbG9hdChjbG9zZXN0UG9pbnQudG9GaXhlZCh0aGlzLmdldFByZWNpc2lvbihzdGVwKSkpIDogY2xvc2VzdFBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGNPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjT2Zmc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBtaW4gPSBfcHJvcHMubWluO1xuICAgICAgdmFyIG1heCA9IF9wcm9wcy5tYXg7XG5cbiAgICAgIHZhciByYXRpbyA9ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICAgIHJldHVybiByYXRpbyAqIDEwMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjVmFsdWUob2Zmc2V0KSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgdmVydGljYWwgPSBfcHJvcHMyLnZlcnRpY2FsO1xuICAgICAgdmFyIG1pbiA9IF9wcm9wczIubWluO1xuICAgICAgdmFyIG1heCA9IF9wcm9wczIubWF4O1xuXG4gICAgICB2YXIgcmF0aW8gPSBNYXRoLmFicyhvZmZzZXQgLyB0aGlzLmdldFNsaWRlckxlbmd0aCgpKTtcbiAgICAgIHZhciB2YWx1ZSA9IHZlcnRpY2FsID8gKDEgLSByYXRpbykgKiAobWF4IC0gbWluKSArIG1pbiA6IHJhdGlvICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY1ZhbHVlQnlQb3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjVmFsdWVCeVBvcyhwb3NpdGlvbikge1xuICAgICAgdmFyIHBpeGVsT2Zmc2V0ID0gcG9zaXRpb24gLSB0aGlzLmdldFNsaWRlclN0YXJ0KCk7XG4gICAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy50cmltQWxpZ25WYWx1ZSh0aGlzLmNhbGNWYWx1ZShwaXhlbE9mZnNldCkpO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGREb2N1bWVudEV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERvY3VtZW50RXZlbnRzKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIC8vIGp1c3Qgd29yayBmb3IgY2hyb21lIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQnJvd3NlclxuICAgICAgICB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIgPSAoMCwgX3JjVXRpbExpYkRvbUFkZEV2ZW50TGlzdGVuZXIyWydkZWZhdWx0J10pKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vblRvdWNoVXBMaXN0ZW5lciA9ICgwLCBfcmNVdGlsTGliRG9tQWRkRXZlbnRMaXN0ZW5lcjJbJ2RlZmF1bHQnXSkoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuZW5kLmJpbmQodGhpcywgJ3RvdWNoJykpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lciA9ICgwLCBfcmNVdGlsTGliRG9tQWRkRXZlbnRMaXN0ZW5lcjJbJ2RlZmF1bHQnXSkoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gKDAsIF9yY1V0aWxMaWJEb21BZGRFdmVudExpc3RlbmVyMlsnZGVmYXVsdCddKShkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLmVuZC5iaW5kKHRoaXMsICdtb3VzZScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudHModHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoTW92ZUxpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9uVG91Y2hVcExpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXBMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQodHlwZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudHModHlwZSk7XG4gICAgICB0aGlzLnByb3BzLm9uQWZ0ZXJDaGFuZ2UodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYW5kbGU6IG51bGwgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9jbGFzc05hbWVzO1xuXG4gICAgICB2YXIgX3N0YXRlMyA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgaGFuZGxlID0gX3N0YXRlMy5oYW5kbGU7XG4gICAgICB2YXIgdXBwZXJCb3VuZCA9IF9zdGF0ZTMudXBwZXJCb3VuZDtcbiAgICAgIHZhciBsb3dlckJvdW5kID0gX3N0YXRlMy5sb3dlckJvdW5kO1xuICAgICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IF9wcm9wczMuY2xhc3NOYW1lO1xuICAgICAgdmFyIHByZWZpeENscyA9IF9wcm9wczMucHJlZml4Q2xzO1xuICAgICAgdmFyIGRpc2FibGVkID0gX3Byb3BzMy5kaXNhYmxlZDtcbiAgICAgIHZhciB2ZXJ0aWNhbCA9IF9wcm9wczMudmVydGljYWw7XG4gICAgICB2YXIgZG90cyA9IF9wcm9wczMuZG90cztcbiAgICAgIHZhciBpbmNsdWRlZCA9IF9wcm9wczMuaW5jbHVkZWQ7XG4gICAgICB2YXIgcmFuZ2UgPSBfcHJvcHMzLnJhbmdlO1xuICAgICAgdmFyIHN0ZXAgPSBfcHJvcHMzLnN0ZXA7XG4gICAgICB2YXIgbWFya3MgPSBfcHJvcHMzLm1hcmtzO1xuICAgICAgdmFyIG1heCA9IF9wcm9wczMubWF4O1xuICAgICAgdmFyIG1pbiA9IF9wcm9wczMubWluO1xuICAgICAgdmFyIHRpcFRyYW5zaXRpb25OYW1lID0gX3Byb3BzMy50aXBUcmFuc2l0aW9uTmFtZTtcbiAgICAgIHZhciB0aXBGb3JtYXR0ZXIgPSBfcHJvcHMzLnRpcEZvcm1hdHRlcjtcbiAgICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wczMuY2hpbGRyZW47XG5cbiAgICAgIHZhciBjdXN0b21IYW5kbGUgPSB0aGlzLnByb3BzLmhhbmRsZTtcblxuICAgICAgdmFyIHVwcGVyT2Zmc2V0ID0gdGhpcy5jYWxjT2Zmc2V0KHVwcGVyQm91bmQpO1xuICAgICAgdmFyIGxvd2VyT2Zmc2V0ID0gdGhpcy5jYWxjT2Zmc2V0KGxvd2VyQm91bmQpO1xuXG4gICAgICB2YXIgaGFuZGxlQ2xhc3NOYW1lID0gcHJlZml4Q2xzICsgJy1oYW5kbGUnO1xuICAgICAgdmFyIGlzTm9UaXAgPSBzdGVwID09PSBudWxsIHx8IHRpcEZvcm1hdHRlciA9PT0gbnVsbDtcblxuICAgICAgdmFyIHVwcGVyID0gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGN1c3RvbUhhbmRsZSwgeyBjbGFzc05hbWU6IGhhbmRsZUNsYXNzTmFtZSxcbiAgICAgICAgbm9UaXA6IGlzTm9UaXAsIHRpcFRyYW5zaXRpb25OYW1lOiB0aXBUcmFuc2l0aW9uTmFtZSwgdGlwRm9ybWF0dGVyOiB0aXBGb3JtYXR0ZXIsXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbCwgb2Zmc2V0OiB1cHBlck9mZnNldCwgdmFsdWU6IHVwcGVyQm91bmQsIGRyYWdnaW5nOiBoYW5kbGUgPT09ICd1cHBlckJvdW5kJyB9KTtcblxuICAgICAgdmFyIGxvd2VyID0gbnVsbDtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBsb3dlciA9ICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjdXN0b21IYW5kbGUsIHsgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc05hbWUsXG4gICAgICAgICAgbm9UaXA6IGlzTm9UaXAsIHRpcFRyYW5zaXRpb25OYW1lOiB0aXBUcmFuc2l0aW9uTmFtZSwgdGlwRm9ybWF0dGVyOiB0aXBGb3JtYXR0ZXIsXG4gICAgICAgICAgdmVydGljYWw6IHZlcnRpY2FsLCBvZmZzZXQ6IGxvd2VyT2Zmc2V0LCB2YWx1ZTogbG93ZXJCb3VuZCwgZHJhZ2dpbmc6IGhhbmRsZSA9PT0gJ2xvd2VyQm91bmQnIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpZGVyQ2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKSgoX2NsYXNzTmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBwcmVmaXhDbHMsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIHByZWZpeENscyArICctZGlzYWJsZWQnLCBkaXNhYmxlZCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgY2xhc3NOYW1lLCAhIWNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgcHJlZml4Q2xzICsgJy12ZXJ0aWNhbCcsIHRoaXMucHJvcHMudmVydGljYWwpLCBfY2xhc3NOYW1lcykpO1xuICAgICAgdmFyIGlzSW5jbHVkZWQgPSBpbmNsdWRlZCB8fCByYW5nZTtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgcmVmOiAnc2xpZGVyJywgY2xhc3NOYW1lOiBzbGlkZXJDbGFzc05hbWUsXG4gICAgICAgICAgb25Ub3VjaFN0YXJ0OiBkaXNhYmxlZCA/IG5vb3AgOiB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgICAgIG9uTW91c2VEb3duOiBkaXNhYmxlZCA/IG5vb3AgOiB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykgfSxcbiAgICAgICAgdXBwZXIsXG4gICAgICAgIGxvd2VyLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfVHJhY2syWydkZWZhdWx0J10sIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRyYWNrJywgdmVydGljYWw6IHZlcnRpY2FsLCBpbmNsdWRlZDogaXNJbmNsdWRlZCxcbiAgICAgICAgICBvZmZzZXQ6IGxvd2VyT2Zmc2V0LCBsZW5ndGg6IHVwcGVyT2Zmc2V0IC0gbG93ZXJPZmZzZXQgfSksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TdGVwczJbJ2RlZmF1bHQnXSwgeyBwcmVmaXhDbHM6IHByZWZpeENscywgdmVydGljYWw6IHZlcnRpY2FsLCBtYXJrczogbWFya3MsIGRvdHM6IGRvdHMsIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgaW5jbHVkZWQ6IGlzSW5jbHVkZWQsIGxvd2VyQm91bmQ6IGxvd2VyQm91bmQsXG4gICAgICAgICAgdXBwZXJCb3VuZDogdXBwZXJCb3VuZCwgbWF4OiBtYXgsIG1pbjogbWluIH0pLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfTWFya3MyWydkZWZhdWx0J10sIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW1hcmsnLCB2ZXJ0aWNhbDogdmVydGljYWwsIG1hcmtzOiBtYXJrcyxcbiAgICAgICAgICBpbmNsdWRlZDogaXNJbmNsdWRlZCwgbG93ZXJCb3VuZDogbG93ZXJCb3VuZCxcbiAgICAgICAgICB1cHBlckJvdW5kOiB1cHBlckJvdW5kLCBtYXg6IG1heCwgbWluOiBtaW4gfSksXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGlkZXI7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuU2xpZGVyLnByb3BUeXBlcyA9IHtcbiAgbWluOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgbWF4OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgc3RlcDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsXG4gIGRlZmF1bHRWYWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLCBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIpXSksXG4gIHZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsIF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcildKSxcbiAgbWFya3M6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICBpbmNsdWRlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBjbGFzc05hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBwcmVmaXhDbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBkaXNhYmxlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnksXG4gIG9uQmVmb3JlQ2hhbmdlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2hhbmdlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQWZ0ZXJDaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgaGFuZGxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmVsZW1lbnQsXG4gIHRpcFRyYW5zaXRpb25OYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlwRm9ybWF0dGVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gIGRvdHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgcmFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgdmVydGljYWw6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgYWxsb3dDcm9zczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sXG59O1xuXG5TbGlkZXIuZGVmYXVsdFByb3BzID0ge1xuICBwcmVmaXhDbHM6ICdyYy1zbGlkZXInLFxuICBjbGFzc05hbWU6ICcnLFxuICB0aXBUcmFuc2l0aW9uTmFtZTogJycsXG4gIG1pbjogMCxcbiAgbWF4OiAxMDAsXG4gIHN0ZXA6IDEsXG4gIG1hcmtzOiB7fSxcbiAgaGFuZGxlOiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfSGFuZGxlMlsnZGVmYXVsdCddLCBudWxsKSxcbiAgb25CZWZvcmVDaGFuZ2U6IG5vb3AsXG4gIG9uQ2hhbmdlOiBub29wLFxuICBvbkFmdGVyQ2hhbmdlOiBub29wLFxuICB0aXBGb3JtYXR0ZXI6IGZ1bmN0aW9uIHRpcEZvcm1hdHRlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgaW5jbHVkZWQ6IHRydWUsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZG90czogZmFsc2UsXG4gIHJhbmdlOiBmYWxzZSxcbiAgdmVydGljYWw6IGZhbHNlLFxuICBhbGxvd0Nyb3NzOiB0cnVlXG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTbGlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBjYWxjUG9pbnRzKHZlcnRpY2FsLCBtYXJrcywgZG90cywgc3RlcCwgbWluLCBtYXgpIHtcbiAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShkb3RzID8gc3RlcCA+IDAgOiB0cnVlLCAnYFNsaWRlcltzdGVwXWAgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyIGluIG9yZGVyIHRvIG1ha2UgU2xpZGVyW2RvdHNdIHdvcmsuJyk7XG4gIHZhciBwb2ludHMgPSBPYmplY3Qua2V5cyhtYXJrcykubWFwKHBhcnNlRmxvYXQpO1xuICBpZiAoZG90cykge1xuICAgIGZvciAodmFyIGkgPSBtaW47IGkgPD0gbWF4OyBpID0gaSArIHN0ZXApIHtcbiAgICAgIGlmIChwb2ludHMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHBvaW50cy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufVxuXG52YXIgU3RlcHMgPSBmdW5jdGlvbiBTdGVwcyhfcmVmKSB7XG4gIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscztcbiAgdmFyIHZlcnRpY2FsID0gX3JlZi52ZXJ0aWNhbDtcbiAgdmFyIG1hcmtzID0gX3JlZi5tYXJrcztcbiAgdmFyIGRvdHMgPSBfcmVmLmRvdHM7XG4gIHZhciBzdGVwID0gX3JlZi5zdGVwO1xuICB2YXIgaW5jbHVkZWQgPSBfcmVmLmluY2x1ZGVkO1xuICB2YXIgbG93ZXJCb3VuZCA9IF9yZWYubG93ZXJCb3VuZDtcbiAgdmFyIHVwcGVyQm91bmQgPSBfcmVmLnVwcGVyQm91bmQ7XG4gIHZhciBtYXggPSBfcmVmLm1heDtcbiAgdmFyIG1pbiA9IF9yZWYubWluO1xuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgdmFyIGVsZW1lbnRzID0gY2FsY1BvaW50cyh2ZXJ0aWNhbCwgbWFya3MsIGRvdHMsIHN0ZXAsIG1pbiwgbWF4KS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIF9jbGFzc05hbWVzO1xuXG4gICAgdmFyIG9mZnNldCA9IE1hdGguYWJzKHBvaW50IC0gbWluKSAvIHJhbmdlICogMTAwICsgJyUnO1xuICAgIHZhciBzdHlsZSA9IHZlcnRpY2FsID8geyBib3R0b206IG9mZnNldCB9IDogeyBsZWZ0OiBvZmZzZXQgfTtcblxuICAgIHZhciBpc0FjdGl2ZWQgPSAhaW5jbHVkZWQgJiYgcG9pbnQgPT09IHVwcGVyQm91bmQgfHwgaW5jbHVkZWQgJiYgcG9pbnQgPD0gdXBwZXJCb3VuZCAmJiBwb2ludCA+PSBsb3dlckJvdW5kO1xuICAgIHZhciBwb2ludENsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgcHJlZml4Q2xzICsgJy1kb3QnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBwcmVmaXhDbHMgKyAnLWRvdC1hY3RpdmUnLCBpc0FjdGl2ZWQpLCBfY2xhc3NOYW1lcykpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBjbGFzc05hbWU6IHBvaW50Q2xhc3NOYW1lLCBzdHlsZTogc3R5bGUsIGtleTogcG9pbnQgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAnZGl2JyxcbiAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zdGVwJyB9LFxuICAgIGVsZW1lbnRzXG4gICk7XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdGVwcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgVHJhY2sgPSBmdW5jdGlvbiBUcmFjayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcbiAgdmFyIGluY2x1ZGVkID0gX3JlZi5pbmNsdWRlZDtcbiAgdmFyIHZlcnRpY2FsID0gX3JlZi52ZXJ0aWNhbDtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgbGVuZ3RoID0gX3JlZi5sZW5ndGg7XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIHZpc2liaWxpdHk6IGluY2x1ZGVkID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcbiAgfTtcbiAgaWYgKHZlcnRpY2FsKSB7XG4gICAgc3R5bGUuYm90dG9tID0gb2Zmc2V0ICsgJyUnO1xuICAgIHN0eWxlLmhlaWdodCA9IGxlbmd0aCArICclJztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5sZWZ0ID0gb2Zmc2V0ICsgJyUnO1xuICAgIHN0eWxlLndpZHRoID0gbGVuZ3RoICsgJyUnO1xuICB9XG4gIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlIH0pO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVHJhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9TbGlkZXInKTsiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3BsYWNlbWVudHMgPSByZXF1aXJlKCcuL3BsYWNlbWVudHMnKTtcblxudmFyIF9yY1RyaWdnZXIgPSByZXF1aXJlKCdyYy10cmlnZ2VyJyk7XG5cbnZhciBfcmNUcmlnZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVHJpZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBUb29sdGlwID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1Rvb2x0aXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRyaWdnZXI6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBkZWZhdWx0VmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBwbGFjZW1lbnQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRyYW5zaXRpb25OYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhbmltYXRpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIG9uVmlzaWJsZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFmdGVyVmlzaWJsZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG92ZXJsYXk6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubm9kZSwgX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmNdKS5pc1JlcXVpcmVkLFxuICAgIG92ZXJsYXlTdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb3ZlcmxheUNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtb3VzZUVudGVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1vdXNlTGVhdmVEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZ2V0VG9vbHRpcENvbnRhaW5lcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRlc3Ryb3lUb29sdGlwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgYWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGFycm93Q29udGVudDogX3JlYWN0LlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtdG9vbHRpcCcsXG4gICAgICBtb3VzZUVudGVyRGVsYXk6IDAsXG4gICAgICBkZXN0cm95VG9vbHRpcE9uSGlkZTogZmFsc2UsXG4gICAgICBtb3VzZUxlYXZlRGVsYXk6IDAuMSxcbiAgICAgIGFsaWduOiB7fSxcbiAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICAgIHRyaWdnZXI6IFsnaG92ZXInXSxcbiAgICAgIGFycm93Q29udGVudDogbnVsbFxuICAgIH07XG4gIH0sXG4gIGdldFBvcHVwRWxlbWVudDogZnVuY3Rpb24gZ2V0UG9wdXBFbGVtZW50KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhcnJvd0NvbnRlbnQgPSBfcHJvcHMuYXJyb3dDb250ZW50O1xuICAgIHZhciBvdmVybGF5ID0gX3Byb3BzLm92ZXJsYXk7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wcy5wcmVmaXhDbHM7XG5cbiAgICByZXR1cm4gW19yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWFycm93Jywga2V5OiAnYXJyb3cnIH0sXG4gICAgICBhcnJvd0NvbnRlbnRcbiAgICApLCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pbm5lcicsIGtleTogJ2NvbnRlbnQnIH0sXG4gICAgICB0eXBlb2Ygb3ZlcmxheSA9PT0gJ2Z1bmN0aW9uJyA/IG92ZXJsYXkoKSA6IG92ZXJsYXlcbiAgICApXTtcbiAgfSxcbiAgZ2V0UG9wdXBEb21Ob2RlOiBmdW5jdGlvbiBnZXRQb3B1cERvbU5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmcy50cmlnZ2VyLmdldFBvcHVwRG9tTm9kZSgpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG92ZXJsYXlDbGFzc05hbWUgPSBfcHJvcHMyLm92ZXJsYXlDbGFzc05hbWU7XG4gICAgdmFyIHRyaWdnZXIgPSBfcHJvcHMyLnRyaWdnZXI7XG4gICAgdmFyIG1vdXNlRW50ZXJEZWxheSA9IF9wcm9wczIubW91c2VFbnRlckRlbGF5O1xuICAgIHZhciBtb3VzZUxlYXZlRGVsYXkgPSBfcHJvcHMyLm1vdXNlTGVhdmVEZWxheTtcbiAgICB2YXIgb3ZlcmxheVN0eWxlID0gX3Byb3BzMi5vdmVybGF5U3R5bGU7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczIucHJlZml4Q2xzO1xuICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW47XG4gICAgdmFyIG9uVmlzaWJsZUNoYW5nZSA9IF9wcm9wczIub25WaXNpYmxlQ2hhbmdlO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IF9wcm9wczIudHJhbnNpdGlvbk5hbWU7XG4gICAgdmFyIGFuaW1hdGlvbiA9IF9wcm9wczIuYW5pbWF0aW9uO1xuICAgIHZhciBwbGFjZW1lbnQgPSBfcHJvcHMyLnBsYWNlbWVudDtcbiAgICB2YXIgYWxpZ24gPSBfcHJvcHMyLmFsaWduO1xuICAgIHZhciBkZXN0cm95VG9vbHRpcE9uSGlkZSA9IF9wcm9wczIuZGVzdHJveVRvb2x0aXBPbkhpZGU7XG4gICAgdmFyIGRlZmF1bHRWaXNpYmxlID0gX3Byb3BzMi5kZWZhdWx0VmlzaWJsZTtcbiAgICB2YXIgZ2V0VG9vbHRpcENvbnRhaW5lciA9IF9wcm9wczIuZ2V0VG9vbHRpcENvbnRhaW5lcjtcblxuICAgIHZhciByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMiwgWydvdmVybGF5Q2xhc3NOYW1lJywgJ3RyaWdnZXInLCAnbW91c2VFbnRlckRlbGF5JywgJ21vdXNlTGVhdmVEZWxheScsICdvdmVybGF5U3R5bGUnLCAncHJlZml4Q2xzJywgJ2NoaWxkcmVuJywgJ29uVmlzaWJsZUNoYW5nZScsICd0cmFuc2l0aW9uTmFtZScsICdhbmltYXRpb24nLCAncGxhY2VtZW50JywgJ2FsaWduJywgJ2Rlc3Ryb3lUb29sdGlwT25IaWRlJywgJ2RlZmF1bHRWaXNpYmxlJywgJ2dldFRvb2x0aXBDb250YWluZXInXSk7XG5cbiAgICB2YXIgZXh0cmFQcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0UHJvcHMpO1xuICAgIGlmICgndmlzaWJsZScgaW4gdGhpcy5wcm9wcykge1xuICAgICAgZXh0cmFQcm9wcy5wb3B1cFZpc2libGUgPSB0aGlzLnByb3BzLnZpc2libGU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjVHJpZ2dlcjJbXCJkZWZhdWx0XCJdLFxuICAgICAgX2V4dGVuZHMoe1xuICAgICAgICBwb3B1cENsYXNzTmFtZTogb3ZlcmxheUNsYXNzTmFtZSxcbiAgICAgICAgcmVmOiAndHJpZ2dlcicsXG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICBwb3B1cDogdGhpcy5nZXRQb3B1cEVsZW1lbnQsXG4gICAgICAgIGFjdGlvbjogdHJpZ2dlcixcbiAgICAgICAgYnVpbHRpblBsYWNlbWVudHM6IF9wbGFjZW1lbnRzLnBsYWNlbWVudHMsXG4gICAgICAgIHBvcHVwUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIHBvcHVwQWxpZ246IGFsaWduLFxuICAgICAgICBnZXRQb3B1cENvbnRhaW5lcjogZ2V0VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IG9uVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIHBvcHVwQW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgIGRlZmF1bHRQb3B1cFZpc2libGU6IGRlZmF1bHRWaXNpYmxlLFxuICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IGRlc3Ryb3lUb29sdGlwT25IaWRlLFxuICAgICAgICBtb3VzZUxlYXZlRGVsYXk6IG1vdXNlTGVhdmVEZWxheSxcbiAgICAgICAgcG9wdXBTdHlsZTogb3ZlcmxheVN0eWxlLFxuICAgICAgICBtb3VzZUVudGVyRGVsYXk6IG1vdXNlRW50ZXJEZWxheVxuICAgICAgfSwgZXh0cmFQcm9wcyksXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRvb2x0aXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Ub29sdGlwJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGF1dG9BZGp1c3RPdmVyZmxvdyA9IHtcbiAgYWRqdXN0WDogMSxcbiAgYWRqdXN0WTogMVxufTtcblxudmFyIHRhcmdldE9mZnNldCA9IFswLCAwXTtcblxudmFyIHBsYWNlbWVudHMgPSBleHBvcnRzLnBsYWNlbWVudHMgPSB7XG4gIGxlZnQ6IHtcbiAgICBwb2ludHM6IFsnY3InLCAnY2wnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWy00LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICByaWdodDoge1xuICAgIHBvaW50czogWydjbCcsICdjciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wOiB7XG4gICAgcG9pbnRzOiBbJ2JjJywgJ3RjJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgcG9pbnRzOiBbJ3RjJywgJ2JjJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCA0XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICB0b3BMZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgbGVmdFRvcDoge1xuICAgIHBvaW50czogWyd0cicsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbLTQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHRvcFJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ2JyJywgJ3RyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgcmlnaHRUb3A6IHtcbiAgICBwb2ludHM6IFsndGwnLCAndHInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbVJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ3RyJywgJ2JyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCA0XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICByaWdodEJvdHRvbToge1xuICAgIHBvaW50czogWydibCcsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgbGVmdEJvdHRvbToge1xuICAgIHBvaW50czogWydicicsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbLTQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGxhY2VtZW50czsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIExhenlSZW5kZXJCb3ggPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTGF6eVJlbmRlckJveCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGhpZGRlbkNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIG5leHRQcm9wcy5oaWRkZW5DbGFzc05hbWUgfHwgbmV4dFByb3BzLnZpc2libGU7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBoaWRkZW5DbGFzc05hbWUgPSBfcHJvcHMuaGlkZGVuQ2xhc3NOYW1lO1xuICAgIHZhciB2aXNpYmxlID0gX3Byb3BzLnZpc2libGU7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2hpZGRlbkNsYXNzTmFtZScsICd2aXNpYmxlJ10pO1xuXG4gICAgaWYgKGhpZGRlbkNsYXNzTmFtZSB8fCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAxKSB7XG4gICAgICBpZiAoIXZpc2libGUgJiYgaGlkZGVuQ2xhc3NOYW1lKSB7XG4gICAgICAgIHByb3BzLmNsYXNzTmFtZSArPSAnICcgKyBoaWRkZW5DbGFzc05hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnZGl2JywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KHByb3BzLmNoaWxkcmVuKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTGF6eVJlbmRlckJveDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjQWxpZ24gPSByZXF1aXJlKCdyYy1hbGlnbicpO1xuXG52YXIgX3JjQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbGlnbik7XG5cbnZhciBfcmNBbmltYXRlID0gcmVxdWlyZSgncmMtYW5pbWF0ZScpO1xuXG52YXIgX3JjQW5pbWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FuaW1hdGUpO1xuXG52YXIgX1BvcHVwSW5uZXIgPSByZXF1aXJlKCcuL1BvcHVwSW5uZXInKTtcblxudmFyIF9Qb3B1cElubmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwSW5uZXIpO1xuXG52YXIgX0xhenlSZW5kZXJCb3ggPSByZXF1aXJlKCcuL0xhenlSZW5kZXJCb3gnKTtcblxudmFyIF9MYXp5UmVuZGVyQm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhenlSZW5kZXJCb3gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFBvcHVwID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1BvcHVwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGdldENsYXNzTmFtZUZyb21BbGlnbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBnZXRSb290RG9tTm9kZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VFbnRlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBkZXN0cm95UG9wdXBPbkhpZGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5yb290Tm9kZSA9IHRoaXMuZ2V0UG9wdXBEb21Ob2RlKCk7XG4gIH0sXG4gIG9uQWxpZ246IGZ1bmN0aW9uIG9uQWxpZ24ocG9wdXBEb21Ob2RlLCBhbGlnbikge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFsaWduQ2xhc3NOYW1lID0gcHJvcHMuZ2V0Q2xhc3NOYW1lRnJvbUFsaWduKHByb3BzLmFsaWduKTtcbiAgICB2YXIgY3VycmVudEFsaWduQ2xhc3NOYW1lID0gcHJvcHMuZ2V0Q2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKTtcbiAgICBpZiAoYWxpZ25DbGFzc05hbWUgIT09IGN1cnJlbnRBbGlnbkNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5jdXJyZW50QWxpZ25DbGFzc05hbWUgPSBjdXJyZW50QWxpZ25DbGFzc05hbWU7XG4gICAgICBwb3B1cERvbU5vZGUuY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUoY3VycmVudEFsaWduQ2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcHJvcHMub25BbGlnbihwb3B1cERvbU5vZGUsIGFsaWduKTtcbiAgfSxcbiAgZ2V0UG9wdXBEb21Ob2RlOiBmdW5jdGlvbiBnZXRQb3B1cERvbU5vZGUoKSB7XG4gICAgcmV0dXJuIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMucmVmcy5wb3B1cCk7XG4gIH0sXG4gIGdldFRhcmdldDogZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmdldFJvb3REb21Ob2RlKCk7XG4gIH0sXG4gIGdldE1hc2tUcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0TWFza1RyYW5zaXRpb25OYW1lKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMubWFza1RyYW5zaXRpb25OYW1lO1xuICAgIHZhciBhbmltYXRpb24gPSBwcm9wcy5tYXNrQW5pbWF0aW9uO1xuICAgIGlmICghdHJhbnNpdGlvbk5hbWUgJiYgYW5pbWF0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnByZWZpeENscyArICctJyArIGFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25OYW1lO1xuICB9LFxuICBnZXRUcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbk5hbWUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50cmFuc2l0aW9uTmFtZTtcbiAgICBpZiAoIXRyYW5zaXRpb25OYW1lICYmIHByb3BzLmFuaW1hdGlvbikge1xuICAgICAgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5wcmVmaXhDbHMgKyAnLScgKyBwcm9wcy5hbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9uTmFtZTtcbiAgfSxcbiAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbiBnZXRDbGFzc05hbWUoY3VycmVudEFsaWduQ2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucHJlZml4Q2xzICsgJyAnICsgdGhpcy5wcm9wcy5jbGFzc05hbWUgKyAnICcgKyBjdXJyZW50QWxpZ25DbGFzc05hbWU7XG4gIH0sXG4gIGdldFBvcHVwRWxlbWVudDogZnVuY3Rpb24gZ2V0UG9wdXBFbGVtZW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGU7XG4gICAgdmFyIHZpc2libGUgPSBwcm9wcy52aXNpYmxlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIGRlc3Ryb3lQb3B1cE9uSGlkZSA9IHByb3BzLmRlc3Ryb3lQb3B1cE9uSGlkZTtcblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZSh0aGlzLmN1cnJlbnRBbGlnbkNsYXNzTmFtZSB8fCBwcm9wcy5nZXRDbGFzc05hbWVGcm9tQWxpZ24oYWxpZ24pKTtcbiAgICB2YXIgaGlkZGVuQ2xhc3NOYW1lID0gcHJlZml4Q2xzICsgJy1oaWRkZW4nO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgdGhpcy5jdXJyZW50QWxpZ25DbGFzc05hbWUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbmV3U3R5bGUgPSBfZXh0ZW5kcyh7fSwgc3R5bGUsIHRoaXMuZ2V0WkluZGV4U3R5bGUoKSk7XG4gICAgdmFyIHBvcHVwSW5uZXJQcm9wcyA9IHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICByZWY6ICdwb3B1cCcsXG4gICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgIG9uTW91c2VMZWF2ZTogcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgc3R5bGU6IG5ld1N0eWxlXG4gICAgfTtcbiAgICBpZiAoZGVzdHJveVBvcHVwT25IaWRlKSB7XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgX3JjQW5pbWF0ZTJbXCJkZWZhdWx0XCJdLFxuICAgICAgICB7XG4gICAgICAgICAgY29tcG9uZW50OiAnJyxcbiAgICAgICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogdHJ1ZSxcbiAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogdGhpcy5nZXRUcmFuc2l0aW9uTmFtZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGUgPyBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9yY0FsaWduMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldFRhcmdldCxcbiAgICAgICAgICAgIGtleTogJ3BvcHVwJyxcbiAgICAgICAgICAgIHJlZjogdGhpcy5zYXZlQWxpZ24sXG4gICAgICAgICAgICBtb25pdG9yV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgb25BbGlnbjogdGhpcy5vbkFsaWduXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX1BvcHVwSW5uZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSwgcG9wdXBJbm5lclByb3BzKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgKVxuICAgICAgICApIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNBbmltYXRlMltcImRlZmF1bHRcIl0sXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgICAgc2hvd1Byb3A6ICd4VmlzaWJsZSdcbiAgICAgIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICB7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldFRhcmdldCxcbiAgICAgICAgICBrZXk6ICdwb3B1cCcsXG4gICAgICAgICAgcmVmOiB0aGlzLnNhdmVBbGlnbixcbiAgICAgICAgICBtb25pdG9yV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgIHhWaXNpYmxlOiB2aXNpYmxlLFxuICAgICAgICAgIGNoaWxkcmVuUHJvcHM6IHsgdmlzaWJsZTogJ3hWaXNpYmxlJyB9LFxuICAgICAgICAgIGRpc2FibGVkOiAhdmlzaWJsZSxcbiAgICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgICAgb25BbGlnbjogdGhpcy5vbkFsaWduXG4gICAgICAgIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX1BvcHVwSW5uZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBoaWRkZW5DbGFzc05hbWU6IGhpZGRlbkNsYXNzTmFtZVxuICAgICAgICAgIH0sIHBvcHVwSW5uZXJQcm9wcyksXG4gICAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG4gIGdldFpJbmRleFN0eWxlOiBmdW5jdGlvbiBnZXRaSW5kZXhTdHlsZSgpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy56SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGUuekluZGV4ID0gcHJvcHMuekluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIGdldE1hc2tFbGVtZW50OiBmdW5jdGlvbiBnZXRNYXNrRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBtYXNrRWxlbWVudCA9IHZvaWQgMDtcbiAgICBpZiAocHJvcHMubWFzaykge1xuICAgICAgdmFyIG1hc2tUcmFuc2l0aW9uID0gdGhpcy5nZXRNYXNrVHJhbnNpdGlvbk5hbWUoKTtcbiAgICAgIG1hc2tFbGVtZW50ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF6eVJlbmRlckJveDJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLmdldFpJbmRleFN0eWxlKCksXG4gICAgICAgIGtleTogJ21hc2snLFxuICAgICAgICBjbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctbWFzaycsXG4gICAgICAgIGhpZGRlbkNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1tYXNrLWhpZGRlbicsXG4gICAgICAgIHZpc2libGU6IHByb3BzLnZpc2libGVcbiAgICAgIH0pO1xuICAgICAgaWYgKG1hc2tUcmFuc2l0aW9uKSB7XG4gICAgICAgIG1hc2tFbGVtZW50ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNBbmltYXRlMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnbWFzaycsXG4gICAgICAgICAgICBzaG93UHJvcDogJ3Zpc2libGUnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogbWFza1RyYW5zaXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hc2tFbGVtZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrRWxlbWVudDtcbiAgfSxcbiAgc2F2ZUFsaWduOiBmdW5jdGlvbiBzYXZlQWxpZ24oYWxpZ24pIHtcbiAgICB0aGlzLmFsaWduSW5zdGFuY2UgPSBhbGlnbjtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmdldE1hc2tFbGVtZW50KCksXG4gICAgICB0aGlzLmdldFBvcHVwRWxlbWVudCgpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9MYXp5UmVuZGVyQm94ID0gcmVxdWlyZSgnLi9MYXp5UmVuZGVyQm94Jyk7XG5cbnZhciBfTGF6eVJlbmRlckJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYXp5UmVuZGVyQm94KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBQb3B1cElubmVyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1BvcHVwSW5uZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGhpZGRlbkNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uTW91c2VFbnRlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgaWYgKCFwcm9wcy52aXNpYmxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gJyAnICsgcHJvcHMuaGlkZGVuQ2xhc3NOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgICBzdHlsZTogcHJvcHMuc3R5bGVcbiAgICAgIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfTGF6eVJlbmRlckJveDJbXCJkZWZhdWx0XCJdLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1jb250ZW50JywgdmlzaWJsZTogcHJvcHMudmlzaWJsZSB9LFxuICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvcHVwSW5uZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uID0gcmVxdWlyZSgncmMtdXRpbC9saWIvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uJyk7XG5cbnZhciBfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNoYWluZWRGdW5jdGlvbik7XG5cbnZhciBfY29udGFpbnMgPSByZXF1aXJlKCdyYy11dGlsL2xpYi9Eb20vY29udGFpbnMnKTtcblxudmFyIF9jb250YWluczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250YWlucyk7XG5cbnZhciBfYWRkRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ3JjLXV0aWwvbGliL0RvbS9hZGRFdmVudExpc3RlbmVyJyk7XG5cbnZhciBfYWRkRXZlbnRMaXN0ZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRFdmVudExpc3RlbmVyKTtcblxudmFyIF9Qb3B1cCA9IHJlcXVpcmUoJy4vUG9wdXAnKTtcblxudmFyIF9Qb3B1cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gcmV0dXJuRW1wdHlTdHJpbmcoKSB7XG4gIHJldHVybiAnJztcbn1cblxudmFyIEFMTF9IQU5ETEVSUyA9IFsnb25DbGljaycsICdvbk1vdXNlRG93bicsICdvblRvdWNoU3RhcnQnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZScsICdvbkZvY3VzJywgJ29uQmx1ciddO1xuXG52YXIgVHJpZ2dlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdUcmlnZ2VyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBhY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHNob3dBY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGhpZGVBY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcG9wdXA6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLm5vZGUsIF9yZWFjdC5Qcm9wVHlwZXMuZnVuY10pLmlzUmVxdWlyZWQsXG4gICAgcG9wdXBTdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwb3B1cENsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcG9wdXBQbGFjZW1lbnQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGJ1aWx0aW5QbGFjZW1lbnRzOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwb3B1cFRyYW5zaXRpb25OYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwb3B1cEFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgbW91c2VFbnRlckRlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBtb3VzZUxlYXZlRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHpJbmRleDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZm9jdXNEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgYmx1ckRlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG1hc2s6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblBvcHVwQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwb3B1cEFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwb3B1cFZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBtYXNrVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1hc2tBbmltYXRpb246IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeENsczogJ3JjLXRyaWdnZXItcG9wdXAnLFxuICAgICAgZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ246IHJldHVybkVtcHR5U3RyaW5nLFxuICAgICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IG5vb3AsXG4gICAgICBhZnRlclBvcHVwVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICAgIG9uUG9wdXBBbGlnbjogbm9vcCxcbiAgICAgIHBvcHVwQ2xhc3NOYW1lOiAnJyxcbiAgICAgIG1vdXNlRW50ZXJEZWxheTogMCxcbiAgICAgIG1vdXNlTGVhdmVEZWxheTogMC4xLFxuICAgICAgZm9jdXNEZWxheTogMCxcbiAgICAgIGJsdXJEZWxheTogMC4xNSxcbiAgICAgIHBvcHVwU3R5bGU6IHt9LFxuICAgICAgZGVzdHJveVBvcHVwT25IaWRlOiBmYWxzZSxcbiAgICAgIHBvcHVwQWxpZ246IHt9LFxuICAgICAgZGVmYXVsdFBvcHVwVmlzaWJsZTogZmFsc2UsXG4gICAgICBtYXNrOiBmYWxzZSxcbiAgICAgIGFjdGlvbjogW10sXG4gICAgICBzaG93QWN0aW9uOiBbXSxcbiAgICAgIGhpZGVBY3Rpb246IFtdXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcG9wdXBWaXNpYmxlID0gdm9pZCAwO1xuICAgIGlmICgncG9wdXBWaXNpYmxlJyBpbiBwcm9wcykge1xuICAgICAgcG9wdXBWaXNpYmxlID0gISFwcm9wcy5wb3B1cFZpc2libGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcHVwVmlzaWJsZSA9ICEhcHJvcHMuZGVmYXVsdFBvcHVwVmlzaWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcHVwVmlzaWJsZTogcG9wdXBWaXNpYmxlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKHt9LCB7XG4gICAgICBwb3B1cFZpc2libGU6IHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlXG4gICAgfSk7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKCdwb3B1cFZpc2libGUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBvcHVwVmlzaWJsZTogISFuZXh0UHJvcHMucG9wdXBWaXNpYmxlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5wb3B1cFJlbmRlcmVkKSB7XG4gICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0udW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoX3RoaXMsIF90aGlzLmdldFBvcHVwRWxlbWVudCgpLCBfdGhpcy5nZXRQb3B1cENvbnRhaW5lcigpLCBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICAgIHNlbGYucG9wdXBJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgICAgaWYgKHByZXZTdGF0ZS5wb3B1cFZpc2libGUgIT09IHN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgICAgcHJvcHMuYWZ0ZXJQb3B1cFZpc2libGVDaGFuZ2Uoc3RhdGUucG9wdXBWaXNpYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX3RoaXMuaXNDbGlja1RvSGlkZSgpKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIgPSAoMCwgX2FkZEV2ZW50TGlzdGVuZXIyW1wiZGVmYXVsdFwiXSkoZG9jdW1lbnQsICdtb3VzZWRvd24nLCBfdGhpcy5vbkRvY3VtZW50Q2xpY2spO1xuICAgICAgICAgICAgICBfdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyID0gKDAsIF9hZGRFdmVudExpc3RlbmVyMltcImRlZmF1bHRcIl0pKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIF90aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgICAgICBfdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgcG9wdXBDb250YWluZXIgPSB0aGlzLnBvcHVwQ29udGFpbmVyO1xuICAgIGlmIChwb3B1cENvbnRhaW5lcikge1xuICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0udW5tb3VudENvbXBvbmVudEF0Tm9kZShwb3B1cENvbnRhaW5lcik7XG4gICAgICBwb3B1cENvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHVwQ29udGFpbmVyKTtcbiAgICAgIHRoaXMucG9wdXBDb250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmICh0aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG91Y2hPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICB0aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZSh0cnVlLCB0aGlzLnByb3BzLm1vdXNlRW50ZXJEZWxheSk7XG4gIH0sXG4gIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtY29tcG9uZW50L3RyaWdnZXIvcHVsbC8xM1xuICAgIC8vIHJlYWN0IGJ1Zz9cbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmICFlLnJlbGF0ZWRUYXJnZXQuc2V0VGltZW91dCAmJiAoMCwgX2NvbnRhaW5zMltcImRlZmF1bHRcIl0pKHRoaXMucG9wdXBDb250YWluZXIsIGUucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZShmYWxzZSwgdGhpcy5wcm9wcy5tb3VzZUxlYXZlRGVsYXkpO1xuICB9LFxuICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgIC8vIGluY2FzZSBmb2N1c2luIGFuZCBmb2N1c291dFxuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuaXNGb2N1c1RvU2hvdygpKSB7XG4gICAgICB0aGlzLmZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgICB0aGlzLmRlbGF5U2V0UG9wdXBWaXNpYmxlKHRydWUsIHRoaXMucHJvcHMuZm9jdXNEZWxheSk7XG4gICAgfVxuICB9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG4gICAgdGhpcy5wcmVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICB9LFxuICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gIH0sXG4gIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuaXNCbHVyVG9IaWRlKCkpIHtcbiAgICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUoZmFsc2UsIHRoaXMucHJvcHMuYmx1ckRlbGF5KTtcbiAgICB9XG4gIH0sXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBmb2N1cyB3aWxsIHRyaWdnZXIgY2xpY2tcbiAgICBpZiAodGhpcy5mb2N1c1RpbWUpIHtcbiAgICAgIHZhciBwcmVUaW1lID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMucHJlQ2xpY2tUaW1lICYmIHRoaXMucHJlVG91Y2hUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSBNYXRoLm1pbih0aGlzLnByZUNsaWNrVGltZSwgdGhpcy5wcmVUb3VjaFRpbWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByZUNsaWNrVGltZSkge1xuICAgICAgICBwcmVUaW1lID0gdGhpcy5wcmVDbGlja1RpbWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJlVG91Y2hUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSB0aGlzLnByZVRvdWNoVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhwcmVUaW1lIC0gdGhpcy5mb2N1c1RpbWUpIDwgMjApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5mb2N1c1RpbWUgPSAwO1xuICAgIH1cbiAgICB0aGlzLnByZUNsaWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcmVUb3VjaFRpbWUgPSAwO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIG5leHRWaXNpYmxlID0gIXRoaXMuc3RhdGUucG9wdXBWaXNpYmxlO1xuICAgIGlmICh0aGlzLmlzQ2xpY2tUb0hpZGUoKSAmJiAhbmV4dFZpc2libGUgfHwgbmV4dFZpc2libGUgJiYgdGhpcy5pc0NsaWNrVG9TaG93KCkpIHtcbiAgICAgIHRoaXMuc2V0UG9wdXBWaXNpYmxlKCF0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSk7XG4gICAgfVxuICB9LFxuICBvbkRvY3VtZW50Q2xpY2s6IGZ1bmN0aW9uIG9uRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIHJvb3QgPSAoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzKTtcbiAgICB2YXIgcG9wdXBOb2RlID0gdGhpcy5nZXRQb3B1cERvbU5vZGUoKTtcbiAgICBpZiAoISgwLCBfY29udGFpbnMyW1wiZGVmYXVsdFwiXSkocm9vdCwgdGFyZ2V0KSAmJiAhKDAsIF9jb250YWluczJbXCJkZWZhdWx0XCJdKShwb3B1cE5vZGUsIHRhcmdldCkpIHtcbiAgICAgIHRoaXMuc2V0UG9wdXBWaXNpYmxlKGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIGdldFBvcHVwRG9tTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBEb21Ob2RlKCkge1xuICAgIC8vIGZvciB0ZXN0XG4gICAgaWYgKHRoaXMucG9wdXBJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIHRoaXMucG9wdXBJbnN0YW5jZS5pc01vdW50ZWQoKSA/IHRoaXMucG9wdXBJbnN0YW5jZS5nZXRQb3B1cERvbU5vZGUoKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBnZXRSb290RG9tTm9kZTogZnVuY3Rpb24gZ2V0Um9vdERvbU5vZGUoKSB7XG4gICAgcmV0dXJuIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpO1xuICB9LFxuICBnZXRQb3B1cENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0UG9wdXBDb250YWluZXIoKSB7XG4gICAgaWYgKCF0aGlzLnBvcHVwQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnBvcHVwQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB2YXIgbW91bnROb2RlID0gdGhpcy5wcm9wcy5nZXRQb3B1cENvbnRhaW5lciA/IHRoaXMucHJvcHMuZ2V0UG9wdXBDb250YWluZXIoKDAsIF9yZWFjdERvbS5maW5kRE9NTm9kZSkodGhpcykpIDogZG9jdW1lbnQuYm9keTtcbiAgICAgIG1vdW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwQ29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucG9wdXBDb250YWluZXI7XG4gIH0sXG4gIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduOiBmdW5jdGlvbiBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbihhbGlnbikge1xuICAgIHZhciBjbGFzc05hbWUgPSBbXTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwb3B1cFBsYWNlbWVudCA9IHByb3BzLnBvcHVwUGxhY2VtZW50O1xuICAgIHZhciBidWlsdGluUGxhY2VtZW50cyA9IHByb3BzLmJ1aWx0aW5QbGFjZW1lbnRzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG5cbiAgICBpZiAocG9wdXBQbGFjZW1lbnQgJiYgYnVpbHRpblBsYWNlbWVudHMpIHtcbiAgICAgIGNsYXNzTmFtZS5wdXNoKCgwLCBfdXRpbHMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24pKGJ1aWx0aW5QbGFjZW1lbnRzLCBwcmVmaXhDbHMsIGFsaWduKSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbikge1xuICAgICAgY2xhc3NOYW1lLnB1c2gocHJvcHMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24oYWxpZ24pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5qb2luKCcgJyk7XG4gIH0sXG4gIGdldFBvcHVwQWxpZ246IGZ1bmN0aW9uIGdldFBvcHVwQWxpZ24oKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcG9wdXBQbGFjZW1lbnQgPSBwcm9wcy5wb3B1cFBsYWNlbWVudDtcbiAgICB2YXIgcG9wdXBBbGlnbiA9IHByb3BzLnBvcHVwQWxpZ247XG4gICAgdmFyIGJ1aWx0aW5QbGFjZW1lbnRzID0gcHJvcHMuYnVpbHRpblBsYWNlbWVudHM7XG5cbiAgICBpZiAocG9wdXBQbGFjZW1lbnQgJiYgYnVpbHRpblBsYWNlbWVudHMpIHtcbiAgICAgIHJldHVybiAoMCwgX3V0aWxzLmdldEFsaWduRnJvbVBsYWNlbWVudCkoYnVpbHRpblBsYWNlbWVudHMsIHBvcHVwUGxhY2VtZW50LCBwb3B1cEFsaWduKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVwQWxpZ247XG4gIH0sXG4gIGdldFBvcHVwRWxlbWVudDogZnVuY3Rpb24gZ2V0UG9wdXBFbGVtZW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIHZhciBtb3VzZVByb3BzID0ge307XG4gICAgaWYgKHRoaXMuaXNNb3VzZUVudGVyVG9TaG93KCkpIHtcbiAgICAgIG1vdXNlUHJvcHMub25Nb3VzZUVudGVyID0gdGhpcy5vbk1vdXNlRW50ZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTW91c2VMZWF2ZVRvSGlkZSgpKSB7XG4gICAgICBtb3VzZVByb3BzLm9uTW91c2VMZWF2ZSA9IHRoaXMub25Nb3VzZUxlYXZlO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgIF9Qb3B1cDJbXCJkZWZhdWx0XCJdLFxuICAgICAgX2V4dGVuZHMoe1xuICAgICAgICBwcmVmaXhDbHM6IHByb3BzLnByZWZpeENscyxcbiAgICAgICAgZGVzdHJveVBvcHVwT25IaWRlOiBwcm9wcy5kZXN0cm95UG9wdXBPbkhpZGUsXG4gICAgICAgIHZpc2libGU6IHN0YXRlLnBvcHVwVmlzaWJsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wb3B1cENsYXNzTmFtZSxcbiAgICAgICAgYWN0aW9uOiBwcm9wcy5hY3Rpb24sXG4gICAgICAgIGFsaWduOiB0aGlzLmdldFBvcHVwQWxpZ24oKSxcbiAgICAgICAgb25BbGlnbjogcHJvcHMub25Qb3B1cEFsaWduLFxuICAgICAgICBhbmltYXRpb246IHByb3BzLnBvcHVwQW5pbWF0aW9uLFxuICAgICAgICBnZXRDbGFzc05hbWVGcm9tQWxpZ246IHRoaXMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ25cbiAgICAgIH0sIG1vdXNlUHJvcHMsIHtcbiAgICAgICAgZ2V0Um9vdERvbU5vZGU6IHRoaXMuZ2V0Um9vdERvbU5vZGUsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5wb3B1cFN0eWxlLFxuICAgICAgICBtYXNrOiBwcm9wcy5tYXNrLFxuICAgICAgICB6SW5kZXg6IHByb3BzLnpJbmRleCxcbiAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHByb3BzLnBvcHVwVHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIG1hc2tBbmltYXRpb246IHByb3BzLm1hc2tBbmltYXRpb24sXG4gICAgICAgIG1hc2tUcmFuc2l0aW9uTmFtZTogcHJvcHMubWFza1RyYW5zaXRpb25OYW1lXG4gICAgICB9KSxcbiAgICAgIHR5cGVvZiBwcm9wcy5wb3B1cCA9PT0gJ2Z1bmN0aW9uJyA/IHByb3BzLnBvcHVwKCkgOiBwcm9wcy5wb3B1cFxuICAgICk7XG4gIH0sXG4gIHNldFBvcHVwVmlzaWJsZTogZnVuY3Rpb24gc2V0UG9wdXBWaXNpYmxlKHBvcHVwVmlzaWJsZSkge1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlICE9PSBwb3B1cFZpc2libGUpIHtcbiAgICAgIGlmICghKCdwb3B1cFZpc2libGUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHBvcHVwVmlzaWJsZTogcG9wdXBWaXNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vblBvcHVwVmlzaWJsZUNoYW5nZShwb3B1cFZpc2libGUpO1xuICAgIH1cbiAgfSxcbiAgZGVsYXlTZXRQb3B1cFZpc2libGU6IGZ1bmN0aW9uIGRlbGF5U2V0UG9wdXBWaXNpYmxlKHZpc2libGUsIGRlbGF5Uykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGRlbGF5ID0gZGVsYXlTICogMTAwMDtcbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmIChkZWxheSkge1xuICAgICAgdGhpcy5kZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXRQb3B1cFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgIF90aGlzMi5jbGVhckRlbGF5VGltZXIoKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuICB9LFxuICBjbGVhckRlbGF5VGltZXI6IGZ1bmN0aW9uIGNsZWFyRGVsYXlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5kZWxheVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVyKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBpc0NsaWNrVG9TaG93OiBmdW5jdGlvbiBpc0NsaWNrVG9TaG93KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMuYWN0aW9uO1xuICAgIHZhciBzaG93QWN0aW9uID0gX3Byb3BzLnNob3dBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTE7XG4gIH0sXG4gIGlzQ2xpY2tUb0hpZGU6IGZ1bmN0aW9uIGlzQ2xpY2tUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMyLmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczIuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMTtcbiAgfSxcbiAgaXNNb3VzZUVudGVyVG9TaG93OiBmdW5jdGlvbiBpc01vdXNlRW50ZXJUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMzLmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wczMuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignaG92ZXInKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdtb3VzZUVudGVyJykgIT09IC0xO1xuICB9LFxuICBpc01vdXNlTGVhdmVUb0hpZGU6IGZ1bmN0aW9uIGlzTW91c2VMZWF2ZVRvSGlkZSgpIHtcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczQuYWN0aW9uO1xuICAgIHZhciBoaWRlQWN0aW9uID0gX3Byb3BzNC5oaWRlQWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdob3ZlcicpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoJ21vdXNlTGVhdmUnKSAhPT0gLTE7XG4gIH0sXG4gIGlzRm9jdXNUb1Nob3c6IGZ1bmN0aW9uIGlzRm9jdXNUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wczUgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM1LmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wczUuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdmb2N1cycpICE9PSAtMTtcbiAgfSxcbiAgaXNCbHVyVG9IaWRlOiBmdW5jdGlvbiBpc0JsdXJUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM2LmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczYuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdibHVyJykgIT09IC0xO1xuICB9LFxuICBmb3JjZVBvcHVwQWxpZ246IGZ1bmN0aW9uIGZvcmNlUG9wdXBBbGlnbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3B1cFZpc2libGUgJiYgdGhpcy5wb3B1cEluc3RhbmNlICYmIHRoaXMucG9wdXBJbnN0YW5jZS5hbGlnbkluc3RhbmNlKSB7XG4gICAgICB0aGlzLnBvcHVwSW5zdGFuY2UuYWxpZ25JbnN0YW5jZS5mb3JjZUFsaWduKCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLnBvcHVwUmVuZGVyZWQgPSB0aGlzLnBvcHVwUmVuZGVyZWQgfHwgdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IGNoaWxkLnByb3BzIHx8IHt9O1xuICAgIHZhciBuZXdDaGlsZFByb3BzID0ge307XG5cbiAgICBpZiAodGhpcy5pc0NsaWNrVG9IaWRlKCkgfHwgdGhpcy5pc0NsaWNrVG9TaG93KCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25DbGljayA9ICgwLCBfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uMltcImRlZmF1bHRcIl0pKHRoaXMub25DbGljaywgY2hpbGRQcm9wcy5vbkNsaWNrKTtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZURvd24gPSAoMCwgX2NyZWF0ZUNoYWluZWRGdW5jdGlvbjJbXCJkZWZhdWx0XCJdKSh0aGlzLm9uTW91c2VEb3duLCBjaGlsZFByb3BzLm9uTW91c2VEb3duKTtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Ub3VjaFN0YXJ0ID0gKDAsIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yW1wiZGVmYXVsdFwiXSkodGhpcy5vblRvdWNoU3RhcnQsIGNoaWxkUHJvcHMub25Ub3VjaFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUVudGVyVG9TaG93KCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKDAsIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yW1wiZGVmYXVsdFwiXSkodGhpcy5vbk1vdXNlRW50ZXIsIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUxlYXZlVG9IaWRlKCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUxlYXZlID0gKDAsIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yW1wiZGVmYXVsdFwiXSkodGhpcy5vbk1vdXNlTGVhdmUsIGNoaWxkUHJvcHMub25Nb3VzZUxlYXZlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb2N1c1RvU2hvdygpIHx8IHRoaXMuaXNCbHVyVG9IaWRlKCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Gb2N1cyA9ICgwLCBfY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uMltcImRlZmF1bHRcIl0pKHRoaXMub25Gb2N1cywgY2hpbGRQcm9wcy5vbkZvY3VzKTtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25CbHVyID0gKDAsIF9jcmVhdGVDaGFpbmVkRnVuY3Rpb24yW1wiZGVmYXVsdFwiXSkodGhpcy5vbkJsdXIsIGNoaWxkUHJvcHMub25CbHVyKTtcbiAgICB9XG5cbiAgICBBTExfSEFORExFUlMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIG5ld0ZuID0gdm9pZCAwO1xuICAgICAgaWYgKHByb3BzW2hhbmRsZXJdICYmIG5ld0NoaWxkUHJvcHNbaGFuZGxlcl0pIHtcbiAgICAgICAgbmV3Rm4gPSAoMCwgX2NyZWF0ZUNoYWluZWRGdW5jdGlvbjJbXCJkZWZhdWx0XCJdKShwcm9wc1toYW5kbGVyXSwgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdGbiA9IHByb3BzW2hhbmRsZXJdIHx8IG5ld0NoaWxkUHJvcHNbaGFuZGxlcl07XG4gICAgICB9XG4gICAgICBpZiAobmV3Rm4pIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXSA9IG5ld0ZuO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjaGlsZCwgbmV3Q2hpbGRQcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRyaWdnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9UcmlnZ2VyJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmdldEFsaWduRnJvbVBsYWNlbWVudCA9IGdldEFsaWduRnJvbVBsYWNlbWVudDtcbmV4cG9ydHMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24gPSBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjtcbmZ1bmN0aW9uIGlzUG9pbnRzRXEoYTEsIGEyKSB7XG4gIHJldHVybiBhMVswXSA9PT0gYTJbMF0gJiYgYTFbMV0gPT09IGEyWzFdO1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbkZyb21QbGFjZW1lbnQoYnVpbHRpblBsYWNlbWVudHMsIHBsYWNlbWVudFN0ciwgYWxpZ24pIHtcbiAgdmFyIGJhc2VBbGlnbiA9IGJ1aWx0aW5QbGFjZW1lbnRzW3BsYWNlbWVudFN0cl0gfHwge307XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgYmFzZUFsaWduLCBhbGlnbik7XG59XG5cbmZ1bmN0aW9uIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKGJ1aWx0aW5QbGFjZW1lbnRzLCBwcmVmaXhDbHMsIGFsaWduKSB7XG4gIHZhciBwb2ludHMgPSBhbGlnbi5wb2ludHM7XG4gIGZvciAodmFyIHBsYWNlbWVudCBpbiBidWlsdGluUGxhY2VtZW50cykge1xuICAgIGlmIChidWlsdGluUGxhY2VtZW50cy5oYXNPd25Qcm9wZXJ0eShwbGFjZW1lbnQpKSB7XG4gICAgICBpZiAoaXNQb2ludHNFcShidWlsdGluUGxhY2VtZW50c1twbGFjZW1lbnRdLnBvaW50cywgcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gcHJlZml4Q2xzICsgJy1wbGFjZW1lbnQtJyArIHBsYWNlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2RvbUFsaWduID0gcmVxdWlyZSgnZG9tLWFsaWduJyk7XG5cbnZhciBfZG9tQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tQWxpZ24pO1xuXG52YXIgX2FkZEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdyYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgX2FkZEV2ZW50TGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkRXZlbnRMaXN0ZW5lcik7XG5cbnZhciBfaXNXaW5kb3cgPSByZXF1aXJlKCcuL2lzV2luZG93Jyk7XG5cbnZhciBfaXNXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNXaW5kb3cpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gYnVmZmVyKGZuLCBtcykge1xuICB2YXIgdGltZXIgPSB2b2lkIDA7XG4gIHJldHVybiBmdW5jdGlvbiBidWZmZXJGbigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dChmbiwgbXMpO1xuICB9O1xufVxuXG52YXIgQWxpZ24gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQWxpZ24nLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNoaWxkcmVuUHJvcHM6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHRhcmdldDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBtb25pdG9yQnVmZmVyVGltZTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgfSxcbiAgICAgIG9uQWxpZ246IGZ1bmN0aW9uIG9uQWxpZ24oKSB7fSxcblxuICAgICAgbW9uaXRvckJ1ZmZlclRpbWU6IDUwLFxuICAgICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAvLyBpZiBwYXJlbnQgcmVmIG5vdCBhdHRhY2hlZCAuLi4uIHVzZSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZFxuICAgIHRoaXMuZm9yY2VBbGlnbigpO1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQgJiYgcHJvcHMubW9uaXRvcldpbmRvd1Jlc2l6ZSkge1xuICAgICAgdGhpcy5zdGFydE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciByZUFsaWduID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGlmIChwcmV2UHJvcHMuZGlzYWJsZWQgfHwgcHJldlByb3BzLmFsaWduICE9PSBwcm9wcy5hbGlnbikge1xuICAgICAgICByZUFsaWduID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXN0VGFyZ2V0ID0gcHJldlByb3BzLnRhcmdldCgpO1xuICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IHByb3BzLnRhcmdldCgpO1xuICAgICAgICBpZiAoKDAsIF9pc1dpbmRvdzJbXCJkZWZhdWx0XCJdKShsYXN0VGFyZ2V0KSAmJiAoMCwgX2lzV2luZG93MltcImRlZmF1bHRcIl0pKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgcmVBbGlnbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RUYXJnZXQgIT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICByZUFsaWduID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZUFsaWduKSB7XG4gICAgICB0aGlzLmZvcmNlQWxpZ24oKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMubW9uaXRvcldpbmRvd1Jlc2l6ZSAmJiAhcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yV2luZG93UmVzaXplKCk7XG4gIH0sXG4gIHN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24gc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCkge1xuICAgIGlmICghdGhpcy5yZXNpemVIYW5kbGVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSAoMCwgX2FkZEV2ZW50TGlzdGVuZXIyW1wiZGVmYXVsdFwiXSkod2luZG93LCAncmVzaXplJywgYnVmZmVyKHRoaXMuZm9yY2VBbGlnbiwgdGhpcy5wcm9wcy5tb25pdG9yQnVmZmVyVGltZSkpO1xuICAgIH1cbiAgfSxcbiAgc3RvcE1vbml0b3JXaW5kb3dSZXNpemU6IGZ1bmN0aW9uIHN0b3BNb25pdG9yV2luZG93UmVzaXplKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMucmVzaXplSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBmb3JjZUFsaWduOiBmdW5jdGlvbiBmb3JjZUFsaWduKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgcHJvcHMub25BbGlnbihzb3VyY2UsICgwLCBfZG9tQWxpZ24yW1wiZGVmYXVsdFwiXSkoc291cmNlLCBwcm9wcy50YXJnZXQoKSwgcHJvcHMuYWxpZ24pKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGlsZHJlblByb3BzID0gX3Byb3BzLmNoaWxkcmVuUHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGNoaWxkID0gX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkcmVuUHJvcHMpIHtcbiAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBjaGlsZHJlblByb3BzKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblByb3BzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgbmV3UHJvcHNbcHJvcF0gPSB0aGlzLnByb3BzW2NoaWxkcmVuUHJvcHNbcHJvcF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQWxpZ247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQWxpZ24gPSByZXF1aXJlKCcuL0FsaWduJyk7XG5cbnZhciBfQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWxpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfQWxpZ24yW1wiZGVmYXVsdFwiXTsgLy8gZXhwb3J0IHRoaXMgcGFja2FnZSdzIGFwaVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gaXNXaW5kb3c7XG5mdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgLyogZXNsaW50IG5vLWVxLW51bGw6IDAgKi9cbiAgLyogZXNsaW50IGVxZXFlcTogMCAqL1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG5mdW5jdGlvbiBhZGp1c3RGb3JWaWV3cG9ydChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0LCBvdmVyZmxvdykge1xuICB2YXIgcG9zID0gX3V0aWxzMlsnZGVmYXVsdCddLmNsb25lKGVsRnV0dXJlUG9zKTtcbiAgdmFyIHNpemUgPSB7XG4gICAgd2lkdGg6IGVsUmVnaW9uLndpZHRoLFxuICAgIGhlaWdodDogZWxSZWdpb24uaGVpZ2h0XG4gIH07XG5cbiAgaWYgKG92ZXJmbG93LmFkanVzdFggJiYgcG9zLmxlZnQgPCB2aXNpYmxlUmVjdC5sZWZ0KSB7XG4gICAgcG9zLmxlZnQgPSB2aXNpYmxlUmVjdC5sZWZ0O1xuICB9XG5cbiAgLy8gTGVmdCBlZGdlIGluc2lkZSBhbmQgcmlnaHQgZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gcmVzaXplIGl0LlxuICBpZiAob3ZlcmZsb3cucmVzaXplV2lkdGggJiYgcG9zLmxlZnQgPj0gdmlzaWJsZVJlY3QubGVmdCAmJiBwb3MubGVmdCArIHNpemUud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodCkge1xuICAgIHNpemUud2lkdGggLT0gcG9zLmxlZnQgKyBzaXplLndpZHRoIC0gdmlzaWJsZVJlY3QucmlnaHQ7XG4gIH1cblxuICAvLyBSaWdodCBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byBtb3ZlIGl0LlxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WCAmJiBwb3MubGVmdCArIHNpemUud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodCkge1xuICAgIC8vIOS/neivgeW3pui+ueeVjOWSjOWPr+inhuWMuuWfn+W3pui+ueeVjOWvuem9kFxuICAgIHBvcy5sZWZ0ID0gTWF0aC5tYXgodmlzaWJsZVJlY3QucmlnaHQgLSBzaXplLndpZHRoLCB2aXNpYmxlUmVjdC5sZWZ0KTtcbiAgfVxuXG4gIC8vIFRvcCBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byBtb3ZlIGl0LlxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WSAmJiBwb3MudG9wIDwgdmlzaWJsZVJlY3QudG9wKSB7XG4gICAgcG9zLnRvcCA9IHZpc2libGVSZWN0LnRvcDtcbiAgfVxuXG4gIC8vIFRvcCBlZGdlIGluc2lkZSBhbmQgYm90dG9tIGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIHJlc2l6ZSBpdC5cbiAgaWYgKG92ZXJmbG93LnJlc2l6ZUhlaWdodCAmJiBwb3MudG9wID49IHZpc2libGVSZWN0LnRvcCAmJiBwb3MudG9wICsgc2l6ZS5oZWlnaHQgPiB2aXNpYmxlUmVjdC5ib3R0b20pIHtcbiAgICBzaXplLmhlaWdodCAtPSBwb3MudG9wICsgc2l6ZS5oZWlnaHQgLSB2aXNpYmxlUmVjdC5ib3R0b207XG4gIH1cblxuICAvLyBCb3R0b20gZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gbW92ZSBpdC5cbiAgaWYgKG92ZXJmbG93LmFkanVzdFkgJiYgcG9zLnRvcCArIHNpemUuaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tKSB7XG4gICAgLy8g5L+d6K+B5LiK6L6555WM5ZKM5Y+v6KeG5Yy65Z+f5LiK6L6555WM5a+56b2QXG4gICAgcG9zLnRvcCA9IE1hdGgubWF4KHZpc2libGVSZWN0LmJvdHRvbSAtIHNpemUuaGVpZ2h0LCB2aXNpYmxlUmVjdC50b3ApO1xuICB9XG5cbiAgcmV0dXJuIF91dGlsczJbJ2RlZmF1bHQnXS5taXgocG9zLCBzaXplKTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gYWRqdXN0Rm9yVmlld3BvcnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIOiOt+WPliBub2RlIOS4iueahCBhbGlnbiDlr7npvZDngrkg55u45a+55LqO6aG16Z2i55qE5Z2Q5qCHXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIGdldEFsaWduT2Zmc2V0KHJlZ2lvbiwgYWxpZ24pIHtcbiAgdmFyIFYgPSBhbGlnbi5jaGFyQXQoMCk7XG4gIHZhciBIID0gYWxpZ24uY2hhckF0KDEpO1xuICB2YXIgdyA9IHJlZ2lvbi53aWR0aDtcbiAgdmFyIGggPSByZWdpb24uaGVpZ2h0O1xuICB2YXIgeCA9IHVuZGVmaW5lZDtcbiAgdmFyIHkgPSB1bmRlZmluZWQ7XG5cbiAgeCA9IHJlZ2lvbi5sZWZ0O1xuICB5ID0gcmVnaW9uLnRvcDtcblxuICBpZiAoViA9PT0gJ2MnKSB7XG4gICAgeSArPSBoIC8gMjtcbiAgfSBlbHNlIGlmIChWID09PSAnYicpIHtcbiAgICB5ICs9IGg7XG4gIH1cblxuICBpZiAoSCA9PT0gJ2MnKSB7XG4gICAgeCArPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChIID09PSAncicpIHtcbiAgICB4ICs9IHc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsXG4gICAgdG9wOiB5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEFsaWduT2Zmc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dldEFsaWduT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXRBbGlnbk9mZnNldCcpO1xuXG52YXIgX2dldEFsaWduT2Zmc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEFsaWduT2Zmc2V0KTtcblxuZnVuY3Rpb24gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpIHtcbiAgdmFyIHh5ID0gdW5kZWZpbmVkO1xuICB2YXIgZGlmZiA9IHVuZGVmaW5lZDtcbiAgdmFyIHAxID0gdW5kZWZpbmVkO1xuICB2YXIgcDIgPSB1bmRlZmluZWQ7XG5cbiAgeHkgPSB7XG4gICAgbGVmdDogZWxSZWdpb24ubGVmdCxcbiAgICB0b3A6IGVsUmVnaW9uLnRvcFxuICB9O1xuXG4gIHAxID0gKDAsIF9nZXRBbGlnbk9mZnNldDJbJ2RlZmF1bHQnXSkocmVmTm9kZVJlZ2lvbiwgcG9pbnRzWzFdKTtcbiAgcDIgPSAoMCwgX2dldEFsaWduT2Zmc2V0MlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcG9pbnRzWzBdKTtcblxuICBkaWZmID0gW3AyLmxlZnQgLSBwMS5sZWZ0LCBwMi50b3AgLSBwMS50b3BdO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogeHkubGVmdCAtIGRpZmZbMF0gKyBvZmZzZXRbMF0gLSB0YXJnZXRPZmZzZXRbMF0sXG4gICAgdG9wOiB4eS50b3AgLSBkaWZmWzFdICsgb2Zmc2V0WzFdIC0gdGFyZ2V0T2Zmc2V0WzFdXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEVsRnV0dXJlUG9zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxuLyoqXG4gKiDlvpfliLDkvJrlr7zoh7TlhYPntKDmmL7npLrkuI3lhajnmoTnpZblhYjlhYPntKBcbiAqL1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBpZSDov5nkuKrkuZ/kuI3mmK/lrozlhajlj6/ooYxcbiAgLypcbiAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNTBweDtoZWlnaHQ6IDEwMHB4O292ZXJmbG93OiBoaWRkZW5cIj5cbiAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNTBweDtoZWlnaHQ6IDEwMHB4O3Bvc2l0aW9uOiByZWxhdGl2ZTtcIiBpZD1cImQ2XCI+XG4gICDlhYPntKAgNiDpq5ggMTAwcHgg5a69IDUwcHg8YnIvPlxuICAgPC9kaXY+XG4gICA8L2Rpdj5cbiAgICovXG4gIC8vIGVsZW1lbnQub2Zmc2V0UGFyZW50IGRvZXMgdGhlIHJpZ2h0IHRoaW5nIGluIGllNyBhbmQgYmVsb3cuIFJldHVybiBwYXJlbnQgd2l0aCBsYXlvdXQhXG4gIC8vICBJbiBvdGhlciBicm93c2VycyBpdCBvbmx5IGluY2x1ZGVzIGVsZW1lbnRzIHdpdGggcG9zaXRpb24gYWJzb2x1dGUsIHJlbGF0aXZlIG9yXG4gIC8vIGZpeGVkLCBub3QgZWxlbWVudHMgd2l0aCBvdmVyZmxvdyBzZXQgdG8gYXV0byBvciBzY3JvbGwuXG4gIC8vICAgICAgICBpZiAoVUEuaWUgJiYgaWVNb2RlIDwgOCkge1xuICAvLyAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgLy8gICAgICAgIH1cbiAgLy8g57uf5LiA55qEIG9mZnNldFBhcmVudCDmlrnms5VcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIHBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIHBvc2l0aW9uU3R5bGUgPSBfdXRpbHMyWydkZWZhdWx0J10uY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpO1xuICB2YXIgc2tpcFN0YXRpYyA9IHBvc2l0aW9uU3R5bGUgPT09ICdmaXhlZCcgfHwgcG9zaXRpb25TdHlsZSA9PT0gJ2Fic29sdXRlJztcblxuICBpZiAoIXNraXBTdGF0aWMpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaHRtbCcgPyBudWxsIDogZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgZm9yIChwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT09IGJvZHk7IHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgcG9zaXRpb25TdHlsZSA9IF91dGlsczJbJ2RlZmF1bHQnXS5jc3MocGFyZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAocG9zaXRpb25TdHlsZSAhPT0gJ3N0YXRpYycpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBnZXRPZmZzZXRQYXJlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG5mdW5jdGlvbiBnZXRSZWdpb24obm9kZSkge1xuICB2YXIgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICB2YXIgdyA9IHVuZGVmaW5lZDtcbiAgdmFyIGggPSB1bmRlZmluZWQ7XG4gIGlmICghX3V0aWxzMlsnZGVmYXVsdCddLmlzV2luZG93KG5vZGUpICYmIG5vZGUubm9kZVR5cGUgIT09IDkpIHtcbiAgICBvZmZzZXQgPSBfdXRpbHMyWydkZWZhdWx0J10ub2Zmc2V0KG5vZGUpO1xuICAgIHcgPSBfdXRpbHMyWydkZWZhdWx0J10ub3V0ZXJXaWR0aChub2RlKTtcbiAgICBoID0gX3V0aWxzMlsnZGVmYXVsdCddLm91dGVySGVpZ2h0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB3aW4gPSBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93KG5vZGUpO1xuICAgIG9mZnNldCA9IHtcbiAgICAgIGxlZnQ6IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxMZWZ0KHdpbiksXG4gICAgICB0b3A6IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKVxuICAgIH07XG4gICAgdyA9IF91dGlsczJbJ2RlZmF1bHQnXS52aWV3cG9ydFdpZHRoKHdpbik7XG4gICAgaCA9IF91dGlsczJbJ2RlZmF1bHQnXS52aWV3cG9ydEhlaWdodCh3aW4pO1xuICB9XG4gIG9mZnNldC53aWR0aCA9IHc7XG4gIG9mZnNldC5oZWlnaHQgPSBoO1xuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBnZXRSZWdpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG52YXIgX2dldE9mZnNldFBhcmVudCA9IHJlcXVpcmUoJy4vZ2V0T2Zmc2V0UGFyZW50Jyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE9mZnNldFBhcmVudCk7XG5cbi8qKlxuICog6I635b6X5YWD57Sg55qE5pi+56S66YOo5YiG55qE5Yy65Z+fXG4gKi9cbmZ1bmN0aW9uIGdldFZpc2libGVSZWN0Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB2aXNpYmxlUmVjdCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBJbmZpbml0eVxuICB9O1xuICB2YXIgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWxlbWVudCk7XG4gIHZhciBzY3JvbGxYID0gdW5kZWZpbmVkO1xuICB2YXIgc2Nyb2xsWSA9IHVuZGVmaW5lZDtcbiAgdmFyIHdpblNpemUgPSB1bmRlZmluZWQ7XG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSB2aXNpYmxlIHJlY3QgYnkgY2xpbWJpbmcgdGhlIGRvbSBhY2NvdW50aW5nIGZvclxuICAvLyBhbGwgc2Nyb2xsYWJsZSBjb250YWluZXJzLlxuICB3aGlsZSAoZWwpIHtcbiAgICAvLyBjbGllbnRXaWR0aCBpcyB6ZXJvIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudHMgaW4gaWUuXG4gICAgaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEgfHwgZWwuY2xpZW50V2lkdGggIT09IDApICYmXG4gICAgLy8gYm9keSBtYXkgaGF2ZSBvdmVyZmxvdyBzZXQgb24gaXQsIHlldCB3ZSBzdGlsbCBnZXQgdGhlIGVudGlyZVxuICAgIC8vIHZpZXdwb3J0LiBJbiBzb21lIGJyb3dzZXJzLCBlbC5vZmZzZXRQYXJlbnQgbWF5IGJlXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzbyBjaGVjayBmb3IgdGhhdCB0b28uXG4gICAgZWwgIT09IGJvZHkgJiYgZWwgIT09IGRvY3VtZW50RWxlbWVudCAmJiBfdXRpbHMyWydkZWZhdWx0J10uY3NzKGVsLCAnb3ZlcmZsb3cnKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YXIgcG9zID0gX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChlbCk7XG4gICAgICAvLyBhZGQgYm9yZGVyXG4gICAgICBwb3MubGVmdCArPSBlbC5jbGllbnRMZWZ0O1xuICAgICAgcG9zLnRvcCArPSBlbC5jbGllbnRUb3A7XG4gICAgICB2aXNpYmxlUmVjdC50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIHBvcy50b3ApO1xuICAgICAgdmlzaWJsZVJlY3QucmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCxcbiAgICAgIC8vIGNvbnNpZGVyIGFyZWEgd2l0aG91dCBzY3JvbGxCYXJcbiAgICAgIHBvcy5sZWZ0ICsgZWwuY2xpZW50V2lkdGgpO1xuICAgICAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBwb3MudG9wICsgZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBwb3MubGVmdCk7XG4gICAgfSBlbHNlIGlmIChlbCA9PT0gYm9keSB8fCBlbCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWwpO1xuICB9XG5cbiAgLy8gQ2xpcCBieSB3aW5kb3cncyB2aWV3cG9ydC5cbiAgc2Nyb2xsWCA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxMZWZ0KHdpbik7XG4gIHNjcm9sbFkgPSBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93U2Nyb2xsVG9wKHdpbik7XG4gIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBzY3JvbGxYKTtcbiAgdmlzaWJsZVJlY3QudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBzY3JvbGxZKTtcbiAgd2luU2l6ZSA9IHtcbiAgICB3aWR0aDogX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKSxcbiAgICBoZWlnaHQ6IF91dGlsczJbJ2RlZmF1bHQnXS52aWV3cG9ydEhlaWdodCh3aW4pXG4gIH07XG4gIHZpc2libGVSZWN0LnJpZ2h0ID0gTWF0aC5taW4odmlzaWJsZVJlY3QucmlnaHQsIHNjcm9sbFggKyB3aW5TaXplLndpZHRoKTtcbiAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBzY3JvbGxZICsgd2luU2l6ZS5oZWlnaHQpO1xuICByZXR1cm4gdmlzaWJsZVJlY3QudG9wID49IDAgJiYgdmlzaWJsZVJlY3QubGVmdCA+PSAwICYmIHZpc2libGVSZWN0LmJvdHRvbSA+IHZpc2libGVSZWN0LnRvcCAmJiB2aXNpYmxlUmVjdC5yaWdodCA+IHZpc2libGVSZWN0LmxlZnQgPyB2aXNpYmxlUmVjdCA6IG51bGw7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFZpc2libGVSZWN0Rm9yRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogYWxpZ24gZG9tIG5vZGUgZmxleGlibHlcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxudmFyIF9nZXRPZmZzZXRQYXJlbnQgPSByZXF1aXJlKCcuL2dldE9mZnNldFBhcmVudCcpO1xuXG52YXIgX2dldE9mZnNldFBhcmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRPZmZzZXRQYXJlbnQpO1xuXG52YXIgX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCA9IHJlcXVpcmUoJy4vZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50Jyk7XG5cbnZhciBfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCk7XG5cbnZhciBfYWRqdXN0Rm9yVmlld3BvcnQgPSByZXF1aXJlKCcuL2FkanVzdEZvclZpZXdwb3J0Jyk7XG5cbnZhciBfYWRqdXN0Rm9yVmlld3BvcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRqdXN0Rm9yVmlld3BvcnQpO1xuXG52YXIgX2dldFJlZ2lvbiA9IHJlcXVpcmUoJy4vZ2V0UmVnaW9uJyk7XG5cbnZhciBfZ2V0UmVnaW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFJlZ2lvbik7XG5cbnZhciBfZ2V0RWxGdXR1cmVQb3MgPSByZXF1aXJlKCcuL2dldEVsRnV0dXJlUG9zJyk7XG5cbnZhciBfZ2V0RWxGdXR1cmVQb3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RWxGdXR1cmVQb3MpO1xuXG4vLyBodHRwOi8veWltaW5naGUuaXRleWUuY29tL2Jsb2cvMTEyNDcyMFxuXG5mdW5jdGlvbiBpc0ZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLmxlZnQgPCB2aXNpYmxlUmVjdC5sZWZ0IHx8IGVsRnV0dXJlUG9zLmxlZnQgKyBlbFJlZ2lvbi53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0O1xufVxuXG5mdW5jdGlvbiBpc0ZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLnRvcCA8IHZpc2libGVSZWN0LnRvcCB8fCBlbEZ1dHVyZVBvcy50b3AgKyBlbFJlZ2lvbi5oZWlnaHQgPiB2aXNpYmxlUmVjdC5ib3R0b207XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGVGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy5sZWZ0ID4gdmlzaWJsZVJlY3QucmlnaHQgfHwgZWxGdXR1cmVQb3MubGVmdCArIGVsUmVnaW9uLndpZHRoIDwgdmlzaWJsZVJlY3QubGVmdDtcbn1cblxuZnVuY3Rpb24gaXNDb21wbGV0ZUZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLnRvcCA+IHZpc2libGVSZWN0LmJvdHRvbSB8fCBlbEZ1dHVyZVBvcy50b3AgKyBlbFJlZ2lvbi5oZWlnaHQgPCB2aXNpYmxlUmVjdC50b3A7XG59XG5cbmZ1bmN0aW9uIGZsaXAocG9pbnRzLCByZWcsIG1hcCkge1xuICB2YXIgcmV0ID0gW107XG4gIF91dGlsczJbJ2RlZmF1bHQnXS5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHApIHtcbiAgICByZXQucHVzaChwLnJlcGxhY2UocmVnLCBmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG1hcFttXTtcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmbGlwT2Zmc2V0KG9mZnNldCwgaW5kZXgpIHtcbiAgb2Zmc2V0W2luZGV4XSA9IC1vZmZzZXRbaW5kZXhdO1xuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0KHN0ciwgb2Zmc2V0TGVuKSB7XG4gIHZhciBuID0gdW5kZWZpbmVkO1xuICBpZiAoLyUkLy50ZXN0KHN0cikpIHtcbiAgICBuID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSksIDEwKSAvIDEwMCAqIG9mZnNldExlbjtcbiAgfSBlbHNlIHtcbiAgICBuID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIH1cbiAgcmV0dXJuIG4gfHwgMDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCwgZWwpIHtcbiAgb2Zmc2V0WzBdID0gY29udmVydE9mZnNldChvZmZzZXRbMF0sIGVsLndpZHRoKTtcbiAgb2Zmc2V0WzFdID0gY29udmVydE9mZnNldChvZmZzZXRbMV0sIGVsLmhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIGRvbUFsaWduKGVsLCByZWZOb2RlLCBhbGlnbikge1xuICB2YXIgcG9pbnRzID0gYWxpZ24ucG9pbnRzO1xuICB2YXIgb2Zmc2V0ID0gYWxpZ24ub2Zmc2V0IHx8IFswLCAwXTtcbiAgdmFyIHRhcmdldE9mZnNldCA9IGFsaWduLnRhcmdldE9mZnNldCB8fCBbMCwgMF07XG4gIHZhciBvdmVyZmxvdyA9IGFsaWduLm92ZXJmbG93O1xuICB2YXIgdGFyZ2V0ID0gYWxpZ24udGFyZ2V0IHx8IHJlZk5vZGU7XG4gIHZhciBzb3VyY2UgPSBhbGlnbi5zb3VyY2UgfHwgZWw7XG4gIG9mZnNldCA9IFtdLmNvbmNhdChvZmZzZXQpO1xuICB0YXJnZXRPZmZzZXQgPSBbXS5jb25jYXQodGFyZ2V0T2Zmc2V0KTtcbiAgb3ZlcmZsb3cgPSBvdmVyZmxvdyB8fCB7fTtcbiAgdmFyIG5ld092ZXJmbG93Q2ZnID0ge307XG5cbiAgdmFyIGZhaWwgPSAwO1xuICAvLyDlvZPliY3oioLngrnlj6/ku6XooqvmlL7nva7nmoTmmL7npLrljLrln59cbiAgdmFyIHZpc2libGVSZWN0ID0gKDAsIF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQyWydkZWZhdWx0J10pKHNvdXJjZSk7XG4gIC8vIOW9k+WJjeiKgueCueaJgOWNoOeahOWMuuWfnywgbGVmdC90b3Avd2lkdGgvaGVpZ2h0XG4gIHZhciBlbFJlZ2lvbiA9ICgwLCBfZ2V0UmVnaW9uMlsnZGVmYXVsdCddKShzb3VyY2UpO1xuICAvLyDlj4LnhafoioLngrnmiYDljaDnmoTljLrln58sIGxlZnQvdG9wL3dpZHRoL2hlaWdodFxuICB2YXIgcmVmTm9kZVJlZ2lvbiA9ICgwLCBfZ2V0UmVnaW9uMlsnZGVmYXVsdCddKSh0YXJnZXQpO1xuICAvLyDlsIYgb2Zmc2V0IOi9rOaNouaIkOaVsOWAvO+8jOaUr+aMgeeZvuWIhuavlFxuICBub3JtYWxpemVPZmZzZXQob2Zmc2V0LCBlbFJlZ2lvbik7XG4gIG5vcm1hbGl6ZU9mZnNldCh0YXJnZXRPZmZzZXQsIHJlZk5vZGVSZWdpb24pO1xuICAvLyDlvZPliY3oioLngrnlsIbopoHooqvmlL7nva7nmoTkvY3nva5cbiAgdmFyIGVsRnV0dXJlUG9zID0gKDAsIF9nZXRFbEZ1dHVyZVBvczJbJ2RlZmF1bHQnXSkoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpO1xuICAvLyDlvZPliY3oioLngrnlsIbopoHmiYDlpITnmoTljLrln59cbiAgdmFyIG5ld0VsUmVnaW9uID0gX3V0aWxzMlsnZGVmYXVsdCddLm1lcmdlKGVsUmVnaW9uLCBlbEZ1dHVyZVBvcyk7XG5cbiAgLy8g5aaC5p6c5Y+v6KeG5Yy65Z+f5LiN6IO95a6M5YWo5pS+572u5b2T5YmN6IqC54K55pe25YWB6K646LCD5pW0XG4gIGlmICh2aXNpYmxlUmVjdCAmJiAob3ZlcmZsb3cuYWRqdXN0WCB8fCBvdmVyZmxvdy5hZGp1c3RZKSkge1xuICAgIGlmIChvdmVyZmxvdy5hZGp1c3RYKSB7XG4gICAgICAvLyDlpoLmnpzmqKrlkJHkuI3og73mlL7kuItcbiAgICAgIGlmIChpc0ZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgIC8vIOWvuem9kOS9jee9ruWPjeS4i1xuICAgICAgICB2YXIgbmV3UG9pbnRzID0gZmxpcChwb2ludHMsIC9bbHJdL2lnLCB7XG4gICAgICAgICAgbDogJ3InLFxuICAgICAgICAgIHI6ICdsJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8g5YGP56e76YeP5Lmf5Y+N5LiLXG4gICAgICAgIHZhciBuZXdPZmZzZXQgPSBmbGlwT2Zmc2V0KG9mZnNldCwgMCk7XG4gICAgICAgIHZhciBuZXdUYXJnZXRPZmZzZXQgPSBmbGlwT2Zmc2V0KHRhcmdldE9mZnNldCwgMCk7XG4gICAgICAgIHZhciBuZXdFbEZ1dHVyZVBvcyA9ICgwLCBfZ2V0RWxGdXR1cmVQb3MyWydkZWZhdWx0J10pKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBuZXdQb2ludHMsIG5ld09mZnNldCwgbmV3VGFyZ2V0T2Zmc2V0KTtcbiAgICAgICAgaWYgKCFpc0NvbXBsZXRlRmFpbFgobmV3RWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkpIHtcbiAgICAgICAgICBmYWlsID0gMTtcbiAgICAgICAgICBwb2ludHMgPSBuZXdQb2ludHM7XG4gICAgICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgICAgIHRhcmdldE9mZnNldCA9IG5ld1RhcmdldE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdmVyZmxvdy5hZGp1c3RZKSB7XG4gICAgICAvLyDlpoLmnpznurXlkJHkuI3og73mlL7kuItcbiAgICAgIGlmIChpc0ZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgIC8vIOWvuem9kOS9jee9ruWPjeS4i1xuICAgICAgICB2YXIgbmV3UG9pbnRzID0gZmxpcChwb2ludHMsIC9bdGJdL2lnLCB7XG4gICAgICAgICAgdDogJ2InLFxuICAgICAgICAgIGI6ICd0J1xuICAgICAgICB9KTtcbiAgICAgICAgLy8g5YGP56e76YeP5Lmf5Y+N5LiLXG4gICAgICAgIHZhciBuZXdPZmZzZXQgPSBmbGlwT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgIHZhciBuZXdUYXJnZXRPZmZzZXQgPSBmbGlwT2Zmc2V0KHRhcmdldE9mZnNldCwgMSk7XG4gICAgICAgIHZhciBuZXdFbEZ1dHVyZVBvcyA9ICgwLCBfZ2V0RWxGdXR1cmVQb3MyWydkZWZhdWx0J10pKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBuZXdQb2ludHMsIG5ld09mZnNldCwgbmV3VGFyZ2V0T2Zmc2V0KTtcbiAgICAgICAgaWYgKCFpc0NvbXBsZXRlRmFpbFkobmV3RWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkpIHtcbiAgICAgICAgICBmYWlsID0gMTtcbiAgICAgICAgICBwb2ludHMgPSBuZXdQb2ludHM7XG4gICAgICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgICAgIHRhcmdldE9mZnNldCA9IG5ld1RhcmdldE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIOWmguaenOWksei0pe+8jOmHjeaWsOiuoeeul+W9k+WJjeiKgueCueWwhuimgeiiq+aUvue9rueahOS9jee9rlxuICAgIGlmIChmYWlsKSB7XG4gICAgICBlbEZ1dHVyZVBvcyA9ICgwLCBfZ2V0RWxGdXR1cmVQb3MyWydkZWZhdWx0J10pKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBwb2ludHMsIG9mZnNldCwgdGFyZ2V0T2Zmc2V0KTtcbiAgICAgIF91dGlsczJbJ2RlZmF1bHQnXS5taXgobmV3RWxSZWdpb24sIGVsRnV0dXJlUG9zKTtcbiAgICB9XG5cbiAgICAvLyDmo4Dmn6Xlj43kuIvlkI7nmoTkvY3nva7mmK/lkKblj6/ku6XmlL7kuIvkuoZcbiAgICAvLyDlpoLmnpzku43nhLbmlL7kuI3kuIvlj6rmnInmjIflrprkuoblj6/ku6XosIPmlbTlvZPliY3mlrnlkJHmiY3osIPmlbRcbiAgICBuZXdPdmVyZmxvd0NmZy5hZGp1c3RYID0gb3ZlcmZsb3cuYWRqdXN0WCAmJiBpc0ZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpO1xuXG4gICAgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WSA9IG92ZXJmbG93LmFkanVzdFkgJiYgaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KTtcblxuICAgIC8vIOehruWunuimgeiwg+aVtO+8jOeUmuiHs+WPr+iDveS8muiwg+aVtOmrmOW6puWuveW6plxuICAgIGlmIChuZXdPdmVyZmxvd0NmZy5hZGp1c3RYIHx8IG5ld092ZXJmbG93Q2ZnLmFkanVzdFkpIHtcbiAgICAgIG5ld0VsUmVnaW9uID0gKDAsIF9hZGp1c3RGb3JWaWV3cG9ydDJbJ2RlZmF1bHQnXSkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCwgbmV3T3ZlcmZsb3dDZmcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5lZWQganVkZ2UgdG8gaW4gY2FzZSBzZXQgZml4ZWQgd2l0aCBpbiBjc3Mgb24gaGVpZ2h0IGF1dG8gZWxlbWVudFxuICBpZiAobmV3RWxSZWdpb24ud2lkdGggIT09IGVsUmVnaW9uLndpZHRoKSB7XG4gICAgX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhzb3VyY2UsICd3aWR0aCcsIHNvdXJjZS53aWR0aCgpICsgbmV3RWxSZWdpb24ud2lkdGggLSBlbFJlZ2lvbi53aWR0aCk7XG4gIH1cblxuICBpZiAobmV3RWxSZWdpb24uaGVpZ2h0ICE9PSBlbFJlZ2lvbi5oZWlnaHQpIHtcbiAgICBfdXRpbHMyWydkZWZhdWx0J10uY3NzKHNvdXJjZSwgJ2hlaWdodCcsIHNvdXJjZS5oZWlnaHQoKSArIG5ld0VsUmVnaW9uLmhlaWdodCAtIGVsUmVnaW9uLmhlaWdodCk7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy8xOTBcbiAgLy8gaHR0cDovL2xvY2FsaG9zdDo4ODg4L2tpc3N5L3NyYy9vdmVybGF5L2RlbW8vb3RoZXIvcmVsYXRpdmVfYWxpZ24vYWxpZ24uaHRtbFxuICAvLyDnm7jlr7nkuo7lsY/luZXkvY3nva7msqHlj5jvvIzogIwgbGVmdC90b3Ag5Y+Y5LqGXG4gIC8vIOS+i+WmgiA8ZGl2ICdyZWxhdGl2ZSc+PGVsIGFic29sdXRlPjwvZGl2PlxuICBfdXRpbHMyWydkZWZhdWx0J10ub2Zmc2V0KHNvdXJjZSwge1xuICAgIGxlZnQ6IG5ld0VsUmVnaW9uLmxlZnQsXG4gICAgdG9wOiBuZXdFbFJlZ2lvbi50b3BcbiAgfSwge1xuICAgIHVzZUNzc1JpZ2h0OiBhbGlnbi51c2VDc3NSaWdodCxcbiAgICB1c2VDc3NCb3R0b206IGFsaWduLnVzZUNzc0JvdHRvbVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHBvaW50czogcG9pbnRzLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0LFxuICAgIG92ZXJmbG93OiBuZXdPdmVyZmxvd0NmZ1xuICB9O1xufVxuXG5kb21BbGlnbi5fX2dldE9mZnNldFBhcmVudCA9IF9nZXRPZmZzZXRQYXJlbnQyWydkZWZhdWx0J107XG5cbmRvbUFsaWduLl9fZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50ID0gX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudDJbJ2RlZmF1bHQnXTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZG9tQWxpZ247XG5cbi8qKlxuICogIDIwMTItMDQtMjYgeWltaW5naGVAZ21haWwuY29tXG4gKiAgIC0g5LyY5YyW5pm66IO95a+56b2Q566X5rOVXG4gKiAgIC0g5oWO55SoIHJlc2l6ZVhYXG4gKlxuICogIDIwMTEtMDctMTMgeWltaW5naGVAZ21haWwuY29tIG5vdGU6XG4gKiAgIC0g5aKe5Yqg5pm66IO95a+56b2Q77yM5Lul5Y+K5aSn5bCP6LCD5pW06YCJ6aG5XG4gKiovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIFJFX05VTSA9IC9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2U7XG5cbnZhciBnZXRDb21wdXRlZFN0eWxlWCA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gY3NzKGVsLCBuYW1lLCB2KSB7XG4gIHZhciB2YWx1ZSA9IHY7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNzcyhlbCwgaSwgbmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCc7XG4gICAgfVxuICAgIGVsLnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWwsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRQb3NpdGlvbihlbGVtKSB7XG4gIHZhciBib3ggPSB1bmRlZmluZWQ7XG4gIHZhciB4ID0gdW5kZWZpbmVkO1xuICB2YXIgeSA9IHVuZGVmaW5lZDtcbiAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY0VsZW0gPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8g5qC55o2uIEdCUyDmnIDmlrDmlbDmja7vvIxBLUdyYWRlIEJyb3dzZXJzIOmDveW3suaUr+aMgSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qg5pa55rOV77yM5LiN55So5YaN6ICD6JmR5Lyg57uf55qE5a6e546w5pa55byPXG4gIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8g5rOo77yaalF1ZXJ5IOi/mOiAg+iZkeWHj+WOuyBkb2NFbGVtLmNsaWVudExlZnQvY2xpZW50VG9wXG4gIC8vIOS9hua1i+ivleWPkeeOsO+8jOi/meagt+WPjeiAjOS8muWvvOiHtOW9kyBodG1sIOWSjCBib2R5IOaciei+uei3nS/ovrnmoYbmoLflvI/ml7bvvIzojrflj5bnmoTlgLzkuI3mraPnoa5cbiAgLy8g5q2k5aSW77yMaWU2IOS8muW/veeVpSBodG1sIOeahCBtYXJnaW4g5YC877yM5bm46L+Q5Zyw5piv5rKh5pyJ6LCB5Lya5Y676K6+572uIGh0bWwg55qEIG1hcmdpblxuXG4gIHggPSBib3gubGVmdDtcbiAgeSA9IGJveC50b3A7XG5cbiAgLy8gSW4gSUUsIG1vc3Qgb2YgdGhlIHRpbWUsIDIgZXh0cmEgcGl4ZWxzIGFyZSBhZGRlZCB0byB0aGUgdG9wIGFuZCBsZWZ0XG4gIC8vIGR1ZSB0byB0aGUgaW1wbGljaXQgMi1waXhlbCBpbnNldCBib3JkZXIuICBJbiBJRTYvNyBxdWlya3MgbW9kZSBhbmRcbiAgLy8gSUU2IHN0YW5kYXJkcyBtb2RlLCB0aGlzIGJvcmRlciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoZVxuICAvLyBkb2N1bWVudCBlbGVtZW50J3MgYm9yZGVyIHRvIHplcm8gLS0gdGh1cywgd2UgY2Fubm90IHJlbHkgb24gdGhlXG4gIC8vIG9mZnNldCBhbHdheXMgYmVpbmcgMiBwaXhlbHMuXG5cbiAgLy8gSW4gcXVpcmtzIG1vZGUsIHRoZSBvZmZzZXQgY2FuIGJlIGRldGVybWluZWQgYnkgcXVlcnlpbmcgdGhlIGJvZHknc1xuICAvLyBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IGluIHN0YW5kYXJkcyBtb2RlLCBpdCBpcyBmb3VuZCBieSBxdWVyeWluZ1xuICAvLyB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGNsaWVudExlZnQvY2xpZW50VG9wLiAgU2luY2Ugd2UgYWxyZWFkeSBjYWxsZWRcbiAgLy8gZ2V0Q2xpZW50Qm91bmRpbmdSZWN0IHdlIGhhdmUgYWxyZWFkeSBmb3JjZWQgYSByZWZsb3csIHNvIGl0IGlzIG5vdFxuICAvLyB0b28gZXhwZW5zaXZlIGp1c3QgdG8gcXVlcnkgdGhlbSBhbGwuXG5cbiAgLy8gaWUg5LiL5bqU6K+l5YeP5Y6756qX5Y+j55qE6L655qGG5ZCn77yM5q+V56uf6buY6K6kIGFic29sdXRlIOmDveaYr+ebuOWvueeql+WPo+WumuS9jeeahFxuICAvLyDnqpflj6PovrnmoYbmoIflh4bmmK/orr4gZG9jdW1lbnRFbGVtZW50ICxxdWlya3Mg5pe26K6+572uIGJvZHlcbiAgLy8g5pyA5aW956aB5q2i5ZyoIGJvZHkg5ZKMIGh0bWwg5LiK6L655qGGIO+8jOS9hiBpZSA8IDkgaHRtbCDpu5jorqTmnIkgMnB4IO+8jOWHj+WOu1xuICAvLyDkvYbmmK/pnZ4gaWUg5LiN5Y+v6IO96K6+572u56qX5Y+j6L655qGG77yMYm9keSBodG1sIOS5n+S4jeaYr+eql+WPoyAsaWUg5Y+v5Lul6YCa6L+HIGh0bWwsYm9keSDorr7nva5cbiAgLy8g5qCH5YeGIGllIOS4iyBkb2NFbGVtLmNsaWVudFRvcCDlsLHmmK8gYm9yZGVyLXRvcFxuICAvLyBpZTcgaHRtbCDljbPnqpflj6PovrnmoYbmlLnlj5jkuI3kuobjgILmsLjov5zkuLogMlxuICAvLyDkvYbmoIflh4YgZmlyZWZveC9jaHJvbWUvaWU5IOS4iyBkb2NFbGVtLmNsaWVudFRvcCDmmK/nqpflj6PovrnmoYbvvIzljbPkvb/orr7kuoYgYm9yZGVyLXRvcCDkuZ/kuLogMFxuXG4gIHggLT0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB5IC09IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG5cbiAgcmV0dXJuIHsgbGVmdDogeCwgdG9wOiB5IH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCh3LCB0b3ApIHtcbiAgdmFyIHJldCA9IHdbJ3BhZ2UnICsgKHRvcCA/ICdZJyA6ICdYJykgKyAnT2Zmc2V0J107XG4gIHZhciBtZXRob2QgPSAnc2Nyb2xsJyArICh0b3AgPyAnVG9wJyA6ICdMZWZ0Jyk7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBkID0gdy5kb2N1bWVudDtcbiAgICAvLyBpZTYsNyw4IHN0YW5kYXJkIG1vZGVcbiAgICByZXQgPSBkLmRvY3VtZW50RWxlbWVudFttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gcXVpcmtzIG1vZGVcbiAgICAgIHJldCA9IGQuYm9keVttZXRob2RdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gIHZhciBwb3MgPSBnZXRDbGllbnRQb3NpdGlvbihlbCk7XG4gIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB2YXIgdyA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICBwb3MubGVmdCArPSBnZXRTY3JvbGxMZWZ0KHcpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbFRvcCh3KTtcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG5hbWUsIGNzKSB7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gY3M7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIGQgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIGNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlIHx8IGQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy82MVxuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIF9SRV9OVU1fTk9fUFggPSBuZXcgUmVnRXhwKCdeKCcgKyBSRV9OVU0gKyAnKSg/IXB4KVthLXolXSskJywgJ2knKTtcbnZhciBSRV9QT1MgPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG52YXIgQ1VSUkVOVF9TVFlMRSA9ICdjdXJyZW50U3R5bGUnO1xudmFyIFJVTlRJTUVfU1RZTEUgPSAncnVudGltZVN0eWxlJztcbnZhciBMRUZUID0gJ2xlZnQnO1xudmFyIFBYID0gJ3B4JztcblxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGVJRShlbGVtLCBuYW1lKSB7XG4gIC8vIGN1cnJlbnRTdHlsZSBtYXliZSBudWxsXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNTIzMS5hc3B4XG4gIHZhciByZXQgPSBlbGVtW0NVUlJFTlRfU1RZTEVdICYmIGVsZW1bQ1VSUkVOVF9TVFlMRV1bbmFtZV07XG5cbiAgLy8g5b2TIHdpZHRoL2hlaWdodCDorr7nva7kuLrnmb7liIbmr5Tml7bvvIzpgJrov4cgcGl4ZWxMZWZ0IOaWueW8j+i9rOaNoueahCB3aWR0aC9oZWlnaHQg5YC8XG4gIC8vIOS4gOW8gOWni+WwseWkhOeQhuS6hiEgQ1VTVE9NX1NUWUxFLmhlaWdodCxDVVNUT01fU1RZTEUud2lkdGggLGNzc0hvb2sg6Kej5YazQDIwMTEtMDgtMTlcbiAgLy8g5ZyoIGllIOS4i+S4jeWvue+8jOmcgOimgeebtOaOpeeUqCBvZmZzZXQg5pa55byPXG4gIC8vIGJvcmRlcldpZHRoIOetieWAvOS5n+aciemXrumimO+8jOS9huiAg+iZkeWIsCBib3JkZXJXaWR0aCDorr7kuLrnmb7liIbmr5TnmoTmpoLnjoflvojlsI/vvIzov5nph4zlsLHkuI3ogIPomZHkuoZcblxuICAvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG4gIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAvLyBleGNsdWRlIGxlZnQgcmlnaHQgZm9yIHJlbGF0aXZpdHlcbiAgaWYgKF9SRV9OVU1fTk9fUFgudGVzdChyZXQpICYmICFSRV9QT1MudGVzdChuYW1lKSkge1xuICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIHZhciBsZWZ0ID0gc3R5bGVbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG5cbiAgICAvLyBwcmV2ZW50IGZsYXNoaW5nIG9mIGNvbnRlbnRcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gZWxlbVtDVVJSRU5UX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICBzdHlsZVtMRUZUXSA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFBYO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgIHN0eWxlW0xFRlRdID0gbGVmdDtcblxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSByc0xlZnQ7XG4gIH1cbiAgcmV0dXJuIHJldCA9PT0gJycgPyAnYXV0bycgOiByZXQ7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnZXRDb21wdXRlZFN0eWxlWCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gX2dldENvbXB1dGVkU3R5bGUgOiBfZ2V0Q29tcHV0ZWRTdHlsZUlFO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXREaXJlY3Rpb24oZGlyLCBvcHRpb24pIHtcbiAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgcmV0dXJuIG9wdGlvbi51c2VDc3NSaWdodCA/ICdyaWdodCcgOiBkaXI7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi51c2VDc3NCb3R0b20gPyAnYm90dG9tJyA6IGRpcjtcbn1cblxuZnVuY3Rpb24gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oZGlyKSB7XG4gIGlmIChkaXIgPT09ICdsZWZ0Jykge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKGRpciA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyID09PSAndG9wJykge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfSBlbHNlIGlmIChkaXIgPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9XG59XG5cbi8vIOiuvue9riBlbGVtIOebuOWvuSBlbGVtLm93bmVyRG9jdW1lbnQg55qE5Z2Q5qCHXG5mdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb2Zmc2V0LCBvcHRpb24pIHtcbiAgLy8gc2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICBpZiAoY3NzKGVsZW0sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICB9XG4gIHZhciBwcmVzZXRIID0gLTk5OTtcbiAgdmFyIHByZXNldFYgPSAtOTk5O1xuICB2YXIgaG9yaXpvbnRhbFByb3BlcnR5ID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKCdsZWZ0Jywgb3B0aW9uKTtcbiAgdmFyIHZlcnRpY2FsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oJ3RvcCcsIG9wdGlvbik7XG4gIHZhciBvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKGhvcml6b250YWxQcm9wZXJ0eSk7XG4gIHZhciBvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHkgPSBvcHBvc2l0ZU9mZnNldERpcmVjdGlvbih2ZXJ0aWNhbFByb3BlcnR5KTtcblxuICBpZiAoaG9yaXpvbnRhbFByb3BlcnR5ICE9PSAnbGVmdCcpIHtcbiAgICBwcmVzZXRIID0gOTk5O1xuICB9XG5cbiAgaWYgKHZlcnRpY2FsUHJvcGVydHkgIT09ICd0b3AnKSB7XG4gICAgcHJlc2V0ViA9IDk5OTtcbiAgfVxuXG4gIGlmICgnbGVmdCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eV0gPSAnJztcbiAgICBlbGVtLnN0eWxlW2hvcml6b250YWxQcm9wZXJ0eV0gPSBwcmVzZXRIICsgJ3B4JztcbiAgfVxuICBpZiAoJ3RvcCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHldID0gJyc7XG4gICAgZWxlbS5zdHlsZVt2ZXJ0aWNhbFByb3BlcnR5XSA9IHByZXNldFYgKyAncHgnO1xuICB9XG4gIHZhciBvbGQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgZm9yIChrZXkgaW4gb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgZGlyID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKGtleSwgb3B0aW9uKTtcbiAgICAgIHZhciBwcmVzZXQgPSBrZXkgPT09ICdsZWZ0JyA/IHByZXNldEggOiBwcmVzZXRWO1xuICAgICAgaWYgKGRpciA9PT0ga2V5KSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2Zmc2V0W2tleV0gLSBvbGRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2xkW2tleV0gLSBvZmZzZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3NzKGVsZW0sIHJldCk7XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCb3JkZXJCb3hGbihlbGVtKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94Jztcbn1cblxudmFyIEJPWF9NT0RFTFMgPSBbJ21hcmdpbicsICdib3JkZXInLCAncGFkZGluZyddO1xudmFyIENPTlRFTlRfSU5ERVggPSAtMTtcbnZhciBQQURESU5HX0lOREVYID0gMjtcbnZhciBCT1JERVJfSU5ERVggPSAxO1xudmFyIE1BUkdJTl9JTkRFWCA9IDA7XG5cbmZ1bmN0aW9uIHN3YXAoZWxlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICB2YXIgbmFtZSA9IHVuZGVmaW5lZDtcblxuICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgb2xkW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICBzdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBCTVdpZHRoKGVsZW0sIHByb3BzLCB3aGljaCkge1xuICB2YXIgdmFsdWUgPSAwO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIGogPSB1bmRlZmluZWQ7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICBmb3IgKGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3aGljaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3NzUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3AgPT09ICdib3JkZXInKSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXSArICdXaWR0aCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIGNzc1Byb3ApKSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQSBjcnVkZSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgYW4gb2JqZWN0IGlzIGEgd2luZG93XG4gKiBAbWVtYmVyIHV0aWxcbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8vIG11c3QgdXNlID09IGZvciBpZThcbiAgLyogZXNsaW50IGVxZXFlcTowICovXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqID09IG9iai53aW5kb3c7XG59XG5cbnZhciBkb21VdGlscyA9IHt9O1xuXG5lYWNoKFsnV2lkdGgnLCAnSGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbVV0aWxzWydkb2MnICsgbmFtZV0gPSBmdW5jdGlvbiAocmVmV2luKSB7XG4gICAgdmFyIGQgPSByZWZXaW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC8vIGZpcmVmb3ggY2hyb21lIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgLy8gaWUgc3RhbmRhcmQgbW9kZSA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgZC5kb2N1bWVudEVsZW1lbnRbJ3Njcm9sbCcgKyBuYW1lXSxcbiAgICAvLyBxdWlya3MgOiBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IOacgOWkp+etieS6juWPr+inhueql+WPo+WkmuS4gOeCue+8n1xuICAgIGQuYm9keVsnc2Nyb2xsJyArIG5hbWVdLCBkb21VdGlsc1sndmlld3BvcnQnICsgbmFtZV0oZCkpO1xuICB9O1xuXG4gIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAvLyBwYyBicm93c2VyIGluY2x1ZGVzIHNjcm9sbGJhciBpbiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBwcm9wID0gJ2NsaWVudCcgKyBuYW1lO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50UHJvcCA9IGRvY3VtZW50RWxlbWVudFtwcm9wXTtcbiAgICAvLyDmoIflh4bmqKHlvI/lj5YgZG9jdW1lbnRFbGVtZW50XG4gICAgLy8gYmFja2NvbXBhdCDlj5YgYm9keVxuICAgIHJldHVybiBkb2MuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnICYmIGRvY3VtZW50RWxlbWVudFByb3AgfHwgYm9keSAmJiBib2R5W3Byb3BdIHx8IGRvY3VtZW50RWxlbWVudFByb3A7XG4gIH07XG59KTtcblxuLypcbiDlvpfliLDlhYPntKDnmoTlpKflsI/kv6Hmga9cbiBAcGFyYW0gZWxlbVxuIEBwYXJhbSBuYW1lXG4gQHBhcmFtIHtTdHJpbmd9IFtleHRyYV0gICdwYWRkaW5nJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZ1xuICdib3JkZXInIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nICsgYm9yZGVyXG4gJ21hcmdpbicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXIgKyBtYXJnaW5cbiAqL1xuZnVuY3Rpb24gZ2V0V0goZWxlbSwgbmFtZSwgZXgpIHtcbiAgdmFyIGV4dHJhID0gZXg7XG4gIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMudmlld3BvcnRXaWR0aChlbGVtKSA6IGRvbVV0aWxzLnZpZXdwb3J0SGVpZ2h0KGVsZW0pO1xuICB9IGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3dpZHRoJyA/IGRvbVV0aWxzLmRvY1dpZHRoKGVsZW0pIDogZG9tVXRpbHMuZG9jSGVpZ2h0KGVsZW0pO1xuICB9XG4gIHZhciB3aGljaCA9IG5hbWUgPT09ICd3aWR0aCcgPyBbJ0xlZnQnLCAnUmlnaHQnXSA6IFsnVG9wJywgJ0JvdHRvbSddO1xuICB2YXIgYm9yZGVyQm94VmFsdWUgPSBuYW1lID09PSAnd2lkdGgnID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0sIGNvbXB1dGVkU3R5bGUpO1xuICB2YXIgY3NzQm94VmFsdWUgPSAwO1xuICBpZiAoYm9yZGVyQm94VmFsdWUgPT09IG51bGwgfHwgYm9yZGVyQm94VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBib3JkZXJCb3hWYWx1ZSA8PSAwKSB7XG4gICAgYm9yZGVyQm94VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW4gY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIGNzc0JveFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgbmFtZSk7XG4gICAgaWYgKGNzc0JveFZhbHVlID09PSBudWxsIHx8IGNzc0JveFZhbHVlID09PSB1bmRlZmluZWQgfHwgTnVtYmVyKGNzc0JveFZhbHVlKSA8IDApIHtcbiAgICAgIGNzc0JveFZhbHVlID0gZWxlbS5zdHlsZVtuYW1lXSB8fCAwO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgJycsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgIGNzc0JveFZhbHVlID0gcGFyc2VGbG9hdChjc3NCb3hWYWx1ZSkgfHwgMDtcbiAgfVxuICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhID0gaXNCb3JkZXJCb3ggPyBCT1JERVJfSU5ERVggOiBDT05URU5UX0lOREVYO1xuICB9XG4gIHZhciBib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3ggPSBib3JkZXJCb3hWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGlzQm9yZGVyQm94O1xuICB2YXIgdmFsID0gYm9yZGVyQm94VmFsdWUgfHwgY3NzQm94VmFsdWU7XG4gIGlmIChleHRyYSA9PT0gQ09OVEVOVF9JTkRFWCkge1xuICAgIGlmIChib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3gpIHtcbiAgICAgIHJldHVybiB2YWwgLSBnZXRQQk1XaWR0aChlbGVtLCBbJ2JvcmRlcicsICdwYWRkaW5nJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzc0JveFZhbHVlO1xuICB9IGVsc2UgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgIGlmIChleHRyYSA9PT0gQk9SREVSX0lOREVYKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsICsgKGV4dHJhID09PSBQQURESU5HX0lOREVYID8gLWdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSA6IGdldFBCTVdpZHRoKGVsZW0sIFsnbWFyZ2luJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSk7XG4gIH1cbiAgcmV0dXJuIGNzc0JveFZhbHVlICsgZ2V0UEJNV2lkdGgoZWxlbSwgQk9YX01PREVMUy5zbGljZShleHRyYSksIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbn1cblxudmFyIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB2aXNpYmlsaXR5OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJyB9O1xuXG4vLyBmaXggIzExOSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzExOVxuZnVuY3Rpb24gZ2V0V0hJZ25vcmVEaXNwbGF5KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgdmFsID0gdW5kZWZpbmVkO1xuICB2YXIgZWxlbSA9IGFyZ3NbMF07XG4gIC8vIGluIGNhc2UgZWxlbSBpcyB3aW5kb3dcbiAgLy8gZWxlbS5vZmZzZXRXaWR0aCA9PT0gdW5kZWZpbmVkXG4gIGlmIChlbGVtLm9mZnNldFdpZHRoICE9PSAwKSB7XG4gICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbCA9IGdldFdILmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZWFjaChbJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgZmlyc3QgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgZG9tVXRpbHNbJ291dGVyJyArIGZpcnN0XSA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZU1hcmdpbikge1xuICAgIHJldHVybiBlbCAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWwsIG5hbWUsIGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fSU5ERVggOiBCT1JERVJfSU5ERVgpO1xuICB9O1xuICB2YXIgd2hpY2ggPSBuYW1lID09PSAnd2lkdGgnID8gWydMZWZ0JywgJ1JpZ2h0J10gOiBbJ1RvcCcsICdCb3R0b20nXTtcblxuICBkb21VdGlsc1tuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCB2KSB7XG4gICAgdmFyIHZhbCA9IHY7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgWydwYWRkaW5nJywgJ2JvcmRlciddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyhlbGVtLCBuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW0gJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0sIG5hbWUsIENPTlRFTlRfSU5ERVgpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIG1peCh0bywgZnJvbSkge1xuICBmb3IgKHZhciBpIGluIGZyb20pIHtcbiAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgdG9baV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbnZhciB1dGlscyA9IHtcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUuZG9jdW1lbnQgJiYgbm9kZS5zZXRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgfSxcbiAgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZWwsIHZhbHVlLCBvcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0T2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldE9mZnNldChlbCk7XG4gICAgfVxuICB9LFxuICBpc1dpbmRvdzogaXNXaW5kb3csXG4gIGVhY2g6IGVhY2gsXG4gIGNzczogY3NzLFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmZsb3cgPSBvYmoub3ZlcmZsb3c7XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXQub3ZlcmZsb3dbaV0gPSBvYmoub3ZlcmZsb3dbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgbWl4OiBtaXgsXG4gIGdldFdpbmRvd1Njcm9sbExlZnQ6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbExlZnQodykge1xuICAgIHJldHVybiBnZXRTY3JvbGxMZWZ0KHcpO1xuICB9LFxuICBnZXRXaW5kb3dTY3JvbGxUb3A6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFRvcCh3KSB7XG4gICAgcmV0dXJuIGdldFNjcm9sbFRvcCh3KTtcbiAgfSxcbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciByZXQgPSB7fTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1dGlscy5taXgocmV0LCBhcmdzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgdmlld3BvcnRXaWR0aDogMCxcbiAgdmlld3BvcnRIZWlnaHQ6IDBcbn07XG5cbm1peCh1dGlscywgZG9tVXRpbHMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1dGlscztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0NoaWxkcmVuVXRpbHMgPSByZXF1aXJlKCcuL0NoaWxkcmVuVXRpbHMnKTtcblxudmFyIF9BbmltYXRlQ2hpbGQgPSByZXF1aXJlKCcuL0FuaW1hdGVDaGlsZCcpO1xuXG52YXIgX0FuaW1hdGVDaGlsZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BbmltYXRlQ2hpbGQpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF91dGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGRlZmF1bHRLZXkgPSAncmNfYW5pbWF0ZV8nICsgRGF0ZS5ub3coKTtcblxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgaWYgKF9yZWFjdDJbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGlmICghY2hpbGRyZW4ua2V5KSB7XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7XG4gICAgICAgIGtleTogZGVmYXVsdEtleVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBBbmltYXRlID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0FuaW1hdGUnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNvbXBvbmVudDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmFueSxcbiAgICBhbmltYXRpb246IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vYmplY3QsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5zdHJpbmcsIF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vYmplY3RdKSxcbiAgICB0cmFuc2l0aW9uRW50ZXI6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25BcHBlYXI6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIGV4Y2x1c2l2ZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkxlYXZlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkVuZDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25FbnRlcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25MZWF2ZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25BcHBlYXI6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5mdW5jLFxuICAgIHNob3dQcm9wOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuaW1hdGlvbjoge30sXG4gICAgICBjb21wb25lbnQ6ICdzcGFuJyxcbiAgICAgIHRyYW5zaXRpb25FbnRlcjogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb25MZWF2ZTogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgb25FbmQ6IG5vb3AsXG4gICAgICBvbkVudGVyOiBub29wLFxuICAgICAgb25MZWF2ZTogbm9vcCxcbiAgICAgIG9uQXBwZWFyOiBub29wXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzID0ge307XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHRoaXMucHJvcHMpKVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcDtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAhIWNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIF90aGlzLnBlcmZvcm1BcHBlYXIoY2hpbGQua2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMubmV4dFByb3BzID0gbmV4dFByb3BzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhuZXh0UHJvcHMpKTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIC8vIGV4Y2x1c2l2ZSBuZWVkcyBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICBpZiAocHJvcHMuZXhjbHVzaXZlKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfdGhpczIuc3RvcChrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBzaG93UHJvcCA9IHByb3BzLnNob3dQcm9wO1xuICAgIHZhciBjdXJyZW50bHlBbmltYXRpbmdLZXlzID0gdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzO1xuICAgIC8vIGxhc3QgcHJvcHMgY2hpbGRyZW4gaWYgZXhjbHVzaXZlXG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9IHByb3BzLmV4Y2x1c2l2ZSA/ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSkgOiB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIC8vIGluIGNhc2UgZGVzdHJveSBpbiBzaG93UHJvcCBtb2RlXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gW107XG4gICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICBjdXJyZW50Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudENoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJyZW50Q2hpbGQgJiYgKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBjdXJyZW50Q2hpbGQua2V5KTtcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gdm9pZCAwO1xuICAgICAgICBpZiAoKCFuZXh0Q2hpbGQgfHwgIW5leHRDaGlsZC5wcm9wc1tzaG93UHJvcF0pICYmIGN1cnJlbnRDaGlsZC5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgICBuZXdDaGlsZCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChuZXh0Q2hpbGQgfHwgY3VycmVudENoaWxkLCBfZGVmaW5lUHJvcGVydHkoe30sIHNob3dQcm9wLCB0cnVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV4dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5leHRDaGlsZCkge1xuICAgICAgICBpZiAoIW5leHRDaGlsZCB8fCAhKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV4dENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLm1lcmdlQ2hpbGRyZW4pKGN1cnJlbnRDaGlsZHJlbiwgbmV4dENoaWxkcmVuKTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHJlbmRlciB0byBhdm9pZCB1cGRhdGVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlblxuICAgIH0pO1xuXG4gICAgbmV4dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIga2V5ID0gY2hpbGQgJiYgY2hpbGQua2V5O1xuICAgICAgaWYgKGNoaWxkICYmIGN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGFzUHJldiA9IGNoaWxkICYmICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5KTtcbiAgICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgICB2YXIgc2hvd0luTmV4dCA9IGNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgICAgaWYgKGhhc1ByZXYpIHtcbiAgICAgICAgICB2YXIgc2hvd0luTm93ID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIGtleSwgc2hvd1Byb3ApO1xuICAgICAgICAgIGlmICghc2hvd0luTm93ICYmIHNob3dJbk5leHQpIHtcbiAgICAgICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNob3dJbk5leHQpIHtcbiAgICAgICAgICBfdGhpczIua2V5c1RvRW50ZXIucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoYXNQcmV2KSB7XG4gICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjdXJyZW50Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBjaGlsZCAmJiBjaGlsZC5rZXk7XG4gICAgICBpZiAoY2hpbGQgJiYgY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNOZXh0ID0gY2hpbGQgJiYgKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBrZXkpO1xuICAgICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICAgIHZhciBzaG93SW5Ob3cgPSBjaGlsZC5wcm9wc1tzaG93UHJvcF07XG4gICAgICAgIGlmIChoYXNOZXh0KSB7XG4gICAgICAgICAgdmFyIHNob3dJbk5leHQgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKG5leHRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgICAgICAgaWYgKCFzaG93SW5OZXh0ICYmIHNob3dJbk5vdykge1xuICAgICAgICAgICAgX3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvd0luTm93KSB7XG4gICAgICAgICAgX3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaGFzTmV4dCkge1xuICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB2YXIga2V5c1RvRW50ZXIgPSB0aGlzLmtleXNUb0VudGVyO1xuICAgIHRoaXMua2V5c1RvRW50ZXIgPSBbXTtcbiAgICBrZXlzVG9FbnRlci5mb3JFYWNoKHRoaXMucGVyZm9ybUVudGVyKTtcbiAgICB2YXIga2V5c1RvTGVhdmUgPSB0aGlzLmtleXNUb0xlYXZlO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgICBrZXlzVG9MZWF2ZS5mb3JFYWNoKHRoaXMucGVyZm9ybUxlYXZlKTtcbiAgfSxcbiAgcGVyZm9ybUVudGVyOiBmdW5jdGlvbiBwZXJmb3JtRW50ZXIoa2V5KSB7XG4gICAgLy8gbWF5IGFscmVhZHkgcmVtb3ZlIGJ5IGV4Y2x1c2l2ZVxuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEVudGVyKHRoaXMuaGFuZGxlRG9uZUFkZGluZy5iaW5kKHRoaXMsIGtleSwgJ2VudGVyJykpO1xuICAgIH1cbiAgfSxcbiAgcGVyZm9ybUFwcGVhcjogZnVuY3Rpb24gcGVyZm9ybUFwcGVhcihrZXkpIHtcbiAgICBpZiAodGhpcy5yZWZzW2tleV0pIHtcbiAgICAgIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVmc1trZXldLmNvbXBvbmVudFdpbGxBcHBlYXIodGhpcy5oYW5kbGVEb25lQWRkaW5nLmJpbmQodGhpcywga2V5LCAnYXBwZWFyJykpO1xuICAgIH1cbiAgfSxcbiAgaGFuZGxlRG9uZUFkZGluZzogZnVuY3Rpb24gaGFuZGxlRG9uZUFkZGluZyhrZXksIHR5cGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XTtcbiAgICAvLyBpZiB1cGRhdGUgb24gZXhjbHVzaXZlIG1vZGUsIHNraXAgY2hlY2tcbiAgICBpZiAocHJvcHMuZXhjbHVzaXZlICYmIHByb3BzICE9PSB0aGlzLm5leHRQcm9wcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VycmVudENoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpKTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpKSB7XG4gICAgICAvLyBleGNsdXNpdmUgd2lsbCBub3QgbmVlZCB0aGlzXG4gICAgICB0aGlzLnBlcmZvcm1MZWF2ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2FwcGVhcicpIHtcbiAgICAgICAgaWYgKF91dGlsMltcImRlZmF1bHRcIl0uYWxsb3dBcHBlYXJDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgICBwcm9wcy5vbkFwcGVhcihrZXkpO1xuICAgICAgICAgIHByb3BzLm9uRW5kKGtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdXRpbDJbXCJkZWZhdWx0XCJdLmFsbG93RW50ZXJDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgICBwcm9wcy5vbkVudGVyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGVyZm9ybUxlYXZlOiBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoa2V5KSB7XG4gICAgLy8gbWF5IGFscmVhZHkgcmVtb3ZlIGJ5IGV4Y2x1c2l2ZVxuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbExlYXZlKHRoaXMuaGFuZGxlRG9uZUxlYXZpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9XG4gIH0sXG4gIGhhbmRsZURvbmVMZWF2aW5nOiBmdW5jdGlvbiBoYW5kbGVEb25lTGVhdmluZyhrZXkpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XTtcbiAgICAvLyBpZiB1cGRhdGUgb24gZXhjbHVzaXZlIG1vZGUsIHNraXAgY2hlY2tcbiAgICBpZiAocHJvcHMuZXhjbHVzaXZlICYmIHByb3BzICE9PSB0aGlzLm5leHRQcm9wcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VycmVudENoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpKTtcbiAgICAvLyBpbiBjYXNlIHN0YXRlIGNoYW5nZSBpcyB0b28gZmFzdFxuICAgIGlmICh0aGlzLmlzVmFsaWRDaGlsZEJ5S2V5KGN1cnJlbnRDaGlsZHJlbiwga2V5KSkge1xuICAgICAgdGhpcy5wZXJmb3JtRW50ZXIoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZCA9IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgICAgaWYgKF91dGlsMltcImRlZmF1bHRcIl0uYWxsb3dMZWF2ZUNhbGxiYWNrKHByb3BzKSkge1xuICAgICAgICAgIHByb3BzLm9uTGVhdmUoa2V5KTtcbiAgICAgICAgICBwcm9wcy5vbkVuZChrZXksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qIGVzbGludCByZWFjdC9uby1pcy1tb3VudGVkOjAgKi9cbiAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmICEoMCwgX0NoaWxkcmVuVXRpbHMuaXNTYW1lQ2hpbGRyZW4pKHRoaXMuc3RhdGUuY2hpbGRyZW4sIGN1cnJlbnRDaGlsZHJlbiwgcHJvcHMuc2hvd1Byb3ApKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGNoaWxkcmVuOiBjdXJyZW50Q2hpbGRyZW5cbiAgICAgICAgfSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNWYWxpZENoaWxkQnlLZXk6IGZ1bmN0aW9uIGlzVmFsaWRDaGlsZEJ5S2V5KGN1cnJlbnRDaGlsZHJlbiwga2V5KSB7XG4gICAgdmFyIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcDtcbiAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgIHJldHVybiAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIGtleSk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3Aoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldO1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBjb21wb25lbnQuc3RvcCgpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLm5leHRQcm9wcyA9IHByb3BzO1xuICAgIHZhciBzdGF0ZUNoaWxkcmVuID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICAgIGlmIChzdGF0ZUNoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbiA9IHN0YXRlQ2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkLmtleSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzZXQga2V5IGZvciA8cmMtYW5pbWF0ZT4gY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfQW5pbWF0ZUNoaWxkMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgICAgICByZWY6IGNoaWxkLmtleSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogcHJvcHMuYW5pbWF0aW9uLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVudGVyOiBwcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiBwcm9wcy50cmFuc2l0aW9uQXBwZWFyLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkxlYXZlOiBwcm9wcy50cmFuc2l0aW9uTGVhdmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIENvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudDtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFzc2VkUHJvcHMgPSBwcm9wcztcbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXNzZWRQcm9wcyA9IHtcbiAgICAgICAgICBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZTogcHJvcHMuc3R5bGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHBhc3NlZFByb3BzLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEFuaW1hdGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfY3NzQW5pbWF0aW9uID0gcmVxdWlyZSgnY3NzLWFuaW1hdGlvbicpO1xuXG52YXIgX2Nzc0FuaW1hdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NBbmltYXRpb24pO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF91dGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIHRyYW5zaXRpb25NYXAgPSB7XG4gIGVudGVyOiAndHJhbnNpdGlvbkVudGVyJyxcbiAgYXBwZWFyOiAndHJhbnNpdGlvbkFwcGVhcicsXG4gIGxlYXZlOiAndHJhbnNpdGlvbkxlYXZlJ1xufTtcblxudmFyIEFuaW1hdGVDaGlsZCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdBbmltYXRlQ2hpbGQnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNoaWxkcmVuOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICB9LFxuICBjb21wb25lbnRXaWxsRW50ZXI6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxFbnRlcihkb25lKSB7XG4gICAgaWYgKF91dGlsMltcImRlZmF1bHRcIl0uaXNFbnRlclN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdlbnRlcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsQXBwZWFyOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsQXBwZWFyKGRvbmUpIHtcbiAgICBpZiAoX3V0aWwyW1wiZGVmYXVsdFwiXS5pc0FwcGVhclN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdhcHBlYXInLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbExlYXZlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTGVhdmUoZG9uZSkge1xuICAgIGlmIChfdXRpbDJbXCJkZWZhdWx0XCJdLmlzTGVhdmVTdXBwb3J0ZWQodGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignbGVhdmUnLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWx3YXlzIHN5bmMsIGRvIG5vdCBpbnRlcnVwdCB3aXRoIHJlYWN0IGNvbXBvbmVudCBsaWZlIGN5Y2xlXG4gICAgICAvLyB1cGRhdGUgaGlkZGVuIC0+IGFuaW1hdGUgaGlkZGVuIC0+XG4gICAgICAvLyBkaWRVcGRhdGUgLT4gYW5pbWF0ZSBsZWF2ZSAtPiB1bm1vdW50IChpZiBhbmltYXRlIGlzIG5vbmUpXG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKGFuaW1hdGlvblR5cGUsIGZpbmlzaENhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBub2RlID0gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50cmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgbmFtZUlzT2JqID0gKHR5cGVvZiB0cmFuc2l0aW9uTmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHJhbnNpdGlvbk5hbWUpKSA9PT0gJ29iamVjdCc7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIF90aGlzLnN0b3BwZXIgPSBudWxsO1xuICAgICAgZmluaXNoQ2FsbGJhY2soKTtcbiAgICB9O1xuICAgIGlmICgoX2Nzc0FuaW1hdGlvbi5pc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCB8fCAhcHJvcHMuYW5pbWF0aW9uW2FuaW1hdGlvblR5cGVdKSAmJiB0cmFuc2l0aW9uTmFtZSAmJiBwcm9wc1t0cmFuc2l0aW9uTWFwW2FuaW1hdGlvblR5cGVdXSkge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lSXNPYmogPyB0cmFuc2l0aW9uTmFtZVthbmltYXRpb25UeXBlXSA6IHRyYW5zaXRpb25OYW1lICsgJy0nICsgYW5pbWF0aW9uVHlwZTtcbiAgICAgIHRoaXMuc3RvcHBlciA9ICgwLCBfY3NzQW5pbWF0aW9uMltcImRlZmF1bHRcIl0pKG5vZGUsIG5hbWUsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcHBlciA9IHByb3BzLmFuaW1hdGlvblthbmltYXRpb25UeXBlXShub2RlLCBlbmQpO1xuICAgIH1cbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgc3RvcHBlciA9IHRoaXMuc3RvcHBlcjtcbiAgICBpZiAoc3RvcHBlcikge1xuICAgICAgdGhpcy5zdG9wcGVyID0gbnVsbDtcbiAgICAgIHN0b3BwZXIuc3RvcCgpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEFuaW1hdGVDaGlsZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudG9BcnJheUNoaWxkcmVuID0gdG9BcnJheUNoaWxkcmVuO1xuZXhwb3J0cy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkgPSBmaW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXk7XG5leHBvcnRzLmZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5ID0gZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXk7XG5leHBvcnRzLmZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleSA9IGZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuaXNTYW1lQ2hpbGRyZW4gPSBpc1NhbWVDaGlsZHJlbjtcbmV4cG9ydHMubWVyZ2VDaGlsZHJlbiA9IG1lcmdlQ2hpbGRyZW47XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvQXJyYXlDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgcmV0ID0gW107XG4gIF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5KSB7XG4gIHZhciByZXQgPSBudWxsO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQgJiYgY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0ID0gY2hpbGQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkoY2hpbGRyZW4sIGtleSwgc2hvd1Byb3ApIHtcbiAgdmFyIHJldCA9IG51bGw7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgJiYgY2hpbGQua2V5ID09PSBrZXkgJiYgY2hpbGQucHJvcHNbc2hvd1Byb3BdKSB7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R3byBjaGlsZCB3aXRoIHNhbWUga2V5IGZvciA8cmMtYW5pbWF0ZT4gY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaW5kSGlkZGVuQ2hpbGRJbkNoaWxkcmVuQnlLZXkoY2hpbGRyZW4sIGtleSwgc2hvd1Byb3ApIHtcbiAgdmFyIGZvdW5kID0gMDtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3VuZCA9IGNoaWxkICYmIGNoaWxkLmtleSA9PT0ga2V5ICYmICFjaGlsZC5wcm9wc1tzaG93UHJvcF07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZHJlbihjMSwgYzIsIHNob3dQcm9wKSB7XG4gIHZhciBzYW1lID0gYzEubGVuZ3RoID09PSBjMi5sZW5ndGg7XG4gIGlmIChzYW1lKSB7XG4gICAgYzEuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICB2YXIgY2hpbGQyID0gYzJbaW5kZXhdO1xuICAgICAgaWYgKGNoaWxkICYmIGNoaWxkMikge1xuICAgICAgICBpZiAoY2hpbGQgJiYgIWNoaWxkMiB8fCAhY2hpbGQgJiYgY2hpbGQyKSB7XG4gICAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmtleSAhPT0gY2hpbGQyLmtleSkge1xuICAgICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG93UHJvcCAmJiBjaGlsZC5wcm9wc1tzaG93UHJvcF0gIT09IGNoaWxkMi5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgICBzYW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2FtZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbihwcmV2LCBuZXh0KSB7XG4gIHZhciByZXQgPSBbXTtcblxuICAvLyBGb3IgZWFjaCBrZXkgb2YgYG5leHRgLCB0aGUgbGlzdCBvZiBrZXlzIHRvIGluc2VydCBiZWZvcmUgdGhhdCBrZXkgaW5cbiAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcbiAgdmFyIG5leHRDaGlsZHJlblBlbmRpbmcgPSB7fTtcbiAgdmFyIHBlbmRpbmdDaGlsZHJlbiA9IFtdO1xuICBwcmV2LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleShuZXh0LCBjaGlsZC5rZXkpKSB7XG4gICAgICBpZiAocGVuZGluZ0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW5QZW5kaW5nW2NoaWxkLmtleV0gPSBwZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgIHBlbmRpbmdDaGlsZHJlbiA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9KTtcblxuICBuZXh0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIG5leHRDaGlsZHJlblBlbmRpbmcuaGFzT3duUHJvcGVydHkoY2hpbGQua2V5KSkge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChuZXh0Q2hpbGRyZW5QZW5kaW5nW2NoaWxkLmtleV0pO1xuICAgIH1cbiAgICByZXQucHVzaChjaGlsZCk7XG4gIH0pO1xuXG4gIHJldCA9IHJldC5jb25jYXQocGVuZGluZ0NoaWxkcmVuKTtcblxuICByZXR1cm4gcmV0O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLy8gZXhwb3J0IHRoaXMgcGFja2FnZSdzIGFwaVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0FuaW1hdGUnKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciB1dGlsID0ge1xuICBpc0FwcGVhclN1cHBvcnRlZDogZnVuY3Rpb24gaXNBcHBlYXJTdXBwb3J0ZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMudHJhbnNpdGlvbkFwcGVhciB8fCBwcm9wcy5hbmltYXRpb24uYXBwZWFyO1xuICB9LFxuICBpc0VudGVyU3VwcG9ydGVkOiBmdW5jdGlvbiBpc0VudGVyU3VwcG9ydGVkKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zaXRpb25OYW1lICYmIHByb3BzLnRyYW5zaXRpb25FbnRlciB8fCBwcm9wcy5hbmltYXRpb24uZW50ZXI7XG4gIH0sXG4gIGlzTGVhdmVTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzTGVhdmVTdXBwb3J0ZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMudHJhbnNpdGlvbkxlYXZlIHx8IHByb3BzLmFuaW1hdGlvbi5sZWF2ZTtcbiAgfSxcbiAgYWxsb3dBcHBlYXJDYWxsYmFjazogZnVuY3Rpb24gYWxsb3dBcHBlYXJDYWxsYmFjayhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uQXBwZWFyIHx8IHByb3BzLmFuaW1hdGlvbi5hcHBlYXI7XG4gIH0sXG4gIGFsbG93RW50ZXJDYWxsYmFjazogZnVuY3Rpb24gYWxsb3dFbnRlckNhbGxiYWNrKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zaXRpb25FbnRlciB8fCBwcm9wcy5hbmltYXRpb24uZW50ZXI7XG4gIH0sXG4gIGFsbG93TGVhdmVDYWxsYmFjazogZnVuY3Rpb24gYWxsb3dMZWF2ZUNhbGxiYWNrKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zaXRpb25MZWF2ZSB8fCBwcm9wcy5hbmltYXRpb24ubGVhdmU7XG4gIH1cbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHV0aWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb25lbmQ6IHtcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIE1velRyYW5zaXRpb246ICdtb3pUcmFuc2l0aW9uRW5kJyxcbiAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICBtc1RyYW5zaXRpb246ICdNU1RyYW5zaXRpb25FbmQnXG4gIH0sXG5cbiAgYW5pbWF0aW9uZW5kOiB7XG4gICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcbiAgICBXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIE1vekFuaW1hdGlvbjogJ21vekFuaW1hdGlvbkVuZCcsXG4gICAgT0FuaW1hdGlvbjogJ29BbmltYXRpb25FbmQnLFxuICAgIG1zQW5pbWF0aW9uOiAnTVNBbmltYXRpb25FbmQnXG4gIH1cbn07XG5cbnZhciBlbmRFdmVudHMgPSBbXTtcblxuZnVuY3Rpb24gZGV0ZWN0RXZlbnRzKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgfVxuXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG5cbiAgZm9yICh2YXIgYmFzZUV2ZW50TmFtZSBpbiBFVkVOVF9OQU1FX01BUCkge1xuICAgIGlmIChFVkVOVF9OQU1FX01BUC5oYXNPd25Qcm9wZXJ0eShiYXNlRXZlbnROYW1lKSkge1xuICAgICAgdmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcbiAgICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBiYXNlRXZlbnRzKSB7XG4gICAgICAgIGlmIChzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICBlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRldGVjdEV2ZW50cygpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxudmFyIFRyYW5zaXRpb25FdmVudHMgPSB7XG4gIGFkZEVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuXG4gIGVuZEV2ZW50czogZW5kRXZlbnRzLFxuXG4gIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJhbnNpdGlvbkV2ZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9FdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcblxudmFyIF9FdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudCk7XG5cbnZhciBfY29tcG9uZW50Q2xhc3NlcyA9IHJlcXVpcmUoJ2NvbXBvbmVudC1jbGFzc2VzJyk7XG5cbnZhciBfY29tcG9uZW50Q2xhc3NlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRDbGFzc2VzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBpc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCA9IF9FdmVudDJbXCJkZWZhdWx0XCJdLmVuZEV2ZW50cy5sZW5ndGggIT09IDA7XG5cblxudmFyIGNhcGl0YWxQcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdPJyxcbi8vIG1zIGlzIHNwZWNpYWwgLi4uLiAhXG4nbXMnXTtcbnZhciBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJywgJ21zLScsICcnXTtcblxuZnVuY3Rpb24gZ2V0RHVyYXRpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICB2YXIgcmV0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZXQgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVzW2ldICsgbmFtZSk7XG4gICAgaWYgKHJldCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpeEJyb3dzZXJCeVRpbWVvdXQobm9kZSkge1xuICBpZiAoaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdChnZXREdXJhdGlvbihub2RlLCAndHJhbnNpdGlvbi1kdXJhdGlvbicpKSB8fCAwO1xuICAgIHZhciBhbmltYXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2V0RHVyYXRpb24obm9kZSwgJ2FuaW1hdGlvbi1kdXJhdGlvbicpKSB8fCAwO1xuICAgIHZhciB0aW1lID0gTWF0aC5tYXgodHJhbnNpdGlvbkR1cmF0aW9uLCBhbmltYXRpb25EdXJhdGlvbik7XG4gICAgLy8gc29tZXRpbWVzLCBicm93c2VyIGJ1Z1xuICAgIG5vZGUucmNFbmRBbmltVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5yY0VuZEFuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChub2RlLnJjRW5kTGlzdGVuZXIpIHtcbiAgICAgICAgbm9kZS5yY0VuZExpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSwgdGltZSAqIDEwMDAgKyAyMDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFyQnJvd3NlckJ1Z1RpbWVvdXQobm9kZSkge1xuICBpZiAobm9kZS5yY0VuZEFuaW1UaW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KG5vZGUucmNFbmRBbmltVGltZW91dCk7XG4gICAgbm9kZS5yY0VuZEFuaW1UaW1lb3V0ID0gbnVsbDtcbiAgfVxufVxuXG52YXIgY3NzQW5pbWF0aW9uID0gZnVuY3Rpb24gY3NzQW5pbWF0aW9uKG5vZGUsIHRyYW5zaXRpb25OYW1lLCBlbmRDYWxsYmFjaykge1xuICB2YXIgY2xhc3NOYW1lID0gdHJhbnNpdGlvbk5hbWU7XG4gIHZhciBhY3RpdmVDbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLWFjdGl2ZSc7XG4gIHZhciBlbmQgPSBlbmRDYWxsYmFjaztcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgYWN0aXZlID0gdm9pZCAwO1xuICB2YXIgbm9kZUNsYXNzZXMgPSAoMCwgX2NvbXBvbmVudENsYXNzZXMyW1wiZGVmYXVsdFwiXSkobm9kZSk7XG5cbiAgaWYgKGVuZENhbGxiYWNrICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbmRDYWxsYmFjaykgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgZW5kID0gZW5kQ2FsbGJhY2suZW5kO1xuICAgIHN0YXJ0ID0gZW5kQ2FsbGJhY2suc3RhcnQ7XG4gICAgYWN0aXZlID0gZW5kQ2FsbGJhY2suYWN0aXZlO1xuICB9XG5cbiAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICB9XG5cbiAgbm9kZS5yY0VuZExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJjQW5pbVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChub2RlLnJjQW5pbVRpbWVvdXQpO1xuICAgICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGVhckJyb3dzZXJCdWdUaW1lb3V0KG5vZGUpO1xuXG4gICAgbm9kZUNsYXNzZXMucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgbm9kZUNsYXNzZXMucmVtb3ZlKGFjdGl2ZUNsYXNzTmFtZSk7XG5cbiAgICBfRXZlbnQyW1wiZGVmYXVsdFwiXS5yZW1vdmVFbmRFdmVudExpc3RlbmVyKG5vZGUsIG5vZGUucmNFbmRMaXN0ZW5lcik7XG4gICAgbm9kZS5yY0VuZExpc3RlbmVyID0gbnVsbDtcblxuICAgIC8vIFVzdWFsbHkgdGhpcyBvcHRpb25hbCBlbmQgaXMgdXNlZCBmb3IgaW5mb3JtaW5nIGFuIG93bmVyIG9mXG4gICAgLy8gYSBsZWF2ZSBhbmltYXRpb24gYW5kIHRlbGxpbmcgaXQgdG8gcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICBpZiAoZW5kKSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgX0V2ZW50MltcImRlZmF1bHRcIl0uYWRkRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBub2RlLnJjRW5kTGlzdGVuZXIpO1xuXG4gIGlmIChzdGFydCkge1xuICAgIHN0YXJ0KCk7XG4gIH1cbiAgbm9kZUNsYXNzZXMuYWRkKGNsYXNzTmFtZSk7XG5cbiAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICBub2RlQ2xhc3Nlcy5hZGQoYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBzZXRUaW1lb3V0KGFjdGl2ZSwgMCk7XG4gICAgfVxuICAgIGZpeEJyb3dzZXJCeVRpbWVvdXQobm9kZSk7XG4gICAgLy8gMzBtcyBmb3IgZmlyZWZveFxuICB9LCAzMCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5jc3NBbmltYXRpb24uc3R5bGUgPSBmdW5jdGlvbiAobm9kZSwgc3R5bGUsIGNhbGxiYWNrKSB7XG4gIGlmIChub2RlLnJjRW5kTGlzdGVuZXIpIHtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgfVxuXG4gIG5vZGUucmNFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5yY0FuaW1UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQobm9kZS5yY0FuaW1UaW1lb3V0KTtcbiAgICAgIG5vZGUucmNBbmltVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKTtcblxuICAgIF9FdmVudDJbXCJkZWZhdWx0XCJdLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgLy8gVXN1YWxseSB0aGlzIG9wdGlvbmFsIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGluZm9ybWluZyBhbiBvd25lciBvZlxuICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfRXZlbnQyW1wiZGVmYXVsdFwiXS5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIG5vZGUucmNFbmRMaXN0ZW5lcik7XG5cbiAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyBpbiBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc10gPSBzdHlsZVtzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICBmaXhCcm93c2VyQnlUaW1lb3V0KG5vZGUpO1xuICB9LCAwKTtcbn07XG5cbmNzc0FuaW1hdGlvbi5zZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHAsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eSA9IHA7XG4gIHZhciB2ID0gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IHByb3BlcnR5O1xuICAgIHByb3BlcnR5ID0gJyc7XG4gIH1cbiAgcHJvcGVydHkgPSBwcm9wZXJ0eSB8fCAnJztcbiAgY2FwaXRhbFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIG5vZGUuc3R5bGVbcHJlZml4ICsgJ1RyYW5zaXRpb24nICsgcHJvcGVydHldID0gdjtcbiAgfSk7XG59O1xuXG5jc3NBbmltYXRpb24uaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgPSBpc0Nzc0FuaW1hdGlvblN1cHBvcnRlZDtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjc3NBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudHJ5IHtcbiAgdmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xufSBjYXRjaCAoZXJyKSB7XG4gIHZhciBpbmRleCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmRleG9mJyk7XG59XG5cbi8qKlxuICogV2hpdGVzcGFjZSByZWdleHAuXG4gKi9cblxudmFyIHJlID0gL1xccysvO1xuXG4vKipcbiAqIHRvU3RyaW5nIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdyYXAgYGVsYCBpbiBhIGBDbGFzc0xpc3RgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCl7XG4gIHJldHVybiBuZXcgQ2xhc3NMaXN0KGVsKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBDbGFzc0xpc3QgZm9yIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICghfmkpIGFyci5wdXNoKG5hbWUpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2xhc3MgYG5hbWVgIHdoZW4gcHJlc2VudCwgb3JcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXG4gKiBhbnkgd2hpY2ggbWF0Y2guXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSl7XG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XG4gIH1cblxuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICh+aSkgYXJyLnNwbGljZShpLCAxKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpe1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgY2xhc3MgYG5hbWVgLCBjYW4gZm9yY2Ugc3RhdGUgdmlhIGBmb3JjZWAuXG4gKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcbiAqIHRoZSBtaXN0YWtlIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGNvcnJlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKXtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XG4gICAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICB2YXIgc3RyID0gY2xhc3NOYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgdmFyIGFyciA9IHN0ci5zcGxpdChyZSk7XG4gIGlmICgnJyA9PT0gYXJyWzBdKSBhcnIuc2hpZnQoKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgY2xhc3MgYG5hbWVgIGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPVxuQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gdGhpcy5saXN0XG4gICAgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSlcbiAgICA6ICEhIH5pbmRleCh0aGlzLmFycmF5KCksIG5hbWUpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoYXJyLmluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gYWRkRXZlbnRMaXN0ZW5lcldyYXA7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9hZGREb21FdmVudExpc3RlbmVyID0gcmVxdWlyZSgnYWRkLWRvbS1ldmVudC1saXN0ZW5lcicpO1xuXG52YXIgX2FkZERvbUV2ZW50TGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkRG9tRXZlbnRMaXN0ZW5lcik7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJXcmFwKHRhcmdldCwgZXZlbnRUeXBlLCBjYikge1xuICAvKiBlc2xpbnQgY2FtZWxjYXNlOiAyICovXG4gIHZhciBjYWxsYmFjayA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/IGZ1bmN0aW9uIHJ1bihlKSB7XG4gICAgX3JlYWN0RG9tMlsnZGVmYXVsdCddLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGNiLCBlKTtcbiAgfSA6IGNiO1xuICByZXR1cm4gKDAsIF9hZGREb21FdmVudExpc3RlbmVyMlsnZGVmYXVsdCddKSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb250YWlucyhyb290LCBuKSB7XG4gIHZhciBub2RlID0gbjtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyIsIi8qKlxuICogU2FmZSBjaGFpbmVkIGZ1bmN0aW9uXG4gKlxuICogV2lsbCBvbmx5IGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBpZiBuZWVkZWQsXG4gKiBvdGhlcndpc2Ugd2lsbCBwYXNzIGJhY2sgZXhpc3RpbmcgZnVuY3Rpb25zIG9yIG51bGwuXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufG51bGx9XG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ3NbaV0gJiYgYXJnc1tpXS5hcHBseSkge1xuICAgICAgICBhcmdzW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbjsiLCIvKipcbiAqIEBpZ25vcmVcbiAqIGJhc2UgZXZlbnQgb2JqZWN0IGZvciBjdXN0b20gYW5kIGRvbSBldmVudC5cbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRCYXNlT2JqZWN0KCkge1xuICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbkV2ZW50QmFzZU9iamVjdC5wcm90b3R5cGUgPSB7XG4gIGlzRXZlbnRPYmplY3Q6IDEsXG5cbiAgY29uc3RydWN0b3I6IEV2ZW50QmFzZU9iamVjdCxcblxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgfSxcblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAvLyBmaXhlZCAxLjJcbiAgICAvLyBjYWxsIHN0b3BQcm9wYWdhdGlvbiBpbXBsaWNpdGx5XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICBoYWx0OiBmdW5jdGlvbiBoYWx0KGltbWVkaWF0ZSkge1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIHRoaXMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFdmVudEJhc2VPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIi8qKlxuICogQGlnbm9yZVxuICogZXZlbnQgb2JqZWN0IGZvciBkb21cbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0V2ZW50QmFzZU9iamVjdCA9IHJlcXVpcmUoJy4vRXZlbnRCYXNlT2JqZWN0Jyk7XG5cbnZhciBfRXZlbnRCYXNlT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50QmFzZU9iamVjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgVFJVRSA9IHRydWU7XG52YXIgRkFMU0UgPSBmYWxzZTtcbnZhciBjb21tb25Qcm9wcyA9IFsnYWx0S2V5JywgJ2J1YmJsZXMnLCAnY2FuY2VsYWJsZScsICdjdHJsS2V5JywgJ2N1cnJlbnRUYXJnZXQnLCAnZXZlbnRQaGFzZScsICdtZXRhS2V5JywgJ3NoaWZ0S2V5JywgJ3RhcmdldCcsICd0aW1lU3RhbXAnLCAndmlldycsICd0eXBlJ107XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHcpIHtcbiAgcmV0dXJuIHcgPT09IG51bGwgfHwgdyA9PT0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnROb3JtYWxpemVycyA9IFt7XG4gIHJlZzogL15rZXkvLFxuICBwcm9wczogWydjaGFyJywgJ2NoYXJDb2RlJywgJ2tleScsICdrZXlDb2RlJywgJ3doaWNoJ10sXG4gIGZpeDogZnVuY3Rpb24gZml4KGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChldmVudC53aGljaCkpIHtcbiAgICAgIGV2ZW50LndoaWNoID0gIWlzTnVsbE9yVW5kZWZpbmVkKG5hdGl2ZUV2ZW50LmNoYXJDb2RlKSA/IG5hdGl2ZUV2ZW50LmNoYXJDb2RlIDogbmF0aXZlRXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbWV0YUtleSB0byBub24tTWFjIGJyb3dzZXJzICh1c2UgY3RybCBmb3IgUEMgJ3MgYW5kIE1ldGEgZm9yIE1hY3MpXG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXZlbnQubWV0YUtleSA9IGV2ZW50LmN0cmxLZXk7XG4gICAgfVxuICB9XG59LCB7XG4gIHJlZzogL150b3VjaC8sXG4gIHByb3BzOiBbJ3RvdWNoZXMnLCAnY2hhbmdlZFRvdWNoZXMnLCAndGFyZ2V0VG91Y2hlcyddXG59LCB7XG4gIHJlZzogL15oYXNoY2hhbmdlJC8sXG4gIHByb3BzOiBbJ25ld1VSTCcsICdvbGRVUkwnXVxufSwge1xuICByZWc6IC9eZ2VzdHVyZWNoYW5nZSQvaSxcbiAgcHJvcHM6IFsncm90YXRpb24nLCAnc2NhbGUnXVxufSwge1xuICByZWc6IC9eKG1vdXNld2hlZWx8RE9NTW91c2VTY3JvbGwpJC8sXG4gIHByb3BzOiBbXSxcbiAgZml4OiBmdW5jdGlvbiBmaXgoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIGRlbHRhWCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZGVsdGFZID0gdW5kZWZpbmVkO1xuICAgIHZhciBkZWx0YSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgd2hlZWxEZWx0YSA9IG5hdGl2ZUV2ZW50LndoZWVsRGVsdGE7XG4gICAgdmFyIGF4aXMgPSBuYXRpdmVFdmVudC5heGlzO1xuICAgIHZhciB3aGVlbERlbHRhWSA9IG5hdGl2ZUV2ZW50LndoZWVsRGVsdGFZO1xuICAgIHZhciB3aGVlbERlbHRhWCA9IG5hdGl2ZUV2ZW50LndoZWVsRGVsdGFYO1xuICAgIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG5cbiAgICAvLyBpZS93ZWJraXRcbiAgICBpZiAod2hlZWxEZWx0YSkge1xuICAgICAgZGVsdGEgPSB3aGVlbERlbHRhIC8gMTIwO1xuICAgIH1cblxuICAgIC8vIGdlY2tvXG4gICAgaWYgKGRldGFpbCkge1xuICAgICAgLy8gcHJlc3MgY29udHJvbCBlLmRldGFpbCA9PSAxIGVsc2UgZS5kZXRhaWwgPT0gM1xuICAgICAgZGVsdGEgPSAwIC0gKGRldGFpbCAlIDMgPT09IDAgPyBkZXRhaWwgLyAzIDogZGV0YWlsKTtcbiAgICB9XG5cbiAgICAvLyBHZWNrb1xuICAgIGlmIChheGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChheGlzID09PSBldmVudC5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgZGVsdGFYID0gMCAtIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChheGlzID09PSBldmVudC5WRVJUSUNBTF9BWElTKSB7XG4gICAgICAgIGRlbHRhWCA9IDA7XG4gICAgICAgIGRlbHRhWSA9IGRlbHRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlYmtpdFxuICAgIGlmICh3aGVlbERlbHRhWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWx0YVkgPSB3aGVlbERlbHRhWSAvIDEyMDtcbiAgICB9XG4gICAgaWYgKHdoZWVsRGVsdGFYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbHRhWCA9IC0xICogd2hlZWxEZWx0YVggLyAxMjA7XG4gICAgfVxuXG4gICAgLy8g6buY6K6kIGRlbHRhWSAoaWUpXG4gICAgaWYgKCFkZWx0YVggJiYgIWRlbHRhWSkge1xuICAgICAgZGVsdGFZID0gZGVsdGE7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIGRlbHRhWCBvZiBtb3VzZXdoZWVsIGV2ZW50XG4gICAgICAgKiBAcHJvcGVydHkgZGVsdGFYXG4gICAgICAgKiBAbWVtYmVyIEV2ZW50LkRvbUV2ZW50Lk9iamVjdFxuICAgICAgICovXG4gICAgICBldmVudC5kZWx0YVggPSBkZWx0YVg7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIGRlbHRhWSBvZiBtb3VzZXdoZWVsIGV2ZW50XG4gICAgICAgKiBAcHJvcGVydHkgZGVsdGFZXG4gICAgICAgKiBAbWVtYmVyIEV2ZW50LkRvbUV2ZW50Lk9iamVjdFxuICAgICAgICovXG4gICAgICBldmVudC5kZWx0YVkgPSBkZWx0YVk7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogZGVsdGEgb2YgbW91c2V3aGVlbCBldmVudFxuICAgICAgICogQHByb3BlcnR5IGRlbHRhXG4gICAgICAgKiBAbWVtYmVyIEV2ZW50LkRvbUV2ZW50Lk9iamVjdFxuICAgICAgICovXG4gICAgICBldmVudC5kZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgfVxufSwge1xuICByZWc6IC9ebW91c2V8Y29udGV4dG1lbnV8Y2xpY2t8bXNwb2ludGVyfCheRE9NTW91c2VTY3JvbGwkKS9pLFxuICBwcm9wczogWydidXR0b25zJywgJ2NsaWVudFgnLCAnY2xpZW50WScsICdidXR0b24nLCAnb2Zmc2V0WCcsICdyZWxhdGVkVGFyZ2V0JywgJ3doaWNoJywgJ2Zyb21FbGVtZW50JywgJ3RvRWxlbWVudCcsICdvZmZzZXRZJywgJ3BhZ2VYJywgJ3BhZ2VZJywgJ3NjcmVlblgnLCAnc2NyZWVuWSddLFxuICBmaXg6IGZ1bmN0aW9uIGZpeChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnREb2MgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRvYyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgYm9keSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBidXR0b24gPSBuYXRpdmVFdmVudC5idXR0b247XG5cbiAgICAvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG4gICAgaWYgKHRhcmdldCAmJiBpc051bGxPclVuZGVmaW5lZChldmVudC5wYWdlWCkgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKG5hdGl2ZUV2ZW50LmNsaWVudFgpKSB7XG4gICAgICBldmVudERvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgICAgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgYm9keSA9IGV2ZW50RG9jLmJvZHk7XG4gICAgICBldmVudC5wYWdlWCA9IG5hdGl2ZUV2ZW50LmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIGV2ZW50LnBhZ2VZID0gbmF0aXZlRXZlbnQuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgfVxuXG4gICAgLy8gd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG4gICAgLy8gZG8gbm90IHVzZSBidXR0b25cbiAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYnV0dG9uICYgMSkge1xuICAgICAgICBldmVudC53aGljaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGJ1dHRvbiAmIDIpIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAzO1xuICAgICAgfSBlbHNlIGlmIChidXR0b24gJiA0KSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0ICYmIGV2ZW50LmZyb21FbGVtZW50KSB7XG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IHRhcmdldCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbiAgfVxufV07XG5cbmZ1bmN0aW9uIHJldFRydWUoKSB7XG4gIHJldHVybiBUUlVFO1xufVxuXG5mdW5jdGlvbiByZXRGYWxzZSgpIHtcbiAgcmV0dXJuIEZBTFNFO1xufVxuXG5mdW5jdGlvbiBEb21FdmVudE9iamVjdChuYXRpdmVFdmVudCkge1xuICB2YXIgdHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGU7XG5cbiAgdmFyIGlzTmF0aXZlID0gdHlwZW9mIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbmF0aXZlRXZlbnQuY2FuY2VsQnViYmxlID09PSAnYm9vbGVhbic7XG5cbiAgX0V2ZW50QmFzZU9iamVjdDJbJ2RlZmF1bHQnXS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICAvLyBpbiBjYXNlIGRvbSBldmVudCBoYXMgYmVlbiBtYXJrIGFzIGRlZmF1bHQgcHJldmVudGVkIGJ5IGxvd2VyIGRvbSBub2RlXG4gIHZhciBpc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXRGYWxzZTtcbiAgaWYgKCdkZWZhdWx0UHJldmVudGVkJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPyByZXRUcnVlIDogcmV0RmFsc2U7XG4gIH0gZWxzZSBpZiAoJ2dldFByZXZlbnREZWZhdWx0JyBpbiBuYXRpdmVFdmVudCkge1xuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5MTE1MVxuICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmdldFByZXZlbnREZWZhdWx0KCkgPyByZXRUcnVlIDogcmV0RmFsc2U7XG4gIH0gZWxzZSBpZiAoJ3JldHVyblZhbHVlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBGQUxTRSA/IHJldFRydWUgOiByZXRGYWxzZTtcbiAgfVxuXG4gIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gaXNEZWZhdWx0UHJldmVudGVkO1xuXG4gIHZhciBmaXhGbnMgPSBbXTtcbiAgdmFyIGZpeEZuID0gdW5kZWZpbmVkO1xuICB2YXIgbCA9IHVuZGVmaW5lZDtcbiAgdmFyIHByb3AgPSB1bmRlZmluZWQ7XG4gIHZhciBwcm9wcyA9IGNvbW1vblByb3BzLmNvbmNhdCgpO1xuXG4gIGV2ZW50Tm9ybWFsaXplcnMuZm9yRWFjaChmdW5jdGlvbiAobm9ybWFsaXplcikge1xuICAgIGlmICh0eXBlLm1hdGNoKG5vcm1hbGl6ZXIucmVnKSkge1xuICAgICAgcHJvcHMgPSBwcm9wcy5jb25jYXQobm9ybWFsaXplci5wcm9wcyk7XG4gICAgICBpZiAobm9ybWFsaXplci5maXgpIHtcbiAgICAgICAgZml4Rm5zLnB1c2gobm9ybWFsaXplci5maXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbCA9IHByb3BzLmxlbmd0aDtcblxuICAvLyBjbG9uZSBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3RcbiAgd2hpbGUgKGwpIHtcbiAgICBwcm9wID0gcHJvcHNbLS1sXTtcbiAgICB0aGlzW3Byb3BdID0gbmF0aXZlRXZlbnRbcHJvcF07XG4gIH1cblxuICAvLyBmaXggdGFyZ2V0IHByb3BlcnR5LCBpZiBuZWNlc3NhcnlcbiAgaWYgKCF0aGlzLnRhcmdldCAmJiBpc05hdGl2ZSkge1xuICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDsgLy8gc3JjRWxlbWVudCBtaWdodCBub3QgYmUgZGVmaW5lZCBlaXRoZXJcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRhcmdldCBpcyBhIHRleHQgbm9kZSAoc2FmYXJpKVxuICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy50YXJnZXQubm9kZVR5cGUgPT09IDMpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRoaXMudGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICBsID0gZml4Rm5zLmxlbmd0aDtcblxuICB3aGlsZSAobCkge1xuICAgIGZpeEZuID0gZml4Rm5zWy0tbF07XG4gICAgZml4Rm4odGhpcywgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgdGhpcy50aW1lU3RhbXAgPSBuYXRpdmVFdmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbn1cblxudmFyIEV2ZW50QmFzZU9iamVjdFByb3RvID0gX0V2ZW50QmFzZU9iamVjdDJbJ2RlZmF1bHQnXS5wcm90b3R5cGU7XG5cbigwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKShEb21FdmVudE9iamVjdC5wcm90b3R5cGUsIEV2ZW50QmFzZU9iamVjdFByb3RvLCB7XG4gIGNvbnN0cnVjdG9yOiBEb21FdmVudE9iamVjdCxcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdmFyIGUgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2Ugc2V0IHRoZSByZXR1cm5WYWx1ZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gRkFMU0UgKElFKVxuICAgICAgZS5yZXR1cm5WYWx1ZSA9IEZBTFNFO1xuICAgIH1cblxuICAgIEV2ZW50QmFzZU9iamVjdFByb3RvLnByZXZlbnREZWZhdWx0LmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2Ugc2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIFRSVUUgKElFKVxuICAgICAgZS5jYW5jZWxCdWJibGUgPSBUUlVFO1xuICAgIH1cblxuICAgIEV2ZW50QmFzZU9iamVjdFByb3RvLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRG9tRXZlbnRPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gYWRkRXZlbnRMaXN0ZW5lcjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0V2ZW50T2JqZWN0ID0gcmVxdWlyZSgnLi9FdmVudE9iamVjdCcpO1xuXG52YXIgX0V2ZW50T2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50T2JqZWN0KTtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gd3JhcENhbGxiYWNrKGUpIHtcbiAgICB2YXIgbmUgPSBuZXcgX0V2ZW50T2JqZWN0MlsnZGVmYXVsdCddKGUpO1xuICAgIGNhbGxiYWNrLmNhbGwodGFyZ2V0LCBuZSk7XG4gIH1cblxuICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHdyYXBDYWxsYmFjaywgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIHdyYXBDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfTWFwTGF5ZXIyID0gcmVxdWlyZSgnLi9NYXBMYXllcicpO1xuXG52YXIgX01hcExheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcExheWVyMik7XG5cbnZhciBCYXNlVGlsZUxheWVyID0gKGZ1bmN0aW9uIChfTWFwTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEJhc2VUaWxlTGF5ZXIsIF9NYXBMYXllcik7XG5cbiAgZnVuY3Rpb24gQmFzZVRpbGVMYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVRpbGVMYXllcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXNlVGlsZUxheWVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVRpbGVMYXllciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBvcGFjaXR5ID0gX3Byb3BzLm9wYWNpdHk7XG4gICAgICB2YXIgekluZGV4ID0gX3Byb3BzLnpJbmRleDtcblxuICAgICAgaWYgKG9wYWNpdHkgJiYgb3BhY2l0eSAhPT0gcHJldlByb3BzLm9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgICAgfVxuICAgICAgaWYgKHpJbmRleCAmJiB6SW5kZXggIT09IHByZXZQcm9wcy56SW5kZXgpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRaSW5kZXgoekluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIG9wYWNpdHk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgekluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VUaWxlTGF5ZXI7XG59KShfTWFwTGF5ZXIzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCYXNlVGlsZUxheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vQmFzZVRpbGVMYXllcicpO1xuXG52YXIgX0Jhc2VUaWxlTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRpbGVMYXllcjIpO1xuXG52YXIgQ2FudmFzVGlsZUxheWVyID0gKGZ1bmN0aW9uIChfQmFzZVRpbGVMYXllcikge1xuICBfaW5oZXJpdHMoQ2FudmFzVGlsZUxheWVyLCBfQmFzZVRpbGVMYXllcik7XG5cbiAgZnVuY3Rpb24gQ2FudmFzVGlsZUxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNUaWxlTGF5ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FudmFzVGlsZUxheWVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENhbnZhc1RpbGVMYXllci5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQudGlsZUxheWVyLmNhbnZhcyhwcm9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZhc1RpbGVMYXllcjtcbn0pKF9CYXNlVGlsZUxheWVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2FudmFzVGlsZUxheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfdHlwZXNMYXRsbmcgPSByZXF1aXJlKCcuL3R5cGVzL2xhdGxuZycpO1xuXG52YXIgX3R5cGVzTGF0bG5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVzTGF0bG5nKTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG52YXIgQ2lyY2xlID0gKGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoQ2lyY2xlLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2lyY2xlLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENpcmNsZS5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNlbnRlciA9IF9wcm9wcy5jZW50ZXI7XG4gICAgICB2YXIgbWFwID0gX3Byb3BzLm1hcDtcbiAgICAgIHZhciByYWRpdXMgPSBfcHJvcHMucmFkaXVzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2NlbnRlcicsICdtYXAnLCAncmFkaXVzJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LmNpcmNsZSkoY2VudGVyLCByYWRpdXMsIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5jZW50ZXIgIT09IHByZXZQcm9wcy5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmcodGhpcy5wcm9wcy5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMucmFkaXVzICE9PSBwcmV2UHJvcHMucmFkaXVzKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0UmFkaXVzKHRoaXMucHJvcHMucmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIGNlbnRlcjogX3R5cGVzTGF0bG5nMlsnZGVmYXVsdCddLmlzUmVxdWlyZWQsXG4gICAgICByYWRpdXM6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGU7XG59KShfUGF0aDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENpcmNsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX3R5cGVzTGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF90eXBlc0xhdGxuZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlc0xhdGxuZyk7XG5cbnZhciBfUGF0aDIgPSByZXF1aXJlKCcuL1BhdGgnKTtcblxudmFyIF9QYXRoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhdGgyKTtcblxudmFyIENpcmNsZU1hcmtlciA9IChmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKENpcmNsZU1hcmtlciwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIENpcmNsZU1hcmtlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlTWFya2VyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENpcmNsZU1hcmtlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZU1hcmtlciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGVNYXJrZXIucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjZW50ZXIgPSBfcHJvcHMuY2VudGVyO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnY2VudGVyJywgJ21hcCddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5jaXJjbGVNYXJrZXIpKGNlbnRlciwgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmNlbnRlciAhPT0gcHJldlByb3BzLmNlbnRlcikge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZyh0aGlzLnByb3BzLmNlbnRlcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy5yYWRpdXMgIT09IHByZXZQcm9wcy5yYWRpdXMpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRSYWRpdXModGhpcy5wcm9wcy5yYWRpdXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZToge1xuICAgICAgY2VudGVyOiBfdHlwZXNMYXRsbmcyWydkZWZhdWx0J10uaXNSZXF1aXJlZCxcbiAgICAgIHJhZGl1czogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGVNYXJrZXI7XG59KShfUGF0aDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENpcmNsZU1hcmtlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbnZhciBGZWF0dXJlR3JvdXAgPSAoZnVuY3Rpb24gKF9QYXRoKSB7XG4gIF9pbmhlcml0cyhGZWF0dXJlR3JvdXAsIF9QYXRoKTtcblxuICBmdW5jdGlvbiBGZWF0dXJlR3JvdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZlYXR1cmVHcm91cCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGZWF0dXJlR3JvdXAucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGZWF0dXJlR3JvdXAsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgbGF5ZXJzID0gX3Byb3BzLmxheWVycztcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2xheWVycycsICdtYXAnXSk7XG5cbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQgPSAoMCwgX2xlYWZsZXQuZmVhdHVyZUdyb3VwKShsYXllcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxheWVyczogX3JlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1dKTtcblxuICByZXR1cm4gRmVhdHVyZUdyb3VwO1xufSkoX1BhdGgzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGZWF0dXJlR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG52YXIgR2VvSnNvbiA9IChmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKEdlb0pzb24sIF9QYXRoKTtcblxuICBmdW5jdGlvbiBHZW9Kc29uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHZW9Kc29uKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlb0pzb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHZW9Kc29uLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlb0pzb24ucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBkYXRhID0gX3Byb3BzLmRhdGE7XG4gICAgICB2YXIgbWFwID0gX3Byb3BzLm1hcDtcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydkYXRhJywgJ21hcCddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5nZW9Kc29uKShkYXRhLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZToge1xuICAgICAgZGF0YTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XSk7XG5cbiAgcmV0dXJuIEdlb0pzb247XG59KShfUGF0aDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEdlb0pzb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF90eXBlc0JvdW5kcyA9IHJlcXVpcmUoJy4vdHlwZXMvYm91bmRzJyk7XG5cbnZhciBfdHlwZXNCb3VuZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZXNCb3VuZHMpO1xuXG52YXIgX01hcExheWVyMiA9IHJlcXVpcmUoJy4vTWFwTGF5ZXInKTtcblxudmFyIF9NYXBMYXllcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBMYXllcjIpO1xuXG52YXIgSW1hZ2VPdmVybGF5ID0gKGZ1bmN0aW9uIChfTWFwTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEltYWdlT3ZlcmxheSwgX01hcExheWVyKTtcblxuICBmdW5jdGlvbiBJbWFnZU92ZXJsYXkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlT3ZlcmxheSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZU92ZXJsYXkucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZU92ZXJsYXksIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW1hZ2VPdmVybGF5LnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgYm91bmRzID0gX3Byb3BzLmJvdW5kcztcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIHVybCA9IF9wcm9wcy51cmw7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYm91bmRzJywgJ21hcCcsICd1cmwnXSk7XG5cbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQgPSAoMCwgX2xlYWZsZXQuaW1hZ2VPdmVybGF5KSh1cmwsIGJvdW5kcywgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnVybCAhPT0gcHJldlByb3BzLnVybCkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldFVybCh0aGlzLnByb3BzLnVybCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy5vcGFjaXR5ICE9PSBwcmV2UHJvcHMub3BhY2l0eSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldE9wYWNpdHkodGhpcy5wcm9wcy5vcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIGF0dHJpYnV0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIGJvdW5kczogX3R5cGVzQm91bmRzMlsnZGVmYXVsdCddLmlzUmVxdWlyZWQsXG4gICAgICBtYXA6IF9yZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihfbGVhZmxldC5NYXApLFxuICAgICAgb3BhY2l0eTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICB1cmw6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZU92ZXJsYXk7XG59KShfTWFwTGF5ZXIzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBJbWFnZU92ZXJsYXk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX01hcExheWVyMiA9IHJlcXVpcmUoJy4vTWFwTGF5ZXInKTtcblxudmFyIF9NYXBMYXllcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBMYXllcjIpO1xuXG52YXIgTGF5ZXJHcm91cCA9IChmdW5jdGlvbiAoX01hcExheWVyKSB7XG4gIF9pbmhlcml0cyhMYXllckdyb3VwLCBfTWFwTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIExheWVyR3JvdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyR3JvdXApO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGF5ZXJHcm91cC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExheWVyR3JvdXAsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGF5ZXJHcm91cC5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQgPSAoMCwgX2xlYWZsZXQubGF5ZXJHcm91cCkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQgPyBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgbGF5ZXJHcm91cDogX3RoaXMubGVhZmxldEVsZW1lbnQsXG4gICAgICAgICAgbWFwOiBfdGhpcy5wcm9wcy5tYXBcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gfSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgIHZhbHVlOiB7XG4gICAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLm5vZGUpLCBfcmVhY3QuUHJvcFR5cGVzLm5vZGVdKSxcbiAgICAgIG1hcDogX3JlYWN0LlByb3BUeXBlcy5pbnN0YW5jZU9mKF9sZWFmbGV0Lk1hcClcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBMYXllckdyb3VwO1xufSkoX01hcExheWVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTGF5ZXJHcm91cDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLWRpZC1tb3VudC1zZXQtc3RhdGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xvZGFzaExhbmdJc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoL2xhbmcvaXNBcnJheScpO1xuXG52YXIgX2xvZGFzaExhbmdJc0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaExhbmdJc0FycmF5KTtcblxudmFyIF9sb2Rhc2hMYW5nSXNVbmRlZmluZWQgPSByZXF1aXJlKCdsb2Rhc2gvbGFuZy9pc1VuZGVmaW5lZCcpO1xuXG52YXIgX2xvZGFzaExhbmdJc1VuZGVmaW5lZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hMYW5nSXNVbmRlZmluZWQpO1xuXG52YXIgX2xvZGFzaFV0aWxpdHlVbmlxdWVJZCA9IHJlcXVpcmUoJ2xvZGFzaC91dGlsaXR5L3VuaXF1ZUlkJyk7XG5cbnZhciBfbG9kYXNoVXRpbGl0eVVuaXF1ZUlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaFV0aWxpdHlVbmlxdWVJZCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX2xlYWZsZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGVhZmxldCk7XG5cbnZhciBfdHlwZXNCb3VuZHMgPSByZXF1aXJlKCcuL3R5cGVzL2JvdW5kcycpO1xuXG52YXIgX3R5cGVzQm91bmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVzQm91bmRzKTtcblxudmFyIF90eXBlc0xhdGxuZyA9IHJlcXVpcmUoJy4vdHlwZXMvbGF0bG5nJyk7XG5cbnZhciBfdHlwZXNMYXRsbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZXNMYXRsbmcpO1xuXG52YXIgX01hcENvbXBvbmVudDIgPSByZXF1aXJlKCcuL01hcENvbXBvbmVudCcpO1xuXG52YXIgX01hcENvbXBvbmVudDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXBDb21wb25lbnQyKTtcblxudmFyIG5vcm1hbGl6ZUNlbnRlciA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNlbnRlcihwb3MpIHtcbiAgcmV0dXJuICgwLCBfbG9kYXNoTGFuZ0lzQXJyYXkyWydkZWZhdWx0J10pKHBvcykgPyBwb3MgOiBbcG9zLmxhdCwgcG9zLmxuZyB8fCBwb3MubG9uXTtcbn07XG5cbnZhciBNYXAgPSAoZnVuY3Rpb24gKF9NYXBDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1hcCwgX01hcENvbXBvbmVudCk7XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcCwgbnVsbCwgW3tcbiAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgIHZhbHVlOiB7XG4gICAgICBib3VuZHM6IF90eXBlc0JvdW5kczJbJ2RlZmF1bHQnXSxcbiAgICAgIGNlbnRlcjogX3R5cGVzTGF0bG5nMlsnZGVmYXVsdCddLFxuICAgICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5ub2RlKSwgX3JlYWN0LlByb3BUeXBlcy5ub2RlXSksXG4gICAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgaWQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgbWF4Qm91bmRzOiBfdHlwZXNCb3VuZHMyWydkZWZhdWx0J10sXG4gICAgICBtYXhab29tOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIG1pblpvb206IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgICAgem9vbTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIE1hcChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXApO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpZDogcHJvcHMuaWQgfHwgKDAsIF9sb2Rhc2hVdGlsaXR5VW5pcXVlSWQyWydkZWZhdWx0J10pKCdtYXAnKVxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQyWydkZWZhdWx0J10ubWFwKHRoaXMuc3RhdGUuaWQsIHRoaXMucHJvcHMpO1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwLnByb3RvdHlwZSksICdjb21wb25lbnREaWRNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbWFwOiB0aGlzLmxlYWZsZXRFbGVtZW50IH0pO1xuICAgICAgaWYgKCEoMCwgX2xvZGFzaExhbmdJc1VuZGVmaW5lZDJbJ2RlZmF1bHQnXSkodGhpcy5wcm9wcy5ib3VuZHMpKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuZml0Qm91bmRzKHRoaXMucHJvcHMuYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBib3VuZHMgPSBfcHJvcHMuYm91bmRzO1xuICAgICAgdmFyIGNlbnRlciA9IF9wcm9wcy5jZW50ZXI7XG4gICAgICB2YXIgbWF4Qm91bmRzID0gX3Byb3BzLm1heEJvdW5kcztcbiAgICAgIHZhciB6b29tID0gX3Byb3BzLnpvb207XG5cbiAgICAgIGlmIChjZW50ZXIgJiYgdGhpcy5zaG91bGRVcGRhdGVDZW50ZXIoY2VudGVyLCBwcmV2UHJvcHMuY2VudGVyKSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldFZpZXcoY2VudGVyLCB6b29tLCB7IGFuaW1hdGU6IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIGlmICh6b29tICYmIHpvb20gIT09IHByZXZQcm9wcy56b29tKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0Wm9vbSh6b29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhCb3VuZHMgJiYgdGhpcy5zaG91bGRVcGRhdGVCb3VuZHMobWF4Qm91bmRzLCBwcmV2UHJvcHMubWF4Qm91bmRzKSkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldE1heEJvdW5kcyhtYXhCb3VuZHMpO1xuICAgICAgfVxuICAgICAgaWYgKGJvdW5kcyAmJiB0aGlzLnNob3VsZFVwZGF0ZUJvdW5kcyhib3VuZHMsIHByZXZQcm9wcy5ib3VuZHMpKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hcC5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbFVubW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5yZW1vdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG91bGRVcGRhdGVDZW50ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRVcGRhdGVDZW50ZXIobmV4dCwgcHJldikge1xuICAgICAgaWYgKCFwcmV2KSByZXR1cm4gdHJ1ZTtcbiAgICAgIG5leHQgPSBub3JtYWxpemVDZW50ZXIobmV4dCk7XG4gICAgICBwcmV2ID0gbm9ybWFsaXplQ2VudGVyKHByZXYpO1xuICAgICAgcmV0dXJuIG5leHRbMF0gIT09IHByZXZbMF0gfHwgbmV4dFsxXSAhPT0gcHJldlsxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG91bGRVcGRhdGVCb3VuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRVcGRhdGVCb3VuZHMobmV4dCwgcHJldikge1xuICAgICAgaWYgKCFwcmV2KSByZXR1cm4gdHJ1ZTtcbiAgICAgIG5leHQgPSBfbGVhZmxldDJbJ2RlZmF1bHQnXS5sYXRMbmdCb3VuZHMobmV4dCk7XG4gICAgICBwcmV2ID0gX2xlYWZsZXQyWydkZWZhdWx0J10ubGF0TG5nQm91bmRzKHByZXYpO1xuICAgICAgcmV0dXJuICFuZXh0LmVxdWFscyhwcmV2KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5sZWFmbGV0RWxlbWVudDtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG1hcCA/IF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZCA/IF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbWFwOiBtYXAgfSkgOiBudWxsO1xuICAgICAgfSkgOiBudWxsO1xuXG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgICBpZDogdGhpcy5zdGF0ZS5pZCxcbiAgICAgICAgICBzdHlsZTogdGhpcy5wcm9wcy5zdHlsZSB9LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFwO1xufSkoX01hcENvbXBvbmVudDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1hcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MywgX3g0LCBfeDUpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gzLCBwcm9wZXJ0eSA9IF94NCwgcmVjZWl2ZXIgPSBfeDU7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gzID0gcGFyZW50OyBfeDQgPSBwcm9wZXJ0eTsgX3g1ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9sb2Rhc2hMYW5nQ2xvbmUgPSByZXF1aXJlKCdsb2Rhc2gvbGFuZy9jbG9uZScpO1xuXG52YXIgX2xvZGFzaExhbmdDbG9uZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hMYW5nQ2xvbmUpO1xuXG52YXIgX2xvZGFzaENvbGxlY3Rpb25Gb3JFYWNoID0gcmVxdWlyZSgnbG9kYXNoL2NvbGxlY3Rpb24vZm9yRWFjaCcpO1xuXG52YXIgX2xvZGFzaENvbGxlY3Rpb25Gb3JFYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaENvbGxlY3Rpb25Gb3JFYWNoKTtcblxudmFyIF9sb2Rhc2hDb2xsZWN0aW9uUmVkdWNlID0gcmVxdWlyZSgnbG9kYXNoL2NvbGxlY3Rpb24vcmVkdWNlJyk7XG5cbnZhciBfbG9kYXNoQ29sbGVjdGlvblJlZHVjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hDb2xsZWN0aW9uUmVkdWNlKTtcblxudmFyIF9sb2Rhc2hPYmplY3RLZXlzID0gcmVxdWlyZSgnbG9kYXNoL29iamVjdC9rZXlzJyk7XG5cbnZhciBfbG9kYXNoT2JqZWN0S2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hPYmplY3RLZXlzKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBFVkVOVFNfUkUgPSAvb24oPzpMZWFmbGV0KT8oLispL2k7XG5cbnZhciBNYXBDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1hcENvbXBvbmVudCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWFwQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBDb21wb25lbnQpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwQ29tcG9uZW50LnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIHRoaXMuX2xlYWZsZXRFdmVudHMgPSB0aGlzLmV4dHJhY3RMZWFmbGV0RXZlbnRzKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmJpbmRMZWFmbGV0RXZlbnRzKHRoaXMuX2xlYWZsZXRFdmVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmV4dHJhY3RMZWFmbGV0RXZlbnRzKG5leHRQcm9wcyk7XG4gICAgICB0aGlzLl9sZWFmbGV0RXZlbnRzID0gdGhpcy5iaW5kTGVhZmxldEV2ZW50cyhuZXh0LCB0aGlzLl9sZWFmbGV0RXZlbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5sZWFmbGV0RWxlbWVudDtcbiAgICAgIGlmICghZWwpIHJldHVybjtcblxuICAgICAgKDAsIF9sb2Rhc2hDb2xsZWN0aW9uRm9yRWFjaDJbJ2RlZmF1bHQnXSkodGhpcy5fbGVhZmxldEV2ZW50cywgZnVuY3Rpb24gKGNiLCBldikge1xuICAgICAgICBlbC5vZmYoZXYsIGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldExlYWZsZXRFbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVhZmxldEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZWFmbGV0RWxlbWVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdleHRyYWN0TGVhZmxldEV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RMZWFmbGV0RXZlbnRzKHByb3BzKSB7XG4gICAgICByZXR1cm4gKDAsIF9sb2Rhc2hDb2xsZWN0aW9uUmVkdWNlMlsnZGVmYXVsdCddKSgoMCwgX2xvZGFzaE9iamVjdEtleXMyWydkZWZhdWx0J10pKHByb3BzKSwgZnVuY3Rpb24gKHJlcywgZXYpIHtcbiAgICAgICAgaWYgKEVWRU5UU19SRS50ZXN0KGV2KSkge1xuICAgICAgICAgIHZhciBrZXkgPSBldi5yZXBsYWNlKEVWRU5UU19SRSwgZnVuY3Rpb24gKG1hdGNoLCBwKSB7XG4gICAgICAgICAgICByZXR1cm4gcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc1trZXldID0gcHJvcHNbZXZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmluZExlYWZsZXRFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kTGVhZmxldEV2ZW50cygpIHtcbiAgICAgIHZhciBuZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcHJldiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB2YXIgZWwgPSB0aGlzLmxlYWZsZXRFbGVtZW50O1xuICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgZGlmZiA9ICgwLCBfbG9kYXNoTGFuZ0Nsb25lMlsnZGVmYXVsdCddKShwcmV2KTtcbiAgICAgICgwLCBfbG9kYXNoQ29sbGVjdGlvbkZvckVhY2gyWydkZWZhdWx0J10pKHByZXYsIGZ1bmN0aW9uIChjYiwgZXYpIHtcbiAgICAgICAgaWYgKCFuZXh0W2V2XSB8fCBjYiAhPT0gbmV4dFtldl0pIHtcbiAgICAgICAgICBkZWxldGUgZGlmZltldl07XG4gICAgICAgICAgZWwub2ZmKGV2LCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX2xvZGFzaENvbGxlY3Rpb25Gb3JFYWNoMlsnZGVmYXVsdCddKShuZXh0LCBmdW5jdGlvbiAoY2IsIGV2KSB7XG4gICAgICAgIGlmICghcHJldltldl0gfHwgY2IgIT09IHByZXZbZXZdKSB7XG4gICAgICAgICAgZGlmZltldl0gPSBjYjtcbiAgICAgICAgICBlbC5vbihldiwgY2IpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlyZUxlYWZsZXRFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVMZWFmbGV0RXZlbnQodHlwZSwgZGF0YSkge1xuICAgICAgdmFyIGVsID0gdGhpcy5sZWFmbGV0RWxlbWVudDtcbiAgICAgIGlmIChlbCkgZWwuZmlyZSh0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFwQ29tcG9uZW50O1xufSkoX3JlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1hcENvbXBvbmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9sb2Rhc2hPYmplY3RBc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2gvb2JqZWN0L2Fzc2lnbicpO1xuXG52YXIgX2xvZGFzaE9iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hPYmplY3RBc3NpZ24pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTWFwQ29tcG9uZW50MiA9IHJlcXVpcmUoJy4vTWFwQ29tcG9uZW50Jyk7XG5cbnZhciBfTWFwQ29tcG9uZW50MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcENvbXBvbmVudDIpO1xuXG52YXIgTWFwTGF5ZXIgPSAoZnVuY3Rpb24gKF9NYXBDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1hcExheWVyLCBfTWFwQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNYXBMYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwTGF5ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwTGF5ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBMYXllciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFwTGF5ZXIucHJvdG90eXBlKSwgJ2NvbXBvbmVudERpZE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICh0aGlzLnByb3BzLmxheWVyR3JvdXAgfHwgdGhpcy5wcm9wcy5tYXApLmFkZExheWVyKHRoaXMubGVhZmxldEVsZW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXBMYXllci5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbFVubW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgKHRoaXMucHJvcHMubGF5ZXJHcm91cCB8fCB0aGlzLnByb3BzLm1hcCkucmVtb3ZlTGF5ZXIodGhpcy5sZWFmbGV0RWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2xvbmVkQ2hpbGRyZW5XaXRoTWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xvbmVkQ2hpbGRyZW5XaXRoTWFwKGV4dHJhKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuXG4gICAgICB2YXIgcHJvcHMgPSAoMCwgX2xvZGFzaE9iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSkoeyBtYXA6IG1hcCB9LCBleHRyYSk7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkID8gX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudChjaGlsZCwgcHJvcHMpIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBMYXllcjtcbn0pKF9NYXBDb21wb25lbnQzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNYXBMYXllcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX3R5cGVzTGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF90eXBlc0xhdGxuZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlc0xhdGxuZyk7XG5cbnZhciBfUG9wdXBDb250YWluZXIyID0gcmVxdWlyZSgnLi9Qb3B1cENvbnRhaW5lcicpO1xuXG52YXIgX1BvcHVwQ29udGFpbmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwQ29udGFpbmVyMik7XG5cbnZhciBNYXJrZXIgPSAoZnVuY3Rpb24gKF9Qb3B1cENvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoTWFya2VyLCBfUG9wdXBDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcmtlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFya2VyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hcmtlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcmtlciwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXJrZXIucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIHBvc2l0aW9uID0gX3Byb3BzLnBvc2l0aW9uO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ21hcCcsICdwb3NpdGlvbiddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5tYXJrZXIpKHBvc2l0aW9uLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMucG9zaXRpb24gIT09IHByZXZQcm9wcy5wb3NpdGlvbikge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZyh0aGlzLnByb3BzLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb3BzLmljb24gIT09IHByZXZQcm9wcy5pY29uKSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0SWNvbih0aGlzLnByb3BzLmljb24pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMuekluZGV4T2Zmc2V0ICE9PSBwcmV2UHJvcHMuekluZGV4T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0WkluZGV4T2Zmc2V0KHRoaXMucHJvcHMuekluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb3BzLm9wYWNpdHkgIT09IHByZXZQcm9wcy5vcGFjaXR5KSB7XG4gICAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQuc2V0T3BhY2l0eSh0aGlzLnByb3BzLm9wYWNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZToge1xuICAgICAgaWNvbjogX3JlYWN0LlByb3BUeXBlcy5pbnN0YW5jZU9mKF9sZWFmbGV0Lkljb24pLFxuICAgICAgb3BhY2l0eTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICBwb3NpdGlvbjogX3R5cGVzTGF0bG5nMlsnZGVmYXVsdCddLmlzUmVxdWlyZWQsXG4gICAgICB6SW5kZXhPZmZzZXQ6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1dKTtcblxuICByZXR1cm4gTWFya2VyO1xufSkoX1BvcHVwQ29udGFpbmVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTWFya2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfdHlwZXNMYXRsbmdMaXN0ID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmdMaXN0Jyk7XG5cbnZhciBfdHlwZXNMYXRsbmdMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVzTGF0bG5nTGlzdCk7XG5cbnZhciBfUGF0aDIgPSByZXF1aXJlKCcuL1BhdGgnKTtcblxudmFyIF9QYXRoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhdGgyKTtcblxudmFyIE11bHRpUG9seWdvbiA9IChmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKE11bHRpUG9seWdvbiwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIE11bHRpUG9seWdvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlQb2x5Z29uKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE11bHRpUG9seWdvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE11bHRpUG9seWdvbiwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNdWx0aVBvbHlnb24ucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIHBvbHlnb25zID0gX3Byb3BzLnBvbHlnb25zO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ21hcCcsICdwb2x5Z29ucyddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5tdWx0aVBvbHlnb24pKHBvbHlnb25zLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMucG9seWdvbnMgIT09IHByZXZQcm9wcy5wb2x5Z29ucykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZ3ModGhpcy5wcm9wcy5wb2x5Z29ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgIHZhbHVlOiB7XG4gICAgICBwb2x5Z29uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF90eXBlc0xhdGxuZ0xpc3QyWydkZWZhdWx0J10pLmlzUmVxdWlyZWRcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBNdWx0aVBvbHlnb247XG59KShfUGF0aDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE11bHRpUG9seWdvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX3R5cGVzTGF0bG5nTGlzdCA9IHJlcXVpcmUoJy4vdHlwZXMvbGF0bG5nTGlzdCcpO1xuXG52YXIgX3R5cGVzTGF0bG5nTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlc0xhdGxuZ0xpc3QpO1xuXG52YXIgX1BhdGgyID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBfUGF0aDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXRoMik7XG5cbnZhciBNdWx0aVBvbHlsaW5lID0gKGZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoTXVsdGlQb2x5bGluZSwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIE11bHRpUG9seWxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpUG9seWxpbmUpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTXVsdGlQb2x5bGluZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE11bHRpUG9seWxpbmUsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTXVsdGlQb2x5bGluZS5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgcG9seWxpbmVzID0gX3Byb3BzLnBvbHlsaW5lcztcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydtYXAnLCAncG9seWxpbmVzJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0Lm11bHRpUG9seWxpbmUpKHBvbHlsaW5lcywgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBvbHlsaW5lcyAhPT0gcHJldlByb3BzLnBvbHlsaW5lcykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZ3ModGhpcy5wcm9wcy5wb2x5bGluZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZToge1xuICAgICAgcG9seWxpbmVzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3R5cGVzTGF0bG5nTGlzdDJbJ2RlZmF1bHQnXSkuaXNSZXF1aXJlZFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XSk7XG5cbiAgcmV0dXJuIE11bHRpUG9seWxpbmU7XG59KShfUGF0aDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE11bHRpUG9seWxpbmU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDIsIF94MywgX3g0KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MiwgcHJvcGVydHkgPSBfeDMsIHJlY2VpdmVyID0gX3g0OyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MiA9IHBhcmVudDsgX3gzID0gcHJvcGVydHk7IF94NCA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbG9kYXNoTGFuZ0lzRXF1YWwgPSByZXF1aXJlKCdsb2Rhc2gvbGFuZy9pc0VxdWFsJyk7XG5cbnZhciBfbG9kYXNoTGFuZ0lzRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9kYXNoTGFuZ0lzRXF1YWwpO1xuXG52YXIgX2xvZGFzaE9iamVjdFBpY2sgPSByZXF1aXJlKCdsb2Rhc2gvb2JqZWN0L3BpY2snKTtcblxudmFyIF9sb2Rhc2hPYmplY3RQaWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaE9iamVjdFBpY2spO1xuXG52YXIgX1BvcHVwQ29udGFpbmVyMiA9IHJlcXVpcmUoJy4vUG9wdXBDb250YWluZXInKTtcblxudmFyIF9Qb3B1cENvbnRhaW5lcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cENvbnRhaW5lcjIpO1xuXG52YXIgT1BUSU9OUyA9IFsnc3Ryb2tlJywgJ2NvbG9yJywgJ3dlaWdodCcsICdvcGFjaXR5JywgJ2ZpbGwnLCAnZmlsbENvbG9yJywgJ2ZpbGxPcGFjaXR5JywgJ2ZpbGxSdWxlJywgJ2Rhc2hBcnJheScsICdsaW5lQ2FwJywgJ2xpbmVKb2luJywgJ2NsaWNrYWJsZScsICdwb2ludGVyRXZlbnRzJywgJ2NsYXNzTmFtZSddO1xuXG52YXIgUGF0aCA9IChmdW5jdGlvbiAoX1BvcHVwQ29udGFpbmVyKSB7XG4gIF9pbmhlcml0cyhQYXRoLCBfUG9wdXBDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGgpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGF0aC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdGgsIFt7XG4gICAga2V5OiAnZ2V0UGF0aE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoT3B0aW9ucyhwcm9wcykge1xuICAgICAgcmV0dXJuICgwLCBfbG9kYXNoT2JqZWN0UGljazJbJ2RlZmF1bHQnXSkocHJvcHMsIE9QVElPTlMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFN0eWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3R5bGUoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldFN0eWxlKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFN0eWxlSWZDaGFuZ2VkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3R5bGVJZkNoYW5nZWQoZnJvbVByb3BzLCB0b1Byb3BzKSB7XG4gICAgICB2YXIgbmV4dFN0eWxlID0gdGhpcy5nZXRQYXRoT3B0aW9ucyh0b1Byb3BzKTtcbiAgICAgIGlmICghKDAsIF9sb2Rhc2hMYW5nSXNFcXVhbDJbJ2RlZmF1bHQnXSkobmV4dFN0eWxlLCB0aGlzLmdldFBhdGhPcHRpb25zKGZyb21Qcm9wcykpKSB7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUobmV4dFN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0aDtcbn0pKF9Qb3B1cENvbnRhaW5lcjNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF90eXBlc0xhdGxuZ0xpc3QgPSByZXF1aXJlKCcuL3R5cGVzL2xhdGxuZ0xpc3QnKTtcblxudmFyIF90eXBlc0xhdGxuZ0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZXNMYXRsbmdMaXN0KTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG52YXIgUG9seWdvbiA9IChmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKFBvbHlnb24sIF9QYXRoKTtcblxuICBmdW5jdGlvbiBQb2x5Z29uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5Z29uKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvbHlnb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2x5Z29uLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvbHlnb24ucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBtYXAgPSBfcHJvcHMubWFwO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IF9wcm9wcy5wb3NpdGlvbnM7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnbWFwJywgJ3Bvc2l0aW9ucyddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5wb2x5Z29uKShwb3NpdGlvbnMsIHByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wb3NpdGlvbnMgIT09IHByZXZQcm9wcy5wb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmdzKHRoaXMucHJvcHMucG9zaXRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3R5bGVJZkNoYW5nZWQocHJldlByb3BzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIHBvc2l0aW9uczogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW190eXBlc0xhdGxuZ0xpc3QyWydkZWZhdWx0J10sIF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfdHlwZXNMYXRsbmdMaXN0MlsnZGVmYXVsdCddKV0pLmlzUmVxdWlyZWRcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBQb2x5Z29uO1xufSkoX1BhdGgzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBQb2x5Z29uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF90eXBlc0xhdGxuZ0xpc3QgPSByZXF1aXJlKCcuL3R5cGVzL2xhdGxuZ0xpc3QnKTtcblxudmFyIF90eXBlc0xhdGxuZ0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZXNMYXRsbmdMaXN0KTtcblxudmFyIF9QYXRoMiA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG52YXIgX1BhdGgzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGF0aDIpO1xuXG52YXIgUG9seWxpbmUgPSAoZnVuY3Rpb24gKF9QYXRoKSB7XG4gIF9pbmhlcml0cyhQb2x5bGluZSwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIFBvbHlsaW5lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5bGluZSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihQb2x5bGluZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbHlsaW5lLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvbHlsaW5lLnByb3RvdHlwZSksICdjb21wb25lbnRXaWxsTW91bnQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgbWFwID0gX3Byb3BzLm1hcDtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBfcHJvcHMucG9zaXRpb25zO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ21hcCcsICdwb3NpdGlvbnMnXSk7XG5cbiAgICAgIHRoaXMubGVhZmxldEVsZW1lbnQgPSAoMCwgX2xlYWZsZXQucG9seWxpbmUpKHBvc2l0aW9ucywgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBvc2l0aW9ucyAhPT0gcHJldlByb3BzLnBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZ3ModGhpcy5wcm9wcy5wb3NpdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZToge1xuICAgICAgcG9zaXRpb25zOiBfdHlwZXNMYXRsbmdMaXN0MlsnZGVmYXVsdCddLmlzUmVxdWlyZWRcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfV0pO1xuXG4gIHJldHVybiBQb2x5bGluZTtcbn0pKF9QYXRoM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUG9seWxpbmU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX3R5cGVzTGF0bG5nID0gcmVxdWlyZSgnLi90eXBlcy9sYXRsbmcnKTtcblxudmFyIF90eXBlc0xhdGxuZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlc0xhdGxuZyk7XG5cbnZhciBfTWFwQ29tcG9uZW50MiA9IHJlcXVpcmUoJy4vTWFwQ29tcG9uZW50Jyk7XG5cbnZhciBfTWFwQ29tcG9uZW50MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcENvbXBvbmVudDIpO1xuXG52YXIgUG9wdXAgPSAoZnVuY3Rpb24gKF9NYXBDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcHVwLCBfTWFwQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb3B1cCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXApO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9wdXAucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb3B1cCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihQb3B1cC5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnY2hpbGRyZW4nLCAnbWFwJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LnBvcHVwKShwcm9wcyk7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50Lm9uKCdvcGVuJywgdGhpcy5yZW5kZXJQb3B1cENvbnRlbnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50Lm9uKCdjbG9zZScsIHRoaXMucmVtb3ZlUG9wdXBDb250ZW50LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgbWFwID0gX3Byb3BzMi5tYXA7XG4gICAgICB2YXIgcG9wdXBDb250YWluZXIgPSBfcHJvcHMyLnBvcHVwQ29udGFpbmVyO1xuICAgICAgdmFyIHBvc2l0aW9uID0gX3Byb3BzMi5wb3NpdGlvbjtcblxuICAgICAgdmFyIGVsID0gdGhpcy5sZWFmbGV0RWxlbWVudDtcblxuICAgICAgaWYgKHBvcHVwQ29udGFpbmVyKSB7XG4gICAgICAgIC8vIEF0dGFjaCB0byBjb250YWluZXIgY29tcG9uZW50XG4gICAgICAgIHBvcHVwQ29udGFpbmVyLmJpbmRQb3B1cChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdHRhY2ggdG8gYSBNYXBcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgZWwuc2V0TGF0TG5nKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5vcGVuT24obWFwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnByb3BzLnBvc2l0aW9uO1xuXG4gICAgICBpZiAocG9zaXRpb24gIT09IHByZXZQcm9wcy5wb3NpdGlvbikge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldExhdExuZyhwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxlYWZsZXRFbGVtZW50Ll9pc09wZW4pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQb3B1cENvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9wdXAucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxVbm1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucmVtb3ZlUG9wdXBDb250ZW50KCk7XG4gICAgICB0aGlzLnByb3BzLm1hcC5yZW1vdmVMYXllcih0aGlzLmxlYWZsZXRFbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJQb3B1cENvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQb3B1cENvbnRlbnQoKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAoMCwgX3JlYWN0RG9tLnJlbmRlcikoX3JlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbiksIHRoaXMubGVhZmxldEVsZW1lbnQuX2NvbnRlbnROb2RlKTtcblxuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50Ll91cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudC5fYWRqdXN0UGFuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVBvcHVwQ29udGVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZVBvcHVwQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVBvcHVwQ29udGVudCgpIHtcbiAgICAgIGlmICh0aGlzLmxlYWZsZXRFbGVtZW50Ll9jb250ZW50Tm9kZSkge1xuICAgICAgICAoMCwgX3JlYWN0RG9tLnVubW91bnRDb21wb25lbnRBdE5vZGUpKHRoaXMubGVhZmxldEVsZW1lbnQuX2NvbnRlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLm5vZGUsXG4gICAgICBtYXA6IF9yZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihfbGVhZmxldC5NYXApLFxuICAgICAgcG9wdXBDb250YWluZXI6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgICAgcG9zaXRpb246IF90eXBlc0xhdGxuZzJbJ2RlZmF1bHQnXVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvcHVwO1xufSkoX01hcENvbXBvbmVudDNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBvcHVwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTWFwTGF5ZXIyID0gcmVxdWlyZSgnLi9NYXBMYXllcicpO1xuXG52YXIgX01hcExheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcExheWVyMik7XG5cbnZhciBQb3B1cENvbnRhaW5lciA9IChmdW5jdGlvbiAoX01hcExheWVyKSB7XG4gIF9pbmhlcml0cyhQb3B1cENvbnRhaW5lciwgX01hcExheWVyKTtcblxuICBmdW5jdGlvbiBQb3B1cENvbnRhaW5lcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXBDb250YWluZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9wdXBDb250YWluZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb3B1cENvbnRhaW5lciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENsb25lZENoaWxkcmVuV2l0aE1hcCh7XG4gICAgICAgIHBvcHVwQ29udGFpbmVyOiB0aGlzLmxlYWZsZXRFbGVtZW50XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gfSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvcHVwQ29udGFpbmVyO1xufSkoX01hcExheWVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUG9wdXBDb250YWluZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9sZWFmbGV0ID0gcmVxdWlyZSgnbGVhZmxldCcpO1xuXG52YXIgX3R5cGVzQm91bmRzID0gcmVxdWlyZSgnLi90eXBlcy9ib3VuZHMnKTtcblxudmFyIF90eXBlc0JvdW5kczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlc0JvdW5kcyk7XG5cbnZhciBfUGF0aDIgPSByZXF1aXJlKCcuL1BhdGgnKTtcblxudmFyIF9QYXRoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhdGgyKTtcblxudmFyIFJlY3RhbmdsZSA9IChmdW5jdGlvbiAoX1BhdGgpIHtcbiAgX2luaGVyaXRzKFJlY3RhbmdsZSwgX1BhdGgpO1xuXG4gIGZ1bmN0aW9uIFJlY3RhbmdsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdGFuZ2xlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlY3RhbmdsZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlY3RhbmdsZSwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihSZWN0YW5nbGUucHJvdG90eXBlKSwgJ2NvbXBvbmVudFdpbGxNb3VudCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBib3VuZHMgPSBfcHJvcHMuYm91bmRzO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYm91bmRzJywgJ21hcCddKTtcblxuICAgICAgdGhpcy5sZWFmbGV0RWxlbWVudCA9ICgwLCBfbGVhZmxldC5yZWN0YW5nbGUpKGJvdW5kcywgcHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcyAhPT0gcHJldlByb3BzLmJvdW5kcykge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldEJvdW5kcyh0aGlzLnByb3BzLmJvdW5kcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgIHZhbHVlOiB7XG4gICAgICBib3VuZHM6IF90eXBlc0JvdW5kczJbJ2RlZmF1bHQnXS5pc1JlcXVpcmVkXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1dKTtcblxuICByZXR1cm4gUmVjdGFuZ2xlO1xufSkoX1BhdGgzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBSZWN0YW5nbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vQmFzZVRpbGVMYXllcicpO1xuXG52YXIgX0Jhc2VUaWxlTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRpbGVMYXllcjIpO1xuXG52YXIgVGlsZUxheWVyID0gKGZ1bmN0aW9uIChfQmFzZVRpbGVMYXllcikge1xuICBfaW5oZXJpdHMoVGlsZUxheWVyLCBfQmFzZVRpbGVMYXllcik7XG5cbiAgZnVuY3Rpb24gVGlsZUxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaWxlTGF5ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGlsZUxheWVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGlsZUxheWVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbGVMYXllci5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgdXJsID0gX3Byb3BzLnVybDtcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydtYXAnLCAndXJsJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gKDAsIF9sZWFmbGV0LnRpbGVMYXllcikodXJsLCBwcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdmFyIHVybCA9IHRoaXMucHJvcHMudXJsO1xuXG4gICAgICBpZiAodXJsICYmIHVybCAhPT0gcHJldlByb3BzLnVybCkge1xuICAgICAgICB0aGlzLmxlYWZsZXRFbGVtZW50LnNldFVybCh1cmwpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZToge1xuICAgICAgdXJsOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1dKTtcblxuICByZXR1cm4gVGlsZUxheWVyO1xufSkoX0Jhc2VUaWxlTGF5ZXIzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUaWxlTGF5ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vQmFzZVRpbGVMYXllcicpO1xuXG52YXIgX0Jhc2VUaWxlTGF5ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVRpbGVMYXllcjIpO1xuXG52YXIgV01TVGlsZUxheWVyID0gKGZ1bmN0aW9uIChfQmFzZVRpbGVMYXllcikge1xuICBfaW5oZXJpdHMoV01TVGlsZUxheWVyLCBfQmFzZVRpbGVMYXllcik7XG5cbiAgZnVuY3Rpb24gV01TVGlsZUxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXTVNUaWxlTGF5ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoV01TVGlsZUxheWVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV01TVGlsZUxheWVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFdNU1RpbGVMYXllci5wcm90b3R5cGUpLCAnY29tcG9uZW50V2lsbE1vdW50JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIG1hcCA9IF9wcm9wcy5tYXA7XG4gICAgICB2YXIgdXJsID0gX3Byb3BzLnVybDtcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydtYXAnLCAndXJsJ10pO1xuXG4gICAgICB0aGlzLmxlYWZsZXRFbGVtZW50ID0gX2xlYWZsZXQudGlsZUxheWVyLndtcyh1cmwsIHByb3BzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3Byb3BUeXBlcycsXG4gICAgdmFsdWU6IHtcbiAgICAgIHVybDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XSk7XG5cbiAgcmV0dXJuIFdNU1RpbGVMYXllcjtcbn0pKF9CYXNlVGlsZUxheWVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gV01TVGlsZUxheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2xlYWZsZXQgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XG5cbnZhciBfbGVhZmxldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sZWFmbGV0KTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxudmFyIF9Qcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdHlwZXMpO1xuXG5leHBvcnRzLlByb3BUeXBlcyA9IF9Qcm9wVHlwZXM7XG5cbnZhciBfQmFzZVRpbGVMYXllcjIgPSByZXF1aXJlKCcuL0Jhc2VUaWxlTGF5ZXInKTtcblxudmFyIF9CYXNlVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VUaWxlTGF5ZXIyKTtcblxuZXhwb3J0cy5CYXNlVGlsZUxheWVyID0gX0Jhc2VUaWxlTGF5ZXIzWydkZWZhdWx0J107XG5cbnZhciBfQ2FudmFzVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vQ2FudmFzVGlsZUxheWVyJyk7XG5cbnZhciBfQ2FudmFzVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhc1RpbGVMYXllcjIpO1xuXG5leHBvcnRzLkNhbnZhc1RpbGVMYXllciA9IF9DYW52YXNUaWxlTGF5ZXIzWydkZWZhdWx0J107XG5cbnZhciBfQ2lyY2xlMiA9IHJlcXVpcmUoJy4vQ2lyY2xlJyk7XG5cbnZhciBfQ2lyY2xlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZTIpO1xuXG5leHBvcnRzLkNpcmNsZSA9IF9DaXJjbGUzWydkZWZhdWx0J107XG5cbnZhciBfQ2lyY2xlTWFya2VyMiA9IHJlcXVpcmUoJy4vQ2lyY2xlTWFya2VyJyk7XG5cbnZhciBfQ2lyY2xlTWFya2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZU1hcmtlcjIpO1xuXG5leHBvcnRzLkNpcmNsZU1hcmtlciA9IF9DaXJjbGVNYXJrZXIzWydkZWZhdWx0J107XG5cbnZhciBfRmVhdHVyZUdyb3VwMiA9IHJlcXVpcmUoJy4vRmVhdHVyZUdyb3VwJyk7XG5cbnZhciBfRmVhdHVyZUdyb3VwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZlYXR1cmVHcm91cDIpO1xuXG5leHBvcnRzLkZlYXR1cmVHcm91cCA9IF9GZWF0dXJlR3JvdXAzWydkZWZhdWx0J107XG5cbnZhciBfR2VvSnNvbjIgPSByZXF1aXJlKCcuL0dlb0pzb24nKTtcblxudmFyIF9HZW9Kc29uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dlb0pzb24yKTtcblxuZXhwb3J0cy5HZW9Kc29uID0gX0dlb0pzb24zWydkZWZhdWx0J107XG5cbnZhciBfSW1hZ2VPdmVybGF5MiA9IHJlcXVpcmUoJy4vSW1hZ2VPdmVybGF5Jyk7XG5cbnZhciBfSW1hZ2VPdmVybGF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ltYWdlT3ZlcmxheTIpO1xuXG5leHBvcnRzLkltYWdlT3ZlcmxheSA9IF9JbWFnZU92ZXJsYXkzWydkZWZhdWx0J107XG5cbnZhciBfTGF5ZXJHcm91cDIgPSByZXF1aXJlKCcuL0xheWVyR3JvdXAnKTtcblxudmFyIF9MYXllckdyb3VwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xheWVyR3JvdXAyKTtcblxuZXhwb3J0cy5MYXllckdyb3VwID0gX0xheWVyR3JvdXAzWydkZWZhdWx0J107XG5cbnZhciBfTWFwMiA9IHJlcXVpcmUoJy4vTWFwJyk7XG5cbnZhciBfTWFwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcDIpO1xuXG5leHBvcnRzLk1hcCA9IF9NYXAzWydkZWZhdWx0J107XG5cbnZhciBfTWFwQ29tcG9uZW50MiA9IHJlcXVpcmUoJy4vTWFwQ29tcG9uZW50Jyk7XG5cbnZhciBfTWFwQ29tcG9uZW50MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcENvbXBvbmVudDIpO1xuXG5leHBvcnRzLk1hcENvbXBvbmVudCA9IF9NYXBDb21wb25lbnQzWydkZWZhdWx0J107XG5cbnZhciBfTWFwTGF5ZXIyID0gcmVxdWlyZSgnLi9NYXBMYXllcicpO1xuXG52YXIgX01hcExheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcExheWVyMik7XG5cbmV4cG9ydHMuTWFwTGF5ZXIgPSBfTWFwTGF5ZXIzWydkZWZhdWx0J107XG5cbnZhciBfTWFya2VyMiA9IHJlcXVpcmUoJy4vTWFya2VyJyk7XG5cbnZhciBfTWFya2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hcmtlcjIpO1xuXG5leHBvcnRzLk1hcmtlciA9IF9NYXJrZXIzWydkZWZhdWx0J107XG5cbnZhciBfTXVsdGlQb2x5Z29uMiA9IHJlcXVpcmUoJy4vTXVsdGlQb2x5Z29uJyk7XG5cbnZhciBfTXVsdGlQb2x5Z29uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX011bHRpUG9seWdvbjIpO1xuXG5leHBvcnRzLk11bHRpUG9seWdvbiA9IF9NdWx0aVBvbHlnb24zWydkZWZhdWx0J107XG5cbnZhciBfTXVsdGlQb2x5bGluZTIgPSByZXF1aXJlKCcuL011bHRpUG9seWxpbmUnKTtcblxudmFyIF9NdWx0aVBvbHlsaW5lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX011bHRpUG9seWxpbmUyKTtcblxuZXhwb3J0cy5NdWx0aVBvbHlsaW5lID0gX011bHRpUG9seWxpbmUzWydkZWZhdWx0J107XG5cbnZhciBfUGF0aDIgPSByZXF1aXJlKCcuL1BhdGgnKTtcblxudmFyIF9QYXRoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BhdGgyKTtcblxuZXhwb3J0cy5QYXRoID0gX1BhdGgzWydkZWZhdWx0J107XG5cbnZhciBfUG9seWdvbjIgPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcblxudmFyIF9Qb2x5Z29uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvbHlnb24yKTtcblxuZXhwb3J0cy5Qb2x5Z29uID0gX1BvbHlnb24zWydkZWZhdWx0J107XG5cbnZhciBfUG9seWxpbmUyID0gcmVxdWlyZSgnLi9Qb2x5bGluZScpO1xuXG52YXIgX1BvbHlsaW5lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvbHlsaW5lMik7XG5cbmV4cG9ydHMuUG9seWxpbmUgPSBfUG9seWxpbmUzWydkZWZhdWx0J107XG5cbnZhciBfUG9wdXAyID0gcmVxdWlyZSgnLi9Qb3B1cCcpO1xuXG52YXIgX1BvcHVwMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwMik7XG5cbmV4cG9ydHMuUG9wdXAgPSBfUG9wdXAzWydkZWZhdWx0J107XG5cbnZhciBfUG9wdXBDb250YWluZXIyID0gcmVxdWlyZSgnLi9Qb3B1cENvbnRhaW5lcicpO1xuXG52YXIgX1BvcHVwQ29udGFpbmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwQ29udGFpbmVyMik7XG5cbmV4cG9ydHMuUG9wdXBDb250YWluZXIgPSBfUG9wdXBDb250YWluZXIzWydkZWZhdWx0J107XG5cbnZhciBfUmVjdGFuZ2xlMiA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XG5cbnZhciBfUmVjdGFuZ2xlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlY3RhbmdsZTIpO1xuXG5leHBvcnRzLlJlY3RhbmdsZSA9IF9SZWN0YW5nbGUzWydkZWZhdWx0J107XG5cbnZhciBfVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vVGlsZUxheWVyJyk7XG5cbnZhciBfVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RpbGVMYXllcjIpO1xuXG5leHBvcnRzLlRpbGVMYXllciA9IF9UaWxlTGF5ZXIzWydkZWZhdWx0J107XG5cbnZhciBfV01TVGlsZUxheWVyMiA9IHJlcXVpcmUoJy4vV01TVGlsZUxheWVyJyk7XG5cbnZhciBfV01TVGlsZUxheWVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dNU1RpbGVMYXllcjIpO1xuXG5leHBvcnRzLldNU1RpbGVMYXllciA9IF9XTVNUaWxlTGF5ZXIzWydkZWZhdWx0J107XG52YXIgc2V0SWNvbkRlZmF1bHRJbWFnZVBhdGggPSBmdW5jdGlvbiBzZXRJY29uRGVmYXVsdEltYWdlUGF0aChwYXRoKSB7XG4gIF9sZWFmbGV0MlsnZGVmYXVsdCddLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSBwYXRoO1xufTtcblxuZXhwb3J0cy5zZXRJY29uRGVmYXVsdEltYWdlUGF0aCA9IHNldEljb25EZWZhdWx0SW1hZ2VQYXRoO1xuc2V0SWNvbkRlZmF1bHRJbWFnZVBhdGgoJy8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2xlYWZsZXQvMC43LjUvaW1hZ2VzJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfbGVhZmxldCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcblxudmFyIF9sZWFmbGV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xlYWZsZXQpO1xuXG52YXIgX2xhdGxuZ0xpc3QgPSByZXF1aXJlKCcuL2xhdGxuZ0xpc3QnKTtcblxudmFyIF9sYXRsbmdMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZ0xpc3QpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5pbnN0YW5jZU9mKF9sZWFmbGV0MlsnZGVmYXVsdCddLkxhdExuZ0JvdW5kcyksIF9sYXRsbmdMaXN0MlsnZGVmYXVsdCddXSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfYm91bmRzMiA9IHJlcXVpcmUoJy4vYm91bmRzJyk7XG5cbnZhciBfYm91bmRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JvdW5kczIpO1xuXG5leHBvcnRzLmJvdW5kcyA9IF9ib3VuZHMzWydkZWZhdWx0J107XG5cbnZhciBfbGF0bG5nMiA9IHJlcXVpcmUoJy4vbGF0bG5nJyk7XG5cbnZhciBfbGF0bG5nMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZzIpO1xuXG5leHBvcnRzLmxhdGxuZyA9IF9sYXRsbmczWydkZWZhdWx0J107XG5cbnZhciBfbGF0bG5nTGlzdDIgPSByZXF1aXJlKCcuL2xhdGxuZ0xpc3QnKTtcblxudmFyIF9sYXRsbmdMaXN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xhdGxuZ0xpc3QyKTtcblxuZXhwb3J0cy5sYXRsbmdMaXN0ID0gX2xhdGxuZ0xpc3QzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtcbi8vIFtOdW1iZXIsIE51bWJlcl1cbl9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLm51bWJlciksXG4vLyB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfVxuX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4gIGxhdDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIGxuZzogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcbn0pLFxuLy8ge2xhdDogTnVtYmVyLCBsb246IE51bWJlcn1cbl9yZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xuICBsYXQ6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICBsb246IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59KV0pO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9sYXRsbmcgPSByZXF1aXJlKCcuL2xhdGxuZycpO1xuXG52YXIgX2xhdGxuZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXRsbmcpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX2xhdGxuZzJbJ2RlZmF1bHQnXSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdleGVudicpO1xudmFyIE1vZGFsUG9ydGFsID0gUmVhY3QuY3JlYXRlRmFjdG9yeShyZXF1aXJlKCcuL01vZGFsUG9ydGFsJykpO1xudmFyIGFyaWFBcHBIaWRlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYXJpYUFwcEhpZGVyJyk7XG52YXIgZWxlbWVudENsYXNzID0gcmVxdWlyZSgnZWxlbWVudC1jbGFzcycpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxudmFyIFNhZmVIVE1MRWxlbWVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdy5IVE1MRWxlbWVudCA6IHt9O1xuXG52YXIgTW9kYWwgPSBtb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ01vZGFsJyxcbiAgc3RhdGljczoge1xuICAgIHNldEFwcEVsZW1lbnQ6IGFyaWFBcHBIaWRlci5zZXRFbGVtZW50LFxuICAgIGluamVjdENTUzogZnVuY3Rpb24oKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlZcbiAgICAgICAgJiYgY29uc29sZS53YXJuKCdSZWFjdC1Nb2RhbDogaW5qZWN0Q1NTIGhhcyBiZWVuIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIG5vIGxvbmdlciBoYXMgYW55IGVmZmVjdC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbicpO1xuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBpc09wZW46IFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgc3R5bGU6IFJlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBjb250ZW50OiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgICAgb3ZlcmxheTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICAgIH0pLFxuICAgIGFwcEVsZW1lbnQ6IFJlYWN0LlByb3BUeXBlcy5pbnN0YW5jZU9mKFNhZmVIVE1MRWxlbWVudCksXG4gICAgb25SZXF1ZXN0Q2xvc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGNsb3NlVGltZW91dE1TOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGFyaWFIaWRlQXBwOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgYXJpYUhpZGVBcHA6IHRydWUsXG4gICAgICBjbG9zZVRpbWVvdXRNUzogMFxuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMubm9kZS5jbGFzc05hbWUgPSAnUmVhY3RNb2RhbFBvcnRhbCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgIHRoaXMucmVuZGVyUG9ydGFsKHRoaXMucHJvcHMpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgdGhpcy5yZW5kZXJQb3J0YWwobmV3UHJvcHMpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMubm9kZSk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICB9LFxuXG4gIHJlbmRlclBvcnRhbDogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaXNPcGVuKSB7XG4gICAgICBlbGVtZW50Q2xhc3MoZG9jdW1lbnQuYm9keSkuYWRkKCdSZWFjdE1vZGFsX19Cb2R5LS1vcGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRDbGFzcyhkb2N1bWVudC5ib2R5KS5yZW1vdmUoJ1JlYWN0TW9kYWxfX0JvZHktLW9wZW4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuYXJpYUhpZGVBcHApIHtcbiAgICAgIGFyaWFBcHBIaWRlci50b2dnbGUocHJvcHMuaXNPcGVuLCBwcm9wcy5hcHBFbGVtZW50KTtcbiAgICB9XG4gICAgc2FuaXRpemVQcm9wcyhwcm9wcyk7XG4gICAgdGhpcy5wb3J0YWwgPSByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcih0aGlzLCBNb2RhbFBvcnRhbChwcm9wcyksIHRoaXMubm9kZSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0LkRPTS5ub3NjcmlwdCgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gc2FuaXRpemVQcm9wcyhwcm9wcykge1xuICBkZWxldGUgcHJvcHMucmVmO1xufVxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBkaXYgPSBSZWFjdC5ET00uZGl2O1xudmFyIGZvY3VzTWFuYWdlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZm9jdXNNYW5hZ2VyJyk7XG52YXIgc2NvcGVUYWIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3Njb3BlVGFiJyk7XG52YXIgQXNzaWduID0gcmVxdWlyZSgnbG9kYXNoLmFzc2lnbicpO1xuXG5cbi8vIHNvIHRoYXQgb3VyIENTUyBpcyBzdGF0aWNhbGx5IGFuYWx5emFibGVcbnZhciBDTEFTU19OQU1FUyA9IHtcbiAgb3ZlcmxheToge1xuICAgIGJhc2U6ICdSZWFjdE1vZGFsX19PdmVybGF5JyxcbiAgICBhZnRlck9wZW46ICdSZWFjdE1vZGFsX19PdmVybGF5LS1hZnRlci1vcGVuJyxcbiAgICBiZWZvcmVDbG9zZTogJ1JlYWN0TW9kYWxfX092ZXJsYXktLWJlZm9yZS1jbG9zZSdcbiAgfSxcbiAgY29udGVudDoge1xuICAgIGJhc2U6ICdSZWFjdE1vZGFsX19Db250ZW50JyxcbiAgICBhZnRlck9wZW46ICdSZWFjdE1vZGFsX19Db250ZW50LS1hZnRlci1vcGVuJyxcbiAgICBiZWZvcmVDbG9zZTogJ1JlYWN0TW9kYWxfX0NvbnRlbnQtLWJlZm9yZS1jbG9zZSdcbiAgfVxufTtcblxudmFyIGRlZmF1bHRTdHlsZXMgPSB7XG4gIG92ZXJsYXk6IHtcbiAgICBwb3NpdGlvbiAgICAgICAgOiAnZml4ZWQnLFxuICAgIHRvcCAgICAgICAgICAgICA6IDAsXG4gICAgbGVmdCAgICAgICAgICAgIDogMCxcbiAgICByaWdodCAgICAgICAgICAgOiAwLFxuICAgIGJvdHRvbSAgICAgICAgICA6IDAsXG4gICAgYmFja2dyb3VuZENvbG9yIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknXG4gIH0sXG4gIGNvbnRlbnQ6IHtcbiAgICBwb3NpdGlvbiAgICAgICAgICAgICAgICA6ICdhYnNvbHV0ZScsXG4gICAgdG9wICAgICAgICAgICAgICAgICAgICAgOiAnNDBweCcsXG4gICAgbGVmdCAgICAgICAgICAgICAgICAgICAgOiAnNDBweCcsXG4gICAgcmlnaHQgICAgICAgICAgICAgICAgICAgOiAnNDBweCcsXG4gICAgYm90dG9tICAgICAgICAgICAgICAgICAgOiAnNDBweCcsXG4gICAgYm9yZGVyICAgICAgICAgICAgICAgICAgOiAnMXB4IHNvbGlkICNjY2MnLFxuICAgIGJhY2tncm91bmQgICAgICAgICAgICAgIDogJyNmZmYnLFxuICAgIG92ZXJmbG93ICAgICAgICAgICAgICAgIDogJ2F1dG8nLFxuICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nIDogJ3RvdWNoJyxcbiAgICBib3JkZXJSYWRpdXMgICAgICAgICAgICA6ICc0cHgnLFxuICAgIG91dGxpbmUgICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgIHBhZGRpbmcgICAgICAgICAgICAgICAgIDogJzIwcHgnXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxudmFyIE1vZGFsUG9ydGFsID0gbW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdNb2RhbFBvcnRhbCcsXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgb3ZlcmxheToge30sXG4gICAgICAgIGNvbnRlbnQ6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZnRlck9wZW46IGZhbHNlLFxuICAgICAgYmVmb3JlQ2xvc2U6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgLy8gRm9jdXMgbmVlZHMgdG8gYmUgc2V0IHdoZW4gbW91bnRpbmcgYW5kIGFscmVhZHkgb3BlblxuICAgIGlmICh0aGlzLnByb3BzLmlzT3Blbikge1xuICAgICAgdGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKHRydWUpO1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXdQcm9wcykge1xuICAgIC8vIEZvY3VzIG9ubHkgbmVlZHMgdG8gYmUgc2V0IG9uY2Ugd2hlbiB0aGUgbW9kYWwgaXMgYmVpbmcgb3BlbmVkXG4gICAgaWYgKCF0aGlzLnByb3BzLmlzT3BlbiAmJiBuZXdQcm9wcy5pc09wZW4pIHtcbiAgICAgIHRoaXMuc2V0Rm9jdXNBZnRlclJlbmRlcih0cnVlKTtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5pc09wZW4gJiYgIW5ld1Byb3BzLmlzT3Blbikge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mb2N1c0FmdGVyUmVuZGVyKSB7XG4gICAgICB0aGlzLmZvY3VzQ29udGVudCgpO1xuICAgICAgdGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0Rm9jdXNBZnRlclJlbmRlcjogZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgdGhpcy5mb2N1c0FmdGVyUmVuZGVyID0gZm9jdXM7XG4gIH0sXG5cbiAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgZm9jdXNNYW5hZ2VyLnNldHVwU2NvcGVkRm9jdXModGhpcy5ub2RlKTtcbiAgICBmb2N1c01hbmFnZXIubWFya0ZvckZvY3VzTGF0ZXIoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtpc09wZW46IHRydWV9LCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2FmdGVyT3BlbjogdHJ1ZX0pO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vd25lckhhbmRsZXNDbG9zZSgpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnByb3BzLmNsb3NlVGltZW91dE1TID4gMClcbiAgICAgIHRoaXMuY2xvc2VXaXRoVGltZW91dCgpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuY2xvc2VXaXRob3V0VGltZW91dCgpO1xuICB9LFxuXG4gIGZvY3VzQ29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWZzLmNvbnRlbnQuZm9jdXMoKTtcbiAgfSxcblxuICBjbG9zZVdpdGhUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtiZWZvcmVDbG9zZTogdHJ1ZX0sIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLmNsb3NlV2l0aG91dFRpbWVvdXQsIHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgY2xvc2VXaXRob3V0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhZnRlck9wZW46IGZhbHNlLFxuICAgICAgYmVmb3JlQ2xvc2U6IGZhbHNlXG4gICAgfSwgdGhpcy5hZnRlckNsb3NlKTtcbiAgfSxcblxuICBhZnRlckNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBmb2N1c01hbmFnZXIucmV0dXJuRm9jdXMoKTtcbiAgICBmb2N1c01hbmFnZXIudGVhcmRvd25TY29wZWRGb2N1cygpO1xuICB9LFxuXG4gIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOSAvKnRhYiovKSBzY29wZVRhYih0aGlzLnJlZnMuY29udGVudCwgZXZlbnQpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3IC8qZXNjKi8pIHRoaXMucmVxdWVzdENsb3NlKCk7XG4gIH0sXG5cbiAgaGFuZGxlT3ZlcmxheUNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vd25lckhhbmRsZXNDbG9zZSgpKVxuICAgICAgdGhpcy5yZXF1ZXN0Q2xvc2UoKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmZvY3VzQ29udGVudCgpO1xuICB9LFxuXG4gIHJlcXVlc3RDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3duZXJIYW5kbGVzQ2xvc2UoKSlcbiAgICAgIHRoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2UoKTtcbiAgfSxcblxuICBvd25lckhhbmRsZXNDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2U7XG4gIH0sXG5cbiAgc2hvdWxkQmVDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5wcm9wcy5pc09wZW4gJiYgIXRoaXMuc3RhdGUuYmVmb3JlQ2xvc2U7XG4gIH0sXG5cbiAgYnVpbGRDbGFzc05hbWU6IGZ1bmN0aW9uKHdoaWNoLCBhZGRpdGlvbmFsKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IENMQVNTX05BTUVTW3doaWNoXS5iYXNlO1xuICAgIGlmICh0aGlzLnN0YXRlLmFmdGVyT3BlbilcbiAgICAgIGNsYXNzTmFtZSArPSAnICcrQ0xBU1NfTkFNRVNbd2hpY2hdLmFmdGVyT3BlbjtcbiAgICBpZiAodGhpcy5zdGF0ZS5iZWZvcmVDbG9zZSlcbiAgICAgIGNsYXNzTmFtZSArPSAnICcrQ0xBU1NfTkFNRVNbd2hpY2hdLmJlZm9yZUNsb3NlO1xuICAgIHJldHVybiBhZGRpdGlvbmFsID8gY2xhc3NOYW1lICsgJyAnICsgYWRkaXRpb25hbCA6IGNsYXNzTmFtZTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNob3VsZEJlQ2xvc2VkKCkgPyBkaXYoKSA6IChcbiAgICAgIGRpdih7XG4gICAgICAgIHJlZjogXCJvdmVybGF5XCIsXG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENsYXNzTmFtZSgnb3ZlcmxheScsIHRoaXMucHJvcHMub3ZlcmxheUNsYXNzTmFtZSksXG4gICAgICAgIHN0eWxlOiBBc3NpZ24oe30sIGRlZmF1bHRTdHlsZXMub3ZlcmxheSwgdGhpcy5wcm9wcy5zdHlsZS5vdmVybGF5IHx8IHt9KSxcbiAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVPdmVybGF5Q2xpY2tcbiAgICAgIH0sXG4gICAgICAgIGRpdih7XG4gICAgICAgICAgcmVmOiBcImNvbnRlbnRcIixcbiAgICAgICAgICBzdHlsZTogQXNzaWduKHt9LCBkZWZhdWx0U3R5bGVzLmNvbnRlbnQsIHRoaXMucHJvcHMuc3R5bGUuY29udGVudCB8fCB7fSksXG4gICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ2xhc3NOYW1lKCdjb250ZW50JywgdGhpcy5wcm9wcy5jbGFzc05hbWUpLFxuICAgICAgICAgIHRhYkluZGV4OiBcIi0xXCIsXG4gICAgICAgICAgb25DbGljazogc3RvcFByb3BhZ2F0aW9uLFxuICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duXG4gICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG4iLCJ2YXIgX2VsZW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbmZ1bmN0aW9uIHNldEVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50KTtcbiAgICBlbGVtZW50ID0gJ2xlbmd0aCcgaW4gZWwgPyBlbFswXSA6IGVsO1xuICB9XG4gIF9lbGVtZW50ID0gZWxlbWVudCB8fCBfZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaGlkZShhcHBFbGVtZW50KSB7XG4gIHZhbGlkYXRlRWxlbWVudChhcHBFbGVtZW50KTtcbiAgKGFwcEVsZW1lbnQgfHwgX2VsZW1lbnQpLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBzaG93KGFwcEVsZW1lbnQpIHtcbiAgdmFsaWRhdGVFbGVtZW50KGFwcEVsZW1lbnQpO1xuICAoYXBwRWxlbWVudCB8fCBfZWxlbWVudCkucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGUoc2hvdWxkSGlkZSwgYXBwRWxlbWVudCkge1xuICBpZiAoc2hvdWxkSGlkZSlcbiAgICBoaWRlKGFwcEVsZW1lbnQpO1xuICBlbHNlXG4gICAgc2hvdyhhcHBFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbGVtZW50KGFwcEVsZW1lbnQpIHtcbiAgaWYgKCFhcHBFbGVtZW50ICYmICFfZWxlbWVudClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LW1vZGFsOiBZb3UgbXVzdCBzZXQgYW4gZWxlbWVudCB3aXRoIGBNb2RhbC5zZXRBcHBFbGVtZW50KGVsKWAgdG8gbWFrZSB0aGlzIGFjY2Vzc2libGUnKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRGb3JUZXN0aW5nKCkge1xuICBfZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG59XG5cbmV4cG9ydHMudG9nZ2xlID0gdG9nZ2xlO1xuZXhwb3J0cy5zZXRFbGVtZW50ID0gc2V0RWxlbWVudDtcbmV4cG9ydHMuc2hvdyA9IHNob3c7XG5leHBvcnRzLmhpZGUgPSBoaWRlO1xuZXhwb3J0cy5yZXNldEZvclRlc3RpbmcgPSByZXNldEZvclRlc3Rpbmc7XG4iLCJ2YXIgZmluZFRhYmJhYmxlID0gcmVxdWlyZSgnLi4vaGVscGVycy90YWJiYWJsZScpO1xudmFyIG1vZGFsRWxlbWVudCA9IG51bGw7XG52YXIgZm9jdXNMYXRlckVsZW1lbnQgPSBudWxsO1xudmFyIG5lZWRUb0ZvY3VzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgbmVlZFRvRm9jdXMgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVGb2N1cyhldmVudCkge1xuICBpZiAobmVlZFRvRm9jdXMpIHtcbiAgICBuZWVkVG9Gb2N1cyA9IGZhbHNlO1xuICAgIGlmICghbW9kYWxFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG5lZWQgdG8gc2VlIGhvdyBqUXVlcnkgc2hpbXMgZG9jdW1lbnQub24oJ2ZvY3VzaW4nKSBzbyB3ZSBkb24ndCBuZWVkIHRoZVxuICAgIC8vIHNldFRpbWVvdXQsIGZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IGZvY3VzaW4sIGlmIGl0IGRpZCwgd2UgY291bGQgZm9jdXNcbiAgICAvLyB0aGUgZWxlbWVudCBvdXRzaWRlIG9mIGEgc2V0VGltZW91dC4gU2lkZS1lZmZlY3Qgb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBcbiAgICAvLyBpcyB0aGF0IHRoZSBkb2N1bWVudC5ib2R5IGdldHMgZm9jdXMsIGFuZCB0aGVuIHdlIGZvY3VzIG91ciBlbGVtZW50IHJpZ2h0IFxuICAgIC8vIGFmdGVyLCBzZWVtcyBmaW5lLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobW9kYWxFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgZWwgPSAoZmluZFRhYmJhYmxlKG1vZGFsRWxlbWVudClbMF0gfHwgbW9kYWxFbGVtZW50KTtcbiAgICAgIGVsLmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZXhwb3J0cy5tYXJrRm9yRm9jdXNMYXRlciA9IGZ1bmN0aW9uKCkge1xuICBmb2N1c0xhdGVyRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG59O1xuXG5leHBvcnRzLnJldHVybkZvY3VzID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgZm9jdXNMYXRlckVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybignWW91IHRyaWVkIHRvIHJldHVybiBmb2N1cyB0byAnK2ZvY3VzTGF0ZXJFbGVtZW50KycgYnV0IGl0IGlzIG5vdCBpbiB0aGUgRE9NIGFueW1vcmUnKTtcbiAgfVxuICBmb2N1c0xhdGVyRWxlbWVudCA9IG51bGw7XG59O1xuXG5leHBvcnRzLnNldHVwU2NvcGVkRm9jdXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIG1vZGFsRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbkJsdXInLCBoYW5kbGVCbHVyKTtcbiAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25Gb2N1cycsIGhhbmRsZUZvY3VzKTtcbiAgfVxufTtcblxuZXhwb3J0cy50ZWFyZG93blNjb3BlZEZvY3VzID0gZnVuY3Rpb24oKSB7XG4gIG1vZGFsRWxlbWVudCA9IG51bGw7XG5cbiAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGV0YWNoRXZlbnQoJ29uQmx1cicsIGhhbmRsZUJsdXIpO1xuICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KCdvbkZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICB9XG59O1xuXG5cbiIsInZhciBmaW5kVGFiYmFibGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RhYmJhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obm9kZSwgZXZlbnQpIHtcbiAgdmFyIHRhYmJhYmxlID0gZmluZFRhYmJhYmxlKG5vZGUpO1xuICB2YXIgZmluYWxUYWJiYWJsZSA9IHRhYmJhYmxlW2V2ZW50LnNoaWZ0S2V5ID8gMCA6IHRhYmJhYmxlLmxlbmd0aCAtIDFdO1xuICB2YXIgbGVhdmluZ0ZpbmFsVGFiYmFibGUgPSAoXG4gICAgZmluYWxUYWJiYWJsZSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fFxuICAgIC8vIGhhbmRsZSBpbW1lZGlhdGUgc2hpZnQrdGFiIGFmdGVyIG9wZW5pbmcgd2l0aCBtb3VzZVxuICAgIG5vZGUgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgKTtcbiAgaWYgKCFsZWF2aW5nRmluYWxUYWJiYWJsZSkgcmV0dXJuO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB2YXIgdGFyZ2V0ID0gdGFiYmFibGVbZXZlbnQuc2hpZnRLZXkgPyB0YWJiYWJsZS5sZW5ndGggLSAxIDogMF07XG4gIHRhcmdldC5mb2N1cygpO1xufTtcbiIsIi8qIVxuICogQWRhcHRlZCBmcm9tIGpRdWVyeSBVSSBjb3JlXG4gKlxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jYXRlZ29yeS91aS1jb3JlL1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzYWJsZShlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3Qobm9kZU5hbWUpID9cbiAgICAhZWxlbWVudC5kaXNhYmxlZCA6XG4gICAgXCJhXCIgPT09IG5vZGVOYW1lID9cbiAgICAgIGVsZW1lbnQuaHJlZiB8fCBpc1RhYkluZGV4Tm90TmFOIDpcbiAgICAgIGlzVGFiSW5kZXhOb3ROYU4pICYmIHZpc2libGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGhpZGRlbihlbCkge1xuICByZXR1cm4gKGVsLm9mZnNldFdpZHRoIDw9IDAgJiYgZWwub2Zmc2V0SGVpZ2h0IDw9IDApIHx8XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnO1xufVxuXG5mdW5jdGlvbiB2aXNpYmxlKGVsZW1lbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkgYnJlYWs7XG4gICAgaWYgKGhpZGRlbihlbGVtZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHRhYmJhYmxlKGVsZW1lbnQpIHtcbiAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gIGlmICh0YWJJbmRleCA9PT0gbnVsbCkgdGFiSW5kZXggPSB1bmRlZmluZWQ7XG4gIHZhciBpc1RhYkluZGV4TmFOID0gaXNOYU4odGFiSW5kZXgpO1xuICByZXR1cm4gKGlzVGFiSW5kZXhOYU4gfHwgdGFiSW5kZXggPj0gMCkgJiYgZm9jdXNhYmxlKGVsZW1lbnQsICFpc1RhYkluZGV4TmFOKTtcbn1cblxuZnVuY3Rpb24gZmluZFRhYmJhYmxlRGVzY2VuZGFudHMoZWxlbWVudCkge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSwgMCkuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIHRhYmJhYmxlKGVsKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFRhYmJhYmxlRGVzY2VuZGFudHM7XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL01vZGFsJyk7XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICByZXR1cm4gbmV3IEVsZW1lbnRDbGFzcyhvcHRzKVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgcHJvcCkge1xuICBpZiAoYXJyLmluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihwcm9wKVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgIGlmIChhcnJbaV0gPT09IHByb3ApIHJldHVybiBpXG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBFbGVtZW50Q2xhc3Mob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRWxlbWVudENsYXNzKSkgcmV0dXJuIG5ldyBFbGVtZW50Q2xhc3Mob3B0cylcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgLy8gc2ltaWxhciBkb2luZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IGJ1dCB3b3JrcyBpbiBJRThcbiAgaWYgKG9wdHMubm9kZVR5cGUpIG9wdHMgPSB7ZWw6IG9wdHN9XG5cbiAgdGhpcy5vcHRzID0gb3B0c1xuICB0aGlzLmVsID0gb3B0cy5lbCB8fCBkb2N1bWVudC5ib2R5XG4gIGlmICh0eXBlb2YgdGhpcy5lbCAhPT0gJ29iamVjdCcpIHRoaXMuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZWwpXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGlmIChlbC5jbGFzc05hbWUgPT09IFwiXCIpIHJldHVybiBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVxuICBpZiAoaW5kZXhPZihjbGFzc2VzLCBjbGFzc05hbWUpID4gLTEpIHJldHVybiBjbGFzc2VzXG4gIGNsYXNzZXMucHVzaChjbGFzc05hbWUpXG4gIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpXG4gIHJldHVybiBjbGFzc2VzXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGlmIChlbC5jbGFzc05hbWUgPT09IFwiXCIpIHJldHVyblxuICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgnICcpXG4gIHZhciBpZHggPSBpbmRleE9mKGNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgaWYgKGlkeCA+IC0xKSBjbGFzc2VzLnNwbGljZShpZHgsIDEpXG4gIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpXG4gIHJldHVybiBjbGFzc2VzXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KCcgJylcbiAgcmV0dXJuIGluZGV4T2YoY2xhc3NlcywgY2xhc3NOYW1lKSA+IC0xXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGlmICh0aGlzLmhhcyhjbGFzc05hbWUpKSB0aGlzLnJlbW92ZShjbGFzc05hbWUpXG4gIGVsc2UgdGhpcy5hZGQoY2xhc3NOYW1lKVxufVxuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNSBKZWQgV2F0c29uLlxuICBCYXNlZCBvbiBjb2RlIHRoYXQgaXMgQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY2FuVXNlRE9NID0gISEoXG5cdFx0dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHR3aW5kb3cuZG9jdW1lbnQgJiZcblx0XHR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuXHQpO1xuXG5cdHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuXHRcdGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG5cdFx0Y2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cblx0XHRjYW5Vc2VFdmVudExpc3RlbmVyczpcblx0XHRcdGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG5cdFx0Y2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW5cblxuXHR9O1xuXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LkV4ZWN1dGlvbkVudmlyb25tZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cdH1cblxufSgpKTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWFzc2lnbicpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnbG9kYXNoLl9jcmVhdGVhc3NpZ25lcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5hc3NpZ25gIGZvciBjdXN0b21pemluZyBhc3NpZ25lZCB2YWx1ZXMgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmBcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBhc3NpZ25XaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHx8XG4gICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICogSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLlxuICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAqIChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBiYXNlZCBvblxuICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgZXh0ZW5kXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmFzc2lnbih7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogNDAgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gKlxuICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHZhbHVlKSA/IG90aGVyIDogdmFsdWU7XG4gKiB9KTtcbiAqXG4gKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAqL1xudmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gIHJldHVybiBjdXN0b21pemVyXG4gICAgPyBhc3NpZ25XaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKVxuICAgIDogYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCIvKipcbiAqIGxvZGFzaCAzLjIuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VDb3B5ID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlY29weScpLFxuICAgIGtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlID09IG51bGxcbiAgICA/IG9iamVjdFxuICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNvcHk7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjEuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJ2xvZGFzaC5fYmluZGNhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCdsb2Rhc2guX2lzaXRlcmF0ZWVjYWxsJyksXG4gICAgcmVzdFBhcmFtID0gcmVxdWlyZSgnbG9kYXNoLnJlc3RwYXJhbScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFzc2lnbnMgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIGEgZ2l2ZW5cbiAqIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBgXy5hc3NpZ25gLCBgXy5kZWZhdWx0c2AsIGFuZCBgXy5tZXJnZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgIGxlbmd0aCAtPSAoY3VzdG9taXplciA/IDEgOiAwKTtcbiAgICB9XG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodGhpc0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbiAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kQ2FsbGJhY2s7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuOSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkpIHtcbiAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy42LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG4iLCIvKipcbiAqIGxvZGFzaCAzLjEuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fZ2V0bmF0aXZlJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdsb2Rhc2guaXNhcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL15cXGQrJC87XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBnZXROYXRpdmUoT2JqZWN0LCAna2V5cycpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICogb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gcHJvcHNMZW5ndGggJiYgb2JqZWN0Lmxlbmd0aDtcblxuICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbnZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICBza2lwSW5kZXhlcyA9IGxlbmd0aCA+IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy45LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuOCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIGluY29ycmVjdGx5IG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIHdlYWsgbWFwIGNvbnN0cnVjdG9ycyxcbiAgLy8gYW5kIFBoYW50b21KUyAxLjkgd2hpY2ggcmV0dXJucyAnZnVuY3Rpb24nIGZvciBgTm9kZUxpc3RgIGluc3RhbmNlcy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbG9vc2VseSBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIEFjY2Vzc29yID0ge1xuICBJREVOVElUWV9GTjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9LFxuXG4gIGdlbmVyYXRlQWNjZXNzb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2ZpZWxkXTtcbiAgICB9O1xuICB9LFxuXG4gIGdlbmVyYXRlT3B0aW9uVG9TdHJpbmdGb3I6IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVBY2Nlc3Nvcihwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuSURFTlRJVFlfRk47XG4gICAgfVxuICB9LFxuXG4gIHZhbHVlRm9yT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvYmplY3Rbb3B0aW9uXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcHRpb24ob2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjZXNzb3I7IiwiLyoqXG4gKiBQb2x5RmlsbHMgbWFrZSBtZSBzYWRcbiAqL1xudmFyIEtleUV2ZW50ID0gS2V5RXZlbnQgfHwge307XG5LZXlFdmVudC5ET01fVktfVVAgPSBLZXlFdmVudC5ET01fVktfVVAgfHwgMzg7XG5LZXlFdmVudC5ET01fVktfRE9XTiA9IEtleUV2ZW50LkRPTV9WS19ET1dOIHx8IDQwO1xuS2V5RXZlbnQuRE9NX1ZLX0JBQ0tfU1BBQ0UgPSBLZXlFdmVudC5ET01fVktfQkFDS19TUEFDRSB8fCA4O1xuS2V5RXZlbnQuRE9NX1ZLX1JFVFVSTiA9IEtleUV2ZW50LkRPTV9WS19SRVRVUk4gfHwgMTM7XG5LZXlFdmVudC5ET01fVktfRU5URVIgPSBLZXlFdmVudC5ET01fVktfRU5URVIgfHwgMTQ7XG5LZXlFdmVudC5ET01fVktfRVNDQVBFID0gS2V5RXZlbnQuRE9NX1ZLX0VTQ0FQRSB8fCAyNztcbktleUV2ZW50LkRPTV9WS19UQUIgPSBLZXlFdmVudC5ET01fVktfVEFCIHx8IDk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXZlbnQ7IiwidmFyIFR5cGVhaGVhZCA9IHJlcXVpcmUoJy4vdHlwZWFoZWFkJyk7XG52YXIgVG9rZW5pemVyID0gcmVxdWlyZSgnLi90b2tlbml6ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFR5cGVhaGVhZDogVHlwZWFoZWFkLFxuICBUb2tlbml6ZXI6IFRva2VuaXplclxufTsiLCJ2YXIgQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9hY2Nlc3NvcicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vdG9rZW4nKTtcbnZhciBLZXlFdmVudCA9IHJlcXVpcmUoJy4uL2tleWV2ZW50Jyk7XG52YXIgVHlwZWFoZWFkID0gcmVxdWlyZSgnLi4vdHlwZWFoZWFkJyk7XG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuZnVuY3Rpb24gX2FycmF5c0FyZURpZmZlcmVudChhcnJheTEsIGFycmF5Mikge1xuICBpZiAoYXJyYXkxLmxlbmd0aCAhPSBhcnJheTIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IGFycmF5Mi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChhcnJheTJbaV0gIT09IGFycmF5MVtpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSB0eXBlYWhlYWQgdGhhdCwgd2hlbiBhbiBvcHRpb24gaXMgc2VsZWN0ZWQsIGluc3RlYWQgb2Ygc2ltcGx5IGZpbGxpbmdcbiAqIHRoZSB0ZXh0IGVudHJ5IHdpZGdldCwgcHJlcGVuZHMgYSByZW5kZXJhYmxlIFwidG9rZW5cIiwgdGhhdCBtYXkgYmUgZGVsZXRlZFxuICogYnkgcHJlc3NpbmcgYmFja3NwYWNlIG9uIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgd2l0aCB0aGUga2V5Ym9hcmQuXG4gKi9cbnZhciBUeXBlYWhlYWRUb2tlbml6ZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVHlwZWFoZWFkVG9rZW5pemVyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBjdXN0b21DbGFzc2VzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGFsbG93Q3VzdG9tVmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGRlZmF1bHRTZWxlY3RlZDogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIGRlZmF1bHRWYWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkaXNhYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaW5wdXRQcm9wczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvblRva2VuUmVtb3ZlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5UHJlc3M6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5VXA6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG9rZW5BZGQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZmlsdGVyT3B0aW9uOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBSZWFjdC5Qcm9wVHlwZXMuZnVuY10pLFxuICAgIGRpc3BsYXlPcHRpb246IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIFJlYWN0LlByb3BUeXBlcy5mdW5jXSksXG4gICAgZm9ybUlucHV0T3B0aW9uOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBSZWFjdC5Qcm9wVHlwZXMuZnVuY10pLFxuICAgIG1heFZpc2libGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZGVmYXVsdENsYXNzTmFtZXM6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29weSB0aGlzIHRvIGF2b2lkIGluY29ycmVjdCBzaGFyaW5nXG4gICAgICAvLyBvZiBzdGF0ZSBhY3Jvc3MgaW5zdGFuY2VzIChlLmcuLCB2aWEgZ2V0RGVmYXVsdFByb3BzKCkpXG4gICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5kZWZhdWx0U2VsZWN0ZWQuc2xpY2UoMClcbiAgICB9O1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiBbXSxcbiAgICAgIGRlZmF1bHRTZWxlY3RlZDogW10sXG4gICAgICBjdXN0b21DbGFzc2VzOiB7fSxcbiAgICAgIGFsbG93Q3VzdG9tVmFsdWVzOiAwLFxuICAgICAgZGVmYXVsdFZhbHVlOiBcIlwiLFxuICAgICAgcGxhY2Vob2xkZXI6IFwiXCIsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBpbnB1dFByb3BzOiB7fSxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVzOiB0cnVlLFxuICAgICAgZmlsdGVyT3B0aW9uOiBudWxsLFxuICAgICAgZGlzcGxheU9wdGlvbjogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0sXG4gICAgICBmb3JtSW5wdXRPcHRpb246IG51bGwsXG4gICAgICBvbktleURvd246IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvbktleVByZXNzOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25LZXlVcDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgIG9uRm9jdXM6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvbkJsdXI6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvblRva2VuQWRkOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIG9uVG9rZW5SZW1vdmU6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgLy8gaWYgd2UgZ2V0IG5ldyBkZWZhdWx0UHJvcHMsIHVwZGF0ZSBzZWxlY3RlZFxuICAgIGlmIChfYXJyYXlzQXJlRGlmZmVyZW50KHRoaXMucHJvcHMuZGVmYXVsdFNlbGVjdGVkLCBuZXh0UHJvcHMuZGVmYXVsdFNlbGVjdGVkKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGVkOiBuZXh0UHJvcHMuZGVmYXVsdFNlbGVjdGVkLnNsaWNlKDApIH0pO1xuICAgIH1cbiAgfSxcblxuICBmb2N1czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVmcy50eXBlYWhlYWQuZm9jdXMoKTtcbiAgfSxcblxuICBnZXRTZWxlY3RlZFRva2VuczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkO1xuICB9LFxuXG4gIC8vIFRPRE86IFN1cHBvcnQgaW5pdGlhbGl6ZWQgdG9rZW5zXG4gIC8vXG4gIF9yZW5kZXJUb2tlbnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9rZW5DbGFzc2VzID0ge307XG4gICAgdG9rZW5DbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy50b2tlbl0gPSAhIXRoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy50b2tlbjtcbiAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lcyh0b2tlbkNsYXNzZXMpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnN0YXRlLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBkaXNwbGF5U3RyaW5nID0gQWNjZXNzb3IudmFsdWVGb3JPcHRpb24odGhpcy5wcm9wcy5kaXNwbGF5T3B0aW9uLCBzZWxlY3RlZCk7XG4gICAgICB2YXIgdmFsdWUgPSBBY2Nlc3Nvci52YWx1ZUZvck9wdGlvbih0aGlzLnByb3BzLmZvcm1JbnB1dE9wdGlvbiB8fCB0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24sIHNlbGVjdGVkKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBUb2tlbixcbiAgICAgICAgeyBrZXk6IGRpc3BsYXlTdHJpbmcsIGNsYXNzTmFtZTogY2xhc3NMaXN0LFxuICAgICAgICAgIG9uUmVtb3ZlOiB0aGlzLl9yZW1vdmVUb2tlbkZvclZhbHVlLFxuICAgICAgICAgIG9iamVjdDogc2VsZWN0ZWQsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5hbWU6IHRoaXMucHJvcHMubmFtZSB9LFxuICAgICAgICBkaXNwbGF5U3RyaW5nXG4gICAgICApO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgX2dldE9wdGlvbnNGb3JUeXBlYWhlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZXR1cm4gdGhpcy5wcm9wcy5vcHRpb25zIHdpdGhvdXQgdGhpcy5zZWxlY3RlZFxuICAgIHJldHVybiB0aGlzLnByb3BzLm9wdGlvbnM7XG4gIH0sXG5cbiAgX29uS2V5RG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IGludGVyY2VwdGluZyBiYWNrc3BhY2VzXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleUV2ZW50LkRPTV9WS19CQUNLX1NQQUNFKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmFja3NwYWNlKGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbktleURvd24oZXZlbnQpO1xuICB9LFxuXG4gIF9oYW5kbGVCYWNrc3BhY2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIE5vIHRva2Vuc1xuICAgIGlmICghdGhpcy5zdGF0ZS5zZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdG9rZW4gT05MWSB3aGVuIGJrc3AgcHJlc3NlZCBhdCBiZWdpbm5pbmcgb2YgbGluZVxuICAgIC8vIHdpdGhvdXQgYSBzZWxlY3Rpb25cbiAgICB2YXIgZW50cnkgPSB0aGlzLnJlZnMudHlwZWFoZWFkLnJlZnMuZW50cnk7XG4gICAgaWYgKGVudHJ5LnNlbGVjdGlvblN0YXJ0ID09IGVudHJ5LnNlbGVjdGlvbkVuZCAmJiBlbnRyeS5zZWxlY3Rpb25TdGFydCA9PSAwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVUb2tlbkZvclZhbHVlKHRoaXMuc3RhdGUuc2VsZWN0ZWRbdGhpcy5zdGF0ZS5zZWxlY3RlZC5sZW5ndGggLSAxXSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICBfcmVtb3ZlVG9rZW5Gb3JWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zdGF0ZS5zZWxlY3RlZC5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGVkOiB0aGlzLnN0YXRlLnNlbGVjdGVkIH0pO1xuICAgIHRoaXMucHJvcHMub25Ub2tlblJlbW92ZSh2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIF9hZGRUb2tlbkZvclZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZC5pbmRleE9mKHZhbHVlKSAhPSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNlbGVjdGVkLnB1c2godmFsdWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZDogdGhpcy5zdGF0ZS5zZWxlY3RlZCB9KTtcbiAgICB0aGlzLnJlZnMudHlwZWFoZWFkLnNldEVudHJ5VGV4dChcIlwiKTtcbiAgICB0aGlzLnByb3BzLm9uVG9rZW5BZGQodmFsdWUpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgY2xhc3Nlc1t0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMudHlwZWFoZWFkXSA9ICEhdGhpcy5wcm9wcy5jdXN0b21DbGFzc2VzLnR5cGVhaGVhZDtcbiAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lcyhjbGFzc2VzKTtcbiAgICB2YXIgdG9rZW5pemVyQ2xhc3NlcyA9IFt0aGlzLnByb3BzLmRlZmF1bHRDbGFzc05hbWVzICYmIFwidHlwZWFoZWFkLXRva2VuaXplclwiXTtcbiAgICB0b2tlbml6ZXJDbGFzc2VzW3RoaXMucHJvcHMuY2xhc3NOYW1lXSA9ICEhdGhpcy5wcm9wcy5jbGFzc05hbWU7XG4gICAgdmFyIHRva2VuaXplckNsYXNzTGlzdCA9IGNsYXNzTmFtZXModG9rZW5pemVyQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHRva2VuaXplckNsYXNzTGlzdCB9LFxuICAgICAgdGhpcy5fcmVuZGVyVG9rZW5zKCksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVhaGVhZCwgeyByZWY6ICd0eXBlYWhlYWQnLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTGlzdCxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLnByb3BzLmRpc2FibGVkLFxuICAgICAgICBpbnB1dFByb3BzOiB0aGlzLnByb3BzLmlucHV0UHJvcHMsXG4gICAgICAgIGFsbG93Q3VzdG9tVmFsdWVzOiB0aGlzLnByb3BzLmFsbG93Q3VzdG9tVmFsdWVzLFxuICAgICAgICBjdXN0b21DbGFzc2VzOiB0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMuX2dldE9wdGlvbnNGb3JUeXBlYWhlYWQoKSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgbWF4VmlzaWJsZTogdGhpcy5wcm9wcy5tYXhWaXNpYmxlLFxuICAgICAgICBvbk9wdGlvblNlbGVjdGVkOiB0aGlzLl9hZGRUb2tlbkZvclZhbHVlLFxuICAgICAgICBvbktleURvd246IHRoaXMuX29uS2V5RG93bixcbiAgICAgICAgb25LZXlQcmVzczogdGhpcy5wcm9wcy5vbktleVByZXNzLFxuICAgICAgICBvbktleVVwOiB0aGlzLnByb3BzLm9uS2V5VXAsXG4gICAgICAgIG9uRm9jdXM6IHRoaXMucHJvcHMub25Gb2N1cyxcbiAgICAgICAgb25CbHVyOiB0aGlzLnByb3BzLm9uQmx1cixcbiAgICAgICAgZGlzcGxheU9wdGlvbjogdGhpcy5wcm9wcy5kaXNwbGF5T3B0aW9uLFxuICAgICAgICBkZWZhdWx0Q2xhc3NOYW1lczogdGhpcy5wcm9wcy5kZWZhdWx0Q2xhc3NOYW1lcyxcbiAgICAgICAgZmlsdGVyT3B0aW9uOiB0aGlzLnByb3BzLmZpbHRlck9wdGlvbiB9KVxuICAgICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVhaGVhZFRva2VuaXplcjsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSByZW5kZXJpbmcgb2YgYW4gb3B0aW9uIHRoYXQgaGFzIGJlZW4gXCJzZWxlY3RlZFwiIGluIGFcbiAqIFR5cGVhaGVhZFRva2VuaXplclxuICovXG52YXIgVG9rZW4gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVG9rZW4nLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9iamVjdDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIG9uUmVtb3ZlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzKFtcInR5cGVhaGVhZC10b2tlblwiLCB0aGlzLnByb3BzLmNsYXNzTmFtZV0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgIHRoaXMuX3JlbmRlckhpZGRlbklucHV0KCksXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgdGhpcy5fcmVuZGVyQ2xvc2VCdXR0b24oKVxuICAgICk7XG4gIH0sXG5cbiAgX3JlbmRlckhpZGRlbklucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSWYgbm8gbmFtZSB3YXMgc2V0LCBkb24ndCBjcmVhdGUgYSBoaWRkZW4gaW5wdXRcbiAgICBpZiAoIXRoaXMucHJvcHMubmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICBuYW1lOiB0aGlzLnByb3BzLm5hbWUgKyAnW10nLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy5vYmplY3RcbiAgICB9KTtcbiAgfSxcblxuICBfcmVuZGVyQ2xvc2VCdXR0b246IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMub25SZW1vdmUpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdhJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndHlwZWFoZWFkLXRva2VuLWNsb3NlJywgaHJlZjogJyMnLCBvbkNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uUmVtb3ZlKHRoaXMucHJvcHMub2JqZWN0KTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LmJpbmQodGhpcykgfSxcbiAgICAgICfDlydcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjsiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9hY2Nlc3NvcicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBUeXBlYWhlYWRTZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnZhciBLZXlFdmVudCA9IHJlcXVpcmUoJy4uL2tleWV2ZW50Jyk7XG52YXIgZnV6enkgPSByZXF1aXJlKCdmdXp6eScpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbi8qKlxuICogQSBcInR5cGVhaGVhZFwiLCBhbiBhdXRvLWNvbXBsZXRpbmcgdGV4dCBpbnB1dFxuICpcbiAqIFJlbmRlcnMgYW4gdGV4dCBpbnB1dCB0aGF0IHNob3dzIG9wdGlvbnMgbmVhcmJ5IHRoYXQgeW91IGNhbiB1c2UgdGhlXG4gKiBrZXlib2FyZCBvciBtb3VzZSB0byBzZWxlY3QuICBSZXF1aXJlcyBDU1MgZm9yIE1BU1NJVkUgREFNQUdFLlxuICovXG52YXIgVHlwZWFoZWFkID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1R5cGVhaGVhZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjdXN0b21DbGFzc2VzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG1heFZpc2libGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIGFsbG93Q3VzdG9tVmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGRlZmF1bHRWYWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkaXNhYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdGV4dGFyZWE6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGlucHV0UHJvcHM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb25PcHRpb25TZWxlY3RlZDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25LZXlQcmVzczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25LZXlVcDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25CbHVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBmaWx0ZXJPcHRpb246IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIFJlYWN0LlByb3BUeXBlcy5mdW5jXSksXG4gICAgZGlzcGxheU9wdGlvbjogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBmb3JtSW5wdXRPcHRpb246IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIFJlYWN0LlByb3BUeXBlcy5mdW5jXSksXG4gICAgZGVmYXVsdENsYXNzTmFtZXM6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGN1c3RvbUxpc3RDb21wb25lbnQ6IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5lbGVtZW50LCBSZWFjdC5Qcm9wVHlwZXMuZnVuY10pLFxuICAgIHNob3dPcHRpb25zV2hlbkVtcHR5OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiBbXSxcbiAgICAgIGN1c3RvbUNsYXNzZXM6IHt9LFxuICAgICAgYWxsb3dDdXN0b21WYWx1ZXM6IDAsXG4gICAgICBkZWZhdWx0VmFsdWU6IFwiXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHBsYWNlaG9sZGVyOiBcIlwiLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdGV4dGFyZWE6IGZhbHNlLFxuICAgICAgaW5wdXRQcm9wczoge30sXG4gICAgICBvbk9wdGlvblNlbGVjdGVkOiBmdW5jdGlvbiAob3B0aW9uKSB7fSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25LZXlQcmVzczogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgIG9uS2V5VXA6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICBvbkZvY3VzOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgb25CbHVyOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgZmlsdGVyT3B0aW9uOiBudWxsLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZXM6IHRydWUsXG4gICAgICBjdXN0b21MaXN0Q29tcG9uZW50OiBUeXBlYWhlYWRTZWxlY3RvcixcbiAgICAgIHNob3dPcHRpb25zV2hlbkVtcHR5OiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50bHkgdmlzaWJsZSBzZXQgb2Ygb3B0aW9uc1xuICAgICAgdmlzaWJsZTogdGhpcy5nZXRPcHRpb25zRm9yVmFsdWUodGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUsIHRoaXMucHJvcHMub3B0aW9ucyksXG5cbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBzb21ldGhpbmcgZWxzZSwgXCJlbnRyeVZhbHVlXCJcbiAgICAgIGVudHJ5VmFsdWU6IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUsXG5cbiAgICAgIC8vIEEgdmFsaWQgdHlwZWFoZWFkIHZhbHVlXG4gICAgICBzZWxlY3Rpb246IHRoaXMucHJvcHMudmFsdWUsXG5cbiAgICAgIC8vIEluZGV4IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgIHNlbGVjdGlvbkluZGV4OiBudWxsXG4gICAgfTtcbiAgfSxcblxuICBfc2hvdWxkU2tpcFNlYXJjaDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGVtcHR5VmFsdWUgPSAhaW5wdXQgfHwgaW5wdXQudHJpbSgpLmxlbmd0aCA9PSAwO1xuICAgIHJldHVybiAhdGhpcy5wcm9wcy5zaG93T3B0aW9uc1doZW5FbXB0eSAmJiBlbXB0eVZhbHVlO1xuICB9LFxuXG4gIGdldE9wdGlvbnNGb3JWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFNraXBTZWFyY2godmFsdWUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlck9wdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZUZpbHRlckZ1bmN0aW9uKCk7XG4gICAgdmFyIHJlc3VsdCA9IGZpbHRlck9wdGlvbnModmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnByb3BzLm1heFZpc2libGUpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCB0aGlzLnByb3BzLm1heFZpc2libGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIHNldEVudHJ5VGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5yZWZzLmVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fb25UZXh0RW50cnlVcGRhdGVkKCk7XG4gIH0sXG5cbiAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlZnMuZW50cnkuZm9jdXMoKTtcbiAgfSxcblxuICBfaGFzQ3VzdG9tVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5hbGxvd0N1c3RvbVZhbHVlcyA+IDAgJiYgdGhpcy5zdGF0ZS5lbnRyeVZhbHVlLmxlbmd0aCA+PSB0aGlzLnByb3BzLmFsbG93Q3VzdG9tVmFsdWVzICYmIHRoaXMuc3RhdGUudmlzaWJsZS5pbmRleE9mKHRoaXMuc3RhdGUuZW50cnlWYWx1ZSkgPCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIF9nZXRDdXN0b21WYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9oYXNDdXN0b21WYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5lbnRyeVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBfcmVuZGVySW5jcmVtZW50YWxTZWFyY2hSZXN1bHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90aGluZyBoYXMgYmVlbiBlbnRlcmVkIGludG8gdGhlIHRleHRib3hcbiAgICBpZiAodGhpcy5fc2hvdWxkU2tpcFNlYXJjaCh0aGlzLnN0YXRlLmVudHJ5VmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICAvLyBTb21ldGhpbmcgd2FzIGp1c3Qgc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY3VzdG9tTGlzdENvbXBvbmVudCwge1xuICAgICAgcmVmOiAnc2VsJywgb3B0aW9uczogdGhpcy5zdGF0ZS52aXNpYmxlLFxuICAgICAgb25PcHRpb25TZWxlY3RlZDogdGhpcy5fb25PcHRpb25TZWxlY3RlZCxcbiAgICAgIGFsbG93Q3VzdG9tVmFsdWVzOiB0aGlzLnByb3BzLmFsbG93Q3VzdG9tVmFsdWVzLFxuICAgICAgY3VzdG9tVmFsdWU6IHRoaXMuX2dldEN1c3RvbVZhbHVlKCksXG4gICAgICBjdXN0b21DbGFzc2VzOiB0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMsXG4gICAgICBzZWxlY3Rpb25JbmRleDogdGhpcy5zdGF0ZS5zZWxlY3Rpb25JbmRleCxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVzOiB0aGlzLnByb3BzLmRlZmF1bHRDbGFzc05hbWVzLFxuICAgICAgZGlzcGxheU9wdGlvbjogQWNjZXNzb3IuZ2VuZXJhdGVPcHRpb25Ub1N0cmluZ0Zvcih0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24pIH0pO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uSW5kZXg7XG4gICAgaWYgKHRoaXMuX2hhc0N1c3RvbVZhbHVlKCkpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5lbnRyeVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudmlzaWJsZVtpbmRleF07XG4gIH0sXG5cbiAgX29uT3B0aW9uU2VsZWN0ZWQ6IGZ1bmN0aW9uIChvcHRpb24sIGV2ZW50KSB7XG4gICAgdmFyIG5FbnRyeSA9IHRoaXMucmVmcy5lbnRyeTtcbiAgICBuRW50cnkuZm9jdXMoKTtcblxuICAgIHZhciBkaXNwbGF5T3B0aW9uID0gQWNjZXNzb3IuZ2VuZXJhdGVPcHRpb25Ub1N0cmluZ0Zvcih0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24pO1xuICAgIHZhciBvcHRpb25TdHJpbmcgPSBkaXNwbGF5T3B0aW9uKG9wdGlvbiwgMCk7XG5cbiAgICB2YXIgZm9ybUlucHV0T3B0aW9uID0gQWNjZXNzb3IuZ2VuZXJhdGVPcHRpb25Ub1N0cmluZ0Zvcih0aGlzLnByb3BzLmZvcm1JbnB1dE9wdGlvbiB8fCBkaXNwbGF5T3B0aW9uKTtcbiAgICB2YXIgZm9ybUlucHV0T3B0aW9uU3RyaW5nID0gZm9ybUlucHV0T3B0aW9uKG9wdGlvbik7XG5cbiAgICBuRW50cnkudmFsdWUgPSBvcHRpb25TdHJpbmc7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZpc2libGU6IHRoaXMuZ2V0T3B0aW9uc0ZvclZhbHVlKG9wdGlvblN0cmluZywgdGhpcy5wcm9wcy5vcHRpb25zKSxcbiAgICAgIHNlbGVjdGlvbjogZm9ybUlucHV0T3B0aW9uU3RyaW5nLFxuICAgICAgZW50cnlWYWx1ZTogb3B0aW9uU3RyaW5nIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9uT3B0aW9uU2VsZWN0ZWQob3B0aW9uLCBldmVudCk7XG4gIH0sXG5cbiAgX29uVGV4dEVudHJ5VXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMucmVmcy5lbnRyeS52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmlzaWJsZTogdGhpcy5nZXRPcHRpb25zRm9yVmFsdWUodmFsdWUsIHRoaXMucHJvcHMub3B0aW9ucyksXG4gICAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgICBlbnRyeVZhbHVlOiB2YWx1ZSB9KTtcbiAgfSxcblxuICBfb25FbnRlcjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uS2V5RG93bihldmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vbk9wdGlvblNlbGVjdGVkKHNlbGVjdGlvbiwgZXZlbnQpO1xuICB9LFxuXG4gIF9vbkVzY2FwZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VsZWN0aW9uSW5kZXg6IG51bGxcbiAgICB9KTtcbiAgfSxcblxuICBfb25UYWI6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIHZhciBvcHRpb24gPSBzZWxlY3Rpb24gPyBzZWxlY3Rpb24gOiB0aGlzLnN0YXRlLnZpc2libGUubGVuZ3RoID4gMCA/IHRoaXMuc3RhdGUudmlzaWJsZVswXSA6IG51bGw7XG5cbiAgICBpZiAob3B0aW9uID09PSBudWxsICYmIHRoaXMuX2hhc0N1c3RvbVZhbHVlKCkpIHtcbiAgICAgIG9wdGlvbiA9IHRoaXMuX2dldEN1c3RvbVZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uT3B0aW9uU2VsZWN0ZWQob3B0aW9uLCBldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGV2ZW50TWFwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzID0ge307XG5cbiAgICBldmVudHNbS2V5RXZlbnQuRE9NX1ZLX1VQXSA9IHRoaXMubmF2VXA7XG4gICAgZXZlbnRzW0tleUV2ZW50LkRPTV9WS19ET1dOXSA9IHRoaXMubmF2RG93bjtcbiAgICBldmVudHNbS2V5RXZlbnQuRE9NX1ZLX1JFVFVSTl0gPSBldmVudHNbS2V5RXZlbnQuRE9NX1ZLX0VOVEVSXSA9IHRoaXMuX29uRW50ZXI7XG4gICAgZXZlbnRzW0tleUV2ZW50LkRPTV9WS19FU0NBUEVdID0gdGhpcy5fb25Fc2NhcGU7XG4gICAgZXZlbnRzW0tleUV2ZW50LkRPTV9WS19UQUJdID0gdGhpcy5fb25UYWI7XG5cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIF9uYXY6IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgIGlmICghdGhpcy5faGFzSGludCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdJbmRleCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uSW5kZXggPT09IG51bGwgPyBkZWx0YSA9PSAxID8gMCA6IGRlbHRhIDogdGhpcy5zdGF0ZS5zZWxlY3Rpb25JbmRleCArIGRlbHRhO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnN0YXRlLnZpc2libGUubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9oYXNDdXN0b21WYWx1ZSgpKSB7XG4gICAgICBsZW5ndGggKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmV3SW5kZXggPCAwKSB7XG4gICAgICBuZXdJbmRleCArPSBsZW5ndGg7XG4gICAgfSBlbHNlIGlmIChuZXdJbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgIG5ld0luZGV4IC09IGxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgc2VsZWN0aW9uSW5kZXg6IG5ld0luZGV4IH0pO1xuICB9LFxuXG4gIG5hdkRvd246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uYXYoMSk7XG4gIH0sXG5cbiAgbmF2VXA6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uYXYoLTEpO1xuICB9LFxuXG4gIF9vbkNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX29uVGV4dEVudHJ5VXBkYXRlZCgpO1xuICB9LFxuXG4gIF9vbktleURvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyB2aXNpYmxlIGVsZW1lbnRzLCBkb24ndCBwZXJmb3JtIHNlbGVjdG9yIG5hdmlnYXRpb24uXG4gICAgLy8gSnVzdCBwYXNzIHRoaXMgdXAgdG8gdGhlIHVwc3RyZWFtIG9uS2V5ZG93biBoYW5kbGVyLlxuICAgIC8vIEFsc28gc2tpcCBpZiB0aGUgdXNlciBpcyBwcmVzc2luZyB0aGUgc2hpZnQga2V5LCBzaW5jZSBub25lIG9mIG91ciBoYW5kbGVycyBhcmUgbG9va2luZyBmb3Igc2hpZnRcbiAgICBpZiAoIXRoaXMuX2hhc0hpbnQoKSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25LZXlEb3duKGV2ZW50KTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRNYXAoKVtldmVudC5rZXlDb2RlXTtcblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25LZXlEb3duKGV2ZW50KTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgcHJvcGFnYXRlIHRoZSBrZXlzdHJva2UgYmFjayB0byB0aGUgRE9NL2Jyb3dzZXJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZpc2libGU6IHRoaXMuZ2V0T3B0aW9uc0ZvclZhbHVlKHRoaXMuc3RhdGUuZW50cnlWYWx1ZSwgbmV4dFByb3BzLm9wdGlvbnMpXG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0Q2xhc3NlcyA9IHt9O1xuICAgIGlucHV0Q2xhc3Nlc1t0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuaW5wdXRdID0gISF0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuaW5wdXQ7XG4gICAgdmFyIGlucHV0Q2xhc3NMaXN0ID0gY2xhc3NOYW1lcyhpbnB1dENsYXNzZXMpO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICB0eXBlYWhlYWQ6IHRoaXMucHJvcHMuZGVmYXVsdENsYXNzTmFtZXNcbiAgICB9O1xuICAgIGNsYXNzZXNbdGhpcy5wcm9wcy5jbGFzc05hbWVdID0gISF0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lcyhjbGFzc2VzKTtcblxuICAgIHZhciBJbnB1dEVsZW1lbnQgPSB0aGlzLnByb3BzLnRleHRhcmVhID8gJ3RleHRhcmVhJyA6ICdpbnB1dCc7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTGlzdCB9LFxuICAgICAgdGhpcy5fcmVuZGVySGlkZGVuSW5wdXQoKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRFbGVtZW50LCBfZXh0ZW5kcyh7IHJlZjogJ2VudHJ5JywgdHlwZTogJ3RleHQnLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy5wcm9wcy5kaXNhYmxlZFxuICAgICAgfSwgdGhpcy5wcm9wcy5pbnB1dFByb3BzLCB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnByb3BzLnBsYWNlaG9sZGVyLFxuICAgICAgICBjbGFzc05hbWU6IGlucHV0Q2xhc3NMaXN0LFxuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lbnRyeVZhbHVlLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5fb25DaGFuZ2UsXG4gICAgICAgIG9uS2V5RG93bjogdGhpcy5fb25LZXlEb3duLFxuICAgICAgICBvbktleVByZXNzOiB0aGlzLnByb3BzLm9uS2V5UHJlc3MsXG4gICAgICAgIG9uS2V5VXA6IHRoaXMucHJvcHMub25LZXlVcCxcbiAgICAgICAgb25Gb2N1czogdGhpcy5wcm9wcy5vbkZvY3VzLFxuICAgICAgICBvbkJsdXI6IHRoaXMucHJvcHMub25CbHVyXG4gICAgICB9KSksXG4gICAgICB0aGlzLl9yZW5kZXJJbmNyZW1lbnRhbFNlYXJjaFJlc3VsdHMoKVxuICAgICk7XG4gIH0sXG5cbiAgX3JlbmRlckhpZGRlbklucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLm5hbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgIHR5cGU6ICdoaWRkZW4nLFxuICAgICAgbmFtZTogdGhpcy5wcm9wcy5uYW1lLFxuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgfSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlRmlsdGVyRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsdGVyT3B0aW9uUHJvcCA9IHRoaXMucHJvcHMuZmlsdGVyT3B0aW9uO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyT3B0aW9uUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyT3B0aW9uUHJvcCh2YWx1ZSwgbyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcHBlcjtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyT3B0aW9uUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFwcGVyID0gQWNjZXNzb3IuZ2VuZXJhdGVBY2Nlc3NvcihmaWx0ZXJPcHRpb25Qcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlciA9IEFjY2Vzc29yLklERU5USVRZX0ZOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZnV6enkuZmlsdGVyKHZhbHVlLCBvcHRpb25zLCB7IGV4dHJhY3Q6IG1hcHBlciB9KS5tYXAoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zW3Jlcy5pbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhc0hpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS52aXNpYmxlLmxlbmd0aCA+IDAgfHwgdGhpcy5faGFzQ3VzdG9tVmFsdWUoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkOyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuLyoqXG4gKiBBIHNpbmdsZSBvcHRpb24gd2l0aGluIHRoZSBUeXBlYWhlYWRTZWxlY3RvclxuICovXG52YXIgVHlwZWFoZWFkT3B0aW9uID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1R5cGVhaGVhZE9wdGlvbicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY3VzdG9tQ2xhc3NlczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjdXN0b21WYWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNsaWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjaGlsZHJlbjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBob3ZlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VzdG9tQ2xhc3Nlczoge30sXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgY2xhc3Nlc1t0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuaG92ZXIgfHwgXCJob3ZlclwiXSA9ICEhdGhpcy5wcm9wcy5ob3ZlcjtcbiAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5saXN0SXRlbV0gPSAhIXRoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5saXN0SXRlbTtcblxuICAgIGlmICh0aGlzLnByb3BzLmN1c3RvbVZhbHVlKSB7XG4gICAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5jdXN0b21BZGRdID0gISF0aGlzLnByb3BzLmN1c3RvbUNsYXNzZXMuY3VzdG9tQWRkO1xuICAgIH1cblxuICAgIHZhciBjbGFzc0xpc3QgPSBjbGFzc05hbWVzKGNsYXNzZXMpO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTGlzdCwgb25DbGljazogdGhpcy5fb25DbGljayB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2EnLFxuICAgICAgICB7IGhyZWY6ICdqYXZhc2NyaXB0OiB2b2lkIDA7JywgY2xhc3NOYW1lOiB0aGlzLl9nZXRDbGFzc2VzKCksIHJlZjogJ2FuY2hvcicgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgKVxuICAgICk7XG4gIH0sXG5cbiAgX2dldENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHtcbiAgICAgIFwidHlwZWFoZWFkLW9wdGlvblwiOiB0cnVlXG4gICAgfTtcbiAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5saXN0QW5jaG9yXSA9ICEhdGhpcy5wcm9wcy5jdXN0b21DbGFzc2VzLmxpc3RBbmNob3I7XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lcyhjbGFzc2VzKTtcbiAgfSxcblxuICBfb25DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkT3B0aW9uOyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgVHlwZWFoZWFkT3B0aW9uID0gcmVxdWlyZSgnLi9vcHRpb24nKTtcbnZhciBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgYXV0b2NvbXBsZXRpb24gcHJvY2Vzc1xuICogb2YgdGhlIHR5cGVhaGVhZFxuICovXG52YXIgVHlwZWFoZWFkU2VsZWN0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVHlwZWFoZWFkU2VsZWN0b3InLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBhbGxvd0N1c3RvbVZhbHVlczogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBjdXN0b21DbGFzc2VzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGN1c3RvbVZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNlbGVjdGlvbkluZGV4OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG9uT3B0aW9uU2VsZWN0ZWQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRpc3BsYXlPcHRpb246IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZGVmYXVsdENsYXNzTmFtZXM6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdGlvbkluZGV4OiBudWxsLFxuICAgICAgY3VzdG9tQ2xhc3Nlczoge30sXG4gICAgICBhbGxvd0N1c3RvbVZhbHVlczogMCxcbiAgICAgIGN1c3RvbVZhbHVlOiBudWxsLFxuICAgICAgb25PcHRpb25TZWxlY3RlZDogZnVuY3Rpb24gKG9wdGlvbikge30sXG4gICAgICBkZWZhdWx0Q2xhc3NOYW1lczogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG9uJ3QgcmVuZGVyIGlmIHRoZXJlIGFyZSBubyBvcHRpb25zIHRvIGRpc3BsYXlcbiAgICBpZiAoIXRoaXMucHJvcHMub3B0aW9ucy5sZW5ndGggJiYgdGhpcy5wcm9wcy5hbGxvd0N1c3RvbVZhbHVlcyA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICBcInR5cGVhaGVhZC1zZWxlY3RvclwiOiB0aGlzLnByb3BzLmRlZmF1bHRDbGFzc05hbWVzXG4gICAgfTtcbiAgICBjbGFzc2VzW3RoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5yZXN1bHRzXSA9IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3Nlcy5yZXN1bHRzO1xuICAgIHZhciBjbGFzc0xpc3QgPSBjbGFzc05hbWVzKGNsYXNzZXMpO1xuXG4gICAgLy8gQ3VzdG9tVmFsdWUgc2hvdWxkIGJlIGFkZGVkIHRvIHRvcCBvZiByZXN1bHRzIGxpc3Qgd2l0aCBkaWZmZXJlbnQgY2xhc3MgbmFtZVxuICAgIHZhciBjdXN0b21WYWx1ZSA9IG51bGw7XG4gICAgdmFyIGN1c3RvbVZhbHVlT2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy5wcm9wcy5jdXN0b21WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY3VzdG9tVmFsdWVPZmZzZXQrKztcbiAgICAgIGN1c3RvbVZhbHVlID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgVHlwZWFoZWFkT3B0aW9uLFxuICAgICAgICB7IHJlZjogdGhpcy5wcm9wcy5jdXN0b21WYWx1ZSwga2V5OiB0aGlzLnByb3BzLmN1c3RvbVZhbHVlLFxuICAgICAgICAgIGhvdmVyOiB0aGlzLnByb3BzLnNlbGVjdGlvbkluZGV4ID09PSAwLFxuICAgICAgICAgIGN1c3RvbUNsYXNzZXM6IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3NlcyxcbiAgICAgICAgICBjdXN0b21WYWx1ZTogdGhpcy5wcm9wcy5jdXN0b21WYWx1ZSxcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcywgdGhpcy5wcm9wcy5jdXN0b21WYWx1ZSkgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jdXN0b21WYWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IHRoaXMucHJvcHMub3B0aW9ucy5tYXAoZnVuY3Rpb24gKHJlc3VsdCwgaSkge1xuICAgICAgdmFyIGRpc3BsYXlTdHJpbmcgPSB0aGlzLnByb3BzLmRpc3BsYXlPcHRpb24ocmVzdWx0LCBpKTtcbiAgICAgIHZhciB1bmlxdWVLZXkgPSBkaXNwbGF5U3RyaW5nICsgJ18nICsgaTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBUeXBlYWhlYWRPcHRpb24sXG4gICAgICAgIHsgcmVmOiB1bmlxdWVLZXksIGtleTogdW5pcXVlS2V5LFxuICAgICAgICAgIGhvdmVyOiB0aGlzLnByb3BzLnNlbGVjdGlvbkluZGV4ID09PSBpICsgY3VzdG9tVmFsdWVPZmZzZXQsXG4gICAgICAgICAgY3VzdG9tQ2xhc3NlczogdGhpcy5wcm9wcy5jdXN0b21DbGFzc2VzLFxuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzLCByZXN1bHQpIH0sXG4gICAgICAgIGRpc3BsYXlTdHJpbmdcbiAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICd1bCcsXG4gICAgICB7IGNsYXNzTmFtZTogY2xhc3NMaXN0IH0sXG4gICAgICBjdXN0b21WYWx1ZSxcbiAgICAgIHJlc3VsdHNcbiAgICApO1xuICB9LFxuXG4gIF9vbkNsaWNrOiBmdW5jdGlvbiAocmVzdWx0LCBldmVudCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9uT3B0aW9uU2VsZWN0ZWQocmVzdWx0LCBldmVudCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkU2VsZWN0b3I7IiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNSBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuXG5mdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuXHR2YXIgY2xhc3NlcyA9ICcnO1xuXHR2YXIgYXJnO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdGlmICghYXJnKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBhcmcgfHwgJ251bWJlcicgPT09IHR5cGVvZiBhcmcpIHtcblx0XHRcdGNsYXNzZXMgKz0gJyAnICsgYXJnO1xuXHRcdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0XHRcdGNsYXNzZXMgKz0gJyAnICsgY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBhcmcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0aWYgKCFhcmcuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAhYXJnW2tleV0pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGFzc2VzICs9ICcgJyArIGtleTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGNsYXNzZXMuc3Vic3RyKDEpO1xufVxuXG4vLyBzYWZlbHkgZXhwb3J0IGNsYXNzTmFtZXMgZm9yIG5vZGUgLyBicm93c2VyaWZ5XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xufVxuXG4vLyBzYWZlbHkgZXhwb3J0IGNsYXNzTmFtZXMgZm9yIFJlcXVpcmVKU1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHR9KTtcbn1cbiIsIi8qXG4gKiBGdXp6eVxuICogaHR0cHM6Ly9naXRodWIuY29tL215b3JrL2Z1enp5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE1hdHQgWW9ya1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbihmdW5jdGlvbigpIHtcblxudmFyIHJvb3QgPSB0aGlzO1xuXG52YXIgZnV6enkgPSB7fTtcblxuLy8gVXNlIGluIG5vZGUgb3IgaW4gYnJvd3NlclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1enp5O1xufSBlbHNlIHtcbiAgcm9vdC5mdXp6eSA9IGZ1enp5O1xufVxuXG4vLyBSZXR1cm4gYWxsIGVsZW1lbnRzIG9mIGBhcnJheWAgdGhhdCBoYXZlIGEgZnV6enlcbi8vIG1hdGNoIGFnYWluc3QgYHBhdHRlcm5gLlxuZnV6enkuc2ltcGxlRmlsdGVyID0gZnVuY3Rpb24ocGF0dGVybiwgYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gZnV6enkudGVzdChwYXR0ZXJuLCBzdHJpbmcpO1xuICB9KTtcbn07XG5cbi8vIERvZXMgYHBhdHRlcm5gIGZ1enp5IG1hdGNoIGBzdHJpbmdgP1xuZnV6enkudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0cmluZykge1xuICByZXR1cm4gZnV6enkubWF0Y2gocGF0dGVybiwgc3RyaW5nKSAhPT0gbnVsbDtcbn07XG5cbi8vIElmIGBwYXR0ZXJuYCBtYXRjaGVzIGBzdHJpbmdgLCB3cmFwIGVhY2ggbWF0Y2hpbmcgY2hhcmFjdGVyXG4vLyBpbiBgb3B0cy5wcmVgIGFuZCBgb3B0cy5wb3N0YC4gSWYgbm8gbWF0Y2gsIHJldHVybiBudWxsXG5mdXp6eS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0cmluZywgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHBhdHRlcm5JZHggPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgbGVuID0gc3RyaW5nLmxlbmd0aFxuICAgICwgdG90YWxTY29yZSA9IDBcbiAgICAsIGN1cnJTY29yZSA9IDBcbiAgICAvLyBwcmVmaXhcbiAgICAsIHByZSA9IG9wdHMucHJlIHx8ICcnXG4gICAgLy8gc3VmZml4XG4gICAgLCBwb3N0ID0gb3B0cy5wb3N0IHx8ICcnXG4gICAgLy8gU3RyaW5nIHRvIGNvbXBhcmUgYWdhaW5zdC4gVGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSB2ZXJzaW9uIG9mIHRoZVxuICAgIC8vIHJhdyBzdHJpbmdcbiAgICAsIGNvbXBhcmVTdHJpbmcgPSAgb3B0cy5jYXNlU2Vuc2l0aXZlICYmIHN0cmluZyB8fCBzdHJpbmcudG9Mb3dlckNhc2UoKVxuICAgICwgY2gsIGNvbXBhcmVDaGFyO1xuXG4gIHBhdHRlcm4gPSBvcHRzLmNhc2VTZW5zaXRpdmUgJiYgcGF0dGVybiB8fCBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gRm9yIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcsIGVpdGhlciBhZGQgaXQgdG8gdGhlIHJlc3VsdFxuICAvLyBvciB3cmFwIGluIHRlbXBsYXRlIGlmIGl0J3MgdGhlIG5leHQgc3RyaW5nIGluIHRoZSBwYXR0ZXJuXG4gIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIGNoID0gc3RyaW5nW2lkeF07XG4gICAgaWYoY29tcGFyZVN0cmluZ1tpZHhdID09PSBwYXR0ZXJuW3BhdHRlcm5JZHhdKSB7XG4gICAgICBjaCA9IHByZSArIGNoICsgcG9zdDtcbiAgICAgIHBhdHRlcm5JZHggKz0gMTtcblxuICAgICAgLy8gY29uc2VjdXRpdmUgY2hhcmFjdGVycyBzaG91bGQgaW5jcmVhc2UgdGhlIHNjb3JlIG1vcmUgdGhhbiBsaW5lYXJseVxuICAgICAgY3VyclNjb3JlICs9IDEgKyBjdXJyU2NvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJTY29yZSA9IDA7XG4gICAgfVxuICAgIHRvdGFsU2NvcmUgKz0gY3VyclNjb3JlO1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGNoO1xuICB9XG5cbiAgLy8gcmV0dXJuIHJlbmRlcmVkIHN0cmluZyBpZiB3ZSBoYXZlIGEgbWF0Y2ggZm9yIGV2ZXJ5IGNoYXJcbiAgaWYocGF0dGVybklkeCA9PT0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge3JlbmRlcmVkOiByZXN1bHQuam9pbignJyksIHNjb3JlOiB0b3RhbFNjb3JlfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gVGhlIG5vcm1hbCBlbnRyeSBwb2ludC4gRmlsdGVycyBgYXJyYCBmb3IgbWF0Y2hlcyBhZ2FpbnN0IGBwYXR0ZXJuYC5cbi8vIEl0IHJldHVybnMgYW4gYXJyYXkgd2l0aCBtYXRjaGluZyB2YWx1ZXMgb2YgdGhlIHR5cGU6XG4vL1xuLy8gICAgIFt7XG4vLyAgICAgICAgIHN0cmluZzogICAnPGI+bGFoJyAvLyBUaGUgcmVuZGVyZWQgc3RyaW5nXG4vLyAgICAgICAsIGluZGV4OiAgICAyICAgICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gYGFycmBcbi8vICAgICAgICwgb3JpZ2luYWw6ICdibGFoJyAgIC8vIFRoZSBvcmlnaW5hbCBlbGVtZW50IGluIGBhcnJgXG4vLyAgICAgfV1cbi8vXG4vLyBgb3B0c2AgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgYmFnLiBEZXRhaWxzOlxuLy9cbi8vICAgIG9wdHMgPSB7XG4vLyAgICAgICAgLy8gc3RyaW5nIHRvIHB1dCBiZWZvcmUgYSBtYXRjaGluZyBjaGFyYWN0ZXJcbi8vICAgICAgICBwcmU6ICAgICAnPGI+J1xuLy9cbi8vICAgICAgICAvLyBzdHJpbmcgdG8gcHV0IGFmdGVyIG1hdGNoaW5nIGNoYXJhY3RlclxuLy8gICAgICAsIHBvc3Q6ICAgICc8L2I+J1xuLy9cbi8vICAgICAgICAvLyBPcHRpb25hbCBmdW5jdGlvbi4gSW5wdXQgaXMgYW4gZW50cnkgaW4gdGhlIGdpdmVuIGFycmAsXG4vLyAgICAgICAgLy8gb3V0cHV0IHNob3VsZCBiZSB0aGUgc3RyaW5nIHRvIHRlc3QgYHBhdHRlcm5gIGFnYWluc3QuXG4vLyAgICAgICAgLy8gSW4gdGhpcyBleGFtcGxlLCBpZiBgYXJyID0gW3tjcnlpbmc6ICdrb2FsYSd9XWAgd2Ugd291bGQgcmV0dXJuXG4vLyAgICAgICAgLy8gJ2tvYWxhJy5cbi8vICAgICAgLCBleHRyYWN0OiBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZy5jcnlpbmc7IH1cbi8vICAgIH1cbmZ1enp5LmZpbHRlciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGFyciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgcmV0dXJuIGFyclxuICAgIC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgZWxlbWVudCwgaWR4LCBhcnIpIHtcbiAgICAgIHZhciBzdHIgPSBlbGVtZW50O1xuICAgICAgaWYob3B0cy5leHRyYWN0KSB7XG4gICAgICAgIHN0ciA9IG9wdHMuZXh0cmFjdChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciByZW5kZXJlZCA9IGZ1enp5Lm1hdGNoKHBhdHRlcm4sIHN0ciwgb3B0cyk7XG4gICAgICBpZihyZW5kZXJlZCAhPSBudWxsKSB7XG4gICAgICAgIHByZXZbcHJldi5sZW5ndGhdID0ge1xuICAgICAgICAgICAgc3RyaW5nOiByZW5kZXJlZC5yZW5kZXJlZFxuICAgICAgICAgICwgc2NvcmU6IHJlbmRlcmVkLnNjb3JlXG4gICAgICAgICAgLCBpbmRleDogaWR4XG4gICAgICAgICAgLCBvcmlnaW5hbDogZWxlbWVudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgW10pXG5cbiAgICAvLyBTb3J0IGJ5IHNjb3JlLiBCcm93c2VycyBhcmUgaW5jb25zaXN0ZW50IHdydCBzdGFibGUvdW5zdGFibGVcbiAgICAvLyBzb3J0aW5nLCBzbyBmb3JjZSBzdGFibGUgYnkgdXNpbmcgdGhlIGluZGV4IGluIHRoZSBjYXNlIG9mIHRpZS5cbiAgICAvLyBTZWUgaHR0cDovL29mYi5uZXQvfnNldGhtbC9pcy1zb3J0LXN0YWJsZS5odG1sXG4gICAgLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgICB2YXIgY29tcGFyZSA9IGIuc2NvcmUgLSBhLnNjb3JlO1xuICAgICAgaWYoY29tcGFyZSkgcmV0dXJuIGNvbXBhcmU7XG4gICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgfSk7XG59O1xuXG5cbn0oKSk7XG5cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8vaW1wb3J0IFwiYmFiZWwtcG9seWZpbGxcIjtcblxuLy8gc3RvcmVzXG5pbXBvcnQgQXJlYURlc2NyaXB0aW9uc1N0b3JlIGZyb20gJy4vc3RvcmVzL0FyZWFEZXNjcmlwdGlvbnNTdG9yZSc7XG5pbXBvcnQgQ2l0eVN0b3JlIGZyb20gJy4vc3RvcmVzL0NpdHlTdG9yZSc7XG5pbXBvcnQgTWFwU3RhdGVTdG9yZSBmcm9tICcuL3N0b3Jlcy9NYXBTdGF0ZVN0b3JlJztcbmltcG9ydCBSYXN0ZXJTdG9yZSBmcm9tICcuL3N0b3Jlcy9SYXN0ZXJTdG9yZSc7XG5pbXBvcnQgVXNlckxvY2F0aW9uU3RvcmUgZnJvbSAnLi9zdG9yZXMvVXNlckxvY2F0aW9uU3RvcmUnO1xuaW1wb3J0IFRleHRzU3RvcmUgZnJvbSAnLi9zdG9yZXMvVGV4dHNTdG9yZSc7XG5cbi8vIGNvbXBvbmVudHMgKHZpZXdzKVxuaW1wb3J0IEFEQ2F0IGZyb20gJy4vY29tcG9uZW50cy9BRENhdC5qc3gnO1xuaW1wb3J0IEFyZWFEZXNjcmlwdGlvbiBmcm9tICcuL2NvbXBvbmVudHMvQXJlYURlc2NyaXB0aW9uLmpzeCc7XG5pbXBvcnQgQXJlYVBvbHlnb24gZnJvbSAnLi9jb21wb25lbnRzL0FyZWFQb2x5Z29uLmpzeCc7XG5pbXBvcnQgeyBDYXJ0b0RCVGlsZUxheWVyLCBIYXNoTWFuYWdlciwgTGVnZW5kLCBOYXZpZ2F0aW9uIH0gZnJvbSAnQHBhbm9yYW1hL3Rvb2xraXQnO1xuaW1wb3J0IENpdHlTbmlwcGV0IGZyb20gJy4vY29tcG9uZW50cy9DaXR5U25pcHBldC5qc3gnO1xuaW1wb3J0IENpdHlTdGF0cyBmcm9tICcuL2NvbXBvbmVudHMvQ2l0eVN0YXRzLmpzeCc7XG5pbXBvcnQgRG9udXQgZnJvbSAnLi9jb21wb25lbnRzL0RvbnV0L0RvbnV0LmpzeCc7XG5pbXBvcnQgRG93bmxvYWRlciBmcm9tICcuL2NvbXBvbmVudHMvRG93bmxvYWRlci5qc3gnO1xuaW1wb3J0IHsgaWNvbiB9IGZyb20gJ2xlYWZsZXQnO1xuaW1wb3J0IHsgTWFwLCBUaWxlTGF5ZXIsIEdlb0pzb24sIENpcmNsZSwgTGF5ZXJHcm91cCwgTWFya2VyLCBzZXRJY29uRGVmYXVsdEltYWdlUGF0aCB9IGZyb20gJ3JlYWN0LWxlYWZsZXQnO1xuaW1wb3J0IE1vZGFsIGZyb20gJ3JlYWN0LW1vZGFsJztcbmltcG9ydCBTbGlkZXIgZnJvbSAncmMtc2xpZGVyJztcbmltcG9ydCBTdGF0ZVN0YXRzIGZyb20gJy4vY29tcG9uZW50cy9TdGF0ZVN0YXRzLmpzeCc7XG5pbXBvcnQgeyBUeXBlYWhlYWQgfSBmcm9tICdyZWFjdC10eXBlYWhlYWQnO1xuaW1wb3J0IFR5cGVBaGVhZENpdHlTbmlwcGV0IGZyb20gJy4vY29tcG9uZW50cy9UeXBlQWhlYWRDaXR5U25pcHBldC5qc3gnO1xuXG4vLyB1dGlsc1xuaW1wb3J0IHsgQXBwQWN0aW9ucywgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuXG4vLyBjb25maWdcbmltcG9ydCBjYXJ0b2RiQ29uZmlnIGZyb20gJy4uL2Jhc2VtYXBzL2NhcnRvZGIvY29uZmlnLmpzb24nO1xuaW1wb3J0IGNhcnRvZGJMYXllcnMgZnJvbSAnLi4vYmFzZW1hcHMvY2FydG9kYi9iYXNlbWFwcy5qc29uJztcbmltcG9ydCB0aWxlTGF5ZXJzIGZyb20gJy4uL2Jhc2VtYXBzL3RpbGVMYXllcnMuanNvbic7XG5cbi8vIGRhdGFcbmltcG9ydCBwYW5vcmFtYU5hdkRhdGEgZnJvbSAnLi4vZGF0YS9wYW5vcmFtYV9uYXYuanNvbic7XG5pbXBvcnQgc3RhdGVBYmJycyBmcm9tICcuLi9kYXRhL3N0YXRlX2FiYnIuanNvbic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHNvbWV0aGluZ1JlcXVlc3RlZDogT2JqZWN0LmtleXMoSGFzaE1hbmFnZXIuZ2V0U3RhdGUoKSkucmVkdWNlKChhLGIpID0+ICh0eXBlb2YgYSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEhhc2hNYW5hZ2VyLmdldFN0YXRlKClbYV0gIT09ICd1bmRlZmluZWQnKSB8fCAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBIYXNoTWFuYWdlci5nZXRTdGF0ZSgpW2JdICE9PSAndW5kZWZpbmVkJyksICcnKVxuXHR9O1xuXG5cdGNvbnN0cnVjdG9yIChwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5nZXREZWZhdWx0U3RhdGUoKTtcblxuXHRcdC8vIGJpbmQgaGFuZGxlcnNcblx0XHRjb25zdCBoYW5kbGVycyA9IFsnb25XaW5kb3dSZXNpemUnLCdvbk1vZGFsQ2xpY2snLCd0b2dnbGVCdXJnZXNzRGlhZ3JhbScsJ3N0b3JlQ2hhbmdlZCcsJ29uQnVyZ2Vzc0NoYXJ0T2ZmJywnb25CdXJnZXNzQ2hhcnRIb3ZlcicsJ29uU3RhdGVTZWxlY3RlZCcsJ29uQ2l0eVNlbGVjdGVkJywnb25NYXBNb3ZlZCcsJ29uUGFub3JhbWFNZW51Q2xpY2snLCdvbkRvd25sb2FkQ2xpY2tlZCcsJ29uQ2F0ZWdvcnlDbGljaycsJ25laWdoYm9yaG9vZEhpZ2hsaWdodGVkJywnbmVpZ2hib3Job29kc1VuaGlnaGxpZ2h0ZWQnLCdvblNsaWRlckNoYW5nZScsJ29uVXNlckNpdHlSZXNwb25zZScsJ29uTmVpZ2hib3Job29kUG9seWdvbkNsaWNrJywnb25BcmVhQ2hhcnRIb3ZlcicsJ29uQXJlYUNoYXJ0T2ZmJywnb25DaXR5TWFya2VyU2VsZWN0ZWQnLCdvbkdyYWRlSG92ZXInLCdvbkdyYWRlVW5ob3ZlcicsJ29uSE9MQ0lEQ2xpY2snXTtcblx0XHRoYW5kbGVycy5tYXAoaGFuZGxlciA9PiB7IHRoaXNbaGFuZGxlcl0gPSB0aGlzW2hhbmRsZXJdLmJpbmQodGhpcyk7IH0pO1xuXHR9XG5cblx0LyogTGlmZWN5Y2xlIG1ldGhvZHMgKi9cblxuXHRjb21wb25lbnRXaWxsTW91bnQgKCkge1xuXHRcdHRoaXMuY29tcHV0ZUNvbXBvbmVudERpbWVuc2lvbnMoKTtcblx0XHRBcHBBY3Rpb25zLmxvYWRJbml0aWFsRGF0YSh0aGlzLnN0YXRlLCBIYXNoTWFuYWdlci5nZXRTdGF0ZSgpKTtcblxuXHRcdC8vdHJ5IHRvIHJldHJpZXZlIHRoZSB1c2VycyBsb2NhdGlvblxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oKHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdEFwcEFjdGlvbnMudXNlckxvY2F0ZWQoW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV0pO1xuXHRcdFx0fSwgKGVycm9yKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignR2VvbG9jYXRpb24gZXJyb3Igb2NjdXJyZWQuIEVycm9yIGNvZGU6ICcgKyBlcnJvci5jb2RlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50ICgpIHtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vbldpbmRvd1Jlc2l6ZSk7XG5cdFx0QXJlYURlc2NyaXB0aW9uc1N0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdENpdHlTdG9yZS5hZGRMaXN0ZW5lcihBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQsIHRoaXMuc3RvcmVDaGFuZ2VkKTtcblx0XHRNYXBTdGF0ZVN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFJhc3RlclN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFVzZXJMb2NhdGlvblN0b3JlLmFkZExpc3RlbmVyKEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCwgdGhpcy5zdG9yZUNoYW5nZWQpO1xuXHRcdFRleHRzU3RvcmUuYWRkTGlzdGVuZXIoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkLCB0aGlzLnN0b3JlQ2hhbmdlZCk7XG5cblx0XHQvLyB5b3UgaGF2ZSB0byB3YWl0IHVudGlsIHRoZXJlJ3MgYSBtYXAgdG8gcXVlcnkgdG8gZ2V0IHRoZSB2aXNpYmxlIG1hcHNcblx0XHRjb25zdCB3YWl0aW5nSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRpZiAoUmFzdGVyU3RvcmUuaGFzTG9hZGVkKCkpIHtcblx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh3YWl0aW5nSWQpO1xuXG5cdFx0XHRcdC8vIGVtaXQgbWFwcGVkIG1vdmVkIGV2ZW50IHRvIGluaXRpYWxpemUgbWFwIHN0YXRlXG5cdFx0XHRcdEFwcEFjdGlvbnMubWFwSW5pdGlhbGl6ZWQodGhpcy5yZWZzLnRoZV9tYXAubGVhZmxldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0sIDEwMCk7XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7IH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUgKCkge31cblxuXHQvKiBzZXRTdGF0ZSBtZXRob2RzICovXG5cblx0Z2V0RGVmYXVsdFN0YXRlICgpIHtcblx0XHRjb25zdCBoYXNoU3RhdGUgPSBIYXNoTWFuYWdlci5nZXRTdGF0ZSgpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbGVjdGVkQ2l0eTogKGhhc2hTdGF0ZS5jaXR5KSA/IHBhcnNlSW50KGhhc2hTdGF0ZS5jaXR5KSA6IG51bGwsIFxuXHRcdFx0c2VsZWN0ZWROZWlnaGJvcmhvb2Q6IChoYXNoU3RhdGUuYXJlYSkgPyBoYXNoU3RhdGUuYXJlYSA6IG51bGwsXG5cdFx0XHRzZWxlY3RlZENhdGVnb3J5OiAoaGFzaFN0YXRlLmNhdGVnb3J5KSA/IGhhc2hTdGF0ZS5jYXRlZ29yeSA6IG51bGwsXG5cdFx0XHRzZWxlY3RlZFJpbmdHcmFkZTogeyBcblx0XHRcdFx0cmluZ0lkOiBudWxsLCBcblx0XHRcdFx0Z3JhZGU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRzZWxlY3RlZEdyYWRlOiBudWxsLFxuXHRcdFx0cmFzdGVyOiB7XG5cdFx0XHRcdG9wYWNpdHk6IChoYXNoU3RhdGUub3BhY2l0eSkgPyBwYXJzZUZsb2F0KGhhc2hTdGF0ZS5vcGFjaXR5KSA6IDAuOFxuXHRcdFx0fSxcblx0XHRcdGhpZ2hsaWdodGVkTmVpZ2hib3Job29kOiBudWxsLFxuXHRcdFx0YnVyZ2Vzc0RpYWdyYW1WaXNpYmxlOiBmYWxzZSxcblx0XHRcdGRvd25sb2FkT3BlbjogZmFsc2UsXG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0em9vbTogKGhhc2hTdGF0ZS5sb2MgJiYgaGFzaFN0YXRlLmxvYy56b29tKSA/IGhhc2hTdGF0ZS5sb2Muem9vbSA6IDUsXG5cdFx0XHRcdGNlbnRlcjogKGhhc2hTdGF0ZS5sb2MgJiYgaGFzaFN0YXRlLmxvYy5jZW50ZXIpID8gW2hhc2hTdGF0ZS5sb2MuY2VudGVyWzBdLCBoYXNoU3RhdGUubG9jLmNlbnRlclsxXV0gOiBbMzkuODMzMzMzMywtOTguNTg1NTIyXVxuXHRcdFx0fSxcblx0XHRcdGRpbWVuc2lvbnM6IHtcblx0XHRcdFx0bGVmdDoge1xuXHRcdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRcdGhlaWdodDogMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cHBlclJpZ2h0OiB7XG5cdFx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0c3RvcmVDaGFuZ2VkIChvcHRpb25zID0ge30pIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdHNlbGVjdGVkQ2l0eTogQ2l0eVN0b3JlLmdldElkKCksXG5cdFx0XHRzZWxlY3RlZEdyYWRlOiBDaXR5U3RvcmUuZ2V0U2VsZWN0ZWRHcmFkZSgpLFxuXHRcdFx0c2VsZWN0ZWROZWlnaGJvcmhvb2Q6IENpdHlTdG9yZS5nZXRTZWxlY3RlZEhvbGNJZCgpLFxuXHRcdFx0c2VsZWN0ZWRDYXRlZ29yeTogQ2l0eVN0b3JlLmdldFNlbGVjdGVkQ2F0ZWdvcnkoKSxcblx0XHRcdHNlbGVjdGVkUmluZ0dyYWRlOiBDaXR5U3RvcmUuZ2V0U2VsZWN0ZWRSaW5nR3JhZGUoKSxcblx0XHRcdGhpZ2hsaWdodGVkTmVpZ2hib3Job29kOiBDaXR5U3RvcmUuZ2V0SGlnaGxpZ2h0ZWRIb2xjSWQoKSxcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRjZW50ZXI6IE1hcFN0YXRlU3RvcmUuZ2V0Q2VudGVyKCksXG5cdFx0XHRcdHpvb206IE1hcFN0YXRlU3RvcmUuZ2V0Wm9vbSgpXG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5jaGFuZ2VIYXNoKTsgXG5cdH1cblxuXHRvbk1hcE1vdmVkIChldmVudCkge1xuXHRcdEFwcEFjdGlvbnMubWFwTW92ZWQodGhpcy5yZWZzLnRoZV9tYXAubGVhZmxldEVsZW1lbnQpO1xuXHR9XG5cblx0b25DaXR5U2VsZWN0ZWQgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5jaXR5U2VsZWN0ZWQoZXZlbnQudGFyZ2V0LmlkLCB0cnVlKTtcblx0fVxuXG5cdG9uQ2l0eU1hcmtlclNlbGVjdGVkIChldmVudCkge1xuXHRcdEFwcEFjdGlvbnMuY2l0eVNlbGVjdGVkKGV2ZW50LnRhcmdldC5vcHRpb25zLmlkLCB0cnVlKTtcblx0fVxuXG5cdG9uTmVpZ2hib3Job29kUG9seWdvbkNsaWNrIChldmVudCkge1xuXHRcdGxldCBuZWlnaGJvcmhvb2RJZCA9IGV2ZW50LnRhcmdldC5vcHRpb25zLm5laWdoYm9yaG9vZElkLFxuXHRcdFx0YWRJZCA9IGV2ZW50LnRhcmdldC5vcHRpb25zLmFkSWQ7XG5cblx0XHQvLyBjbGlja2luZyBvbiBhIHNlbGVjdGVkIG5laWdoYm9yaG9vZCBkZXNlbGVjdHMgaXRcblx0XHRuZWlnaGJvcmhvb2RJZCA9IChuZWlnaGJvcmhvb2RJZCA9PSB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKSA/IG51bGwgOiBuZWlnaGJvcmhvb2RJZFxuXG5cdFx0QXBwQWN0aW9ucy5uZWlnaGJvcmhvb2RTZWxlY3RlZChuZWlnaGJvcmhvb2RJZCwgYWRJZCk7XG5cdH1cblxuXHRvbkhPTENJRENsaWNrIChldmVudCkge1xuXHRcdGNvbnNvbGUubG9nKGV2ZW50KTtcblx0XHRBcHBBY3Rpb25zLm5laWdoYm9yaG9vZFNlbGVjdGVkKGV2ZW50LnRhcmdldC5pZCwgdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpO1xuXHR9XG5cblx0bmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5uZWlnaGJvcmhvb2RIaWdobGlnaHRlZChldmVudC50YXJnZXQuaWQpO1xuXHR9XG5cblx0bmVpZ2hib3Job29kc1VuaGlnaGxpZ2h0ZWQgKCkge1xuXHRcdEFwcEFjdGlvbnMubmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQobnVsbCk7XG5cdH1cblxuXHRvbkNhdGVnb3J5Q2xpY2sgKGV2ZW50KSB7XG5cdFx0QXBwQWN0aW9ucy5BRENhdGVnb3J5U2VsZWN0ZWQoZXZlbnQudGFyZ2V0LmlkKTtcblx0fVxuXG5cdG9uQnVyZ2Vzc0NoYXJ0SG92ZXIgKHJpbmdJZCwgZ3JhZGUpIHtcblx0XHRBcHBBY3Rpb25zLnJpbmdHcmFkZVNlbGVjdGVkKHtyaW5nSWQ6IHJpbmdJZCwgZ3JhZGU6IGdyYWRlfSk7XG5cdH1cblxuXHRvbkJ1cmdlc3NDaGFydE9mZiAoKSB7XG5cdFx0QXBwQWN0aW9ucy5yaW5nR3JhZGVTZWxlY3RlZCh7cmluZ0lkOiAtMSwgZ3JhZGU6IG51bGx9KTtcblx0fVxuXG5cdG9uQXJlYUNoYXJ0SG92ZXIgKGdyYWRlKSB7XG5cdFx0QXBwQWN0aW9ucy5ncmFkZVNlbGVjdGVkKGdyYWRlKTtcblx0fVxuXG5cdG9uQXJlYUNoYXJ0T2ZmICgpIHtcblx0XHRBcHBBY3Rpb25zLmdyYWRlU2VsZWN0ZWQobnVsbCk7XG5cdH1cblxuXHRvbkxlZ2VuZFNlbGVjdCAobGVnZW5kVGV4dCkge1xuXG5cdH1cblxuXHRvbkdyYWRlSG92ZXIgKGV2ZW50KSB7XG5cdFx0Y29uc29sZS5sb2coZXZlbnQpO1xuXHRcdEFwcEFjdGlvbnMuZ3JhZGVTZWxlY3RlZChldmVudC50YXJnZXQuZ3JhZGUpO1xuXHR9XG5cblx0b25HcmFkZVVuaG92ZXIgKCkge1xuXHRcdEFwcEFjdGlvbnMuZ3JhZGVTZWxlY3RlZChudWxsKTtcblx0fVxuXG5cdGNhdGVnb3J5U2VsZWN0ZWQgKGlkKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRzZWxlY3RlZE5laWdoYm9yaG9vZDogbnVsbCxcblx0XHRcdHNlbGVjdGVkQ2F0ZWdvcnk6IGlkXG5cdFx0fSwgdGhpcy5jaGFuZ2VIYXNoKTtcblx0fVxuXG5cdG9uV2luZG93UmVzaXplIChldmVudCkge1xuXHRcdHRoaXMuY29tcHV0ZUNvbXBvbmVudERpbWVuc2lvbnMoKTtcblx0fVxuXG5cdG9uU3RhdGVTZWxlY3RlZCAodmFsdWUsIGluZGV4KSB7XG5cdFx0Ly8gZm9yIGNsaWNrIG9uIHN0YXRlIG5hbWUgaW4gc2lkZWJhclxuXHRcdHZhbHVlID0gKHZhbHVlLnRhcmdldCkgPyB2YWx1ZS50YXJnZXQgOiB2YWx1ZTtcblx0XHRcdFx0XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRzZWxlY3RlZENpdHk6IG51bGwsXG5cdFx0XHRzZWxlY3RlZE5laWdoYm9yaG9vZDogbnVsbCxcblx0XHRcdG1hcDoge1xuXHRcdFx0XHR6b29tOiB0aGlzLnJlZnMudGhlX21hcC5sZWFmbGV0RWxlbWVudC5nZXRCb3VuZHNab29tKFJhc3RlclN0b3JlLmdldE1hcEJvdW5kc0ZvclN0YXRlKHZhbHVlLmlkKSksXG5cdFx0XHRcdGNlbnRlcjogUmFzdGVyU3RvcmUuZ2V0Q2VudGVyRm9yU3RhdGUodmFsdWUuaWQpXG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5jaGFuZ2VIYXNoKCkpO1xuXHR9XG5cblx0b25TbGlkZXJDaGFuZ2UgKHZhbHVlKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRyYXN0ZXI6IHtcblx0XHRcdFx0b3BhY2l0eTogdmFsdWUgLyAxMDBcblx0XHRcdH1cblx0XHR9LCB0aGlzLmNoYW5nZUhhc2gpO1xuXHR9XG5cblx0b25Eb3dubG9hZENsaWNrZWQgKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0ZG93bmxvYWRPcGVuOiAhdGhpcy5zdGF0ZS5kb3dubG9hZE9wZW5cblx0XHR9KTtcblx0fVxuXG5cdG9uUGFub3JhbWFNZW51Q2xpY2sgKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0c2hvd19wYW5vcmFtYV9tZW51OiAhdGhpcy5zdGF0ZS5zaG93X3Bhbm9yYW1hX21lbnVcblx0XHR9KTtcblx0fVxuXG5cdG9uVXNlckNpdHlSZXNwb25zZShldmVudCkge1xuXHRcdGlmIChldmVudC50YXJnZXQudmFsdWUgPT0gJ3llcycpIHtcblx0XHRcdEFwcEFjdGlvbnMuY2l0eVNlbGVjdGVkKFVzZXJMb2NhdGlvblN0b3JlLmdldEFkSWQoKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdEFwcEFjdGlvbnMudXNlclJlc3BvbmRlZFRvWm9vbU9mZmVyKCk7XG5cdH1cblxuXHR0b2dnbGVCdXJnZXNzRGlhZ3JhbSAoKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRidXJnZXNzRGlhZ3JhbVZpc2libGU6ICF0aGlzLnN0YXRlLmJ1cmdlc3NEaWFncmFtVmlzaWJsZVxuXHRcdH0pO1xuXHR9XG5cblx0b25Nb2RhbENsaWNrIChldmVudCkge1xuXHRcdGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCk7XG5cdFx0Y29uc3Qgc3ViamVjdCA9IChldmVudC50YXJnZXQuaWQpID8gKGV2ZW50LnRhcmdldC5pZCkgOiBudWxsO1xuXHRcdEFwcEFjdGlvbnMub25Nb2RhbENsaWNrKHN1YmplY3QpO1xuXHR9XG5cblx0LyogbWFuYWdlIGhhc2ggKi9cblxuXHRjaGFuZ2VIYXNoICgpIHtcblx0XHRIYXNoTWFuYWdlci51cGRhdGVIYXNoKHsgXG5cdFx0XHRjaXR5OiB0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSxcblx0XHRcdGFyZWE6IHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QsXG5cdFx0XHRjYXRlZ29yeTogdGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5LFxuXHRcdFx0b3BhY2l0eTogdGhpcy5zdGF0ZS5yYXN0ZXIub3BhY2l0eSxcblx0XHRcdGxvYzoge1xuXHRcdFx0XHR6b29tOiB0aGlzLnN0YXRlLm1hcC56b29tLFxuXHRcdFx0XHRjZW50ZXI6IHRoaXMuc3RhdGUubWFwLmNlbnRlclxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyogaGVscGVyIG1ldGhvZHMgKi9cblxuXHRjb21wdXRlQ29tcG9uZW50RGltZW5zaW9ucyAoKSB7XG5cdFx0Ly8gYmFzZWQgb2ZmIG9mIHNpemVzIHN0b3JlZCB3aXRoaW4gX3ZhcmlhYmxlcy5zY3NzIC0tXG5cdFx0Ly8gaWYgeW91IGNoYW5nZSB0aGVtIHRoZXJlLCBjaGFuZ2UgdGhlbSBoZXJlLlxuXHRcdHZhciBjb250YWluZXJQYWRkaW5nID0gMjAsXG5cdFx0XHRoZWFkZXJIZWlnaHQgPSAxMDAsXG5cdFx0XHRib3R0b21Sb3dIZWlnaHQgPSAzMDAsXG5cdFx0XHRkaW1lbnNpb25zID0ge307XG5cblx0XHRkaW1lbnNpb25zLnNlYXJjaCA9IHtcblx0XHRcdHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAvIDMgLSAyICogY29udGFpbmVyUGFkZGluZyxcblx0XHRcdGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gMiAqIGNvbnRhaW5lclBhZGRpbmdcblx0XHR9O1xuXG5cdFx0ZGltZW5zaW9ucy5hcmVhQ2hhcnQgPSB7XG5cdFx0XHR3aWR0aDogd2luZG93LmlubmVyV2lkdGggLyAzIC0gNCAqIGNvbnRhaW5lclBhZGRpbmcsXG5cdFx0fTtcblxuXHRcdGRpbWVuc2lvbnMuYm90dG9tID0ge1xuXHRcdFx0aGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBoZWFkZXJIZWlnaHQgLSAyICogY29udGFpbmVyUGFkZGluZ1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFN0YXRlKHsgZGltZW5zaW9uczogZGltZW5zaW9ucyB9KTtcblx0fVxuXG5cdHNlYXJjaERpc3BsYXkgKCkge1xuXHRcdGxldCBjaXRpZXNPcHRpb25zID0gUmFzdGVyU3RvcmUuZ2V0Q2l0eUlkc0FuZE5hbWVzKCksXG5cdFx0XHRjaXRpZXNEYXRhID0gUmFzdGVyU3RvcmUuZ2V0QWxsUmFzdGVycygpO1xuXHRcdHJldHVybiBjaXRpZXNPcHRpb25zLm1hcCgoY2l0eU9wdGlvbikgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQ6IGNpdHlPcHRpb24uaWQsXG5cdFx0XHRcdGNpdHlOYW1lOiBjaXR5T3B0aW9uLmNpdHlOYW1lLFxuXHRcdFx0XHRkaXNwbGF5OiA8Q2l0eVNuaXBwZXQgXG5cdFx0XHRcdFx0Y2l0eURhdGE9eyBjaXRpZXNEYXRhW2NpdHlPcHRpb24uaWRdIH0gXG5cdFx0XHRcdFx0b25DaXR5Q2xpY2s9eyB0aGlzLnByb3BzLm9uQ2l0eUNsaWNrIH0gXG5cdFx0XHRcdFx0a2V5PXsgJ2NpdHlTZWFyY2gnICsgY2l0eU9wdGlvbi5pZCB9IFxuXHRcdFx0XHQvPlxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyogcmVuZGVyIGFuZCBkaXNwbGF5IG1ldGhvZHMgKi9cbsKgwqDCoMKgwqBcblx0cmVuZGVyU2lkZWJhcigpIHtcblx0XHRsZXQgdGl0bGUsIGNvbnRlbnQsIGNvbnRlbnQyLCB0aGVDbGFzcywgQURzLCBBRHNCeUNhdDtcblx0XHQvLyBpZiAoQXJlYURlc2NyaXB0aW9uc1N0b3JlLmRhdGEuYXJlYURlc2NyaXB0aW9ucyAmJiBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZGF0YS5hcmVhRGVzY3JpcHRpb25zW3RoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5XSkge1xuXHRcdC8vIFx0Y29uc29sZS5sb2coQXJlYURlc2NyaXB0aW9uc1N0b3JlLmRhdGEuYXJlYURlc2NyaXB0aW9uc1t0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eV0uYnlDYXRlZ29yeSk7XG5cdFx0Ly8gfVxuXHRcdGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSkge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QpIHtcblx0XHRcdFx0QURzID0gQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldEFEc0Zvck5laWdoYm9yaG9vZCh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZClcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5KSB7XG5cdFx0XHRcdEFEc0J5Q2F0ID0gQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldEFEc0ZvckNhdGVnb3J5KHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5LCB0aGlzLnN0YXRlLnNlbGVjdGVkQ2F0ZWdvcnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnN0YXRlLmRvd25sb2FkT3Blbikge1xuXHRcdFx0dGl0bGUgPSBcdDxoMj5cblx0XHRcdFx0XHRcdFx0eyAodHlwZW9mKFJhc3RlclN0b3JlLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCkpICE9ICd1bmRlZmluZWQnKSA/IFJhc3RlclN0b3JlLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCkubmFtZSA6ICcnIH1cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2Rvd25sb2FkaWNvbicgaHJlZj0nIycgb25DbGljaz17IHRoaXMub25Eb3dubG9hZENsaWNrZWQgfT48L2Rpdj5cblx0XHRcdFx0XHRcdDwvaDI+O1xuXHRcdFx0Y29udGVudCA9IDxEb3dubG9hZGVyIG1hcHVybD17IFJhc3RlclN0b3JlLmdldE1hcFVybCgpIH0gbmFtZT17IFJhc3RlclN0b3JlLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCkubmFtZSB9IC8+O1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCAmJiBBRHMpIHtcblx0XHRcdHRoZUNsYXNzID0gJ2FyZWEnO1xuXHRcdFx0dGl0bGUgPSBcdDxoMj5cblx0XHRcdFx0XHRcdFx0PHNwYW4+eyBDaXR5U3RvcmUuZ2V0TmFtZSgpICsgJywgJ308L3NwYW4+IFxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBcblx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5vblN0YXRlU2VsZWN0ZWQgfSBcblx0XHRcdFx0XHRcdFx0XHRpZD17IENpdHlTdG9yZS5nZXRTdGF0ZSgpIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdHsgQ2l0eVN0b3JlLmdldFN0YXRlKCkgfVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdkb3dubG9hZGljb24nIGhyZWY9JyMnIG9uQ2xpY2s9eyB0aGlzLm9uRG93bmxvYWRDbGlja2VkIH0+PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2gyPjtcblx0XHRcdGNvbnRlbnQgPSBcdDxBcmVhRGVzY3JpcHRpb24gXG5cdFx0XHRcdFx0XHRcdGFyZWFJZD17IHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QgfSBcblx0XHRcdFx0XHRcdFx0cHJldmlvdXNBcmVhSWQ9eyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0UHJldmlvdXNIT0xDSWQodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QpIH1cblx0XHRcdFx0XHRcdFx0bmV4dEFyZWFJZD17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXROZXh0SE9MQ0lkKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5LCB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKSB9XG5cdFx0XHRcdFx0XHRcdGFyZWFEZXNjcmlwdGlvbnM9eyBBRHMgfSBcblx0XHRcdFx0XHRcdFx0Zm9ybUlkPXsgQ2l0eVN0b3JlLmdldEZvcm1JZCgpIH0gXG5cdFx0XHRcdFx0XHRcdGNpdHlJZD17IHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5IH1cblx0XHRcdFx0XHRcdFx0b25DYXRlZ29yeUNsaWNrPXsgdGhpcy5vbkNhdGVnb3J5Q2xpY2sgfSBcblx0XHRcdFx0XHRcdFx0b25IT0xDSURDbGljaz17IHRoaXMub25IT0xDSURDbGljayB9IFxuXHRcdFx0XHRcdFx0XHRyZWY9eydhcmVhZGVzY3JpcHRpb24nICsgdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZCB9IFxuXHRcdFx0XHRcdFx0Lz47XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkQ2F0ZWdvcnkgJiYgQURzQnlDYXQpIHtcblx0XHRcdGxldCBbY2F0TnVtLCBjYXRMZXR0ZXJdID0gdGhpcy5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5LnNwbGl0KCctJyk7XG5cdFx0XHR0aGVDbGFzcyA9ICdjYXRlZ29yeSc7XG5cdFx0XHR0aXRsZSA9IFx0PGgyPlxuXHRcdFx0XHRcdFx0XHQ8c3Bhbj57IENpdHlTdG9yZS5nZXROYW1lKCkgKyAnLCAnfTwvc3Bhbj4gXG5cdFx0XHRcdFx0XHRcdDxzcGFuIFxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLm9uU3RhdGVTZWxlY3RlZCB9IFxuXHRcdFx0XHRcdFx0XHRcdGlkPXsgQ2l0eVN0b3JlLmdldFN0YXRlKCkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0eyBDaXR5U3RvcmUuZ2V0U3RhdGUoKSB9XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2Rvd25sb2FkaWNvbicgaHJlZj0nIycgb25DbGljaz17IHRoaXMub25Eb3dubG9hZENsaWNrZWQgfT48L2Rpdj5cblx0XHRcdFx0XHRcdDwvaDI+O1xuXHRcdFx0Y29udGVudCA9IFx0PEFEQ2F0IFxuXHRcdFx0XHRcdFx0XHRBRHNCeUNhdD17IEFEc0J5Q2F0IH1cblx0XHRcdFx0XHRcdFx0Zm9ybUlkID0geyBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0Rm9ybUlkKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KSB9XG5cdFx0XHRcdFx0XHRcdHRpdGxlPXsgQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldENhdFRpdGxlKHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5LCBjYXROdW0sIGNhdExldHRlcikgfVxuXHRcdFx0XHRcdFx0XHRjYXROdW09eyBjYXROdW0gfSBcblx0XHRcdFx0XHRcdFx0Y2F0TGV0dGVyID0geyBjYXRMZXR0ZXIgfSBcblx0XHRcdFx0XHRcdFx0cHJldmlvdXNDYXRJZHMgPSB7IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRQcmV2aW91c0NhdElkcyh0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eSwgY2F0TnVtLCBjYXRMZXR0ZXIpIH1cblx0XHRcdFx0XHRcdFx0bmV4dENhdElkcyA9IHsgQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldE5leHRDYXRJZHModGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIGNhdE51bSwgY2F0TGV0dGVyKSB9XG5cdFx0XHRcdFx0XHRcdGNpdHlJZD17IHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5IH1cblx0XHRcdFx0XHRcdFx0b25OZWlnaGJvcmhvb2RDbGljaz17IHRoaXMub25IT0xDSURDbGljayB9IFxuXHRcdFx0XHRcdFx0XHRvbkNhdGVnb3J5Q2xpY2s9eyB0aGlzLm9uQ2F0ZWdvcnlDbGljayB9IFxuXHRcdFx0XHRcdFx0XHRvbk5laWdoYm9yaG9vZEhvdmVyPXsgdGhpcy5uZWlnaGJvcmhvb2RIaWdobGlnaHRlZCB9IFxuXHRcdFx0XHRcdFx0XHRvbk5laWdoYm9yaG9vZE91dD17IHRoaXMubmVpZ2hib3Job29kc1VuaGlnaGxpZ2h0ZWQgfSBcblx0XHRcdFx0XHRcdC8+O1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpIHtcblx0XHRcdGNvbnN0IHZpc2libGVNYXBzID0gTWFwU3RhdGVTdG9yZS5nZXRWaXNpYmxlSE9MQ01hcHMoKTtcblxuXHRcdFx0dGhlQ2xhc3MgPSAnY2l0eSc7XG5cdFx0XHR0aXRsZSA9IFx0PGgyPlxuXHRcdFx0XHRcdFx0XHQ8c3Bhbj57IENpdHlTdG9yZS5nZXROYW1lKCkgKyAnLCAnfTwvc3Bhbj4gXG5cdFx0XHRcdFx0XHRcdDxzcGFuIFxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLm9uU3RhdGVTZWxlY3RlZCB9IFxuXHRcdFx0XHRcdFx0XHRcdGlkPXsgQ2l0eVN0b3JlLmdldFN0YXRlKCkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0eyBDaXR5U3RvcmUuZ2V0U3RhdGUoKSB9XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2Rvd25sb2FkaWNvbicgaHJlZj0nIycgb25DbGljaz17IHRoaXMub25Eb3dubG9hZENsaWNrZWQgfT48L2Rpdj5cblx0XHRcdFx0XHRcdDwvaDI+O1xuXHRcdFx0Y29udGVudCA9IFx0PENpdHlTdGF0cyBcblx0XHRcdFx0XHRcdFx0Y2l0eURhdGE9eyBDaXR5U3RvcmUuZ2V0Q2l0eURhdGEoKSB9IFxuXHRcdFx0XHRcdFx0XHRhcmVhPXsgQXJlYURlc2NyaXB0aW9uc1N0b3JlLmdldEFyZWEodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpIH0gXG5cdFx0XHRcdFx0XHRcdGdyYWRlU3RhdHM9eyBDaXR5U3RvcmUuZ2V0R3JhZGVTdGF0cygpIH0gXG5cdFx0XHRcdFx0XHRcdHJpbmdTdGF0cz17IENpdHlTdG9yZS5nZXRSaW5nU3RhdHMoKSB9IFxuXHRcdFx0XHRcdFx0XHRhcmVhU2VsZWN0ZWQ9eyB0aGlzLm9uQnVyZ2Vzc0NoYXJ0SG92ZXIgfSBcblx0XHRcdFx0XHRcdFx0YXJlYVVuc2VsZWN0ZWQ9eyB0aGlzLm9uQnVyZ2Vzc0NoYXJ0T2ZmIH0gXG5cdFx0XHRcdFx0XHRcdGdyYWRlU2VsZWN0ZWQ9eyB0aGlzLm9uQXJlYUNoYXJ0SG92ZXIgfSBcblx0XHRcdFx0XHRcdFx0Z3JhZGVVbnNlbGVjdGVkPXsgdGhpcy5vbkFyZWFDaGFydE9mZiB9IFxuXHRcdFx0XHRcdFx0XHRvcGVuQnVyZ2Vzcz17IHRoaXMub25Nb2RhbENsaWNrIH1cblx0XHRcdFx0XHRcdFx0YnVyZ2Vzc0RpYWdyYW1WaXNpYmxlPXsgdGhpcy5zdGF0ZS5idXJnZXNzRGlhZ3JhbVZpc2libGUgfSBcblx0XHRcdFx0XHRcdFx0dG9nZ2xlQnVyZ2Vzc0RpYWdyYW09eyB0aGlzLnRvZ2dsZUJ1cmdlc3NEaWFncmFtIH0gXG5cdFx0XHRcdFx0XHRcdGhhc0FEcz17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5oYXNBRERhdGEodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpIH1cblx0XHRcdFx0XHRcdC8+O1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKHZpc2libGVNYXBzKS5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRjb250ZW50MiA9IDxkaXY+XG5cdFx0XHRcdFx0XHRcdFx0PGg0Pk90aGVyIFZpc2libGUgTWFwczwvaDQ+XG5cdFx0XHRcdFx0XHRcdFx0eyBPYmplY3Qua2V5cyh2aXNpYmxlTWFwcykubWFwKChtYXBJZCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZpc2libGVNYXBzW21hcElkXS5jaXR5SWQgIT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiA8Q2l0eVNuaXBwZXQgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2l0eURhdGE9eyB2aXNpYmxlTWFwc1ttYXBJZF0gfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNpdHlDbGljaz17IHRoaXMub25DaXR5U2VsZWN0ZWQgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9eyAnY2l0eScgKyBtYXBJZCB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlY2VudGVyPXsgZmFsc2UgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0fSBcblx0XHRcdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHRcdFx0PC9kaXY+O1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICghdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHkpIHtcblx0XHRcdHRoZUNsYXNzID0gJ3N0YXRlJztcblx0XHRcdGxldCB2aXNpYmxlU3RhdGVzID0gTWFwU3RhdGVTdG9yZS5nZXRWaXNpYmxlSE9MQ01hcHNCeVN0YXRlKCk7XG5cdFx0XHRpZiAoTWFwU3RhdGVTdG9yZS5nZXRWaXNpYmxlSE9MQ01hcHNJZHMoKS5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRjb250ZW50ID0gXHRPYmplY3Qua2V5cyh2aXNpYmxlU3RhdGVzKS5tYXAoKHRoZVN0YXRlKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIDxTdGF0ZVN0YXRzIFxuXHRcdFx0XHRcdFx0c3RhdGVOYW1lPXsgc3RhdGVBYmJyc1t0aGVTdGF0ZV0gfSBcblx0XHRcdFx0XHRcdGNpdGllcz17IHZpc2libGVTdGF0ZXNbdGhlU3RhdGVdIH0gXG5cdFx0XHRcdFx0XHRvbkNpdHlDbGljaz17IHRoaXMub25DaXR5U2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0a2V5PXsgdGhlU3RhdGUgfVxuXHRcdFx0XHRcdFx0YXJlYUNoYXJ0V2lkdGg9eyB0aGlzLnN0YXRlLmRpbWVuc2lvbnMuYXJlYUNoYXJ0LndpZHRoIH1cblx0XHRcdFx0XHQvPjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyB0aGVDbGFzcyB9IGtleT17IHRoZUNsYXNzIH0+XG5cdFx0XHRcdHsgdGl0bGUgfVxuXHRcdFx0XHR7IGNvbnRlbnQgfVxuXHRcdFx0XHR7IGNvbnRlbnQyIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXHRcdC8vY29uc29sZS5sb2codGhpcy5zdGF0ZSk7XG5cdFx0bGV0IG1vZGFsU3R5bGUgPSB7XG5cdFx0XHRcdG92ZXJsYXkgOiB7XG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBudWxsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbnRlbnQgOiB7XG5cdFx0XHRcdFx0dG9wOiBudWxsLFxuXHRcdFx0XHRcdGxlZnQ6IG51bGwsXG5cdFx0XHRcdFx0cmlnaHQ6IG51bGwsXG5cdFx0XHRcdFx0Ym90dG9tOiBudWxsLFxuXHRcdFx0XHRcdGJvcmRlcjogbnVsbCxcblx0XHRcdFx0XHRiYWNrZ3JvdW5kOiBudWxsLFxuXHRcdFx0XHRcdGJvcmRlclJhZGl1czogbnVsbCxcblx0XHRcdFx0XHRwYWRkaW5nOiBudWxsLFxuXHRcdFx0XHRcdHBvc2l0aW9uOiBudWxsXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRBRHMgPSBBcmVhRGVzY3JpcHRpb25zU3RvcmUuZ2V0VmlzaWJsZSgpLFxuXHRcdFx0YWJvdmVUaHJlc2hvbGQgPSBNYXBTdGF0ZVN0b3JlLmlzQWJvdmVab29tVGhyZXNob2xkKCksXG5cdFx0XHRvdXRlclJhZGl1cyA9IENpdHlTdG9yZS5nZXRPdXRlclJpbmdSYWRpdXMoKTtcblxuXHRcdGxldCBsZWdlbmREYXRhID0ge1xuXHRcdFx0aXRlbXM6IFtcblx0XHRcdFx0J0EgRmlyc3QgR3JhZGUnLFxuXHRcdFx0XHQnQiBTZWNvbmQgR3JhZGUnLFxuXHRcdFx0XHQnQyBUaGlyZCBHcmFkZScsXG5cdFx0XHRcdCdEIFRoaXJkIEdyYWRlJyxcblx0XHRcdF1cblx0XHR9O1xuXHRcdGlmICghTWFwU3RhdGVTdG9yZS5pc0Fib3ZlWm9vbVRocmVzaG9sZCgpKSB7XG5cdFx0XHRsZWdlbmREYXRhLml0ZW1zLnB1c2goJ1Byb3BvcnRpb24gb2YgRWFjaCBHcmFkZScpO1xuXHRcdH1cblxuXHRcdC8vc2V0SWNvbkRlZmF1bHRJbWFnZVBhdGgoJy4vc3RhdGljJyk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbnRhaW5lciBmdWxsLWhlaWdodCc+XG5cdFx0XHRcdDxOYXZpZ2F0aW9uIFxuXHRcdFx0XHRcdHNob3dfbWVudT17IHRoaXMuc3RhdGUuc2hvd19wYW5vcmFtYV9tZW51IH0gXG5cdFx0XHRcdFx0b25faGFtYnVyZ2VyX2NsaWNrPXsgdGhpcy5vblBhbm9yYW1hTWVudUNsaWNrIH0gXG5cdFx0XHRcdFx0bmF2X2RhdGE9eyBwYW5vcmFtYU5hdkRhdGEuZmlsdGVyKChpdGVtLCBpKSA9PiBpdGVtLnVybC5pbmRleE9mKCdob2xjJykgPT09IC0xKSB9IFxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ncm93IGZ1bGwtaGVpZ2h0Jz5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nY29sdW1ucyBlaWdodCBmdWxsLWhlaWdodCc+XG5cdFx0XHRcdFx0XHQ8aGVhZGVyIGNsYXNzTmFtZT0ncm93IHUtZnVsbC13aWR0aCc+XG5cdFx0XHRcdFx0XHRcdDxoMT5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2hlYWRlci1tYWluJz5NYXBwaW5nIEluZXF1YWxpdHk8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdoZWFkZXItc3ViJz5SZWRsaW5pbmcgaW4gTmV3IERlYWwgQW1lcmljYTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PC9oMT5cblx0XHRcdFx0XHRcdFx0PGg0IG9uQ2xpY2s9eyB0aGlzLm9uTW9kYWxDbGljayB9IGlkPXsgJ2Fib3V0JyB9PkludHJvZHVjdGlvbjwvaDQ+XG5cdFx0XHRcdFx0XHRcdDxoNCBvbkNsaWNrPXsgdGhpcy5vbk1vZGFsQ2xpY2sgfSBpZD17ICdiaWJsaW9ncmFwaCcgfT5CaWJsaW9ncmFwaGljIE5vdGVzICYgQmlibGlvZ3JhcGh5PC9oND5cblx0XHRcdFx0XHRcdFx0PGg0IG9uQ2xpY2s9eyB0aGlzLm9uTW9kYWxDbGljayB9IGlkPXsgJ2NyZWRpdHMnIH0+Q3JlZGl0czwvaDQ+XG5cdFx0XHRcdFx0XHRcdDxociBjbGFzc05hbWU9J3N0eWxlLWVpZ2h0JyAvPlxuXHRcdFx0XHRcdFx0PC9oZWFkZXI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ncm93IHRlbXBsYXRlLXRpbGUgbGVhZmxldC1jb250YWluZXIgbWFpbi1wYW5lJyBzdHlsZT17e2hlaWdodDogdGhpcy5zdGF0ZS5kaW1lbnNpb25zLmJvdHRvbS5oZWlnaHQgKyAncHgnfX0+XG5cdFx0XHRcdFx0XHRcdDxNYXAgXG5cdFx0XHRcdFx0XHRcdFx0cmVmPSd0aGVfbWFwJyBcblx0XHRcdFx0XHRcdFx0XHRjZW50ZXI9eyB0aGlzLnN0YXRlLm1hcC5jZW50ZXIgfSBcblx0XHRcdFx0XHRcdFx0XHR6b29tPXsgdGhpcy5zdGF0ZS5tYXAuem9vbSB9ICBcblx0XHRcdFx0XHRcdFx0XHRvbk1vdmVlbmQ9eyB0aGlzLm9uTWFwTW92ZWQgfSBcblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9J3RoZV9tYXAnXG5cdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdHsgdGlsZUxheWVycy5sYXllcnMubWFwKChpdGVtLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKHRoaXMuc3RhdGUubWFwLnpvb20gPCAxMCApID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFRpbGVMYXllclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT0nbm9MYWJlbHMnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXJsPXsgaXRlbS51cmxOb0xhYmVscyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ekluZGV4PXsgLTEgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvPiA6IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8VGlsZUxheWVyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PSdsYWJlbHMnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXJsPXsgaXRlbS51cmxMYWJlbHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHpJbmRleD17IC0xIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHR9KSB9IFxuXG5cdFx0XHRcdFx0XHRcdFx0eyBSYXN0ZXJTdG9yZS5nZXRNYXBzTGlzdCgpLm1hcCgoaXRlbSwgaSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IG1hcEJvdW5kcyA9IHRoaXMucmVmcy50aGVfbWFwLmxlYWZsZXRFbGVtZW50LmdldEJvdW5kcygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG1hcEJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxUaWxlTGF5ZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdob2xjdGlsZXMnICsgaX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICd0aWxlc0ZvckNpdHknICsgaXRlbS5jaXR5SWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXJsPXsgaXRlbS51cmwgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWluWm9vbT17IGl0ZW0ubWluWm9vbSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib3VuZHM9IHsgaXRlbS5ib3VuZHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3BhY2l0eT17IHRoaXMuc3RhdGUucmFzdGVyLm9wYWNpdHkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ekluZGV4PXsgKGl0ZW0uY2l0eUlkID09IHRoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5KSA/IDEgOiBudWxsIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pIH1cblxuXHRcdFx0XHRcdFx0XHRcdHsgKCFhYm92ZVRocmVzaG9sZCkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FydG9kYkxheWVycy5sYXllcmdyb3VwLmxheWVycy5tYXAoKGl0ZW0sIGkpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8Q2FydG9EQlRpbGVMYXllclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2NhcnRvZGItdGlsZS1sYXllci0nICsgaSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1c2VySWQ9eyBjYXJ0b2RiQ29uZmlnLnVzZXJJZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzcWw9eyBpdGVtLm9wdGlvbnMuc3FsIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhcnRvY3NzPXsgaXRlbS5vcHRpb25zLmNhcnRvY3NzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHpJbmRleD17MTAwMH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHsvKiByaW5nczogZG9udXQgaG9sZXMgKi99XG5cdFx0XHRcdFx0XHRcdFx0eyAoYWJvdmVUaHJlc2hvbGQgJiYgb3V0ZXJSYWRpdXMgPiAwKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Q2lyY2xlIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjZW50ZXI9eyBDaXR5U3RvcmUuZ2V0TG9vcExhdExuZygpIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJhZGl1cz17IG91dGVyUmFkaXVzIC8gNyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWxsT3BhY2l0eT17ICh0aGlzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCA+PSAyKSA/IDAuNzUgOiAwIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpbGxDb2xvcj0geyAnIzAwMCcgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xpY2thYmxlPXsgZmFsc2UgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgJ2RvbnV0aG9sZScgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2RvbnV0aG9sZScgfSBcblx0XHRcdFx0XHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdHsvKiByaW5nczogZG9udXRzICovfVxuXHRcdFx0XHRcdFx0XHRcdHsgKGFib3ZlVGhyZXNob2xkICYmIG91dGVyUmFkaXVzID4gMCkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0WzIsMyw0LDVdLm1hcCgocmluZ051bSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxEb251dCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNlbnRlcj17IENpdHlTdG9yZS5nZXRMb29wTGF0TG5nKCkgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlubmVyUmFkaXVzPXsgKHJpbmdOdW0gKiAyIC0gMykgLyA3ICogb3V0ZXJSYWRpdXMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJSYWRpdXM9eyAocmluZ051bSA9PSA1KSA/IG91dGVyUmFkaXVzICogMTAwIDogKHJpbmdOdW0gKiAyIC0gMSkgLyA3ICogb3V0ZXJSYWRpdXN9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGlja2FibGU9eyBmYWxzZSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsbE9wYWNpdHk9eyAodGhpcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5yaW5nSWQgPiAwICYmIHJpbmdOdW0gIT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRSaW5nR3JhZGUucmluZ0lkKSA/IDAuNzUgOiAwIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWxsQ29sb3I9IHsgJyMwMDAnIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3ZWlnaHQ9eyAxIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdkb251dCcgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdkb251dCcgKyBTdHJpbmcocmluZ051bSkgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHsvKiByaW5nczogc2VsZWN0ZWQgcmluZyAqL31cblx0XHRcdFx0XHRcdFx0XHR7IChhYm92ZVRocmVzaG9sZCAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCA+IDApID9cblx0XHRcdFx0XHRcdFx0XHRcdDxMYXllckdyb3VwPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8R2VvSnNvbiBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhPXsgQ2l0eVN0b3JlLmdldEludmVydGVkR2VvSnNvbkZvclNlbGVjdGVkUmluZ0FyZWEodGhpcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5yaW5nSWQsIHRoaXMuc3RhdGUuc2VsZWN0ZWRSaW5nR3JhZGUuZ3JhZGUpIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGlja2FibGU9eyBmYWxzZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2ludmVydGVkUmluZ1N0cm9rZSd9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbGxDb2xvcj17ICcjMDAwJ31cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWxsT3BhY2l0eT17IDAuNiB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3I9eyAnI2ZmZicgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdlaWdodD17IDIgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wYWNpdHk9eyAwLjkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdpbnZlcnRlZFJpbmdHcmFkZWRBcmVhJyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxHZW9Kc29uIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGE9eyBDaXR5U3RvcmUuZ2V0R2VvSnNvbkZvclNlbGVjdGVkUmluZ0FyZWEodGhpcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5yaW5nSWQsIHRoaXMuc3RhdGUuc2VsZWN0ZWRSaW5nR3JhZGUuZ3JhZGUpIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGlja2FibGU9eyBmYWxzZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ3JpbmdTdHJva2UnfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWxsT3BhY2l0eT17ICgxIC0gdGhpcy5zdGF0ZS5yYXN0ZXIub3BhY2l0eSkgLyAyIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3ZWlnaHQ9eyAyIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcGFjaXR5PXsgMC45IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAncmluZ0dyYWRlZEFyZWEgZ3JhZGUnICsgdGhpcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5ncmFkZX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvTGF5ZXJHcm91cD4gOlxuXHRcdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHsvKiBzZWxlY3RlZCBncmFkZSAqL31cblx0XHRcdFx0XHRcdFx0XHR7IChhYm92ZVRocmVzaG9sZCAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkR3JhZGUpID9cblx0XHRcdFx0XHRcdFx0XHRcdDxBcmVhUG9seWdvbiBcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YT17IEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5nZXRHZW9Kc29uRm9yR3JhZGUodGhpcy5zdGF0ZS5zZWxlY3RlZENpdHksIHRoaXMuc3RhdGUuc2VsZWN0ZWRHcmFkZSkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9eyAnc2VsZWN0ZWRHcmFkZWROZWlnaGJvcmhvb2RzJyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnc2VsZWN0ZWRHcmFkZWROZWlnaGJvcmhvb2RzIGdyYWRlJyArIHRoaXMuc3RhdGUuc2VsZWN0ZWRHcmFkZSB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHsgKGFib3ZlVGhyZXNob2xkICYmIHRoaXMuc3RhdGUuaGlnaGxpZ2h0ZWROZWlnaGJvcmhvb2QgJiYgQURzW3RoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5XSAmJiBBRHNbdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMuc3RhdGUuaGlnaGxpZ2h0ZWROZWlnaGJvcmhvb2RdICYmIEFEc1t0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5zdGF0ZS5oaWdobGlnaHRlZE5laWdoYm9yaG9vZF0uYXJlYV9nZW9qc29uX2ludmVydGVkKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHQ8QXJlYVBvbHlnb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YT17IEFEc1t0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5zdGF0ZS5oaWdobGlnaHRlZE5laWdoYm9yaG9vZF0uYXJlYV9nZW9qc29uX2ludmVydGVkIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsaWNrYWJsZT17IGZhbHNlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgJ25laWdoYm9yaG9vZFBvbHlnb25JbnZlcnRlZCBncmFkZScgKyBBRHNbdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMuc3RhdGUuaGlnaGxpZ2h0ZWROZWlnaGJvcmhvb2RdLmhvbGNfZ3JhZGUgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ25laWdoYm9yaG9vZFBvbHlnb25JbnZlcnRlZCcgKyB0aGlzLnN0YXRlLmhpZ2hsaWdodGVkTmVpZ2hib3Job29kIH1cblx0XHRcdFx0XHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7Lyogc2VsZWN0ZWQgbmVpZ2hib3Job29kICovfVxuXHRcdFx0XHRcdFx0XHRcdHsgKGFib3ZlVGhyZXNob2xkICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QgJiYgQURzW3RoaXMuc3RhdGUuc2VsZWN0ZWRDaXR5XSAmJiBBRHNbdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2RdICYmIEFEc1t0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZF0uYXJlYV9nZW9qc29uX2ludmVydGVkKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHQ8QXJlYVBvbHlnb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YT17IEFEc1t0aGlzLnN0YXRlLnNlbGVjdGVkQ2l0eV1bdGhpcy5zdGF0ZS5zZWxlY3RlZE5laWdoYm9yaG9vZF0uYXJlYV9nZW9qc29uX2ludmVydGVkIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsaWNrYWJsZT17IGZhbHNlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgJ25laWdoYm9yaG9vZFBvbHlnb25JbnZlcnRlZCBncmFkZScgKyBBRHNbdGhpcy5zdGF0ZS5zZWxlY3RlZENpdHldW3RoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2RdLmhvbGNfZ3JhZGUgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ25laWdoYm9yaG9vZFBvbHlnb25JbnZlcnRlZCcgKyB0aGlzLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kIH1cblx0XHRcdFx0XHRcdFx0XHRcdC8+IDpcblx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7LyogbmVpZ2hib3Job29kIHBvbHlnb25zOiBzaG93biBvbiB6b29tIGxldmVsIDEwIGFuZCBoaWdoZXIgKi99XG5cdFx0XHRcdFx0XHRcdFx0eyAoYWJvdmVUaHJlc2hvbGQpID9cblx0XHRcdFx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKEFEcykubWFwKGFkSWQgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKEFEc1thZElkXSkubWFwKChhcmVhSWQpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxBcmVhUG9seWdvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGE9eyBBRHNbYWRJZF1bYXJlYUlkXS5hcmVhX2dlb2pzb24gfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICduZWlnaGJvcmhvb2RQb2x5Z29uIGdyYWRlJyArIEFEc1thZElkXVthcmVhSWRdLmhvbGNfZ3JhZGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICduZWlnaGJvcmhvb2RQb2x5Z29uJyArIGFyZWFJZCB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLm9uTmVpZ2hib3Job29kUG9seWdvbkNsaWNrIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZElkPXsgYWRJZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmVpZ2hib3Job29kSWQ9eyBhcmVhSWQgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvL2ZpbGxPcGFjaXR5PXsgKGlkID09IHRoaXMuc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QpID8gMSA6IDAgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcGFjaXR5Oih0aGlzLnN0YXRlLnNlbGVjdGVkUmluZ0dyYWRlLnJpbmdJZCA+IDApID8gKDEgLSB0aGlzLnN0YXRlLnJhc3Rlci5vcGFjaXR5KSAvIDUgOiAoMSAtIHRoaXMuc3RhdGUucmFzdGVyLm9wYWNpdHkpIC8gMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbGxPcGFjaXR5OiAodGhpcy5zdGF0ZS5zZWxlY3RlZFJpbmdHcmFkZS5yaW5nSWQgPiAwKSA/IDAgOiAoMSAtIHRoaXMuc3RhdGUucmFzdGVyLm9wYWNpdHkpIC8gNVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7LyogY2FydG9ncmFtIG1hcmtlciBmb3IgY2l0eTogc2hvd24gYmVsb3cgem9vbSBsZXZlbCAxMCAqL31cblx0XHRcdFx0XHRcdFx0XHR7ICghYWJvdmVUaHJlc2hvbGQpID9cblx0XHRcdFx0XHRcdFx0XHRcdFJhc3RlclN0b3JlLmdldE1hcHNMaXN0KCkubWFwKChpdGVtLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoKGl0ZW0ucmFkaWkpID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhpdGVtLnJhZGlpKS5tYXAoKGdyYWRlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKGl0ZW0ucmFkaWlbZ3JhZGVdLmlubmVyID09IDApID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PENpcmNsZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNlbnRlcj17IFtpdGVtLmNlbnRlckxhdCwgaXRlbS5jZW50ZXJMbmddIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyYWRpdXM9eyBpdGVtLnJhZGlpW2dyYWRlXS5vdXRlciB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ9eyBpdGVtLmNpdHlJZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMub25DaXR5TWFya2VyU2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdjbGlja2FibGVEb251dCcgKyBpdGVtLmNpdHlJZCArIGdyYWRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnc2ltcGxlRG9udXQgZ3JhZGVfJyArIGdyYWRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lz4gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8RG9udXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjZW50ZXI9eyBbaXRlbS5jZW50ZXJMYXQsIGl0ZW0uY2VudGVyTG5nXSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5uZXJSYWRpdXM9eyBpdGVtLnJhZGlpW2dyYWRlXS5pbm5lciB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJSYWRpdXM9eyBpdGVtLnJhZGlpW2dyYWRlXS5vdXRlciB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ9eyBpdGVtLmNpdHlJZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMub25DaXR5TWFya2VyU2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17ICdjbGlja2FibGVEb251dCcgKyBpdGVtLmNpdHlJZCArIGdyYWRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnc2ltcGxlRG9udXQgZ3JhZGVfJyArIGdyYWRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCFpdGVtLnBhcmVudF9pZCkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PENpcmNsZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjZW50ZXI9eyBbaXRlbS5jZW50ZXJMYXQsIGl0ZW0uY2VudGVyTG5nXSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJhZGl1cz17IDI1MDAwIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ9eyBpdGVtLmNpdHlJZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLm9uQ2l0eU1hcmtlclNlbGVjdGVkIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2NsaWNrYWJsZU1hcCcgKyBpdGVtLmNpdHlJZCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17ICdjaXR5Q2lyY2xlICd9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPiA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0ey8qIG1hcmtlciBmb3IgdXNlcidzIGxvY2F0aW9uICovfVxuXHRcdFx0XHRcdFx0XHRcdHsgKHRoaXMuc3RhdGUudXNlckxvY2F0aW9uKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHQ8TWFya2VyIHBvc2l0aW9uPXsgdGhpcy5zdGF0ZS51c2VyTG9jYXRpb24gfSAvPiA6XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0PExlZ2VuZCB7IC4uLmxlZ2VuZERhdGEgfSBvbkl0ZW1TZWxlY3RlZD17IHRoaXMub25HcmFkZUhvdmVyIH0gLz5cblxuXG5cdFx0XHRcdFx0XHRcdDwvTWFwPlxuXG5cdFx0XHRcdFx0XHRcdHsgVGV4dHNTdG9yZS5tYWluTW9kYWxJc09wZW4oKSA/XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2xvbmdpc2hmb3JtJz5cblx0XHRcdFx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPSdjbG9zZScgb25DbGljaz17IHRoaXMub25Nb2RhbENsaWNrIH0+PHNwYW4+w5c8L3NwYW4+PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nY29udGVudCcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9eyBUZXh0c1N0b3JlLmdldE1vZGFsQ29udGVudCgpIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj4gOlxuXHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdvcGFjaXR5U2xpZGVyJz5cblx0XHRcdFx0XHRcdDxTbGlkZXIgXG5cdFx0XHRcdFx0XHRcdHZlcnRpY2FsPXsgdHJ1ZSB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17IHRoaXMuc3RhdGUucmFzdGVyLm9wYWNpdHkgKiAxMDAgfVxuXHRcdFx0XHRcdFx0XHRvbkFmdGVyQ2hhbmdlPXsgdGhpcy5vblNsaWRlckNoYW5nZSB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbHVtbnMgZm91ciBmdWxsLWhlaWdodCc+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ncm93IHRlbXBsYXRlLXRpbGUgY2l0eS1zZWxlY3Rvcicgc3R5bGU9e3toZWlnaHQ6IHRoaXMuc3RhdGUuZGltZW5zaW9ucy5zZWFyY2guaGVpZ2h0ICsgJ3B4Jywgd2lkdGg6IHRoaXMuc3RhdGUuZGltZW5zaW9ucy5zZWFyY2gud2lkdGggKyAncHgnfX0+XG5cdFx0XHRcdFx0XHRcdDxUeXBlYWhlYWRcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgUmFzdGVyU3RvcmUuZ2V0TWFwc0xpc3QoKSB9XG5cdFx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyAnU2VhcmNoIGJ5IGNpdHkgb3Igc3RhdGUnIH1cblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJPcHRpb249eyAnc2VhcmNoTmFtZScgfVxuXHRcdFx0XHRcdFx0XHRcdGRpc3BsYXlPcHRpb249eyhjaXR5LCBpKSA9PiBjaXR5LmNpdHlJZCB9XG5cdFx0XHRcdFx0XHRcdFx0b25PcHRpb25TZWxlY3RlZD17IHRoaXMub25DaXR5U2VsZWN0ZWQgfVxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUxpc3RDb21wb25lbnQ9eyBUeXBlQWhlYWRDaXR5U25pcHBldCB9XG5cdFx0XHRcdFx0XHRcdFx0bWF4VmlzaWJsZT17IDggfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ncm93IGZ1bGwtaGVpZ2h0IHRlbXBsYXRlLXRpbGUgZGF0YVZpZXdlcicgc3R5bGU9e3toZWlnaHQ6IHRoaXMuc3RhdGUuZGltZW5zaW9ucy5ib3R0b20uaGVpZ2h0ICsgJ3B4J319PlxuXHRcdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2lkZWJhcigpIH1cblxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0PE1vZGFsIFxuXHRcdFx0XHRcdFx0aXNPcGVuPXsgZmFsc2UgfVxuXHRcdFx0XHRcdFx0Ly8gaXNPcGVuPXsgVGV4dHNTdG9yZS5tYWluTW9kYWxJc09wZW4oKSB9IFxuXHRcdFx0XHRcdFx0c3R5bGU9eyBtb2RhbFN0eWxlIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT0nY2xvc2UnIG9uQ2xpY2s9eyB0aGlzLm9uTW9kYWxDbGljayB9PjxzcGFuPsOXPC9zcGFuPjwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0PGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17IFRleHRzU3RvcmUuZ2V0TW9kYWxDb250ZW50KCkgfT48L2Rpdj5cblx0XHRcdFx0XHQ8L01vZGFsPlxuXG5cdFx0XHRcdFx0PE1vZGFsIFxuXHRcdFx0XHRcdFx0aXNPcGVuPXsgVXNlckxvY2F0aW9uU3RvcmUuZ2V0T2ZmZXJab29tVG8oKSB9IFxuXHRcdFx0XHRcdFx0c3R5bGU9eyBtb2RhbFN0eWxlIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8cD5Xb3VsZCB5b3UgbGlrZSB0byB6b29tIHRvIHsgVXNlckxvY2F0aW9uU3RvcmUuZ2V0Q2l0eSgpIH0/PC9wPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXsgdGhpcy5vblVzZXJDaXR5UmVzcG9uc2UgfSB2YWx1ZT17ICd5ZXMnIH0+U3VyZTwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXsgdGhpcy5vblVzZXJDaXR5UmVzcG9uc2UgfSB2YWx1ZT17ICdubycgfT5ObyB0aGFua3M8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L01vZGFsPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PiBcblx0XHQpO1xuXG5cdH1cbn0iLCJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQURDYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRcblx0fTtcblxuXHQvLyAoaW5zdGVhZCBvZiBFUzUtc3R5bGUgZ2V0RGVmYXVsdFByb3BzKVxuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNhdE51bTogdW5kZWZpbmVkLFxuXHRcdGNhdExldHRlcjogdW5kZWZpbmVkXG5cdH07XG5cblx0Y29uc3RydWN0b3IgKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvLyBiaW5kIGhhbmRsZXJzXG5cdFx0bGV0IGhhbmRsZXJzID0gWydyZW5kZXIxOTM3MDgyNl81YycsICdyZW5kZXIxOTM3MDgyNl81YycsICdyZW5kZXIxOTM3MDIwM181ZCcsICdyZW5kZXIxOTM3MDgyNl81ZCcsICdyZW5kZXIxOTM3MDgyNl81ZycsICdyZW5kZXIxOTM3MDIwM181ZycsJ3JlbmRlcjE5MzcwMjAzXzhhJywncmVuZGVyMTkzNzA4MjZfOGEnLCdyZW5kZXIxOTM3MDIwM184YicsJ3JlbmRlcjE5MzcwODI2XzhiJywncmVuZGVyMTkzNzAyMDNfOGMnLCdyZW5kZXIxOTM3MDgyNl84YyddO1xuXHRcdGhhbmRsZXJzLm1hcChoYW5kbGVyID0+IHsgdGhpc1toYW5kbGVyXSA9IHRoaXNbaGFuZGxlcl0uYmluZCh0aGlzKTsgfSk7XG5cdH1cblxuXHRzaG91bGRDb21wb25lbnRVcGRhdGUgKG5leHRQcm9wcykge1xuXHRcdHJldHVybiAobmV4dFByb3BzLmNhdE51bSAhPT0gdGhpcy5wcm9wcy5jYXROdW0gfHwgbmV4dFByb3BzLmNhdExldHRlciAhPT0gdGhpcy5wcm9wcy5jYXRMZXR0ZXIgfHwgbmV4dFByb3BzLmNpdHlJZCAhPT0gdGhpcy5wcm9wcy5jaXR5SWQpXG5cdH1cblxuXHQvKiBhbHBoYW51bS5qcyAoQykgQnJpYW4gSHVpc21hblxuXHQqIEJhc2VkIG9uIHRoZSBBbHBoYW51bSBBbGdvcml0aG0gYnkgRGF2aWQgS29lbGxlXG5cdCogVGhlIEFscGhhbnVtIEFsZ29yaXRobSBpcyBkaXNjdXNzZWQgYXQgaHR0cDovL3d3dy5EYXZlS29lbGxlLmNvbVxuXHQqXG5cdCogRGlzdHJpYnV0ZWQgdW5kZXIgc2FtZSBsaWNlbnNlIGFzIG9yaWdpbmFsXG5cdCogXG5cdCogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuXHQqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcblx0KiBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcblx0KiB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgYW55IGxhdGVyIHZlcnNpb24uXG5cdCogXG5cdCogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5cdCogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcblx0KiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuXHQqIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cdCogXG5cdCogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuXHQqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcblx0KiBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BICAwMjExMC0xMzAxICBVU0Fcblx0Ki9cblx0YWxwaGFudW1DYXNlIChhLCBiKSB7XG5cdFx0ZnVuY3Rpb24gY2h1bmtpZnkodCkge1xuXHRcdFx0dmFyIHR6ID0gbmV3IEFycmF5KCk7XG5cdFx0XHR2YXIgeCA9IDAsIHkgPSAtMSwgbiA9IDAsIGksIGo7XG5cdFx0XHR3aGlsZSAoaSA9IChqID0gdC5jaGFyQXQoeCsrKSkuY2hhckNvZGVBdCgwKSkge1xuXHRcdFx0XHR2YXIgbSA9IChpID09IDQ2IHx8IChpID49NDggJiYgaSA8PSA1NykpO1xuXHRcdFx0XHRpZiAobSAhPT0gbikge1xuXHRcdFx0XHRcdHR6WysreV0gPSAnJztcblx0XHRcdFx0XHRuID0gbTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0elt5XSArPSBqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHR6O1xuXHRcdH1cblxuXHRcdHZhciBhYSA9IGNodW5raWZ5KGEudG9Mb3dlckNhc2UoKSk7XG5cdFx0dmFyIGJiID0gY2h1bmtpZnkoYi50b0xvd2VyQ2FzZSgpKTtcdFx0XG5cdFx0Zm9yIChsZXQgeCA9IDA7IGFhW3hdICYmIGJiW3hdOyB4KyspIHtcblx0XHRcdGlmIChhYVt4XSAhPT0gYmJbeF0pIHtcblx0XHRcdFx0dmFyIGMgPSBOdW1iZXIoYWFbeF0pLCBkID0gTnVtYmVyKGJiW3hdKTtcblx0XHRcdFx0aWYgKGMgPT0gYWFbeF0gJiYgZCA9PSBiYlt4XSkge1xuXHRcdFx0XHRcdHJldHVybiBjIC0gZDtcblx0XHRcdFx0fSBlbHNlIHJldHVybiAoYWFbeF0gPiBiYlt4XSkgPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhYS5sZW5ndGggLSBiYi5sZW5ndGg7XG5cdH1cblxuXHRnZXRDYXRlZ29yeVN0cmluZyAoY2F0TnVtLCBjYXRMZXR0ZXIpIHtcblx0XHRyZXR1cm4gY2F0TnVtICsgKChjYXRMZXR0ZXIpID8gJy0nICsgY2F0TGV0dGVyIDogJycpO1xuXHR9XG5cblx0cmVuZGVyR3JhZGUoZ3JhZGUpIHtcblx0XHRsZXQgaWRpb3N5bmNyYXRpY0Rpc3BsYXkgPSB0aGlzWydyZW5kZXInICsgdGhpcy5wcm9wcy5mb3JtSWQgKyAnXycgKyB0aGlzLnByb3BzLmNhdE51bSArICgodGhpcy5wcm9wcy5jYXRMZXR0ZXIpID8gdGhpcy5wcm9wcy5jYXRMZXR0ZXIgOiAnJyldLFxuXHRcdFx0Y2F0ZWdvcnlEYXRhID0gdGhpcy5wcm9wcy5BRHNCeUNhdDtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eydncmFkZS1oZWFkZXInICsgZ3JhZGV9PjxoMj57IGdyYWRlIH08L2gyPjwvZGl2PlxuXHRcdFx0XHQ8dWwgY2xhc3NOYW1lPSdhcmVhX2Rlc2NyaXB0aW9uJyByZWY9eyAnY2F0JyArIGdyYWRlIH0+XG5cdFx0XHRcdFx0eyBPYmplY3Qua2V5cyhjYXRlZ29yeURhdGEpLnNvcnQodGhpcy5hbHBoYW51bUNhc2UpLm1hcChuZWlnaGJvcmhvb2RJZCA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoZ3JhZGUgPT0gbmVpZ2hib3Job29kSWQuY2hhckF0KDApKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0PGxpIFxuXHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgJ2NhdCcgKyBncmFkZSArIG5laWdoYm9yaG9vZElkIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbk5laWdoYm9yaG9vZENsaWNrIH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRvbk1vdXNlRW50ZXI9eyB0aGlzLnByb3BzLm9uTmVpZ2hib3Job29kSG92ZXIgfSBcblx0XHRcdFx0XHRcdFx0XHRcdG9uTW91c2VMZWF2ZT17IHRoaXMucHJvcHMub25OZWlnaGJvcmhvb2RPdXQgfSBcblx0XHRcdFx0XHRcdFx0XHRcdGlkPXsgbmVpZ2hib3Job29kSWQgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZScgaWQ9eyBuZWlnaGJvcmhvb2RJZCB9PnsgbmVpZ2hib3Job29kSWQgfTwvc3Bhbj46IFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAodHlwZW9mKGlkaW9zeW5jcmF0aWNEaXNwbGF5KSA9PT0gJ2Z1bmN0aW9uJykgPyBpZGlvc3luY3JhdGljRGlzcGxheShjYXRlZ29yeURhdGFbbmVpZ2hib3Job29kSWRdKSA6IHRoaXMucmVuZGVyRGF0dW0oY2F0ZWdvcnlEYXRhW25laWdoYm9yaG9vZElkXSkgfVxuXHRcdFx0XHRcdFx0XHRcdDwvbGk+XG5cblxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pfVxuXHRcdFx0XHQ8L3VsPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlckRhdHVtKGRhdHVtLCBuZWlnaGJvcmhvb2RJZCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c3Bhbj57IChkYXR1bSkgPyA8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgZGF0dW0gfTwvc3Bhbj4gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyMTkzNzAyMDNfNWMoZGF0YSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c3Bhbj5cblx0XHRcdFx0eyB0aGlzLnJlbmRlckRhdHVtKGRhdGFbMV0pfTsgeyB0aGlzLnJlbmRlckRhdHVtKGRhdGFbMl0pfVxuXHRcdFx0PC9zcGFuPlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIxOTM3MDgyNl81YyA9IHRoaXMucmVuZGVyMTkzNzAyMDNfNWM7XG5cdHJlbmRlcjE5MzcwMjAzXzVkID0gdGhpcy5yZW5kZXIxOTM3MDIwM181Yztcblx0cmVuZGVyMTkzNzA4MjZfNWQgPSB0aGlzLnJlbmRlcjE5MzcwMjAzXzVjO1xuXG5cdHJlbmRlcjE5MzcwMjAzXzVnKGRhdGEpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PHNwYW4+XG5cdFx0XHRcdFBvcHVsYXRpb24gaXMgaW5jcmVhc2luZyB7IHRoaXMucmVuZGVyRGF0dW0oZGF0YVsxXSl9OyBkZWNyZWFzaW5nIHsgdGhpcy5yZW5kZXJEYXR1bShkYXRhWzJdKX07IHN0YXRpYy5cblx0XHRcdDwvc3Bhbj5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyMTkzNzA4MjZfNWcgPSB0aGlzLnJlbmRlcjE5MzcwMjAzXzVnO1xuXG5cdHJlbmRlcjE5MzcwMjAzXzhhKGRhdGEpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PHNwYW4+eyB0aGlzLnJlbmRlckRhdHVtKGRhdGEpIH0lPC9zcGFuPlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIxOTM3MDgyNl84YSA9IHRoaXMucmVuZGVyMTkzNzAyMDNfOGE7XG5cdHJlbmRlcjE5MzcwMjAzXzhiID0gdGhpcy5yZW5kZXIxOTM3MDIwM184YTtcblx0cmVuZGVyMTkzNzA4MjZfOGIgPSB0aGlzLnJlbmRlcjE5MzcwMjAzXzhhO1xuXHRyZW5kZXIxOTM3MDIwM184YyA9IHRoaXMucmVuZGVyMTkzNzAyMDNfOGE7XG5cdHJlbmRlcjE5MzcwODI2XzhjID0gdGhpcy5yZW5kZXIxOTM3MDIwM184YTtcblxuXHRyZW5kZXIgKCkge1xuXG5cdFx0bGV0IHByZXZpb3VzQ2F0ID0gdGhpcy5wcm9wcy5wcmV2aW91c0NhdElkcyxcblx0XHRcdG5leHRDYXQgPSB0aGlzLnByb3BzLm5leHRDYXRJZHM7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J2FkLXNlbGVjdGlvbic+XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0PHVsIGNsYXNzTmFtZT0nYWRfY2F0Jz5cblx0XHRcdFx0XHQ8bGk+eyAocHJldmlvdXNDYXQpID88c3BhbiBjbGFzc05hbWU9J2xlZnQtYXJyb3cnIG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2F0ZWdvcnlDbGljayB9IGlkPXsgdGhpcy5nZXRDYXRlZ29yeVN0cmluZyguLi5wcmV2aW91c0NhdCkgfT48L3NwYW4+IDogJycgfTwvbGk+XG5cdFx0XHRcdFx0PGxpPnsgKHByZXZpb3VzQ2F0KSA/IDxzcGFuIGNsYXNzTmFtZT0nYWQtbGVmdCcgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9eyB0aGlzLmdldENhdGVnb3J5U3RyaW5nKC4uLnByZXZpb3VzQ2F0KSB9PnsgKHByZXZpb3VzQ2F0WzFdKSA/IHByZXZpb3VzQ2F0WzBdICsgcHJldmlvdXNDYXRbMV0gOiBwcmV2aW91c0NhdFswXSB9PC9zcGFuPiA6ICcnIH08L2xpPlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdDxsaT57IChuZXh0Q2F0KSA/PHNwYW4gY2xhc3NOYW1lPSdyaWdodC1hcnJvdycgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9eyB0aGlzLmdldENhdGVnb3J5U3RyaW5nKC4uLm5leHRDYXQpIH0+PC9zcGFuPiA6ICcnIH08L2xpPlxuXHRcdFx0XHRcdDxsaT57IChuZXh0Q2F0KSA/ICA8c3BhbiBjbGFzc05hbWU9J2FkLXJpZ2h0JyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD17IHRoaXMuZ2V0Q2F0ZWdvcnlTdHJpbmcoLi4ubmV4dENhdCkgfT57IChuZXh0Q2F0WzFdKSA/IG5leHRDYXRbMF0gKyBuZXh0Q2F0WzFdIDogbmV4dENhdFswXSB9PC9zcGFuPiA6ICcnIH08L2xpPlxuXHRcdFx0XHRcdDxsaT48aDQ+eyB0aGlzLnByb3BzLnRpdGxlIH08L2g0PjwvbGk+XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdDwvdWw+XG5cblx0XHRcdFx0eyB0aGlzLnJlbmRlckdyYWRlKCdBJykgfVxuXHRcdFx0XHR7IHRoaXMucmVuZGVyR3JhZGUoJ0InKSB9XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJHcmFkZSgnQycpIH1cblx0XHRcdFx0eyB0aGlzLnJlbmRlckdyYWRlKCdEJykgfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG59IiwiXG5pbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJlYURlc2NyaXB0aW9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuXHQvLyBwcm9wZXJ0eSB2YWxpZGF0aW9uXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0YXJlYURlc2NyaXB0aW9uczogUHJvcFR5cGVzLm9iamVjdFxuXHR9O1xuXG5cdC8vIChpbnN0ZWFkIG9mIEVTNS1zdHlsZSBnZXREZWZhdWx0UHJvcHMpXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0YXJlYURlc2NyaXB0aW9uczoge31cblx0fTtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG5cdFx0cmV0dXJuIChuZXh0UHJvcHMuYXJlYUlkICE9PSB0aGlzLnByb3BzLmFyZWFJZCB8fCBuZXh0UHJvcHMuY2l0eUlkICE9PSB0aGlzLnByb3BzLmNpdHlJZCk7XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXG5cdFx0LyogaWYgKHR5cGVvZih0aGlzLnByb3BzLmFyZWFEYXRhKSA9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YodGhpcy5wcm9wcy5hcmVhRGF0YS5hcmVhRGVzYykgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9ICovXG5cblxuXG5cdFx0cmV0dXJuIChcblxuXHRcdFx0PGRpdj5cblx0XHRcdFx0PHVsIGNsYXNzTmFtZT0nYWQtc2VsZWN0aW9uJz5cblx0XHRcdFx0XHR7ICh0aGlzLnByb3BzLnByZXZpb3VzQXJlYUlkKSA/IFxuXHRcdFx0XHRcdFx0PGxpIG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uSE9MQ0lEQ2xpY2sgfSBpZD17IHRoaXMucHJvcHMucHJldmlvdXNBcmVhSWQgfSBjbGFzc05hbWU9J2FkLWxlZnQnID57ICc8JyArIHRoaXMucHJvcHMucHJldmlvdXNBcmVhSWQgfVxuXHRcdFx0XHRcdFx0PC9saT4gOiBcblx0XHRcdFx0XHRcdCcnIFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7ICh0aGlzLnByb3BzLm5leHRBcmVhSWQpID8gXG5cdFx0XHRcdFx0XHQ8bGkgb25DbGljaz17IHRoaXMucHJvcHMub25IT0xDSURDbGljayB9IGlkPXsgdGhpcy5wcm9wcy5uZXh0QXJlYUlkIH0gY2xhc3NOYW1lPSdhZC1yaWdodCcgPnsgdGhpcy5wcm9wcy5uZXh0QXJlYUlkICsgJz4nIH1cblx0XHRcdFx0XHRcdDwvbGk+IDogXG5cdFx0XHRcdFx0XHQnJyBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PGxpPjxoND57IHRoaXMucHJvcHMuYXJlYUlkIH08L2g0PjwvbGk+XG5cdFx0XHRcdDwvdWw+XG5cdFx0XG5cdFx0XHRcdHsgKFsxOTM3MDIwMywxOTM3MDgyNl0uaW5kZXhPZihwYXJzZUludCh0aGlzLnByb3BzLmZvcm1JZCkpID49IDApID8gdGhpcy5yZW5kZXJOU0Zvcm04XzE5MzcwMjAzKCkgOlxuXHRcdFx0XHQgIChwYXJzZUludCh0aGlzLnByb3BzLmZvcm1JZCkgPT0gMTkzNzEwMDEpID8gdGhpcy5yZW5kZXJOU0Zvcm04XzE5MzcxMDAxKCkgOlxuXHRcdFx0XHQgIG51bGxcblx0XHRcdFx0fVxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXG5cblx0fVxuXG5cblx0cmVuZGVyTlNGb3JtOF8xOTM3MDIwMygpIHtcblx0XHRsZXQgQUQgPSB0aGlzLnByb3BzLmFyZWFEZXNjcmlwdGlvbnM7XG5cblx0XHRyZXR1cm4gKFxuXG5cdFx0XHQ8dWwgY2xhc3NOYW1lPSdhcmVhX2Rlc2NyaXB0aW9uIE5TRm9ybTgnPlxuXG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+MTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPk5hbWUgb2YgQ2l0eTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzFdICYmIEFEWzFdWzFdICkgPyBBRFsxXVsxXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XHRcdFx0XHRcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUgaW5kZW50Jz4gU2VjdXJpdHkgR3JhZGUgPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbMV0gJiYgQURbMV1bMl0gKSA/IEFEWzFdWzJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUgaW5kZW50Jz4gQXJlYSBOby4gPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbMV0gJiYgQURbMV1bM10gKSA/IEFEWzFdWzNdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVDYXRlZ29yeSgyLCAnRGVzY3JpcHRpb24gb2YgVGVycmFpbicpIH1cblx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZUNhdGVnb3J5KDMsICdGYXZvcmFibGUgSW5mbHVlbmNlcycpIH1cblx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZUNhdGVnb3J5KDQsICdEZXRyaW1lbnRhbCBJbmZsdWVuY2VzJykgfVxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjU8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5JbmhhYml0YW50czwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNSwgJ2EnLCAnVHlwZScpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg1LCAnYicsICdFc3RpbWF0ZWQgYW5udWFsIGZhbWlseSBpbmNvbWUnKSB9XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyIGNhdFNlbGVjdGFibGUnIG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2F0ZWdvcnlDbGljayB9IGlkPSc1LWMnPmM8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD0nNS1jJz5Gb3JlaWduLWJvcm48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbNV0gJiYgQURbNV1bJ2MnXVsnMSddICkgPyBBRFs1XVsnYyddWycxJ10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTsgeyAoQURbNV0gJiYgQURbNV1bJ2MnXVsnMiddICkgPyBBRFs1XVsnYyddWycyJ10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyIGNhdFNlbGVjdGFibGUnIG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2F0ZWdvcnlDbGljayB9IGlkPSc1LWQnPmQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD0nNS1kJz5OZWdybzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs1XSAmJiBBRFs1XVsnZCddWycxJ10gKSA/IEFEWzVdWydkJ11bJzEnXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9OyB7IChBRFs1XSAmJiBBRFs1XVsnZCddWycyJ10gKSA/IEFEWzVdWydkJ11bJzInXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg1LCAnZScsICdJbmZpbHRyYXRpb24gb2YnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNSwgJ2YnLCAnUmVsaWVmIGZhbWlsaWVzJykgfVxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlciBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD0nNS1nJz5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUgY2F0U2VsZWN0YWJsZScgb25DbGljaz17IHRoaXMucHJvcHMub25DYXRlZ29yeUNsaWNrIH0gaWQ9JzUtZyc+UG9wdWxhdGlvbiBpcyBpbmNyZWFzaW5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzVdICYmIEFEWzVdWydnJ11bJzEnXSApID8gQURbNV1bJ2cnXVsnMSddIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSc+OyBkZWNyZWFzaW5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzVdICYmIEFEWzVdWydnJ11bJzInXSApID8gQURbNV1bJ2cnXVsnMiddIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+OyBcblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXROYW1lJz47IHN0YXRpYzwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjY8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5CdWlsZGluZ3M8L3NwYW4+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDYsICdhJywgJ1R5cGUgb3IgVHlwZXMnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNiwgJ2InLCAnVHlwZSBvZiBjb25zdHJ1Y3Rpb24nKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNiwgJ2MnLCAnQXZlcmFnZSBhZ2UnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoNiwgJ2QnLCAnUmVwYWlyJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+Nzwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkhpc3Rvcnk8L3NwYW4+XG5cdFx0XHRcdFx0PHRhYmxlPlxuXHRcdFx0XHRcdFx0PHRoZWFkPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlNhbGVzIFZhbHVlczwvdGg+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+WWVhcjwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlJhbmdlPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+UHJlZG9taW5hdGluZzwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPiU8L3RoPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0PC90aGVhZD5cblx0XHRcdFx0XHRcdDx0Ym9keT5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD4xOTI5IGxldmVsPC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMV0gKSA/IEFEWzddWzFdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsyXSApID8gQURbN11bMl0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjEwMCU8L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPnsgQURbN11bNV0gfSBsZXZlbDwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzZdICkgPyBBRFs3XVs2XSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bN10gKSA/IEFEWzddWzddIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVs4XSApID8gQURbN11bOF0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+eyBBRFs3XVsxMl0gfSAgbGV2ZWw8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsxM10gKSA/IEFEWzddWzEzXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMTRdICkgPyBBRFs3XVsxNF0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzE1XSApID8gQURbN11bMTVdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0PC90Ym9keT5cblx0XHRcdFx0XHQ8L3RhYmxlPlxuXG5cdFx0XHRcdFx0PHRhYmxlPlxuXHRcdFx0XHRcdFx0PHRoZWFkPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlJlbnRhbCBWYWx1ZXM8L3RoPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlllYXI8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5SYW5nZTwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPlByZWRvbWluYXRpbmc8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD4lPC90aD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdDwvdGhlYWQ+XG5cdFx0XHRcdFx0XHQ8dGJvZHk+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+MTkyOSBsZXZlbDwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzNdICkgPyBBRFs3XVszXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bNF0gKSA/IEFEWzddWzRdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD4xMDAlPC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD57IChBRFs3XSAmJiBBRFs3XVs1XSApID8gQURbN11bNV0gOiAnJ30gbGV2ZWw8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVs5XSApID8gQURbN11bOV0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzEwXSApID8gQURbN11bMTBdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsxMV0gKSA/IEFEWzddWzExXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD57IEFEWzddWzEyXSB9ICBsZXZlbDwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgKEFEWzddICYmIEFEWzddWzE2XSApID8gQURbN11bMTZdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IChBRFs3XSAmJiBBRFs3XVsxN10gKSA/IEFEWzddWzE3XSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyAoQURbN10gJiYgQURbN11bMThdICkgPyBBRFs3XVsxOF0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHQ8L3Rib2R5PlxuXHRcdFx0XHRcdDwvdGFibGU+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J3BlcmNlbnRhZ2UnPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXROYW1lJz5QZWFrIFNhbGVzIHZhbHVlcyBvY2N1cnJlZCBpbjwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbN10gJiYgQURbN11bMTldICkgPyBBRFs3XVsxOV0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSc+IGFuZCB3ZXJlIDwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbN10gJiYgQURbN11bMjBdICkgPyBBRFs3XVsyMF0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSc+JSBvZiB0aGUgMTkyOSBsZXZlbC48L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J3BlcmNlbnRhZ2UnPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXROYW1lJz5QZWFrIHJlbnRhbCB2YWx1ZXMgb2NjdXJyZWQgaW48L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzddICYmIEFEWzddWzIxXSApID8gQURbN11bMjFdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnPiBhbmQgd2VyZSA8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzddICYmIEFEWzddWzIyXSApID8gQURbN11bMjJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdE5hbWUnPiUgb2YgdGhlIDE5MjkgbGV2ZWwuPC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjg8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5PY2N1cGFuY3k8L3NwYW4+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDgsICdhJywgJ0xhbmQnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoOCwgJ2InLCAnRHdlbGxpbmcgdW5pdHMnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoOCwgJ2MnLCAnSG9tZSBPd25lcnMnKSB9XG5cdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz45PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+U2FsZXMgRGVtYW5kPC9zcGFuPlxuXHRcdFx0XHRcdDx1bD5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg5LCAnYScsICcnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoOSwgJ2InLCAnJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDksICdjJywgJ0FjdGl2aXR5IGlzJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+MTA8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5SZW50YWwgRGVtYW5kPC9zcGFuPlxuXHRcdFx0XHRcdDx1bD5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxMCwgJ2EnLCAnJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDEwLCAnYicsICcnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMTAsICdjJywgJ0FjdGl2aXR5IGlzJykgfVxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+MTE8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5OZXcgQ29uc3RydWN0aW9uPC9zcGFuPlxuXHRcdFx0XHRcdDx1bD5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxMSwgJ2EnLCAnVHlwZXMnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMTEsICdiJywgJ0Ftb3VudCBsYXN0IHllYXInKSB9XG5cdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz4xMjwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkF2YWlsYWJpbGl0eSBvZiBNb3J0Z2FnZSBGdW5kczwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMTIsICdhJywgJ0hvbWUgcHVyY2hhc2UnKSB9XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMTIsICdiJywgJ0hvbWUgYnVpbGRpbmcnKSB9XG5cdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZUNhdGVnb3J5KDEzLCAnVHJlbmQgb2YgRGVzaXJlYWJpbGl0eSBOZXh0IDEwLTE1IFllYXJzJykgfVxuXHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlQ2F0ZWdvcnkoMTQsICdDbGFyaWZ5aW5nIFJlbWFya3MnKSB9XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+MTU8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5JbmZvcm1hdGlvbiBmb3IgdGhpcyBmb3JtIHdhcyBvYnRhaW5lZCBmcm9tPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbMTVdICAmJiB0eXBlb2YoQURbMTVdKSA9PSAnc3RyaW5nJyApID8gQURbMTVdIDogKEFEWzE1XSAmJiBBRFsxNV1bMV0pID8gQURbMTVdWzFdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdHsgKHR5cGVvZihBRFsxNV0pID09PSAnb2JqZWN0JykgP1xuXHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSBpbmRlbnQnPkRhdGU8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzE1XSAmJiBBRFsxNV1bMl0gKSA/IEFEWzE1XVsyXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lIGluZGVudCc+MTkzPC9zcGFuPjxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbMTVdICYmIEFEWzE1XVszXSApID8gQURbMTVdWzNdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0PC9saT4gOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdH1cblx0XHRcdDwvdWw+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlck5TRm9ybThfMTkzNzEwMDEoKSB7XG5cdFx0bGV0IEFEID0gdGhpcy5wcm9wcy5hcmVhRGVzY3JpcHRpb25zO1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8dWwgY2xhc3NOYW1lPSdhcmVhX2Rlc2NyaXB0aW9uIE5TRm9ybTgnPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjE8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5BcmVhIENoYXJhY3RlcmlzdGljczwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMSwgJ2EnLCAnRGVzY3JpcHRpb24gb2YgVGVycmFpbicpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxLCAnYicsICdGYXZvcmFibGUgSW5mbHVlbmNlcycpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxLCAnYycsICdEZXRyaW1lbnRhbCBJbmZsdWVuY2VzJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDEsICdkJywgJ1BlcmNlbnRhZ2Ugb2YgbGFuZCBpbXByb3ZlZCcpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgxLCAnZScsICdUcmVuZCBvZiBkZXNpcmVhYmlsaXR5IG5leHQgMTAtMTUgeXJzLicpIH1cblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROdW0nPjI8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5JbmhhYml0YW50czwvc3Bhbj5cblx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHR7IHRoaXMucmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoMiwgJ2EnLCAnT2NjdXBhdGlvbicpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgyLCAnYicsICdFc3RpbWF0ZWQgQW5udWFsIEZhbWlseSBJbmNvbWUnKSB9XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5jPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkZvcmVpZ24tYm9ybiBmYW1pbGllczwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgyLCAnYycsIDEpIH08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTs8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDIsICdjJywgMikgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4gIHByZWRvbWluYXRpbmc8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+ZDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5OZWdybzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgyLCAnZCcsIDEpIH08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTs8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+IHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDIsICdkJywgMikgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4gIHByZWRvbWluYXRpbmc8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDIsICdlJywgJ0luZmlsdHJhdGlvbiBvZicpIH1cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSgyLCAnZicsICdSZWxpZWYgZmFtaWxpZXMnKSB9XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlBvcHVsYXRpb24gaXMgaW5jcmVhc2luZzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz4geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMiwgJ2cnLCAxKSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjsgZGVjcmVhc2luZzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz4geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMiwgJ2cnLCAyKSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjsgc3RhdGljPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPiB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgyLCAnZycsIDMpIH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdDwvdWw+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+Mzwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkJ1aWxkaW5nczwvc3Bhbj5cblx0XHRcdFx0XHQ8dGFibGU+XG5cdFx0XHRcdFx0XHQ8dGhlYWQ+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+PC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGg+UHJlZG9taW5hdGluZyB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCBudWxsLCAxKSB9JTwvdGg+XG5cdFx0XHRcdFx0XHRcdFx0PHRoPk90aGVyIFR5cGUgeyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgbnVsbCwgMikgfSU8L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aD5PdGhlciBUeXBlIHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsIG51bGwsIDMpIH0lPC90aD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdDwvdGhlYWQ+XG5cdFx0XHRcdFx0XHQ8dGJvZHk+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+YTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+VHlwZTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYScsIDEpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYScsIDIpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYScsIDMpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmI8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkNvbnN0cnVjdGlvbjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYicsIDEpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYicsIDIpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnYicsIDMpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmM8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPkF2ZXJhZ2UgYWdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdjJywgMSkgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlllYXJzPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdjJywgMikgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlllYXJzPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdjJywgMykgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPlllYXJzPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+ZDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+UmVwYWlyPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdkJywgMSkgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdkJywgMikgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdkJywgMykgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+ZTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+T2NjdXBhbmN5PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdlJywgMSkgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZScsIDIpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2UnLCAzKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+Zjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+SG9tZSBPd25lcnNoaXA8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2YnLCAxKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdmJywgMikgfTxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZicsIDMpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5nPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5Db25zdHJ1Y3RlZCBwYXN0IHlyLjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZycsIDEpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZycsIDIpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnZycsIDMpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPmg8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjE5MjkgUHJpY2UgcmFuZ2U8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdoJywgMSkgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdoJywgMikgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdoJywgMykgfSA8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5pPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDEpIH0gUHJpY2UgcmFuZ2U8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdpJywgMikgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDMpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdpJywgNCkgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDUpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdpJywgNikgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaScsIDcpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5qPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDEpIH0gUHJpY2UgcmFuZ2U8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdqJywgMikgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDMpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdqJywgNCkgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDUpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdqJywgNikgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnaicsIDcpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5rPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5TYWxlcyBkZW1hbmQgVXAgdG88L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2snLCAxKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+VXAgdG8geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2snLCAyKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ2snLCAzKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5sPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5BY3Rpdml0eTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbCcsIDEpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbCcsIDIpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbCcsIDMpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPm08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjE5MjkgUmVudCByYW5nZTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD48c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiQ8L3NwYW4+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ20nLCAxKSB9IDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+MTAwJTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD48c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiQ8L3NwYW4+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ20nLCAyKSB9IDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+MTAwJTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD48c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiQ8L3NwYW4+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ20nLCAzKSB9IDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+MTAwJTwvc3Bhbj48L3RkPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXRMZXR0ZXInPm48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICduJywgMSkgfSBSZW50IHJhbmdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbicsIDIpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ24nLCAzKSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4xMDAlPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbicsIDQpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ24nLCA1KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPjxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+JDwvc3Bhbj57IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbicsIDYpIH0geyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ24nLCA3KSB9PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4lPC9zcGFuPjwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+bzwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ28nLCAxKSB9IFJlbnQgcmFuZ2U8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdvJywgMikgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbycsIDMpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPjEwMCU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdvJywgNCkgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbycsIDUpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz4kPC9zcGFuPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdvJywgNikgfSB7IHRoaXMucmVuZGVyU2ltcGxlRGF0YSgzLCAnbycsIDcpIH08c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPiU8L3NwYW4+PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TGV0dGVyJz5wPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5SZW50YWwgZGVtYW5kIFVwIHRvPC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdwJywgMSkgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPlVwIHRvIHsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdwJywgMikgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0PHRkPnsgdGhpcy5yZW5kZXJTaW1wbGVEYXRhKDMsICdwJywgMykgfTwvdGQ+XG5cdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlcic+cTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+QWN0aXZpdHk8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ3EnLCAxKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ3EnLCAyKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0XHQ8dGQ+eyB0aGlzLnJlbmRlclNpbXBsZURhdGEoMywgJ3EnLCAzKSB9PC90ZD5cblx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdDwvdGJvZHk+XG5cdFx0XHRcdFx0PC90YWJsZT5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TnVtJz40PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+QXZhaWxhYmlsaXR5IG9mIE1vcnRnYWdlIEZ1bmRzPC9zcGFuPlxuXHRcdFx0XHRcdDx1bD5cblx0XHRcdFx0XHRcdHsgdGhpcy5yZW5kZXJTaW1wbGVTdWJjYXRlZ29yeSg0LCAnYScsICdIb21lIHB1cmNoYXNlJykgfVxuXHRcdFx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZVN1YmNhdGVnb3J5KDQsICdiJywgJ0hvbWUgYnVpbGRpbmcnKSB9XG5cdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0eyB0aGlzLnJlbmRlclNpbXBsZUNhdGVnb3J5KDUsICdDbGFyaWZ5aW5nIFJlbWFya3MnKSB9XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSc+Njwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE5hbWUnPk5hbWUgYW5kIExvY2F0aW9uPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyAoQURbNl0gJiYgQURbNl1bMV0gKSA/IEFEWzZdWzFdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5TZWN1cml0eSBHcmFkZTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEWzZdICYmIEFEWzZdWzJdICkgPyBBRFs2XVsyXSA6IDxzcGFuIGNsYXNzTmFtZT0nZW1wdHknPmVtcHR5PC9zcGFuPiB9PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSc+QXJlYSBOby48L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPSdzdWJjYXREYXRhJz57IChBRFs2XSAmJiBBRFs2XVszXSApID8gQURbNl1bM10gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdDwvdWw+XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlclNpbXBsZUNhdGVnb3J5KGNhdE51bSwgY2F0TmFtZSkge1xuXHRcdGxldCBBRCA9IHRoaXMucHJvcHMuYXJlYURlc2NyaXB0aW9ucztcblx0XHRcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGxpIGtleT17J0FELScgKyBjYXROdW19PlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdE51bSBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD17IGNhdE51bSB9PnsgY2F0TnVtIH08L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nY2F0TmFtZSBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD17IGNhdE51bSB9PnsgY2F0TmFtZSB9PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdERhdGEnPnsgKEFEW2NhdE51bV0gKSA/IEFEW2NhdE51bV0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj59PC9zcGFuPlxuXHRcdFx0PC9saT5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyU2ltcGxlU3ViY2F0ZWdvcnkoY2F0TnVtLCBjYXRMZXR0ZXIsIHN1YmNhdE5hbWUpIHtcblx0XHRsZXQgQUQgPSB0aGlzLnByb3BzLmFyZWFEZXNjcmlwdGlvbnM7IFxuXG5cdFx0aWYgKHR5cGVvZiBBRFtjYXROdW1dW2NhdExldHRlcl0gPT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnNvbGUud2FybihjYXROdW0gKyBjYXRMZXR0ZXIgKyAnIGlzIGFuIG9iamVjdCB3aGVuIGEgc3RyaW5nIHdhcyBleHBlY3RlZCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGxpPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J2NhdExldHRlciBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD17IGNhdE51bSArICctJyArIGNhdExldHRlciB9PnsgY2F0TGV0dGVyIH08L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0TmFtZSBjYXRTZWxlY3RhYmxlJyBvbkNsaWNrPXsgdGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2xpY2sgfSBpZD17IGNhdE51bSArICctJyArIGNhdExldHRlciB9Pnsgc3ViY2F0TmFtZSB9PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9J3N1YmNhdERhdGEnPnsgKEFEW2NhdE51bV0gJiYgQURbY2F0TnVtXVtjYXRMZXR0ZXJdICYmIHR5cGVvZiBBRFtjYXROdW1dW2NhdExldHRlcl0gIT09ICdvYmplY3QnICkgPyBBRFtjYXROdW1dW2NhdExldHRlcl0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj59PC9zcGFuPlxuXHRcdFx0PC9saT5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyU2ltcGxlRGF0YShjYXROdW0sIHN1YmNhdExldHRlciA9ICcnLCBvcmRlciA9IG51bGwpIHtcblx0XHRsZXQgQUQgPSB0aGlzLnByb3BzLmFyZWFEZXNjcmlwdGlvbnM7XG5cdFx0aWYgKG9yZGVyID09IG51bGwpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxzcGFuPnsgKEFEW2NhdE51bV0gJiYgQURbY2F0TnVtXVtzdWJjYXRMZXR0ZXJdICkgPyBBRFtjYXROdW1dW3N1YmNhdExldHRlcl0gOiA8c3BhbiBjbGFzc05hbWU9J2VtcHR5Jz5lbXB0eTwvc3Bhbj4gfTwvc3Bhbj5cblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChzdWJjYXRMZXR0ZXIgPT0gJycpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxzcGFuPnsgKEFEW2NhdE51bV0gJiYgQURbY2F0TnVtXVtvcmRlcl0gKSA/IEFEW2NhdE51bV1bb3JkZXJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8c3Bhbj57IChBRFtjYXROdW1dICYmIEFEW2NhdE51bV1bc3ViY2F0TGV0dGVyXSAmJiBBRFtjYXROdW1dW3N1YmNhdExldHRlcl1bb3JkZXJdICkgPyBBRFtjYXROdW1dW3N1YmNhdExldHRlcl1bb3JkZXJdIDogPHNwYW4gY2xhc3NOYW1lPSdlbXB0eSc+ZW1wdHk8L3NwYW4+IH08L3NwYW4+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG59XG4iLCJpbXBvcnQgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge0dlb0pzb259ICBmcm9tICdyZWFjdC1sZWFmbGV0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJlYVBvbHlnb24gZXh0ZW5kcyBHZW9Kc29uIHtcblxuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuXHRcdGlmIChuZXh0UHJvcHMuZGF0YSAhPT0gdGhpcy5wcm9wcy5kYXRhKSB7XG5cdFx0XHR0aGlzLmxlYWZsZXRFbGVtZW50LmNsZWFyTGF5ZXJzKCk7XG5cdFx0fVxuXHRcdGlmIChuZXh0UHJvcHMuY2xhc3NOYW1lICE9PSB0aGlzLnByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0dGhpcy5sZWFmbGV0RWxlbWVudC5vcHRpb25zLmNsYXNzTmFtZSA9IG5leHRQcm9wcy5jbGFzc05hbWU7XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRQcm9wcy5maWxsT3BhY2l0eSAhPT0gdGhpcy5wcm9wcy5maWxsT3BhY2l0eSkge1xuXHRcdFx0Y29uc29sZS5sb2codGhpcy5sZWFmbGV0RWxlbWVudCk7XG5cdFx0XHR0aGlzLmxlYWZsZXRFbGVtZW50Lm9wdGlvbnMuZmlsbE9wYWNpdHkgPSBuZXh0UHJvcHMuZmlsbE9wYWNpdHk7XG5cdFx0fVxuXHR9XG5cblx0Y29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuXHRcdGlmIChwcmV2UHJvcHMuZGF0YSAhPT0gdGhpcy5wcm9wcy5kYXRhKSB7XG5cdFx0XHR0aGlzLmxlYWZsZXRFbGVtZW50LmFkZERhdGEodGhpcy5wcm9wcy5kYXRhKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRTdHlsZUlmQ2hhbmdlZChwcmV2UHJvcHMuc3R5bGUsIHRoaXMucHJvcHMuc3R5bGUpO1xuXHR9XG59XG5cbkFyZWFQb2x5Z29uLnByb3BUeXBlcyA9IHtcblx0ZGF0YTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59OyIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBcHBBY3Rpb25UeXBlcyB9IGZyb20gJy4uL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXR5U25pcHBldCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRjaXR5RGF0YTogUHJvcFR5cGVzLm9iamVjdFxuXHR9O1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0Ly90aGlzLmQzQ2hhcnQgPSB0aGlzLmQzQ2hhcnQuYmluZCh0aGlzKTtcblx0fVxuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG5cdFx0cmV0dXJuIChuZXh0UHJvcHMuY2l0eURhdGEuY2l0eSAhPT0gdGhpcy5wcm9wcy5jaXR5RGF0YS5jaXR5KTtcblx0fSBcblxuXHRjb21wb25lbnRXaWxsTW91bnQgKCkge31cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5jaXR5RGF0YS5oYXNQb2x5Z29ucykge1xuXHRcdFx0Ly90aGlzLmQzQ2hhcnQudXBkYXRlKHRoaXMucmVmcy5iYXJjaGFydCwgdGhpcy5wYXJzZVBlcmNlbnRzKCksIHRoaXMucHJvcHMuYXJlYUNoYXJ0V2lkdGgpO1xuXHRcdFx0Ly90aGlzLmQzUGllQ2hhcnQudXBkYXRlKHRoaXMucmVmcy5waWVjaGFydCwgdGhpcy5wYXJzZVBlcmNlbnRzKCkpO1xuXHRcdFx0dGhpcy5kM0JhckNoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMuYmFyY2hhcnQsIHRoaXMucGFyc2VQZXJjZW50cygpKTtcblx0XHR9XG5cdH1cblxuXHRwYXJzZVBlcmNlbnRzICgpIHtcblxuXHRcdHJldHVybiAodGhpcy5wcm9wcy5jaXR5RGF0YS5oYXNQb2x5Z29ucykgPyBbXG5cdFx0XHR7J2dyYWRlJzogJ0EnLCAncGVyY2VudCc6IHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS5hIC8gdGhpcy5wcm9wcy5jaXR5RGF0YS5hcmVhLnRvdGFsIH0sXG5cdFx0XHR7J2dyYWRlJzogJ0InLCAncGVyY2VudCc6IHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS5iIC8gdGhpcy5wcm9wcy5jaXR5RGF0YS5hcmVhLnRvdGFsIH0sXG5cdFx0XHR7J2dyYWRlJzogJ0MnLCAncGVyY2VudCc6IHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS5jIC8gdGhpcy5wcm9wcy5jaXR5RGF0YS5hcmVhLnRvdGFsIH0sXG5cdFx0XHR7J2dyYWRlJzogJ0QnLCAncGVyY2VudCc6IHRoaXMucHJvcHMuY2l0eURhdGEuYXJlYS5kIC8gdGhpcy5wcm9wcy5jaXR5RGF0YS5hcmVhLnRvdGFsIH1cblx0XHRdIDogZmFsc2U7XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IFxuXHRcdFx0XHRjbGFzc05hbWU9J2NpdHktc25pcHBldCcgXG5cdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnByb3BzLm9uQ2l0eUNsaWNrIH0gXG5cdFx0XHRcdGlkPXsgdGhpcy5wcm9wcy5jaXR5RGF0YS5jaXR5SWQgfVxuXHRcdFx0PlxuXHRcdFx0XHR7ICh0aGlzLnByb3BzLmNpdHlEYXRhLmhhc0FEcykgP1xuXHRcdFx0XHRcdDxoND5hcmVhIGRlc2NyaXB0aW9ucyBhdmFpbGFibGU8L2g0PiA6IFxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdH1cblx0XHRcdFx0eyAodGhpcy5wcm9wcy5jaXR5RGF0YS5oYXNQb2x5Z29ucykgP1xuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdiYXJjaGFydCcgcmVmPSdiYXJjaGFydCc+PC9kaXY+IDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdH1cblx0XHRcdFx0PGgzID57dGhpcy5wcm9wcy5jaXR5RGF0YS5jaXR5ICsgKCh0aGlzLnByb3BzLmRpc3BsYXlTdGF0ZSkgPyAnLCAnICsgdGhpcy5wcm9wcy5jaXR5RGF0YS5zdGF0ZSA6ICcnKSB9PC9oMz5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J3BvcHVsYXRpb25TdGF0cyc+PHNwYW4gY2xhc3NOYW1lPSdjYXROYW1lJz5Qb3B1bGF0aW9uICgxOTQwKTo8L3NwYW4+IDxzcGFuIGNsYXNzTmFtZT0nc3ViY2F0RGF0YSc+eyB0aGlzLnByb3BzLmNpdHlEYXRhLnBvcHVsYXRpb25fMTk0MC50b0xvY2FsZVN0cmluZygpIH08L3NwYW4+PC9kaXY+XG5cdFx0XHRcdHsgdGhpcy5yZW5kZXJfcG9wdWxhdGlvbl9kZXRhaWxzKCkgfVxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyX3BvcHVsYXRpb25fZGV0YWlscyAoKSB7XG5cdFx0bGV0IENEID0gdGhpcy5wcm9wcy5jaXR5RGF0YSxcblx0XHRcdGFnZ3JlZ2F0ZWRfcG9wID0gQ0Qud2hpdGVfcG9wXzE5NDAgKyBDRC5ibGFja19wb3BfMTk0MCArIENELmFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTk0MCArIENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MDtcblx0XHRpZiAoYWdncmVnYXRlZF9wb3AgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcHJvcG9ydGlvbnMgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQnbGFiZWwnOiAnd2hpdGUnLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0Qud2hpdGVfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FmcmljYW4gQW1lcmljYW4nLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0QuYmxhY2tfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FzaWFuIEFtZXJpY2FuJyxcblx0XHRcdFx0XHQncHJvcG9ydGlvbic6IENELmFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQnbGFiZWwnOiAnTmF0aXZlIEFtZXJpY2FuJyxcblx0XHRcdFx0XHQncHJvcG9ydGlvbic6IENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXG5cdFx0XHRcdH1cblx0XHRcdF07XG5cdFx0XHRwcm9wb3J0aW9ucy5zb3J0KChhLGIpID0+IGEucHJvcG9ydGlvbiA8IGIucHJvcG9ydGlvbik7XG5cdFx0XHRyZXR1cm4gPHVsPlxuXHRcdFx0XHR7IHByb3BvcnRpb25zLm1hcCgocG9wKSA9PiB7XG5cdFx0XHRcdFx0aWYgKE1hdGgucm91bmQocG9wLnByb3BvcnRpb24gKiAxMDApICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gPGxpIGtleT17ICdwb3AxOTQwJyArIHBvcC5sYWJlbC5yZXBsYWNlKC8gL2csJycpIH0+eyBNYXRoLnJvdW5kKHBvcC5wcm9wb3J0aW9uICogMTAwKSArICclICcgKyBwb3AubGFiZWwgfTwvbGk+O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSl9XG5cdFx0XHRcdDwvdWw+O1xuXHRcdH1cblx0fVxuXG5cdGQzUGllQ2hhcnQgPSB7XG5cdFx0cmFkaXVzOiAzMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgZ3JhZGVTdGF0cykge1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGdyYWRlU3RhdHMpLmxlbmd0aCA9PT0gMCkgeyBcblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdHJldHVybjsgXG5cdFx0XHR9XG5cblx0XHRcdGxldCBzY29wZSA9IHRoaXM7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gWycjNDE4ZTQxJywgJyM0YTRhZTQnLCAnI2Y0ZjU3MCcsICcjZWIzZjNmJ11baV07IH07XG5cdFx0XHR2YXIgY29sb3JCb3JkZXIgPSBmdW5jdGlvbihpKSB7IHJldHVybiBbJyM0MThlNDEnLCAnIzRhNGFlNCcsICcjQTNBMzRCJywgJyNlYjNmM2YnXVtpXTsgfTtcblx0XHRcdHZhciBjb2xvckdyYWRlID0gZnVuY3Rpb24oZ3JhZGUpIHtcblx0XHRcdFx0bGV0IGdyYWRlQ29sb3JzID0geydBJzonIzQxOGU0MScsJ0InOicjNGE0YWU0JywnQyc6JyNmNGY1NzAnLCdEJzonI2ViM2YzZid9O1xuXHRcdFx0XHRyZXR1cm4gZ3JhZGVDb2xvcnNbZ3JhZGVdO1xuXHRcdFx0fTtcblxuXHRcdFx0bGV0IHBpZSA9IGQzLmxheW91dC5waWUoKVxuXHRcdFx0XHQudmFsdWUoKGQpID0+IGQucGVyY2VudClcblx0XHRcdFx0LnNvcnQobnVsbCk7XG5cdFx0XHR2YXIgYXJjID0gZDMuc3ZnLmFyYygpXG5cdFx0XHRcdCAgLm91dGVyUmFkaXVzKHNjb3BlLnJhZGl1cyAtIDEwKVxuXHRcdFx0XHQgIC5pbm5lclJhZGl1cygwKTtcblx0XHRcdHZhciBwZXJjZW50ID0gZDMuZm9ybWF0KCcsJScpO1xuXG5cdFx0XHRsZXQgdGhlQ2hhcnQgPSBkMy5zZWxlY3Qobm9kZSlcblx0XHRcdFx0LmFwcGVuZCgnc3ZnJylcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgc2NvcGUucmFkaXVzICogMilcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLnJhZGl1cyAqIDIpXG5cdFx0XHRcdC5hdHRyKCdpZCcsICdwaWVjaGFydCcpXG5cdFx0XHRcdC5hcHBlbmQoJ2cnKVxuXHRcdFx0XHQuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc2NvcGUucmFkaXVzICsgJywnICsgc2NvcGUucmFkaXVzICsgJyknKTtcblxuXHRcdFx0Ly8gdGhlQ2hhcnRcblx0XHRcdC8vICAgLnNlbGVjdEFsbCgncmVjdCcpXG5cdFx0XHQvLyAgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQvLyAgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0XHQvLyAgIC8vLmF0dHIoJ2NsYXNzJywgKGQsaSxqKSA9PiAnYXJlYUJhciBiYXJHcmFkZScgKyBkLnBlcmNlbnRzW2pdLmdyYWRlICsgJyByaW5nJyArIChpICsgMSkpXG5cdFx0XHQvLyAgIC5hdHRyKCdoZWlnaHQnLCBzY29wZS5IRUlHSFQpXG5cdFx0XHQvLyAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLndpZHRoKVxuXHRcdFx0Ly8gICAuYXR0cignb3BhY2l0eScsIC43KVxuXHRcdFx0Ly8gICAuYXR0cigneScsIDApXG5cdFx0XHQvLyAgIC5hdHRyKCd4JywgKGQpID0+IGQueCArIHNjb3BlLk1BUkdJTilcblx0XHRcdC8vICAgLmF0dHIoJ2ZpbGwnLCAoZCkgPT4gY29sb3JHcmFkZShkLmdyYWRlKSk7XG5cblx0XHRcdHRoZUNoYXJ0XG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3BhdGgnKVxuXHRcdFx0ICAuZGF0YShwaWUoZ3JhZGVTdGF0cykpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG5cdFx0XHQgIC5hdHRyKFwiZFwiLCBhcmMpXG5cdFx0XHQgIC5maWx0ZXIoKGQpID0+IGQuZGF0YS5wZXJjZW50ID4gMClcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpKSA9PiBjb2xvckdyYWRlKGQuZGF0YS5ncmFkZSkpXG5cdFx0XHQgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKVxuXHRcdFx0ICAuYXR0cignY2xhc3MnLCAoZCkgPT4gJ3NsaWNlR3JhZGUnICsgZC5kYXRhLmdyYWRlKVxuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0ZDMuc2VsZWN0KG5vZGUpLmh0bWwoJycpO1xuXHRcdH0gXG5cdH1cblxuXHRkM0JhckNoYXJ0ID0ge1xuXHRcdC8vIGxheW91dCBjb25zdGFudHNcblx0XHRXSURUSDogOTAsXG5cdFx0SEVJR0hUOiA0MCxcblx0XHRNQVJHSU46IDI0LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihub2RlLCBncmFkZVN0YXRzLCB3aWR0aCA9IGZhbHNlKSB7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoZ3JhZGVTdGF0cykubGVuZ3RoID09PSAwKSB7IFxuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0cmV0dXJuOyBcblx0XHRcdH1cblxuXHRcdFx0bGV0IHNjb3BlID0gdGhpcztcblxuXHRcdFx0aWYgKHdpZHRoKSB7XG5cdFx0XHRcdC8vc2NvcGUuV0lEVEggPSB3aWR0aDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbG9yID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gWycjNDE4ZTQxJywgJyM0YTRhZTQnLCAnI2Y0ZjU3MCcsICcjZWIzZjNmJ11baV07IH07XG5cdFx0XHR2YXIgY29sb3JCb3JkZXIgPSBmdW5jdGlvbihpKSB7IHJldHVybiBbJyM0MThlNDEnLCAnIzRhNGFlNCcsICcjQTNBMzRCJywgJyNlYjNmM2YnXVtpXTsgfTtcblx0XHRcdHZhciBjb2xvckdyYWRlID0gZnVuY3Rpb24oZ3JhZGUpIHtcblx0XHRcdFx0bGV0IGdyYWRlQ29sb3JzID0geydBJzonIzQxOGU0MScsJ0InOicjNGE0YWU0JywnQyc6JyNDQ0NDMDAnLCdEJzonI2ViM2YzZid9O1xuXHRcdFx0XHRyZXR1cm4gZ3JhZGVDb2xvcnNbZ3JhZGVdO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBlcmNlbnQgPSBkMy5mb3JtYXQoJywlJyk7XG5cdFx0XHR2YXIgd2lkdGggPSBkMy5zY2FsZS5saW5lYXIoKVxuXHRcdFx0XHQucmFuZ2VSb3VuZChbMCwgc2NvcGUuV0lEVEhdKTtcblxuXHRcdFx0bGV0IHggPSAwO1xuXHRcdFx0Z3JhZGVTdGF0cy5mb3JFYWNoKChkLCBpKSA9PiB7XG5cdFx0XHRcdGdyYWRlU3RhdHNbaV0gPSB7IHg6IHgsIHdpZHRoOiB3aWR0aChkLnBlcmNlbnQpLCBwZXJjZW50OiBkLnBlcmNlbnQsIGdyYWRlOiBkLmdyYWRlIH07XG5cdFx0XHRcdHggKz0gd2lkdGgoZC5wZXJjZW50KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgdGhlQ2hhcnQgPSBkMy5zZWxlY3Qobm9kZSlcblx0XHRcdFx0LmFwcGVuZCgnc3ZnJylcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgc2NvcGUuV0lEVEgpXG5cdFx0XHRcdC5hdHRyKCdoZWlnaHQnLCBzY29wZS5IRUlHSFQgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHRcdC5hdHRyKCdpZCcsICdiYXJjaGFydCcpXG5cdFx0XHRcdC5zZWxlY3RBbGwoJ2cnKVxuXHRcdFx0XHQuZGF0YShncmFkZVN0YXRzKVxuXHRcdFx0XHQuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcblxuXHRcdFx0dGhlQ2hhcnRcblx0XHRcdCAgLnNlbGVjdEFsbCgncmVjdCcpXG5cdFx0XHQgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0XHQgIC8vLmF0dHIoJ2NsYXNzJywgKGQsaSxqKSA9PiAnYXJlYUJhciBiYXJHcmFkZScgKyBkLnBlcmNlbnRzW2pdLmdyYWRlICsgJyByaW5nJyArIChpICsgMSkpXG5cdFx0XHQgIC5hdHRyKCdoZWlnaHQnLCBzY29wZS5IRUlHSFQvNCAtIDQpXG5cdFx0XHQgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLndpZHRoKVxuXHRcdFx0ICAuYXR0cignb3BhY2l0eScsIC43KVxuXHRcdFx0ICAuYXR0cigneScsIChkLGkpID0+IHNjb3BlLk1BUkdJTiArIHNjb3BlLkhFSUdIVC80ICogaSlcblx0XHRcdCAgLmF0dHIoJ3gnLCAoZCkgPT4gc2NvcGUuV0lEVEggLSBkLndpZHRoKVxuXHRcdFx0ICAuYXR0cignZmlsbCcsIChkKSA9PiBjb2xvckdyYWRlKGQuZ3JhZGUpKTtcblxuXHRcdFx0Ly8gdGhlQ2hhcnRcblx0XHRcdC8vICAgLnNlbGVjdEFsbCgndGV4dCcpXG5cdFx0XHQvLyAgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQvLyAgIC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG5cdFx0XHQvLyAgIC5hdHRyKCd4JywgKGQpID0+IGQueCArIGQud2lkdGggLyAyICsgc2NvcGUuTUFSR0lOKVxuXHRcdFx0Ly8gICAuYXR0cigneScsIDExKVxuXHRcdFx0Ly8gICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcblx0XHRcdC8vICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKVxuXHRcdFx0Ly8gICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxuXHRcdFx0Ly8gICAuYXR0cignZmlsbCcsIChkKSA9PiAoZC5ncmFkZSA9PSAnQycpID8gJ2JsYWNrJyA6ICd3aGl0ZScpXG5cdFx0XHQvLyAgIC50ZXh0KChkKSA9PiAoZC5wZXJjZW50ID4gMC4wMykgPyBwZXJjZW50KGQucGVyY2VudCkgOiAnJyk7XG5cdFx0fSwgXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0ZDMuc2VsZWN0KG5vZGUpLmh0bWwoJycpO1xuXHRcdH0gXG5cdH1cblxuXHRkM0NoYXJ0ID0ge1xuXHRcdC8vIGxheW91dCBjb25zdGFudHNcblx0XHRXSURUSDogKHRoaXMucHJvcHMgJiYgdGhpcy5wcm9wcy5hcmVhQ2hhcnRXaWR0aCkgPyB0aGlzLnByb3BzLmFyZWFDaGFydFdpZHRoIDogMjUwLFxuXHRcdEhFSUdIVDogMTUsXG5cdFx0TUFSR0lOOiAyMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgZ3JhZGVTdGF0cywgd2lkdGggPSBmYWxzZSkge1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGdyYWRlU3RhdHMpLmxlbmd0aCA9PT0gMCkgeyBcblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdHJldHVybjsgXG5cdFx0XHR9XG5cblx0XHRcdGxldCBzY29wZSA9IHRoaXM7XG5cblx0XHRcdGlmICh3aWR0aCkge1xuXHRcdFx0XHQvL3Njb3BlLldJRFRIID0gd2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb2xvciA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFsnIzQxOGU0MScsICcjNGE0YWU0JywgJyNmNGY1NzAnLCAnI2ViM2YzZiddW2ldOyB9O1xuXHRcdFx0dmFyIGNvbG9yQm9yZGVyID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gWycjNDE4ZTQxJywgJyM0YTRhZTQnLCAnI0EzQTM0QicsICcjZWIzZjNmJ11baV07IH07XG5cdFx0XHR2YXIgY29sb3JHcmFkZSA9IGZ1bmN0aW9uKGdyYWRlKSB7XG5cdFx0XHRcdGxldCBncmFkZUNvbG9ycyA9IHsnQSc6JyM0MThlNDEnLCdCJzonIzRhNGFlNCcsJ0MnOicjZjRmNTcwJywnRCc6JyNlYjNmM2YnfTtcblx0XHRcdFx0cmV0dXJuIGdyYWRlQ29sb3JzW2dyYWRlXTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBwZXJjZW50ID0gZDMuZm9ybWF0KCcsJScpO1xuXHRcdFx0dmFyIHdpZHRoID0gZDMuc2NhbGUubGluZWFyKClcblx0XHRcdFx0LnJhbmdlUm91bmQoWzAsIHNjb3BlLldJRFRIXSk7XG5cblx0XHRcdGxldCB4ID0gMDtcblx0XHRcdGdyYWRlU3RhdHMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuXHRcdFx0XHRncmFkZVN0YXRzW2ldID0geyB4OiB4LCB3aWR0aDogd2lkdGgoZC5wZXJjZW50KSwgcGVyY2VudDogZC5wZXJjZW50LCBncmFkZTogZC5ncmFkZSB9O1xuXHRcdFx0XHR4ICs9IHdpZHRoKGQucGVyY2VudCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0bGV0IHRoZUNoYXJ0ID0gZDMuc2VsZWN0KG5vZGUpXG5cdFx0XHRcdC5hcHBlbmQoJ3N2ZycpXG5cdFx0XHRcdC5hdHRyKCd3aWR0aCcsIHNjb3BlLldJRFRIICsgc2NvcGUuTUFSR0lOKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0Jywgc2NvcGUuSEVJR0hUKVxuXHRcdFx0XHQuYXR0cignaWQnLCAnYmFyY2hhcnQnKVxuXHRcdFx0XHQuc2VsZWN0QWxsKCdnJylcblx0XHRcdFx0LmRhdGEoZ3JhZGVTdGF0cylcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCdnJyk7XG5cblx0XHRcdHRoZUNoYXJ0XG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuXHRcdFx0ICAuZGF0YShncmFkZVN0YXRzKVxuXHRcdFx0ICAuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuXHRcdFx0ICAvLy5hdHRyKCdjbGFzcycsIChkLGksaikgPT4gJ2FyZWFCYXIgYmFyR3JhZGUnICsgZC5wZXJjZW50c1tqXS5ncmFkZSArICcgcmluZycgKyAoaSArIDEpKVxuXHRcdFx0ICAuYXR0cignaGVpZ2h0Jywgc2NvcGUuSEVJR0hUKVxuXHRcdFx0ICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZC53aWR0aClcblx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAuNylcblx0XHRcdCAgLmF0dHIoJ3knLCAwKVxuXHRcdFx0ICAuYXR0cigneCcsIChkKSA9PiBkLnggKyBzY29wZS5NQVJHSU4pXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IGNvbG9yR3JhZGUoZC5ncmFkZSkpO1xuXG5cdFx0XHR0aGVDaGFydFxuXHRcdFx0ICAuc2VsZWN0QWxsKCd0ZXh0Jylcblx0XHRcdCAgLmRhdGEoZ3JhZGVTdGF0cylcblx0XHRcdCAgLmVudGVyKCkuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdCAgLmF0dHIoJ3gnLCAoZCkgPT4gZC54ICsgZC53aWR0aCAvIDIgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHQgIC5hdHRyKCd5JywgMTEpXG5cdFx0XHQgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuXHRcdFx0ICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXG5cdFx0XHQgIC5hdHRyKCdmb250LXNpemUnLCAnMTBweCcpXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IChkLmdyYWRlID09ICdDJykgPyAnYmxhY2snIDogJ3doaXRlJylcblx0XHRcdCAgLnRleHQoKGQpID0+IChkLnBlcmNlbnQgPiAwLjAzKSA/IHBlcmNlbnQoZC5wZXJjZW50KSA6ICcnKTtcblx0XHR9LCBcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRkMy5zZWxlY3Qobm9kZSkuaHRtbCgnJyk7XG5cdFx0fSBcblx0fVxufSIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgQXBwQWN0aW9ucyB9IGZyb20gJy4uL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXR5U3RhdHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRyaW5nU3RhdHM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLmJvb2xdKSxcblx0XHRncmFkZVN0YXRzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5ib29sXSksXG5cdFx0YXJlYVNlbGVjdGVkOiBQcm9wVHlwZXMuZnVuYyxcblx0XHRhcmVhVW5zZWxlY3RlZDogUHJvcFR5cGVzLmZ1bmMsXG5cdFx0Z3JhZGVTZWxlY3RlZDogUHJvcFR5cGVzLmZ1bmMsXG5cdFx0Z3JhZGVVbnNlbGVjdGVkOiBQcm9wVHlwZXMuZnVuYyxcblx0XHR0b2dnbGVCdXJnZXNzRGlhZ3JhbTogUHJvcFR5cGVzLmZ1bmMsXG5cdFx0YnVyZ2Vzc0RpYWdyYW1WaXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblx0XHRjaXR5RGF0YTogUHJvcFR5cGVzLm9iamVjdFxuXHR9O1xuXG5cdC8vIChpbnN0ZWFkIG9mIEVTNS1zdHlsZSBnZXREZWZhdWx0UHJvcHMpXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0bmFtZTogJycsXG5cdFx0cmluZ1N0YXRzOiB7XG5cdFx0XHQxOiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAnZGVuc2l0eSc6IDB9LFxuXHRcdFx0MjogeydBJzogMCwgJ0InOiAwLCAnQyc6IDAsICdEJzogMCwgJ2RlbnNpdHknOiAwfSxcblx0XHRcdDM6IHsnQSc6IDAsICdCJzogMCwgJ0MnOiAwLCAnRCc6IDAsICdkZW5zaXR5JzogMH0sXG5cdFx0XHQ0OiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAnZGVuc2l0eSc6IDB9XG5cdFx0fSxcblx0XHRncmFkZVN0YXRzOiB7XG5cdFx0XHQnQSc6eydhcmVhJzowLCdwZXJjZW50JzowfSxcblx0XHRcdCdCJzp7J2FyZWEnOjAsJ3BlcmNlbnQnOjB9LFxuXHRcdFx0J0MnOnsnYXJlYSc6MCwncGVyY2VudCc6MH0sXG5cdFx0XHQnRCc6eydhcmVhJzowLCdwZXJjZW50JzowfSxcblx0XHR9XG5cdH07XG5cblx0Y29uc3RydWN0b3IgKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHR9O1xuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuXHRcdC8vIGRvbid0IGtub3cgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5LCBidXQgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGluZyBvbiBtb3VzZW92ZXItLXRoaXMgcHJldmVudHMgdGhhdC5cblx0XHRyZXR1cm4gKG5leHRQcm9wcy5idXJnZXNzRGlhZ3JhbVZpc2libGUgIT09IHRoaXMucHJvcHMuYnVyZ2Vzc0RpYWdyYW1WaXNpYmxlIHx8IG5leHRQcm9wcy5yaW5nU3RhdHMgIT09IHRoaXMucHJvcHMucmluZ1N0YXRzKTtcblx0fTtcblx0XG5cdGNvbXBvbmVudFdpbGxNb3VudCAoKSB7fTtcblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLmQzTmVzdGVkUGllQ2hhcnQub25Ib3ZlciA9IHRoaXMucHJvcHMuYXJlYVNlbGVjdGVkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0Lm9uSG92ZXJPdXQgPSB0aGlzLnByb3BzLmFyZWFVbnNlbGVjdGVkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0Lm9uR3JhZGVIb3ZlciA9IHRoaXMucHJvcHMuZ3JhZGVTZWxlY3RlZC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZDNOZXN0ZWRQaWVDaGFydC5vbkdyYWRlSG92ZXJPdXQgPSB0aGlzLnByb3BzLmdyYWRlVW5zZWxlY3RlZC5iaW5kKHRoaXMpO1xuXHRcdGlmICh0aGlzLnByb3BzLnJpbmdTdGF0cykge1xuXHRcdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMuY29udGVudCwgdGhpcy5wcm9wcy5yaW5nU3RhdHMsIHRoaXMucHJvcHMuZ3JhZGVTdGF0cyk7XG5cdFx0XHQvL3RoaXMuZDNTbG9wZUNoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMuc2xvcGVDaGFydCwgdGhpcy5nZXRTbG9wZUNoYXJ0RGF0YSgpKTtcblx0XHR9XG5cdH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUgKCkge1xuXHRcdHRoaXMuZDNOZXN0ZWRQaWVDaGFydC5kZXN0cm95KHRoaXMucmVmcy5jb250ZW50KTtcblx0XHQvL3RoaXMuZDNOZXN0ZWRQaWVDaGFydC5kZXN0cm95KHRoaXMucmVmcy5zbG9wZUNoYXJ0KTtcblx0XHR0aGlzLmQzTmVzdGVkUGllQ2hhcnQub25Ib3ZlciA9IHRoaXMucHJvcHMuYXJlYVNlbGVjdGVkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5kM05lc3RlZFBpZUNoYXJ0Lm9uSG92ZXJPdXQgPSB0aGlzLnByb3BzLmFyZWFVbnNlbGVjdGVkLmJpbmQodGhpcyk7XG5cdFx0aWYgKHRoaXMucHJvcHMucmluZ1N0YXRzKSB7XG5cdFx0XHR0aGlzLmQzTmVzdGVkUGllQ2hhcnQudXBkYXRlKHRoaXMucmVmcy5jb250ZW50LCB0aGlzLnByb3BzLnJpbmdTdGF0cywgdGhpcy5wcm9wcy5ncmFkZVN0YXRzKTtcblx0XHRcdHRoaXMuZDNTbG9wZUNoYXJ0LnVwZGF0ZSh0aGlzLnJlZnMuc2xvcGVDaGFydCwgdGhpcy5nZXRTbG9wZUNoYXJ0RGF0YSgpKTtcblx0XHR9XG5cdH1cblxuXHRhcmVhSG92ZXIgKHNlbGVjdGVkUmluZ0lkLCBzZWxlY3RlZEdyYWRlKSB7XG5cdFx0QXBwQWN0aW9ucy5yaW5nQXJlYVNlbGVjdGVkKHNlbGVjdGVkUmluZ0lkLCBzZWxlY3RlZEdyYWRlKTtcblx0fVxuXG5cdGdldFBvcExhYmVsIChrZXkpIHtcblx0XHRjb25zdCBsYWJlbHMgPSB7XG5cdFx0XHR3aGl0ZTogJ3doaXRlJyxcblx0XHRcdGJsYWNrOiAnQWZyaWNhbiBBbWVyaWNhbicsXG5cdFx0XHRhc2lhbkFtZXJpY2FuOiAnQXNpYW4gQW1lcmljYW4nLFxuXHRcdFx0bmF0aXZlQW1lcmljYW46ICdOYXRpdmUgQW1lcmljYW4nXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxhYmVsc1trZXldO1xuXHR9XG5cblx0Z2V0U2xvcGVDaGFydERhdGEgKCkge1xuXHRcdGxldCBDRCA9IHRoaXMucHJvcHMuY2l0eURhdGEsXG5cdFx0XHRhZ2dyZWdhdGVkX3BvcF8xOTMwID0gQ0Qud2hpdGVfcG9wXzE5MzAgKyBDRC5ibGFja19wb3BfMTkzMCArIENELmFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5MzAgKyBDRC5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5MzAsXG5cdFx0XHRhZ2dyZWdhdGVkX3BvcF8xOTQwID0gQ0Qud2hpdGVfcG9wXzE5NDAgKyBDRC5ibGFja19wb3BfMTk0MCArIENELmFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5NDAgKyBDRC5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5NDAsXG5cdFx0XHRwb3BTdGF0cyA9IHtcblx0XHRcdFx0MTkzMDoge1xuXHRcdFx0XHRcdHRvdGFsOiAodGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgJiYgdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgIT09IDApID8gdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgOiBudWxsLFxuXHRcdFx0XHRcdHdoaXRlOiBDRC53aGl0ZV9wb3BfMTkzMCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5MzAsXG5cdFx0XHRcdFx0YmxhY2s6IENELmJsYWNrX3BvcF8xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMCxcblx0XHRcdFx0XHRhc2lhbkFtZXJpY2FuOiBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMCxcblx0XHRcdFx0XHRuYXRpdmVBbWVyaWNhbjogQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQxOTQwOiB7XG5cdFx0XHRcdFx0dG90YWw6ICh0aGlzLnByb3BzLmNpdHlEYXRhLnBvcHVsYXRpb25fMTk0MCAmJiB0aGlzLnByb3BzLmNpdHlEYXRhLnBvcHVsYXRpb25fMTk0MCAhPT0gMCkgPyB0aGlzLnByb3BzLmNpdHlEYXRhLnBvcHVsYXRpb25fMTk0MCA6IG51bGwsXG5cdFx0XHRcdFx0d2hpdGU6IENELndoaXRlX3BvcF8xOTQwIC8gYWdncmVnYXRlZF9wb3BfMTk0MCxcblx0XHRcdFx0XHRibGFjazogQ0QuYmxhY2tfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcF8xOTQwLFxuXHRcdFx0XHRcdGFzaWFuQW1lcmljYW46IENELmFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcF8xOTQwLFxuXHRcdFx0XHRcdG5hdGl2ZUFtZXJpY2FuOiBDRC5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcF8xOTQwXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzbG9wZUNoYXJ0RGF0YSA9IFtcblx0XHRcdFx0eyBsYWJlbDogJ3doaXRlJywgdjMwOiBwb3BTdGF0c1sxOTMwXS53aGl0ZSwgdjQwOiBwb3BTdGF0c1sxOTQwXS53aGl0ZSB9LFxuXHRcdFx0XHR7IGxhYmVsOiAnYmxhY2snLCB2MzA6IHBvcFN0YXRzWzE5MzBdLmJsYWNrLCB2NDA6IHBvcFN0YXRzWzE5NDBdLmJsYWNrIH0sXG5cdFx0XHRcdHsgbGFiZWw6ICdhc2lhbkFtZXJpY2FuJywgdjMwOiBwb3BTdGF0c1sxOTMwXS5hc2lhbkFtZXJpY2FuLCB2NDA6IHBvcFN0YXRzWzE5NDBdLmFzaWFuQW1lcmljYW4gfSxcblx0XHRcdFx0eyBsYWJlbDogJ25hdGl2ZUFtZXJpY2FuJywgdjMwOiBwb3BTdGF0c1sxOTMwXS5uYXRpdmVBbWVyaWNhbiwgdjQwOiBwb3BTdGF0c1sxOTQwXS5uYXRpdmVBbWVyaWNhbiB9XG5cdFx0XHRcdC8vIGRhdGE6IFtcblx0XHRcdFx0Ly8gXHRbcG9wU3RhdHNbMTkzMF0ud2hpdGUsIHBvcFN0YXRzWzE5MzBdLmJsYWNrLCBwb3BTdGF0c1sxOTMwXS5hc2lhbkFtZXJpY2FuLCBwb3BTdGF0c1sxOTMwXS5uYXRpdmVBbWVyaWNhbl0sIFxuXHRcdFx0XHQvLyBcdFtwb3BTdGF0c1sxOTQwXS53aGl0ZSwgcG9wU3RhdHNbMTk0MF0uYmxhY2ssIHBvcFN0YXRzWzE5NDBdLmFzaWFuQW1lcmljYW4sIHBvcFN0YXRzWzE5NDBdLm5hdGl2ZUFtZXJpY2FuXSxcblx0XHRcdFx0Ly8gXSxcblx0XHRcdFx0Ly8gbGFiZWw6IFtbJ3doaXRlJywgJ0FmcmljYW4gQW1lcmljYW4nLCAnQXNpYW4gQW1lcmljYW4nLCAnTmF0aXZlIEFtZXJpY2FuJ11dXG5cblx0XHRcdF07XG5cblx0XHRyZXR1cm4gc2xvcGVDaGFydERhdGE7XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXG5cdFx0bGV0IGJ1cmdlc3NDbGFzc05hbWUgPSAodGhpcy5wcm9wcy5idXJnZXNzRGlhZ3JhbVZpc2libGUpID8gJycgOiAnaGlkZGVuJyxcblx0XHRcdHBvcHVsYXRpb24xOTMwID0gKHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTMwICYmIHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTMwICE9PSAwKSA/IHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTMwLnRvTG9jYWxlU3RyaW5nKCkgOiBudWxsLFxuXHRcdFx0cG9wdWxhdGlvbjE5NDAgPSAodGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5NDAgJiYgdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5NDAgIT09IDApID8gdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5NDAudG9Mb2NhbGVTdHJpbmcoKSA6IG51bGwsXG5cdFx0XHRhcmVhID0gKHRoaXMucHJvcHMuYXJlYSkgPyBNYXRoLnJvdW5kKHRoaXMucHJvcHMuYXJlYSAqIDEwMCkgLyAxMDAgKyAnc3EgbWknIDogJyc7XG5cblx0XHRsZXQgQ0QgPSB0aGlzLnByb3BzLmNpdHlEYXRhLFxuXHRcdFx0YWdncmVnYXRlZF9wb3BfMTkzMCA9IENELndoaXRlX3BvcF8xOTMwICsgQ0QuYmxhY2tfcG9wXzE5MzAgKyBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwICsgQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwLFxuXHRcdFx0YWdncmVnYXRlZF9wb3BfMTk0MCA9IENELndoaXRlX3BvcF8xOTQwICsgQ0QuYmxhY2tfcG9wXzE5NDAgKyBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTQwICsgQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTQwLFxuXHRcdFx0cG9wU3RhdHMgPSB7XG5cdFx0XHRcdDE5MzA6IHtcblx0XHRcdFx0XHQvL3RvdGFsOiAodGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgJiYgdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgIT09IDApID8gdGhpcy5wcm9wcy5jaXR5RGF0YS5wb3B1bGF0aW9uXzE5MzAgOiBudWxsLFxuXHRcdFx0XHRcdHdoaXRlOiBDRC53aGl0ZV9wb3BfMTkzMCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5MzAsXG5cdFx0XHRcdFx0YmxhY2s6IENELmJsYWNrX3BvcF8xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMCxcblx0XHRcdFx0XHRhc2lhbkFtZXJpY2FuOiBDRC5hc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMCxcblx0XHRcdFx0XHRuYXRpdmVBbWVyaWNhbjogQ0QuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwIC8gYWdncmVnYXRlZF9wb3BfMTkzMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQxOTQwOiB7XG5cdFx0XHRcdFx0Ly90b3RhbDogKHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTQwICYmIHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTQwICE9PSAwKSA/IHRoaXMucHJvcHMuY2l0eURhdGEucG9wdWxhdGlvbl8xOTQwIDogbnVsbCxcblx0XHRcdFx0XHR3aGl0ZTogQ0Qud2hpdGVfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcF8xOTQwLFxuXHRcdFx0XHRcdGJsYWNrOiBDRC5ibGFja19wb3BfMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5NDAsXG5cdFx0XHRcdFx0YXNpYW5BbWVyaWNhbjogQ0QuYXNpYW5fcGFjaWZpY19pbHNsYW5kZXJfMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5NDAsXG5cdFx0XHRcdFx0bmF0aXZlQW1lcmljYW46IENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MCAvIGFnZ3JlZ2F0ZWRfcG9wXzE5NDBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNsb3BlQ2hhcnREYXRhID0ge1xuXHRcdFx0XHRkYXRhOiBbXG5cdFx0XHRcdFx0W3BvcFN0YXRzWzE5MzBdLndoaXRlLCBwb3BTdGF0c1sxOTMwXS5ibGFjaywgcG9wU3RhdHNbMTkzMF0uYXNpYW5BbWVyaWNhbiwgcG9wU3RhdHNbMTkzMF0ubmF0aXZlQW1lcmljYW5dLCBcblx0XHRcdFx0XHRbcG9wU3RhdHNbMTk0MF0ud2hpdGUsIHBvcFN0YXRzWzE5NDBdLmJsYWNrLCBwb3BTdGF0c1sxOTQwXS5hc2lhbkFtZXJpY2FuLCBwb3BTdGF0c1sxOTQwXS5uYXRpdmVBbWVyaWNhbl0sXG5cdFx0XHRcdF0sXG5cdFx0XHRcdGxhYmVsOiBbWyd3aGl0ZScsICdBZnJpY2FuIEFtZXJpY2FuJywgJ0FzaWFuIEFtZXJpY2FuJywgJ05hdGl2ZSBBbWVyaWNhbiddXVxuXHRcdFx0fTtcblxuXHRcdGxldCBvcmRlcmVkS2V5cyA9IE9iamVjdC5rZXlzKHBvcFN0YXRzWzE5NDBdKS5zb3J0KChhLGIpID0+IChwb3BTdGF0c1sxOTQwXVthXSA8IHBvcFN0YXRzWzE5NDBdW2JdKSk7XG5cblxuXHRcdFx0XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPSdjaXR5U3RhdHMnPlxuXHRcdFx0XHR7ICh0aGlzLnByb3BzLmhhc0FEcykgP1xuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdhZEluc3RydWN0aW9ucyc+Y2xpY2sgb24gbmVpZ2hib3Job29kcyBvbiB0aGUgbWFwIHRvIHJlYWQgdGhlaXIgYXJlYSBkZXNjcmlwdGlvbjwvZGl2PiA6IFxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdhZEluc3RydWN0aW9ucyc+YXJlYSBkZXNjcmlwdGlvbnMgYXJlbid0IGF2YWlsYWJsZSBmb3IgdGhpcyBjaXR5LCBidXQgd2lsbCBiZSBzb29uPC9kaXY+XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ8dGFibGUgY2xhc3NOYW1lPSdwb3B1bGF0aW9uLXN0YXRzJz5cblx0XHRcdFx0XHQ8dGJvZHk+XG5cdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdDx0aD48L3RoPlxuXHRcdFx0XHRcdFx0XHQ8dGg+MTkzMDwvdGg+XG5cdFx0XHRcdFx0XHRcdDx0aD4xOTQwPC90aD5cblx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdDx0ZD5Qb3B1bGF0aW9uPC90ZD5cblx0XHRcdFx0XHRcdFx0PHRkIGNsYXNzTmFtZT0ndG90YWwnIGtleT0ndG90YWwxOTMwJz57IHBvcHVsYXRpb24xOTMwIH08L3RkPlxuXHRcdFx0XHRcdFx0XHQ8dGQgY2xhc3NOYW1lPSd0b3RhbCcga2V5PSd0b3RhbDE5NDAnPnsgcG9wdWxhdGlvbjE5NDAgfTwvdGQ+XG5cdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0eyBvcmRlcmVkS2V5cy5tYXAocG9wa2V5ID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICgocG9wU3RhdHNbMTkzMF1bcG9wa2V5XSA+IDAuMDEgfHwgcG9wU3RhdHNbMTkzMF1bcG9wa2V5XSA+IDAuMDEpID9cblx0XHRcdFx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8dGQga2V5PXsgcG9wa2V5ICsgJ2xhYmVsJyB9PnsgdGhpcy5nZXRQb3BMYWJlbChwb3BrZXkpIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHRkIGtleT17IHBvcGtleSArICcxOTMwJyB9PnsgKE1hdGgucm91bmQocG9wU3RhdHNbMTkzMF1bcG9wa2V5XSAqIDEwMDApIC8gMTApICsgJyUnIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHRkIGtleT17IHBvcGtleSArICcxOTQwJyB9PnsgKE1hdGgucm91bmQocG9wU3RhdHNbMTk0MF1bcG9wa2V5XSAqIDEwMDApIC8gMTApICsgJyUnIH08L3RkPlxuXHRcdFx0XHRcdFx0XHRcdDwvdHI+IDpcblx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdDwvdGJvZHk+XG5cdFx0XHRcdDwvdGFibGU+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J25lc3RlZHBpZWNoYXJ0Jz5cblx0XHRcdFx0XHQ8YnV0dG9uIFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPSdpbnRyby1idXR0b24nIFxuXHRcdFx0XHRcdFx0IFxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0naWNvbiBpbmZvJyBpZD0nYnVyZ2Vzcycgb25DbGljaz17IHRoaXMucHJvcHMub3BlbkJ1cmdlc3MgfSAvPlxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdHsgKHRoaXMucHJvcHMucmluZ1N0YXRzKSA/XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nY29udGVudCcgcmVmPSdjb250ZW50Jz48L2Rpdj4gOlxuXHRcdFx0XHRcdFx0PHA+QXJlYSBkZXNjcmlwdGlvbnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGJ1dCB3aWxsIGJlIGV2ZW50dWFsbHkuPC9wPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8aW1nIHNyYz0nc3RhdGljL2J1cmdlc3MucG5nJyBjbGFzc05hbWU9eyBidXJnZXNzQ2xhc3NOYW1lIH0gcmVmPSdidXJnZXNzRGlhZ3JhbScgaWQ9J2J1cmdlc3NEaWFncmFtJyAvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXJfcG9wdWxhdGlvbl8xOTMwICgpIHtcblx0XHRsZXQgQ0QgPSB0aGlzLnByb3BzLmNpdHlEYXRhLFxuXHRcdFx0YWdncmVnYXRlZF9wb3AgPSBDRC53aGl0ZV9wb3BfMTkzMCArIENELmJsYWNrX3BvcF8xOTMwICsgQ0QuYXNpYW5fcGFjaWZpY19pbHNsYW5kZXJfMTkzMCArIENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTkzMDtcblx0XHRpZiAoYWdncmVnYXRlZF9wb3AgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcHJvcG9ydGlvbnMgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQnbGFiZWwnOiAnd2hpdGUnLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0Qud2hpdGVfcG9wXzE5MzAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FmcmljYW4gQW1lcmljYW4nLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0QuYmxhY2tfcG9wXzE5MzAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FzaWFuIEFtZXJpY2FuJyxcblx0XHRcdFx0XHQncHJvcG9ydGlvbic6IENELmFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5MzAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ05hdGl2ZSBBbWVyaWNhbicsXG5cdFx0XHRcdFx0J3Byb3BvcnRpb24nOiBDRC5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5MzAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXHRcdFx0cHJvcG9ydGlvbnMuc29ydCgoYSxiKSA9PiBhLnByb3BvcnRpb24gPCBiLnByb3BvcnRpb24pO1xuXHRcdFx0cmV0dXJuIDx1bD5cblx0XHRcdFx0eyBwcm9wb3J0aW9ucy5tYXAoKHBvcCkgPT4ge1xuXHRcdFx0XHRcdGlmIChNYXRoLnJvdW5kKHBvcC5wcm9wb3J0aW9uICogMTAwKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDxsaSBrZXk9eyAncG9wMTkzMCcgKyBwb3AubGFiZWwucmVwbGFjZSgvIC9nLCcnKSB9PnsgKE1hdGgucm91bmQocG9wLnByb3BvcnRpb24gKiAxMCkgKiAxMCkgKyAnJSAnICsgcG9wLmxhYmVsIH08L2xpPjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pfVxuXHRcdFx0XHQ8L3VsPjtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXJfcG9wdWxhdGlvbl8xOTQwICgpIHtcblx0XHRsZXQgQ0QgPSB0aGlzLnByb3BzLmNpdHlEYXRhLFxuXHRcdFx0YWdncmVnYXRlZF9wb3AgPSBDRC53aGl0ZV9wb3BfMTk0MCArIENELmJsYWNrX3BvcF8xOTQwICsgQ0QuYXNpYW5fcGFjaWZpY19pbHNsYW5kZXJfMTk0MCArIENELmFtZXJpY2FuX2luZGlhbl9lc2tpbW9fMTk0MDtcblx0XHRpZiAoYWdncmVnYXRlZF9wb3AgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcHJvcG9ydGlvbnMgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQnbGFiZWwnOiAnd2hpdGUnLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0Qud2hpdGVfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FmcmljYW4gQW1lcmljYW4nLFxuXHRcdFx0XHRcdCdwcm9wb3J0aW9uJzogQ0QuYmxhY2tfcG9wXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ0FzaWFuIEFtZXJpY2FuJyxcblx0XHRcdFx0XHQncHJvcG9ydGlvbic6IENELmFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0J2xhYmVsJzogJ05hdGl2ZSBBbWVyaWNhbicsXG5cdFx0XHRcdFx0J3Byb3BvcnRpb24nOiBDRC5hbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5NDAgLyBhZ2dyZWdhdGVkX3BvcFxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXHRcdFx0cHJvcG9ydGlvbnMuc29ydCgoYSxiKSA9PiBhLnByb3BvcnRpb24gPCBiLnByb3BvcnRpb24pO1xuXHRcdFx0cmV0dXJuIDx1bD5cblx0XHRcdFx0eyBwcm9wb3J0aW9ucy5tYXAoKHBvcCkgPT4ge1xuXHRcdFx0XHRcdGlmIChNYXRoLnJvdW5kKHBvcC5wcm9wb3J0aW9uICogMTAwKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDxsaSBrZXk9eyAncG9wMTk0MCcgKyBwb3AubGFiZWwucmVwbGFjZSgvIC9nLCcnKSB9PnsgKE1hdGgucm91bmQocG9wLnByb3BvcnRpb24gKiAxMCkgKiAxMCkgKyAnJSAnICsgcG9wLmxhYmVsIH08L2xpPjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pfVxuXHRcdFx0XHQ8L3VsPjtcblx0XHR9XG5cdH1cblxuXHRkM1Nsb3BlQ2hhcnQgPSB7XG5cdFx0d2lkdGg6IDQwMCxcblx0XHRoZWlnaHQ6IDEyNSxcblx0XHRndXR0ZXJQZXJjZW50OiA0MCxcblx0XHRndXR0ZXJMYWJlbDogNTAsXG5cdFx0bWFyZ2luOiAyMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgc2xvcGVDaGFydERhdGEpIHtcblx0XHRcdGlmIChpc05hTihzbG9wZUNoYXJ0RGF0YVswXS52MzApKSB7IFxuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0cmV0dXJuOyBcblx0XHRcdH1cblxuXHRcdFx0bGV0IHNjb3BlID0gdGhpcztcblxuXHRcdFx0Y29uc3QgbWF4ID0gZDMubWF4KHNsb3BlQ2hhcnREYXRhLCBkID0+IChkLnYzMCA+IGQudjQwKSA/IGQudjMwIDogZC52NDAgKSxcblx0XHRcdFx0bWluID0gZDMubWluKHNsb3BlQ2hhcnREYXRhLCBkID0+IChkLnYzMCA8IDAuMDEgJiYgZC52NDAgPCAwLjAxKSA/IDEwMCA6IChkLnYzMCA8IGQudjQwKSA/IGQudjMwIDogZC52NDAgKTtcblxuXHRcdFx0dmFyIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcblx0XHRcdFx0LmRvbWFpbihbbWluLCBtYXhdKVxuXHRcdFx0XHQucmFuZ2UoW3Njb3BlLmhlaWdodCAtIHNjb3BlLm1hcmdpbiwgc2NvcGUubWFyZ2luXSk7XG5cblx0XHRcdHZhciBwZXJjZW50ID0gZDMuZm9ybWF0KCcsJScpO1xuXG5cdFx0XHRsZXQgc2xvcGVDaGFydCA9IGQzLnNlbGVjdChub2RlKVxuXHRcdFx0XHQuYXBwZW5kKCdzdmcnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCBzY29wZS53aWR0aClcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLmhlaWdodClcblx0XHRcdFx0LnNlbGVjdEFsbCgnZycpXG5cdFx0XHRcdC5kYXRhKHNsb3BlQ2hhcnREYXRhKVxuXHRcdFx0XHQuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcblxuXHRcdFx0c2xvcGVDaGFydC5zZWxlY3RBbGwoJ2xpbmUnKVxuXHRcdFx0XHQuZGF0YShzbG9wZUNoYXJ0RGF0YSlcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCdsaW5lJylcblx0XHRcdFx0LmZpbHRlcihkID0+IGQudjMwID4gMC4wMSB8fCBkLnY0MCA+IDAuMDEpXG5cdFx0XHRcdC5hdHRyKCd5MScsIChkLGkpID0+IHNjYWxlKGQudjMwKSlcblx0XHRcdFx0LmF0dHIoJ3kyJywgKGQsaSkgPT4gc2NhbGUoZC52NDApKVxuXHRcdFx0XHQuYXR0cigneDEnLCBzY29wZS5ndXR0ZXJQZXJjZW50ICsgc2NvcGUuZ3V0dGVyTGFiZWwpXG5cdFx0XHRcdC5hdHRyKCd4MicsIHNjb3BlLndpZHRoIC0gKHNjb3BlLmd1dHRlclBlcmNlbnQgKyBzY29wZS5ndXR0ZXJMYWJlbCkpXG5cdFx0XHRcdC5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKTtcblxuXHRcdFx0dmFyIGxhYmVsczMwID0gc2xvcGVDaGFydC5zZWxlY3RBbGwoJ3RleHQubGFiZWxzMzAnKVxuXHRcdFx0XHQuZGF0YShzbG9wZUNoYXJ0RGF0YSlcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdFx0LmZpbHRlcihkID0+IGQudjMwID4gMC4wMSB8fCBkLnY0MCA+IDAuMDEpXG5cdFx0XHRcdC5hdHRyKCd4Jywgc2NvcGUuZ3V0dGVyUGVyY2VudCArIHNjb3BlLmd1dHRlckxhYmVsKVxuXHRcdFx0XHQuYXR0cigneScsIGQgPT4gc2NhbGUoZC52MzApKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuXHRcdFx0XHQuY2xhc3NlZCgnbGFiZWxzMzAnLCB0cnVlKVxuXHRcdFx0XHQudGV4dCgoZCkgPT4gcGVyY2VudChkLnYzMCkpO1xuXG5cdFx0XHR2YXIgbGFiZWxzNDAgPSBzbG9wZUNoYXJ0LnNlbGVjdEFsbCgndGV4dC5sYWJlbHM0MCcpXG5cdFx0XHRcdC5kYXRhKHNsb3BlQ2hhcnREYXRhKVxuXHRcdFx0XHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0XHQuZmlsdGVyKGQgPT4gZC52MzAgPiAwLjAxIHx8IGQudjQwID4gMC4wMSlcblx0XHRcdFx0LmF0dHIoJ3gnLCBzY29wZS53aWR0aCAtIChzY29wZS5ndXR0ZXJQZXJjZW50ICsgc2NvcGUuZ3V0dGVyTGFiZWwpKVxuXHRcdFx0XHQuYXR0cigneScsIGQgPT4gc2NhbGUoZC52NDApKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpXG5cdFx0XHRcdC5jbGFzc2VkKCdsYWJlbHM0MCcsIHRydWUpXG5cdFx0XHRcdC50ZXh0KChkKSA9PiBwZXJjZW50KGQudjQwKSk7XG5cblx0XHRcdHZhciBsYWJlbHMgPSBzbG9wZUNoYXJ0LnNlbGVjdEFsbCgndGV4dC5sYWJlbHMnKVxuXHRcdFx0XHQuZGF0YShzbG9wZUNoYXJ0RGF0YSlcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdFx0LmZpbHRlcihkID0+IGQudjMwID4gMC4wMSB8fCBkLnY0MCA+IDAuMDEpXG5cdFx0XHRcdC5hdHRyKCd4Jywgc2NvcGUud2lkdGggLSBzY29wZS5ndXR0ZXJMYWJlbClcblx0XHRcdFx0LmF0dHIoJ3knLCBkID0+IHNjYWxlKGQudjQwKSlcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKVxuXHRcdFx0XHQuY2xhc3NlZCgnbGFiZWxzJywgdHJ1ZSlcblx0XHRcdFx0LnRleHQoKGQpID0+IGQubGFiZWwpO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0ZDMuc2VsZWN0KG5vZGUpLmh0bWwoJycpO1xuXHRcdH1cblx0fVxuXG5cdGQzTmVzdGVkUGllQ2hhcnQgPSB7XG5cdFx0Ly8gbGF5b3V0IGNvbnN0YW50c1xuXHRcdEhFQURFUjogMjUsXG5cdFx0V0lEVEg6IDI1MCxcblx0XHRESUFNRVRFUjogMjUwLCAvLyBvZiB0aGUgZG9udXRcblx0XHRTVEFUU0hFSUdIVDogMTgsXG5cdFx0RE9OVVRXSURUSDogMzUsXG5cdFx0TUFSR0lOOiAxMCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgcmluZ3N0YXRzLCBncmFkZVN0YXRzKSB7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMocmluZ3N0YXRzKS5sZW5ndGggPT09IDApIHsgXG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRyZXR1cm47IFxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgc2NvcGUgPSB0aGlzO1x0XG5cdFx0XHR2YXIgY29sb3IgPSBmdW5jdGlvbihpKSB7IHJldHVybiBbJyM0MThlNDEnLCAnIzRhNGFlNCcsICcjZmZkZjAwJywgJyNlYjNmM2YnXVtpXTsgfTtcblx0XHRcdHZhciBjb2xvckJvcmRlciA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFsnIzQxOGU0MScsICcjNGE0YWU0JywgJyNmZmRmMDAnLCAnI2ViM2YzZiddW2ldOyB9O1xuXHRcdFx0dmFyIGNvbG9yR3JhZGUgPSBmdW5jdGlvbihncmFkZSkge1xuXHRcdFx0XHRsZXQgZ3JhZGVDb2xvcnMgPSB7J0EnOicjNDE4ZTQxJywnQic6JyM0YTRhZTQnLCdDJzonI2ZmZGYwMCcsJ0QnOicjZWIzZjNmJ307XG5cdFx0XHRcdHJldHVybiBncmFkZUNvbG9yc1tncmFkZV07XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcGllID0gZDMubGF5b3V0LnBpZSgpXG5cdFx0XHRcdC52YWx1ZSgoZCkgPT4gZC5wZXJjZW50KVxuXHRcdFx0XHQuc29ydChudWxsKTtcblx0XHRcdHZhciBhcmMgPSBkMy5zdmcuYXJjKClcblx0XHRcdFx0LmlubmVyUmFkaXVzKChkKSA9PiAoZC5kYXRhLnJpbmdJZCAtIDEuNSkgKiBzY29wZS5ET05VVFdJRFRIKVxuXHRcdFx0XHQub3V0ZXJSYWRpdXMoKGQpID0+IChkLmRhdGEucmluZ0lkIC0gMC41KSAqIHNjb3BlLkRPTlVUV0lEVEgpO1xuXHRcdFx0dmFyIGFyY0JvcmRlciA9IGQzLnN2Zy5hcmMoKVxuXHRcdFx0XHQuaW5uZXJSYWRpdXMoKGQpID0+IChkLmRhdGEucmluZ0lkIC0gMC41KSAqIHNjb3BlLkRPTlVUV0lEVEgpXG5cdFx0XHRcdC5vdXRlclJhZGl1cygoZCkgPT4gKGQuZGF0YS5yaW5nSWQgLSAwLjUpICogc2NvcGUuRE9OVVRXSURUSCk7XG5cdFx0XHR2YXIgcGVyY2VudCA9IGQzLmZvcm1hdCgnLCUnKTtcblx0XG5cdFx0XHQvLyA8Zz4gZm9yIGVhY2ggcmluZ1xuXHRcdFx0bGV0IHJpbmdOb2RlcyA9IGQzLnNlbGVjdChub2RlKVxuXHRcdFx0XHQuYXBwZW5kKCdzdmcnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCBzY29wZS5XSURUSClcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLkhFQURFUiAqIDIgKyBzY29wZS5NQVJHSU4gKiA1ICsgc2NvcGUuU1RBVFNIRUlHSFQgKyBzY29wZS5ESUFNRVRFUilcblx0XHRcdFx0LmF0dHIoJ2lkJywgJ3BpZWNoYXJ0Jylcblx0XHRcdFx0LnNlbGVjdEFsbCgnZycpXG5cdFx0XHRcdC5kYXRhKHJpbmdzdGF0cylcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKCdnJyk7XG5cdFx0XHRcdC8vLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChzY29wZS5XSURUSCAvIDIpICsgJywnICsgKHNjb3BlLkhFSUdIVCAvIDIgKyA1MCkgKyAnKScpO1xuXHRcblx0XHRcdC8vIHBhdGggZm9yIGVhY2ggcGllIHBpZWNlXG5cdFx0XHRsZXQgYnVyZ2VzcyA9IHJpbmdOb2Rlc1xuXHRcdFx0ICAuc2VsZWN0QWxsKCdwYXRoJylcblx0XHRcdCAgLmRhdGEoKGQpID0+IHBpZShkLnBlcmNlbnRzKSlcblx0XHRcdCAgLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcblx0XHRcdCAgLmZpbHRlcigoZCkgPT4gZC5kYXRhLnBlcmNlbnQgPiAwKVxuXHRcdFx0ICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHNjb3BlLldJRFRIIC8gMikgKyAnLCcgKyAoc2NvcGUuSEVBREVSICogMiArIHNjb3BlLk1BUkdJTiAqIDUgKyBzY29wZS5TVEFUU0hFSUdIVCArIHNjb3BlLkRJQU1FVEVSIC8gMikgKyAnKScpXG5cdFx0XHQgIC5hdHRyKCdkJywgYXJjKVxuXHRcdFx0ICAuYXR0cignZmlsbCcsIChkLGkpID0+IGNvbG9yR3JhZGUoZC5kYXRhLmdyYWRlKSlcblx0XHRcdCAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIChkKSA9PiBkLmRhdGEub3BhY2l0eSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZScsIChkLGkpID0+IGNvbG9yR3JhZGUoZC5kYXRhLmdyYWRlKSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApXG5cdFx0XHQgIC5hdHRyKCdkYXRhLW9wYWNpdHknLCAoZCkgPT4gZC5kYXRhLm9wYWNpdHkpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnc2xpY2VHcmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHQgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHQgIGQzLnNlbGVjdCh0aGlzKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oMjAwMClcblx0XHRcdFx0ICBcdC5hdHRyKCdmaWxsLW9wYWNpdHknLCAxKTtcblx0XHRcdFx0ICBkMy5zZWxlY3QoJyNyaW5nJyArIGQuZGF0YS5yaW5nSWQgKyAnZ3JhZGUnICsgZC5kYXRhLmdyYWRlKVxuXHRcdFx0XHQgICAgLmF0dHIoJ29wYWNpdHknLCAxKTtcblx0XHRcdFx0ICBkMy5zZWxlY3RBbGwoJy5hcmVhQmFyJylcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0LmR1cmF0aW9uKDIwMDApXG5cdFx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHNjb3BlLlNUQVRTSEVJR0hUICogMC41KVxuXHRcdFx0XHRcdC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSICsgc2NvcGUuTUFSR0lOICsgc2NvcGUuU1RBVFNIRUlHSFQgKiAwLjI1KVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgLjI1KTtcblx0XHRcdFx0ICBkMy5zZWxlY3RBbGwoJy5iYXJHcmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHRcdFx0LmZpbHRlcignLnJpbmcnICsgZC5kYXRhLnJpbmdJZClcblx0XHRcdFx0XHQuYXR0cignaGVpZ2h0Jywgc2NvcGUuU1RBVFNIRUlHSFQpXG5cdFx0XHRcdFx0LmF0dHIoJ3knLCBzY29wZS5IRUFERVIgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5kdXJhdGlvbigyMDAwKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMSk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcuYmFyR3JhZGVQZXJjZW50JyArIGQuZGF0YS5ncmFkZSlcblx0XHRcdFx0XHQuZmlsdGVyKCcucmluZycgKyBkLmRhdGEucmluZ0lkKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oNTAwKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMSk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcub3ZlcmFsbFBlcmNlbnQnKVxuXHRcdFx0XHQgIFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMCk7XG5cdFx0XHRcdCAgc2NvcGUub25Ib3ZlcihkLmRhdGEucmluZ0lkLCBkLmRhdGEuZ3JhZGUpO1xuXHRcdFx0ICB9KVxuXHRcdFx0ICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHQgIHNjb3BlLm9uSG92ZXJPdXQoKTtcblx0XHRcdFx0ICBkMy5zZWxlY3QodGhpcylcblx0XHRcdFx0ICAgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuYXR0cignZmlsbC1vcGFjaXR5JywgKGQpID0+IGQuZGF0YS5vcGFjaXR5KTtcblx0XHRcdFx0ICBkMy5zZWxlY3QoJyNyaW5nJyArIGQuZGF0YS5yaW5nSWQgKyAnZ3JhZGUnICsgZC5kYXRhLmdyYWRlIClcblx0XHRcdFx0XHQuYXR0cignb3BhY2l0eScsIDApO1xuXHRcdFx0XHQgIGQzLnNlbGVjdEFsbCgnLmFyZWFCYXInKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oMjAwMClcblx0XHRcdFx0XHQuYXR0cignaGVpZ2h0Jywgc2NvcGUuU1RBVFNIRUlHSFQpXG5cdFx0XHRcdFx0LmF0dHIoJ3knLCBzY29wZS5IRUFERVIgKyBzY29wZS5NQVJHSU4pXG5cdFx0XHRcdFx0LmF0dHIoJ29wYWNpdHknLCAuNyk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcuYXJlYUJhclBlcmNlbnQnKVxuXHRcdFx0XHQgIFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMCk7XG5cdFx0XHRcdCAgZDMuc2VsZWN0QWxsKCcub3ZlcmFsbFBlcmNlbnQnKVxuXHRcdFx0XHQgIFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMSk7XG5cdFx0XHQgIH0pO1x0XG5cblx0XHRcdC8vIGFkZCB0aGluIHN0cm9rZSBsaW5lIGZvciBlYWNoIHNsaWNlIG9mIHBpZXNcblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuc2VsZWN0QWxsKCdwYXRoLmJvcmRlcicpXG5cdFx0XHQgIC5kYXRhKChkKSA9PiBwaWUoZC5wZXJjZW50cykgKVxuXHRcdFx0ICAuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuXHRcdFx0ICAuY2xhc3NlZCgnYm9yZGVyJywgdHJ1ZSlcblx0XHRcdCAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChzY29wZS5XSURUSCAvIDIpICsgJywnICsgKHNjb3BlLkhFQURFUiAqIDIgKyBzY29wZS5NQVJHSU4gKiA1ICsgc2NvcGUuU1RBVFNIRUlHSFQgKyBzY29wZS5ESUFNRVRFUiAvIDIpICsgJyknKVxuXHRcdFx0ICAuYXR0cignZCcsIGFyY0JvcmRlcilcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpKSA9PiBjb2xvcihpKSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZScsIChkLGkpID0+IGNvbG9yQm9yZGVyKGkpKVxuXHRcdFx0ICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC4yNSlcblx0XHRcdCAgLmF0dHIoJ3N0cm9rZS1vcGFjaXR5JywgMC43KTtcblxuXHRcdFx0Ly8gYSB0cmFucGFyZW50IGJvcmRlciBhcm91bmQgZWFjaCBzbGljZVxuXHRcdFx0Ly8gaXQncyBtYWRlIG9wYXF1ZSBmb3IgaGlnaGxpZ2h0aW5nIGFuZCB0aHVzIG5lZWRzXG5cdFx0XHQvLyB0byBiZSBhZGRlZCBhZnRlciB0aGUgc2xpY2UgYW5kIHRoZSBib3JkZXJcblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuc2VsZWN0QWxsKCdwYXRocy5zbGljZUJvcmRlcicpXG5cdFx0XHQgIC5kYXRhKChkKSA9PiBwaWUoZC5wZXJjZW50cykpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG5cdFx0XHQgIC5maWx0ZXIoKGQpID0+IGQuZGF0YS5wZXJjZW50ID4gMClcblx0XHRcdCAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChzY29wZS5XSURUSCAvIDIpICsgJywnICsgKHNjb3BlLkhFQURFUiAqIDIgKyBzY29wZS5NQVJHSU4gKiA1ICsgc2NvcGUuU1RBVFNIRUlHSFQgKyBzY29wZS5ESUFNRVRFUiAvIDIpICsgJyknKVxuXHRcdFx0ICAuYXR0cignZCcsIGFyYylcblx0XHRcdCAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDApXG5cdFx0XHQgIC5hdHRyKCdzdHJva2UnLCAoZCxpKSA9PiBjb2xvckdyYWRlKGQuZGF0YS5ncmFkZSkpXG5cdFx0XHQgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKVxuXHRcdFx0ICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnc2xpY2VCb3JkZXIgZ3JhZGUnICsgZC5kYXRhLmdyYWRlKTtcblxuXHRcdFx0Ly8gYWRkIHRleHQgZm9yIGVhY2ggc2xpY2Ugb2YgcGllXG5cdFx0XHRyaW5nTm9kZXNcblx0XHRcdCAgLnNlbGVjdEFsbCgndGV4dC5idXJnZXNzU2xpY2VQZXJjZW50Jylcblx0XHRcdCAgLmRhdGEoKGQpID0+IHBpZShkLnBlcmNlbnRzKSApXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG5cdFx0XHQgIC5maWx0ZXIoKGQpID0+IGQuZGF0YS5wZXJjZW50ID4gMClcblx0XHRcdCAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiAndHJhbnNsYXRlKCcgKyAoYXJjLmNlbnRyb2lkKGQpWzBdICsgc2NvcGUuV0lEVEggLyAyKSArICcsJyArIChhcmMuY2VudHJvaWQoZClbMV0gKyBzY29wZS5IRUFERVIgKiAyICsgc2NvcGUuTUFSR0lOICogNSArIHNjb3BlLlNUQVRTSEVJR0hUICsgc2NvcGUuRElBTUVURVIgLyAyKSArICcpJylcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC5zdHlsZSgnZm9udCcsICcxMXB4IEFyaWFsJylcblx0XHRcdCAgLmF0dHIoJ2R5JywgNS41KVxuXHRcdFx0ICBcblx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAwKVxuXHRcdFx0ICAuYXR0cignaWQnLCAoZCkgPT4gJ3JpbmcnICsgZC5kYXRhLnJpbmdJZCArICdncmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnYnVyZ2Vzc1NsaWNlUGVyY2VudCBncmFkZScgKyBkLmRhdGEuZ3JhZGUpXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IChkLmRhdGEuZ3JhZGUgPT0gJ0MnKSA/ICdibGFjaycgOiAnd2hpdGUnKVxuXHRcdFx0ICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG5cdFx0XHQgIC50ZXh0KChkKSA9PiBwZXJjZW50KGQudmFsdWUpKTtcblxuXHRcdFx0cmluZ05vZGVzXG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuXHRcdFx0ICAuZGF0YShyaW5nc3RhdHMpXG5cdFx0XHQgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkLGksaikgPT4gJ2FyZWFCYXIgYmFyR3JhZGUnICsgZC5wZXJjZW50c1tqXS5ncmFkZSArICcgcmluZycgKyAoaSArIDEpKVxuXHRcdFx0ICAuYXR0cignaGVpZ2h0Jywgc2NvcGUuU1RBVFNIRUlHSFQpXG5cdFx0XHQgIC5hdHRyKCd3aWR0aCcsIChkLGksaikgPT4gTWF0aC5yb3VuZChkLnBlcmNlbnRzW2pdLm92ZXJhbGxQZXJjZW50ICogc2NvcGUuV0lEVEgpKVxuXHRcdFx0ICAuYXR0cignb3BhY2l0eScsIC43KVxuXHRcdFx0ICAuYXR0cigneScsIHNjb3BlLkhFQURFUiArIHNjb3BlLk1BUkdJTilcblx0XHRcdCAgLmF0dHIoJ3gnLCAoZCxpLGopID0+IHtcblx0XHRcdFx0bGV0IHggPSAwO1xuXHRcdFx0XHRmb3IgKGxldCBqMCA9IDA7IGowIDw9IDM7IGowKyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpMCA9IDA7IGkwIDw9IDM7IGkwKyspIHtcblx0XHRcdFx0XHRcdGlmIChyaW5nc3RhdHNbajBdLnBlcmNlbnRzW2kwXS5ncmFkZSA8IGQucGVyY2VudHNbal0uZ3JhZGUgfHwgKHJpbmdzdGF0c1tqMF0ucGVyY2VudHNbaTBdLmdyYWRlID09IGQucGVyY2VudHNbal0uZ3JhZGUgJiYgcmluZ3N0YXRzW2owXS5wZXJjZW50c1tpMF0ucmluZ0lkIDwgZC5wZXJjZW50c1tqXS5yaW5nSWQpKSB7XG5cdFx0XHRcdFx0XHRcdHgrPSBNYXRoLnJvdW5kKHJpbmdzdGF0c1tqMF0ucGVyY2VudHNbaTBdLm92ZXJhbGxQZXJjZW50ICogc2NvcGUuV0lEVEgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdCAgfSlcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpLGopID0+IGNvbG9yKGopKVxuXHRcdFx0ICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSxqKSB7XG5cdFx0XHRcdGxldCBncmFkZSA9IFsnQScsJ0InLCdDJywnRCddW2pdO1xuXHRcdFx0XHRkMy5zZWxlY3RBbGwoJy5hcmVhQmFyJylcblx0XHRcdFx0ICAudHJhbnNpdGlvbigpXG5cdFx0XHRcdCAgLmR1cmF0aW9uKDEwMDApXG5cdFx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAuNCk7XG5cdFx0XHRcdGQzLnNlbGVjdEFsbCgncmVjdC5iYXJHcmFkZScgKyBncmFkZSlcblx0XHRcdFx0ICAudHJhbnNpdGlvbigpXG5cdFx0XHRcdCAgLmR1cmF0aW9uKDEwMDApXG5cdFx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAxKTtcblx0XHRcdFx0ZDMuc2VsZWN0QWxsKCcuc2xpY2VCb3JkZXInKVxuXHRcdFx0XHQgIC5maWx0ZXIoJy5ncmFkZScgKyBncmFkZSlcblx0XHRcdFx0ICAudHJhbnNpdGlvbigpXG5cdFx0XHRcdCAgLmR1cmF0aW9uKDEwMDApXG5cdFx0XHRcdCAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDUpO1xuXHRcdFx0XHRkMy5zZWxlY3RBbGwoJy5idXJnZXNzU2xpY2VQZXJjZW50Jylcblx0XHRcdFx0ICAuZmlsdGVyKCcuZ3JhZGUnICsgZ3JhZGUpXG5cdFx0XHRcdCAgLmZpbHRlcigoZCkgPT4gZC5kYXRhLnBlcmNlbnQgPiAuMDYpXG5cdFx0XHRcdCAgLnRyYW5zaXRpb24oKVxuXHRcdFx0XHQgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcblx0XHRcdFx0ICAuYXR0cignb3BhY2l0eScsIDEpO1xuXHRcdFx0XHRzY29wZS5vbkdyYWRlSG92ZXIoZ3JhZGUpO1xuXHRcdFx0ICB9KS5cblx0XHRcdCAgb24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpLGopIHtcblx0XHRcdFx0bGV0IGdyYWRlID0gWydBJywnQicsJ0MnLCdEJ11bal07XG5cdFx0XHRcdGQzLnNlbGVjdEFsbCgnLmFyZWFCYXInKVxuXHRcdFx0XHQgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0ICAuYXR0cignb3BhY2l0eScsIC43KTtcblx0XHRcdFx0ZDMuc2VsZWN0QWxsKCcuc2xpY2VCb3JkZXInKVxuXHRcdFx0XHQgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0ICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XG5cdFx0XHRcdGQzLnNlbGVjdEFsbCgnLmJ1cmdlc3NTbGljZVBlcmNlbnQnKVxuXHRcdFx0XHQgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0ICAuYXR0cignb3BhY2l0eScsIDApXG5cdFx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCkgPT4gKGQuZGF0YS5ncmFkZSA9PSAnQycpID8gJ2JsYWNrJyA6ICd3aGl0ZScpO1xuXHRcdFx0XHRzY29wZS5vbkdyYWRlSG92ZXJPdXQoKTtcblx0XHRcdCAgfSk7XG5cblx0XHRcdC8vIHBlcmNlbnRzIGZvciBlYWNoIG9mIHRoZXNlIHNsaWNlcyBpbiB0aGUgYXJlYSBjaGFydFxuXHRcdFx0cmluZ05vZGVzXG5cdFx0XHQgIC5zZWxlY3RBbGwoJ3RleHQuc2xpY2VQZXJjZW50Jylcblx0XHRcdCAgLmRhdGEocmluZ3N0YXRzKVxuXHRcdFx0ICAuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0ICAuYXR0cigneCcsIChkLGksaikgPT4ge1xuXHRcdFx0XHRsZXQgeCA9IDA7XG5cdFx0XHRcdGZvciAobGV0IGowID0gMDsgajAgPD0gMzsgajArKykge1xuXHRcdFx0XHRcdGZvciAobGV0IGkwID0gMDsgaTAgPD0gMzsgaTArKykge1xuXHRcdFx0XHRcdFx0aWYgKHJpbmdzdGF0c1tqMF0ucGVyY2VudHNbaTBdLmdyYWRlIDwgZC5wZXJjZW50c1tqXS5ncmFkZSB8fCAocmluZ3N0YXRzW2owXS5wZXJjZW50c1tpMF0uZ3JhZGUgPT0gZC5wZXJjZW50c1tqXS5ncmFkZSAmJiByaW5nc3RhdHNbajBdLnBlcmNlbnRzW2kwXS5yaW5nSWQgPCBkLnBlcmNlbnRzW2pdLnJpbmdJZCkpIHtcblx0XHRcdFx0XHRcdFx0eCs9IE1hdGgucm91bmQocmluZ3N0YXRzW2owXS5wZXJjZW50c1tpMF0ub3ZlcmFsbFBlcmNlbnQgKiBzY29wZS5XSURUSCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHggKz0gTWF0aC5yb3VuZChkLnBlcmNlbnRzW2pdLm92ZXJhbGxQZXJjZW50ICogc2NvcGUuV0lEVEggLyAyKTtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHQgIH0pXG5cdFx0XHQgIC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSICsgc2NvcGUuTUFSR0lOICsgMTMpXG5cdFx0XHQgIC5hdHRyKCdjbGFzcycsIChkLGksaikgPT4gJ2FyZWFCYXJQZXJjZW50IGJhckdyYWRlUGVyY2VudCcgKyBkLnBlcmNlbnRzW2pdLmdyYWRlICsgJyByaW5nJyArIChpICsgMSkpXG5cdFx0XHQgIC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJylcblx0XHRcdCAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMHB4Jylcblx0XHRcdCAgLmF0dHIoJ2ZpbGwnLCAoZCxpLGopID0+IChkLnBlcmNlbnRzW2pdLmdyYWRlID09ICdDJykgPyAnYmxhY2snIDogJ3doaXRlJylcblx0XHRcdCAgLmF0dHIoJ29wYWNpdHknLCAwKVxuXHRcdFx0ICAudGV4dCgoZCxpLGopID0+IHBlcmNlbnQoZC5wZXJjZW50c1tqXS5vdmVyYWxsUGVyY2VudCkpO1xuXG5cdFx0XHRyaW5nTm9kZXNcblx0XHRcdCAgLnNlbGVjdEFsbCgndGV4dC5vdmVyYWxsUGVyY2VudCcpXG5cdFx0XHQgIC5kYXRhKGdyYWRlU3RhdHMpXG5cdFx0XHQgIC5lbnRlcigpXG5cdFx0XHQgIC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0ICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG5cdFx0XHRcdGxldCB4ID0gZC5wZXJjZW50ICogc2NvcGUuV0lEVEggLyAyO1xuXHRcdFx0XHRmb3IgKGxldCBpMCA9IDA7IGkwIDwgaTsgaTArKykge1xuXHRcdFx0XHRcdHggKz0gZ3JhZGVTdGF0c1tpMF0ucGVyY2VudCAqIHNjb3BlLldJRFRIO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0ICB9KVxuXHRcdFx0ICAuYXR0cigneScsIHNjb3BlLkhFQURFUiArIHNjb3BlLk1BUkdJTiArIDEzKVxuXHRcdFx0ICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG5cdFx0XHQgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuXHRcdFx0ICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXG5cdFx0XHQgIC5hdHRyKCdmb250LXNpemUnLCAnMTBweCcpXG5cdFx0XHQgIC5hdHRyKCdmaWxsJywgKGQpID0+IChkLmdyYWRlID09ICdDJykgPyAnYmxhY2snIDogJ3doaXRlJylcblx0XHRcdCAgLmNsYXNzZWQoJ292ZXJhbGxQZXJjZW50JywgdHJ1ZSlcblx0XHRcdCAgLnRleHQoKGQpID0+IHBlcmNlbnQoZC5wZXJjZW50KSk7XG5cblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdCAgLmF0dHIoJ3gnLCBzY29wZS5XSURUSCAvIDIpXG5cdFx0XHQgIC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSKVxuXHRcdFx0ICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcblx0XHRcdCAgLnRleHQoJ0dyYWRpbmcgaW4gVGVybXMgb2YgQXJlYScpO1xuXG5cdFx0XHRyaW5nTm9kZXNcblx0XHRcdCAgLmFwcGVuZCgndGV4dCcpXG5cdFx0XHQgIC5hdHRyKCd4Jywgc2NvcGUuV0lEVEggLyAyKVxuXHRcdFx0ICAuYXR0cigneScsIHNjb3BlLkhFQURFUiArIHNjb3BlLk1BUkdJTiAqIDQgKyBzY29wZS5TVEFUU0hFSUdIVClcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC50ZXh0KCdHcmFkaW5nICYgRGVuc2l0eSBPdXR3YXJkJyk7XG5cblx0XHRcdHJpbmdOb2Rlc1xuXHRcdFx0ICAuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdCAgLmF0dHIoJ3gnLCBzY29wZS5XSURUSCAvIDIpXG5cdFx0XHQgIC5hdHRyKCd5Jywgc2NvcGUuSEVBREVSICogMiArIHNjb3BlLk1BUkdJTiAqIDQgKyBzY29wZS5TVEFUU0hFSUdIVClcblx0XHRcdCAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG5cdFx0XHQgIC50ZXh0KCdmcm9tIENpdHkgQ2VudGVyJyk7XG5cblx0XHRcdGQzLnhtbCgnc3RhdGljL2J1cmdlc3Muc3ZnJykuZ2V0KChlcnJvciwgeG1sKSA9PiB7XG5cdFx0XHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cblx0XHRcdFx0bGV0IGJ1cmdlc3NEaWFncmFtID0gcmluZ05vZGVzLm5vZGUoKS5hcHBlbmRDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblxuXHRcdFx0XHR2YXIgaW5uZXJTVkcgPSByaW5nTm9kZXMuc2VsZWN0KFwic3ZnXCIpO1xuXG5cdFx0XHRcdGlubmVyU1ZHXG5cdFx0XHRcdFx0LmF0dHIoJ3gnLCAtNSlcblx0XHRcdFx0XHQuYXR0cigneScsIDEwMik7XG5cblx0XHRcdFx0aW5uZXJTVkcudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMDAwKVxuXHRcdFx0XHRcdC5hdHRyKCdvcGFjaXR5JywgLjM1KTtcblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gYm91bmQgaW4gY29tcG9uZW50RGlkTW91bnQgdG8gdGhlIGFyZWFTZWxlY3RlZCBtZXRob2Qgb2YgQXBwIChwYXNzZWQgaW4gYXMgYSBwcm9wcylcblx0XHR9LFxuXG5cdFx0b25Ib3Zlck91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBib3VuZCBpbiBjb21wb25lbnREaWRNb3VudCB0byB0aGUgYXJlYVVuc2VsZWN0ZWQgbWV0dGhvZCBvZiBBcHBcblx0XHR9LFxuXG5cdFx0b25HcmFkZUhvdmVyOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGJvdW5kIGluIGNvbXBvbmVudERpZE1vdW50IHRvIHRoZSBncmFkZVNlbGVjdGVkIG1ldGhvZCBvZiBBcHAgKHBhc3NlZCBpbiBhcyBhIHByb3BzKVxuXHRcdH0sXG5cblx0XHRvbkdyYWRlSG92ZXJPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gYm91bmQgaW4gY29tcG9uZW50RGlkTW91bnQgdG8gdGhlIGdyYWRlVW5zZWxlY3RlZCBtZXR0aG9kIG9mIEFwcFxuXHRcdH0sXG5cdFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRkMy5zZWxlY3Qobm9kZSkuaHRtbCgnJyk7XG5cdFx0fVxuXHR9XG5cbn07XG4iLCJpbXBvcnQgUmVhY3QsIHtQcm9wVHlwZXN9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBhdGgsIFByb3BUeXBlcyBhcyBMZWFmbGV0UHJvcFR5cGVzIH0gZnJvbSAncmVhY3QtbGVhZmxldCc7XG5pbXBvcnQgZG9udXQgZnJvbSAnLi9MLkRvbnV0LmpzJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb251dCBleHRlbmRzIFBhdGgge1xuXHQvLyBSYWRpaSBhcmUgaW4gbWV0ZXJzXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0Y2VudGVyOiBMZWFmbGV0UHJvcFR5cGVzLmxhdGxuZy5pc1JlcXVpcmVkLFxuXHRcdG91dGVyUmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cdFx0aW5uZXJSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcblx0fTtcblxuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge307XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRjb25zdCB7Y2VudGVyLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XG5cdFx0c3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0dGhpcy5sZWFmbGV0RWxlbWVudCA9IG5ldyBkb251dChjZW50ZXIsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgcHJvcHMpO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuXHRcdGlmICh0aGlzLnByb3BzLmNlbnRlciAhPT0gcHJldlByb3BzLmNlbnRlcikge1xuXHRcdFx0dGhpcy5sZWFmbGV0RWxlbWVudC5zZXRMYXRMbmcodGhpcy5wcm9wcy5jZW50ZXIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BzLm91dGVyUmFkaXVzICE9PSBwcmV2UHJvcHMub3V0ZXJSYWRpdXMgfHwgdGhpcy5wcm9wcy5pbm5lclJhZGl1cyAhPT0gcHJldlByb3BzLmlubmVyUmFkaXVzKSB7XG5cdFx0XHR0aGlzLmxlYWZsZXRFbGVtZW50LnNldFJhZGl1cyh0aGlzLnByb3BzLm91dGVyUmFkaXVzLCB0aGlzLnByb3BzLmlubmVyUmFkaXVzKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldFN0eWxlSWZDaGFuZ2VkKHByZXZQcm9wcywgdGhpcy5wcm9wcyk7XG5cdH1cbn0iLCJpbXBvcnQgKiBhcyBMIGZyb20gJ2xlYWZsZXQnO1xuXG5jb25zdCBEb251dCA9IChmdW5jdGlvbiAoTCkge1xuXG5cdHJldHVybiBMLkNpcmNsZS5leHRlbmQoe1xuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBvcHRpb25zKSB7XG5cdFx0XHRMLlBhdGgucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHRcdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHRcdHRoaXMuX21PdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuXHRcdFx0dGhpcy5fbUlubmVyUmFkaXVzID0gdGhpcy5fdmFsaWRhdGVJbm5lclJhZGl1cyhvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuXHRcdH0sXG5cblx0XHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpIHtcblx0XHRcdHRoaXMuX21PdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuXHRcdFx0dGhpcy5fbUlubmVyUmFkaXVzID0gdGhpcy5fdmFsaWRhdGVJbm5lclJhZGl1cyhvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdFx0fSxcblxuXHRcdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbG5nUmFkaXVzID0gdGhpcy5fZ2V0TG5nUmFkaXVzKCksXG5cdFx0XHRcdCAgbGF0bG5nID0gdGhpcy5fbGF0bG5nLFxuXHRcdFx0XHQgIG91dGVyUG9pbnRMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZyAtIGxuZ1JhZGl1c1swXV0pLFxuXHRcdFx0XHQgIGlubmVyUG9pbnRMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZyAtIGxuZ1JhZGl1c1sxXV0pO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKTtcblx0XHRcdHRoaXMuX291dGVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5fcG9pbnQueCAtIG91dGVyUG9pbnRMZWZ0LngsIDEpO1xuXHRcdFx0dGhpcy5faW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLl9wb2ludC54IC0gaW5uZXJQb2ludExlZnQueCwgMSk7XG5cdFx0fSxcblxuXHRcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxuZ1JhZGl1cyA9IHRoaXMuX2dldExuZ1JhZGl1cygpWzBdLFxuXHRcdFx0XHQgIGxhdFJhZGl1cyA9IHRoaXMuX2dldExhdFJhZGl1cygpWzBdLFxuXHRcdFx0XHQgIGxhdGxuZyA9IHRoaXMuX2xhdGxuZztcblxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHRcdFx0XHRcdFx0W2xhdGxuZy5sYXQgLSBsYXRSYWRpdXMsIGxhdGxuZy5sbmcgLSBsbmdSYWRpdXNdLFxuXHRcdFx0XHRcdFx0XHRbbGF0bG5nLmxhdCArIGxhdFJhZGl1cywgbGF0bG5nLmxuZyArIGxuZ1JhZGl1c10pO1xuXHRcdH0sXG5cblx0XHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBbdGhpcy5fbU91dGVyUmFkaXVzLCB0aGlzLl9tSW5uZXJSYWRpdXNdO1xuXHRcdH0sXG5cblx0XHRfZ2V0TGF0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gWyh0aGlzLl9tT3V0ZXJSYWRpdXMgLyA0MDA3NTAxNykgKiAzNjAsICh0aGlzLl9tSW5uZXJSYWRpdXMgLyA0MDA3NTAxNykgKiAzNjBdO1xuXHRcdH0sXG5cblx0XHRfZ2V0TG5nUmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcmFkaWkgPSB0aGlzLl9nZXRMYXRSYWRpdXMoKTtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0KHJhZGlpWzBdIC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIHRoaXMuX2xhdGxuZy5sYXQpKSxcblx0XHRcdFx0KHJhZGlpWzFdIC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIHRoaXMuX2xhdGxuZy5sYXQpKVxuXHRcdFx0XTtcblx0XHR9LFxuXG5cdFx0X2NoZWNrSWZFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdnAgPSB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCxcblx0XHRcdFx0ICBvdXRlclJhZGl1cyA9IHRoaXMuX291dGVyUmFkaXVzLFxuXHRcdFx0XHQgIHAgPSB0aGlzLl9wb2ludDtcblxuXHRcdFx0cmV0dXJuIHAueCAtIG91dGVyUmFkaXVzID4gdnAubWF4LnggfHwgcC55IC0gb3V0ZXJSYWRpdXMgPiB2cC5tYXgueSB8fFxuXHRcdFx0XHRcdFx0IHAueCArIG91dGVyUmFkaXVzIDwgdnAubWluLnggfHwgcC55ICsgb3V0ZXJSYWRpdXMgPCB2cC5taW4ueTtcblx0XHR9LFxuXG5cdFx0X3ZhbGlkYXRlSW5uZXJSYWRpdXM6IGZ1bmN0aW9uKG91dGVyLCBpbm5lcikge1xuXHRcdFx0aWYgKGlubmVyID49IG91dGVyKSByZXR1cm4gb3V0ZXIgLSAxO1xuXHRcdFx0cmV0dXJuIGlubmVyO1xuXHRcdH0sXG5cblx0XHRnZXRBcmM6IGZ1bmN0aW9uKHB0LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpIHtcblx0XHRcdHZhciB4MiA9IHB0LnggLSAwLjAxO1xuXHRcdFx0dmFyIHkxID0gcHQueSAtIG91dGVyUmFkaXVzO1xuXHRcdFx0dmFyIHkyID0gcHQueSAtIGlubmVyUmFkaXVzO1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHQnTScsIHB0LngsIHkxLFxuXHRcdFx0XHQnQScsIG91dGVyUmFkaXVzLCBvdXRlclJhZGl1cywgMCwgMSwgMSwgeDIsIHkxLFxuXHRcdFx0XHQnTScsIHgyLCB5Mixcblx0XHRcdFx0J0EnLCBpbm5lclJhZGl1cywgaW5uZXJSYWRpdXMsIDAsIDEsIDAsIHB0LngsIHkyLFxuXHRcdFx0XHQnWidcblx0XHRcdF0uam9pbignICcpO1xuXHRcdH0sXG5cblx0XHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0XHQgIG91dGVyUmFkaXVzID0gdGhpcy5fb3V0ZXJSYWRpdXMsXG5cdFx0XHRcdCAgaW5uZXJSYWRpdXMgPSB0aGlzLl9pbm5lclJhZGl1cztcblxuXHRcdFx0aWYgKHRoaXMuX2NoZWNrSWZFbXB0eSgpKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKEwuQnJvd3Nlci5zdmcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXJjKHAsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cyk7XG5cdFx0XHR9IGVsc2UgeyAvLyBUT0RPOiBWTUwgRG9udXQgcGF0aFxuXHRcdFx0XHRwLl9yb3VuZCgpO1xuXHRcdFx0XHRyID0gTWF0aC5yb3VuZChyKTtcblx0XHRcdFx0cmV0dXJuICdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgb3V0ZXJSYWRpdXMgKyAnLCcgKyBvdXRlclJhZGl1cyArICcgMCwnICsgKDY1NTM1ICogMzYwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KShMKTtcblxuZXhwb3J0IGRlZmF1bHQgRG9udXQ7IiwiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG93bmxvYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRtYXB1cmw6IFByb3BUeXBlcy5zdHJpbmcsXG5cdFx0bmFtZTogUHJvcFR5cGVzLnN0cmluZ1xuXHR9O1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0cmVuZGVyICgpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J2Rvd25sb2FkX21lbnUnPlxuXHRcdFx0PHVsPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PGgzPjxhIGhyZWY9e3RoaXMucHJvcHMubWFwdXJsfSBkb3dubG9hZD17IHRoaXMucHJvcHMubmFtZSArICdIT0xDTWFwLmpwZyd9PkRvd25sb2FkIEhPTEMgbWFwPC9hPjwvaDM+XG5cdFx0XHRcdFx0PGltZyBzcmM9e3RoaXMucHJvcHMubWFwVGh1bWJuYWlsIH0gLz5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdDxoMz48YSBocmVmPXt0aGlzLnByb3BzLm1hcHVybH0gZG93bmxvYWQ9eyB0aGlzLnByb3BzLm5hbWUgKyAnSE9MQ01hcC5qcGcnfT5Eb3dubG9hZCBIT0xDIGFyZWEgZGVzY3JpcHRpb248L2E+PC9oMz5cblx0XHRcdFx0XHQ8aW1nIHNyYz17dGhpcy5wcm9wcy5tYXBUaHVtYm5haWwgfSAvPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0PGgzPjxhIGhyZWY9e3RoaXMucHJvcHMubWFwdXJsfSBkb3dubG9hZD17IHRoaXMucHJvcHMubmFtZSArICdIT0xDTWFwLmpwZyd9PkRvd25sb2FkIEhPTEMgZ2VvcmVmZXJlbmNlZCBtYXA8L2E+PC9oMz5cblx0XHRcdFx0XHQ8aW1nIHNyYz17dGhpcy5wcm9wcy5tYXBUaHVtYm5haWwgfSAvPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0PC91bD5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn0iLCJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDaXR5U25pcHBldCBmcm9tICcuL0NpdHlTbmlwcGV0LmpzeCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVTdGF0cyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8vIHByb3BlcnR5IHZhbGlkYXRpb25cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHRzdGF0ZU5hbWU6IFByb3BUeXBlcy5zdHJpbmdcblx0fTtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdHJlbmRlciAoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxoMj57IHRoaXMucHJvcHMuc3RhdGVOYW1lIH08L2gyPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuY2l0aWVzLm1hcCgoY2l0eURhdGEpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gPENpdHlTbmlwcGV0IFxuXHRcdFx0XHRcdFx0Y2l0eURhdGE9eyBjaXR5RGF0YSB9IFxuXHRcdFx0XHRcdFx0b25DaXR5Q2xpY2s9eyB0aGlzLnByb3BzLm9uQ2l0eUNsaWNrIH0gXG5cdFx0XHRcdFx0XHRrZXk9eyAnY2l0eScgKyBjaXR5RGF0YS5jaXR5SWQgfSBcblx0XHRcdFx0XHRcdGFyZWFDaGFydFdpZHRoPXsgdGhpcy5wcm9wcy5hcmVhQ2hhcnRXaWR0aCB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0fSkgfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBcHBBY3Rpb25UeXBlcyB9IGZyb20gJy4uL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuaW1wb3J0IENpdHlTbmlwcGV0IGZyb20gJy4vQ2l0eVNuaXBwZXQuanN4JztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlQWhlYWRDaXR5U25pcHBldCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cblx0Y29uc3RydWN0b3IgKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2PlxuXHRcdFx0XHR7IHRoaXMucHJvcHMub3B0aW9ucy5tYXAoKGNpdHlEYXRhKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIDxDaXR5U25pcHBldCBjaXR5RGF0YT17IGNpdHlEYXRhIH0gb25DaXR5Q2xpY2s9eyB0aGlzLnByb3BzLm9uT3B0aW9uU2VsZWN0ZWQgfSBkaXNwbGF5U3RhdGU9eyB0cnVlIH0ga2V5PXsgJ2NpdHknICsgY2l0eURhdGEuY2l0eUlkIH0gLz5cblx0XHRcdFx0fSkgfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAuanN4JztcblxuLy9wcm9jZXNzLmVudi5OT0RFX0VOViA9ICdkZXZlbG9wbWVudCc7XG4vL2ltcG9ydCBQZXJmIGZyb20gJ3JlYWN0LWFkZG9ucy1wZXJmJztcbi8vd2luZG93LlBlcmYgPSBQZXJmO1xuXG4vL1BlcmYuc3RhcnQoKTtcblxuUmVhY3RET00ucmVuZGVyKDxBcHAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcC1jb250YWluZXInKSk7XG4vL1BlcmYuc3RvcCgpO1xuLy9QZXJmLnByaW50V2FzdGVkKCk7IiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBBcHBEaXNwYXRjaGVyIGZyb20gJy4uL3V0aWxzL0FwcERpc3BhdGNoZXInO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDYXJ0b0RCTG9hZGVyIGZyb20gJy4uL3V0aWxzL0NhcnRvREJMb2FkZXInO1xuaW1wb3J0IGZvcm1zTWV0YWRhdGEgZnJvbSAnLi4vLi4vZGF0YS9mb3Jtc01ldGFkYXRhLmpzb24nO1xuaW1wb3J0IE1hcFN0YXRlU3RvcmUgZnJvbSAnLi4vc3RvcmVzL01hcFN0YXRlU3RvcmUnO1xuXG5cbmNvbnN0IEFyZWFEZXNjcmlwdGlvbnNTdG9yZSA9IHtcblxuXHRkYXRhOiB7XG5cdFx0YWRJZHM6IFtdLFxuXHRcdGFyZWFEZXNjcmlwdGlvbnM6IHt9XG5cdH0sXG5cblx0ZGF0YUxvYWRlcjogQ2FydG9EQkxvYWRlcixcblxuXHRsb2FkRGF0YTogZnVuY3Rpb24gKGFkSWRzKSB7XG5cblx0XHR0aGlzLmRhdGEuYWRJZHMgPSBhZElkcy5tYXAoYWRJZCA9PiBwYXJzZUludChhZElkKSk7XG5cblx0XHQvLyBjcmVhdGUgcXVlcmllcyBmb3IgdGhvc2UgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbiBtZW1vcnlcblx0XHRsZXQgcXVlcmllcyA9IFtdO1xuXHRcdGFkSWRzLmZvckVhY2goYWRJZCA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSB7XG5cdFx0XHRcdHF1ZXJpZXMucHVzaCh7XG5cdFx0XHRcdFx0cXVlcnk6ICdTRUxFQ1QgaG9sY19hZHMuY2l0eV9pZCBhcyBhZF9pZCwgZm9ybV9pZCwgaG9sY19pZCwgaG9sY19ncmFkZSwgcG9seWdvbl9pZCwgY2F0X2lkLCBzdWJfY2F0X2lkLCBfb3JkZXIgYXMgb3JkZXIsIGRhdGEsIFNUX2FzZ2VvanNvbiAoaG9sY19wb2x5Z29ucy50aGVfZ2VvbSwgNCkgYXMgdGhlX2dlb2pzb24sIHN0X3htaW4oc3RfZW52ZWxvcGUoZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMudGhlX2dlb20pKSBhcyBiYnhtaW4sIHN0X3ltaW4oc3RfZW52ZWxvcGUoZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMudGhlX2dlb20pKSBhcyBiYnltaW4sIHN0X3htYXgoc3RfZW52ZWxvcGUoZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMudGhlX2dlb20pKSBhcyBiYnhtYXgsIHN0X3ltYXgoc3RfZW52ZWxvcGUoZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMudGhlX2dlb20pKSBhcyBiYnltYXgsc3RfYXJlYShob2xjX3BvbHlnb25zLnRoZV9nZW9tOjpnZW9ncmFwaHkpLzEwMDAwMDAgKiAwLjM4NjEwMiBhcyBzcW1pIEZST00gaG9sY19hZF9kYXRhIHJpZ2h0IGpvaW4gaG9sY19wb2x5Z29ucyBvbiBob2xjX2FkX2RhdGEucG9seWdvbl9pZCA9IGhvbGNfcG9seWdvbnMubmVpZ2hib3Job29kX2lkIGpvaW4gaG9sY19hZHMgb24gaG9sY19hZHMuY2l0eV9pZCA9IGhvbGNfcG9seWdvbnMuYWRfaWQgd2hlcmUgaG9sY19hZHMuY2l0eV9pZCA9ICcgKyBhZElkICsgJyBvcmRlciBieSBob2xjX2lkLCBjYXRfaWQsIHN1Yl9jYXRfaWQsIF9vcmRlcicsXG5cdFx0XHRcdFx0Zm9ybWF0OiAnSlNPTidcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmRhdGFMb2FkZXIucXVlcnkocXVlcmllcykudGhlbigocmVzcG9uc2VzKSA9PiB7XG5cdFx0XHRyZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWRJZCA9IHJlc3BvbnNlWzBdLmFkX2lkO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdID0ge1xuXHRcdFx0XHRcdFx0Zm9ybUlkOiByZXNwb25zZVswXS5mb3JtX2lkLFxuXHRcdFx0XHRcdFx0YnlOZWlnaGJvcmhvb2Q6IHRoaXMucGFyc2VBcmVhRGVzY3JpcHRpb25zKHJlc3BvbnNlKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlDYXRlZ29yeSA9IHRoaXMucGFyc2VBRHNCeUNhdCh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZCk7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYXJlYSA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKS5tYXAoKEhPTENJZCwgaSkgPT4gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbSE9MQ0lkXS5zcW1pICkucmVkdWNlKChhLGIpID0+IGErYiwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblxuXHRcdH0sIChlcnJvcikgPT4ge1xuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIHRoaXMuXG5cdFx0XHRjb25zb2xlLmxvZygnQXJlYURlc2NyaXB0aW9uc1N0b3JlIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHBhcnNlQXJlYURlc2NyaXB0aW9uczogZnVuY3Rpb24ocmF3QWREYXRhKSB7XG5cdFx0bGV0IGFkRGF0YSA9IHt9O1xuXG5cdFx0Zm9yKHZhciByb3cgaW4gcmF3QWREYXRhKSB7XG5cdFx0XHRsZXQgZCA9IHJhd0FkRGF0YVtyb3ddO1xuXG5cdFx0XHQvLyBkZWZpbmUgaWQgaWYgdW5kZWZpbmVkXG5cdFx0XHRpZih0eXBlb2YgYWREYXRhW2QuaG9sY19pZF0gPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0gPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIGFzc2lnbiBwcm9wZXJ0aWVzICAgIFxuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYV9nZW9qc29uID0gKCFhZERhdGFbZC5ob2xjX2lkXS5hcmVhX2dlb2pzb24pID8gSlNPTi5wYXJzZShkLnRoZV9nZW9qc29uKSA6IGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFfZ2VvanNvbjtcblx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFfZ2VvanNvbl9pbnZlcnRlZCA9ICghYWREYXRhW2QuaG9sY19pZF0uYXJlYV9nZW9qc29uX2ludmVydGVkKSA/IHRoaXMucGFyc2VJbnZlcnRlZEdlb0pzb24oSlNPTi5wYXJzZShkLnRoZV9nZW9qc29uKSkgOiBhZERhdGFbZC5ob2xjX2lkXS5hcmVhX2dlb2pzb25faW52ZXJ0ZWQ7XG5cdFx0XHRhZERhdGFbZC5ob2xjX2lkXS5ib3VuZGluZ0JveCA9IFtbZC5iYnhtaW4sZC5iYnltaW5dLFtkLmJieG1heCxkLmJieW1heF1dO1xuXHRcdFx0Ly9hZERhdGFbZC5ob2xjX2lkXS5uYW1lID0gZC5uYW1lO1xuXHRcdFx0YWREYXRhW2QuaG9sY19pZF0uaG9sY19ncmFkZSA9IGQuaG9sY19ncmFkZTtcblx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLnNxbWkgPSBkLnNxbWk7XG5cdFx0XHRcblx0XHRcdC8vIGRlZmluZSBhcmVhIGRlc2NyaXB0aW9uIGlmIHVuZGVmaW5lZFxuXHRcdFx0aWYodHlwZW9mIGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjID0ge307XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGRlZmluZSBjYXRlZ29yeSBpZCBmb3IgYXJlYSBkZXNjcmlwdGlvbiBpZiB1bmRlZmluZWRcblx0XHRcdGlmIChkLmNhdF9pZCAmJiBkLnN1Yl9jYXRfaWQgPT09ICcnICYmIGQub3JkZXIgPT09IG51bGwpIHtcblx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2NbZC5jYXRfaWRdID0gZC5kYXRhO1xuXHRcdFx0fSBlbHNlIGlmKGQuY2F0X2lkICYmIHR5cGVvZiBhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzY1tkLmNhdF9pZF0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjW2QuY2F0X2lkXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2hlY2sgZm9yIHN1YmNhdGVnb3JpZXNcblx0XHRcdGlmKGQuc3ViX2NhdF9pZCkge1xuXHRcdFx0XHQvLyBjcmVhdGUgc3ViLW9iamVjdCBpZiB3ZSBoYXZlIGEgc3ViY2F0ZWdvcnkuLi5cblx0XHRcdFx0aWYodHlwZW9mIGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjW2QuY2F0X2lkXVtkLnN1Yl9jYXRfaWRdID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhkLCBhZERhdGFbZC5ob2xjX2lkXSk7XG5cdFx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2NbZC5jYXRfaWRdW2Quc3ViX2NhdF9pZF0gPSB7fTtcblxuXHRcdFx0XHRcdC8vIGxvb2sgZm9yIG9yZGVyXG5cdFx0XHRcdFx0aWYoZC5vcmRlcikge1xuXHRcdFx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2NbZC5jYXRfaWRdW2Quc3ViX2NhdF9pZF1bZC5vcmRlcl0gPWQuZGF0YTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2NbZC5jYXRfaWRdW2Quc3ViX2NhdF9pZF0gPSBkLmRhdGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IFxuXG5cdFx0XHQvLyBsb29rIGZvciBvcmRlclxuXHRcdFx0ZWxzZSBpZiAoZC5vcmRlcikgeyBcblx0XHRcdFx0YWREYXRhW2QuaG9sY19pZF0uYXJlYURlc2NbZC5jYXRfaWRdW2Qub3JkZXJdID0gcmF3QWREYXRhW3Jvd10uZGF0YTtcblx0XHRcdH0gXG5cblx0XHRcdGlmIChPYmplY3Qua2V5cyhhZERhdGFbZC5ob2xjX2lkXS5hcmVhRGVzYykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGFkRGF0YVtkLmhvbGNfaWRdLmFyZWFEZXNjID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHR9ICAvLyBlbmQgaWZcblxuXHRcdHJldHVybiBhZERhdGE7XG5cdH0sXG5cblx0cGFyc2VBRHNCeUNhdDogZnVuY3Rpb24oQURzKSB7XG5cdFx0bGV0IEFEc0J5Q2F0ID0ge307XG5cdFx0T2JqZWN0LmtleXMoQURzKS5mb3JFYWNoKGZ1bmN0aW9uKG5laWdoYm9yaG9vZElkKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhBRHNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjKS5mb3JFYWNoKGZ1bmN0aW9uKGNhdCkge1xuXHRcdFx0XHQvLyBpbml0aWFsaXplIGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRBRHNCeUNhdFtjYXRdID0gQURzQnlDYXRbY2F0XSB8fCB7fTtcblx0XHRcdFx0aWYgKHR5cGVvZihBRHNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjW2NhdF0pID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0QURzQnlDYXRbY2F0XVtuZWlnaGJvcmhvb2RJZF0gPSBBRHNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjW2NhdF07XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKEFEc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2NbY2F0XSkgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhBRHNbbmVpZ2hib3Job29kSWRdLmFyZWFEZXNjW2NhdF0pLmZvckVhY2goZnVuY3Rpb24gKHN1YmNhdCkge1xuXHRcdFx0XHRcdFx0QURzQnlDYXRbY2F0XVtzdWJjYXRdID0gQURzQnlDYXRbY2F0XVtzdWJjYXRdIHx8IHt9O1xuXHRcdFx0XHRcdFx0QURzQnlDYXRbY2F0XVtzdWJjYXRdW25laWdoYm9yaG9vZElkXSA9IEFEc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2NbY2F0XVtzdWJjYXRdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBBRHNCeUNhdDtcblx0fSxcblxuXHRwYXJzZUludmVydGVkR2VvSnNvbjogZnVuY3Rpb24oZ2VvanNvbikge1xuXHRcdC8vQ3JlYXRlIGEgbmV3IHNldCBvZiBsYXRsbmdzLCBhZGRpbmcgb3VyIHdvcmxkLXNpemVkIHJpbmcgZmlyc3Rcblx0XHRsZXQgTldIZW1pc3BoZXJlID0gW1swLDBdLCBbMCwgOTBdLCBbLTE4MCwgOTBdLCBbLTE4MCwgMF0sIFswLDBdXSxcblx0XHRcdG5ld0xhdExuZ3MgPSBbIE5XSGVtaXNwaGVyZSBdLFxuXHRcdFx0aG9sZXMgPVtdO1xuXG5cdFx0Z2VvanNvbi5jb29yZGluYXRlcy5mb3JFYWNoKChwb2x5Z29uLCBpKSA9PiB7XG5cdFx0XHRwb2x5Z29uLmZvckVhY2goKHBvbHlnb25waWVjZXMsIGkyKSA9PiB7XG5cdFx0XHRcdGlmIChpMiA9PSAwKSB7XG5cdFx0XHRcdFx0bmV3TGF0TG5ncy5wdXNoKHBvbHlnb25waWVjZXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhvbGVzLnB1c2gocG9seWdvbnBpZWNlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGdlb2pzb24uY29vcmRpbmF0ZXMgPSAoaG9sZXMubGVuZ3RoID4gMCkgPyBbbmV3TGF0TG5ncy5jb25jYXQoaG9sZXMpXSA6IFtuZXdMYXRMbmdzXVxuXHRcdHJldHVybiBnZW9qc29uO1xuXHR9LFxuXG5cdGdldEFyZWFEZXNjcmlwdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9ucztcblx0fSxcblxuXHRnZXRBRHM6IGZ1bmN0aW9uKGFkSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kIDogZmFsc2U7XG5cdH0sXG5cblx0Z2V0R2VvSnNvbkZvckdyYWRlOiBmdW5jdGlvbihhZElkLCBncmFkZSkge1xuXHRcdGxldCBwb2x5Z29ucyA9IFtbWzAsMF0sIFswLCA5MF0sIFstMTgwLCA5MF0sIFstMTgwLCAwXSwgWzAsMF1dXSxcblx0XHRcdGhvbGVzID0gW107XG5cdFx0T2JqZWN0LmtleXModGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2QpLmZvckVhY2goKGlkLCBpKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbaWRdLmhvbGNfZ3JhZGUgPT0gZ3JhZGUpIHtcblx0XHRcdFx0dGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbaWRdLmFyZWFfZ2VvanNvbi5jb29yZGluYXRlc1swXS5mb3JFYWNoKChjb29yZHMsIGkyKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGkyID09IDApIHtcblx0XHRcdFx0XHRcdHBvbHlnb25zLnB1c2goY29vcmRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aG9sZXMucHVzaChjb29yZHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRwb2x5Z29ucyA9IChob2xlcy5sZW5ndGggPiAwKSA/IFtwb2x5Z29ucy5jb25jYXQoaG9sZXMpXSA6IFtwb2x5Z29uc11cblxuXHRcdGxldCBnZW9qc29uID0ge1xuXHRcdFx0J3R5cGUnOiAnRmVhdHVyZScsXG5cdFx0XHQnZ2VvbWV0cnknOiB7XG5cdFx0XHRcdCd0eXBlJzogJ011bHRpUG9seWdvbicsXG5cdFx0XHRcdCdjb29yZGluYXRlcyc6IHBvbHlnb25zXG5cdFx0XHR9LFxuXHRcdFx0J3Byb3BlcnRpZXMnOiB7fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gZ2VvanNvbjtcblx0fSxcblxuXHRnZXRBRHNGb3JOZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKGFkSWQsIGhvbGNJZCkge1xuXHRcdHJldHVybiAodGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0gJiYgdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2RbaG9sY0lkXSkgPyB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieU5laWdoYm9yaG9vZFtob2xjSWRdLmFyZWFEZXNjIDogZmFsc2U7XG5cdH0sXG5cblx0Z2V0QURzRm9yQ2F0ZWdvcnk6IGZ1bmN0aW9uKGFkSWQsIGNhdGVnb3J5KSB7XG5cdFx0aWYgKCF0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IFtjYXROdW0sIGNhdExldHRlcl0gPSBjYXRlZ29yeS5zcGxpdCgnLScpO1xuXG5cdFx0aWYgKCFjYXROdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieUNhdGVnb3J5O1xuXHRcdH1cblxuXHRcdGlmICghY2F0TGV0dGVyICYmIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5Q2F0ZWdvcnlbY2F0TnVtXSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5Q2F0ZWdvcnlbY2F0TnVtXTtcblx0XHR9IGVsc2UgaWYgKGNhdExldHRlciAmJiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieUNhdGVnb3J5W2NhdE51bV0gJiYgdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlDYXRlZ29yeVtjYXROdW1dW2NhdExldHRlcl0pIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5ieUNhdGVnb3J5W2NhdE51bV1bY2F0TGV0dGVyXTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblxuXHRnZXRWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRsZXQgQURzID0ge307XG5cdFx0dGhpcy5kYXRhLmFkSWRzLmZvckVhY2goYWRJZCA9PiB7XG5cdFx0XHRpZiAodGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0pIHtcblx0XHRcdFx0QURzW2FkSWRdID0gdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2Q7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIEFEcztcblx0fSxcblxuXHRnZXRWaXNpYmxlTWFwSWRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFkSWRzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKGFkSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSA/IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmFyZWEgOiBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzSE9MQ0lkOiBmdW5jdGlvbihhZElkLCBIT0xDSWQpIHtcblx0XHRsZXQgZm9ybUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmJ5TmVpZ2hib3Job29kKS5zb3J0KHRoaXMuYWxwaGFudW1DYXNlKTtcblx0XHRyZXR1cm4gZm9ybUlkc1tmb3JtSWRzLmluZGV4T2YoSE9MQ0lkKSAtIDFdO1xuXHR9LFxuXG5cdGdldE5leHRIT0xDSWQ6IGZ1bmN0aW9uKGFkSWQsIEhPTENJZCkge1xuXHRcdGxldCBmb3JtSWRzID0gT2JqZWN0LmtleXModGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0uYnlOZWlnaGJvcmhvb2QpLnNvcnQodGhpcy5hbHBoYW51bUNhc2UpO1xuXHRcdHJldHVybiBmb3JtSWRzW2Zvcm1JZHMuaW5kZXhPZihIT0xDSWQpICsgMV07XG5cdH0sXG5cblx0Z2V0Rm9ybUlkOiBmdW5jdGlvbihhZElkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXSkgPyB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5mb3JtSWQgOiBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzQ2F0SWRzOiBmdW5jdGlvbihhZElkLCBjYXROdW0sIGNhdExldHRlcikge1xuXHRcdGlmICghdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZvcm1JZCA9IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmZvcm1JZDtcblx0XHRmb3IgKGxldCBjaGVja0NhdE51bSA9ICghY2F0TGV0dGVyKSA/IHBhcnNlSW50KGNhdE51bSkgLSAxIDogcGFyc2VJbnQoY2F0TnVtKTsgY2hlY2tDYXROdW0gPj0gMTsgY2hlY2tDYXROdW0tLSkge1xuXHRcdFx0Zm9yIChsZXQgY2hlY2tDYXRMZXR0ZXIgPSAoIWNhdExldHRlciB8fCBjYXRMZXR0ZXIgPT0gJ2EnKSA/ICd6JyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2F0TGV0dGVyLmNoYXJDb2RlQXQoKS0xKTsgY2hlY2tDYXRMZXR0ZXIgPj0gJ2EnOyBjaGVja0NhdExldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hlY2tDYXRMZXR0ZXIuY2hhckNvZGVBdCgpLTEpLCBjYXRMZXR0ZXIgPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZihmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2hlY2tDYXROdW1dKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2NoZWNrQ2F0TnVtLCB1bmRlZmluZWRdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjaGVja0NhdE51bV0gJiYgZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NoZWNrQ2F0TnVtXS5zdWJjYXRzICYmIHR5cGVvZihmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2hlY2tDYXROdW1dLnN1YmNhdHNbY2hlY2tDYXRMZXR0ZXJdKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2NoZWNrQ2F0TnVtLCBjaGVja0NhdExldHRlcl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0TmV4dENhdElkczogZnVuY3Rpb24oYWRJZCwgY2F0TnVtLCBjYXRMZXR0ZXIpIHtcblx0XHRpZiAoIXRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBmb3JtSWQgPSB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1thZElkXS5mb3JtSWQ7XG5cdFx0Zm9yIChsZXQgY2hlY2tDYXROdW0gPSAoIWNhdExldHRlcikgPyBwYXJzZUludChjYXROdW0pICsgMSA6IHBhcnNlSW50KGNhdE51bSk7IGNoZWNrQ2F0TnVtIDwgMzA7IGNoZWNrQ2F0TnVtKyspIHtcblx0XHRcdGZvciAobGV0IGNoZWNrQ2F0TGV0dGVyID0gKCFjYXRMZXR0ZXIgfHwgY2F0TGV0dGVyID09ICd6JykgPyAnYScgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNhdExldHRlci5jaGFyQ29kZUF0KCkrMSk7IGNoZWNrQ2F0TGV0dGVyIDw9ICd6JzsgY2hlY2tDYXRMZXR0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoZWNrQ2F0TGV0dGVyLmNoYXJDb2RlQXQoKSsxKSwgY2F0TGV0dGVyID0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NoZWNrQ2F0TnVtXSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFtjaGVja0NhdE51bSwgdW5kZWZpbmVkXTtcblx0XHRcdFx0fSBlbHNlIGlmIChmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2hlY2tDYXROdW1dICYmIGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjaGVja0NhdE51bV0uc3ViY2F0cyAmJiB0eXBlb2YoZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NoZWNrQ2F0TnVtXS5zdWJjYXRzW2NoZWNrQ2F0TGV0dGVyXSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFtjaGVja0NhdE51bSwgY2hlY2tDYXRMZXR0ZXJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENhdFRpdGxlOiBmdW5jdGlvbihhZElkLCBjYXQsIHN1YmNhdCkge1xuXHRcdGlmICghdGhpcy5kYXRhLmFyZWFEZXNjcmlwdGlvbnNbYWRJZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZvcm1JZCA9IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdLmZvcm1JZDtcblx0XHRpZiAoIXN1YmNhdCkge1xuXHRcdFx0cmV0dXJuIGNhdCArICcgJyArIGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjYXRdO1xuXHRcdH0gZWxzZSBpZiAoc3ViY2F0KSB7XG5cdFx0XHRyZXR1cm4gY2F0ICsgc3ViY2F0ICsgJyAnICsgZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NhdF0uaGVhZGVyICsgKChmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2F0XS5zdWJjYXRzW3N1YmNhdF0gIT09ICcnKSA/ICc6ICcgKyBmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2F0XS5zdWJjYXRzW3N1YmNhdF0gOiAnJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRoYXNBRERhdGE6IGZ1bmN0aW9uKGFkSWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW2FkSWRdKTtcblx0fSxcblxuXHQvKiBhbHBoYW51bS5qcyAoQykgQnJpYW4gSHVpc21hblxuXHQqIEJhc2VkIG9uIHRoZSBBbHBoYW51bSBBbGdvcml0aG0gYnkgRGF2aWQgS29lbGxlXG5cdCogVGhlIEFscGhhbnVtIEFsZ29yaXRobSBpcyBkaXNjdXNzZWQgYXQgaHR0cDovL3d3dy5EYXZlS29lbGxlLmNvbVxuXHQqXG5cdCogRGlzdHJpYnV0ZWQgdW5kZXIgc2FtZSBsaWNlbnNlIGFzIG9yaWdpbmFsXG5cdCogXG5cdCogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuXHQqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcblx0KiBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcblx0KiB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgYW55IGxhdGVyIHZlcnNpb24uXG5cdCogXG5cdCogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5cdCogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcblx0KiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuXHQqIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cdCogXG5cdCogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuXHQqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcblx0KiBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BICAwMjExMC0xMzAxICBVU0Fcblx0Ki9cblx0YWxwaGFudW1DYXNlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0ZnVuY3Rpb24gY2h1bmtpZnkodCkge1xuXHRcdFx0dmFyIHR6ID0gbmV3IEFycmF5KCk7XG5cdFx0XHR2YXIgeCA9IDAsIHkgPSAtMSwgbiA9IDAsIGksIGo7XG5cdFx0XHR3aGlsZSAoaSA9IChqID0gdC5jaGFyQXQoeCsrKSkuY2hhckNvZGVBdCgwKSkge1xuXHRcdFx0XHR2YXIgbSA9IChpID09IDQ2IHx8IChpID49NDggJiYgaSA8PSA1NykpO1xuXHRcdFx0XHRpZiAobSAhPT0gbikge1xuXHRcdFx0XHRcdHR6WysreV0gPSAnJztcblx0XHRcdFx0XHRuID0gbTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0elt5XSArPSBqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHR6O1xuXHRcdH1cblxuXHRcdHZhciBhYSA9IChhLm5laWdoYm9yaG9vZElkKSA/IGNodW5raWZ5KGEubmVpZ2hib3Job29kSWQudG9Mb3dlckNhc2UoKSkgOiBjaHVua2lmeShhLnRvTG93ZXJDYXNlKCkpO1xuXHRcdHZhciBiYiA9IChiLm5laWdoYm9yaG9vZElkKSA/IGNodW5raWZ5KGIubmVpZ2hib3Job29kSWQudG9Mb3dlckNhc2UoKSkgOiBjaHVua2lmeShiLnRvTG93ZXJDYXNlKCkpO1x0XG5cdFx0Zm9yIChsZXQgeCA9IDA7IGFhW3hdICYmIGJiW3hdOyB4KyspIHtcblx0XHRcdGlmIChhYVt4XSAhPT0gYmJbeF0pIHtcblx0XHRcdFx0dmFyIGMgPSBOdW1iZXIoYWFbeF0pLCBkID0gTnVtYmVyKGJiW3hdKTtcblx0XHRcdFx0aWYgKGMgPT0gYWFbeF0gJiYgZCA9PSBiYlt4XSkge1xuXHRcdFx0XHRcdHJldHVybiBjIC0gZDtcblx0XHRcdFx0fSBlbHNlIHJldHVybiAoYWFbeF0gPiBiYlt4XSkgPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhYS5sZW5ndGggLSBiYi5sZW5ndGg7XG5cdH1cblxufTtcblxuLy8gTWl4aW4gRXZlbnRFbWl0dGVyIGZ1bmN0aW9uYWxpdHlcbk9iamVjdC5hc3NpZ24oQXJlYURlc2NyaXB0aW9uc1N0b3JlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLy8gUmVnaXN0ZXIgY2FsbGJhY2sgdG8gaGFuZGxlIGFsbCB1cGRhdGVzXG5BcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKChhY3Rpb24pID0+IHtcblxuXG5cblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5sb2FkSW5pdGlhbERhdGE6XG5cdFx0XHRBcHBEaXNwYXRjaGVyLndhaXRGb3IoW01hcFN0YXRlU3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuXHRcdFx0aWYgKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHkgJiYgTWFwU3RhdGVTdG9yZS5pc0Fib3ZlWm9vbVRocmVzaG9sZCgpKSB7XG5cdFx0XHRcdEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5sb2FkRGF0YShbYWN0aW9uLnN0YXRlLnNlbGVjdGVkQ2l0eV0pO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLm1hcE1vdmVkOlxuXHRcdFx0QXBwRGlzcGF0Y2hlci53YWl0Rm9yKFtNYXBTdGF0ZVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcblxuXHRcdFx0bGV0IHZpc2libGVIT0xDTWFwc0lkcyA9IE1hcFN0YXRlU3RvcmUuZ2V0VmlzaWJsZUhPTENNYXBzSWRzKCk7XG5cblx0XHRcdGlmICh2aXNpYmxlSE9MQ01hcHNJZHMgJiYgTWFwU3RhdGVTdG9yZS5pc0Fib3ZlWm9vbVRocmVzaG9sZCgpKSB7XG5cdFx0XHRcdEFyZWFEZXNjcmlwdGlvbnNTdG9yZS5sb2FkRGF0YSh2aXNpYmxlSE9MQ01hcHNJZHMpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXG5cdHJldHVybiB0cnVlO1xuXG59KTtcblxuXG5leHBvcnQgZGVmYXVsdCBBcmVhRGVzY3JpcHRpb25zU3RvcmU7IiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBBcHBEaXNwYXRjaGVyIGZyb20gJy4uL3V0aWxzL0FwcERpc3BhdGNoZXInO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDYXJ0b0RCTG9hZGVyIGZyb20gJy4uL3V0aWxzL0NhcnRvREJMb2FkZXInO1xuaW1wb3J0IGZvcm1zTWV0YWRhdGEgZnJvbSAnLi4vLi4vZGF0YS9mb3Jtc01ldGFkYXRhLmpzb24nO1xuaW1wb3J0IE1hcFN0YXRlU3RvcmUgZnJvbSAnLi4vc3RvcmVzL01hcFN0YXRlU3RvcmUnO1xuXG4vKiBDaXR5IFN0b3JlIGlzIHJlc3BvbnNpYmxlIGZvciBtYWludGFpbmluZyBtb3N0IG9mIHRoZSBpbXBvcnRhbnQgc3RhdGVcbnZhcmlhYmxlczogZS5nLiBzZWxlY3RlZCBjaXR5LCBuZWlnaGJvcmhvb2QsIGNhdGVnb3J5LCByaW5nLCBncmFkZSwgZXRjLiAqL1xuY29uc3QgQ2l0eVN0b3JlID0ge1xuXG5cdGRhdGE6IHtcblx0XHRpZDogbnVsbCxcblx0XHRuYW1lOiBudWxsLFxuXHRcdHN0YXRlOiBudWxsLFxuXHRcdHllYXI6IG51bGwsXG5cdFx0c2VsZWN0ZWRSaW5nR3JhZGU6IHtcblx0XHRcdHJpbmdJZDogLTEsXG5cdFx0XHRncmFkZTogbnVsbFxuXHRcdH0sXG5cdFx0c2VsZWN0ZWRIb2xjSWQ6IG51bGwsXG5cdFx0c2VsZWN0ZWRDYXRlZ29yeTogbnVsbCxcblx0XHRzZWxlY3RlZEdyYWRlOiBudWxsLFxuXHRcdGhpZ2hsaWdodGVkSG9sY0lkOiBudWxsLFxuXHRcdGFyZWFzOiB7fSxcblx0XHRyaW5nQXJlYXNHZW9tZXRyeTogW10sIC8vIG5vdCB0aGUgcmluZ3MgdGhlbXNlbHZlcyBidXQgdGhlIGludGVyc2VjdGlvbiBvZiByaW5ncyBhbmQgYXJlYXNcblx0XHRsb29wTGF0TG5nOiBbXSxcblx0XHQvLyB0aGUgZGlzdGFuY2UgaW4gbWV0ZXJzIGJldHdlZW4gdGhlIGxvb3AgY2VudGVyIGFuZCB0aGUgb3V0ZXJtb3N0IHBvaW50XG5cdFx0b3V0ZXJSaW5nUmFkaXVzOiBudWxsLFxuXHRcdGNpdHlEYXRhOiB7fSxcblxuXHRcdC8qKiBQZXJjZW50YWdlcyBvZiBlYWNoIHJpbmcgZm9yIGVhY2ggZ3JhZGUsIHdpdGggXG5cdFx0ICogZGVuc2l0eSByZWNvcmRpbmcgdGhlIGFtb3VudCBvZiBuZWlnaGJvcmhvb2QgYXJlYSBcblx0XHQgKiBpbiB0aGUgcmluZy5cblx0XHQgKiB7XG5cdFx0ICogICAxOiB7XG5cdFx0ICogICAgICdBJzogZmxvYXQsXG5cdFx0ICogICAgICdCJzogZmxvYXQsXG5cdFx0ICogICAgICdDJzogZmxvYXQsXG5cdFx0ICogICAgICdEJzogZmxvYXQsXG5cdFx0ICogICAgICdkZW5zaXR5JzogZmxvYXQsXG5cdFx0ICogICB9LFxuXHRcdCAqICAgMjogeyAuLi4gfSxcblx0XHQgKiAgIC4uLlxuXHRcdCB9XG5cdFx0ICogfVxuXHRcdCAqL1xuXHRcdHJpbmdTdGF0czogW10sXG5cdFx0Z3JhZGVTdGF0czogW10sXG5cblx0XHRBRHNCeUNhdDoge30sXG5cdFx0cG9seWdvbkJvdW5kaW5nQm94OiBudWxsLFxuXHRcdHBvbHlnb25zQ2VudGVyOiBudWxsLFxuXHRcdGdyYWRlZEFyZWE6IG51bGwsXG5cdFx0Z3JhZGVkQXJlYU9mUmluZ3M6IHt9LFxuXHRcdGdyYWRlZEFyZWFCeUdyYWRlOiB7fSxcblx0XHR1c2Vyczoge1xuXHRcdFx0bGF0TG5nOiBudWxsLFxuXHRcdFx0YWRJZDogbnVsbCxcblx0XHRcdGNpdHk6IG51bGwsXG5cdFx0XHRuZWlnaGJvcmhvb2Q6IG51bGwsXG5cdFx0XHRvZmZlclpvb21UbzogZmFsc2Vcblx0XHR9LFxuXHRcdHNlbGVjdGVkQnlVc2VyOiBmYWxzZSxcblx0XHRoYXNMb2FkZWQ6IGZhbHNlXG5cdH0sXG5cblx0Ly8gVE9ETzogTWFrZSBhIGdlbmVyaWMgRGF0YUxvYWRlciBjbGFzcyB0byBkZWZpbmUgYW4gaW50ZXJmYWNlLFxuXHQvLyBhbmQgbGV0IENhcnRvREJMb2FkZXIgZXh0ZW5kIGFuZCBpbXBsZW1lbnQgdGhhdD9cblx0Ly8gQmFzaWMgaWRlYSBpcyB0aGF0IGFueXRoaW5nIHdpdGggYSBxdWVyeSBtZXRob2QgdGhhdCByZXR1cm5zIGEgUHJvbWlzZVxuXHQvLyB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgcmVzcG9uc2UgZGF0YSBvciByZWplY3RzIHdpdGggYW4gZXJyb3Jcblx0Ly8gY2FuIGJlIHVzZWQgaGVyZS5cblx0ZGF0YUxvYWRlcjogQ2FydG9EQkxvYWRlcixcblxuXHRsb2FkRGF0YTogZnVuY3Rpb24gKGNpdHlJZCwgc2VsZWN0ZWRCeVVzZXIpIHtcblx0XHRpZiAoY2l0eUlkID09IG51bGwpIHtcblx0XHRcdHRoaXMuZGF0YS5pZCA9IG51bGw7XG5cdFx0XHR0aGlzLmRhdGEuc2VsZWN0ZWROZWlnaGJvcmhvb2QgPSBudWxsO1xuXHRcdFx0dGhpcy5kYXRhLnNlbGVjdGVkQ2F0ZWdvcnkgPSBudWxsO1xuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGNpdHlJZCA9PSB0aGlzLmRhdGEuaWQpIHtcblx0XHRcdC8vIGFscmVhZHkgbG9hZGVkO1xuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhTG9hZGVyLnF1ZXJ5KFtcblx0XHRcdHtcblx0XHRcdFx0cXVlcnk6ICdTRUxFQ1QgKiBmcm9tIGhvbGNfYWRzIHdoZXJlIGNpdHlfaWQgPSAnICsgY2l0eUlkLFxuXHRcdFx0XHRmb3JtYXQ6ICdKU09OJ1xuXHRcdFx0fSxcblx0XHRcdC8vIGdldCByaW5nIHBvbHlnb25zXG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXJ5OiAnV0lUSCB0aGVfaHVsbCBhcyAoc2VsZWN0IFNUX0NvbGxlY3QoZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMudGhlX2dlb21fd2VibWVyY2F0b3IpIGFzIGh1bGwsIGFkX2lkIEZST00gZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMgd2hlcmUgYWRfaWQgPSAnICsgY2l0eUlkICsgJyBHUk9VUCBCWSBhZF9pZCksIG1heGRpc3QgYXMgKFNFTEVDVCBzdF9kaXN0YW5jZV9zcGhlcmUoc3RfdHJhbnNmb3JtKHN0X2VuZHBvaW50KHN0X2xvbmdlc3RsaW5lKHN0X3RyYW5zZm9ybShTVF9TZXRTUklEKFNUX01ha2VQb2ludChsb29wbG5nLGxvb3BsYXQpLDQzMjYpLDM4NTcpLCBodWxsKSksIDQzMjYpLCBTVF9TZXRTUklEKFNUX01ha2VQb2ludChsb29wbG5nLGxvb3BsYXQpLCA0MzI2KSkgYXMgb3V0ZXJyaW5ncmFkaXVzLCBzdF9sZW5ndGgoc3RfbG9uZ2VzdGxpbmUoc3RfdHJhbnNmb3JtKFNUX1NldFNSSUQoU1RfUG9pbnQobG9vcGxuZyxsb29wbGF0KSw0MzI2KSwzODU3KSwgaHVsbCkpIC8gMy41IGFzIGRpc3RpbnR2LCBTVF9UcmFuc2Zvcm0oU1RfU2V0U1JJRChTVF9NYWtlUG9pbnQobG9vcGxuZyxsb29wbGF0KSw0MzI2KSwzODU3KTo6Z2VvbWV0cnkgYXMgdGhlX3BvaW50IGZyb20gdGhlX2h1bGwgam9pbiBob2xjX2FkcyBvbiB0aGVfaHVsbC5hZF9pZCA9IGhvbGNfYWRzLmNpdHlfaWQgYW5kIGhvbGNfYWRzLmNpdHlfaWQgPSAnICsgY2l0eUlkICsgJyBPcmRlciBieSBkaXN0aW50diBERVNDIExpbWl0IDEgKSwgY2l0eV9idWZmZXJzIGFzIChTRUxFQ1QgU1RfVHJhbnNmb3JtKChTVF9CdWZmZXIodGhlX3BvaW50LGRpc3RpbnR2ICogMy41LFxcJ3F1YWRfc2Vncz0zMlxcJyk6Omdlb21ldHJ5KSwzODU3KSBhcyBidWZmZXI0LCBTVF9UcmFuc2Zvcm0oKFNUX0J1ZmZlcih0aGVfcG9pbnQsZGlzdGludHYgKiAyLjUsXFwncXVhZF9zZWdzPTMyXFwnKTo6Z2VvbWV0cnkpLDM4NTcpIGFzIGJ1ZmZlcjMsIFNUX1RyYW5zZm9ybSgoU1RfQnVmZmVyKHRoZV9wb2ludCxkaXN0aW50diAqIDEuNSxcXCdxdWFkX3NlZ3M9MzJcXCcpOjpnZW9tZXRyeSksMzg1NykgYXMgYnVmZmVyMiwgU1RfVHJhbnNmb3JtKChTVF9CdWZmZXIodGhlX3BvaW50LGRpc3RpbnR2ICogMC41LFxcJ3F1YWRfc2Vncz0zMlxcJyk6Omdlb21ldHJ5KSwzODU3KSBhcyBidWZmZXIxIEZST00gbWF4ZGlzdCksIGNpdHlfcmluZ3MgYXMgKFNFTEVDVCBTVF9EaWZmZXJlbmNlKGJ1ZmZlcjQsIGJ1ZmZlcjMpIGFzIHRoZV9nZW9tX3dlYm1lcmNhdG9yLCA0IGFzIHJpbmdfaWQsIHN0X2FyZWEoU1RfRGlmZmVyZW5jZShidWZmZXI0LCBidWZmZXIzKSkgYXMgcmluZ19hcmVhIGZyb20gY2l0eV9idWZmZXJzIHVuaW9uIGFsbCBzZWxlY3QgU1RfRGlmZmVyZW5jZShidWZmZXIzLCBidWZmZXIyKSBhcyB0aGVfZ2VvbV93ZWJtZXJjYXRvciwgMyBhcyByaW5nX2lkLCBzdF9hcmVhKFNUX0RpZmZlcmVuY2UoYnVmZmVyMywgYnVmZmVyMikpIGFzIHJpbmdfYXJlYSBmcm9tIGNpdHlfYnVmZmVycyB1bmlvbiBhbGwgc2VsZWN0IFNUX0RpZmZlcmVuY2UoYnVmZmVyMiwgYnVmZmVyMSkgYXMgdGhlX2dlb21fd2VibWVyY2F0b3IsIDIgYXMgcmluZ19pZCwgc3RfYXJlYShTVF9EaWZmZXJlbmNlKGJ1ZmZlcjIsIGJ1ZmZlcjEpKSBhcyByaW5nX2FyZWEgZnJvbSBjaXR5X2J1ZmZlcnMgdW5pb24gYWxsIHNlbGVjdCBidWZmZXIxIGFzIHRoZV93ZWJtZXJjYXRvciwgMSBhcyByaW5nX2lkLCBzdF9hcmVhKGJ1ZmZlcjEpIGFzIHJpbmdfYXJlYSBmcm9tIGNpdHlfYnVmZmVycyApLCBjb21iaW5lZF9ncmFkZXMgYXMgKFNFTEVDVCBob2xjX2dyYWRlLCBTVF91bmlvbih0aGVfZ2VvbV93ZWJtZXJjYXRvcikgYXMgdGhlX2dlb21fd2VibWVyY2F0b3IgRlJPTSBkaWdpdGFsc2Nob2xhcnNoaXBsYWIuaG9sY19wb2x5Z29ucyB3aGVyZSBhZF9pZCA9ICcgKyBjaXR5SWQgKyAnIGdyb3VwIGJ5IGhvbGNfZ3JhZGUpIFNFTEVDVCBob2xjX2dyYWRlIGFzIGdyYWRlLCByaW5nX2lkIGFzIHJpbmcsIFNUX0FzR2VvSlNPTihTVF9UcmFuc2Zvcm0oU1RfSW50ZXJzZWN0aW9uKGNpdHlfcmluZ3MudGhlX2dlb21fd2VibWVyY2F0b3IsIGNvbWJpbmVkX2dyYWRlcy50aGVfZ2VvbV93ZWJtZXJjYXRvciksNDMyNiksIDQpIGFzIHRoZV9nZW9qc29uLCBTVF9Bc0dlb0pTT04oU1RfVHJhbnNmb3JtKFNUX0RpZmZlcmVuY2UoY2l0eV9yaW5ncy50aGVfZ2VvbV93ZWJtZXJjYXRvciwgY29tYmluZWRfZ3JhZGVzLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSw0MzI2KSwgNCkgYXMgaW52ZXJ0ZWRfZ2VvanNvbiwgc3RfYXJlYShTVF9JbnRlcnNlY3Rpb24oY2l0eV9yaW5ncy50aGVfZ2VvbV93ZWJtZXJjYXRvciwgY29tYmluZWRfZ3JhZGVzLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSkgYXMgYXJlYSwgU1RfQXJlYShjaXR5X3JpbmdzLnRoZV9nZW9tX3dlYm1lcmNhdG9yKSBhcyByaW5nX2FyZWEsIG91dGVycmluZ3JhZGl1cyBGUk9NIGNpdHlfcmluZ3MsIGNvbWJpbmVkX2dyYWRlcywgbWF4ZGlzdCcsXG5cdFx0XHRcdGZvcm1hdDogJ0pTT04nXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRxdWVyeTogJ1NlbGVjdCBzdF94KHN0X2NlbnRyb2lkKFNUX1NldFNSSUQoc3RfZXh0ZW50KHRoZV9nZW9tKSw0MzI2KSkpIGFzIGNlbnRlckxuZywgc3RfeShzdF9jZW50cm9pZChTVF9TZXRTUklEKHN0X2V4dGVudCh0aGVfZ2VvbSksNDMyNikpKSBhcyBjZW50ZXJMYXQsIHN0X3htaW4oU1RfU2V0U1JJRChzdF9leHRlbnQodGhlX2dlb20pLDQzMjYpKSBhcyBtaW5sbmcsIHN0X3ltaW4oU1RfU2V0U1JJRChzdF9leHRlbnQodGhlX2dlb20pLDQzMjYpKSBhcyBtaW5sYXQsIHN0X3htYXgoU1RfU2V0U1JJRChzdF9leHRlbnQodGhlX2dlb20pLDQzMjYpKSBhcyBtYXhsbmcsIHN0X3ltYXgoU1RfU2V0U1JJRChzdF9leHRlbnQodGhlX2dlb20pLDQzMjYpKSBhcyBtYXhsYXQgZnJvbSBkaWdpdGFsc2Nob2xhcnNoaXBsYWIuaG9sY19wb2x5Z29ucyB3aGVyZSBhZF9pZCA9ICcgKyBjaXR5SWQsXG5cdFx0XHRcdGZvcm1hdDogJ0pTT04nXG5cdFx0XHR9XG5cdFx0XSkudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdHRoaXMuZGF0YS5pZCA9IHBhcnNlSW50KGNpdHlJZCk7XG5cdFx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRCeVVzZXIgPSBzZWxlY3RlZEJ5VXNlcjtcblxuXHRcdFx0bGV0IGNpdHlEYXRhID0gcmVzcG9uc2VbMF1bMF07XG5cdFx0XHR0aGlzLmRhdGEubmFtZSA9IGNpdHlEYXRhLmNpdHk7XG5cdFx0XHR0aGlzLmRhdGEuc3RhdGUgPSBjaXR5RGF0YS5zdGF0ZTtcblx0XHRcdHRoaXMuZGF0YS55ZWFyID0gY2l0eURhdGEueWVhcjtcblx0XHRcdHRoaXMuZGF0YS5mb3JtX2lkID0gY2l0eURhdGEuZm9ybV9pZDtcblx0XHRcdHRoaXMuZGF0YS5jaXR5RGF0YSA9IGNpdHlEYXRhO1xuXG5cdFx0XHRjb25zdCByaW5nRGF0YSA9IHJlc3BvbnNlWzFdO1xuXHRcdFx0dGhpcy5kYXRhLmdyYWRlZEFyZWEgPSB0aGlzLmNhbGN1bGF0ZWRHcmFkZWRBcmVhKHJpbmdEYXRhKTtcblx0XHRcdHRoaXMuZGF0YS5ncmFkZWRBcmVhT2ZSaW5ncyA9IHRoaXMuY2FsY3VsYXRlR3JhZGVkQXJlYU9mUmluZ3MocmluZ0RhdGEpO1xuXHRcdFx0dGhpcy5kYXRhLmdyYWRlZEFyZWFCeUdyYWRlID0gdGhpcy5jYWxjdWxhdGVHcmFkZWRBcmVhQnlHcmFkZShyaW5nRGF0YSk7XG5cdFx0XHR0aGlzLmRhdGEucmluZ0FyZWFzR2VvbWV0cnkgPSB0aGlzLnBhcnNlUmluZ0FyZWFHZW9tZXRyeShyaW5nRGF0YSk7XG5cdFx0XHR0aGlzLmRhdGEucmluZ1N0YXRzID0gdGhpcy5wYXJzZVJpbmdTdGF0cyh0aGlzLmRhdGEucmluZ0FyZWFzR2VvbWV0cnkpO1xuXHRcdFx0dGhpcy5kYXRhLm91dGVyUmluZ1JhZGl1cyA9IChyZXNwb25zZVsxXVswXSkgPyByZXNwb25zZVsxXVswXS5vdXRlcnJpbmdyYWRpdXMgOiBmYWxzZTtcblx0XHRcdHRoaXMuZGF0YS5sb29wTGF0TG5nID0gKGNpdHlEYXRhKSA/IFtjaXR5RGF0YS5sb29wbGF0LCBjaXR5RGF0YS5sb29wbG5nXSA6IGZhbHNlO1xuXHRcdFx0dGhpcy5kYXRhLmdyYWRlU3RhdHMgPSB0aGlzLnBhcnNlR3JhZGVTdGF0cyh0aGlzLmRhdGEucmluZ0FyZWFzR2VvbWV0cnkpO1xuXHRcdFx0XG5cdFx0XHRsZXQgcG9seWdvbkxhdExuZ3MgPSByZXNwb25zZVsyXVswXTtcblx0XHRcdGlmIChwb2x5Z29uTGF0TG5ncy5taW5sYXQpIHtcblx0XHRcdFx0dGhpcy5kYXRhLnBvbHlnb25Cb3VuZGluZ0JveCA9IFsgW3BvbHlnb25MYXRMbmdzLm1pbmxhdCwgcG9seWdvbkxhdExuZ3MubWlubG5nXSwgW3BvbHlnb25MYXRMbmdzLm1heGxhdCwgcG9seWdvbkxhdExuZ3MubWF4bG5nXSBdO1xuXHRcdFx0XHR0aGlzLmRhdGEucG9seWdvbnNDZW50ZXIgPSBbIHBvbHlnb25MYXRMbmdzLmNlbnRlcmxhdCwgcG9seWdvbkxhdExuZ3MuY2VudGVybG5nIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRhdGEucG9seWdvbkJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHRcdFx0dGhpcy5kYXRhLnBvbHlnb25zQ2VudGVyID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kYXRhLmhhc0xvYWRlZCA9IHRydWU7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCdDaXR5U3RvcmUgZmluaXNoZWQgbG9hZGluZycpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2codGhpcy5kYXRhKTtcblxuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cblx0XHR9LCAoZXJyb3IpID0+IHtcblx0XHRcdC8vIFRPRE86IGhhbmRsZSB0aGlzLlxuXHRcdFx0Y29uc29sZS5sb2coJ0NpdHlTdG9yZSByZWNlaXZlZCBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9KTtcblx0fSxcblxuXHRnZXRDaXR5RnJvbVBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGxldCBhZElkO1xuXHRcdHRoaXMuZGF0YUxvYWRlci5xdWVyeShbXG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXJ5OiAnU0VMRUNUIGFkX2lkLCBjaXR5LCBTVF9kaXN0YW5jZShTVF9zZXRzcmlkKFNUX01ha2VQb2ludChob2xjX21hcHMubG9vcGxuZywgaG9sY19tYXBzLmxvb3BsYXQpLDQzMjYpLCBTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpKSBhcyBkaXN0YW5jZSwgc3RfeG1pbiggc3RfZW52ZWxvcGUoc3RfY29sbGVjdChTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpLCBob2xjX21hcHMudGhlX2dlb20pKSkgYXMgYmJ4bWluLCBzdF94bWF4KCBzdF9lbnZlbG9wZShzdF9jb2xsZWN0KFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KCcgKyBwb2ludFsxXSArJywgJyArIHBvaW50WzBdICsgJyksNDMyNiksIGhvbGNfbWFwcy50aGVfZ2VvbSkpKSBhcyBiYnhtYXgsIHN0X3ltaW4oIHN0X2VudmVsb3BlKHN0X2NvbGxlY3QoU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoJyArIHBvaW50WzFdICsnLCAnICsgcG9pbnRbMF0gKyAnKSw0MzI2KSwgaG9sY19tYXBzLnRoZV9nZW9tKSkpIGFzIGJieW1pbiwgc3RfeW1heCggc3RfZW52ZWxvcGUoc3RfY29sbGVjdChTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpLCBob2xjX21hcHMudGhlX2dlb20pKSkgYXMgYmJ5bWF4IGZyb20gaG9sY19tYXBzIGpvaW4gaG9sY19tYXBzX2Fkc19qb2luIG9uIGhvbGNfbWFwcy5tYXBfaWQgPSBob2xjX21hcHNfYWRzX2pvaW4ubWFwX2lkIGpvaW4gaG9sY19hZHMgb24gaG9sY19hZHMuY2l0eV9pZCA9IGhvbGNfbWFwc19hZHNfam9pbi5hZF9pZCBvcmRlciBieSBkaXN0YW5jZSBsaW1pdCAxJyxcblx0XHRcdFx0Zm9ybWF0OiAnSlNPTidcblx0XHRcdH1cblx0XHRdKS50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0dGhpcy5kYXRhLnVzZXJzLmNpdHkgPSByZXNwb25zZVswXVswXS5jaXR5O1xuXHRcdFx0dGhpcy5kYXRhLnVzZXJzLmFkSWQgPSByZXNwb25zZVswXVswXS5hZF9pZDtcblxuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnVzZXJMb2NhdGVkKTtcblx0XHR9LCAoZXJyb3IpID0+IHtcblx0XHRcdC8vIFRPRE86IGhhbmRsZSB0aGlzLlxuXHRcdFx0Y29uc29sZS5sb2coJ0xvY2F0aW9uIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qIHNldHRlciBmdW5jdGlvbnMgZm9yIHN0YXRlIHZhcmlhYmxlICovXG5cblx0c2V0SGlnaGxpZ2h0ZWRIb2xjSWQ6IGZ1bmN0aW9uIChob2xjSWQpIHtcblx0XHR0aGlzLmRhdGEuaGlnaGxpZ2h0ZWRIb2xjSWQgPSBob2xjSWQ7XG5cdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWRDYXRlZ29yeTogZnVuY3Rpb24gKGlkKSB7XG5cdFx0dGhpcy5kYXRhLnNlbGVjdGVkQ2F0ZWdvcnkgPSBpZDtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZEhvbGNJZDogZnVuY3Rpb24gKGhvbGNJZCkge1xuXHRcdHRoaXMuZGF0YS5zZWxlY3RlZEhvbGNJZCA9IGhvbGNJZDtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZEdyYWRlOiBmdW5jdGlvbiAoZ3JhZGUpIHtcblx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRHcmFkZSA9IGdyYWRlO1xuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkUmluZ0dyYWRlOiBmdW5jdGlvbiAoc2VsZWN0ZWRSaW5nR3JhZGUpIHtcblx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRSaW5nR3JhZGUgPSBzZWxlY3RlZFJpbmdHcmFkZTtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHQvKiBnZXR0ZXIgZnVuY3Rpb25zICovXG5cblx0Z2V0SGlnaGxpZ2h0ZWRIb2xjSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuaGlnaGxpZ2h0ZWRIb2xjSWQ7XG5cdH0sXG5cblx0Z2V0SWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuaWQ7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRDYXRlZ29yeTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZENhdGVnb3J5O1xuXHR9LFxuXG5cdGdldFNlbGVjdGVkSG9sY0lkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnNlbGVjdGVkSG9sY0lkO1xuXHR9LFxuXG5cdGdldFNlbGVjdGVkR3JhZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc2VsZWN0ZWRHcmFkZTtcblx0fSxcblxuXHRnZXRTZWxlY3RlZFJpbmdHcmFkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZFJpbmdHcmFkZTtcblx0fSxcblxuXHRnZXROYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLm5hbWU7XG5cdH0sXG5cblx0Z2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc3RhdGU7XG5cdH0sXG5cblx0Z2V0Rm9ybUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmZvcm1faWQ7XG5cdH0sXG5cblx0Z2V0UmluZ1N0YXRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnJpbmdTdGF0cztcblx0fSxcblxuXHRnZXRSaW5nQXJlYXNHZW9tZXRyeTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5yaW5nQXJlYXNHZW9tZXRyeTtcblx0fSxcblxuXHRnZXRHcmFkZVN0YXRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmdyYWRlU3RhdHM7XG5cdH0sXG5cblx0Z2V0Q2l0eURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuY2l0eURhdGE7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRHcmFkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZEdyYWRlO1xuXHR9LFxuXG5cdGdldEdlb0pzb25Gb3JTZWxlY3RlZFJpbmdBcmVhOiBmdW5jdGlvbihyaW5nLCBncmFkZSkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEucmluZ0FyZWFzR2VvbWV0cnlbcmluZ11bZ3JhZGVdLnRoZV9nZW9qc29uO1xuXHR9LFxuXG5cdGdldEludmVydGVkR2VvSnNvbkZvclNlbGVjdGVkUmluZ0FyZWE6IGZ1bmN0aW9uKHJpbmcsIGdyYWRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5yaW5nQXJlYXNHZW9tZXRyeVtyaW5nXVtncmFkZV0uaW52ZXJ0ZWRfZ2VvanNvbjtcblx0fSxcblxuXHRnZXRPdXRlclJpbmdSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEub3V0ZXJSaW5nUmFkaXVzO1xuXHR9LFxuXG5cdGdldExvb3BMYXRMbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEubG9vcExhdExuZztcblx0fSxcblxuXHRnZXRQb2x5Z29uc0JvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5wb2x5Z29uQm91bmRpbmdCb3g7XG5cdH0sXG5cblx0Z2V0UG9seWdvbnNDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEucG9seWdvbnNDZW50ZXI7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRCeVVzZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc2VsZWN0ZWRCeVVzZXI7XG5cdH0sXG5cblx0Z2V0VXNlcnNDaXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnVzZXJzLmNpdHk7XG5cdH0sXG5cblx0Z2V0VXNlcnNBZElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnVzZXJzLmFkSWQ7XG5cdH0sXG5cblx0Z2V0VXNlcnNOZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudXNlcnMubmVpZ2hib3Job29kO1xuXHR9LFxuXG5cdGdldEFEc0J5Q2F0OiBmdW5jdGlvbihjYXQsIHN1YmNhdCkge1xuXHRcdGlmICghY2F0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLkFEc0J5Q2F0O1xuXHRcdH1cblxuXHRcdGlmICghc3ViY2F0ICYmIHRoaXMuZGF0YS5BRHNCeUNhdFtjYXRdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLkFEc0J5Q2F0W2NhdF07XG5cdFx0fSBlbHNlIGlmIChzdWJjYXQgJiYgdGhpcy5kYXRhLkFEc0J5Q2F0W2NhdF0gJiYgdGhpcy5kYXRhLkFEc0J5Q2F0W2NhdF1bc3ViY2F0XSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5BRHNCeUNhdFtjYXRdW3N1YmNhdF07XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXRDYXRlZ29yeVN0cmluZzogZnVuY3Rpb24oY2F0TnVtLCBjYXRMZXR0ZXIpIHtcblx0XHRyZXR1cm4gY2F0TnVtICsgKChjYXRMZXR0ZXIpID8gJy0nICsgY2F0TGV0dGVyIDogJycpO1xuXHR9LFxuXG5cdGdldENhdFRpdGxlOiBmdW5jdGlvbihjYXQsIHN1YmNhdCkge1xuXHRcdGxldCBmb3JtSWQgPSB0aGlzLmdldEZvcm1JZCgpO1xuXHRcdGlmICghc3ViY2F0KSB7XG5cdFx0XHRyZXR1cm4gY2F0ICsgJyAnICsgZm9ybXNNZXRhZGF0YVtmb3JtSWRdW2NhdF07XG5cdFx0fSBlbHNlIGlmIChzdWJjYXQpIHtcblx0XHRcdHJldHVybiBjYXQgKyBzdWJjYXQgKyAnICcgKyBmb3Jtc01ldGFkYXRhW2Zvcm1JZF1bY2F0XS5oZWFkZXIgKyAoKGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjYXRdLnN1YmNhdHNbc3ViY2F0XSAhPT0gJycpID8gJzogJyArIGZvcm1zTWV0YWRhdGFbZm9ybUlkXVtjYXRdLnN1YmNhdHNbc3ViY2F0XSA6ICcnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRxdWVyeUNhdGVnb3J5OiBmdW5jdGlvbihjYXROdW0sIGNhdExldHRlcikge1xuXHRcdGlmIChPYmplY3Qua2V5cyh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9ucykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0bGV0IGFyciA9IFtdOyAvLyBhcnJheSB0byBzdG9yZSByZXN1bHRzXG5cblx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9ucykubWFwKChuZWlnaGJvcmhvb2RJZCwgaSkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW25laWdoYm9yaG9vZElkXS5hcmVhRGVzYy5oYXNPd25Qcm9wZXJ0eShjYXROdW0pICYmIHR5cGVvZihjYXRMZXR0ZXIpID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGFyci5wdXNoKCB7IG5laWdoYm9yaG9vZElkOiBuZWlnaGJvcmhvb2RJZCwgYW5zd2VyOiB0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2NbY2F0TnVtXS5hIH0pO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmRhdGEuYXJlYURlc2NyaXB0aW9uc1tuZWlnaGJvcmhvb2RJZF0uYXJlYURlc2MuaGFzT3duUHJvcGVydHkoY2F0TnVtKSAmJnRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW25laWdoYm9yaG9vZElkXS5hcmVhRGVzY1tjYXROdW1dLmhhc093blByb3BlcnR5KGNhdExldHRlcikpIHtcblx0XHRcdFx0YXJyLnB1c2goIHsgbmVpZ2hib3Job29kSWQ6IG5laWdoYm9yaG9vZElkLCBhbnN3ZXI6IHRoaXMuZGF0YS5hcmVhRGVzY3JpcHRpb25zW25laWdoYm9yaG9vZElkXS5hcmVhRGVzY1tjYXROdW1dW2NhdExldHRlcl0uYSB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFyci5wdXNoKHsgbmVpZ2hib3Job29kSWQ6IG5laWdoYm9yaG9vZElkLCBhbnN3ZXI6IG51bGwgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhcnIuc29ydCh0aGlzLmFscGhhbnVtQ2FzZSk7XG5cblx0XHRyZXR1cm4gYXJyO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZWRHcmFkZWRBcmVhOiBmdW5jdGlvbihnZW9tZXRyaWVzKSB7XG5cdFx0bGV0IGdyYWRlZFRvdGFsQXJlYSA9IDA7XG5cdFx0Z2VvbWV0cmllcy5mb3JFYWNoKChkKSA9PiB7XG5cdFx0XHRncmFkZWRUb3RhbEFyZWEgKz0gZC5hcmVhO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGdyYWRlZFRvdGFsQXJlYTtcblx0fSxcblxuXHRjYWxjdWxhdGVHcmFkZWRBcmVhT2ZSaW5nczogZnVuY3Rpb24oZ2VvbWV0cmllcykge1xuXHRcdGxldCBncmFkZWRBcmVhT2ZSaW5ncyA9IHsxOjAsMjowLDM6MCw0OjB9O1xuXHRcdGdlb21ldHJpZXMuZm9yRWFjaCgoZCkgPT4ge1xuXHRcdFx0Z3JhZGVkQXJlYU9mUmluZ3NbZC5yaW5nXSArPSBkLmFyZWE7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZ3JhZGVkQXJlYU9mUmluZ3M7XG5cdH0sXG5cblx0Y2FsY3VsYXRlR3JhZGVkQXJlYUJ5R3JhZGU6IGZ1bmN0aW9uKGdlb21ldHJpZXMpIHtcblx0XHRsZXQgZ3JhZGVkQXJlYUJ5R3JhZGUgPSB7J0EnOjAsJ0InOjAsJ0MnOjAsJ0QnOjB9O1xuXHRcdGdlb21ldHJpZXMuZm9yRWFjaCgoZCkgPT4ge1xuXHRcdFx0Z3JhZGVkQXJlYUJ5R3JhZGVbZC5ncmFkZV0gKz0gZC5hcmVhO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGdyYWRlZEFyZWFCeUdyYWRlO1xuXHR9LFxuXG5cdHBhcnNlUmluZ0FyZWFHZW9tZXRyeTogZnVuY3Rpb24oZ2VvbWV0cmllcykge1xuXHRcdGlmIChnZW9tZXRyaWVzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0bGV0IHJpbmdBcmVhc0dlb21ldHJ5ICA9IHtcblx0XHRcdDE6IHsnQSc6e30sJ0InOnt9LCdDJzp7fSwnRCc6e319LFxuXHRcdFx0MjogeydBJzp7fSwnQic6e30sJ0MnOnt9LCdEJzp7fX0sXG5cdFx0XHQzOiB7J0EnOnt9LCdCJzp7fSwnQyc6e30sJ0QnOnt9fSxcblx0XHRcdDQ6IHsnQSc6e30sJ0InOnt9LCdDJzp7fSwnRCc6e319XG5cdFx0fTtcblxuXHRcdGdlb21ldHJpZXMuZm9yRWFjaCgoZCkgPT4ge1xuXHRcdFx0cmluZ0FyZWFzR2VvbWV0cnlbZC5yaW5nXS5kZW5zaXR5ID0gdGhpcy5kYXRhLmdyYWRlZEFyZWFPZlJpbmdzW2QucmluZ10gLyBkLnJpbmdfYXJlYTtcblx0XHRcdHJpbmdBcmVhc0dlb21ldHJ5W2QucmluZ11bZC5ncmFkZV0gPSB7XG5cdFx0XHRcdCd0aGVfZ2VvanNvbic6IEpTT04ucGFyc2UoZC50aGVfZ2VvanNvbiksXG5cdFx0XHRcdCdpbnZlcnRlZF9nZW9qc29uJzogSlNPTi5wYXJzZShkLmludmVydGVkX2dlb2pzb24pLFxuXHRcdFx0XHQncGVyY2VudCc6IGQuYXJlYSAvIHRoaXMuZGF0YS5ncmFkZWRBcmVhT2ZSaW5nc1tkLnJpbmddLFxuXHRcdFx0XHQnb3ZlcmFsbFBlcmNlbnQnOiBkLmFyZWEgLyB0aGlzLmRhdGEuZ3JhZGVkQXJlYVxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdHJldHVybiByaW5nQXJlYXNHZW9tZXRyeTtcblx0fSxcblxuXHRwYXJzZVJpbmdTdGF0czogZnVuY3Rpb24ocmluZ1N0YXRzKSB7XG5cdFx0aWYgKCFyaW5nU3RhdHMgfHwgcmluZ1N0YXRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogbGV0IHJpbmdDdW11bGF0aXZlID0ge1xuXHRcdFx0XHQxOiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAndG90YWwnOiAwfSxcblx0XHRcdFx0MjogeydBJzogMCwgJ0InOiAwLCAnQyc6IDAsICdEJzogMCwgJ3RvdGFsJzogMH0sXG5cdFx0XHRcdDM6IHsnQSc6IDAsICdCJzogMCwgJ0MnOiAwLCAnRCc6IDAsICd0b3RhbCc6IDB9LFxuXHRcdFx0XHQ0OiB7J0EnOiAwLCAnQic6IDAsICdDJzogMCwgJ0QnOiAwLCAndG90YWwnOiAwfVxuXHRcdFx0fSxcblx0XHRcdGFyZWFPZlJpbmdzID0ge30sXG5cdFx0XHR0b3RhbEdyYWRlZEFyZWEgPSAwLCBcblx0XHRcdHJpbmdTdGF0cyA9IHsgMSA6IHt9LCAyOiB7fSwgMzoge30sIDQ6IHt9IH07XG5cdFx0cmluZ0FyZWFHZW9tZXRyeS5mb3JFYWNoKChyaW5nKSA9PiB7XG5cdFx0XHRyaW5nQ3VtdWxhdGl2ZVtyaW5nLnJpbmdfaWRdW3JpbmcuaG9sY19ncmFkZV0gKz0gcmluZy5hcmVhO1xuXHRcdFx0cmluZ0N1bXVsYXRpdmVbcmluZy5yaW5nX2lkXS50b3RhbCArPSByaW5nLmFyZWE7XG5cdFx0XHRhcmVhT2ZSaW5nc1tyaW5nLnJpbmdfaWRdID0gcmluZy5yaW5nX2FyZWE7XG5cdFx0XHR0b3RhbEdyYWRlZEFyZWEgKz0gcmluZy5hcmVhO1xuXHRcdH0pO1xuXHRcdGNvbnNvbGUubG9nKHRvdGFsR3JhZGVkQXJlYSk7XG5cdFx0T2JqZWN0LmtleXMocmluZ0N1bXVsYXRpdmUpLm1hcCgocmluZ19pZCkgPT4ge1xuXHRcdFx0T2JqZWN0LmtleXMocmluZ0N1bXVsYXRpdmVbcmluZ19pZF0pLm1hcCgoZ3JhZGUpID0+IHtcblx0XHRcdFx0cmluZ1N0YXRzW3JpbmdfaWRdW2dyYWRlXSA9IChyaW5nU3RhdHNbcmluZ19pZF1bZ3JhZGVdKSA/IHJpbmdTdGF0c1tyaW5nX2lkXVtncmFkZV0gOiB7fTtcblx0XHRcdFx0cmluZ1N0YXRzW3JpbmdfaWRdW2dyYWRlXS5wZXJjZW50ID0gcmluZ0N1bXVsYXRpdmVbcmluZ19pZF1bZ3JhZGVdIC8gcmluZ0N1bXVsYXRpdmVbcmluZ19pZF0udG90YWw7XG5cdFx0XHRcdHJpbmdTdGF0c1tyaW5nX2lkXS5kZW5zaXR5ID0gcmluZ0N1bXVsYXRpdmVbcmluZ19pZF0udG90YWwgLyBhcmVhT2ZSaW5nc1tyaW5nX2lkXTtcblx0XHRcdFx0cmluZ1N0YXRzW3JpbmdfaWRdW2dyYWRlXS5vdmVyYWxsUGVyY2VudCA9IHJpbmdDdW11bGF0aXZlW3JpbmdfaWRdW2dyYWRlXSAvIHRvdGFsR3JhZGVkQXJlYTtcblx0XHRcdH0pO1xuXHRcdH0pOyAqL1xuXG5cdFx0Ly9mb3JtYXQgZm9yIEQzXG5cdFx0bGV0IGZvcm1hdHRlZFN0YXRzID0gW107XG5cdFx0Zm9yIChsZXQgcmluZ0lkID0gMTsgcmluZ0lkIDw9IDQ7IHJpbmdJZCsrKSB7XG5cdFx0XHRmb3JtYXR0ZWRTdGF0cy5wdXNoKHsgXG5cdFx0XHRcdHBlcmNlbnRzOiBbIFxuXHRcdFx0XHRcdHsgcGVyY2VudDogcmluZ1N0YXRzW3JpbmdJZF0uQS5wZXJjZW50LCBvdmVyYWxsUGVyY2VudDogcmluZ1N0YXRzW3JpbmdJZF0uQS5vdmVyYWxsUGVyY2VudCwgcmluZ0lkOiByaW5nSWQsIG9wYWNpdHk6IHJpbmdTdGF0c1tyaW5nSWRdLmRlbnNpdHksIGdyYWRlOiAnQScgfSwgXG5cdFx0XHRcdFx0eyBwZXJjZW50OiByaW5nU3RhdHNbcmluZ0lkXS5CLnBlcmNlbnQsIG92ZXJhbGxQZXJjZW50OiByaW5nU3RhdHNbcmluZ0lkXS5CLm92ZXJhbGxQZXJjZW50LCByaW5nSWQ6IHJpbmdJZCwgb3BhY2l0eTogcmluZ1N0YXRzW3JpbmdJZF0uZGVuc2l0eSwgZ3JhZGU6ICdCJyB9LCBcblx0XHRcdFx0XHR7IHBlcmNlbnQ6IHJpbmdTdGF0c1tyaW5nSWRdLkMucGVyY2VudCwgb3ZlcmFsbFBlcmNlbnQ6IHJpbmdTdGF0c1tyaW5nSWRdLkMub3ZlcmFsbFBlcmNlbnQsIHJpbmdJZDogcmluZ0lkLCBvcGFjaXR5OiByaW5nU3RhdHNbcmluZ0lkXS5kZW5zaXR5LCBncmFkZTogJ0MnIH0sIFxuXHRcdFx0XHRcdHsgcGVyY2VudDogcmluZ1N0YXRzW3JpbmdJZF0uRC5wZXJjZW50LCBvdmVyYWxsUGVyY2VudDogcmluZ1N0YXRzW3JpbmdJZF0uRC5vdmVyYWxsUGVyY2VudCwgcmluZ0lkOiByaW5nSWQsIG9wYWNpdHk6IHJpbmdTdGF0c1tyaW5nSWRdLmRlbnNpdHksIGdyYWRlOiAnRCcgfSBcblx0XHRcdFx0XSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm9ybWF0dGVkU3RhdHM7XG5cdH0sXG5cblx0aGFzTG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmhhc0xvYWRlZDtcblx0fSxcblxuXHRwYXJzZUdyYWRlU3RhdHM6IGZ1bmN0aW9uKHJpbmdBcmVhc0dlb21ldHJ5KSB7XG5cdFx0bGV0IGdyYWRlcyA9IFsnQScsJ0InLCdDJywnRCddO1xuXG5cdFx0Ly9mb3JtYXQgZm9yIEQzXG5cdFx0cmV0dXJuIGdyYWRlcy5tYXAoKGdyYWRlKSA9PiB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRncmFkZTogZ3JhZGUsXG5cdFx0XHRcdHBlcmNlbnQ6IHRoaXMuZGF0YS5ncmFkZWRBcmVhQnlHcmFkZVtncmFkZV0gLyB0aGlzLmRhdGEuZ3JhZGVkQXJlYVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fSxcblxuXHRwYXJzZUludmVydGVkR2VvSnNvbjogZnVuY3Rpb24oZ2VvanNvbikge1xuXHRcdC8vQ3JlYXRlIGEgbmV3IHNldCBvZiBsYXRsbmdzLCBhZGRpbmcgb3VyIHdvcmxkLXNpemVkIHJpbmcgZmlyc3Rcblx0XHRsZXQgTldIZW1pc3BoZXJlID0gW1swLDBdLCBbMCwgOTBdLCBbLTE4MCwgOTBdLCBbLTE4MCwgMF0sIFswLDBdXSxcblx0XHRcdG5ld0xhdExuZ3MgPSBbIE5XSGVtaXNwaGVyZSBdLFxuXHRcdFx0aG9sZXMgPVtdO1xuXG5cdFx0Z2VvanNvbi5jb29yZGluYXRlcy5mb3JFYWNoKChwb2x5Z29uLCBpKSA9PiB7XG5cdFx0XHRwb2x5Z29uLmZvckVhY2goKHBvbHlnb25waWVjZXMsIGkyKSA9PiB7XG5cdFx0XHRcdGlmIChpMiA9PSAwKSB7XG5cdFx0XHRcdFx0bmV3TGF0TG5ncy5wdXNoKHBvbHlnb25waWVjZXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhvbGVzLnB1c2gocG9seWdvbnBpZWNlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGdlb2pzb24uY29vcmRpbmF0ZXMgPSAoaG9sZXMubGVuZ3RoID4gMCkgPyBbbmV3TGF0TG5ncy5jb25jYXQoaG9sZXMpXSA6IFtuZXdMYXRMbmdzXVxuXHRcdHJldHVybiBnZW9qc29uO1xuXHR9LFxuXG5cdC8qIGFscGhhbnVtLmpzIChDKSBCcmlhbiBIdWlzbWFuXG5cdCogQmFzZWQgb24gdGhlIEFscGhhbnVtIEFsZ29yaXRobSBieSBEYXZpZCBLb2VsbGVcblx0KiBUaGUgQWxwaGFudW0gQWxnb3JpdGhtIGlzIGRpc2N1c3NlZCBhdCBodHRwOi8vd3d3LkRhdmVLb2VsbGUuY29tXG5cdCpcblx0KiBEaXN0cmlidXRlZCB1bmRlciBzYW1lIGxpY2Vuc2UgYXMgb3JpZ2luYWxcblx0KiBcblx0KiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG5cdCogbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuXHQqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuXHQqIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciBhbnkgbGF0ZXIgdmVyc2lvbi5cblx0KiBcblx0KiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcblx0KiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuXHQqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG5cdCogTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblx0KiBcblx0KiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG5cdCogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuXHQqIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgIDAyMTEwLTEzMDEgIFVTQVxuXHQqL1xuXHRhbHBoYW51bUNhc2U6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRmdW5jdGlvbiBjaHVua2lmeSh0KSB7XG5cdFx0XHR2YXIgdHogPSBuZXcgQXJyYXkoKTtcblx0XHRcdHZhciB4ID0gMCwgeSA9IC0xLCBuID0gMCwgaSwgajtcblx0XHRcdHdoaWxlIChpID0gKGogPSB0LmNoYXJBdCh4KyspKS5jaGFyQ29kZUF0KDApKSB7XG5cdFx0XHRcdHZhciBtID0gKGkgPT0gNDYgfHwgKGkgPj00OCAmJiBpIDw9IDU3KSk7XG5cdFx0XHRcdGlmIChtICE9PSBuKSB7XG5cdFx0XHRcdFx0dHpbKyt5XSA9ICcnO1xuXHRcdFx0XHRcdG4gPSBtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR6W3ldICs9IGo7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHo7XG5cdFx0fVxuXG5cdFx0dmFyIGFhID0gKGEubmVpZ2hib3Job29kSWQpID8gY2h1bmtpZnkoYS5uZWlnaGJvcmhvb2RJZC50b0xvd2VyQ2FzZSgpKSA6IGNodW5raWZ5KGEudG9Mb3dlckNhc2UoKSk7XG5cdFx0dmFyIGJiID0gKGIubmVpZ2hib3Job29kSWQpID8gY2h1bmtpZnkoYi5uZWlnaGJvcmhvb2RJZC50b0xvd2VyQ2FzZSgpKSA6IGNodW5raWZ5KGIudG9Mb3dlckNhc2UoKSk7XHRcblx0XHRmb3IgKGxldCB4ID0gMDsgYWFbeF0gJiYgYmJbeF07IHgrKykge1xuXHRcdFx0aWYgKGFhW3hdICE9PSBiYlt4XSkge1xuXHRcdFx0XHR2YXIgYyA9IE51bWJlcihhYVt4XSksIGQgPSBOdW1iZXIoYmJbeF0pO1xuXHRcdFx0XHRpZiAoYyA9PSBhYVt4XSAmJiBkID09IGJiW3hdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGMgLSBkO1xuXHRcdFx0XHR9IGVsc2UgcmV0dXJuIChhYVt4XSA+IGJiW3hdKSA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGFhLmxlbmd0aCAtIGJiLmxlbmd0aDtcblx0fVxufTtcblxuLy8gTWl4aW4gRXZlbnRFbWl0dGVyIGZ1bmN0aW9uYWxpdHlcbk9iamVjdC5hc3NpZ24oQ2l0eVN0b3JlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLy8gUmVnaXN0ZXIgY2FsbGJhY2sgdG8gaGFuZGxlIGFsbCB1cGRhdGVzXG5DaXR5U3RvcmUuZGlzcGF0Y2hUb2tlbiA9IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoKGFjdGlvbikgPT4ge1xuXG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMuQURDYXRlZ29yeVNlbGVjdGVkOlxuXHRcdFx0Q2l0eVN0b3JlLnNldFNlbGVjdGVkQ2F0ZWdvcnkoYWN0aW9uLnZhbHVlKTtcblx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZEhvbGNJZChudWxsKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5sb2FkSW5pdGlhbERhdGE6XG5cdFx0XHRpZiAoYWN0aW9uLnN0YXRlLnNlbGVjdGVkQ2l0eSkge1xuXHRcdFx0XHRDaXR5U3RvcmUubG9hZERhdGEoYWN0aW9uLnN0YXRlLnNlbGVjdGVkQ2l0eSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWN0aW9uLnN0YXRlLnNlbGVjdGVkTmVpZ2hib3Job29kKSB7XG5cdFx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZEhvbGNJZChhY3Rpb24uc3RhdGUuc2VsZWN0ZWROZWlnaGJvcmhvb2QpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5KSB7XG5cdFx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZENhdGVnb3J5KGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENhdGVnb3J5KTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5jaXR5U2VsZWN0ZWQ6XG5cdFx0XHRDaXR5U3RvcmUubG9hZERhdGEoYWN0aW9uLnZhbHVlLCBhY3Rpb24uc2VsZWN0ZWRCeVVzZXIpO1xuXHRcdFx0Q2l0eVN0b3JlLnNldFNlbGVjdGVkSG9sY0lkKG51bGwpO1xuXHRcdFx0Q2l0eVN0b3JlLnNldFNlbGVjdGVkQ2F0ZWdvcnkobnVsbCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMuZ3JhZGVTZWxlY3RlZDpcblx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZEdyYWRlKGFjdGlvbi52YWx1ZSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMubmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQ6XG5cdFx0XHRDaXR5U3RvcmUuc2V0SGlnaGxpZ2h0ZWRIb2xjSWQoYWN0aW9uLmhvbGNJZCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMubmVpZ2hib3Job29kU2VsZWN0ZWQ6XG5cdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRDYXRlZ29yeShudWxsKTtcblx0XHRcdENpdHlTdG9yZS5zZXRTZWxlY3RlZEhvbGNJZChhY3Rpb24uaG9sY0lkKTtcblx0XHRcdGlmIChhY3Rpb24uYWRJZCAhPT0gQ2l0eVN0b3JlLmdldElkKCkpIHtcblx0XHRcdFx0Q2l0eVN0b3JlLmxvYWREYXRhKGFjdGlvbi5hZElkLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMucmluZ0dyYWRlU2VsZWN0ZWQ6XG5cdFx0XHRDaXR5U3RvcmUuc2V0U2VsZWN0ZWRSaW5nR3JhZGUoYWN0aW9uLnZhbHVlKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5tYXBNb3ZlZDpcblx0XHRcdEFwcERpc3BhdGNoZXIud2FpdEZvcihbTWFwU3RhdGVTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG5cblx0XHRcdGxldCB2aXNpYmxlQWRJZHMgPSBNYXBTdGF0ZVN0b3JlLmdldFZpc2libGVBZElkcygpO1xuXHRcdFx0Ly8gdW5sb2FkIGNpdHkgaWYgbm90aGluZydzIHZpc2libGUgXG5cdFx0XHRpZiAodmlzaWJsZUFkSWRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdENpdHlTdG9yZS5sb2FkRGF0YShudWxsKTtcblx0XHRcdH1cblx0XHRcdC8vIGxvYWQgYSBjaXR5IGlmIHRoZXJlJ3Mgb25seSBvbmUgdmlzaWJsZSBhbmQgaXQncyBkaWZmZXJlbnRcblx0XHRcdGVsc2UgaWYgKHZpc2libGVBZElkcy5sZW5ndGggPT0gMSAmJiB2aXNpYmxlQWRJZHNbMF0gIT09IENpdHlTdG9yZS5nZXRJZCgpKSB7XG5cdFx0XHRcdENpdHlTdG9yZS5sb2FkRGF0YSh2aXNpYmxlQWRJZHNbMF0sIHsgem9vbVRvOiBmYWxzZSB9KTtcblx0XHRcdH0gXG5cdFx0XHQvLyB1bmxvYWQgdGhlIGNpdHkgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgYnV0IGl0J3Mgbm90IGFtb25nIHRoZW1cblx0XHRcdGVsc2UgaWYgKHZpc2libGVBZElkcy5sZW5ndGggPiAxICYmIHZpc2libGVBZElkcy5pbmRleE9mKENpdHlTdG9yZS5nZXRJZCgpKSA9PSAtMSkge1xuXHRcdFx0XHRDaXR5U3RvcmUubG9hZERhdGEobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHQvLyB1bmxvYWQgY2l0eSBpZiBtb3JlIHRoYW4gb25lIGFyZSB2aXNpYmxlIGFuZCBpdCdzIGJlbG93IHRoZSB6b29tIHRocmVzaG9sZFxuXHRcdFx0ZWxzZSBpZiAodmlzaWJsZUFkSWRzLmxlbmd0aCA+IDEgJiYgIU1hcFN0YXRlU3RvcmUuaXNBYm92ZVpvb21UaHJlc2hvbGQoKSkge1xuXHRcdFx0XHRDaXR5U3RvcmUubG9hZERhdGEobnVsbCk7XG5cdFx0XHR9IFxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXG5cdHJldHVybiB0cnVlO1xuXG59KTtcblxuXG5leHBvcnQgZGVmYXVsdCBDaXR5U3RvcmU7IiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBBcHBEaXNwYXRjaGVyIGZyb20gJy4uL3V0aWxzL0FwcERpc3BhdGNoZXInO1xuaW1wb3J0IHsgQXBwQWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9BcHBBY3Rpb25DcmVhdG9yJztcbmltcG9ydCBDaXR5U3RvcmUgZnJvbSAnLi4vc3RvcmVzL0NpdHlTdG9yZSc7XG5pbXBvcnQgUmFzdGVyU3RvcmUgZnJvbSAnLi4vc3RvcmVzL1Jhc3RlclN0b3JlJztcblxuY29uc3QgTWFwU3RhdGVTdG9yZSA9IHtcblxuXHRkYXRhOiB7XG5cdFx0dGhlTWFwOiBudWxsLFxuXHRcdGNlbnRlcjogWzM5LjgzMzMzMzMsLTk4LjU4NTUyMl0sXG5cdFx0em9vbTogNSxcblx0XHRib3VuZHM6IG51bGwsXG5cdFx0dmlzaWJsZUhPTENNYXBzOiB7fSxcblx0XHR2aXNpYmxlSE9MQ01hcHNJZHM6IFtdLFxuXHRcdHZpc2libGVBZElkczogW10sXG5cdFx0YWRab29tVGhyZXNob2xkOiA5XG5cdH0sXG5cblx0bG9hZERhdGE6IGZ1bmN0aW9uICh0aGVNYXAsIHJhc3RlcnMpIHtcblx0XHRjb25zdCB0aGVCb3VuZHMgPSB0aGVNYXAuZ2V0Qm91bmRzKCk7XG5cdFx0bGV0IHZpc2libGVIT0xDTWFwcyA9IHt9LFxuXHRcdFx0dmlzaWJsZUhPTENNYXBzSWRzID0gW10sXG5cdFx0XHR2aXNpYmxlSE9MQ01hcHNCeVN0YXRlID0ge30sXG5cdFx0XHR2aXNpYmxlQWRJZHMgPSBbXTtcblxuXHRcdE9iamVjdC5rZXlzKHJhc3RlcnMpLmZvckVhY2goKGlkKSA9PiB7XG5cdFx0XHRpZiAodGhlQm91bmRzLmludGVyc2VjdHMocmFzdGVyc1tpZF0uYm91bmRzKSAmJiAhcmFzdGVyc1tpZF0ucGFyZW50X2lkKSB7XG5cdFx0XHRcdHZpc2libGVIT0xDTWFwc1tpZF0gPSByYXN0ZXJzW2lkXTtcblx0XHRcdFx0dmlzaWJsZUhPTENNYXBzSWRzLnB1c2gocGFyc2VJbnQoaWQpKTtcblx0XHRcdFx0aWYgKHZpc2libGVBZElkcy5pbmRleE9mKHJhc3RlcnNbaWRdLmFkX2lkKSA9PSAtMSkge1xuXHRcdFx0XHRcdHZpc2libGVBZElkcy5wdXNoKHBhcnNlSW50KHJhc3RlcnNbaWRdLmFkX2lkKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIG9yZ2FuaXplIGJ5IHN0YXRlXG5cdFx0dmlzaWJsZUhPTENNYXBzSWRzLmZvckVhY2goKGlkKSA9PiB7XG5cdFx0XHR2aXNpYmxlSE9MQ01hcHNCeVN0YXRlW3Zpc2libGVIT0xDTWFwc1tpZF0uc3RhdGVdID0gKHZpc2libGVIT0xDTWFwc0J5U3RhdGVbdmlzaWJsZUhPTENNYXBzW2lkXS5zdGF0ZV0pID8gdmlzaWJsZUhPTENNYXBzQnlTdGF0ZVt2aXNpYmxlSE9MQ01hcHNbaWRdLnN0YXRlXSA6IFtdO1xuXHRcdFx0dmlzaWJsZUhPTENNYXBzQnlTdGF0ZVt2aXNpYmxlSE9MQ01hcHNbaWRdLnN0YXRlXS5wdXNoKHZpc2libGVIT0xDTWFwc1tpZF0pO1xuXHRcdH0pO1xuXHRcdC8vIGFscGhhYmV0aXplXG5cdFx0T2JqZWN0LmtleXModmlzaWJsZUhPTENNYXBzQnlTdGF0ZSkuZm9yRWFjaCgodGhlX3N0YXRlKSA9PiB7XG5cdFx0XHR2aXNpYmxlSE9MQ01hcHNCeVN0YXRlW3RoZV9zdGF0ZV0uc29ydCgoYSxiKSA9PiBhLmNpdHkgPiBiLmNpdHkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5kYXRhLnRoZU1hcCA9IHRoZU1hcDtcblx0XHR0aGlzLmRhdGEuY2VudGVyID0gW3RoZU1hcC5nZXRDZW50ZXIoKS5sYXQsIHRoZU1hcC5nZXRDZW50ZXIoKS5sbmddO1xuXHRcdHRoaXMuZGF0YS56b29tID0gdGhlTWFwLmdldFpvb20oKTtcblx0XHR0aGlzLmRhdGEuYm91bmRzID0gdGhlQm91bmRzO1xuXHRcdHRoaXMuZGF0YS52aXNpYmxlSE9MQ01hcHMgPSB2aXNpYmxlSE9MQ01hcHM7XG5cdFx0dGhpcy5kYXRhLnZpc2libGVIT0xDTWFwc0lkcyA9IHZpc2libGVIT0xDTWFwc0lkcztcblx0XHR0aGlzLmRhdGEudmlzaWJsZUhPTENNYXBzQnlTdGF0ZSA9IHZpc2libGVIT0xDTWFwc0J5U3RhdGU7XG5cdFx0dGhpcy5kYXRhLnZpc2libGVBZElkcyA9IHZpc2libGVBZElkcztcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdNYXBTdGF0ZVN0b3JlIGZpbmlzaGVkIGxvYWRpbmcnKTtcblxuXHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHR9LFxuXG5cdHNldFZpZXc6IGZ1bmN0aW9uICh6b29tLCBjZW50ZXIpIHtcblx0XHR0aGlzLmRhdGEuem9vbSA9IHpvb207XG5cdFx0dGhpcy5kYXRhLmNlbnRlciA9IGNlbnRlcjtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRnZXRUaGVNYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudGhlTWFwO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jZW50ZXI7XG5cdH0sXG5cblx0Z2V0Wm9vbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS56b29tO1xuXHR9LFxuXG5cdGdldFZpc2libGVIT0xDTWFwczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS52aXNpYmxlSE9MQ01hcHM7XG5cdH0sXG5cblx0Z2V0VmlzaWJsZUhPTENNYXBzSWRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnZpc2libGVIT0xDTWFwc0lkcztcblx0fSxcblxuXHRnZXRWaXNpYmxlSE9MQ01hcHNCeVN0YXRlKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudmlzaWJsZUhPTENNYXBzQnlTdGF0ZTtcblx0fSxcblxuXHRnZXRWaXNpYmxlQWRJZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEudmlzaWJsZUFkSWRzO1xuXHR9LFxuXG5cdGlzQWJvdmVab29tVGhyZXNob2xkKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuem9vbSA+PSB0aGlzLmRhdGEuYWRab29tVGhyZXNob2xkO1xuXHR9XG59XG5cbi8vIE1peGluIEV2ZW50RW1pdHRlciBmdW5jdGlvbmFsaXR5XG5PYmplY3QuYXNzaWduKE1hcFN0YXRlU3RvcmUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBSZWdpc3RlciBjYWxsYmFjayB0byBoYW5kbGUgYWxsIHVwZGF0ZXNcbk1hcFN0YXRlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoKGFjdGlvbikgPT4ge1xuXG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMubG9hZEluaXRpYWxEYXRhOlxuXHRcdFx0Ly8geW91IGhhdmUgdG8gd2FpdCBmb3IgUmFzdGVyU3RvcmUgYW5kLCBpZiBhIGNpdHkgaXMgcmVxdWVzdGVkIGluIHRoZSBoYXNoLCBDaXR5U3RvcmUgdG8gZmluaXNoIHRoZWlyIGluaXRpYWwgbG9hZFxuXHRcdFx0Y29uc3Qgd2FpdGluZ0luaXRpYWxMb2FkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0XHRpZiAoUmFzdGVyU3RvcmUuaGFzTG9hZGVkKCkgJiYgKCFhY3Rpb24uc3RhdGUuc2VsZWN0ZWRDaXR5IHx8IENpdHlTdG9yZS5oYXNMb2FkZWQoKSkpIHtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKHdhaXRpbmdJbml0aWFsTG9hZCk7XG5cblx0XHRcdFx0XHRsZXQgem9vbSxcblx0XHRcdFx0XHRcdGNlbnRlcjtcblxuXHRcdFx0XHRcdGlmIChhY3Rpb24uaGFzaFN0YXRlLmxvYykge1xuXHRcdFx0XHRcdFx0em9vbSA9IGFjdGlvbi5oYXNoU3RhdGUubG9jLnpvb207XG5cdFx0XHRcdFx0XHRjZW50ZXIgPSBhY3Rpb24uaGFzaFN0YXRlLmxvYy5jZW50ZXI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChDaXR5U3RvcmUuZ2V0SWQoKSkge1xuXHRcdFx0XHRcdFx0em9vbSA9IDEyO1xuXHRcdFx0XHRcdFx0Y2VudGVyID0gKENpdHlTdG9yZS5nZXRQb2x5Z29uc0NlbnRlcigpKSA/IENpdHlTdG9yZS5nZXRQb2x5Z29uc0NlbnRlcigpIDogUmFzdGVyU3RvcmUuZ2V0Q2VudGVyKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHpvb20gPSBhY3Rpb24uc3RhdGUubWFwLnpvb207XG5cdFx0XHRcdFx0XHRjZW50ZXIgPSBhY3Rpb24uc3RhdGUubWFwLmNlbnRlcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRNYXBTdGF0ZVN0b3JlLnNldFZpZXcoem9vbSwgY2VudGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5tYXBJbml0aWFsaXplZDpcblx0XHRcdE1hcFN0YXRlU3RvcmUubG9hZERhdGEoYWN0aW9uLnRoZU1hcCwgYWN0aW9uLnJhc3RlcnMpO1xuXG5cdFx0XHQvLyBpZiBhIGNpdHkgaGFzIGJlZW4gc2VsZWN0ZWQgKHRob3VnaCB0aGUgaGFzaCksIHNldCB0aGUgbmV3IGJvdW5kc1xuXHRcdFx0aWYgKENpdHlTdG9yZS5nZXRJZCgpKSB7XG5cdFx0XHRcdGNvbnN0IGJvdW5kcyA9IChDaXR5U3RvcmUuZ2V0UG9seWdvbnNCb3VuZHMoKSkgPyBDaXR5U3RvcmUuZ2V0UG9seWdvbnNCb3VuZHMoKSA6IFJhc3RlclN0b3JlLmdldE1hcEJvdW5kcygpLFxuXHRcdFx0XHRcdG5ld1pvb20gPSBhY3Rpb24udGhlTWFwLmdldEJvdW5kc1pvb20oYm91bmRzKSxcblx0XHRcdFx0XHRuZXdDZW50ZXIgPSAoQ2l0eVN0b3JlLmdldFBvbHlnb25zQ2VudGVyKCkpID8gQ2l0eVN0b3JlLmdldFBvbHlnb25zQ2VudGVyKCkgOiBSYXN0ZXJTdG9yZS5nZXRDZW50ZXIoKTtcblx0XHRcdFx0Ly9NYXBTdGF0ZVN0b3JlLnNldFZpZXcobmV3Wm9vbSwgbmV3Q2VudGVyKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy5tYXBNb3ZlZDpcblx0XHRcdE1hcFN0YXRlU3RvcmUubG9hZERhdGEoYWN0aW9uLnRoZU1hcCwgYWN0aW9uLnJhc3RlcnMpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmNpdHlTZWxlY3RlZDpcblx0XHRcdC8vIHlvdSBoYXZlIHRvIHdhaXQgZm9yIENpdHlTdG9yZSBhbmQgUmFzdGVyU3RvcmUgdG8gZmluaXNoIHRoZWlyIGluaXRpYWwgbG9hZFxuXHRcdFx0QXBwRGlzcGF0Y2hlci53YWl0Rm9yKFtSYXN0ZXJTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG5cblx0XHRcdGNvbnN0IHdhaXRpbmdJZCA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdFx0aWYgKGFjdGlvbi52YWx1ZSA9PSBDaXR5U3RvcmUuZ2V0SWQoKSkge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwod2FpdGluZ0lkKTtcblxuXHRcdFx0XHRcdGlmIChhY3Rpb24uc2VsZWN0ZWRCeVVzZXIgJiYgTWFwU3RhdGVTdG9yZS5nZXRUaGVNYXAoKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgYm91bmRzID0gKENpdHlTdG9yZS5nZXRQb2x5Z29uc0JvdW5kcygpKSA/IENpdHlTdG9yZS5nZXRQb2x5Z29uc0JvdW5kcygpIDogUmFzdGVyU3RvcmUuZ2V0TWFwQm91bmRzKCksXG5cdFx0XHRcdFx0XHRcdG5ld1pvb20gPSBNYXBTdGF0ZVN0b3JlLmdldFRoZU1hcCgpLmdldEJvdW5kc1pvb20oYm91bmRzKSxcblx0XHRcdFx0XHRcdFx0bmV3Q2VudGVyID0gKENpdHlTdG9yZS5nZXRQb2x5Z29uc0NlbnRlcigpKSA/IENpdHlTdG9yZS5nZXRQb2x5Z29uc0NlbnRlcigpIDogUmFzdGVyU3RvcmUuZ2V0Q2VudGVyKCk7XG5cdFx0XHRcdFx0XHRNYXBTdGF0ZVN0b3JlLnNldFZpZXcobmV3Wm9vbSwgbmV3Q2VudGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIDEwMCk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwU3RhdGVTdG9yZTsiLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IEFwcERpc3BhdGNoZXIgZnJvbSAnLi4vdXRpbHMvQXBwRGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBBcHBBY3Rpb25UeXBlcyB9IGZyb20gJy4uL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuaW1wb3J0IENhcnRvREJMb2FkZXIgZnJvbSAnLi4vdXRpbHMvQ2FydG9EQkxvYWRlcic7XG5cbmltcG9ydCBzdGF0ZUFiYnJzIGZyb20gJy4uLy4uL2RhdGEvc3RhdGVfYWJici5qc29uJztcblxuY29uc3QgUmFzdGVyU3RvcmUgPSB7XG5cblx0ZGF0YToge1xuXHRcdC8qKlxuXHRcdCAqIE1ldGFkYXRhIGFib3V0IHRoZSBtYXBzXG5cdFx0ICogYnkgeWVhciAodGhpcmQgb3JkZXIpLCBjaXR5IChzZWNvbmQgb3JkZXIpLCBhbmQgc3RhdGUsIGZpcnN0IG9yZGVyXG5cdFx0ICoge1xuXHRcdCAqICAgc3RhdGVYOiB7XG5cdFx0ICogICAgIGNpdHlYOiB7XG5cdFx0ICogICAgICAgeWVhcng6IHtcblx0XHQgKiAgICAgICAgIHVybDogJ3N0cicsXG5cdFx0ICogICAgICAgICBib3VuZHM6ICdsYXRsbmdib3VuZHMnLFxuXHRcdCAqICAgICAgICAgbWluWm9vbTogaW50LFxuXHRcdCAqICAgICAgICAgbWF4dFpvb206IGludFxuXHRcdCAqICAgICAgIH0sXG5cdFx0ICogICAgICAgeWVhclk6IHsgLi4uIH1cblx0XHQgKiAgICAgfSxcblx0XHQgKiAgICAgY2l0eVk6IHsgLi4uIH0sXG5cdFx0ICogICAgIG5hbWU6ICdzdHInLFxuXHRcdCAqICAgICBkZXNjcmlwdGlvbjogJ3N0cicsXG5cdFx0ICogICAgIHVuaXRzOiAnc3RyJ1xuXHRcdCAqICAgfSxcblx0XHQgKiAgIHN0YXRlWTogeyAuLi4gfSxcblx0XHQgKiAgIC4uLlxuXHRcdCAqIH1cblx0XHQgKi9cblx0XHQgbWFwcyA6IHt9LFxuXHRcdCBjaXRpZXNXaXRoUG9seWdvbnM6IHt9LCBcblx0XHQgY2l0eUlkc1dpdGhBRHM6IFtdLFxuXG5cdFx0IHNlbGVjdGVkQ2l0eTogbnVsbCxcblx0XHQgc2VsZWN0ZWRTdGF0ZTogbnVsbCxcblx0XHQgbG9hZGVkOiBmYWxzZVxuXG5cdH0sXG5cblx0Ly8gVE9ETzogTWFrZSBhIGdlbmVyaWMgRGF0YUxvYWRlciBjbGFzcyB0byBkZWZpbmUgYW4gaW50ZXJmYWNlLFxuXHQvLyBhbmQgbGV0IENhcnRvREJMb2FkZXIgZXh0ZW5kIGFuZCBpbXBsZW1lbnQgdGhhdD9cblx0Ly8gQmFzaWMgaWRlYSBpcyB0aGF0IGFueXRoaW5nIHdpdGggYSBxdWVyeSBtZXRob2QgdGhhdCByZXR1cm5zIGEgUHJvbWlzZVxuXHQvLyB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgcmVzcG9uc2UgZGF0YSBvciByZWplY3RzIHdpdGggYW4gZXJyb3Jcblx0Ly8gY2FuIGJlIHVzZWQgaGVyZS5cblx0ZGF0YUxvYWRlcjogQ2FydG9EQkxvYWRlcixcblxuXG5cdGxvYWRJbml0aWFsRGF0YTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cblx0XHR0aGlzLmRhdGFMb2FkZXIucXVlcnkoW1xuXHRcdFx0e1xuXHRcdFx0XHRxdWVyeTogJ1NFTEVDVCBwb3B1bGF0aW9uXzE5NDAsIHBvcHVsYXRpb25fMTkzMCwgYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwLCBhbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5NDAsIGFzaWFuX3BhY2lmaWNfaWxzbGFuZGVyXzE5MzAgYXMgYXNpYW5fcGFjaWZpY19pc2xhbmRlcl8xOTMwLCBhc2lhbl9wYWNpZmljX2lsc2xhbmRlcl8xOTQwIGFzIGFzaWFuX3BhY2lmaWNfaXNsYW5kZXJfMTk0MCwgYmxhY2tfcG9wXzE5MzAsIGJsYWNrX3BvcF8xOTQwLCB3aGl0ZV9wb3BfMTkzMCwgd2hpdGVfcG9wXzE5NDAsIGFkX2lkLCBob2xjX21hcHMuKiwgc3RfeG1pbihob2xjX21hcHMudGhlX2dlb20pIGFzIG1pbkxuZywgc3RfeG1heChob2xjX21hcHMudGhlX2dlb20pIGFzIG1heExuZywgc3RfeW1pbihob2xjX21hcHMudGhlX2dlb20pIGFzIG1pbkxhdCwgc3RfeW1heChob2xjX21hcHMudGhlX2dlb20pIGFzIG1heExhdCwgc3RfeChzdF9jZW50cm9pZChob2xjX21hcHMudGhlX2dlb20pKSBhcyBjZW50ZXJMbmcsIHN0X3koc3RfY2VudHJvaWQoaG9sY19tYXBzLnRoZV9nZW9tKSkgYXMgY2VudGVyTGF0IEZST00gaG9sY19tYXBzIGpvaW4gaG9sY19tYXBzX2Fkc19qb2luIGhtYWogb24gaG1hai5tYXBfaWQgPSBob2xjX21hcHMubWFwX2lkIGpvaW4gaG9sY19hZHMgb24gaG9sY19hZHMuY2l0eV9pZCA9IGhtYWouYWRfaWQgb3JkZXIgYnkgcGFyZW50X2lkIGRlc2MnLFxuXHRcdFx0XHRmb3JtYXQ6ICdKU09OJ1xuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0cXVlcnk6ICdTRUxFQ1QgZGlzdGluY3QoaG9sY19hZHMuY2l0eV9pZCksIHN0YXRlLCBjaXR5IEZST00gaG9sY19hZF9kYXRhIGpvaW4gZGlnaXRhbHNjaG9sYXJzaGlwbGFiLmhvbGNfcG9seWdvbnMgb24gcG9seWdvbl9pZCA9IGhvbGNfcG9seWdvbnMubmVpZ2hib3Job29kX2lkIGpvaW4gaG9sY19hZHMgb24gaG9sY19wb2x5Z29ucy5hZF9pZCA9IGhvbGNfYWRzLmNpdHlfaWQgb3JkZXIgYnkgc3RhdGUsIGNpdHknLFxuXHRcdFx0XHRmb3JtYXQ6ICdKU09OJ1xuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0cXVlcnk6IFwiU0VMRUNUIGFkX2lkLCBzdW0oc3RfYXJlYSh0aGVfZ2VvbV93ZWJtZXJjYXRvcikpIC8gMTYwOS4zNF4yIGFzIHRvdGFsX2FyZWEsIHN1bShDQVNFIFdIRU4gaG9sY19ncmFkZSA9ICdBJyBUSEVOIHN0X2FyZWEodGhlX2dlb21fd2VibWVyY2F0b3IpIEVMU0UgMCBFTkQpIC8gMTYwOS4zNF4yIGFzIGFyZWFfYSwgc3VtKENBU0UgV0hFTiBob2xjX2dyYWRlID0gJ0InIFRIRU4gc3RfYXJlYSh0aGVfZ2VvbV93ZWJtZXJjYXRvcikgRUxTRSAwIEVORCkgLyAxNjA5LjM0XjIgYXMgYXJlYV9iLCBzdW0oQ0FTRSBXSEVOIGhvbGNfZ3JhZGUgPSAnQycgVEhFTiBzdF9hcmVhKHRoZV9nZW9tX3dlYm1lcmNhdG9yKSBFTFNFIDAgRU5EKSAvIDE2MDkuMzReMiBhcyBhcmVhX2MsIHN1bShDQVNFIFdIRU4gaG9sY19ncmFkZSA9ICdEJyBUSEVOIHN0X2FyZWEodGhlX2dlb21fd2VibWVyY2F0b3IpIEVMU0UgMCBFTkQpIC8gMTYwOS4zNF4yIGFzIGFyZWFfZCBGUk9NIGRpZ2l0YWxzY2hvbGFyc2hpcGxhYi5ob2xjX3BvbHlnb25zIGdyb3VwIGJ5IGFkX2lkIG9yZGVyIGJ5IGFkX2lkIGRlc2NcIixcblx0XHRcdFx0Zm9ybWF0OiAnSlNPTidcblx0XHRcdH1cblx0XHRdKS50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0dGhpcy5kYXRhLm1hcHMgPSB0aGlzLnBhcnNlTWFwRGF0YShyZXNwb25zZVswXSwgcmVzcG9uc2VbMl0sIHJlc3BvbnNlWzFdKTtcblx0XHRcdHRoaXMuZGF0YS5jaXR5SWRzV2l0aEFEcyA9IHJlc3BvbnNlWzFdLm1hcCgocm93KSA9PiByb3cuaWQpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRDaXR5ID0gc3RhdGUuc2VsZWN0ZWRDaXR5O1xuXHRcdFx0dGhpcy5kYXRhLnNlbGVjdGVkU3RhdGUgPSBzdGF0ZS5zZWxlY3RlZFN0YXRlO1xuXG5cdFx0XHR0aGlzLmRhdGEubG9hZGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1Jhc3RlclN0b3JlIGZpbmlzaGVkIGxvYWRpbmcnKTtcblxuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdFx0fSxcblx0XHQoZXJyb3IpID0+IHtcblx0XHRcdC8vIFRPRE86IGhhbmRsZSB0aGlzLlxuXHRcdFx0Y29uc29sZS5sb2coJ1Jhc3RlclN0b3JlIHJlY2VpdmVkIGVycm9yOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgc2VsZWN0ZWQgY2l0eSBmb3IgdGhlIHdob2xlIGFwcGxpY2F0aW9uIHRvIGRpc3BsYXkuXG5cdCAqL1xuXHRzZXRTZWxlY3RlZENpdHk6IGZ1bmN0aW9uIChjaXR5SWQpIHtcblx0XHR0aGlzLmRhdGEuc2VsZWN0ZWRDaXR5ID0gY2l0eUlkOyAgXG5cdH0sXG5cblx0c2V0U2VsZWN0ZWRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0aWYgKHR5cGVvZihzdGF0ZSkgIT09ICd1bmRlZmluZWQnICYmIHN0YXRlICE9PSB0aGlzLmRhdGEuc2VsZWN0ZWRTdGF0ZSkge1xuXHRcdFx0dGhpcy5kYXRhLnNlbGVjdGVkQ2l0eSA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuZW1pdChBcHBBY3Rpb25UeXBlcy5zdG9yZUNoYW5nZWQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRBbGxSYXN0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGEubWFwczsgfSxcblxuXHRnZXRTZWxlY3RlZENpdHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZENpdHk7IH0sXG5cblx0Z2V0QWxsQ2l0aWVzV2l0aFBvbHlnb25zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGF0YS5jaXRpZXNXaXRoUG9seWdvbnM7IH0sXG5cblx0Ly8gcmV0dXJucyBldmVyeXRoaW5nIG9yIGEgc3BlY2lmaWVkIGF0dHJpYnV0ZVxuXHRnZXRTZWxlY3RlZENpdHlNZXRhZGF0YTogZnVuY3Rpb24oa2V5PW51bGwpIHsgXG5cdFx0aWYgKCF0aGlzLmdldFNlbGVjdGVkQ2l0eSgpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIChrZXkpID8gdGhpcy5kYXRhLm1hcHNbdGhpcy5nZXRTZWxlY3RlZENpdHkoKV1ba2V5XSA6IHRoaXMuZGF0YS5tYXBzW3RoaXMuZ2V0U2VsZWN0ZWRDaXR5KCldOyBcblx0fSxcblxuXHRnZXRDaXR5TWV0YWRhdGE6IGZ1bmN0aW9uKGNpdHlfaWQsIGtleT1udWxsKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEubWFwc1tjaXR5X2lkXSkgPyAoa2V5ICYmIHRoaXMuZGF0YS5tYXBzW2NpdHlfaWRdW2tleV0pID8gdGhpcy5kYXRhLm1hcHNbY2l0eV9pZF1ba2V5XSA6IHRoaXMuZGF0YS5tYXBzW2NpdHlfaWRdIDogbnVsbDtcblx0fSxcblxuXHRnZXRNYXBCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyBcblx0XHRcdFsgdGhpcy5nZXRTZWxlY3RlZENpdHlNZXRhZGF0YSgnbWluTGF0JyksIHRoaXMuZ2V0U2VsZWN0ZWRDaXR5TWV0YWRhdGEoJ21pbkxuZycpIF0sIFxuXHRcdFx0WyB0aGlzLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCdtYXhMYXQnKSwgdGhpcy5nZXRTZWxlY3RlZENpdHlNZXRhZGF0YSgnbWF4TG5nJykgXSBcblx0XHRdO1xuXHR9LFxuXG5cdGdldE1hcEJvdW5kc0J5QWRJZDogZnVuY3Rpb24oYWRJZCkge1xuXHRcdHJldHVybiBbIFxuXHRcdFx0WyB0aGlzLmRhdGEubWFwc1thZElkXS5taW5MYXQsIHRoaXMuZGF0YS5tYXBzW2FkSWRdLm1pbkxuZyBdLCBcblx0XHRcdFsgdGhpcy5kYXRhLm1hcHNbYWRJZF0ubWF4TGF0LCB0aGlzLmRhdGEubWFwc1thZElkXS5tYXhMbmcgXSBcblx0XHRdO1xuXHR9LFxuXG5cdGdldENpdHlOYW1lczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRhdGEubWFwcykubWFwKChpZCkgPT4gdGhpcy5kYXRhLm1hcHNbaWRdLmNpdHkgKyAnLCAnICtzdGF0ZUFiYnJzW3RoaXMuZGF0YS5tYXBzW2lkXS5zdGF0ZV0pO1xuXHR9LFxuXG5cdGdldENpdHlJZHNXaXRoTmFtZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRsZXQgaWRzQW5kTmFtZXMgPSB7fTtcblxuXHRcdE9iamVjdC5rZXlzKHRoaXMuZGF0YS5tYXBzKS5mb3JFYWNoKChpZCkgPT4ge1xuXHRcdFx0aWRzQW5kTmFtZXNbaWRdID0gdGhpcy5kYXRhLm1hcHNbaWRdLmNpdHkgKyAnLCAnICtzdGF0ZUFiYnJzW3RoaXMuZGF0YS5tYXBzW2lkXS5zdGF0ZV1cblx0XHR9KTtcblxuXHRcdHJldHVybiBpZHNBbmROYW1lcztcblx0fSxcblxuXHRnZXRDaXR5SWRzQW5kTmFtZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhLm1hcHMpLm1hcCgoaWQpID0+IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBwYXJzZUludChpZCksXG5cdFx0XHRcdGNpdHlOYW1lOiB0aGlzLmRhdGEubWFwc1tpZF0uY2l0eSArICcsICcgKyBzdGF0ZUFiYnJzW3RoaXMuZGF0YS5tYXBzW2lkXS5zdGF0ZV1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuZ2V0U2VsZWN0ZWRDaXR5TWV0YWRhdGEoJ2NlbnRlckxhdCcpLCB0aGlzLmdldFNlbGVjdGVkQ2l0eU1ldGFkYXRhKCdjZW50ZXJMbmcnKV07XG5cdH0sXG5cblx0Z2V0Q2VudGVyT2xkOiBmdW5jdGlvbigpIHtcblx0XHRsZXQgYm91bmRzID0gdGhpcy5nZXRNYXBCb3VuZHMoKTtcblx0XHRyZXR1cm4gWyhib3VuZHNbMF1bMF0gKyBib3VuZHNbMV1bMF0pIC8gMiwgKGJvdW5kc1swXVsxXSArIGJvdW5kc1sxXVsxXSkgLyAyXTtcblx0fSxcblxuXHRnZXRNYXBCb3VuZHNGb3JTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0bGV0IG1pbkxhdCA9IDkwLCBtaW5MbmcgPSAwLCBtYXhMYXQgPSAwLCBtYXhMbmcgPSAtMTgwO1xuXHRcdGxldCBjaXRpZXNGb3JTdGF0ZSA9IHRoaXMuZ2V0Q2l0aWVzRm9yU3RhdGUoc3RhdGUpO1xuXG5cdFx0Y2l0aWVzRm9yU3RhdGUuZm9yRWFjaCgoY2l0eURhdGEpID0+IHtcblx0XHRcdG1pbkxhdCA9IChjaXR5RGF0YS5taW5MYXQgJiYgY2l0eURhdGEubWluTGF0IDwgbWluTGF0KSA/IGNpdHlEYXRhLm1pbkxhdCA6IG1pbkxhdDtcblx0XHRcdG1heExhdCA9IChjaXR5RGF0YS5tYXhMYXQgJiYgY2l0eURhdGEubWF4TGF0ID4gbWF4TGF0KSA/IGNpdHlEYXRhLm1heExhdCA6IG1heExhdDtcblx0XHRcdG1pbkxuZyA9IChjaXR5RGF0YS5taW5MbmcgJiYgY2l0eURhdGEubWluTG5nIDwgbWluTG5nKSA/IGNpdHlEYXRhLm1pbkxuZyA6IG1pbkxuZztcblx0XHRcdG1heExuZyA9IChjaXR5RGF0YS5tYXhMbmcgJiYgY2l0eURhdGEubWF4TG5nID4gbWF4TG5nKSA/IGNpdHlEYXRhLm1heExuZyA6IG1heExuZztcblx0XHR9KTtcblxuXHRcdHJldHVybiBbWyBtaW5MYXQsIG1pbkxuZyBdLFsgbWF4TGF0LCBtYXhMbmcgXV07XG5cdH0sXG5cblx0Z2V0Q2VudGVyRm9yU3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0bGV0IGJvdW5kcyA9IHRoaXMuZ2V0TWFwQm91bmRzRm9yU3RhdGUoc3RhdGUpO1xuXHRcdHJldHVybiBbKGJvdW5kc1swXVswXSArIGJvdW5kc1sxXVswXSkgLyAyLCAoYm91bmRzWzBdWzFdICsgYm91bmRzWzFdWzFdKSAvIDJdO1xuXHR9LFxuXG5cdGdldENpdGllc0ZvclN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaXRpZXNMaXN0KCkuZmlsdGVyKGZ1bmN0aW9uKGNpdHlEYXRhKSB7IHJldHVybiAoY2l0eURhdGEuc3RhdGUgPT0gc3RhdGUpOyB9KTtcblx0fSxcblxuXHRnZXRNYXBVcmw6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTZWxlY3RlZENpdHlNZXRhZGF0YSgnbWFwdXJsJyk7XG5cdH0sXG5cblx0Z2V0TWFwVGh1bWJuYWlsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2VsZWN0ZWRDaXR5TWV0YWRhdGEoJ21hcFRodW1ibmFpbCcpO1xuXHR9LFxuXG5cdC8vIHJldHVybiBhIGZsYXQgbGlzdCBvZiB0aGUgSE9MQyBtYXBzIGZvciByZW5kZXJpbmdcblx0Z2V0Q2l0aWVzTGlzdDogZnVuY3Rpb24oKSB7IFxuXHRcdGxldCBjaXRpZXMgPSB0aGlzLmNvbWJpbmVDaXRpZXNMaXN0cygpO1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyhjaXRpZXMpLm1hcChjaXR5SWQgPT4gY2l0aWVzW2NpdHlJZF0pOyBcblx0fSxcblxuXHRnZXRTdGF0ZXNPYmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdGxldCBzdGF0ZXNPYmplY3QgPSB7fTtcblx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEubWFwcykubWFwKGNpdHlJZCA9PiB7XG5cdFx0XHRzdGF0ZXNPYmplY3RbdGhpcy5kYXRhLm1hcHNbY2l0eUlkXS5zdGF0ZV0gPSB7XG5cdFx0XHRcdGlkOiB0aGlzLmRhdGEubWFwc1tjaXR5SWRdLnN0YXRlLFxuXHRcdFx0XHRuYW1lOiBzdGF0ZUFiYnJzW3RoaXMuZGF0YS5tYXBzW2NpdHlJZF0uc3RhdGVdLFxuXHRcdFx0XHRjaXRpZXNJZHM6IHRoaXMuZ2V0Q2l0aWVzRm9yU3RhdGUodGhpcy5kYXRhLm1hcHNbY2l0eUlkXS5zdGF0ZSkubWFwKChjaXR5RGF0YSkgPT4gY2l0eURhdGEuaWQpXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHJldHVybiBzdGF0ZXNPYmplY3Q7XG5cdH0sXG5cblx0Z2V0U3RhdGVzTGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0bGV0IHN0YXRlcyA9IHRoaXMuZ2V0U3RhdGVzT2JqZWN0KCk7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlcykubWFwKHN0YXRlQWJiciA9PiBzdGF0ZXNbc3RhdGVBYmJyXSk7XG5cdH0sXG5cblx0Z2V0U3RhdGVzV2l0aEZpcnN0Q2l0aWVzOiBmdW5jdGlvbigpIHtcblx0XHRsZXQgc3RhdGVzID0gW10sXG5cdFx0XHQgIGNpdGllcyA9IHRoaXMuY29tYmluZUNpdGllc0xpc3RzKCksXG5cdFx0XHQgIHN0YXRlSW5MaXN0ID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdFx0ICBsZXQgaW5MaXN0ID0gZmFsc2U7XG5cdFx0XHRcdCAgc3RhdGVzLm1hcCgoY2l0eURhdGEpID0+IHtcblx0XHRcdFx0XHQgIGlmIChjaXR5RGF0YS5zdGF0ZSA9PSBzdGF0ZSkge1xuXHRcdFx0XHRcdFx0ICBpbkxpc3QgPSB0cnVlO1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHQgIH0pO1xuXHRcdFx0XHQgIHJldHVybiBpbkxpc3Q7XG5cdFx0XHQgIH07XG5cblx0XHRPYmplY3Qua2V5cyhjaXRpZXMpLm1hcCgoY2l0eUlkKSA9PiB7XG5cdFx0XHRpZiAoIXN0YXRlSW5MaXN0KHRoaXMuZGF0YS5tYXBzW2NpdHlJZF0uc3RhdGUpKSB7XG5cdFx0XHRcdHN0YXRlcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGF0YS5tYXBzW2NpdHlJZF0pKTtcblx0XHRcdH1cblx0XHR9KTsgXG5cblx0XHRzdGF0ZXMubWFwKChjaXR5RGF0YSkgPT4geyBjaXR5RGF0YS5uYW1lID0gc3RhdGVBYmJyc1tjaXR5RGF0YS5zdGF0ZV07IH0pO1xuXG5cdFx0cmV0dXJuIHN0YXRlcztcblx0fSxcblxuXHRnZXRGaXJzdENpdHlPZlN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdGxldCBzdGF0ZXNXaXRoRmlyc3RDaXRpZXMgPSB0aGlzLmdldFN0YXRlc1dpdGhGaXJzdENpdGllcygpO1xuXHRcdGZvciAobGV0IGkgaW4gc3RhdGVzV2l0aEZpcnN0Q2l0aWVzKSB7XG5cdFx0XHRpZiAoc3RhdGVzV2l0aEZpcnN0Q2l0aWVzW2ldLnN0YXRlID09IHN0YXRlKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZXNXaXRoRmlyc3RDaXRpZXNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGhhc0xvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sb2FkZWQ7XG5cdH0sXG5cblx0c2VsZWN0ZWRIYXNQb2x5Z29uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRhdGEubWFwc1t0aGlzLmRhdGEuc2VsZWN0ZWRDaXR5XSkgPyB0aGlzLmRhdGEubWFwc1t0aGlzLmRhdGEuc2VsZWN0ZWRDaXR5XS5oYXNQb2x5Z29ucyA6IGZhbHNlO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZVNpbXBsZVJpbmdzUmFkaWk6IGZ1bmN0aW9uIChhcmVhRGF0YSkge1xuXHRcdGxldCBmdXJ0aGVzdFJhZGl1cyA9IDI1MDAwLFxuXHRcdFx0ZnVsbEFyZWEgPSBNYXRoLlBJICogZnVydGhlc3RSYWRpdXMgKiBmdXJ0aGVzdFJhZGl1cyxcblx0XHRcdG91dGVyUmFkaXVzLFxuXHRcdFx0aW5uZXJSYWRpdXMgPSAwLFxuXHRcdFx0ZG9udXRBcmVhLFxuXHRcdFx0Z3JhZGVBcmVhLFxuXHRcdFx0cmFkaWkgPSB7fTtcblxuXHRcdFsnZCcsJ2MnLCdiJywnYSddLmZvckVhY2goKGdyYWRlKSA9PiB7XG5cdFx0XHRsZXQgZG9udXRob2xlQXJlYSA9IE1hdGguUEkgKiBpbm5lclJhZGl1cyAqIGlubmVyUmFkaXVzLFxuXHRcdFx0XHRncmFkZUFyZWEgPSBmdWxsQXJlYSAqIChhcmVhRGF0YVtncmFkZV0gLyBhcmVhRGF0YS50b3RhbCksXG5cdFx0XHRcdG91dGVyUmFkaXVzID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoKGdyYWRlQXJlYSArIGRvbnV0aG9sZUFyZWEpIC8gTWF0aC5QSSkpO1xuXHRcdFx0cmFkaWlbZ3JhZGVdID0ge1xuXHRcdFx0XHQnaW5uZXInOiBpbm5lclJhZGl1cyxcblx0XHRcdFx0J291dGVyJzogb3V0ZXJSYWRpdXNcblx0XHRcdH07XG5cdFx0XHRpbm5lclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJhZGlpO1xuXHR9LFxuXG5cdGdldFNlbGVjdGVkTWFwczogZnVuY3Rpb24gKHJlcXVlc3RlZE1hcElkcywgc2VsZWN0ZWRBZCA9IG51bGwpIHtcblx0XHRsZXQgc2VsZWN0ZWRNYXBzID0gW107XG5cdFx0Y29uc3QgYWxsTWFwcyA9IHRoaXMuZ2V0TWFwc0xpc3QoKTtcblxuXHRcdGFsbE1hcHMuZm9yRWFjaChtYXAgPT4ge1xuXHRcdFx0aWYgKHJlcXVlc3RlZE1hcElkcy5pbmRleE9mKG1hcC5hZF9pZCkgIT09IC0xICYmIG1hcC5hZF9pZCAhPT0gc2VsZWN0ZWRBZCkge1xuXHRcdFx0XHRzZWxlY3RlZE1hcHMucHVzaChtYXApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YWxsTWFwcy5mb3JFYWNoKG1hcCA9PiB7XG5cdFx0XHRpZiAocmVxdWVzdGVkTWFwSWRzLmluZGV4T2YobWFwLmFkX2lkKSAhPT0gLTEgJiYgbWFwLmFkX2lkID09IHNlbGVjdGVkQWQpIHtcblx0XHRcdFx0c2VsZWN0ZWRNYXBzLnB1c2gobWFwKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXG5cdFx0cmV0dXJuIHNlbGVjdGVkTWFwcztcblx0fSxcblx0XG5cdC8vIHJldHVybiBhIGZsYXQgbGlzdCBvZiB0aGUgSE9MQyBtYXBzIGZvciByZW5kZXJpbmdcblx0Z2V0TWFwc0xpc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhLm1hcHMpLm1hcCgoY2l0eUlkKSA9PiB0aGlzLmRhdGEubWFwc1tjaXR5SWRdKTsgfSxcblxuXHRwYXJzZU1hcERhdGE6IGZ1bmN0aW9uIChjaXRpZXNEYXRhLCBjaXRpZXNXaXRoUG9seWdvbnNEYXRhLCBjaXRpZXNXaXRoQURzKSB7XG5cdFx0bGV0IG1hcHMgPSB7fTtcblxuXHRcdGNpdGllc0RhdGEuZm9yRWFjaChtYXBEYXRhID0+IHtcblx0XHRcdG1hcHNbbWFwRGF0YS5tYXBfaWRdID0ge1xuXHRcdFx0XHRjaXR5SWQgOiBtYXBEYXRhLmFkX2lkLFxuXHRcdFx0XHRpZDogbWFwRGF0YS5hZF9pZCxcblx0XHRcdFx0YWRfaWQ6IHBhcnNlSW50KG1hcERhdGEuYWRfaWQpLFxuXHRcdFx0XHRwYXJlbnRfaWQ6IG1hcERhdGEucGFyZW50X2lkLFxuXHRcdFx0XHRjaXR5OiBtYXBEYXRhLm5hbWUsXG5cdFx0XHRcdHN0YXRlOiBtYXBEYXRhLnN0YXRlLFxuXHRcdFx0XHRzZWFyY2hOYW1lOiAobWFwRGF0YS5wYXJlbnRfaWQpID8gJycgOiBtYXBEYXRhLm5hbWUgKyAnLCAnICsgc3RhdGVBYmJyc1ttYXBEYXRhLnN0YXRlXSxcblx0XHRcdFx0bmFtZTogbWFwRGF0YS5uYW1lLCAvLyArIFwiLCBcIiArIG1hcERhdGEuc3RhdGUsXG5cdFx0XHRcdG1pblpvb206IG1hcERhdGEubWluem9vbSxcblx0XHRcdFx0bWF4Wm9vbTogbWFwRGF0YS5tYXh6b29tLFxuXHRcdFx0XHRib3VuZHM6IFsgW21hcERhdGEubWlubGF0LG1hcERhdGEubWlubG5nXSwgW21hcERhdGEubWF4bGF0LG1hcERhdGEubWF4bG5nXSBdLFxuXHRcdFx0XHRtaW5MYXQ6IG1hcERhdGEubWlubGF0LFxuXHRcdFx0XHRtYXhMYXQ6IG1hcERhdGEubWF4bGF0LFxuXHRcdFx0XHRtaW5Mbmc6IG1hcERhdGEubWlubG5nLFxuXHRcdFx0XHRtYXhMbmc6IG1hcERhdGEubWF4bG5nLFxuXHRcdFx0XHRjZW50ZXJMYXQ6IG1hcERhdGEuY2VudGVybGF0LFxuXHRcdFx0XHRjZW50ZXJMbmc6IG1hcERhdGEuY2VudGVybG5nLFxuXHRcdFx0XHRwb3B1bGF0aW9uXzE5MzA6IG1hcERhdGEucG9wdWxhdGlvbl8xOTMwLFxuXHRcdFx0XHRwb3B1bGF0aW9uXzE5NDA6IG1hcERhdGEucG9wdWxhdGlvbl8xOTQwLFxuXHRcdFx0XHRhbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5MzA6IG1hcERhdGEuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTMwLFxuXHRcdFx0XHRhbWVyaWNhbl9pbmRpYW5fZXNraW1vXzE5NDA6IG1hcERhdGEuYW1lcmljYW5faW5kaWFuX2Vza2ltb18xOTQwLFxuXHRcdFx0XHRhc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5MzA6IG1hcERhdGEuYXNpYW5fcGFjaWZpY19pc2xhbmRlcl8xOTMwLFxuXHRcdFx0XHRhc2lhbl9wYWNpZmljX2lzbGFuZGVyXzE5NDA6IG1hcERhdGEuYXNpYW5fcGFjaWZpY19pc2xhbmRlcl8xOTQwLFxuXHRcdFx0XHRibGFja19wb3BfMTkzMDogbWFwRGF0YS5ibGFja19wb3BfMTkzMCxcblx0XHRcdFx0YmxhY2tfcG9wXzE5NDA6IG1hcERhdGEuYmxhY2tfcG9wXzE5NDAsXG5cdFx0XHRcdHdoaXRlX3BvcF8xOTMwOiBtYXBEYXRhLndoaXRlX3BvcF8xOTMwLFxuXHRcdFx0XHR3aGl0ZV9wb3BfMTk0MDogbWFwRGF0YS53aGl0ZV9wb3BfMTk0MCxcblx0XHRcdFx0aGFzUG9seWdvbnM6IGZhbHNlLFxuXHRcdFx0XHRoYXNBRHM6IGZhbHNlLFxuXHRcdFx0XHR1cmw6ICdodHRwOi8vaG9sYy5zMy13ZWJzaXRlLXVzLWVhc3QtMS5hbWF6b25hd3MuY29tL3RpbGVzLycgKyBtYXBEYXRhLnN0YXRlICsgJy8nICttYXBEYXRhLlx0ZmlsZV9uYW1lLnJlcGxhY2UoL1xccysvZywgJycpICArICcvJyArIG1hcERhdGEueWVhciArICcve3p9L3t4fS97eX0ucG5nJyxcblx0XHRcdFx0bWFwdXJsOiAnaHR0cDovL2hvbGMuczMtd2Vic2l0ZS11cy1lYXN0LTEuYW1hem9uYXdzLmNvbS90aWxlcy8nICsgbWFwRGF0YS5zdGF0ZSArICcvJyArbWFwRGF0YVx0LmZpbGVfbmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKSAgKyAnLycgKyBtYXBEYXRhLnllYXIgKyAnL2hvbGMtc2Nhbi5qcGcnLFxuXHRcdFx0XHRtYXBUaHVtYm5haWw6ICdodHRwOi8vaG9sYy5zMy13ZWJzaXRlLXVzLWVhc3QtMS5hbWF6b25hd3MuY29tL3RpbGVzLycgKyBtYXBEYXRhLnN0YXRlICsgJy8nICsgXHRtYXBEYXRhLmZpbGVfbmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKSAgKyAnLycgKyBtYXBEYXRhLnllYXIgKyAnL3RodW1ibmFpbC5qcGcnXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjaXRpZXNXaXRoUG9seWdvbnNEYXRhLmZvckVhY2goYXJlYURhdGEgPT4ge1xuXHRcdFx0aWYgKG1hcHNbYXJlYURhdGEuYWRfaWRdKSB7XG5cdFx0XHRcdG1hcHNbYXJlYURhdGEuYWRfaWRdLmhhc1BvbHlnb25zID0gdHJ1ZSxcblx0XHRcdFx0bWFwc1thcmVhRGF0YS5hZF9pZF0uYXJlYSA9IHtcblx0XHRcdFx0XHQndG90YWwnIDogYXJlYURhdGEudG90YWxfYXJlYSxcblx0XHRcdFx0XHQnYSc6IGFyZWFEYXRhLmFyZWFfYSxcblx0XHRcdFx0XHQnYic6IGFyZWFEYXRhLmFyZWFfYixcblx0XHRcdFx0XHQnYyc6IGFyZWFEYXRhLmFyZWFfYyxcblx0XHRcdFx0XHQnZCc6IGFyZWFEYXRhLmFyZWFfZFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtYXBzW2FyZWFEYXRhLmFkX2lkXS5yYWRpaSA9IHRoaXMuY2FsY3VsYXRlU2ltcGxlUmluZ3NSYWRpaShtYXBzW2FyZWFEYXRhLmFkX2lkXS5hcmVhKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y2l0aWVzV2l0aEFEcy5mb3JFYWNoKGFyZWFEYXRhID0+IHtcblx0XHRcdGlmIChtYXBzW2FyZWFEYXRhLmlkXSkge1xuXHRcdFx0XHRtYXBzW2FyZWFEYXRhLmlkXS5oYXNBRHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG1hcHM7XG5cblx0fSxcblxuXHRwYXJzZUNpdGllc1dpdGhQb2x5Z29uc0RhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0bGV0IGNpdGllcyA9IHt9O1xuXG5cdFx0ZGF0YS5mb3JFYWNoKGNpdGllc0RhdGEgPT4ge1xuXHRcdFx0Y2l0aWVzW2NpdGllc0RhdGEuaWRdID0ge1xuXHRcdFx0XHRhZElkOiAgY2l0aWVzRGF0YS5pZCxcblx0XHRcdFx0aWQ6IGNpdGllc0RhdGEuaWQsXG5cdFx0XHRcdGNpdHk6IGNpdGllc0RhdGEuY2l0eSxcblx0XHRcdFx0c3RhdGU6IGNpdGllc0RhdGEuc3RhdGUsXG5cdFx0XHRcdG5hbWU6IGNpdGllc0RhdGEuY2l0eSArICAoKHRoaXMuZGF0YS5jaXR5SWRzV2l0aEFEcy5pbmRleE9mKGNpdGllc0RhdGEuaWQgKSAhPSAtMSkgPyAnICoqJyA6ICcgKicpLCAvLyBcIiwgXCIgKyBzdGF0ZUFiYnJzW2NpdGllc0RhdGEuc3RhdGVdICtcblx0XHRcdFx0bWluTGF0OiBjaXRpZXNEYXRhLm1pbmxhdCxcblx0XHRcdFx0bWF4TGF0OiBjaXRpZXNEYXRhLm1heGxhdCxcblx0XHRcdFx0bWluTG5nOiBjaXRpZXNEYXRhLm1pbmxuZyxcblx0XHRcdFx0bWF4TG5nOiBjaXRpZXNEYXRhLm1heGxuZyxcblx0XHRcdFx0Y2VudGVyTGF0OiBjaXRpZXNEYXRhLmNlbnRlcmxhdCxcblx0XHRcdFx0Y2VudGVyTG5nOiBjaXRpZXNEYXRhLmNlbnRlcmxuZyxcblx0XHRcdFx0aGFzUG9seWdvbnM6IHRydWUsXG5cdFx0XHRcdGhhc0FEczogKHRoaXMuZGF0YS5jaXR5SWRzV2l0aEFEcy5pbmRleE9mKGNpdGllc0RhdGEuaWQgKSAhPSAtMSlcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY2l0aWVzO1xuXHR9LFxuXG5cdGNvbWJpbmVDaXRpZXNMaXN0czogZnVuY3Rpb24gKCkge1xuXHRcdGxldCBjb21iaW5lZExpc3QgPSB7fTtcblx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEubWFwcykubWFwKChpZCwgaSkgPT4ge1xuXHRcdFx0Y29tYmluZWRMaXN0W2lkXSA9ICh0aGlzLmRhdGEuY2l0aWVzV2l0aFBvbHlnb25zW2lkXSkgPyB0aGlzLmRhdGEuY2l0aWVzV2l0aFBvbHlnb25zW2lkXSA6IHRoaXMuZGF0YS5tYXBzW2lkXTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjb21iaW5lZExpc3Q7XG5cdH1cblxufTtcblxuLy8gTWl4aW4gRXZlbnRFbWl0dGVyIGZ1bmN0aW9uYWxpdHlcbk9iamVjdC5hc3NpZ24oUmFzdGVyU3RvcmUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBSZWdpc3RlciBjYWxsYmFjayB0byBoYW5kbGUgYWxsIHVwZGF0ZXNcblJhc3RlclN0b3JlLmRpc3BhdGNoVG9rZW4gPSBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKChhY3Rpb24pID0+IHtcblxuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmxvYWRJbml0aWFsRGF0YTpcblx0XHRcdFJhc3RlclN0b3JlLmxvYWRJbml0aWFsRGF0YShhY3Rpb24uc3RhdGUpO1xuXHRcdFx0aWYgKGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHkpIHtcblx0XHRcdFx0UmFzdGVyU3RvcmUuc2V0U2VsZWN0ZWRDaXR5KGFjdGlvbi5zdGF0ZS5zZWxlY3RlZENpdHkpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIEFwcEFjdGlvblR5cGVzLmNpdHlTZWxlY3RlZDpcblx0XHRcdFJhc3RlclN0b3JlLnNldFNlbGVjdGVkQ2l0eShhY3Rpb24udmFsdWUpO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhc3RlclN0b3JlOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgQXBwRGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9BcHBEaXNwYXRjaGVyJztcbmltcG9ydCB7IEFwcEFjdGlvblR5cGVzIH0gZnJvbSAnLi4vdXRpbHMvQXBwQWN0aW9uQ3JlYXRvcic7XG5cbmNvbnN0IFRleHRzU3RvcmUgPSB7XG5cblx0ZGF0YToge1xuXHRcdG1vZGFsOiB7XG5cdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdHN1YmplY3Q6IG51bGxcblx0XHR9LFxuXHRcdGFib3V0OiBbXG5cdFx0XHRcIjxoMj5JbnRyb2R1Y3Rpb248L2gyPlwiLFxuXHRcdFx0XCI8cD48Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IHVwZGF0ZXMgdGhlIHN0dWR5IG9mIE5ldyBEZWFsIEFtZXJpY2EsIHRoZSBmZWRlcmFsIGdvdmVybm1lbnQsIGhvdXNpbmcsIGFuZCBpbmVxdWFsaXR5IGZvciB0aGUgdHdlbnR5LWZpcnN0IGNlbnR1cnkuIEl0IG9mZmVycyB1bnByZWNlZGVudGVkIG9ubGluZSBhY2Nlc3MgdG8gdGhlIG5hdGlvbmFsIGNvbGxlY3Rpb24gb2YgXFxcIlx0c2VjdXJpdHkgbWFwc1xcXCIgYW5kIGFyZWEgZGVzY3JpcHRpb25zIHByb2R1Y2VkIGJldHdlZW4gMTkzNSBhbmQgMTk0MCBieSBvbmUgb2YgdGhlIE5ldyBEZWFsJ3MgbW9zdCBpbXBvcnRhbnQgYWdlbmNpZXMsIHRoZSBIb21lIE93bmVycycgTG9hbiBDb3Jwb3JhdGlvbiBvciBIT0xDIChwcm9ub3VuY2VkIFxcXCJob2xrXFxcIikuIDwvcD5cIixcblx0XHRcdFwiPHA+SE9MQyByZWNydWl0ZWQgbW9ydGdhZ2UgbGVuZGVycywgZGV2ZWxvcGVycywgYW5kIHJlYWwgZXN0YXRlIGFwcHJhaXNlcnMgaW4gbmVhcmx5IDI1MCBjaXRpZXMgdG8gY3JlYXRlIG1hcHMgdGhhdCBjb2xvci1jb2RlZCBjcmVkaXQgd29ydGhpbmVzcyBhbmQgcmlzayBvbiBuZWlnaGJvcmhvb2QgYW5kIG1ldHJvcG9saXRhbiBsZXZlbHMuIFRoZXNlIG1hcHMgYW5kIHRoZWlyIGFjY29tcGFueWluZyBkb2N1bWVudGF0aW9uIGhlbHBlZCBzZXQgdGhlIHJ1bGVzIGZvciBuZWFybHkgYSBjZW50dXJ5IG9mIHJlYWwgZXN0YXRlIHByYWN0aWNlLiBUaGV5IGhhdmUgYWxzbyBzZXJ2ZWQgYXMgY3JpdGljYWwgZXZpZGVuY2UgaW4gY291bnRsZXNzIHVyYmFuIHN0dWRpZXMgaW4gdGhlIGZpZWxkcyBvZiBoaXN0b3J5LCBzb2Npb2xvZ3ksIGVjb25vbWljcywgYW5kIGxhdy4gIEluZGVlZCwgbW9yZSB0aGFuIGEgaGFsZi1jZW50dXJ5IG9mIHJlc2VhcmNoIGhhcyBzaG93biBob3VzaW5nIHRvIGJlIGZvciB0aGUgdHdlbnRpZXRoIGNlbnR1cnkgd2hhdCBzbGF2ZXJ5IHdhcyB0byB0aGUgYW50ZWJlbGx1bSBwZXJpb2QsIG5hbWVseSB0aGUgYnJvYWQgZm91bmRhdGlvbiBvZiBib3RoIEFtZXJpY2FuIHByb3NwZXJpdHkgYW5kIHJhY2lhbCBpbmVxdWFsaXR5LiAgVGhyb3VnaCBvZmZlcmluZyBhIGRpZ2l0YWwgbGlicmFyeSBvZiB0aGUgc3RhdGUncyByb2xlIGluIGhvdXNpbmcgZGV2ZWxvcG1lbnQsIE1hcHBpbmcgSW5lcXVhbGl0eSBpbGx1c3RyYXRlcyB2aXZpZGx5IHRoZSBpbnRlcnBsYXkgYmV0d2VlbiByYWNpc20sIGFkbWluaXN0cmF0aXZlIGN1bHR1cmUsIGVjb25vbWljcywgYW5kIHRoZSBidWlsdCBlbnZpcm9ubWVudC48L3A+XCIsXG5cdFx0XHRcIjxwPjxjaXRlPk1hcHBpbmcgSW5lcXVhbGl0eTwvY2l0ZT4gaW50cm9kdWNlcyB2aWV3ZXJzIHRvIHRoZSByZWNvcmRzIG9mIHRoZSBIb21lIE93bmVycyBMb2FuIENvcnBvcmF0aW9uIHdpdGggYWNjZXNzaWJpbGl0eSBhbmQgb24gYSBzY2FsZSB0aGF0IGlzIHVucHJlY2VkZW50ZWQuIFZpc2l0b3JzIGNhbiBicm93c2Ugb3ZlciB0d28taHVuZHJlZCBpbnRlcmFjdGl2ZSBtYXBzIGFuZCBnZXQgYSB2aWV3IG9mIERlcHJlc3Npb24tZXJhIEFtZXJpY2EgYXMgZGV2ZWxvcGVycywgcmVhbHRvcnMsIHRheCBhc3Nlc3NvcnMsIGFuZCBzdXJ2ZXlvcnMgc2F3IGl0JiM4MjEyO2Egc2V0IG9mIGludGVybG9ja2luZyBjb2xvci1saW5lcywgcmFjaWFsIGdyb3VwcywgYW5kIGVudmlyb25tZW50YWwgcmlza3MuICBUaGV5IGNhbiBhbHNvIHVzZSB0aGUgbWFwcyBhbmQgYXJlYSBkZXNjcmlwdGlvbnMgdG8gZHJhdyBjb25uZWN0aW9ucyBiZXR3ZWVuIHBhc3Qgc3RhdGUgYWN0aW9ucyAoYW5kIGluYWN0aW9ucykgYW5kIGNvbnRlbXBvcmFyeSBBbWVyaWNhbiBwcm9ibGVtcy48L3A+XCIsXG5cdFx0XHRcIjxoMz5BcmNoaXZpbmcgSW5lcXVhbGl0eSBmb3IgdGhlIERpZ2l0YWwgQWdlPC9oMz5cIixcblx0XHRcdFwiPHA+TGlrZSBzbyBtYW55IG90aGVyIGdvdmVybm1lbnQgYWdlbmNpZXMgZHVyaW5nIHRoZSBOZXcgRGVhbCwgSE9MQyBhbmQgaXRzIHBhcmVudCBidXJlYXUsIHRoZSBGZWRlcmFsIEhvbWUgTG9hbiBCYW5rIEJvYXJkLCBzaGFwZWQgQW1lcmljYW5zJyBsaXZlcyBhbmQgbGl2ZWxpaG9vZHMgcHJvZm91bmRseSBkdXJpbmcgYW5kIGFmdGVyIHRoZSBHcmVhdCBEZXByZXNzaW9uIG9mIHRoZSAxOTMwcy4gQm90aCBwcm92ZWQgY3JpdGljYWwgdG8gcHJvdGVjdGluZyBhbmQgZXhwYW5kaW5nIGhvbWUgb3duZXJzaGlwLCB0byBzdGFuZGFyZGl6aW5nIGxlbmRpbmcgcHJhY3RpY2VzLCBhbmQgdG8gZW5jb3VyYWdpbmcgcmVzaWRlbnRpYWwgYW5kIGNvbW1lcmNpYWwgcmVhbCBlc3RhdGUgaW52ZXN0bWVudCBpbiBhIGZsYWdnaW5nIGVjb25vbXkuICBBY3Jvc3MgdGhlIG1pZGRsZSB0aGlyZCBvZiB0aGUgdHdlbnRpZXRoIGNlbnR1cnksIGFyZ3VhYmx5IHRoZSBtb3N0IHByb3NwZXJvdXMgZGVjYWRlcyBpbiBBbWVyaWNhbiBoaXN0b3J5LCB0aGVzZSBhZ2VuY2llcyB3b3JrZWQgd2l0aCBwdWJsaWMgYW5kIHByaXZhdGUgc2VjdG9yIHBhcnRuZXJzIHRvIGNyZWF0ZSBtaWxsaW9ucyBvZiBqb2JzIGFuZCBoZWxwIG1pbGxpb25zIG9mIEFtZXJpY2FucyBidXkgb3Iga2VlcCB0aGVpciBob21lcy4gQXQgdGhlIHZlcnkgc2FtZSB0aW1lLCBmZWRlcmFsIGhvdXNpbmcgcHJvZ3JhbXMgaGVscGVkIGNvZGlmeSBhbmQgZXhwYW5kIHByYWN0aWNlcyBvZiByYWNpYWwgYW5kIGNsYXNzIHNlZ3JlZ2F0aW9uLiAgVGhleSBlbnN1cmVkLCBtb3Jlb3ZlciwgdGhhdCByYW1wYW50IHJlYWwgZXN0YXRlIHNwZWN1bGF0aW9uIGFuZCBlbnZpcm9ubWVudGFsIGRlZ3JhZGF0aW9uIHdvdWxkIGFjY29tcGFueSBBbWVyaWNhJ3MgcmVtYXJrYWJsZSBlY29ub21pYyByZWNvdmVyeSBhbmQgZ3Jvd3RoLjwvcD5cIixcblx0XHRcdFwiPHA+PGNpdGU+TWFwcGluZyBJbmVxdWFsaXR5PC9jaXRlPiBicmluZ3Mgb25lIG9mIHRoZSBjb3VudHJ5J3MgbW9zdCBpbXBvcnRhbnQgYXJjaGl2ZXMgdG8gdGhlIHB1YmxpYy4gIEhPTEMncyBkb2N1bWVudHMgY29udGFpbiBhIHdlYWx0aCBvZiBpbmZvcm1hdGlvbiBhYm91dCBob3cgZ292ZXJubWVudCBvZmZpY2lhbHMsIGxlbmRlcnMsIGFuZCByZWFsIGVzdGF0ZSBpbnRlcmVzdHMgc3VydmV5ZWQgYW5kIGVuc3VyZWQgdGhlIGVjb25vbWljIGhlYWx0aCBvZiBBbWVyaWNhbiBjaXRpZXMuICBBbmQgd2l0aCB0aGUgaGVscCBvZiBvbmdvaW5nIHJlc2VhcmNoLCB3ZSBjb250aW51ZSB0byBsZWFybiBhdCB3aGF0IGNvc3Qgc3VjaCBtZWFzdXJlcyB3ZXJlIHJlYWxpemVkLjwvcD5cIixcblx0XHRcdFwiPHA+T3ZlciB0aGUgbGFzdCB0aGlydHkgeWVhcnMgZXNwZWNpYWxseSwgc2Nob2xhcnMgaGF2ZSBjaGFyYWN0ZXJpemVkIEhPTEMncyBwcm9wZXJ0eSBhc3Nlc3NtZW50IGFuZCByaXNrIG1hbmFnZW1lbnQgcHJhY3RpY2VzLCBhcyB3ZWxsIGFzIHRob3NlIG9mIHRoZSBGZWRlcmFsIEhvdXNpbmcgQWRtaW5pc3RyYXRpb24sIFZldGVyYW5zIEFkbWluaXN0cmF0aW9uLCBhbmQgVVMuIEhvdXNpbmcgQXV0aG9yaXR5LCBhcyBzb21lIG9mIHRoZSBtb3N0IGltcG9ydGFudCBmYWN0b3JzIGluIHByZXNlcnZpbmcgcmFjaWFsIHNlZ3JlZ2F0aW9uLCBpbnRlcmdlbmVyYXRpb25hbCBwb3ZlcnR5LCBhbmQgdGhlIGNvbnRpbnVlZCB3ZWFsdGggZ2FwIGJldHdlZW4gd2hpdGUgQW1lcmljYW5zIGFuZCBtb3N0IG90aGVyIGdyb3VwcyBpbiB0aGUgVS5TLiAgTWFueSBvZiB0aGVzZSBhZ2VuY2llcyBvcGVyYXRlZCB1bmRlciB0aGUgaW5mbHVlbmNlIG9mIHBvd2VyZnVsIHJlYWwgZXN0YXRlIGxvYmJpZXMgb3Igd3JvdGUgdGhlaXIgcG9saWNpZXMgc3RlZXBlZCBpbiB3aGF0IHdlcmUsIGF0IHRoZSB0aW1lLCB3aWRlc3ByZWFkIGFzc3VtcHRpb25zIGFib3V0IHRoZSBwcm9maXRhYmlsaXR5IG9mIHJhY2lhbCBzZWdyZWdhdGlvbiBhbmQgdGhlIHJlc2lkZW50aWFsIGluY29tcGF0aWJpbGl0eSBvZiBjZXJ0YWluIHJhY2lhbCBhbmQgZXRobmljIGdyb3Vwcy4gIFRocm91Z2ggSE9MQywgaW4gcGFydGljdWxhciwgcmVhbCBlc3RhdGUgYXBwcmFpc2VycyB1c2VkIHRoZSBhcHBhcmVudCByYWNpYWwgYW5kIGN1bHR1cmFsIHZhbHVlIG9mIGEgY29tbXVuaXR5IHRvIGRldGVybWluZSBpdHMgZWNvbm9taWMgdmFsdWUuICA8Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IG9mZmVycyBhIHdpbmRvdyBpbnRvIHRoZSBOZXcgRGVhbCBlcmEgaG91c2luZyBwb2xpY2llcyB0aGF0IGhlbHBlZCBzZXQgdGhlIGNvdXJzZSBmb3IgY29udGVtcG9yYXJ5IEFtZXJpY2EuIFRoaXMgcHJvamVjdCBwcm92aWRlcyB2aXNpdG9ycyB3aXRoIGEgbmV3IHZpZXcsIGFuZCBwZXJoYXBzIGV2ZW4gYSBuZXcgbGFuZ3VhZ2UsIGZvciBkZXNjcmliaW5nIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB3ZWFsdGggYW5kIHBvdmVydHkgaW4gQW1lcmljYS48L3A+XCJcblx0XHRdLFxuXHRcdGJpYmxpb2dyYXBoOiBbXG5cdFx0XHRcIjxoMj5CaWJsaW9ncmFwaGljIE5vdGU8L2gyPlwiLFxuXHRcdFx0XCI8cD5UaGUgSG9tZSBPd25lcnMgTG9hbiBDb3Jwb3JhdGlvbiAoSE9MQykgaGFzIGxvbmcgYmVlbiBzZWVuIGFzIGJvdGggYSBzYXZpb3IgdG8gdGhlIGhvdXNpbmcgc2VjdG9yIGFuZCBhIGZvcmNlIGZvciByYWNpYWwgc2VncmVnYXRpb24uICBBcyB0aGUgZWNvbm9taWMgY29sbGFwc2Ugb2YgdGhlIDE5MzBzIHJlY2VkZXMgYmV5b25kIGxpdmluZyBtZW1vcnksIGhpc3RvcmlhbnMgaGF2ZSBmb2N1c2VkIG1vcmUgb24gdGhlIHNlZ3JlZ2F0aW9uaXN0IG5hdHVyZSBvZiBob3VzaW5nIHBvbGljeeKAlGhvdyByYWNpc20gaGVscGVkIHNhdmUgdGhlIEFtZXJpY2FuIGVjb25vbXkuICBUaGUgbGVnaXNsYXRpb24gY3JlYXRpbmcgSE9MQyBjYW1lIG91dCBvZiB0aGUgZmlyc3QgMTAwIGRheXMgb2YgdGhlIFJvb3NldmVsdCBhZG1pbmlzdHJhdGlvbiBhbmQgcHJvdmlkZWQgYmlsbGlvbnMgb2YgZG9sbGFycyBmb3IgdGhlIHJlc2N1ZSBvZiBiYW5rcywgdGhyaWZ0cywgYW5kIGRpc3RyZXNzZWQgaG9tZW93bmVycy4gIE5ldyBEZWFsIGxlZ2lzbGF0aW9uIHdhcyBoaWdobHkgcG9wdWxhciBpbiB0aGUgbWlkc3Qgb2YgYW4gZWNvbm9taWMgY3Jpc2lz4oCUdGhlIERlbW9jcmF0aWNhbGx5LWNvbnRyb2xsZWQgSG91c2Ugb2YgUmVwcmVzZW50YXRpdmVzIHBhc3NlZCB0aGUgYmlsbCAzODMtNC48L3A+XCIsXG5cdFx0XHRcIjxwPkhPTEMgaGVscGVkIHJlc3RydWN0dXJlIHRoZSBBbWVyaWNhbiBtb3J0Z2FnZSBsZW5kaW5nIG1hcmtldCBieSBjcmVhdGluZyBhbmQgc3RhbmRhcmRpemluZyBzZXZlcmFsIG9mIGl0cyBlbGVtZW50cy4gIEhPTEMgaW5jb3Jwb3JhdGVkIGFwcHJhaXNhbCBvZiBob21lIHZhbHVlIGludG8gaXRzIGxlbmRpbmcgcHJvY2Vzc2VzLCBhIHByYWN0aWNlIG9ubHkgaW4gaXRzIGluZmFuY3kgYXQgdGhlIHRpbWUuICBIT0xDIHN1cHBvcnRlZCB0aGUgdHJhaW5pbmcgb2YgaG9tZSBhcHByYWlzZXJzIGFuZCBlbXBsb3llZCBodW5kcmVkcyBvZiBhcHByYWlzZXJzIHRocm91Z2hvdXQgdGhlIDE5MzBzLCB3b3JraW5nIGluIGNvbmNlcnQgd2l0aCB0aGUgbmF0aW9u4oCZcyByZWFsdG9ycyB0byBpbmF1Z3VyYXRlIGFuZCBhZHZhbmNlIHJlYWwgZXN0YXRlIGFwcHJhaXNhbCBhcyBhIHByb2Zlc3Npb24uICBIT0xD4oCZcyBkZXBhcnRtZW50IG9mIFJlc2VhcmNoIGFuZCBTdGF0aXN0aWNzIGRyZXcgdXBvbiBpdHMgbmV0d29yayBvZiByZWFsdG9ycywgZGV2ZWxvcGVycywgbGVuZGVycywgYW5kIGFwcHJhaXNlcnMgdG8gY3JlYXRlIGEgbmVpZ2hib3Job29kLWJ5LW5laWdoYm9yaG9vZCBhc3Nlc3NtZW50IG9mIG1vcmUgdGhhbiAyMDAgY2l0aWVzIGluIHRoZSBjb3VudHJ5LiAgVGhlc2UgYXNzZXNzbWVudHMgaW5jbHVkZWQgZGVtb2dyYXBoaWMgZGF0YSwgZWNvbm9taWMgcmVwb3J0cywgYW5kIHRoZSBjb2xvci1jb2RlZCBTZWN1cml0eSBNYXBzIGxhdGVyIGRlZW1lZCBpbmZhbW91cyBhcyBpbnN0cnVtZW50cyBvZiDigJxyZWRsaW5pbmcu4oCdPC9wPlwiLFxuXHRcdFx0XCI8cD5UaGUgbWFpbnN0cmVhbSB3aGl0ZSBwcmVzc+KAlG1ham9yIGRhaWx5IG5ld3NwYXBlcnMgYW5kIHBlcmlvZGljYWxz4oCUZ3JlZXRlZCB0aGUgYWdlbmN5IGFuZCBpdHMgcHJvZ3JhbXMgd2l0aCBhcHByb3ZhbC4gIFRoZXkgZXhwbGFpbmVkIHRoZSBwcm9ncmFtIGFuZCBmb3JlY2FzdCB1cHR1cm5zIGluIHRoZSByZWFsIGVzdGF0ZSBhbmQgY29uc3RydWN0aW9uIHNlY3RvcnMsIGFzIHRoZSBwcm9ncmFtIGVuam95ZWQgcG9wdWxhciBzdXBwb3J0LiAgSW4gQ2hpY2Fnbywgc2V2ZW50ZWVuIHRob3VzYW5kIHBlb3BsZSBzdG9vZCBpbiBsaW5lIGF0IEhPTEPigJlzIG9mZmljZSB0aGUgZmlyc3QgZGF5IGl0IG9wZW5lZCBpbiBBdWd1c3Qgb2YgMTkzMyB0byBpbnF1aXJlIG9yIGFwcGx5IGZvciBhaWQuICBUaGUgY29ycG9yYXRpb27igJlzIG1haW4gbGVuZGluZyBwaGFzZSBlbmRlZCBhZnRlciB0aHJlZSB5ZWFycyBhbmQgdGhlIGNvcnBvcmF0aW9uIHJlY2VkZWQgZnJvbSBtYWluc3RyZWFtIHB1YmxpYyB2aWV3LiAgSE9MQyBzbG93bHkgcmVkdWNlZCBpdHMgb3BlcmF0aW9ucyBkdXJpbmcgdGhlIDE5NDBzIHRvIG1hbmFnZSB0aGUgbG9hbnMgYW5kIGhvbWVzIGl0IGFjcXVpcmVkIGluIGl0cyBrZXkgcGhhc2Ugb2YgYWN0aXZpdHkuPC9wPlwiLFxuXHRcdFx0XCI8cD5BZnJpY2FuIEFtZXJpY2FucyBsYW1iYXN0ZWQgSE9MQyBzdGFmZmluZyBkZWNpc2lvbnMgYW5kIGluZnJhc3RydWN0dXJlIHRoYXQgZmF2b3JlZCB3aGl0ZSBob21lb3duZXJzIGFuZCBidXNpbmVzc2VzIGF0IHRoZSBleHBlbnNlIG9mIGJsYWNrcy4gIEhvd2V2ZXIsIGRpc2N1c3Npb24gaW4gYmxhY2sgbmV3c3BhcGVycywgc3VjaCBhcyB0aGUgPGNpdGU+Q2hpY2FnbyBEZWZlbmRlcjwvY2l0ZT4sIHByb21wdGVkIG9ubHkgbW9kZXN0IHJlc3BvbnNlIGJ5IHBvbGljeSBhbmQgbWVkaWEgZWxpdGVzLiAgVGhlIFJvb3NldmVsdCBhZG1pbmlzdHJhdGlvbiByZWJ1ZmZlZCBOQUFDUCBjb25jZXJucyBhYm91dCByZXN0cmljdGl2ZSBjb3ZlbmFudHMsIGV2ZW4gd2hlbiBIT0xDIHJlZGxpbmluZyB3YXMgZXhwb3NlZCBpbiAxOTM4LiAgQmxhY2sgaG91c2luZyBvZmZpY2lhbHMgb2Z0ZW4gd29ya2VkIGluY3JlbWVudGFsbHkgb24gYSBob3N0IG9mIGlzc3VlcywgaW5jbHVkaW5nIGVuZGluZyB3aGl0ZSB0ZXJyb3Jpc20gYW5kIGdldHRpbmcgbmV3IGJsYWNrIGhvdXNpbmcgYnVpbHQsIGV2ZW4gaWYgdGhhdCBtZWFudCBvcGVyYXRpbmcgd2l0aGluIHRoZSBzZWdyZWdhdGlvbmlzdCBzdHJpY3R1cmVzIG9mIGZlZGVyYWwgcG9saWN5LiAgUmFjaWFsIHNlZ3JlZ2F0aW9uIGluIGhvdXNpbmcgd2FzIG5vdCBmb3JtYWxseSBkZWVtZWQgaWxsZWdhbCB1bnRpbCB0aGUgRmFpciBIb3VzaW5nIEFjdCBvZiAxOTY4LjwvcD5cIixcblx0XHRcdFwiPHA+U2Nob2xhcnMgdmlld2VkIEhPTEMgZmF2b3JhYmx5LCBzaGFwZWQgYnkgZWNvbm9taXN0IEMuIExvd2VsbCBIYXJyaXNz4oCZIDxjaXRlPkhpc3RvcnkgYW5kIFBvbGljaWVzIG9mIHRoZSBIb21lIE93bmVyc+KAmSBMb2FuIENvcnBvcmF0aW9uPC9jaXRlPiwgcHVibGlzaGVkIGluIDE5NTEgYXMgdGhlIGZlZGVyYWwgZ292ZXJubWVudCB1bndvdW5kIHRoZSBhZ2VuY3kuICBIT0xDIGhhZCByZWZpbmFuY2VkIGEgbWlsbGlvbiBob21lcyBhbmQgcmV0dXJuZWQgYSBwcm9maXQgb2YgJDE0IG1pbGxpb24gdG8gdGhlIFUuUy4gVHJlYXN1cnkuICBJdCB3YXMgYSBzdWNjZXNzZnVsIGJ1c2luZXNzIHZlbnR1cmUgZm9yIGFuIGFnZW5jeSBjcmVhdGVkIGFzIGVtZXJnZW5jeSByZWxpZWYgdGhhdCBoZWxwZWQgc3RhYmlsaXplIGFuZCBldmVuIHJlc3VycmVjdCBhIG1vcmlidW5kIG1vcnRnYWdlIG1hcmtldCBhbmQgc3RhZ25hbnQgaG9tZSBidWlsZGluZyBzZWN0b3IuPC9wPlwiLFxuXHRcdFx0XCI8cD5JbiB0aGUgMTk4MHMgZGlzY292ZXJ5IG9mIHRoZSBIT0xDIHNlY3VyaXR5IG1hcHMgY2hhbmdlZCB0aGUgd2F5IGhpc3RvcmlhbnMgdGhvdWdodCBhYm91dCBIT0xDIGFuZCBOZXcgRGVhbCBob3VzaW5nIHBvbGljeS4gIEhvdXNpbmcgYWN0aXZpc3RzIGluIHRoZSAxOTYwcyBhbmQgMTk3MHMgaGFkIGNyaXRpY2l6ZWQgYW5kIHByb3Rlc3RlZCBkaXNjcmltaW5hdGlvbiBpbiByZWFsIGVzdGF0ZSBsZW5kaW5nIGFuZCBidXlpbmcsIGNvaW5pbmcgdGhlIHRlcm0g4oCccmVkbGluaW5n4oCdIHRvIGlsbHVzdHJhdGUgdGhlIGdlb2dyYXBoaWMgZGltZW5zaW9ucyBvZiBob3VzaW5nIGRpc2NyaW1pbmF0aW9uLiAgSGlzdG9yaWFuIEtlbm5ldGggSmFja3NvbiBmb3VuZCB0aGUgbWFwcyBpbiB0aGUgTmF0aW9uYWwgQXJjaGl2ZXMsIHN0YXRpbmcgaW4gaGlzIGF3YXJkLXdpbm5pbmcgYm9vayA8Y2l0ZT5DcmFiZ3Jhc3MgRnJvbnRpZXI8L2NpdGU+IHRoYXQgSE9MQyDigJxkZXZpc2VkIGEgcmF0aW5nIHN5c3RlbSB0aGF0IHVuZGVydmFsdWVkIG5laWdoYm9yaG9vZHMgdGhhdCB3ZXJlIGRlbnNlLCBtaXhlZCwgb3IgYWdpbmcs4oCdIGFuZCByYXRoZXIgdGhhbiBjcmVhdGluZyByYWNpYWwgZGlzY3JpbWluYXRpb24sIOKAnGFwcGxpZWQgW2V4aXN0aW5nXSBub3Rpb25zIG9mIGV0aG5pYyBhbmQgcmFjaWFsIHdvcnRoIHRvIHJlYWwtZXN0YXRlIGFwcHJhaXNpbmcgb24gYW4gdW5wcmVjZWRlbnRlZCBzY2FsZS7igJ0gIEZlZGVyYWwgaG91c2luZyBwb2xpY3kgc2ltcGx5IGJsb2NrZWQgQWZyaWNhbiBBbWVyaWNhbnMgZnJvbSBhY2Nlc3NpbmcgcmVhbCBlc3RhdGUgY2FwaXRhbCwgbGVhZGluZyB0byB0aGUgY3JlYXRpb24gb2Ygc2VncmVnYXRlZCBtYXNzIHN1YnVyYmlhIGFuZCwgbmVpZ2hib3Job29kIGJ5IG5laWdoYm9yaG9vZCwgb3BlbmVkIHJlc2lkZW50cyB0byBvcHBvcnR1bml0eSBhbmQgd2VhbHRoIGFjY3VtdWxhdGlvbiBvciBjbG9zZWQgY2l0aXplbnMgb2ZmIGZyb20gdGhlIEFtZXJpY2FuIGRyZWFtLiAgRm9sbG93aW5nIEphY2tzb27igJlzIHdvcmssIGhpc3RvcmlhbiBUaG9tYXMgU3VncnVlIHdyb3RlIG9mIHRoZSBsZWdhY3kgb2YgZmVkZXJhbCBob3VzaW5nIHBvbGljeSBpbiBEZXRyb2l0OiDigJxnZW9ncmFwaHkgaXMgZGVzdGlueS7igJ0gIE91dHNpZGUgb2YgaGlzdG9yeSwgc2Nob2xhcnMgYW5kIGpvdXJuYWxpc3RzLCBpbmNsdWRpbmcgc29jaW9sb2dpc3QgRG91Z2xhcyBNYXNzZXkgYW5kIHdyaXRlciBUYS1OZWhpc2kgQ29hdGVzLCBwb2ludCB0byBIT0xDIHJlZGxpbmluZyBhcyBhIGtleSBmYWN0b3IgaW4gcmFjaWFsIGRpc3Bhcml0aWVzIGluIHdlYWx0aCBhbmQgb3Bwb3J0dW5pdHkgdGhhdCBjb250aW51ZSB0byB0aGUgcHJlc2VudCBkYXkuPC9wPlwiLFxuXHRcdFx0XCI8cD5XaGVuIGhpc3RvcmlhbnMgaW5jb3Jwb3JhdGVkIG5ldyBkYXRhIHRlY2hub2xvZ3kgaW4gdGhlaXIgcmVzZWFyY2gsIHRoZXkgYmVnYW4gdG8gZHJhdyBuZXcgY29uY2x1c2lvbnMgYWJvdXQgSE9MQ+KAmXMgbGVnYWN5LiAgTWFwcGluZyB3aXRoIGdlb2dyYXBoaWMgaW5mb3JtYXRpb24gc3lzdGVtcyAoR0lTKSBhbmQgcXVhbnRpdGF0aXZlIHN0YXRpc3RpY2FsIG1ldGhvZHMgZnJvbSB0aGUgc29jaWFsIHNjaWVuY2VzLCBzY2hvbGFycyBpbmNsdWRpbmcgQW15IEhpbGxpZXIgYW5kIEphbWVzIEdyZWVyIGhhdmUgY291bnRlcmVkIEphY2tzb27igJlzIGluaXRpYWwgYXNzZXNzbWVudC4gIFNvbWUgQWZyaWNhbiBBbWVyaWNhbnMgZGlkIGdhaW4gYWNjZXNzIHRvIEhPTEMgZmluYW5jaW5nLCBhbmQgYSBuZWlnaGJvcmhvb2QgcmF0aW5nIHdhcyBuZWl0aGVyIGEgYmxhbmtldCBndWFyYW50ZWUgbm9yIHByb3NjcmlwdGlvbiBmb3IgTmV3IERlYWwgYWlk4oCU4oCcQ+KAnSBhbmQg4oCcROKAnS1yYXRlZCBuZWlnaGJvcmhvb2RzIG9mdGVuIHJlY2VpdmVkIG1vcmUgbW9ydGdhZ2VzIHRoYW4gbmVhcmJ5IOKAnEHigJ0gbmVpZ2hib3Job29kcy4gIFRoZSBhYmlsaXR5IHRvIHdvcmsgd2l0aCBkaWdpdGFsIGRhdGEgYW5kIHRvIHRyYW5zbWl0IGluZm9ybWF0aW9uIG92ZXIgdGhlIHdlYiBoYXMgb3BlbmVkIG1hbnkgbmV3IGF2ZW51ZXMgZm9yIHNjaG9sYXJseSBpbnF1aXJ5LCBpbmNsdWRpbmcgYXNzZXNzaW5nIHRoZSBpbXBvcnRhbmNlIG9mIHJlc3RyaWN0aXZlIGNvdmVuYW50cyBhbmQgYXNraW5nIHJlc2VhcmNoIHF1ZXN0aW9ucyBhYm91dCB0aGUgd2hvbGUgcHJvZ3JhbSwgcmF0aGVyIHRoYW4ganVzdCBpbmRpdmlkdWFsIGNpdGllcy4gIE1hbmFnaW5nIG1hc3NpdmUgYW1vdW50cyBvZiByZWFsIGVzdGF0ZSBhbmQgZGVtb2dyYXBoaWMgZGF0YSBoYXMgYmVlbiBhIGhlcmN1bGVhbiB0YXNrIHVwIHVudGlsIHJlY2VudGx5IGJ1dCBpcyBub3cgcG9zc2libGUgd2l0aCBtYXBwaW5nLCB2aXN1YWxpemF0aW9uLCBhbmQgc3RhdGlzdGljYWwgdG9vbHMuPC9wPlwiLFxuXHRcdFx0XCI8cD48Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IG9wZW5zIHRoZSBIT0xDIGZpbGVzIGF0IHRoZSBOYXRpb25hbCBBcmNoaXZlcyB0byBzY2hvbGFycywgc3R1ZGVudHMsIGFuZCByZXNpZGVudHMgYW5kIHBvbGljeSBsZWFkZXJzIGluIGxvY2FsIGNvbW11bml0aWVzLiAgVGhpcyBzaXRlIG1ha2VzIHRoZSB3ZWxsLWtub3duIHNlY3VyaXR5IG1hcHMgb2YgSE9MQyBhdmFpbGFibGUgaW4gZGlnaXRhbCBmb3JtLCBhcyB3ZWxsIGFzIHRoZSBkYXRhIGFuZCB0ZXh0dWFsIGFzc2Vzc21lbnRzIG9mIHRoZSBhcmVhIGRlc2NyaXB0aW9ucyB0aGF0IHdlcmUgY3JlYXRlZCB0byBnbyB3aXRoIHRoZSBtYXBzLiAgQnkgYnJpbmdpbmcgc3R1ZHkgb2YgSE9MQyBpbnRvIHRoZSBkaWdpdGFsIHJlYWxtLCA8Y2l0ZT5NYXBwaW5nIEluZXF1YWxpdHk8L2NpdGU+IGVtYnJhY2VzIGEgYmlnIGRhdGEgYXBwcm9hY2ggdGhhdCBjYW4gc2ltdWx0YW5lb3VzbHkgZ2l2ZSBhIG5hdGlvbmFsIHZpZXcgb2YgdGhlIHByb2dyYW0gb3IgYSBuZWlnaGJvcmhvb2QtbGV2ZWwgYXNzZXNzbWVudCBvZiB0aGUgMTkzMHMgcmVhbCBlc3RhdGUgcmVzY3VlLiAgUHJvamVjdCByZXNlYXJjaGVycyBhcmUgcHJvdmlkaW5nIGFjY2VzcyB0byBzb21lIG9mIHRoZSBkaWdpdGFsIHRvb2xzIGFuZCBpbnRlcmFjdGl2ZSByZXNvdXJjZXMgdGhleSBhcmUgdXNpbmcgaW4gdGhlaXIgb3duIHJlc2VhcmNoLCBpbiB0aGUgaG9wZSB0aGF0IHRoZSBwdWJsaWMgd2lsbCBiZSBhYmxlIHRvIHVuZGVyc3RhbmQgdGhlIGVmZmVjdHMgb2YgZmVkZXJhbCBob3VzaW5nIHBvbGljeSBhbmQgbG9jYWwgaW1wbGVtZW50YXRpb24gaW4gdGhlaXIgb3duIGNvbW11bml0aWVzLjwvcD5cIixcblx0XHRcdFwiPGgyPkJpYmxpb2dyYXBoeTwvaDI+XCIsXG5cdFx0XHRcIjxoMz5UZXh0Ym9va3MgYW5kIE1hbnVhbHMgb24gSG9tZSBBcHByYWlzYWwgYW5kIFZhbHVhdGlvbjwvaDM+XCIsXG5cdFx0XHRcIjx1bD5cIixcblx0XHRcdFwiPGxpPjxjaXRlPkZIQSBVbmRlcndyaXRpbmcgTWFudWFsPC9jaXRlPiAoV2FzaGluZ3RvbiwgREM6IEZlZGVyYWwgSG91c2luZyBBZG1pbmlzdHJhdGlvbiwgMTkzNik8L2xpPlwiLFxuXHRcdFx0XCI8bGk+RnJlZGVyaWNrIEJhYmNvY2ssIDxjaXRlPlRoZSBWYWx1YXRpb24gb2YgUmVhbCBFc3RhdGU8L2NpdGU+IChNY0dyYXcgSGlsbCBCb29rIENvLjogTmV3IFlvcmssIDE5MzIpLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5SaWNoYXJkIEVseSBhbmQgR2VvcmdlIFdlaHJ3ZWluLCA8Y2l0ZT5MYW5kIEVjb25vbWljczwvY2l0ZT4gKE1hZGlzb24sIFdJOiBVbml2ZXJzaXR5IG9mIFdpc2NvbnNpbiBQcmVzcywgcmV2LiAxOTY0KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+RXJuZXN0IEZpc2hlciwgPGNpdGU+UHJpbmNpcGxlcyBvZiBSZWFsIEVzdGF0ZSBQcmFjdGljZTwvY2l0ZT4gKE5ldyBZb3JrOiBUaGUgTWFjTWlsbGFuIENvLiwgMTkyNCkuPC9saT5cIixcblx0XHRcdFwiPGxpPlJpY2hhcmQgSHVyZCwgPGNpdGU+UHJpbmNpcGxlcyBvZiBDaXR5IExhbmQgVmFsdWVzIDwvY2l0ZT4oTmV3IFlvcms6IFRoZSBSZWNvcmQgYW5kIEd1aWRlLCAxOTI0KS48L2xpPlwiLFxuXHRcdFx0XCI8L3VsPlwiLFxuXHRcdFx0XCI8aDM+Q29udGVtcG9yYW5lb3VzIFN0dWRpZXMgb2YgSE9MQyBhbmQgUmFjaWFsIFNlZ3JlZ2F0aW9uPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+Q2hhcmxlcyBBYnJhbXMsIDxjaXRlPkZvcmJpZGRlbiBOZWlnaGJvcnM6IEEgU3R1ZHkgb2YgUHJlanVkaWNlIGluIEhvdXNpbmcgPC9jaXRlPihOZXcgWW9yazogSGFycGVyICZhbXA7IEJyb3RoZXJzLCAxOTU1KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+Qy4gTG93ZWxsIEhhcnJpc3MsIDxjaXRlPkhpc3RvcnkgYW5kIFBvbGljaWVzIG9mIHRoZSBIb21lIE93bmVycyZyc3F1bzsgTG9hbiBDb3Jwb3JhdGlvbjwvY2l0ZT4gKFdhc2hpbmd0b24sIEQuQy4sIE5hdGlvbmFsIEJ1cmVhdSBvZiBFY29ub21pYyBSZXNlYXJjaCwgMTk1MSkuPC9saT5cIixcblx0XHRcdFwiPGxpPlJvYmVydCBDLiBXZWF2ZXIsIDxjaXRlPlRoZSBOZWdybyBHaGV0dG8gPC9jaXRlPihOZXcgWW9yazogSGFyY291cnQsIEJyYWNlLCAxOTQ4KS48L2xpPlwiLFxuXHRcdFx0XCI8L3VsPlwiLFxuXHRcdFx0XCI8aDM+SGlzdG9yaWNhbCBTdHVkaWVzIG9mIEhPTEMsIFNlZ3JlZ2F0aW9uLCBhbmQgSG9tZSBGaW5hbmNlPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+RGF2aWQgTS4gUC4gRnJldW5kLCA8Y2l0ZT5Db2xvcmVkIFByb3BlcnR5OiBTdGF0ZSBQb2xpY3kgYW5kIFdoaXRlIFJhY2lhbCBQb2xpdGljcyBpbiBTdWJ1cmJhbiBBbWVyaWNhPC9jaXRlPiAoQ2hpY2FnbzogVW5pdmVyc2l0eSBvZiBDaGljYWdvIFByZXNzLCAyMDA3KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+TWFyZ2FyZXQgR2FyYiwgPGNpdGU+Q2l0eSBvZiBBbWVyaWNhbiBEcmVhbXM6IEEgSGlzdG9yeSBvZiBIb21lIE93bmVyc2hpcCBhbmQgSG91c2luZyBSZWZvcm0gaW4gQ2hpY2FnbywgMTg3MS0xOTE5PC9jaXRlPi4mbmJzcDsgKENoaWNhZ286IFVuaXZlcnNpdHkgb2YgQ2hpY2FnbyBQcmVzcywgMjAwNSkuPC9saT5cIixcblx0XHRcdFwiPGxpPkFteSBFLiBIaWxsaWVyLCAmbGRxdW87UmVkbGluaW5nIGFuZCB0aGUgSG9tZSBPd25lcnMmcnNxdW87IExvYW4gQ29ycG9yYXRpb24sJnJkcXVvOyA8Y2l0ZT5Kb3VybmFsIG9mIFVyYmFuIEhpc3Rvcnk8L2NpdGU+IDI5LCBuby4gNCAoTWF5IDIwMDMpOiAzOTQtNDIwLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5BbXkgRS4gSGlsbGllciwgJmxkcXVvO1Jlc2lkZW50aWFsIFNlY3VyaXR5IE1hcHMgYW5kIE5laWdoYm9yaG9vZCBBcHByYWlzYWxzOiBUaGUgSG9tZSBPd25lcnMmcnNxdW87IExvYW4gQ29ycG9yYXRpb24gYW5kIHRoZSBDYXNlIG9mIFBoaWxhZGVscGhpYSwmcmRxdW87IDxjaXRlPlNvY2lhbCBTY2llbmNlIEhpc3Rvcnk8L2NpdGU+IDI5LCBuby4gMiAoU3VtbWVyIDIwMDUpOiBYWFhYPC9saT5cIixcblx0XHRcdFwiPGxpPkFteSBFLiBIaWxsaWVyLCAmbGRxdW87U2VhcmNoaW5nIGZvciBSZWQgTGluZXM6IFNwYXRpYWwgQW5hbHlzaXMgb2YgTGVuZGluZyBQYXR0ZXJucyBpbiBQaGlsYWRlbHBoaWEsIDE5NDAtMTk2MCwmcmRxdW87IDxjaXRlPlBlbm5zeWx2YW5pYSBIaXN0b3J5PC9jaXRlPiA3Miwgbm8uIDEgKFdpbnRlciAyMDA1KTogWFhYPC9saT5cIixcblx0XHRcdFwiPGxpPkFybm9sZCBSLiBIaXJzY2gsICZsZHF1bztDb250YWlubWVudCBvbiB0aGUgSG9tZSBGcm9udDogUmFjZSBhbmQgRmVkZXJhbCBIb3VzaW5nIFBvbGljeSBmcm9tIHRoZSBOZXcgRGVhbCB0byB0aGUgQ29sZCBXYXIsJnJkcXVvOyA8Y2l0ZT5Kb3VybmFsIG9mIFVyYmFuIEhpc3Rvcnk8L2NpdGU+IDI2LCBuby4gMiAoSmFudWFyeSAyMDAwKTogMTU4LTE4OTwvbGk+XCIsXG5cdFx0XHRcIjxsaT5LZW5uZXRoIFQuIEphY2tzb24sICZsZHF1bztSYWNlIEV0aG5pY2l0eSwgYW5kIFJlYWwgRXN0YXRlIEFwcHJhaXNhbDogVGhlIEhvbWUgT3duZXJzIExvYW4gQ29ycG9yYXRpb24gYW5kIHRoZSBGZWRlcmFsIEhvdXNpbmcgQWRtaW5pc3RyYXRpb24sJnJkcXVvOyA8Y2l0ZT5Kb3VybmFsIG9mIFVyYmFuIEhpc3Rvcnk8L2NpdGU+IDYsIG5vLiA0IChBdWd1c3QsIDE5ODApOiA0MTktNDUyLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5LZW5uZXRoIFQuIEphY2tzb24sIDxjaXRlPkNyYWJncmFzcyBGcm9udGllcjogVGhlIFN1YnVyYmFuaXphdGlvbiBvZiB0aGUgVW5pdGVkIFN0YXRlczwvY2l0ZT4gKE94Zm9yZDogT3hmb3JkIFVuaXZlcnNpdHkgUHJlc3MsIDE5ODUpLjwvbGk+XCIsXG5cdFx0XHRcIjxsaT5KZW5uaWZlciBTLiBMaWdodCwgJmxkcXVvO05hdGlvbmFsaXR5IGFuZCBOZWlnaGJvcmhvb2QgUmlzayBhdCB0aGUgT3JpZ2lucyBvZiBGSEEgVW5kZXJ3cml0aW5nLCZyZHF1bzsgPGNpdGU+Sm91cm5hbCBvZiBVcmJhbiBIaXN0b3J5PC9jaXRlPiAzNiAoNSk6IDYzNC02NzEuPC9saT5cIixcblx0XHRcdFwiPGxpPkxvdWlzIExlZSBXb29kcyBJSSwgJmxkcXVvO1RoZSBGZWRlcmFsIEhvbWUgTG9hbiBCYW5rIEJvYXJkLCBSZWRsaW5pbmcsIGFuZCB0aGUgTmF0aW9uYWwgUHJvbGlmZXJhdGlvbiBvZiBSYWNpYWwgTGVuZGluZyBEaXNjcmltaW5hdGlvbiwgMTkyMS0xOTUwLCZyZHF1bzsgPGNpdGU+Sm91cm5hbCBvZiBVcmJhbiBIaXN0b3J5PC9jaXRlPjsgVm9sdW1lIDM4LCBJc3N1ZSA2IChOb3ZlbWJlciAyMDEyKTogMTAzNi0xMDU5LjwvbGk+XCIsXG5cdFx0XHRcIjwvdWw+XCIsXG5cdFx0XHRcIjxoMz5IaXN0b3JpY2FsIENvbW11bml0eSBTdHVkaWVzIEZlYXR1cmluZyBBbmFseXNpcyBvZiBIT0xDPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+V2VuZGVsbCBQcml0Y2hldHQsIDxjaXRlPkJyb3duc3ZpbGxlLCBCcm9va2x5bjogQmxhY2tzLCBKZXdzLCBhbmQgdGhlIENoYW5naW5nIEZhY2Ugb2YgdGhlIEdoZXR0byA8L2NpdGU+KENoaWNhZ286IFVuaXZlcnNpdHkgb2YgQ2hpY2FnbyBQcmVzcywgMjAwMikuPC9saT5cIixcblx0XHRcdFwiPGxpPkJlcnlsIFNhdHRlciwgPGNpdGU+RmFtaWx5IFByb3BlcnRpZXM6IFJhY2UsIFJlYWwgRXN0YXRlLCBhbmQgdGhlIEV4cGxvaXRhdGlvbiBvZiBCbGFjayBVcmJhbiBBbWVyaWNhPC9jaXRlPiAoTWV0cm9wb2xpdGFuIEJvb2tzLCAyMDA5KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+Um9iZXJ0IE8uIFNlbGYsIDxjaXRlPkFtZXJpY2FuIEJhYnlsb24sIFJhY2UgYW5kIHRoZSBTdHJ1Z2dsZSBmb3IgUG9zdHdhciBPYWtsYW5kPC9jaXRlPiAoUHJpbmNldG9uOiBQcmluY2V0b24gVW5pdmVyc2l0eSBQcmVzcywgMjAwMykuPC9saT5cIixcblx0XHRcdFwiPGxpPlRob21hcyBKLiBTdWdydWUsIDxjaXRlPk9yaWdpbnMgb2YgdGhlIFVyYmFuIENyaXNpczogUmFjZSBhbmQgSW5lcXVhbGl0eSBpbiBQb3N0d2FyIERldHJvaXQ8L2NpdGU+IChQcmluY2V0b246IFByaW5jZXRvbiBVbml2ZXJzaXR5IFByZXNzLCAxOTk2KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+Q3JhaWcgU3RldmVuIFdpbGRlciwgPGNpdGU+Q292ZW5hbnQgV2l0aCBDb2xvcjogUmFjZSBhbmQgU29jaWFsIFBvd2VyIGluIEJyb29rbHluPC9jaXRlPiAoTmV3IFlvcms6IENvbHVtYmlhIFVuaXZlcnNpdHkgUHJlc3MsIDIwMDEpLjwvbGk+XCIsXG5cdFx0XHRcIjwvdWw+XCIsXG5cdFx0XHRcIjxoMz5Tb2Npb2xvZ2ljYWwgU3R1ZGllcyBvZiBSYWNpYWwgRGlzY3JpbWluYXRpb24gYW5kIFNlZ3JlZ2F0aW9uPC9oMz5cIixcblx0XHRcdFwiPHVsPlwiLFxuXHRcdFx0XCI8bGk+Um9zZSBIZWxwZXIsIDxjaXRlPlJhY2lhbCBQb2xpY2llcyBhbmQgUHJhY3RpY2VzIG9mIFJlYWwgRXN0YXRlIEJyb2tlcnM8L2NpdGU+LiAoTWlubmVhcG9saXM6IFVuaXZlcnNpdHkgb2YgTWlubmVzb3RhIFByZXNzLCAxOTY5KS48L2xpPlwiLFxuXHRcdFx0XCI8bGk+RG91Z2xhcyBTLiBNYXNzZXkgYW5kIE5hbmN5IEEuIERlbnRvbiwgPGNpdGU+QW1lcmljYW4gQXBhcnRoZWlkOiBTZWdyZWdhdGlvbiBhbmQgdGhlIE1ha2luZyBvZiB0aGUgVW5kZXJjbGFzczwvY2l0ZT4gKENhbWJyaWRnZTogSGFydmFyZCBVbml2ZXJzaXR5IFByZXNzLCAxOTkzKS48L2xpPlwiLFxuXHRcdFx0XCI8L3VsPlwiXG5cdFx0XSxcblx0XHRcImJ1cmdlc3NcIjogW1xuXHRcdFx0XCI8cD48c3Ryb25nPkJvcnJvd2VkIGFuZCBtb2RpZmllZCBmcm9tIHRoZSAxOTIwcy1lcmEgXFxcImNvbmNlbnRyaWMgem9uZXMgdGhlb3J5XFxcIiBvZiBFcm5lc3QgVy4gQnVyZ2VzcywgdGhpcyBkaWFncmFtIG9mZmVycyBhIHZpZXcgb2YgaG93IHJlZGxpbmluZyBjb25jZW50cmF0ZWQgcG9wdWxhdGlvbnMsIGFuZCBkaWQgc28gYWxvbmcgYSBnZW5lcmFsbHkgY29uc2lzdGVudCBwYXR0ZXJuLjwvc3Ryb25nPjwvcD5cIixcblx0XHRcdFwiPHA+QWNjb3JkaW5nIHRvIEJ1cmdlc3MsIGV2ZXJ5IGNpdHkgZGV2ZWxvcGVkIGFzIGEgc2VyaWVzIG9mIGNvbmNlbnRyaWMgY2lyY2xlcy4gIERvd250b3duIGJ1c2luZXNzIGRpc3RyaWN0cyB3b3VsZCBiZSBmb2xsb3dlZCBieSBmYWN0b3J5IHpvbmVzLiAgRmFjdG9yeSB6b25lcyB3b3VsZCB0cmFuc2l0aW9uIHRvIHNsdW1zLCBmb2xsb3dlZCB0aGVuIGJ5IHByb2dyZXNzaXZlbHkgbW9yZSBhZmZsdWVudCBob3VzaW5nIGZvciB3b3JraW5nIHBlb3BsZSBhbmQgdGhlIGludmVzdG9yIGNsYXNzLCBiZWZvcmUgdGhlbiByZWFjaGluZyB0aGUgZmluYWwgem9uZSwgZnJvbSB3aGVuY2UgY29tbXV0ZXJzIGNhbWUgaW50byB0aGUgY2l0eS4gQXMgdGhlIGhpc3RvcmlhbiBFbGFpbmUgTGV3aW5uZWsgcG9pbnRzIG91dCwgXFxcIkJ1cmdlc3MgYWRhcHRlZCBhIGhhbGYtY2VudHVyeSBvZiBDaGljYWdvIG1hcHMgYW5kIGNvZGlmaWVkIHRoZW0gaW4gYSBtb2RlbCBvZiBhYnN0cmFjdGlvbiBhbmQgdXJiYW4gdGhlb3J5IHRoYXQgaGFzIGJlZW4gY2FsbGVkJiM4MjEyO3dpdGggc29tZSBoeXBlcmJvbGUmIzgyMTI7J3RoZSBtb3N0IGZhbW91cyBkaWFncmFtIGluIHNvY2lhbCBzY2llbmNlLidcXFwiPC9wPlwiLFxuXHRcdFx0XCI8cD5JbiBCdXJnZXNzJ3MgbW9kZWwsIGVhY2ggcmluZyBoYWQgY3VsdHVyYWwgYW5kIGVjb25vbWljIGZlYXR1cmVzJiM4MjEyO2ZlYXR1cmVzIHRoYXQgaGUgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggZXRobmljIGFuZCByYWNpYWwgcG9wdWxhdGlvbnMuIFBvb3Igd2hpdGVzIGFuZCBibGFjayBtaWdyYW50cyBvY2N1cGllZCBjZW50cmFsIHNsdW0gZGlzdHJpY3RzIHJpZmUgd2l0aCB2aWNlIGRlbnMgYW5kIHJ1biBkb3duIHJvb21pbmcgaG91c2VzIGFuZCBpbW1pZ3JhbnQgY29sb25pZXMuICBTZWNvbmQtZ2VuZXJhdGlvbiBFdXJvcGVhbiBpbW1pZ3JhbnRzIGFuZCBmYWN0b3J5IGFuZCBhIHNob3Agd29ya2VycywgXFxcInNraWxsZWQgYW5kIHRocmlmdHksXFxcIiBsaXZlZCBvbiB0aGUgb3V0ZXIgZWRnZSBvZiB0aGUgc2x1bXMgYW5kIG9uIHRoZSBpbm5lciBlZGdlIG9mIHRoZSByaW5nIG9mIHdlbGwta2VwdCBhcGFydG1lbnQgaG91c2VzIGFuZCBcXFwid29ya2luZ21lbidzIGhvbWVzLlxcXCIgQmV5b25kIHRoZW0gd2FzIHRoZSBcXFwiUHJvbWlzZWQgTGFuZFxcXCIgb2YgcmVzaWRlbnRpYWwgaG90ZWxzIGFuZCBzaW5nbGUtZmFtaWx5IGhvbWVzLiAgSW4gY29udHJhc3QgdG8gdGhlIHN3YXJ0aHksIGNvbmdlc3RlZCBzbHVtcywgdGhlc2Ugd2VyZSBcXFwiYnJpZ2h0IGxpZ2h0IGFyZWFzXFxcIiBzYWZlbHkgcHJvdGVjdGVkIGJ5IHJlc3RyaWN0aXZlIGNvdmVuYW50cyBhbmQgaGlnaCBwcmljZSBwb2ludHMuPC9wPlwiLFxuXHRcdFx0XCI8cD5CdXJnZXNzJ3MgbW9kZWwsIGluIGFkZGl0aW9uIHRvIHJlZmxlY3RpbmcgdGhlIGhvbWVzIG9mIHJlYWwgZXN0YXRlIGludmVzdG9yIGNvbW11bml0aWVzLCBzZXJ2ZWQgYXMgYW4gZXh0ZW5zaW9uIG9mIHdpZGVyIHNlZ3JlZ2F0aW9uaXN0IHRoaW5raW5nIGRyaXZpbmcgYm90aCBzb2Npb2xvZ3kgYXMgYSBkaXNjaXBsaW5lIGFuZCBhZG1pbmlzdHJhdGl2ZSBwcmFjdGljZSBkdXJpbmcgdGhlIHByb2dyZXNzaXZlIGVyYS4gIE9ic2Vzc2lvbiB3aXRoIGNpdGllcyBhcyBcXFwib3JnYW5pc21zXFxcIiBvZiBzb2NpZXR5LCB0aGV5IGJlbGlldmVkIGluIHdoYXQgdGhlIHNvY2lvbG9naXN0IExvdWlzIFdpcnRoIGJlbmlnbmx5IGRlc2NyaWJlZCBhcyB0aGUgXFxcImV1Z2VuaWNzIG9mIHRoZSBjaXR5LlxcXCI8L3A+XCIsXG5cdFx0XHRcIjxwPk1hbnkgb2YgdGhlIEhPTEMgbWFwcyByZWZsZWN0ZWQgYm90aCB0aGUgY2F0ZWdvcmljYWwgaW1wdWxzZSBhbmQgc3BhdGlhbCBvcmdhbml6YXRpb24gb2YgQnVyZ2VzcyBtb2RlbCB3aXRoIEQgYW5kIEMgbmVpZ2hib3Job29kcyBtb3JlIGxpa2VseSB0byBiZSBsb2NhdGVkIGFyb3VuZCBjZW50cmFsIGJ1c2luZXNzIGRpc3RyaWN0cyBhbmQgQSBhbmQgQiBuZWlnaGJvcmhvb2RzIGluIGluY3JlYXNpbmdseSBzdWJ1cmJhbiBwZXJpcGhlcmllcy4gVGhlIGRpYWdyYW0gdmlzdWFsaXplcyB0aGUgcmVsYXRpdmUgZGlzdHJpYnV0aW9uIG9mIEhPTEMgZ3JhZGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNpdHkuIFRoZSBvcGFjaXR5IG9mIHRoZSByaW5ncyByZWZsZWN0cyB0aGUgcmVsYXRpdmUgZGVuc2l0eSBvZiB6b25lZCBhcmVhcyBvbiB0aGUgbWFwLiBIb3ZlcmluZyBvdmVyIHRoZSByaW5ncyB3aWxsIGhpZ2hsaWdodCBhcmVhcyBmb3IgdGhhdCBncmFkZS48L3A+XCIsXG5cdFx0XHRcIjxwPkluIEJ1cmdlc3MncyBtb2RlbCwgZWFjaCByaW5nIGhhZCBjdWx0dXJhbCBhbmQgZWNvbm9taWMgZmVhdHVyZXMmIzgyMTI7ZmVhdHVyZXMgdGhhdCBoZSBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCBldGhuaWMgYW5kIHJhY2lhbCBwb3B1bGF0aW9ucy4gUG9vciB3aGl0ZXMgYW5kIGJsYWNrIG1pZ3JhbnRzIG9jY3VwaWVkIGNlbnRyYWwgc2x1bSBkaXN0cmljdHMgcmlmZSB3aXRoIHZpY2UgZGVucyBhbmQgcnVuIGRvd24gcm9vbWluZyBob3VzZXMgYW5kIGltbWlncmFudCBjb2xvbmllcy4gIFNlY29uZC1nZW5lcmF0aW9uIEV1cm9wZWFuIGltbWlncmFudHMgYW5kIGZhY3RvcnkgYW5kIGEgc2hvcCB3b3JrZXJzLCBcXFwic2tpbGxlZCBhbmQgdGhyaWZ0eSxcXFwiIGxpdmVkIG9uIHRoZSBvdXRlciBlZGdlIG9mIHRoZSBzbHVtcyBhbmQgb24gdGhlIGlubmVyIGVkZ2Ugb2YgdGhlIHJpbmcgb2Ygd2VsbC1rZXB0IGFwYXJ0bWVudCBob3VzZXMgYW5kIFxcXCJ3b3JraW5nbWVuJ3MgaG9tZXMuXFxcIiBCZXlvbmQgdGhlbSB3YXMgdGhlIFxcXCJQcm9taXNlZCBMYW5kXFxcIiBvZiByZXNpZGVudGlhbCBob3RlbHMgYW5kIHNpbmdsZS1mYW1pbHkgaG9tZXMuICBJbiBjb250cmFzdCB0byB0aGUgc3dhcnRoeSwgY29uZ2VzdGVkIHNsdW1zLCB0aGVzZSB3ZXJlIFxcXCJicmlnaHQgbGlnaHQgYXJlYXNcXFwiIHNhZmVseSBwcm90ZWN0ZWQgYnkgcmVzdHJpY3RpdmUgY292ZW5hbnRzIGFuZCBoaWdoIHByaWNlIHBvaW50cy48L3A+XCIsXG5cdFx0XHRcIjxwPkJ1cmdlc3MncyBtb2RlbCwgaW4gYWRkaXRpb24gdG8gcmVmbGVjdGluZyB0aGUgaG9tZXMgb2YgcmVhbCBlc3RhdGUgaW52ZXN0b3IgY29tbXVuaXRpZXMsIHNlcnZlZCBhcyBhbiBleHRlbnNpb24gb2Ygd2lkZXIgc2VncmVnYXRpb25pc3QgdGhpbmtpbmcgZHJpdmluZyBib3RoIHNvY2lvbG9neSBhcyBhIGRpc2NpcGxpbmUgYW5kIGFkbWluaXN0cmF0aXZlIHByYWN0aWNlIGR1cmluZyB0aGUgcHJvZ3Jlc3NpdmUgZXJhLiAgT2JzZXNzaW9uIHdpdGggY2l0aWVzIGFzIFxcXCJvcmdhbmlzbXNcXFwiIG9mIHNvY2lldHksIHRoZXkgYmVsaWV2ZWQgaW4gd2hhdCB0aGUgc29jaW9sb2dpc3QgTG91aXMgV2lydGggYmVuaWdubHkgZGVzY3JpYmVkIGFzIHRoZSBcXFwiZXVnZW5pY3Mgb2YgdGhlIGNpdHkuXFxcIjwvcD5cIixcblx0XHRcdFwiPHA+TWFueSBvZiB0aGUgSE9MQyBtYXBzIHJlZmxlY3RlZCBib3RoIHRoZSBjYXRlZ29yaWNhbCBpbXB1bHNlIGFuZCBzcGF0aWFsIG9yZ2FuaXphdGlvbiBvZiBCdXJnZXNzIG1vZGVsIHdpdGggRCBhbmQgQyBuZWlnaGJvcmhvb2RzIG1vcmUgbGlrZWx5IHRvIGJlIGxvY2F0ZWQgYXJvdW5kIGNlbnRyYWwgYnVzaW5lc3MgZGlzdHJpY3RzIGFuZCBBIGFuZCBCIG5laWdoYm9yaG9vZHMgaW4gaW5jcmVhc2luZ2x5IHN1YnVyYmFuIHBlcmlwaGVyaWVzLiBUaGUgZGlhZ3JhbSB2aXN1YWxpemVzIHRoZSByZWxhdGl2ZSBkaXN0cmlidXRpb24gb2YgSE9MQyBncmFkZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNlbnRlciBvZiB0aGUgY2l0eS4gVGhlIG9wYWNpdHkgb2YgdGhlIHJpbmdzIHJlZmxlY3RzIHRoZSByZWxhdGl2ZSBkZW5zaXR5IG9mIHpvbmVkIGFyZWFzIG9uIHRoZSBtYXAuIEhvdmVyaW5nIG92ZXIgdGhlIHJpbmdzIHdpbGwgaGlnaGxpZ2h0IGFyZWFzIGZvciB0aGF0IGdyYWRlLjwvcD5cIlxuXHRcdF1cblx0fSxcblxuXHRzZXRTaG93OiBmdW5jdGlvbiAoc3ViamVjdCkge1xuXHRcdHRoaXMuZGF0YS5tb2RhbCA9IHtcblx0XHRcdG9wZW46IChzdWJqZWN0ICE9PSBudWxsKSxcblx0XHRcdHN1YmplY3Q6IHN1YmplY3Rcblx0XHR9XG5cdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdH0sXG5cblx0Z2V0TW9kYWxDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGF0YS5tb2RhbC5vcGVuKSA/IHRoaXMucGFyc2VNb2RhbENvcHkodGhpcy5kYXRhW3RoaXMuZGF0YS5tb2RhbC5zdWJqZWN0XSkgOiBudWxsO1xuXHR9LFxuXG5cdG1haW5Nb2RhbElzT3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5tb2RhbC5vcGVuO1xuXHR9LFxuXG5cdHBhcnNlTW9kYWxDb3B5IChyYXdDb250ZW50KSB7XG5cdFx0bGV0IG1vZGFsQ29weSA9ICcnO1xuXG5cdFx0dHJ5IHtcblx0XHRcdG1vZGFsQ29weSA9IHJhd0NvbnRlbnQuam9pbignXFxuJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUud2FybignRXJyb3IgcGFyc2luZyBtb2RhbCBjb3B5OiAnKTtcblx0XHRcdG1vZGFsQ29weSA9ICdFcnJvciBwYXJzaW5nIG1vZGFsIGNvcHkuJztcblx0XHR9XG5cblx0XHQvLyBSZWFjdCByZXF1aXJlcyB0aGlzIGZvcm1hdCB0byByZW5kZXIgYSBzdHJpbmcgYXMgSFRNTCxcblx0XHQvLyB2aWEgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuXG5cdFx0cmV0dXJuIHtcblx0XHRcdF9faHRtbDogbW9kYWxDb3B5XG5cdFx0fTtcblx0fVxuXG59XG5cbi8vIE1peGluIEV2ZW50RW1pdHRlciBmdW5jdGlvbmFsaXR5XG5PYmplY3QuYXNzaWduKFRleHRzU3RvcmUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBSZWdpc3RlciBjYWxsYmFjayB0byBoYW5kbGUgYWxsIHVwZGF0ZXNcbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoKGFjdGlvbikgPT4ge1xuXG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuXHRcdGNhc2UgQXBwQWN0aW9uVHlwZXMub25Nb2RhbENsaWNrOlxuXHRcdFx0VGV4dHNTdG9yZS5zZXRTaG93KGFjdGlvbi5zdWJqZWN0KTtcblx0XHRcdGJyZWFrO1xuXG5cdH1cblx0cmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dHNTdG9yZTsiLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IEFwcERpc3BhdGNoZXIgZnJvbSAnLi4vdXRpbHMvQXBwRGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBBcHBBY3Rpb25UeXBlcyB9IGZyb20gJy4uL3V0aWxzL0FwcEFjdGlvbkNyZWF0b3InO1xuaW1wb3J0IENhcnRvREJMb2FkZXIgZnJvbSAnLi4vdXRpbHMvQ2FydG9EQkxvYWRlcic7XG5cbmNvbnN0IFVzZXJMb2NhdGlvblN0b3JlID0ge1xuXG5cdGRhdGE6IHtcblx0XHRsYXRMbmc6IG51bGwsXG5cdFx0YWRJZDogbnVsbCxcblx0XHRjaXR5OiBudWxsLFxuXHRcdG5laWdoYm9yaG9vZDogbnVsbCxcblx0XHRvZmZlclpvb21UbzogZmFsc2Vcblx0fSxcblxuXHRkYXRhTG9hZGVyOiBDYXJ0b0RCTG9hZGVyLFxuXG5cdGxvYWREYXRhOiBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHR0aGlzLmRhdGEubGF0TG5nID0gcG9pbnQ7XG5cblx0XHR0aGlzLmRhdGFMb2FkZXIucXVlcnkoW1xuXHRcdFx0e1xuXHRcdFx0XHRxdWVyeTogJ1NFTEVDVCBhZF9pZCwgY2l0eSwgU1RfZGlzdGFuY2UoU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoaG9sY19tYXBzLmxvb3BsbmcsIGhvbGNfbWFwcy5sb29wbGF0KSw0MzI2KSwgU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoJyArIHBvaW50WzFdICsnLCAnICsgcG9pbnRbMF0gKyAnKSw0MzI2KSkgYXMgZGlzdGFuY2UsIHN0X3htaW4oIHN0X2VudmVsb3BlKHN0X2NvbGxlY3QoU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoJyArIHBvaW50WzFdICsnLCAnICsgcG9pbnRbMF0gKyAnKSw0MzI2KSwgaG9sY19tYXBzLnRoZV9nZW9tKSkpIGFzIGJieG1pbiwgc3RfeG1heCggc3RfZW52ZWxvcGUoc3RfY29sbGVjdChTVF9zZXRzcmlkKFNUX01ha2VQb2ludCgnICsgcG9pbnRbMV0gKycsICcgKyBwb2ludFswXSArICcpLDQzMjYpLCBob2xjX21hcHMudGhlX2dlb20pKSkgYXMgYmJ4bWF4LCBzdF95bWluKCBzdF9lbnZlbG9wZShzdF9jb2xsZWN0KFNUX3NldHNyaWQoU1RfTWFrZVBvaW50KCcgKyBwb2ludFsxXSArJywgJyArIHBvaW50WzBdICsgJyksNDMyNiksIGhvbGNfbWFwcy50aGVfZ2VvbSkpKSBhcyBiYnltaW4sIHN0X3ltYXgoIHN0X2VudmVsb3BlKHN0X2NvbGxlY3QoU1Rfc2V0c3JpZChTVF9NYWtlUG9pbnQoJyArIHBvaW50WzFdICsnLCAnICsgcG9pbnRbMF0gKyAnKSw0MzI2KSwgaG9sY19tYXBzLnRoZV9nZW9tKSkpIGFzIGJieW1heCBmcm9tIGhvbGNfbWFwcyBqb2luIGhvbGNfbWFwc19hZHNfam9pbiBvbiBob2xjX21hcHMubWFwX2lkID0gaG9sY19tYXBzX2Fkc19qb2luLm1hcF9pZCBqb2luIGhvbGNfYWRzIG9uIGhvbGNfYWRzLmlkID0gaG9sY19tYXBzX2Fkc19qb2luLmFkX2lkIG9yZGVyIGJ5IGRpc3RhbmNlIGxpbWl0IDEnLFxuXHRcdFx0XHRmb3JtYXQ6ICdKU09OJ1xuXHRcdFx0fVxuXHRcdF0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHR0aGlzLmRhdGEuY2l0eSA9IHJlc3BvbnNlWzBdWzBdLmNpdHk7XG5cdFx0XHR0aGlzLmRhdGEuYWRJZCA9IHJlc3BvbnNlWzBdWzBdLmFkX2lkO1xuXHRcdFx0dGhpcy5kYXRhLm9mZmVyWm9vbVRvID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5lbWl0KEFwcEFjdGlvblR5cGVzLnN0b3JlQ2hhbmdlZCk7XG5cdFx0fSwgKGVycm9yKSA9PiB7XG5cdFx0XHQvLyBUT0RPOiBoYW5kbGUgdGhpcy5cblx0XHRcdGNvbnNvbGUubG9nKCdMb2NhdGlvbiByZWNlaXZlZCBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9KTtcblxuXHR9LFxuXG5cdHNldE9mZmVyWm9vbVRvOiBmdW5jdGlvbiAodHJ1ZU9yRmFsc2UpIHtcblx0XHR0aGlzLmRhdGEub2ZmZXJab29tVG8gPSB0cnVlT3JGYWxzZTtcblx0XHR0aGlzLmVtaXQoQXBwQWN0aW9uVHlwZXMuc3RvcmVDaGFuZ2VkKTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sYXRMbmc7XG5cdH0sXG5cblx0Z2V0QWRJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hZElkO1xuXHR9LFxuXG5cdGdldENpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuY2l0eTtcblx0fSxcblxuXHRnZXROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEubmVpZ2hib3Job29kO1xuXHR9LFxuXG5cdGdldE9mZmVyWm9vbVRvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLm9mZmVyWm9vbVRvO1xuXHR9LFxufVxuXG4vLyBNaXhpbiBFdmVudEVtaXR0ZXIgZnVuY3Rpb25hbGl0eVxuT2JqZWN0LmFzc2lnbihVc2VyTG9jYXRpb25TdG9yZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIGhhbmRsZSBhbGwgdXBkYXRlc1xuQXBwRGlzcGF0Y2hlci5yZWdpc3RlcigoYWN0aW9uKSA9PiB7XG5cblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy51c2VyTG9jYXRlZDpcblx0XHRcdGlmIChhY3Rpb24ucG9pbnQpIHtcblx0XHRcdFx0VXNlckxvY2F0aW9uU3RvcmUubG9hZERhdGEoYWN0aW9uLnBvaW50KTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBBcHBBY3Rpb25UeXBlcy51c2VyUmVzcG9uZGVkVG9ab29tT2ZmZXI6XG5cdFx0XHRVc2VyTG9jYXRpb25TdG9yZS5zZXRPZmZlclpvb21UbyhmYWxzZSk7XG5cdFx0XHRicmVhaztcblxuXHR9XG5cdHJldHVybiB0cnVlO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFVzZXJMb2NhdGlvblN0b3JlOyIsImltcG9ydCBBcHBEaXNwYXRjaGVyIGZyb20gJy4vQXBwRGlzcGF0Y2hlcic7XG5pbXBvcnQgUmFzdGVyU3RvcmUgZnJvbSAnLi4vc3RvcmVzL1Jhc3RlclN0b3JlJztcblxuZXhwb3J0IGNvbnN0IEFwcEFjdGlvblR5cGVzID0ge1xuXG5cdC8vIE5vdGU6IHN0b3JlcyBlbWl0IHRoaXMgdHlwZSBvZiBldmVudC5cblx0Ly8gVGhvdWdoIGl0IGlzIG5vdCBhY3R1YWxseSBhbiBBY3Rpb24gdHlwZTtcblx0Ly8gaXQncyBlbnVtZXJhdGVkIGhlcmUgZm9yIGVhc2Ugb2YgYWNjZXNzLlxuXHRzdG9yZUNoYW5nZWQ6ICdzdG9yZUNoYW5nZWQnLFxuXG5cdEFEQ2F0ZWdvcnlTZWxlY3RlZDogJ0FEQ2F0ZWdvcnlTZWxlY3RlZCcsXG5cdGxvYWRJbml0aWFsRGF0YTogJ2xvYWRJbml0aWFsRGF0YScsXG5cdGluaXRpYWxEYXRhTG9hZGVkOiAnaW5pdGlhbERhdGFMb2FkZWQnLFxuXHRnZXRJbml0aWFsRGF0YTogJ2dldEluaXRpYWxEYXRhJyxcblx0Y2l0eVNlbGVjdGVkOiAnY2l0eVNlbGVjdGVkJyxcblx0Z3JhZGVTZWxlY3RlZDogJ2dyYWRlU2VsZWN0ZWQnLFxuXHRuZWlnaGJvcmhvb2RIaWdobGlnaHRlZDogJ25laWdoYm9yaG9vZEhpZ2hsaWdodGVkJyxcblx0bmVpZ2hib3Job29kU2VsZWN0ZWQ6ICduZWlnaGJvcmhvb2RTZWxlY3RlZCcsXG5cdHJpbmdHcmFkZVNlbGVjdGVkOiAncmluZ0dyYWRlU2VsZWN0ZWQnLFxuXHRtYXBJbml0aWFsaXplZDogJ21hcEluaXRpYWxpemVkJyxcblx0bWFwTW92ZWQ6ICdtYXBNb3ZlZCcsXG5cdHVzZXJMb2NhdGVkOiAndXNlckxvY2F0ZWQnLFxuXHR1c2VyUmVzcG9uZGVkVG9ab29tT2ZmZXI6ICd1c2VyUmVzcG9uZGVkVG9ab29tT2ZmZXInLFxuXHRvbk1vZGFsQ2xpY2s6ICdvbk1vZGFsQ2xpY2snXG5cbn07XG5cbmV4cG9ydCBjb25zdCBBcHBBY3Rpb25zID0ge1xuXG5cdEFEQ2F0ZWdvcnlTZWxlY3RlZDogKHZhbHVlKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5BRENhdGVnb3J5U2VsZWN0ZWQsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogTG9hZCBkYXRhIG5lZWRlZCBieSB0aGUgYXBwbGljYXRpb24gb24gaW5pdC5cblx0ICovXG5cdGxvYWRJbml0aWFsRGF0YTogKHN0YXRlLCBoYXNoU3RhdGUpID0+IHtcblx0XHQvL2NvbnNvbGUubG9nKGBbMWFdIEEgJyR7IEFwcEFjdGlvblR5cGVzLmxvYWRJbml0aWFsRGF0YSB9JyBldmVudCBpcyBicm9hZGNhc3QgZ2xvYmFsbHkgZnJvbSBBcHBBY3Rpb25DcmVhdG9yLmxvYWRJbml0aWFsRGF0YSgpLmApO1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMubG9hZEluaXRpYWxEYXRhLFxuXHRcdFx0c3RhdGU6IHN0YXRlLFxuXHRcdFx0aGFzaFN0YXRlOiBoYXNoU3RhdGVcblx0XHR9KTtcblx0fSxcblxuXHRpbml0aWFsRGF0YUxvYWRlZDogKHN0YXRlKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5pbml0aWFsRGF0YUxvYWRlZCxcblx0XHRcdHN0YXRlOiBzdGF0ZVxuXHRcdH0pO1xuXHR9LFxuXG5cdGNpdHlTZWxlY3RlZDogKGNpdHksIHNlbGVjdGVkQnlVc2VyID0gZmFsc2UpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLmNpdHlTZWxlY3RlZCxcblx0XHRcdHZhbHVlOiBjaXR5LFxuXHRcdFx0c2VsZWN0ZWRCeVVzZXI6IHRydWVcblx0XHR9KTtcblx0fSxcblxuXHRncmFkZVNlbGVjdGVkOiAoZ3JhZGUpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLmdyYWRlU2VsZWN0ZWQsXG5cdFx0XHR2YWx1ZTogZ3JhZGVcblx0XHR9KTtcblx0fSxcblxuXHRuZWlnaGJvcmhvb2RIaWdobGlnaHRlZDogKGhvbGNJZCwgYWRJZCkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMubmVpZ2hib3Job29kSGlnaGxpZ2h0ZWQsXG5cdFx0XHRob2xjSWQ6IGhvbGNJZFxuXHRcdH0pXG5cdH0sXG5cblx0bmVpZ2hib3Job29kU2VsZWN0ZWQ6IChob2xjSWQsIGFkSWQpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLm5laWdoYm9yaG9vZFNlbGVjdGVkLFxuXHRcdFx0aG9sY0lkOiBob2xjSWQsXG5cdFx0XHRhZElkOiBhZElkXG5cdFx0fSlcblx0fSxcblxuXHRzdGF0ZVNlbGVjdGVkOiAoc3RhdGUpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLnN0YXRlU2VsZWN0ZWQsXG5cdFx0XHR2YWx1ZTogc3RhdGVcblx0XHR9KTtcblx0fSxcblxuXHRyaW5nR3JhZGVTZWxlY3RlZDogKHNlbGVjdGVkUmluZ0dyYWRlKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy5yaW5nR3JhZGVTZWxlY3RlZCxcblx0XHRcdHZhbHVlOiBzZWxlY3RlZFJpbmdHcmFkZVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIG1hcE1vdmVkOiAodmlzaWJsZUFkSWRzLCBiZWxvd0FkVGhyZXNob2xkID0gZmFsc2UpID0+IHtcblx0Ly8gXHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0Ly8gXHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLm1hcE1vdmVkLFxuXHQvLyBcdFx0dmFsdWU6IHZpc2libGVBZElkcyxcblx0Ly8gXHRcdGJlbG93QWRUaHJlc2hvbGQ6IGJlbG93QWRUaHJlc2hvbGRcblx0Ly8gXHR9KVxuXHQvLyB9LFxuXG5cdG9uTW9kYWxDbGljazogKHN1YmplY3QpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLm9uTW9kYWxDbGljayxcblx0XHRcdHN1YmplY3Q6IHN1YmplY3Rcblx0XHR9KVxuXHR9LFxuXG5cdHVzZXJMb2NhdGVkOiAocG9pbnQpID0+IHtcblx0XHRBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcblx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLnVzZXJMb2NhdGVkLFxuXHRcdFx0cG9pbnQ6IHBvaW50XG5cdFx0fSk7XG5cdH0sXG5cblx0dXNlclJlc3BvbmRlZFRvWm9vbU9mZmVyOiAoKSA9PiB7XG5cdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHR0eXBlOiBBcHBBY3Rpb25UeXBlcy51c2VyUmVzcG9uZGVkVG9ab29tT2ZmZXJcblx0XHR9KTtcblx0fSxcblxuXHRtYXBJbml0aWFsaXplZDogKHRoZU1hcCkgPT4ge1xuXHRcdEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuXHRcdFx0dHlwZTogQXBwQWN0aW9uVHlwZXMubWFwSW5pdGlhbGl6ZWQsXG5cdFx0XHR0aGVNYXA6IHRoZU1hcCxcblx0XHRcdHJhc3RlcnM6IFJhc3RlclN0b3JlLmdldEFsbFJhc3RlcnMoKSBcblx0XHR9KTtcblx0fSxcblxuXHRtYXBNb3ZlZDogKHRoZU1hcCkgPT4ge1xuXHRcdC8vIHRoaXMgaGFzIGZpcmVkIHJlcGVhdGVkbHkgd2hlbiBpdCBzaG91bGQgZmlyZSBvbmx5IG9uY2UuXG5cdFx0Ly8gSSB0aGluayB0aGlzIG1pZ2h0IGJlIHJlbGF0ZWQgdG8gcmUtcmVuZGVyaW5nIGhhcHBlbmluZyBcblx0XHQvLyBkdXJpbmcgbGVhZmxldCBhbmltYXRpb24uXG5cdFx0aWYgKCFBcHBEaXNwYXRjaGVyLmlzRGlzcGF0Y2hpbmcoKSkge1xuXHRcdFx0QXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG5cdFx0XHRcdHR5cGU6IEFwcEFjdGlvblR5cGVzLm1hcE1vdmVkLFxuXHRcdFx0XHR0aGVNYXA6IHRoZU1hcCxcblx0XHRcdFx0cmFzdGVyczogUmFzdGVyU3RvcmUuZ2V0QWxsUmFzdGVycygpXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn07XG5cbiIsImltcG9ydCB7IERpc3BhdGNoZXIgfSBmcm9tICdmbHV4JztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IERpc3BhdGNoZXIoKTtcbiIsIi8qXG4gKiBUT0RPOiBNb3ZlIHRoaXMgaW50byBAcGFub3JhbWEvdG9vbGtpdC5cbiAqIFxuICogQ29uc2lkZXIgcHVsbGluZyBjYXJ0b2RiLWNsaWVudCBpbnRvIHRoaXMgYW5kIHBhY2thZ2luZyB0aGUgd2hvbGUgdGhpbmcgYXMgYSBjb21wb25lbnQsXG4gKiBsZWF2aW5nIGBxdWVyeWAgYXMgdGhlIG9ubHkgcHVibGljIG1ldGhvZC5cbiAqIFxuICogQWxzbywgbm90ZSB0aGlzIGlzIHByZXR0eSBzaW1pbGFyIHRvIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2NhcnRvZGIgYWxyZWFkeSA+LjxcbiAqL1xuXG5pbXBvcnQgUXVldWUgZnJvbSAncXVldWUtYXN5bmMnO1xuXG5pbXBvcnQgY29uZmlnIGZyb20gJy4uLy4uL2Jhc2VtYXBzL2NhcnRvZGIvY29uZmlnLmpzb24nO1xuaW1wb3J0IENhcnRvREJDbGllbnQgZnJvbSAnY2FydG9kYi1jbGllbnQnO1xuXG5jb25zdCBjYXJ0b0RCQ2xpZW50ID0gbmV3IENhcnRvREJDbGllbnQoY29uZmlnLnVzZXJJZCk7XG5cbmNvbnN0IENhcnRvREJMb2FkZXIgPSB7XG5cdFxuXHQvKiogVXNlIGBxdWV1ZS1hc3luY2AgdG8gZGVmZXIoKSB1cCBhbiBhcnJheSBvZiBxdWVyaWVzLFxuXHQgKiBhbmQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYWxsIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkLlxuXHQgKiBBY2NlcHRzIGEgbGlzdCBvZiBvYmplY3RzIGZvcm1hdHRlZCBhcyB7IHF1ZXJ5LCBmb3JtYXQgfS5cblx0ICovXG5cdHF1ZXJ5OiBmdW5jdGlvbiAocXVlcnlDb25maWdzKSB7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG5cdFx0XHQvLyBSdW4gdXAgdG8gMyByZXF1ZXN0cyBpbiBwYXJhbGxlbFxuXHRcdFx0bGV0IHF1ZXVlID0gUXVldWUoMyk7XG5cdFx0XHRxdWVyeUNvbmZpZ3MuZm9yRWFjaCgocXVlcnlDb25maWcpID0+IHtcblx0XHRcdFx0cXVldWUuZGVmZXIodGhpcy5yZXF1ZXN0LCBxdWVyeUNvbmZpZyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cXVldWUuYXdhaXRBbGwoKGVycm9yLCAuLi5yZXNwb25zZXMpID0+IHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKC4uLnJlc3BvbnNlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSk7XG5cblx0fSxcblxuXHRyZXF1ZXN0OiBmdW5jdGlvbiAocXVlcnlDb25maWcsIGNhbGxiYWNrKSB7XG5cblx0XHRjYXJ0b0RCQ2xpZW50LnNxbFJlcXVlc3QocXVlcnlDb25maWcucXVlcnksIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcblx0XHRcdGlmICghZXJyKSB7XG5cdFx0XHRcdGxldCBpbm5lclJlc3BvbnNlO1xuXHRcdFx0XHRzd2l0Y2ggKHF1ZXJ5Q29uZmlnLmZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZ2VvanNvbic6XG5cdFx0XHRcdFx0XHRpbm5lclJlc3BvbnNlID0gcmVzcG9uc2UuZmVhdHVyZXM7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0aW5uZXJSZXNwb25zZSA9IHJlc3BvbnNlLnJvd3M7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCBpbm5lclJlc3BvbnNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0J2Zvcm1hdCc6IHF1ZXJ5Q29uZmlnLmZvcm1hdCxcblx0XHRcdCdkYW5nZXJvdXNseUV4cG9zZWRBUElLZXknOiBjb25maWcuYXBpS2V5XG5cdFx0fSk7XG5cblx0fVxuXHRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhcnRvREJMb2FkZXI7XG4iXX0=
